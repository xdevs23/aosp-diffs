```diff
diff --git a/.devcontainer/Dockerfile b/.devcontainer/Dockerfile
new file mode 100644
index 000000000..24a2d0d57
--- /dev/null
+++ b/.devcontainer/Dockerfile
@@ -0,0 +1,58 @@
+# Modified from https://github.com/iwahjoedi/android-devcontainer/blob/main/Image/Dockerfile
+ARG VARIENT="ubuntu-22.04"
+FROM mcr.microsoft.com/vscode/devcontainers/base:0-${VARIENT}
+
+ENV DEVCONTAINER="true"
+
+RUN apt clean && apt-get update && export DEBIAN_FRONTEND=noninteractive \
+    && apt-get -y upgrade \
+    && apt-get -y install git \
+    && apt-get -y install clang cmake ninja-build pkg-config \
+    && apt-get -y install wget unzip \
+    && apt-get -y install openjdk-17-jdk \
+    && apt-get clean -y \
+    && rm -rf /var/lib/apt/lists/*
+
+ARG USERNAME=vscode
+
+USER $USERNAME
+
+RUN export HOME="/home/$USERNAME"
+ARG HOME="/home/$USERNAME"
+ENV ANDROID_HOME=/home/$USERNAME/Android/Sdk
+ENV ANDROID_SDK_ROOT=/home/$USERNAME/Android/Sdk
+ENV CMDLINE_HOME="${HOME}/Android/Sdk/cmdline-tools"
+ENV CMDLINE="${HOME}/Android/Sdk/cmdline-tools/cmdline-tools/bin"
+ENV ANDROID_SDK_ZIP_FILE_VERSION=11076708
+
+# setup flutter sdk
+ENV PATH=${PATH}:${ANDROID_HOME}/platform-tools
+ENV PATH=${PATH}:${ANDROID_HOME}/platforms
+ENV PATH=${PATH}:${ANDROID_HOME}/emulators
+ENV PATH=${PATH}:${CMDLINE_HOME}:${CMDLINE}
+
+RUN ls -la ~ && whoami && mkdir -pv ${CMDLINE_HOME} && cd ${CMDLINE_HOME} \
+    && wget https://dl.google.com/android/repository/commandlinetools-linux-${ANDROID_SDK_ZIP_FILE_VERSION}_latest.zip \
+    && unzip commandlinetools-linux-${ANDROID_SDK_ZIP_FILE_VERSION}_latest.zip \
+    && rm commandlinetools-linux-${ANDROID_SDK_ZIP_FILE_VERSION}_latest.zip
+
+RUN ls -la ${HOME}/ && ls -la ${CMDLINE_HOME} && echo ${CMDLINE_HOME} && chown -Rv $USERNAME:$USERNAME ${HOME}/Android/Sdk
+RUN chmod +r+w+x -Rv ${HOME}/Android/Sdk
+
+RUN yes | sdkmanager --licenses
+RUN yes | sdkmanager --install "build-tools;34.0.0"
+RUN yes | sdkmanager --install "platforms;android-21"
+RUN yes | sdkmanager --install "platforms;android-22"
+RUN yes | sdkmanager --install "platforms;android-23"
+RUN yes | sdkmanager --install "platforms;android-24"
+RUN yes | sdkmanager --install "platforms;android-25"
+RUN yes | sdkmanager --install "platforms;android-26"
+RUN yes | sdkmanager --install "platforms;android-27"
+RUN yes | sdkmanager --install "platforms;android-28"
+RUN yes | sdkmanager --install "platforms;android-29"
+RUN yes | sdkmanager --install "platforms;android-30"
+RUN yes | sdkmanager --install "platforms;android-31"
+RUN yes | sdkmanager --install "platforms;android-32"
+RUN yes | sdkmanager --install "platforms;android-33"
+RUN yes | sdkmanager --install "platforms;android-34"
+RUN yes | sdkmanager --install "platform-tools" "cmdline-tools;latest"
\ No newline at end of file
diff --git a/.devcontainer/README.md b/.devcontainer/README.md
new file mode 100644
index 000000000..15a4769ea
--- /dev/null
+++ b/.devcontainer/README.md
@@ -0,0 +1,33 @@
+# GitHub's Codespaces Configuration
+
+GitHub Codespaces is the vscode-based cloud development environment for GitHub
+projects. We can use [devcontainer][devcontainer-introduction] to configure
+containers for GitHub Codespaces when opening Robolectric project from it.
+
+As Robolectric there are special requirements for Android SDK and `ANDROID_SDK_HOME`
+environment variable for building, Robolectric selects
+[`Dockerfile`][devcontainer-introduction-docker] to configure necessary Android
+environment for itself.
+
+Any contributor can update it based on the demand. When we update `Dockerfile`, we can run
+the following command to build and test it locally:
+
+```shell
+cd .devcontainer
+docker buildx build .
+```
+
+> See [Docker's buildx repository][docker-buildx] to install buildx.
+
+When local testing is passed, we can push it to remote custom branch, and checkout it
+with latest change in GitHub's Codespaces page and then trigger "Rebuild Container" to
+test its configuration in GitHub's Codespaces environment.
+
+If everything goes well, sending the PR and wait the merging.
+
+Because devcontainer is brought by VSCode, this configuration can also be used
+for VSCode.
+
+[devcontainer-introduction]: https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration/introduction-to-dev-containers
+[devcontainer-introduction-docker]: https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration/introduction-to-dev-containers#dockerfile
+[docker-buildx]: https://github.com/docker/buildx
diff --git a/.devcontainer/devcontainer.json b/.devcontainer/devcontainer.json
new file mode 100644
index 000000000..e594b70c9
--- /dev/null
+++ b/.devcontainer/devcontainer.json
@@ -0,0 +1,10 @@
+{
+  "build": {
+    "args": {
+      "VARIENT": "ubuntu-22.04"
+    },
+    "dockerfile": "Dockerfile"
+  },
+  "name": "robolectric-dev",
+  "remoteUser": "vscode"
+}
diff --git a/.github/workflows/check_code_style.yml b/.github/workflows/check_code_style.yml
index 95fc36012..fe2c542e8 100644
--- a/.github/workflows/check_code_style.yml
+++ b/.github/workflows/check_code_style.yml
@@ -35,8 +35,9 @@ jobs:
 
       - name: Download google-java-format
         run: |
-          curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v1.22.0/google-java-format-1.22.0-all-deps.jar
-          curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v1.22.0/scripts/google-java-format-diff.py
+          googleJavaFormatVersion="1.23.0"
+          curl -L -o $HOME/google-java-format.jar https://github.com/google/google-java-format/releases/download/v${googleJavaFormatVersion}/google-java-format-${googleJavaFormatVersion}-all-deps.jar
+          curl -L -o $HOME/google-java-format-diff.py https://raw.githubusercontent.com/google/google-java-format/v${googleJavaFormatVersion}/scripts/google-java-format-diff.py
           chmod +x $HOME/google-java-format-diff.py
 
       - name: Check Java formatting
@@ -44,7 +45,10 @@ jobs:
           base_branch="${{ github.event.pull_request.base.ref }}"
           echo "Running google-java-format-diff against 'origin/$base_branch'"
           git fetch origin "$base_branch" --depth 1
-          diff=$(git diff -U0 $(git merge-base HEAD origin/$base_branch) | $HOME/google-java-format-diff.py --google-java-format-jar=$HOME/google-java-format.jar -p1)
+          diff=$(git diff -U0 $(git merge-base HEAD origin/$base_branch) -- . \
+            ':(exclude)robolectric/src/test/java/org/robolectric/R.java' \
+            ':(exclude)robolectric/src/test/java/org/robolectric/Manifest.java' \
+            | $HOME/google-java-format-diff.py --google-java-format-jar=$HOME/google-java-format.jar -p1)
           if [[ $diff ]]; then
             echo "Please run google-java-format on the changes in this pull request"
             git diff -U0 $(git merge-base HEAD origin/$base_branch) | $HOME/google-java-format-diff.py --google-java-format-jar=$HOME/google-java-format.jar -p1
@@ -52,9 +56,7 @@ jobs:
           fi
 
       - name: Check Kotlin formatting
-        run: |
-          ./gradlew spotlessCheck
+        run: ./gradlew spotlessCheck
 
       - name: Check Kotlin Quality
-        run: |
-          ./gradlew detekt
+        run: ./gradlew detekt
diff --git a/.github/workflows/codeql.yml b/.github/workflows/codeql.yml
index c9f0cb19d..a978c2288 100644
--- a/.github/workflows/codeql.yml
+++ b/.github/workflows/codeql.yml
@@ -15,7 +15,6 @@ on:
   push:
     branches: [ "master" ]
   pull_request:
-    # The branches below must be a subset of the branches above
     branches: [ "master" ]
 
 concurrency:
@@ -24,45 +23,49 @@ concurrency:
 
 jobs:
   analyze:
-    name: Analyze
+    name: Analyze (${{ matrix.language }})
     # Runner size impacts CodeQL analysis time. To learn more, please see:
     #   - https://gh.io/recommended-hardware-resources-for-running-codeql
     #   - https://gh.io/supported-runners-and-hardware-resources
-    #   - https://gh.io/using-larger-runners
-    # Consider using larger runners for possible analysis time improvements.
-    runs-on: ubuntu-22.04
-    timeout-minutes: 360
+    #   - https://gh.io/using-larger-runners (GitHub.com only)
+    # Consider using larger runners or machines with greater resources for possible analysis time improvements.
+    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
+    timeout-minutes: ${{ (matrix.language == 'swift' && 120) || 360 }}
     permissions:
+      # required for all workflows
+      security-events: write
+
+      # required to fetch internal or private CodeQL packs
+      packages: read
+
+      # only required for workflows in private repositories
       actions: read
       contents: read
-      security-events: write
 
     strategy:
       fail-fast: false
       matrix:
-        language: [ 'java-kotlin' ]
-        # CodeQL supports [ 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'swift' ]
-        # Use only 'java-kotlin' to analyze code written in Java, Kotlin or both
-        # Use only 'javascript-typescript' to analyze code written in JavaScript, TypeScript or both
-        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support
-
+        include:
+          - language: java-kotlin
+            build-mode: autobuild
+        # CodeQL supports the following values keywords for 'language': 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'swift'
+        # Use `c-cpp` to analyze code written in C, C++ or both
+        # Use 'java-kotlin' to analyze code written in Java, Kotlin or both
+        # Use 'javascript-typescript' to analyze code written in JavaScript, TypeScript or both
+        # To learn more about changing the languages that are analyzed or customizing the build mode for your analysis,
+        # see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning.
+        # If you are analyzing a compiled language, you can modify the 'build-mode' for that language to customize how
+        # your codebase is analyzed, see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages
     steps:
       - name: Checkout repository
         uses: actions/checkout@v4
 
-      - name: Set up JDK 17
-        uses: actions/setup-java@v4
-        with:
-          distribution: 'adopt'
-          java-version: 17
-
-      - uses: gradle/actions/setup-gradle@v3
-
       # Initializes the CodeQL tools for scanning.
       - name: Initialize CodeQL
         uses: github/codeql-action/init@v3
         with:
           languages: ${{ matrix.language }}
+          build-mode: ${{ matrix.build-mode }}
           # If you wish to specify custom queries, you can do so here or in a config file.
           # By default, queries listed here will override any specified in a config file.
           # Prefix the list here with "+" to use these queries and those in the config file.
@@ -70,12 +73,25 @@ jobs:
           # For more details on CodeQL's query packs, refer to: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
           # queries: security-extended,security-and-quality
 
+      # CodeQL will assemble the project before performing the analysis.
+      # We add this extra step to take advantage of GitHub Actions caches.
+      - uses: gradle/actions/setup-gradle@v4
+
+      # If the analyze step fails for one of the languages you are analyzing with
+      # "We were unable to automatically build your code", modify the matrix above
+      # to set the build mode to "manual" for that language. Then modify this step
+      # to build your code.
       # ‚ÑπÔ∏è Command-line programs to run using the OS shell.
       # üìö See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun
-      - name: Build
+      - if: matrix.build-mode == 'manual'
+        shell: bash
         run: |
-          SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-          ./gradlew assemble testClasses --parallel --stacktrace --no-watch-fs
+          echo 'If you are using a "manual" build mode for one or more of the' \
+            'languages you are analyzing, replace this with the commands to build' \
+            'your code, for example:'
+          echo '  make bootstrap'
+          echo '  make release'
+          exit 1
 
       - name: Perform CodeQL Analysis
         uses: github/codeql-action/analyze@v3
diff --git a/.github/workflows/copybara_build_and_test.yml b/.github/workflows/copybara_build_and_test.yml
index 9428f6f2c..c25b8c089 100644
--- a/.github/workflows/copybara_build_and_test.yml
+++ b/.github/workflows/copybara_build_and_test.yml
@@ -24,7 +24,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Build
         run: |
@@ -41,7 +41,7 @@ jobs:
             -Drobolectric.enabledSdks=34 \
             -Dorg.gradle.workers.max=2 \
             -x :integration_tests:nativegraphics:test \
-            -x :integration_tests:dependency-on-stubs:test \
+            -x :integration_tests:sdkcompat:test \
           )
 
       - name: SdkCompat tests
@@ -49,5 +49,5 @@ jobs:
           # `SdkCompat tests` is run as a separate step because it has to run on all SDK levels, and
           # the `Integration tests` step only runs on a single SDK level.
           SKIP_ERRORPRONE=true SKIP_JAVADOC=true \
-          ./gradlew :integration_tests:dependency-on-stubs:test --info --stacktrace --continue --no-watch-fs \
+          ./gradlew :integration_tests:sdkcompat:test --info --stacktrace --continue --no-watch-fs \
           -Drobolectric.alwaysIncludeVariantMarkersInTestName=true \
diff --git a/.github/workflows/gradle_tasks_validation.yml b/.github/workflows/gradle_tasks_validation.yml
index bca86899f..8d73b8089 100644
--- a/.github/workflows/gradle_tasks_validation.yml
+++ b/.github/workflows/gradle_tasks_validation.yml
@@ -31,7 +31,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Run aggregateDocs
         run: ./gradlew clean aggregateDocs
@@ -54,7 +54,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Run javadocJar
         run: ./gradlew clean javadocJar
@@ -72,7 +72,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Run :preinstrumented:instrumentAll
         run: ./gradlew :preinstrumented:instrumentAll
@@ -95,7 +95,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Publish to Maven local
         run: ./gradlew publishToMavenLocal --no-watch-fs
diff --git a/.github/workflows/gradle_wrapper_validation.yml b/.github/workflows/gradle_wrapper_validation.yml
deleted file mode 100644
index 6789cb12a..000000000
--- a/.github/workflows/gradle_wrapper_validation.yml
+++ /dev/null
@@ -1,27 +0,0 @@
-name: Validate Gradle Wrapper
-
-on:
-  push:
-    branches: [ master, 'robolectric-*.x' ]
-    paths-ignore:
-      - '**.md'
-
-  pull_request:
-    branches: [ master, google ]
-    paths-ignore:
-      - '**.md'
-
-concurrency:
-  group: ${{ github.workflow }}-${{ github.ref }}
-  cancel-in-progress: true
-
-permissions:
-  contents: read
-
-jobs:
-  validation:
-    name: Validation
-    runs-on: ubuntu-22.04
-    steps:
-      - uses: actions/checkout@v4
-      - uses: gradle/actions/wrapper-validation@v3
diff --git a/.github/workflows/graphics_tests.yml b/.github/workflows/graphics_tests.yml
index 64cb44718..3f23e9555 100644
--- a/.github/workflows/graphics_tests.yml
+++ b/.github/workflows/graphics_tests.yml
@@ -20,6 +20,7 @@ permissions:
 jobs:
   graphics_tests:
     strategy:
+      fail-fast: false
       matrix:
         device: [
           macos-13, # Tests Mac x86_64
@@ -38,11 +39,10 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Show runner info
-        run: |
-          uname -a
+        run: uname -a
 
       - name: Run unit tests
         env:
diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 7ae48559e..58af08d6a 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -34,7 +34,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Build
         run: |
@@ -47,7 +47,7 @@ jobs:
     strategy:
       fail-fast: false
       matrix:
-        api-versions: [ '21,34', '22,23,33', '24,25,32', '26,27,28', '29,30,31', ]
+        api-versions: [ '21,22,23', '24,25,26', '27,28,29', '30,31,32', '33,34' ]
 
     steps:
       - uses: actions/checkout@v4
@@ -58,7 +58,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Run unit tests
         run: |
@@ -105,7 +105,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Enable KVM group perms
         run: |
@@ -184,8 +184,7 @@ jobs:
           distribution: 'adopt'
           java-version: 17
 
-      - uses: gradle/actions/setup-gradle@v3
+      - uses: gradle/actions/setup-gradle@v4
 
       - name: Publish
-        run: |
-          ./gradlew publish --stacktrace --no-watch-fs
+        run: ./gradlew publish --stacktrace --no-watch-fs
diff --git a/Android.bp b/Android.bp
index ffbd38a95..4ae45d278 100644
--- a/Android.bp
+++ b/Android.bp
@@ -77,7 +77,7 @@ java_genrule {
     name: "robolectric_framework_res",
     host_supported: true,
     tools: ["zip2zip"],
-    srcs: [":framework-res"],
+    device_common_srcs: [":framework-res"],
     out: ["robolectric_framework_res.jar"],
     cmd: "$(location zip2zip) " +
         "-i $(location :framework-res) " +
@@ -208,6 +208,8 @@ java_library {
         "//frameworks/opt/car/setupwizard/library/main/tests/robotests:__pkg__",
         "//packages/apps/Car/Notification/tests/robotests:__pkg__",
         "//packages/apps/TvSettings/Settings/tests/robotests:__pkg__",
+        "//packages/apps/Car/Settings/tests/deviceless:__subpackages__",
+        "//packages/apps/Car/Settings/tests/multivalent:__subpackages__",
         "//packages/apps/Car/Settings/tests/robotests:__pkg__",
         "//packages/apps/Car/SystemUI:__pkg__",
         "//packages/apps/Settings/tests/robotests:__pkg__",
@@ -269,6 +271,8 @@ java_host_for_device {
         "//packages/apps/Car/Notification/tests/robotests:__pkg__",
         "//packages/apps/Car/Launcher/libs/appgrid/lib/robotests:__pkg__",
         "//packages/apps/Car/Cluster/DirectRenderingCluster/tests/robotests:__pkg__",
+        "//packages/apps/Car/Settings/tests/deviceless:__subpackages__",
+        "//packages/apps/Car/Settings/tests/multivalent:__subpackages__",
         "//packages/apps/Car/Settings/tests/robotests:__pkg__",
         "//packages/apps/Car/SystemUI:__pkg__",
         "//packages/apps/EmergencyInfo/tests/robolectric:__pkg__",
diff --git a/OWNERS b/OWNERS
index e0564f164..77fe20825 100644
--- a/OWNERS
+++ b/OWNERS
@@ -1,5 +1,4 @@
 rexhoffman@google.com
-yuwu@google.com
 congxiliu@google.com
-ramperi@google.com
-ihcinihsdk@google.com
+brettchabot@google.com
+hoisie@google.com
diff --git a/README.md b/README.md
index 541b50a9e..85de2738e 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-<a name="README">[<img src="https://rawgithub.com/robolectric/robolectric/master/images/robolectric-horizontal.png"/>](http://robolectric.org)</a>
+<a name="README">[<img src="https://rawgithub.com/robolectric/robolectric/master/images/robolectric-horizontal.png"/>](https://robolectric.org)</a>
 
 [![Build Status](https://github.com/robolectric/robolectric/actions/workflows/tests.yml/badge.svg)](https://github.com/robolectric/robolectric/actions?query=workflow%3Atests)
 [![GitHub release](https://img.shields.io/github/release/robolectric/robolectric.svg?maxAge=60)](https://github.com/robolectric/robolectric/releases)
@@ -28,65 +28,43 @@ public class MyActivityTest {
 }
 ```
 
-For more information about how to install and use Robolectric on your project, extend its functionality, and join the community of contributors, please visit [http://robolectric.org](http://robolectric.org).
+For more information about how to install and use Robolectric on your project, extend its functionality, and join the community of contributors, please visit [robolectric.org](https://robolectric.org).
 
 ## Install
 
 ### Starting a New Project
 
-If you'd like to start a new project with Robolectric tests you can refer to `deckard` (for either [maven](http://github.com/robolectric/deckard-maven) or [gradle](http://github.com/robolectric/deckard-gradle)) as a guide to setting up both Android and Robolectric on your machine.
+If you'd like to start a new project with Robolectric tests, you can refer to `deckard` (for either [Maven](https://github.com/robolectric/deckard-maven) or [Gradle](https://github.com/robolectric/deckard-gradle)) as a guide to setting up both Android and Robolectric on your machine.
 
-#### build.gradle:
+### `build.gradle`
 
 ```groovy
 testImplementation "junit:junit:4.13.2"
-testImplementation "org.robolectric:robolectric:4.12.2"
+testImplementation "org.robolectric:robolectric:4.13"
 ```
 
-## Building And Contributing
+## Building and Contributing
 
-Robolectric is built using Gradle. Both IntelliJ and Android Studio can import the top-level `build.gradle` file and will automatically generate their project files from it.
+Robolectric is built using Gradle. Both Android Studio and IntelliJ can import the top-level `build.gradle.kts` file and will automatically generate their project files from it.
+
+To get Robolectric up and running on your machine, check out
+[this guide](https://robolectric.org/building-robolectric/).
 
 To get a high-level overview of Robolectric's architecture, check out
 [ARCHITECTURE.md](ARCHITECTURE.md).
 
-### Prerequisites
-
-See [Building Robolectric](http://robolectric.org/building-robolectric/) for more details about setting up a build environment for Robolectric.
-
-### Building
-
-Robolectric supports running tests against multiple Android API levels. To build Robolectric, run:
-
-    ./gradlew clean assemble testClasses --parallel
-
-### Testing
-
-Run tests for all API levels:
-
-> The fully tests could consume more than 16G memory(total of physical and virtual memory).
+## Using Snapshots
 
-    ./gradlew test --parallel
+If you would like to live on the bleeding edge, you can try running against a snapshot build. Keep in mind that snapshots represent the most recent changes on the `master` and may contain bugs.
 
-Run tests for part of supported API levels, e.g. run tests for API level 26, 27, 28:
-
-    ./gradlew test --parallel "-Drobolectric.enabledSdks=26,27,28"
-
-Run compatibility test suites on opening Emulator:
-
-    ./gradlew connectedCheck
-
-### Using Snapshots
-
-If you would like to live on the bleeding edge, you can try running against a snapshot build. Keep in mind that snapshots represent the most recent changes on master and may contain bugs.
-
-#### build.gradle:
+### `build.gradle`
 
 ```groovy
 repositories {
     maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
 }
+
 dependencies {
-    testImplementation "org.robolectric:robolectric:4.13-SNAPSHOT"
+    testImplementation "org.robolectric:robolectric:4.14-SNAPSHOT"
 }
 ```
diff --git a/annotations/build.gradle b/annotations/build.gradle
deleted file mode 100644
index 7255f1106..000000000
--- a/annotations/build.gradle
+++ /dev/null
@@ -1,15 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    compileOnly libs.findbugs.jsr305
-    compileOnly libs.javax.annotation.api
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.truth
-    testImplementation libs.junit4
-    testImplementation libs.javax.annotation.api
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates // compile against latest Android SDK
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates // run against whatever this JDK supports
-}
diff --git a/annotations/build.gradle.kts b/annotations/build.gradle.kts
new file mode 100644
index 000000000..5af87897f
--- /dev/null
+++ b/annotations/build.gradle.kts
@@ -0,0 +1,14 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  compileOnly(libs.findbugs.jsr305)
+  compileOnly(libs.javax.annotation.api)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.truth)
+  testImplementation(libs.junit4)
+  testImplementation(libs.javax.annotation.api)
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
+}
diff --git a/annotations/src/main/java/org/robolectric/annotation/ClassName.java b/annotations/src/main/java/org/robolectric/annotation/ClassName.java
index 81ac098a5..db7ce1dd4 100644
--- a/annotations/src/main/java/org/robolectric/annotation/ClassName.java
+++ b/annotations/src/main/java/org/robolectric/annotation/ClassName.java
@@ -6,29 +6,34 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 /**
- * Parameters with types that can't be resolved at compile time may be annotated @ClassName.
+ * Parameters, function return with types that can't be resolved at compile time may be annotated
+ * with @ClassName.
  *
  * <p>Use this annotation when creating shadow methods that contain new Android types in the method
- * signature that do not exist in older SDK levels.
+ * signature, return type that do not exist in older SDK levels.
  *
  * <pre>
  * &#64;Implements(FooAndroidClass.class)
  * class ShadowFooAndroidClass {
  *
  *    // A method shadowing FooAndroidClass#setBar(com.android.RealClassName, int, String)
+ *    // Generally, &#64;ClassName will be used together with Object type.
  *    &#64;Implementation
- *    public void setBar(&#64;ClassName("com.android.RealClassName") Object para1, int para2, String para3) {
+ *    public &#64;ClassName("com.android.RealReturnType") Object setBar(
+ *        &#64;ClassName("com.android.RealClassName") Object para1,
+ *        int para2,
+ *        String para3) {
  *
  *    }
  * }
  * </pre>
  */
-@Target(ElementType.PARAMETER)
+@Target({ElementType.TYPE_USE, ElementType.PARAMETER})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface ClassName {
 
   /**
-   * The class name intended for this parameter.
+   * The class name intended for the parameter or the function return value.
    *
    * <p>Use the value as returned from {@link Class#getName()}, not {@link
    * Class#getCanonicalName()}; e.g. {@code Foo$Bar} instead of {@code Foo.Bar}.
diff --git a/annotations/src/main/java/org/robolectric/annotation/Implements.java b/annotations/src/main/java/org/robolectric/annotation/Implements.java
index 84da01ec6..d9e63834a 100644
--- a/annotations/src/main/java/org/robolectric/annotation/Implements.java
+++ b/annotations/src/main/java/org/robolectric/annotation/Implements.java
@@ -50,8 +50,11 @@ public @interface Implements {
    * If true, when an exact method signature match isn't found, Robolectric will look for a method
    * with the same name but with all argument types replaced with java.lang.Object.
    *
+   * @deprecated Use the {@link org.robolectric.annotation.ClassName} annotation or the {@link
+   *     org.robolectric.annotation.Implementation#methodName()} annotation parameter instead.
    * @return True to disable strict signature matching.
    */
+  @Deprecated
   boolean looseSignatures() default false;
 
   /** If specified, the shadow class will be applied only for this SDK or greater. */
diff --git a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
index 16905cb2e..34a467172 100644
--- a/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
+++ b/annotations/src/main/java/org/robolectric/versioning/AndroidVersions.java
@@ -737,15 +737,15 @@ public final class AndroidVersions {
   }
 
   /**
-   * Placeholder for the next InDevelopment SDK after V
+   * Baklava is an InDevelopment SDK after V, the name scheme has wrapped the alphabet.
    *
    * <p>All values here subject to change.
    */
-  public static final class W extends AndroidUnreleased {
+  public static final class Baklava extends AndroidUnreleased {
 
     public static final int SDK_INT = 36;
 
-    public static final String SHORT_CODE = "W";
+    public static final String SHORT_CODE = "Baklava";
 
     public static final String VERSION = "16";
 
diff --git a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
index 57233817a..3dba1dc15 100644
--- a/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
+++ b/annotations/src/test/java/org/robolectric/versioning/AndroidVersionsTest.java
@@ -31,14 +31,14 @@ public final class AndroidVersionsTest {
   }
 
   @Test
-  public void testStandardInitializationW() {
-    assertThat(AndroidVersions.W.SDK_INT).isEqualTo(36);
-    assertThat(AndroidVersions.W.SHORT_CODE).isEqualTo("W");
-    assertThat(AndroidVersions.W.VERSION).isEqualTo("16");
-    assertThat(new AndroidVersions.W().getSdkInt()).isEqualTo(36);
-    assertThat(new AndroidVersions.W().getShortCode()).isEqualTo("W");
-    assertThat(new AndroidVersions.W().getVersion()).isEqualTo("16");
-    assertThat(new AndroidVersions.W().isReleased()).isFalse();
+  public void testStandardInitializationBaklava() {
+    assertThat(AndroidVersions.Baklava.SDK_INT).isEqualTo(36);
+    assertThat(AndroidVersions.Baklava.SHORT_CODE).isEqualTo("Baklava");
+    assertThat(AndroidVersions.Baklava.VERSION).isEqualTo("16");
+    assertThat(new AndroidVersions.Baklava().getSdkInt()).isEqualTo(36);
+    assertThat(new AndroidVersions.Baklava().getShortCode()).isEqualTo("Baklava");
+    assertThat(new AndroidVersions.Baklava().getVersion()).isEqualTo("16");
+    assertThat(new AndroidVersions.Baklava().isReleased()).isFalse();
   }
 
   @Test
diff --git a/build.gradle b/build.gradle
deleted file mode 100644
index dce14a224..000000000
--- a/build.gradle
+++ /dev/null
@@ -1,192 +0,0 @@
-import org.gradle.plugins.ide.idea.model.IdeaModel
-import org.robolectric.gradle.ShadowsPlugin
-
-buildscript {
-    apply from: 'dependencies.gradle'
-
-    repositories {
-        google()
-        mavenCentral()
-        gradlePluginPortal()
-    }
-}
-
-plugins {
-    alias(libs.plugins.android.library) apply false
-    alias(libs.plugins.detekt) apply false
-    alias(libs.plugins.error.prone)
-    alias(libs.plugins.idea)
-    alias(libs.plugins.kotlin.android) apply false
-    alias(libs.plugins.kotlin.jvm) apply false
-    alias(libs.plugins.robolectric.spotless)
-    alias(libs.plugins.robolectric.javadoc)
-    alias(libs.plugins.roborazzi) apply false
-    alias(libs.plugins.spotless) apply false
-}
-
-allprojects {
-    group = "org.robolectric"
-    version = thisVersion
-}
-
-project.ext.configAnnotationProcessing = []
-project.afterEvaluate {
-    def ideaProject = rootProject.extensions.getByType(IdeaModel).project
-    ideaProject.ipr.withXml { provider ->
-        def compilerConfiguration = provider.asNode().component.find { it.'@name' == 'CompilerConfiguration' }
-
-        // prevent compiler from complaining about duplicate classes...
-        def excludeFromCompile = compilerConfiguration.appendNode 'excludeFromCompile'
-        configAnnotationProcessing.each { Project subProject ->
-            def buildDirectory = subProject.layout.buildDirectory.get().asFile
-            excludeFromCompile.appendNode('directory',
-                    [url: "file://$buildDirectory/classes/java/main/generated", includeSubdirectories: "true"])
-        }
-
-        // replace existing annotationProcessing tag with a new one...
-        compilerConfiguration.annotationProcessing.replaceNode {
-            annotationProcessing {
-                configAnnotationProcessing.each { Project subProject ->
-                    profile(name: "${subProject.name}_main", enabled: "true") {
-                        module(name: "${subProject.name}_main")
-                        option(name: "org.robolectric.annotation.processing.shadowPackage",
-                                value: subProject.shadows.packageName)
-                        processor(name: "org.robolectric.annotation.processing.RobolectricProcessor")
-
-                        processorPath(useClasspath: "false") {
-                            project.project(":processor")
-                                    .configurations.named("runtime")
-                                    .configure { runtimeConfiguration ->
-                                        runtimeConfiguration.allArtifacts.each { artifact ->
-                                            entry(name: artifact.file)
-                                        }
-                                        runtimeConfiguration.files.each { file ->
-                                            entry(name: file)
-                                        }
-                                    }
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-
-rootProject.gradle.projectsEvaluated {
-    rootProject.tasks.named("aggregateJavadocs").configure {
-        it.failOnError = false
-    }
-}
-
-gradle.projectsEvaluated {
-    def headerHtml = "<ul class=\"navList\" style=\"font-size: 1.5em;\"><li>Robolectric $thisVersion |" +
-            " <a href=\"/\" target=\"_top\">" +
-            "<img src=\"http://robolectric.org/images/logo-with-bubbles-down.png\"" +
-            " style=\"max-height: 18pt; vertical-align: sub;\"/></a></li></ul>"
-    project.allprojects { p ->
-        p.tasks.withType(Javadoc) {
-            options {
-                noTimestamp = true
-                links = [
-                        "https://docs.oracle.com/javase/8/docs/api/",
-                        "https://developer.android.com/reference/",
-                ]
-                // Set javadoc source to JDK 8 to avoid unnamed module problem
-                // when running aggregateJavadoc with OpenJDK 13+.
-                source("8")
-                header = headerHtml
-                footer = headerHtml
-                // bottom = "<link rel=\"stylesheet\" href=\"http://robolectric.org/assets/css/main.css\">"
-                version = thisVersion
-            }
-        }
-    }
-}
-
-gradle.projectsEvaluated {
-    tasks.register('aggregateJsondocs', Copy) {
-        project.subprojects.findAll { it.plugins.hasPlugin(ShadowsPlugin) }.each { subproject ->
-            dependsOn subproject.tasks.named("compileJava")
-            from subproject.layout.buildDirectory.dir("docs/json")
-        }
-        into layout.buildDirectory.dir("docs/json")
-    }
-}
-
-tasks.register('aggregateDocs') {
-    dependsOn ':aggregateJavadocs'
-    dependsOn ':aggregateJsondocs'
-}
-
-tasks.register('prefetchSdks') {
-    AndroidSdk.ALL_SDKS.each { androidSdk ->
-        doLast {
-            println("Prefetching ${androidSdk.coordinates}...")
-            // prefetch into maven local repo...
-            def mvnCommand = "mvn -q dependency:get -DrepoUrl=http://maven.google.com \
-                -DgroupId=${androidSdk.groupId} -DartifactId=${androidSdk.artifactId} \
-                -Dversion=${androidSdk.version}"
-            shellExec(mvnCommand)
-
-            // prefetch into gradle local cache...
-            def config = configurations.create("sdk${androidSdk.apiLevel}")
-            dependencies.add("sdk${androidSdk.apiLevel}", androidSdk.coordinates)
-            // causes dependencies to be resolved:
-            config.files
-        }
-    }
-}
-
-tasks.register('prefetchInstrumentedSdks') {
-    AndroidSdk.ALL_SDKS.each { androidSdk ->
-        doLast {
-            println("Prefetching ${androidSdk.preinstrumentedCoordinates}...")
-            // prefetch into maven local repo...
-            def mvnCommand = "mvn -q dependency:get -DrepoUrl=http://maven.google.com \
-                -DgroupId=${androidSdk.groupId} -DartifactId=${androidSdk.preinstrumentedArtifactId} \
-                -Dversion=${androidSdk.preinstrumentedVersion}"
-            shellExec(mvnCommand)
-
-            // prefetch into gradle local cache...
-            def config = configurations.create("sdk${androidSdk.apiLevel}")
-            dependencies.add("sdk${androidSdk.apiLevel}", androidSdk.preinstrumentedCoordinates)
-            // causes dependencies to be resolved:
-            config.files
-        }
-    }
-}
-
-private void shellExec(String mvnCommand) {
-    def process = mvnCommand.execute()
-    def out = new StringBuffer()
-    def err = new StringBuffer()
-    process.consumeProcessOutput(out, err)
-    process.waitFor()
-    if (out.size() > 0) println out
-    if (err.size() > 0) println err
-    if (process.exitValue() != 0) System.exit(1)
-}
-
-tasks.register('prefetchDependencies') {
-    doLast {
-        allprojects.each { p ->
-            p.configurations.each { config ->
-                // causes dependencies to be resolved:
-                if (config.isCanBeResolved()) {
-                    try {
-                        config.files
-                    } catch (ResolveException e) {
-                        // ignore resolution issues for integration tests and test app, sigh
-                        if (!p.path.startsWith(":integration_tests:")
-                                && !p.path.startsWith(":testapp")) {
-                            throw e
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-
-// for use of external initialization scripts...
-project.ext.allSdks = AndroidSdk.ALL_SDKS
diff --git a/build.gradle.kts b/build.gradle.kts
new file mode 100644
index 000000000..12e1ab362
--- /dev/null
+++ b/build.gradle.kts
@@ -0,0 +1,222 @@
+import groovy.util.Node
+import org.gradle.plugins.ide.idea.model.IdeaModel
+import org.robolectric.gradle.ShadowsPlugin.ShadowsPluginExtension
+
+// https://github.com/gradle/gradle/issues/21267
+val axtCoreVersion by project.extra { libs.versions.androidx.test.core.get() }
+val axtJunitVersion by project.extra { libs.versions.androidx.test.ext.junit.get() }
+val axtMonitorVersion by project.extra { libs.versions.androidx.test.monitor.get() }
+val axtRunnerVersion by project.extra { libs.versions.androidx.test.runner.get() }
+val axtTruthVersion by project.extra { libs.versions.androidx.test.ext.truth.get() }
+val espressoVersion by project.extra { libs.versions.androidx.test.espresso.get() }
+
+// For use of external initialization scripts...
+val allSdks by project.extra(AndroidSdk.ALL_SDKS)
+val configAnnotationProcessing by project.extra(emptyList<Project>())
+
+val thisVersion: String by project
+
+plugins {
+  alias(libs.plugins.android.library) apply false
+  alias(libs.plugins.detekt) apply false
+  alias(libs.plugins.error.prone)
+  alias(libs.plugins.idea)
+  alias(libs.plugins.kotlin.android) apply false
+  alias(libs.plugins.kotlin.jvm) apply false
+  alias(libs.plugins.robolectric.spotless)
+  alias(libs.plugins.robolectric.javadoc)
+  alias(libs.plugins.roborazzi) apply false
+}
+
+allprojects {
+  group = "org.robolectric"
+  version = thisVersion
+}
+
+project.afterEvaluate {
+  val ideaProject = rootProject.extensions.getByType<IdeaModel>().project
+  ideaProject.ipr.withXml {
+    val compilerConfiguration =
+      asNode().children().filterIsInstance<Node>().first {
+        it.name() == "component" && it.attribute("name") == "CompilerConfiguration"
+      }
+
+    // Prevent compiler from complaining about duplicate classes...
+    val excludeFromCompile = compilerConfiguration.appendNode("excludeFromCompile")
+    configAnnotationProcessing.forEach { subproject ->
+      val buildDirectory = subproject.layout.buildDirectory.get().asFile
+      excludeFromCompile.appendNode(
+        "directory",
+        mapOf(
+          "url" to "file://$buildDirectory/classes/java/main/generated",
+          "includeSubdirectories" to "true",
+        ),
+      )
+    }
+
+    // Replace the existing "annotationProcessing" tag with a new one...
+    val annotationProcessingNode = Node(compilerConfiguration, "annotationProcessing")
+    configAnnotationProcessing.forEach { subproject ->
+      val profileNode =
+        Node(
+          annotationProcessingNode,
+          "profile",
+          mapOf("name" to "${subproject.name}_main", "enabled" to "true"),
+        )
+      profileNode.appendNode("module", mapOf("name" to "${subproject.name}_main"))
+      profileNode.appendNode(
+        "option",
+        mapOf(
+          "name" to "org.robolectric.annotation.processing.shadowPackage",
+          "value" to project.extensions.getByType<ShadowsPluginExtension>().packageName,
+        ),
+      )
+      profileNode.appendNode(
+        "processor",
+        mapOf("name" to "org.robolectric.annotation.processing.RobolectricProcessor"),
+      )
+
+      val processorPathNode = Node(profileNode, "processorPath", mapOf("useClasspath" to "false"))
+      project.project(":processor").configurations.named("runtime").configure {
+        allArtifacts.forEach { artifact ->
+          processorPathNode.appendNode("entry", mapOf("name" to artifact.file))
+        }
+        files.forEach { file -> processorPathNode.appendNode("entry", mapOf("name" to file)) }
+      }
+
+      profileNode.appendNode(processorPathNode)
+      annotationProcessingNode.appendNode(profileNode)
+    }
+
+    compilerConfiguration.replaceNode(annotationProcessingNode)
+  }
+}
+
+rootProject.gradle.projectsEvaluated {
+  rootProject.tasks.named<Javadoc>("aggregateJavadocs").configure { isFailOnError = false }
+}
+
+gradle.projectsEvaluated {
+  val headerHtml =
+    """
+    <ul class="navList" style="font-size: 1.5em;">
+      <li>
+        Robolectric $thisVersion |&nbsp;
+        <a href="/" target="_top">
+          <img src="https://robolectric.org/images/logo-with-bubbles-down.png" style="max-height: 18pt; vertical-align: sub;"/>
+        </a>
+      </li>
+    </ul>
+    """
+      .trimIndent()
+
+  project.allprojects {
+    tasks.withType<Javadoc> {
+      options {
+        this as StandardJavadocDocletOptions
+
+        noTimestamp(true)
+        links(
+          "https://docs.oracle.com/javase/8/docs/api/",
+          "https://developer.android.com/reference/",
+        )
+        // Set Javadoc source to JDK 8 to avoid unnamed module problem
+        // when running 'aggregateJavadocs' with OpenJDK 13+.
+        source("8")
+        header = headerHtml
+        footer = headerHtml
+      }
+    }
+  }
+
+  val aggregateJsondocs by
+    tasks.registering(Copy::class) {
+      project.subprojects
+        .filter { it.pluginManager.hasPlugin(libs.plugins.robolectric.shadows.get().pluginId) }
+        .forEach { subproject ->
+          dependsOn(subproject.tasks.named("compileJava"))
+          from(subproject.layout.buildDirectory.dir("docs/json"))
+        }
+
+      into(layout.buildDirectory.dir("docs/json"))
+    }
+}
+
+val aggregateDocs by tasks.registering { dependsOn(":aggregateJavadocs", ":aggregateJsondocs") }
+
+val prefetchSdks by
+  tasks.registering {
+    allSdks.forEach { androidSdk ->
+      doLast {
+        prefetchSdk(
+          apiLevel = androidSdk.apiLevel,
+          coordinates = androidSdk.coordinates,
+          groupId = androidSdk.groupId,
+          artifactId = androidSdk.artifactId,
+          version = androidSdk.version,
+        )
+      }
+    }
+  }
+
+val prefetchInstrumentedSdks by
+  tasks.registering {
+    allSdks.forEach { androidSdk ->
+      doLast {
+        prefetchSdk(
+          apiLevel = androidSdk.apiLevel,
+          coordinates = androidSdk.preinstrumentedCoordinates,
+          groupId = androidSdk.groupId,
+          artifactId = androidSdk.preinstrumentedArtifactId,
+          version = androidSdk.preinstrumentedVersion,
+        )
+      }
+    }
+  }
+
+fun prefetchSdk(
+  apiLevel: Int,
+  coordinates: String,
+  groupId: String,
+  artifactId: String,
+  version: String,
+) {
+  println("Prefetching $coordinates...")
+
+  // Prefetch into Maven local repo...
+  project.exec {
+    val mvnCommand =
+      "mvn -q dependency:get -DrepoUrl=https://maven.google.com " +
+        "-DgroupId=$groupId -DartifactId=$artifactId -Dversion=$version"
+
+    commandLine(mvnCommand.split(" "))
+  }
+
+  // Prefetch into Gradle local cache...
+  val config = configurations.create("sdk$apiLevel")
+  dependencies.add("sdk$apiLevel", coordinates)
+
+  // Causes dependencies to be resolved:
+  config.files
+}
+
+val prefetchDependencies by
+  tasks.registering {
+    doLast {
+      allprojects.forEach { p ->
+        p.configurations.forEach { config ->
+          // Causes dependencies to be resolved:
+          if (config.isCanBeResolved) {
+            try {
+              config.files
+            } catch (e: ResolveException) {
+              // Ignore resolution issues for the ':integration_tests' and ':testapp' projects, sigh
+              if (!p.path.startsWith(":integration_tests:") && !p.path.startsWith(":testapp")) {
+                throw e
+              }
+            }
+          } // End config resolution
+        } // End configurations
+      } // End allprojects
+    } // End doLast
+  } // End task registration
diff --git a/buildSrc/build.gradle b/buildSrc/build.gradle
deleted file mode 100644
index 655e792bc..000000000
--- a/buildSrc/build.gradle
+++ /dev/null
@@ -1,57 +0,0 @@
-plugins {
-    alias(libs.plugins.groovy)
-    alias(libs.plugins.java.gradle.plugin)
-    alias(libs.plugins.java.library)
-}
-
-gradlePlugin {
-    plugins {
-        AarDepsPlugin {
-            id = "org.robolectric.gradle.AarDepsPlugin"
-            implementationClass = "org.robolectric.gradle.AarDepsPlugin"
-        }
-        AndrodiProjectConfigPlugin {
-            id = "org.robolectric.gradle.AndroidProjectConfigPlugin"
-            implementationClass = "org.robolectric.gradle.AndroidProjectConfigPlugin"
-        }
-        DeployedRoboJavaModulePlugin {
-            id = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
-            implementationClass = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
-        }
-        GradleManagedDevicePlugin {
-            id = "org.robolectric.gradle.GradleManagedDevicePlugin"
-            implementationClass = "org.robolectric.gradle.GradleManagedDevicePlugin"
-        }
-        RoboJavaModulePlugin {
-            id = "org.robolectric.gradle.RoboJavaModulePlugin"
-            implementationClass = "org.robolectric.gradle.RoboJavaModulePlugin"
-        }
-        SpotlessPlugin {
-            id = "org.robolectric.gradle.SpotlessPlugin"
-            implementationClass = "org.robolectric.gradle.SpotlessPlugin"
-        }
-        ShadowsPlugin {
-            id = "org.robolectric.gradle.ShadowsPlugin"
-            implementationClass = "org.robolectric.gradle.ShadowsPlugin"
-        }
-        AggregateJavadocPlugin {
-            id = "org.robolectric.gradle.AggregateJavadocPlugin"
-            implementationClass = "org.robolectric.gradle.AggregateJavadocPlugin"
-        }
-    }
-}
-
-dependencies {
-    implementation gradleApi()
-    implementation localGroovy()
-
-    implementation libs.asm.tree
-    implementation libs.android.gradle.api
-    implementation libs.android.tools.common
-    implementation libs.guava
-}
-
-java {
-    sourceCompatibility = JavaVersion.VERSION_11
-    targetCompatibility = JavaVersion.VERSION_11
-}
diff --git a/buildSrc/build.gradle.kts b/buildSrc/build.gradle.kts
new file mode 100644
index 000000000..773cb8497
--- /dev/null
+++ b/buildSrc/build.gradle.kts
@@ -0,0 +1,54 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins { `kotlin-dsl` }
+
+gradlePlugin {
+  plugins {
+    register("AarDepsPlugin") {
+      id = "org.robolectric.gradle.AarDepsPlugin"
+      implementationClass = "org.robolectric.gradle.AarDepsPlugin"
+    }
+    register("AndroidProjectConfigPlugin") {
+      id = "org.robolectric.gradle.AndroidProjectConfigPlugin"
+      implementationClass = "org.robolectric.gradle.AndroidProjectConfigPlugin"
+    }
+    register("DeployedRoboJavaModulePlugin") {
+      id = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
+      implementationClass = "org.robolectric.gradle.DeployedRoboJavaModulePlugin"
+    }
+    register("GradleManagedDevicePlugin") {
+      id = "org.robolectric.gradle.GradleManagedDevicePlugin"
+      implementationClass = "org.robolectric.gradle.GradleManagedDevicePlugin"
+    }
+    register("RoboJavaModulePlugin") {
+      id = "org.robolectric.gradle.RoboJavaModulePlugin"
+      implementationClass = "org.robolectric.gradle.RoboJavaModulePlugin"
+    }
+    register("SpotlessPlugin") {
+      id = "org.robolectric.gradle.SpotlessPlugin"
+      implementationClass = "org.robolectric.gradle.SpotlessPlugin"
+    }
+    register("ShadowsPlugin") {
+      id = "org.robolectric.gradle.ShadowsPlugin"
+      implementationClass = "org.robolectric.gradle.ShadowsPlugin"
+    }
+    register("AggregateJavadocPlugin") {
+      id = "org.robolectric.gradle.AggregateJavadocPlugin"
+      implementationClass = "org.robolectric.gradle.AggregateJavadocPlugin"
+    }
+  }
+}
+
+dependencies {
+  implementation(libs.android.gradle.api)
+  implementation(libs.android.tools.common)
+  implementation(libs.guava)
+  implementation(libs.spotless)
+}
+
+java {
+  sourceCompatibility = JavaVersion.VERSION_11
+  targetCompatibility = JavaVersion.VERSION_11
+}
+
+kotlin { compilerOptions { jvmTarget = JvmTarget.JVM_11 } }
diff --git a/buildSrc/settings.gradle b/buildSrc/settings.gradle
deleted file mode 100644
index 7a96a41f1..000000000
--- a/buildSrc/settings.gradle
+++ /dev/null
@@ -1,16 +0,0 @@
-import org.gradle.api.initialization.resolve.RepositoriesMode
-
-dependencyResolutionManagement {
-    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
-
-    repositories {
-        google()
-        mavenCentral()
-    }
-
-    versionCatalogs {
-        libs {
-            from(files("../gradle/libs.versions.toml"))
-        }
-    }
-}
diff --git a/buildSrc/settings.gradle.kts b/buildSrc/settings.gradle.kts
new file mode 100644
index 000000000..5d29179aa
--- /dev/null
+++ b/buildSrc/settings.gradle.kts
@@ -0,0 +1,18 @@
+pluginManagement {
+  repositories {
+    gradlePluginPortal()
+    google()
+    mavenCentral()
+  }
+}
+
+dependencyResolutionManagement {
+  repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
+
+  repositories {
+    google()
+    mavenCentral()
+  }
+
+  versionCatalogs { create("libs") { from(files("../gradle/libs.versions.toml")) } }
+}
diff --git a/buildSrc/src/main/groovy/AndroidSdk.groovy b/buildSrc/src/main/groovy/AndroidSdk.groovy
deleted file mode 100644
index c3133a790..000000000
--- a/buildSrc/src/main/groovy/AndroidSdk.groovy
+++ /dev/null
@@ -1,93 +0,0 @@
-class AndroidSdk implements Comparable<AndroidSdk> {
-    static final PREINSTRUMENTED_VERSION = 6
-
-    static final LOLLIPOP = new AndroidSdk(21, "5.0.2_r3", "r0")
-    static final LOLLIPOP_MR1 = new AndroidSdk(22, "5.1.1_r9", "r2")
-    static final M = new AndroidSdk(23, "6.0.1_r3", "r1")
-    static final N = new AndroidSdk(24, "7.0.0_r1", "r1")
-    static final N_MR1 = new AndroidSdk(25, "7.1.0_r7", "r1")
-    static final O = new AndroidSdk(26, "8.0.0_r4", "r1")
-    static final O_MR1 = new AndroidSdk(27, "8.1.0", "4611349")
-    static final P = new AndroidSdk(28, "9", "4913185-2")
-    static final Q = new AndroidSdk(29, "10", "5803371")
-    static final R = new AndroidSdk(30, "11", "6757853")
-    static final S = new AndroidSdk(31, "12", "7732740")
-    static final S_V2 = new AndroidSdk(32, "12.1", "8229987")
-    static final TIRAMISU = new AndroidSdk(33, "13", "9030017")
-    static final U = new AndroidSdk(34, "14", "10818077")
-
-    static final List<AndroidSdk> ALL_SDKS = [
-            LOLLIPOP, LOLLIPOP_MR1, M, N, N_MR1, O, O_MR1, P, Q, R, S, S_V2,
-            TIRAMISU, U
-    ]
-
-    static final MAX_SDK = Collections.max(ALL_SDKS)
-
-    public final int apiLevel
-    public final String androidVersion
-    private final String frameworkSdkBuildVersion
-
-    AndroidSdk(int apiLevel, String androidVersion, String frameworkSdkBuildVersion) {
-        this.apiLevel = apiLevel
-        this.androidVersion = androidVersion
-        this.frameworkSdkBuildVersion = frameworkSdkBuildVersion
-    }
-
-    static String getGroupId() {
-        return "org.robolectric"
-    }
-
-    static String getArtifactId() {
-        return "android-all"
-    }
-
-    static String getPreinstrumentedArtifactId() {
-        return "android-all-instrumented"
-    }
-
-    String getVersion() {
-        return "${androidVersion}-robolectric-${frameworkSdkBuildVersion}"
-    }
-
-    String getPreinstrumentedVersion() {
-        return "${androidVersion}-robolectric-${frameworkSdkBuildVersion}-i${PREINSTRUMENTED_VERSION}"
-    }
-
-    String getCoordinates() {
-        return "${groupId}:${artifactId}:${version}"
-    }
-
-    String getPreinstrumentedCoordinates() {
-        return "${groupId}:${preinstrumentedArtifactId}:${preinstrumentedVersion}"
-    }
-
-    String getJarFileName() {
-        return "android-all-${androidVersion}-robolectric-${frameworkSdkBuildVersion}.jar"
-    }
-
-    String getPreinstrumentedJarFileName() {
-        return "android-all-instrumented-${preinstrumentedVersion}.jar"
-    }
-
-    @Override
-    int compareTo(AndroidSdk other) {
-        return apiLevel - other.apiLevel
-    }
-
-    @Override
-    boolean equals(o) {
-        if (this.is(o)) return true
-        if (getClass() != o.class) return false
-
-        AndroidSdk that = (AndroidSdk) o
-
-        if (apiLevel != that.apiLevel) return false
-
-        return true
-    }
-
-    @Override
-    int hashCode() {
-        return apiLevel
-    }
-}
diff --git a/buildSrc/src/main/groovy/ProvideBuildClasspathTask.groovy b/buildSrc/src/main/groovy/ProvideBuildClasspathTask.groovy
deleted file mode 100644
index 014b1b28c..000000000
--- a/buildSrc/src/main/groovy/ProvideBuildClasspathTask.groovy
+++ /dev/null
@@ -1,37 +0,0 @@
-import org.gradle.api.DefaultTask
-import org.gradle.api.tasks.OutputFile
-import org.gradle.api.tasks.TaskAction
-
-class ProvideBuildClasspathTask extends DefaultTask {
-    @OutputFile File outFile
-
-    @TaskAction
-    void writeProperties() throws Exception {
-        final Properties props = new Properties()
-
-        String preinstrumentedKey = "robolectric.usePreinstrumentedJars"
-        boolean usePreinstrumentedJars =
-            Boolean.parseBoolean(
-              System.getProperty(preinstrumentedKey, "true"))
-
-        AndroidSdk.ALL_SDKS.each { androidSdk ->
-            String coordinates =
-              usePreinstrumentedJars ?
-                androidSdk.preinstrumentedCoordinates : androidSdk.coordinates
-            def config =
-                project.configurations.create("sdk${androidSdk.apiLevel}")
-            project.dependencies.add(
-                "sdk${androidSdk.apiLevel}",
-                coordinates)
-            props.setProperty(
-                coordinates,
-                config.files.join(File.pathSeparator))
-        }
-
-        File outDir = outFile.parentFile
-        if (!outDir.directory) outDir.mkdirs()
-        outFile.withPrintWriter { out ->
-            props.store(out, "# GENERATED by ${this} -- do not edit")
-        }
-    }
-}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java b/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java
deleted file mode 100644
index e5d193450..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/AarDepsPlugin.java
+++ /dev/null
@@ -1,124 +0,0 @@
-package org.robolectric.gradle;
-
-import static org.gradle.api.artifacts.type.ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.stream.Collectors;
-import javax.inject.Inject;
-import org.gradle.api.Action;
-import org.gradle.api.Plugin;
-import org.gradle.api.Project;
-import org.gradle.api.Task;
-import org.gradle.api.artifacts.transform.TransformOutputs;
-import org.gradle.api.file.FileCollection;
-import org.gradle.api.tasks.compile.JavaCompile;
-import org.jetbrains.annotations.NotNull;
-import org.robolectric.gradle.agp.ExtractAarTransform;
-
-/** Resolve aar dependencies into jars for non-Android projects. */
-public class AarDepsPlugin implements Plugin<Project> {
-  @Override
-  public void apply(Project project) {
-    project
-        .getDependencies()
-        .registerTransform(
-            ClassesJarExtractor.class,
-            reg -> {
-              reg.getParameters().getProjectName().set(project.getName());
-              reg.getFrom().attribute(ARTIFACT_TYPE_ATTRIBUTE, "aar");
-              reg.getTo().attribute(ARTIFACT_TYPE_ATTRIBUTE, "jar");
-            });
-
-    project.afterEvaluate(
-        p ->
-            project
-                .getConfigurations()
-                .forEach(
-                    c -> {
-                      // I suspect we're meant to use the org.gradle.usage attribute, but this
-                      // works.
-                      if (c.getName().endsWith("Classpath")) {
-                        c.attributes(
-                            cfgAttrs -> cfgAttrs.attribute(ARTIFACT_TYPE_ATTRIBUTE, "jar"));
-                      }
-                    }));
-
-    // warn if any AARs do make it through somehow; there must be a gradle configuration
-    // that isn't matched above.
-    //noinspection Convert2Lambda
-    project
-        .getTasks()
-        .withType(JavaCompile.class)
-        .all(
-            // the following Action<Task needs to remain an anonymous subclass or gradle's
-            // incremental compile breaks (run `gradlew -i classes` twice to see impact):
-            t ->
-                t.doFirst(
-                    new Action<>() {
-                      @Override
-                      public void execute(@NotNull Task task) {
-                        List<File> aarFiles = AarDepsPlugin.this.findAarFiles(t.getClasspath());
-                        if (!aarFiles.isEmpty()) {
-                          throw new IllegalStateException(
-                              "AARs on classpath: "
-                                  + aarFiles.stream()
-                                      .filter(Objects::nonNull)
-                                      .map(File::toString)
-                                      .collect(Collectors.joining("\n  ")));
-                        }
-                      }
-                    }));
-  }
-
-  private List<File> findAarFiles(FileCollection files) {
-    List<File> bad = new ArrayList<>();
-    for (File file : files.getFiles()) {
-      if (file.getName().toLowerCase().endsWith(".aar")) {
-        bad.add(file);
-      }
-    }
-    return bad;
-  }
-
-  /** Extracts classes.jar from an AAR */
-  public abstract static class ClassesJarExtractor extends ExtractAarTransform {
-    @Inject
-    public ClassesJarExtractor() {}
-
-    @Override
-    public void transform(@NotNull TransformOutputs outputs) {
-      AtomicReference<File> classesJarFile = new AtomicReference<>();
-      AtomicReference<File> outJarFile = new AtomicReference<>();
-      super.transform(
-          new TransformOutputs() {
-            // This is the one that ExtractAarTransform calls.
-            @NotNull
-            @Override
-            public File dir(@NotNull Object o) {
-              // ExtractAarTransform needs a place to extract the AAR. We don't really need to
-              // register this as an output, but it'd be tricky to avoid it.
-              File dir = outputs.dir(o);
-
-              // Also, register our jar file. Its name needs to be quasi-unique or
-              // IntelliJ Gradle/Android plugins get confused.
-              classesJarFile.set(new File(new File(dir, "jars"), "classes.jar"));
-              outJarFile.set(new File(new File(dir, "jars"), o + ".jar"));
-              outputs.file(o + "/jars/" + o + ".jar");
-              return outputs.dir(o);
-            }
-
-            @NotNull
-            @Override
-            public File file(@NotNull Object o) {
-              throw new IllegalStateException("shouldn't be called");
-            }
-          });
-
-      classesJarFile.get().renameTo(outJarFile.get());
-    }
-  }
-}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy
deleted file mode 100644
index 67f67d17f..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/AggregateJavadocPlugin.groovy
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.plugins.JavaBasePlugin
-import org.gradle.api.plugins.JavaPlugin
-import org.gradle.api.tasks.javadoc.Javadoc
-
-/**
- * Modified from https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin.
- *
- * The origin license is Apache v2:
- * https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin?tab=Apache-2.0-1-ov-file#readme.
- */
-class AggregateJavadocPlugin implements Plugin<Project> {
-    private static final String AGGREGATE_JAVADOCS_TASK_NAME = 'aggregateJavadocs'
-
-    @Override
-    void apply(Project project) {
-        Project rootProject = project.rootProject
-        // This plugin only works for root project.
-        if (project != rootProject) {
-            return
-        }
-        rootProject.gradle.projectsEvaluated {
-            Set<Project> javaSubprojects = getJavaSubprojects(rootProject)
-            if (!javaSubprojects.isEmpty()) {
-                rootProject.tasks.register(AGGREGATE_JAVADOCS_TASK_NAME, Javadoc) {
-                    description = 'Aggregates Javadoc API documentation of all subprojects.'
-                    group = JavaBasePlugin.DOCUMENTATION_GROUP
-
-                    dependsOn javaSubprojects.javadoc
-                    source javaSubprojects.javadoc.source
-
-                    String buildDirectory = rootProject.layout.buildDirectory.get().asFile.path
-                    destinationDir rootProject.file("$buildDirectory/docs/javadoc")
-                    classpath = rootProject.files(javaSubprojects.javadoc.classpath)
-                }
-            }
-        }
-    }
-
-    private static Set<Project> getJavaSubprojects(Project rootProject) {
-        rootProject.subprojects.findAll { subproject -> subproject.plugins.hasPlugin(JavaPlugin) }
-    }
-}
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy
deleted file mode 100644
index ea8f04c36..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/AndroidProjectConfigPlugin.groovy
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.tasks.testing.Test
-
-class AndroidProjectConfigPlugin implements Plugin<Project> {
-    @Override
-    void apply(Project project) {
-        project.android.testOptions.unitTests.all {
-            // TODO: DRY up code with RoboJavaModulePlugin...
-            testLogging {
-                exceptionFormat "full"
-                showCauses true
-                showExceptions true
-                showStackTraces true
-                showStandardStreams true
-                events = ["failed", "skipped"]
-            }
-
-            minHeapSize = "2048m"
-            maxHeapSize = "12288m"
-
-            if (System.env['GRADLE_MAX_PARALLEL_FORKS'] != null) {
-                maxParallelForks = Integer.parseInt(System.env['GRADLE_MAX_PARALLEL_FORKS'])
-            }
-
-            def forwardedSystemProperties = System.properties
-                    .findAll { k, v -> k.startsWith("robolectric.") }
-                    .collect { k, v -> "-D$k=$v" }
-            jvmArgs = forwardedSystemProperties
-            jvmArgs += [
-                    '--add-opens=java.base/java.lang=ALL-UNNAMED',
-                    '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
-                    '--add-opens=java.base/java.io=ALL-UNNAMED',
-                    '--add-opens=java.base/java.net=ALL-UNNAMED',
-                    '--add-opens=java.base/java.nio=ALL-UNNAMED', // required for ShadowVMRuntime
-                    '--add-opens=java.base/java.security=ALL-UNNAMED',
-                    '--add-opens=java.base/java.text=ALL-UNNAMED',
-                    '--add-opens=java.base/java.util=ALL-UNNAMED',
-                    '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
-            ]
-
-            doFirst {
-                if (!forwardedSystemProperties.isEmpty()) {
-                    println "Running tests with ${forwardedSystemProperties}"
-                }
-            }
-        }
-
-        project.task('provideBuildClasspath', type: ProvideBuildClasspathTask) {
-            File outDir = project.layout.buildDirectory.dir("generated/robolectric").get().asFile
-            outFile = new File(outDir, "robolectric-deps.properties")
-
-            project.android.sourceSets['test'].resources.srcDir(outDir)
-        }
-
-        project.afterEvaluate {
-            project.tasks.forEach { task ->
-                if (task.name.matches("process.*UnitTestJavaRes")) {
-                    task.dependsOn "provideBuildClasspath"
-                }
-            }
-        }
-
-        // Only run tests in the debug variant. This is to avoid running tests twice when `./gradlew test` is run at the top-level.
-        project.tasks.withType(Test).configureEach {
-            onlyIf { variantName.toLowerCase().contains('debug') }
-        }
-    }
-}
-
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy
deleted file mode 100644
index 299b4e838..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/DeployedRoboJavaModulePlugin.groovy
+++ /dev/null
@@ -1,120 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.publish.maven.MavenPublication
-import org.gradle.api.tasks.bundling.Jar
-
-class DeployedRoboJavaModulePlugin implements Plugin<Project> {
-    Closure doApply = {
-        project.apply plugin: "signing"
-        project.apply plugin: "maven-publish"
-
-        if (!project.plugins.hasPlugin("org.robolectric.gradle.RoboJavaModulePlugin")) {
-            project.apply plugin: "org.robolectric.gradle.RoboJavaModulePlugin"
-        }
-
-        task('sourcesJar', type: Jar, dependsOn: classes) {
-            archiveClassifier = "sources"
-            from sourceSets.main.allJava
-        }
-
-        javadoc {
-            failOnError = false
-            source = sourceSets.main.allJava
-            options.noTimestamp = true
-            options.header = "<ul class=\"navList\"><li>Robolectric $thisVersion | <a href=\"/\">Home</a></li></ul>"
-            options.footer = "<ul class=\"navList\"><li>Robolectric $thisVersion | <a href=\"/\">Home</a></li></ul>"
-            options.bottom = "<link rel=\"stylesheet\" href=\"https://robolectric.org/assets/css/main.css\">"
-            options.version = thisVersion
-        }
-
-        task('javadocJar', type: Jar, dependsOn: javadoc) {
-            archiveClassifier = "javadoc"
-            from javadoc.destinationDir
-        }
-
-        // for maven local install:
-        archivesBaseName = mavenArtifactName
-
-        publishing {
-            publications {
-                mavenJava(MavenPublication) {
-                    from components.java
-
-                    def skipJavadoc = System.getenv('SKIP_JAVADOC') == "true"
-                    artifact sourcesJar
-                    if (!skipJavadoc) {
-                        artifact javadocJar
-                    }
-
-                    artifactId = mavenArtifactName
-                    pom {
-                        name = project.name
-                        description = "An alternative Android testing framework."
-                        url = "http://robolectric.org"
-
-                        licenses {
-                            license {
-                                name = "The MIT License"
-                                url = "https://opensource.org/licenses/MIT"
-                            }
-                        }
-
-                        scm {
-                            url = "git@github.com:robolectric/robolectric.git"
-                            connection = "scm:git:git://github.com/robolectric/robolectric.git"
-                            developerConnection = "scm:git:https://github.com/robolectric/robolectric.git"
-                        }
-
-                        developers {
-                            developer {
-                                name = "Brett Chabot"
-                                email = "brettchabot@google.com"
-                                organization = "Google Inc."
-                                organizationUrl = "http://google.com"
-                            }
-
-                            developer {
-                                name = "Michael Hoisie"
-                                email = "hoisie@google.com"
-                                organization = "Google Inc."
-                                organizationUrl = "http://google.com"
-                            }
-
-                            developer {
-                                name = "Christian Williams"
-                                email = "antixian666@gmail.com"
-                            }
-                        }
-                    }
-                }
-            }
-
-            repositories {
-                maven {
-                    def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-                    def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
-                    url = project.version.endsWith("-SNAPSHOT") ? snapshotsRepoUrl : releasesRepoUrl
-
-                    credentials {
-                        username = System.properties["sonatype-login"] ?: System.env['SONATYPE_LOGIN']
-                        password = System.properties["sonatype-password"] ?: System.env['SONATYPE_PASSWORD']
-                    }
-                }
-            }
-        }
-
-        signing {
-            required { !version.endsWith("SNAPSHOT") && gradle.taskGraph.hasTask("uploadArchives") }
-            sign publishing.publications.mavenJava
-        }
-    }
-
-    @Override
-    void apply(Project project) {
-        doApply.delegate = project
-        doApply.resolveStrategy = Closure.DELEGATE_ONLY
-        doApply()
-    }
-}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/GradleManagedDevicePlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/GradleManagedDevicePlugin.groovy
deleted file mode 100644
index 2589e8327..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/GradleManagedDevicePlugin.groovy
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.robolectric.gradle
-
-import com.android.build.api.dsl.ManagedVirtualDevice
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-
-class GradleManagedDevicePlugin implements Plugin<Project> {
-    @Override
-    void apply(Project project) {
-        project.android.testOptions {
-            animationsDisabled = true
-            devices {
-                // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi29DebugAndroidTest
-                nexusOneApi29(ManagedVirtualDevice) {
-                    device = "Nexus One"
-                    apiLevel = 29
-                    systemImageSource = "aosp"
-                }
-                // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi34DebugAndroidTest
-                nexusOneApi34(ManagedVirtualDevice) {
-                    device = "Nexus One"
-                    apiLevel = 34
-                    systemImageSource = "aosp-atd"
-                }
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy
deleted file mode 100644
index 092c0379c..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/RoboJavaModulePlugin.groovy
+++ /dev/null
@@ -1,103 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.JavaVersion
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.tasks.compile.JavaCompile
-
-class RoboJavaModulePlugin implements Plugin<Project> {
-    Closure doApply = {
-        apply plugin: "java-library"
-
-        def skipErrorprone = System.getenv('SKIP_ERRORPRONE') == "true"
-        if (!skipErrorprone) {
-            apply plugin: "net.ltgt.errorprone"
-            project.dependencies {
-                errorprone(libs.error.prone.core)
-                errorproneJavac(libs.error.prone.javac)
-            }
-        }
-
-        apply plugin: AarDepsPlugin
-
-        sourceCompatibility = JavaVersion.VERSION_1_8
-        targetCompatibility = JavaVersion.VERSION_1_8
-
-        tasks.withType(JavaCompile).configureEach { task ->
-            sourceCompatibility = JavaVersion.VERSION_1_8
-            targetCompatibility = JavaVersion.VERSION_1_8
-
-            // Show all warnings except boot classpath
-            configure(options) {
-                if (System.properties["lint"] != null && System.properties["lint"] != "false") {
-                    compilerArgs << "-Xlint:all"        // Turn on all warnings
-                }
-                compilerArgs << "-Xlint:-options"       // Turn off "missing" bootclasspath warning
-                encoding = "utf-8"                      // Make sure source encoding is UTF-8
-            }
-
-        }
-
-        ext.mavenArtifactName = project.path.substring(1).split(/:/).join("-")
-
-        task('provideBuildClasspath', type: ProvideBuildClasspathTask) {
-            File outDir = project.sourceSets['test'].output.resourcesDir
-            outFile = new File(outDir, 'robolectric-deps.properties')
-        }
-
-        tasks['test'].dependsOn provideBuildClasspath
-
-        test {
-            exclude "**/*\$*" // otherwise gradle runs static inner classes like TestRunnerSequenceTest$SimpleTest
-
-            // TODO: DRY up code with AndroidProjectConfigPlugin...
-            testLogging {
-                exceptionFormat "full"
-                showCauses true
-                showExceptions true
-                showStackTraces true
-                showStandardStreams true
-                events = ["failed", "skipped"]
-            }
-
-            minHeapSize = "1024m"
-            maxHeapSize = "12288m"
-
-            if (System.env['GRADLE_MAX_PARALLEL_FORKS'] != null) {
-                maxParallelForks = Integer.parseInt(System.env['GRADLE_MAX_PARALLEL_FORKS'])
-            }
-
-            def forwardedSystemProperties = System.properties
-                    .findAll { k, v -> k.startsWith("robolectric.") }
-                    .collect { k, v -> "-D$k=$v" }
-            jvmArgs = forwardedSystemProperties
-            jvmArgs += [
-                    '--add-opens=java.base/java.lang=ALL-UNNAMED',
-                    '--add-opens=java.base/java.lang.reflect=ALL-UNNAMED',
-                    '--add-opens=java.base/java.io=ALL-UNNAMED',
-                    '--add-opens=java.base/java.net=ALL-UNNAMED',
-                    '--add-opens=java.base/java.nio=ALL-UNNAMED', // required for ShadowVMRuntime
-                    '--add-opens=java.base/java.security=ALL-UNNAMED',
-                    '--add-opens=java.base/java.text=ALL-UNNAMED',
-                    '--add-opens=java.base/java.util=ALL-UNNAMED',
-                    '--add-opens=java.desktop/java.awt.font=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
-                    '--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
-            ]
-
-            doFirst {
-                if (!forwardedSystemProperties.isEmpty()) {
-                    println "Running tests with ${forwardedSystemProperties}"
-                }
-            }
-        }
-    }
-
-    @Override
-    void apply(Project project) {
-        doApply.delegate = project
-        doApply.resolveStrategy = Closure.DELEGATE_ONLY
-        doApply()
-    }
-}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy
deleted file mode 100644
index f11b7f004..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/ShadowsPlugin.groovy
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-import org.gradle.api.tasks.compile.JavaCompile
-
-import java.util.jar.JarFile
-
-@SuppressWarnings("GroovyUnusedDeclaration")
-class ShadowsPlugin implements Plugin<Project> {
-    @Override
-    void apply(Project project) {
-        project.apply plugin: 'idea'
-
-        project.extensions.create("shadows", ShadowsPluginExtension)
-
-        project.dependencies {
-            annotationProcessor project.project(":processor")
-        }
-
-        // write generated Java into its own dir... see https://github.com/gradle/gradle/issues/4956
-        def generatedSrcDir = project.file("build/generated/src/apt/main")
-
-        project.tasks.named("compileJava").configure { task ->
-            task.options.annotationProcessorGeneratedSourcesDirectory = generatedSrcDir
-
-            task.doFirst {
-                options.compilerArgs.add("-Aorg.robolectric.annotation.processing.jsonDocsEnabled=true")
-                options.compilerArgs.add("-Aorg.robolectric.annotation.processing.jsonDocsDir=${project.layout.buildDirectory.get().asFile}/docs/json")
-                options.compilerArgs.add("-Aorg.robolectric.annotation.processing.shadowPackage=${project.shadows.packageName}")
-                options.compilerArgs.add("-Aorg.robolectric.annotation.processing.sdkCheckMode=${project.shadows.sdkCheckMode}")
-                options.compilerArgs.add("-Aorg.robolectric.annotation.processing.sdks=${project.rootProject.layout.buildDirectory.get().asFile}/sdks.txt")
-            }
-        }
-
-        // include generated sources in javadoc jar
-        project.tasks.named("javadoc").configure { task ->
-            task.source(generatedSrcDir)
-        }
-
-        // verify that we have the apt-generated files in our javadoc and sources jars
-        project.tasks.named("javadocJar").configure { task ->
-            task.doLast {
-                def shadowPackageNameDir = project.shadows.packageName.replaceAll(/\./, '/')
-                checkForFile(task.archivePath, "${shadowPackageNameDir}/Shadows.html")
-            }
-        }
-
-        project.tasks.named("sourcesJar").configure { task ->
-            task.from(generatedSrcDir)
-            task.doLast {
-                def shadowPackageNameDir = project.shadows.packageName.replaceAll(/\./, '/')
-                checkForFile(task.archivePath, "${shadowPackageNameDir}/Shadows.java")
-            }
-        }
-
-        project.rootProject.configAnnotationProcessing += project
-
-        /* Prevents sporadic compilation error:
-         * 'Bad service configuration file, or exception thrown while constructing
-         *  Processor object: javax.annotation.processing.Processor: Error reading
-         *  configuration file'
-         *
-         * See https://discuss.gradle.org/t/gradle-not-compiles-with-solder-tooling-jar/7583/20
-         */
-        project.tasks.withType(JavaCompile).configureEach { options.fork = true }
-    }
-
-    static class ShadowsPluginExtension {
-        String packageName
-        String sdkCheckMode = "WARN"
-    }
-
-    private static void checkForFile(jar, String name) {
-        def files = new JarFile(jar).entries().collect { it.name }.toSet()
-
-        if (!files.contains(name)) {
-            throw new RuntimeException("Missing file ${name} in ${jar}")
-        }
-    }
-}
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy b/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy
deleted file mode 100644
index 3aa88664a..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/SpotlessPlugin.groovy
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.robolectric.gradle
-
-import org.gradle.api.Plugin
-import org.gradle.api.Project
-
-class SpotlessPlugin implements Plugin<Project> {
-    void apply(Project project) {
-        project.getPlugins().apply('com.diffplug.spotless')
-
-        project.spotless {
-            kotlin {
-                // Add configurations for Kotlin files
-                target '**/*.kt'
-                ktfmt('0.49').googleStyle()
-            }
-            groovy {
-                // Add configurations for Groovy files
-                target("**/*.groovy")
-            }
-            groovyGradle {
-                // Add configurations for Groovy Gradle files
-                target('*.gradle', "**/*.gradle")
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java b/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java
deleted file mode 100644
index cbad436f3..000000000
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/ExtractAarTransform.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * This class comes from AGP internals:
- * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:build-system/gradle-core/src/main/java/com/android/build/gradle/internal/dependency/ExtractAarTransform.kt;bpv=0
- */
-
-package org.robolectric.gradle.agp;
-
-import com.android.SdkConstants;
-import com.android.utils.FileUtils;
-import com.google.common.io.Files;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.jar.JarOutputStream;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import org.gradle.api.artifacts.transform.InputArtifact;
-import org.gradle.api.artifacts.transform.TransformAction;
-import org.gradle.api.artifacts.transform.TransformOutputs;
-import org.gradle.api.file.FileSystemLocation;
-import org.gradle.api.provider.Provider;
-import org.gradle.api.tasks.Classpath;
-import org.gradle.work.DisableCachingByDefault;
-import org.jetbrains.annotations.NotNull;
-
-// TODO Keep the original Kotlin implementation when `buildSrc` is migrated to Kotlin.
-@DisableCachingByDefault(because = "Copy task")
-public abstract class ExtractAarTransform implements TransformAction<GenericTransformParameters> {
-  @Classpath
-  @InputArtifact
-  public abstract Provider<FileSystemLocation> getAarFile();
-
-  @Override
-  public void transform(@NotNull TransformOutputs outputs) {
-    // TODO: record transform execution span
-    File inputFile = getAarFile().get().getAsFile();
-    String inputFileNameWithoutExtension = Files.getNameWithoutExtension(inputFile.getName());
-    File outputDir = outputs.dir(inputFileNameWithoutExtension);
-    FileUtils.mkdirs(outputDir);
-    new AarExtractor().extract(inputFile, outputDir);
-  }
-}
-
-class AarExtractor {
-  private static final String LIBS_PREFIX = SdkConstants.LIBS_FOLDER + '/';
-  private static final int LIBS_PREFIX_LENGTH = LIBS_PREFIX.length();
-  private static final int JARS_PREFIX_LENGTH = SdkConstants.FD_JARS.length() + 1;
-
-  // Note:
-  //  - A jar doesn't need a manifest entry, but if we ever want to create a manifest entry, be
-  //    sure to set a fixed timestamp for it so that the jar is deterministic
-  //  - This empty jar takes up only ~22 bytes, so we don't need to GC it at the end of the build.
-  private static final byte[] emptyJar;
-
-  /**
-   * {@link StringBuilder} used to construct all paths. It gets truncated back to {@link
-   * JARS_PREFIX_LENGTH} on every calculation.
-   */
-  private final StringBuilder stringBuilder = new StringBuilder(60);
-
-  static {
-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-    //noinspection EmptyTryBlock
-    try (JarOutputStream outputStream = new JarOutputStream(byteArrayOutputStream)) {
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-
-    emptyJar = byteArrayOutputStream.toByteArray();
-  }
-
-  AarExtractor() {
-    stringBuilder.append(SdkConstants.FD_JARS);
-    stringBuilder.append(File.separatorChar);
-  }
-
-  private String choosePathInOutput(@NotNull String entryName) {
-    stringBuilder.setLength(JARS_PREFIX_LENGTH);
-
-    if (entryName.equals(SdkConstants.FN_CLASSES_JAR)
-        || entryName.equals(SdkConstants.FN_LINT_JAR)) {
-      stringBuilder.append(entryName);
-
-      return stringBuilder.toString();
-    } else if (entryName.startsWith(LIBS_PREFIX)) {
-      // In case we have libs/classes.jar we are going to rename them, due an issue in
-      // Gradle.
-      // TODO: stop doing this once this is fixed in gradle.
-      String pathWithinLibs = entryName.substring(LIBS_PREFIX_LENGTH);
-
-      if (pathWithinLibs.equals(SdkConstants.FN_CLASSES_JAR)) {
-        stringBuilder.append(LIBS_PREFIX).append("classes-2" + SdkConstants.DOT_JAR);
-      } else if (pathWithinLibs.equals(SdkConstants.FN_LINT_JAR)) {
-        stringBuilder.append(LIBS_PREFIX).append("lint-2" + SdkConstants.DOT_JAR);
-      } else {
-        stringBuilder.append(LIBS_PREFIX).append(pathWithinLibs);
-      }
-
-      return stringBuilder.toString();
-    } else {
-      return entryName;
-    }
-  }
-
-  /**
-   * Extracts an AAR file into a directory.
-   *
-   * <p>Note: There are small adjustments made to the extracted contents. For example, classes.jar
-   * inside the AAR will be extracted to jars/classes.jar, and if the jar does not exist, we will
-   * create an empty classes.jar.
-   */
-  void extract(@NotNull File aar, @NotNull File outputDir) {
-    try (ZipInputStream zipInputStream =
-        new ZipInputStream(java.nio.file.Files.newInputStream(aar.toPath()))) {
-      while (true) {
-        ZipEntry entry = zipInputStream.getNextEntry();
-        if (entry == null) {
-          break;
-        }
-
-        if (entry.isDirectory() || entry.getName().contains("../") || entry.getName().isEmpty()) {
-          continue;
-        }
-
-        String path = FileUtils.toSystemDependentPath(choosePathInOutput(entry.getName()));
-        File outputFile = new File(outputDir, path);
-        Files.createParentDirs(outputFile);
-        Files.asByteSink(outputFile).writeFrom(zipInputStream);
-      }
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-
-    // If classes.jar does not exist, create an empty one
-    File classesJar = resolve(outputDir, SdkConstants.FD_JARS + "/" + SdkConstants.FN_CLASSES_JAR);
-    if (!classesJar.exists()) {
-      try {
-        Files.createParentDirs(classesJar);
-        Files.write(emptyJar, classesJar);
-      } catch (IOException e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  @NotNull
-  private File resolve(@NotNull File source, @NotNull String relative) {
-    Path baseDir = source.toPath();
-    Path relativeFile = Paths.get(relative);
-    Path resolvedFile = baseDir.resolve(relativeFile);
-
-    return resolvedFile.toFile();
-  }
-}
diff --git a/buildSrc/src/main/java/AndroidSdk.kt b/buildSrc/src/main/java/AndroidSdk.kt
new file mode 100644
index 000000000..033a5e450
--- /dev/null
+++ b/buildSrc/src/main/java/AndroidSdk.kt
@@ -0,0 +1,74 @@
+class AndroidSdk(
+  val apiLevel: Int,
+  val androidVersion: String,
+  private val frameworkSdkBuildVersion: String,
+) : Comparable<AndroidSdk> {
+  val groupId: String
+    get() = "org.robolectric"
+
+  val artifactId: String
+    get() = "android-all"
+
+  val preinstrumentedArtifactId: String
+    get() = "android-all-instrumented"
+
+  val version: String
+    get() = "$androidVersion-robolectric-$frameworkSdkBuildVersion"
+
+  val preinstrumentedVersion: String
+    get() = "$version-i$PREINSTRUMENTED_VERSION"
+
+  val coordinates: String
+    get() = "$groupId:$artifactId:$version"
+
+  val preinstrumentedCoordinates: String
+    get() = "$groupId:$preinstrumentedArtifactId:$preinstrumentedVersion"
+
+  val jarFileName: String
+    get() = "android-all-$version.jar"
+
+  val preinstrumentedJarFileName: String
+    get() = "android-all-instrumented-$preinstrumentedVersion.jar"
+
+  override fun compareTo(other: AndroidSdk): Int {
+    return apiLevel - other.apiLevel
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return when {
+      this === other -> true
+      other !is AndroidSdk -> false
+      apiLevel != other.apiLevel -> false
+      else -> true
+    }
+  }
+
+  override fun hashCode(): Int {
+    return apiLevel
+  }
+
+  companion object {
+    private const val PREINSTRUMENTED_VERSION = 7
+
+    val LOLLIPOP = AndroidSdk(21, "5.0.2_r3", "r0")
+    val LOLLIPOP_MR1 = AndroidSdk(22, "5.1.1_r9", "r2")
+    val M = AndroidSdk(23, "6.0.1_r3", "r1")
+    val N = AndroidSdk(24, "7.0.0_r1", "r1")
+    val N_MR1 = AndroidSdk(25, "7.1.0_r7", "r1")
+    val O = AndroidSdk(26, "8.0.0_r4", "r1")
+    val O_MR1 = AndroidSdk(27, "8.1.0", "4611349")
+    val P = AndroidSdk(28, "9", "4913185-2")
+    val Q = AndroidSdk(29, "10", "5803371")
+    val R = AndroidSdk(30, "11", "6757853")
+    val S = AndroidSdk(31, "12", "7732740")
+    val S_V2 = AndroidSdk(32, "12.1", "8229987")
+    val TIRAMISU = AndroidSdk(33, "13", "9030017")
+    val U = AndroidSdk(34, "14", "10818077")
+    val V = AndroidSdk(35, "15", "12650502")
+
+    val ALL_SDKS =
+      listOf(LOLLIPOP, LOLLIPOP_MR1, M, N, N_MR1, O, O_MR1, P, Q, R, S, S_V2, TIRAMISU, U, V)
+
+    val MAX_SDK = ALL_SDKS.maxBy { it.apiLevel }
+  }
+}
diff --git a/buildSrc/src/main/java/ProvideBuildClasspathTask.kt b/buildSrc/src/main/java/ProvideBuildClasspathTask.kt
new file mode 100644
index 000000000..5ed54d40f
--- /dev/null
+++ b/buildSrc/src/main/java/ProvideBuildClasspathTask.kt
@@ -0,0 +1,43 @@
+import java.io.File
+import java.util.Properties
+import org.gradle.api.DefaultTask
+import org.gradle.api.tasks.OutputFile
+import org.gradle.api.tasks.TaskAction
+
+abstract class ProvideBuildClasspathTask : DefaultTask() {
+  @get:OutputFile abstract var outFile: File
+
+  @TaskAction
+  @Throws(Exception::class)
+  fun writeProperties() {
+    val props = Properties()
+    val usePreinstrumentedJars = System.getProperty(PREINSTRUMENTED_KEY, "true").toBoolean()
+
+    AndroidSdk.ALL_SDKS.forEach { androidSdk ->
+      val configurationName = "sdk${androidSdk.apiLevel}"
+      val coordinates =
+        if (usePreinstrumentedJars) {
+          androidSdk.preinstrumentedCoordinates
+        } else {
+          androidSdk.coordinates
+        }
+      val config =
+        project.configurations.create(configurationName) {
+          dependencies.add(project.dependencies.create(coordinates))
+        }
+
+      props.setProperty(coordinates, config.files.joinToString(File.pathSeparator))
+    }
+
+    val outDir = outFile.parentFile
+    if (!outDir.isDirectory) {
+      outDir.mkdirs()
+    }
+
+    outFile.printWriter().use { out -> props.store(out, "# GENERATED by $this -- do not edit") }
+  }
+
+  private companion object {
+    private const val PREINSTRUMENTED_KEY = "robolectric.usePreinstrumentedJars"
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/AarDepsPlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/AarDepsPlugin.kt
new file mode 100644
index 000000000..6fa232e8e
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/AarDepsPlugin.kt
@@ -0,0 +1,88 @@
+package org.robolectric.gradle
+
+import com.android.SdkConstants.DOT_JAR
+import com.android.SdkConstants.EXT_AAR
+import com.android.SdkConstants.EXT_JAR
+import com.android.SdkConstants.FD_JARS
+import com.android.SdkConstants.FN_CLASSES_JAR
+import java.io.File
+import java.util.concurrent.atomic.AtomicReference
+import javax.inject.Inject
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.artifacts.transform.TransformOutputs
+import org.gradle.api.artifacts.type.ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE
+import org.gradle.api.file.FileCollection
+import org.gradle.api.tasks.compile.JavaCompile
+import org.gradle.kotlin.dsl.registerTransform
+import org.gradle.kotlin.dsl.withType
+import org.robolectric.gradle.agp.ExtractAarTransform
+
+/** Resolve AAR dependencies into jars for non-Android projects. */
+@Suppress("unused")
+class AarDepsPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.dependencies.registerTransform(ClassesJarExtractor::class) {
+      parameters.projectName.set(project.name)
+      from.attribute(ARTIFACT_TYPE_ATTRIBUTE, EXT_AAR)
+      to.attribute(ARTIFACT_TYPE_ATTRIBUTE, EXT_JAR)
+    }
+
+    project.afterEvaluate {
+      configurations.forEach { configuration ->
+        // I suspect we're meant to use the org.gradle.usage attribute, but this works.
+        if (configuration.name.endsWith("Classpath")) {
+          configuration.attributes { attribute(ARTIFACT_TYPE_ATTRIBUTE, EXT_JAR) }
+        }
+      }
+    }
+
+    // Warn if any AARs do make it through somehow; there must be a Gradle configuration
+    // that isn't matched above.
+    project.tasks.withType<JavaCompile>().forEach { task ->
+      task.doFirst {
+        val aarFiles = findAarFiles(task.classpath)
+
+        check(aarFiles.isEmpty()) { "AARs on classpath: " + aarFiles.joinToString("\n  ") }
+      }
+    }
+  }
+
+  private fun findAarFiles(files: FileCollection): List<File> {
+    return files.files.filter { it.name.lowercase().endsWith(".$EXT_AAR") }
+  }
+
+  /** Extracts classes.jar from an AAR. */
+  abstract class ClassesJarExtractor @Inject constructor() : ExtractAarTransform() {
+    override fun transform(outputs: TransformOutputs) {
+      val classesJarFile = AtomicReference<File>()
+      val outJarFile = AtomicReference<File>()
+
+      val transformOutputs =
+        object : TransformOutputs {
+          // This is the one that ExtractAarTransform calls.
+          override fun dir(path: Any): File {
+            // ExtractAarTransform needs a place to extract the AAR. We don't really need to
+            // register this as an output, but it'd be tricky to avoid it.
+            val dir = outputs.dir(path)
+
+            // Also, register our jar file. Its name needs to be quasi-unique or IntelliJ
+            // Gradle/Android plugins get confused.
+            classesJarFile.set(File(File(dir, FD_JARS), FN_CLASSES_JAR))
+            outJarFile.set(File(File(dir, FD_JARS), "$path$DOT_JAR"))
+            outputs.file("$path/$FD_JARS/$path$DOT_JAR")
+
+            return outputs.dir(path)
+          }
+
+          override fun file(path: Any): File {
+            error("Shouldn't be called")
+          }
+        }
+
+      super.transform(transformOutputs)
+
+      classesJarFile.get().renameTo(outJarFile.get())
+    }
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/AggregateJavadocPlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/AggregateJavadocPlugin.kt
new file mode 100644
index 000000000..4f399e1f2
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/AggregateJavadocPlugin.kt
@@ -0,0 +1,49 @@
+package org.robolectric.gradle
+
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.plugins.JavaBasePlugin
+import org.gradle.api.tasks.javadoc.Javadoc
+import org.gradle.kotlin.dsl.register
+
+/**
+ * Modified from https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin.
+ *
+ * The origin license is Apache v2:
+ * https://github.com/nebula-plugins/gradle-aggregate-javadocs-plugin/blob/master/LICENSE.
+ */
+class AggregateJavadocPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    val rootProject = project.rootProject
+    // This plugin only works on the root project.
+    if (project != rootProject) {
+      return
+    }
+
+    rootProject.gradle.projectsEvaluated {
+      val javadocTasks = getJavadocTasks(rootProject)
+      if (javadocTasks.isNotEmpty()) {
+        rootProject.tasks.register<Javadoc>(AGGREGATE_JAVADOCS_TASK_NAME) {
+          description = "Aggregates Javadoc API documentation of all subprojects."
+          group = JavaBasePlugin.DOCUMENTATION_GROUP
+
+          dependsOn(javadocTasks)
+          source(javadocTasks.map { it.source })
+
+          val javadocDirectory = rootProject.layout.buildDirectory.dir("docs/javadoc").get().asFile
+
+          setDestinationDir(javadocDirectory)
+          classpath = rootProject.files(javadocTasks.map { it.classpath })
+        }
+      }
+    }
+  }
+
+  private fun getJavadocTasks(project: Project): Set<Javadoc> {
+    return project.getAllTasks(true).values.flatten().filterIsInstance<Javadoc>().toSet()
+  }
+
+  private companion object {
+    private const val AGGREGATE_JAVADOCS_TASK_NAME = "aggregateJavadocs"
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/AndroidProjectConfigPlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/AndroidProjectConfigPlugin.kt
new file mode 100644
index 000000000..9f0cb3a9d
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/AndroidProjectConfigPlugin.kt
@@ -0,0 +1,92 @@
+package org.robolectric.gradle
+
+import ProvideBuildClasspathTask
+import com.android.SdkConstants.FD_GENERATED
+import com.android.build.api.dsl.LibraryExtension
+import java.io.File
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.tasks.testing.Test
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+import org.gradle.api.tasks.testing.logging.TestLogEvent
+import org.gradle.kotlin.dsl.configure
+import org.gradle.kotlin.dsl.register
+import org.gradle.kotlin.dsl.withType
+
+class AndroidProjectConfigPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.pluginManager.apply("com.android.library")
+
+    project.tasks.withType<Test>().configureEach {
+      // TODO: DRY up code with RoboJavaModulePlugin...
+      testLogging {
+        exceptionFormat = TestExceptionFormat.FULL
+        showCauses = true
+        showExceptions = true
+        showStackTraces = true
+        showStandardStreams = true
+        events = setOf(TestLogEvent.FAILED, TestLogEvent.SKIPPED)
+      }
+
+      minHeapSize = "2g"
+      maxHeapSize = "12g"
+
+      System.getenv("GRADLE_MAX_PARALLEL_FORKS")?.toIntOrNull()?.let { maxParallelForks = it }
+
+      val systemJvmArgs =
+        System.getProperties()
+          .filterKeys { it.toString().startsWith("robolectric.") }
+          .map { (key, value) -> "-D$key=$value" }
+      val defaultJvmArgs =
+        listOf(
+          "--add-opens=java.base/java.lang=ALL-UNNAMED",
+          "--add-opens=java.base/java.lang.reflect=ALL-UNNAMED",
+          "--add-opens=java.base/java.io=ALL-UNNAMED",
+          "--add-opens=java.base/java.net=ALL-UNNAMED",
+          "--add-opens=java.base/java.nio=ALL-UNNAMED", // required for ShadowVMRuntime
+          "--add-opens=java.base/java.security=ALL-UNNAMED",
+          "--add-opens=java.base/java.text=ALL-UNNAMED",
+          "--add-opens=java.base/java.util=ALL-UNNAMED",
+          "--add-opens=java.base/jdk.internal.access=ALL-UNNAMED",
+          "--add-opens=java.desktop/java.awt.font=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
+        )
+
+      jvmArgs = systemJvmArgs + defaultJvmArgs
+
+      doFirst {
+        if (systemJvmArgs.isNotEmpty()) {
+          println("Running tests with $systemJvmArgs")
+        }
+      }
+    }
+
+    project.tasks.register<ProvideBuildClasspathTask>("provideBuildClasspath") {
+      val outDir = project.layout.buildDirectory.dir("$FD_GENERATED/robolectric").get().asFile
+
+      outFile = File(outDir, "robolectric-deps.properties")
+
+      project.extensions.configure<LibraryExtension> {
+        sourceSets.getByName("test").resources.srcDir(outDir)
+      }
+    }
+
+    project.afterEvaluate {
+      project.tasks.forEach { task ->
+        if (task.name.matches(UNIT_TEST_JAVA_RES_TASK_NAME_REGEX)) {
+          task.dependsOn("provideBuildClasspath")
+        }
+      }
+    }
+
+    // Only run tests in the debug variant. This is to avoid running tests twice when
+    // `./gradlew test` is run at the top-level.
+    project.tasks.withType<Test>().configureEach { onlyIf { name.lowercase().contains("debug") } }
+  }
+
+  private companion object {
+    private val UNIT_TEST_JAVA_RES_TASK_NAME_REGEX = "process.*UnitTestJavaRes".toRegex()
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt
new file mode 100644
index 000000000..14957ae23
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/DeployedRoboJavaModulePlugin.kt
@@ -0,0 +1,145 @@
+package org.robolectric.gradle
+
+import java.net.URI
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.plugins.BasePluginExtension
+import org.gradle.api.plugins.JavaPluginExtension
+import org.gradle.api.publish.PublishingExtension
+import org.gradle.api.publish.maven.MavenPublication
+import org.gradle.api.tasks.javadoc.Javadoc
+import org.gradle.external.javadoc.StandardJavadocDocletOptions
+import org.gradle.jvm.tasks.Jar
+import org.gradle.kotlin.dsl.configure
+import org.gradle.kotlin.dsl.register
+import org.gradle.kotlin.dsl.withType
+import org.gradle.plugins.signing.SigningExtension
+
+class DeployedRoboJavaModulePlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.pluginManager.apply("signing")
+    project.pluginManager.apply("java-library")
+    project.pluginManager.apply("maven-publish")
+
+    val projectVersion = project.version.toString()
+    val isSnapshotVersion = projectVersion.endsWith("-SNAPSHOT")
+    val mavenArtifactName = project.path.substring(1).split(":").joinToString("-")
+
+    project.extensions.configure<BasePluginExtension> {
+      // For Maven local install
+      archivesName.set(mavenArtifactName)
+    }
+
+    project.extensions.configure<JavaPluginExtension> {
+      val sourcesJar =
+        project.tasks.register<Jar>("sourcesJar") {
+          dependsOn(project.tasks.named("classes"))
+          archiveClassifier.set("sources")
+          from(sourceSets.getByName("main").allJava)
+        }
+
+      val javadocJar =
+        project.tasks.register<Jar>("javadocJar") {
+          val javadocTask = project.tasks.withType<Javadoc>()
+
+          dependsOn(javadocTask)
+          archiveClassifier.set("javadoc")
+          from(javadocTask.map { it.destinationDir })
+        }
+
+      project.tasks.withType<Javadoc> {
+        isFailOnError = false
+        source = sourceSets.getByName("main").allJava
+
+        val extraNavItem =
+          """
+          <ul class="navList">
+              <li>Robolectric $projectVersion | <a href="/">Home</a></li>
+          </ul>
+          """
+            .trimIndent()
+        val javadocOptions = options as StandardJavadocDocletOptions
+        javadocOptions.noTimestamp(true)
+        javadocOptions.header = extraNavItem
+        javadocOptions.footer = extraNavItem
+      }
+
+      project.extensions.configure<PublishingExtension> {
+        publications {
+          register<MavenPublication>("mavenJava") {
+            val skipJavadoc = System.getenv("SKIP_JAVADOC") == "true"
+
+            from(project.components.getByName("java"))
+
+            artifact(sourcesJar)
+            if (!skipJavadoc) {
+              artifact(javadocJar)
+            }
+
+            artifactId = mavenArtifactName
+
+            pom {
+              name.set(project.name)
+              description.set("An alternative Android testing framework.")
+              url.set("http://robolectric.org")
+
+              licenses {
+                license {
+                  name.set("The MIT License")
+                  url.set("https://opensource.org/licenses/MIT")
+                }
+              }
+
+              scm {
+                url.set("git@github.com:robolectric/robolectric.git")
+                connection.set("scm:git:git://github.com/robolectric/robolectric.git")
+                developerConnection.set("scm:git:https://github.com/robolectric/robolectric.git")
+              }
+
+              developers {
+                developer {
+                  name.set("Brett Chabot")
+                  email.set("brettchabot@google.com")
+                  organization.set("Google Inc.")
+                  organizationUrl.set("http://google.com")
+                }
+
+                developer {
+                  name.set("Michael Hoisie")
+                  email.set("hoisie@google.com")
+                  organization.set("Google Inc.")
+                  organizationUrl.set("http://google.com")
+                }
+
+                developer {
+                  name.set("Christian Williams")
+                  email.set("antixian666@gmail.com")
+                }
+              }
+            }
+          }
+        }
+
+        repositories {
+          maven {
+            val releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
+            val snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
+
+            url = if (isSnapshotVersion) URI(snapshotsRepoUrl) else URI(releasesRepoUrl)
+
+            credentials {
+              username = System.getProperty("sonatype-login", System.getenv("SONATYPE_LOGIN"))
+              password = System.getProperty("sonatype-password", System.getenv("SONATYPE_PASSWORD"))
+            }
+          }
+        }
+
+        project.extensions.configure<SigningExtension> {
+          setRequired { !isSnapshotVersion && project.gradle.taskGraph.hasTask("uploadArchives") }
+
+          sign(publications.getByName("mavenJava"))
+        }
+      }
+    }
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt
new file mode 100644
index 000000000..d6f410c49
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/GradleManagedDevicePlugin.kt
@@ -0,0 +1,89 @@
+package org.robolectric.gradle
+
+import com.android.build.api.dsl.CommonExtension
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.kotlin.dsl.findByType
+import org.gradle.kotlin.dsl.get
+
+class GradleManagedDevicePlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    val androidExtension = project.extensions.findByType(CommonExtension::class)
+    if (androidExtension == null) {
+      project.logger.warn(
+        "Not applying the '{}' plugin on project '{}' because it is not an Android project",
+        this::class.simpleName,
+        project.path,
+      )
+      return
+    }
+
+    @Suppress("UnstableApiUsage")
+    androidExtension.testOptions {
+      animationsDisabled = true
+
+      managedDevices {
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi29DebugAndroidTest
+        localDevices.register(NAME_API_29) {
+          device = "Nexus One"
+          apiLevel = 29
+          systemImageSource = "aosp"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi30DebugAndroidTest
+        localDevices.register(NAME_API_30) {
+          device = "Nexus One"
+          apiLevel = 30
+          systemImageSource = "aosp-atd"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi31DebugAndroidTest
+        localDevices.register(NAME_API_31) {
+          device = "Nexus One"
+          apiLevel = 31
+          systemImageSource = "aosp-atd"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi32DebugAndroidTest
+        localDevices.register(NAME_API_32) {
+          device = "Nexus One"
+          apiLevel = 32
+          systemImageSource = "aosp-atd"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi33DebugAndroidTest
+        localDevices.register(NAME_API_33) {
+          device = "Nexus One"
+          apiLevel = 33
+          systemImageSource = "aosp-atd"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneApi34DebugAndroidTest
+        localDevices.register(NAME_API_34) {
+          device = "Nexus One"
+          apiLevel = 34
+          systemImageSource = "aosp-atd"
+        }
+
+        // ./gradlew -Pandroid.sdk.channel=3 nexusOneIntegrationTestGroupDebugAndroidTest
+        groups.register("nexusOneIntegrationTestGroup") {
+          targetDevices.add(devices[NAME_API_29])
+          targetDevices.add(devices[NAME_API_30])
+          targetDevices.add(devices[NAME_API_31])
+          targetDevices.add(devices[NAME_API_32])
+          targetDevices.add(devices[NAME_API_33])
+          targetDevices.add(devices[NAME_API_34])
+        }
+      } // managedDevices
+    } // testOptions
+  } // apply
+
+  private companion object {
+    private const val NAME_API_29 = "nexusOneApi29"
+    private const val NAME_API_30 = "nexusOneApi30"
+    private const val NAME_API_31 = "nexusOneApi31"
+    private const val NAME_API_32 = "nexusOneApi32"
+    private const val NAME_API_33 = "nexusOneApi33"
+    private const val NAME_API_34 = "nexusOneApi34"
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt
new file mode 100644
index 000000000..33288df0a
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/RoboJavaModulePlugin.kt
@@ -0,0 +1,111 @@
+package org.robolectric.gradle
+
+import ProvideBuildClasspathTask
+import java.io.File
+import org.gradle.api.JavaVersion
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.artifacts.VersionCatalog
+import org.gradle.api.artifacts.VersionCatalogsExtension
+import org.gradle.api.plugins.JavaPluginExtension
+import org.gradle.api.tasks.compile.JavaCompile
+import org.gradle.api.tasks.testing.Test
+import org.gradle.api.tasks.testing.logging.TestExceptionFormat
+import org.gradle.api.tasks.testing.logging.TestLogEvent
+import org.gradle.kotlin.dsl.configure
+import org.gradle.kotlin.dsl.getByType
+import org.gradle.kotlin.dsl.register
+import org.gradle.kotlin.dsl.withType
+
+class RoboJavaModulePlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.pluginManager.apply("java-library")
+    project.pluginManager.apply("org.robolectric.gradle.AarDepsPlugin")
+
+    val skipErrorProne = System.getenv("SKIP_ERRORPRONE") == "true"
+    if (!skipErrorProne) {
+      project.pluginManager.apply("net.ltgt.errorprone")
+      project.dependencies.add("errorprone", project.libs.findLibrary("error-prone-core").get())
+      project.dependencies.add(
+        "errorproneJavac",
+        project.libs.findLibrary("error-prone-javac").get(),
+      )
+    }
+
+    project.tasks.withType<JavaCompile>().configureEach {
+      sourceCompatibility = JavaVersion.VERSION_1_8.toString()
+      targetCompatibility = JavaVersion.VERSION_1_8.toString()
+
+      // Show all warnings except boot classpath
+      if (System.getProperty("lint") != null && System.getProperty("lint") != "false") {
+        options.compilerArgs.add("-Xlint:all") // Turn on all warnings
+      }
+
+      options.compilerArgs.add("-Xlint:-options") // Turn off "missing" bootclasspath warning
+      options.encoding = "utf-8" // Make sure source encoding is UTF-8
+    }
+
+    val provideBuildClasspath =
+      project.tasks.register<ProvideBuildClasspathTask>("provideBuildClasspath") {
+        project.extensions.configure<JavaPluginExtension> {
+          val outDir = sourceSets.getByName("test").output.resourcesDir
+
+          outFile = File(outDir, "robolectric-deps.properties")
+        }
+      }
+
+    project.tasks.withType<Test>().configureEach {
+      dependsOn(provideBuildClasspath)
+
+      // Otherwise Gradle runs static inner classes like TestRunnerSequenceTest$SimpleTest
+      exclude("**/*\$*")
+
+      // TODO: DRY up code with AndroidProjectConfigPlugin...
+      testLogging {
+        exceptionFormat = TestExceptionFormat.FULL
+        showCauses = true
+        showExceptions = true
+        showStackTraces = true
+        showStandardStreams = true
+        events = setOf(TestLogEvent.FAILED, TestLogEvent.SKIPPED)
+      }
+
+      minHeapSize = "2g"
+      maxHeapSize = "12g"
+
+      System.getenv("GRADLE_MAX_PARALLEL_FORKS")?.toIntOrNull()?.let { maxParallelForks = it }
+
+      val systemJvmArgs =
+        System.getProperties()
+          .filterKeys { it.toString().startsWith("robolectric.") }
+          .map { (key, value) -> "-D$key=$value" }
+      val defaultJvmArgs =
+        listOf(
+          "--add-opens=java.base/java.lang=ALL-UNNAMED",
+          "--add-opens=java.base/java.lang.reflect=ALL-UNNAMED",
+          "--add-opens=java.base/java.io=ALL-UNNAMED",
+          "--add-opens=java.base/java.net=ALL-UNNAMED",
+          "--add-opens=java.base/java.nio=ALL-UNNAMED", // required for ShadowVMRuntime
+          "--add-opens=java.base/java.security=ALL-UNNAMED",
+          "--add-opens=java.base/java.text=ALL-UNNAMED",
+          "--add-opens=java.base/java.util=ALL-UNNAMED",
+          "--add-opens=java.base/jdk.internal.access=ALL-UNNAMED",
+          "--add-opens=java.desktop/java.awt.font=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
+          "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
+        )
+
+      jvmArgs = systemJvmArgs + defaultJvmArgs
+
+      doFirst {
+        if (systemJvmArgs.isNotEmpty()) {
+          println("Running tests with $systemJvmArgs")
+        }
+      }
+    }
+  }
+
+  private val Project.libs: VersionCatalog
+    get() = extensions.getByType<VersionCatalogsExtension>().named("libs")
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/ShadowsPlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/ShadowsPlugin.kt
new file mode 100644
index 000000000..a476b4beb
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/ShadowsPlugin.kt
@@ -0,0 +1,92 @@
+package org.robolectric.gradle
+
+import com.android.SdkConstants.DOT_JAVA
+import com.android.SdkConstants.FD_GENERATED
+import com.android.SdkConstants.FD_MAIN
+import com.android.SdkConstants.SRC_FOLDER
+import java.io.File
+import java.util.jar.JarFile
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.tasks.compile.JavaCompile
+import org.gradle.api.tasks.javadoc.Javadoc
+import org.gradle.jvm.tasks.Jar
+import org.gradle.kotlin.dsl.create
+import org.gradle.kotlin.dsl.extra
+import org.gradle.kotlin.dsl.named
+import org.gradle.kotlin.dsl.provideDelegate
+import org.gradle.kotlin.dsl.withType
+
+class ShadowsPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.pluginManager.apply("idea")
+
+    val shadows = project.extensions.create<ShadowsPluginExtension>("shadows")
+
+    project.dependencies.add("annotationProcessor", project.project(":processor"))
+
+    // Write generated Java into its own dir. See https://github.com/gradle/gradle/issues/4956
+    val generatedSrcDir =
+      project.layout.buildDirectory.dir("$FD_GENERATED/$SRC_FOLDER/apt/$FD_MAIN")
+
+    project.tasks.named<JavaCompile>("compileJava").configure {
+      options.generatedSourceOutputDirectory.set(generatedSrcDir)
+
+      doFirst {
+        val jsonDocsDir = project.layout.buildDirectory.dir("docs/json").get().asFile
+        val sdks = project.rootProject.layout.buildDirectory.file("sdks.txt").get().asFile
+
+        with(options.compilerArgs) {
+          add("-Aorg.robolectric.annotation.processing.jsonDocsEnabled=true")
+          add("-Aorg.robolectric.annotation.processing.jsonDocsDir=$jsonDocsDir")
+          add("-Aorg.robolectric.annotation.processing.shadowPackage=${shadows.packageName}")
+          add("-Aorg.robolectric.annotation.processing.sdkCheckMode=${shadows.sdkCheckMode}")
+          add("-Aorg.robolectric.annotation.processing.sdks=$sdks")
+        }
+      }
+    }
+
+    // Include the generated sources in the Javadoc jar
+    project.tasks.named<Javadoc>("javadoc").configure { source(generatedSrcDir) }
+
+    // Verify that we have the apt-generated files in our Javadoc and sources jars
+    project.tasks.named<Jar>("javadocJar").configure {
+      doLast {
+        val shadowPackageNameDir = shadows.packageName.replace('.', '/')
+        checkForFile(archiveFile.get().asFile, "$shadowPackageNameDir/Shadows.html")
+      }
+    }
+
+    project.tasks.named<Jar>("sourcesJar").configure {
+      from(generatedSrcDir)
+      doLast {
+        val shadowPackageNameDir = shadows.packageName.replace('.', '/')
+        checkForFile(archiveFile.get().asFile, "$shadowPackageNameDir/Shadows$DOT_JAVA")
+      }
+    }
+
+    var configAnnotationProcessing: List<Project> by project.rootProject.extra
+    configAnnotationProcessing += project
+
+    // Prevents sporadic compilation error:
+    // 'Bad service configuration file, or exception thrown while constructing
+    //  Processor object: javax.annotation.processing.Processor: Error reading
+    //  configuration file'
+    //
+    // See https://discuss.gradle.org/t/gradle-not-compiles-with-solder-tooling-jar/7583/20
+    project.tasks.withType<JavaCompile>().configureEach { options.isFork = true }
+  }
+
+  abstract class ShadowsPluginExtension {
+    abstract var packageName: String
+    var sdkCheckMode: String = "WARN"
+  }
+
+  private companion object {
+    private fun checkForFile(jar: File, name: String) {
+      val hasFile = JarFile(jar).entries().asSequence().any { it.name == name }
+
+      check(hasFile) { "Missing file $name in $jar" }
+    }
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/SpotlessPlugin.kt b/buildSrc/src/main/java/org/robolectric/gradle/SpotlessPlugin.kt
new file mode 100644
index 000000000..44402fd89
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/SpotlessPlugin.kt
@@ -0,0 +1,39 @@
+package org.robolectric.gradle
+
+import com.diffplug.gradle.spotless.SpotlessExtension
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.kotlin.dsl.configure
+
+class SpotlessPlugin : Plugin<Project> {
+  override fun apply(project: Project) {
+    project.pluginManager.apply("com.diffplug.spotless")
+
+    project.extensions.configure<SpotlessExtension> {
+      // Add configurations for Kotlin files
+      kotlin {
+        target("**/*.kt")
+        ktfmt("0.49").googleStyle()
+      }
+
+      // Add configurations for Kotlin Gradle files
+      kotlinGradle {
+        target("**/*.kts")
+        ktfmt("0.49").googleStyle()
+      }
+
+      // Only apply yaml and json formatting for root project
+      // to avoid some files are added into multiple project's spotless targets.
+      if (project.rootProject == project) {
+        // Add configurations for JSON files
+        json {
+          target("**/*.json")
+          gson()
+            .indentWithSpaces(2) // Follow code's indent.
+            .sortByKeys()
+            .escapeHtml()
+        }
+      }
+    }
+  }
+}
diff --git a/buildSrc/src/main/java/org/robolectric/gradle/agp/ExtractAarTransform.kt b/buildSrc/src/main/java/org/robolectric/gradle/agp/ExtractAarTransform.kt
new file mode 100644
index 000000000..8393591ef
--- /dev/null
+++ b/buildSrc/src/main/java/org/robolectric/gradle/agp/ExtractAarTransform.kt
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This class comes from AGP internals:
+ * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:build-system/gradle-core/src/main/java/com/android/build/gradle/internal/dependency/ExtractAarTransform.kt;bpv=0
+ */
+
+package org.robolectric.gradle.agp
+
+import com.android.SdkConstants
+import com.android.utils.FileUtils
+import com.google.common.annotations.VisibleForTesting
+import com.google.common.io.Files
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.util.jar.JarOutputStream
+import java.util.zip.ZipInputStream
+import org.gradle.api.artifacts.transform.InputArtifact
+import org.gradle.api.artifacts.transform.TransformAction
+import org.gradle.api.artifacts.transform.TransformOutputs
+import org.gradle.api.file.FileSystemLocation
+import org.gradle.api.provider.Provider
+import org.gradle.api.tasks.Classpath
+import org.gradle.work.DisableCachingByDefault
+
+/**
+ * Transform that extracts an AAR file into a directory.
+ *
+ * Note: There are small adjustments made to the extracted contents (see [AarExtractor.extract]).
+ */
+@DisableCachingByDefault(because = "Copy task")
+abstract class ExtractAarTransform : TransformAction<GenericTransformParameters> {
+
+  @get:Classpath @get:InputArtifact abstract val aarFile: Provider<FileSystemLocation>
+
+  override fun transform(outputs: TransformOutputs) {
+    // TODO: record transform execution span
+    val inputFile = aarFile.get().asFile
+    val outputDir = outputs.dir(inputFile.nameWithoutExtension)
+    FileUtils.mkdirs(outputDir)
+    AarExtractor().extract(inputFile, outputDir)
+  }
+}
+
+private const val LIBS_PREFIX = SdkConstants.LIBS_FOLDER + '/'
+private const val LIBS_PREFIX_LENGTH = LIBS_PREFIX.length
+private const val JARS_PREFIX_LENGTH = SdkConstants.FD_JARS.length + 1
+
+@VisibleForTesting
+internal class AarExtractor {
+
+  /**
+   * [StringBuilder] used to construct all paths. It gets truncated back to [JARS_PREFIX_LENGTH] on
+   * every calculation.
+   */
+  private val stringBuilder =
+    StringBuilder(60).apply {
+      append(SdkConstants.FD_JARS)
+      append(File.separatorChar)
+    }
+
+  private fun choosePathInOutput(entryName: String): String {
+    stringBuilder.setLength(JARS_PREFIX_LENGTH)
+
+    return when {
+      entryName == SdkConstants.FN_CLASSES_JAR || entryName == SdkConstants.FN_LINT_JAR -> {
+        stringBuilder.append(entryName)
+        stringBuilder.toString()
+      }
+      entryName.startsWith(LIBS_PREFIX) -> {
+        // In case we have libs/classes.jar we are going to rename them, due an issue in
+        // Gradle.
+        // TODO: stop doing this once this is fixed in gradle.
+        when (val pathWithinLibs = entryName.substring(LIBS_PREFIX_LENGTH)) {
+          SdkConstants.FN_CLASSES_JAR ->
+            stringBuilder.append(LIBS_PREFIX).append("classes-2${SdkConstants.DOT_JAR}")
+          SdkConstants.FN_LINT_JAR ->
+            stringBuilder.append(LIBS_PREFIX).append("lint-2${SdkConstants.DOT_JAR}")
+          else -> stringBuilder.append(LIBS_PREFIX).append(pathWithinLibs)
+        }
+        stringBuilder.toString()
+      }
+      else -> entryName
+    }
+  }
+
+  /**
+   * Extracts an AAR file into a directory.
+   *
+   * Note: There are small adjustments made to the extracted contents. For example, classes.jar
+   * inside the AAR will be extracted to jars/classes.jar, and if the jar does not exist, we will
+   * create an empty classes.jar.
+   */
+  fun extract(aar: File, outputDir: File) {
+    ZipInputStream(aar.inputStream().buffered()).use { zipInputStream ->
+      while (true) {
+        val entry = zipInputStream.nextEntry ?: break
+        if (entry.isDirectory || entry.name.contains("../") || entry.name.isEmpty()) {
+          continue
+        }
+        val path = FileUtils.toSystemDependentPath(choosePathInOutput(entry.name))
+        val outputFile = File(outputDir, path)
+        Files.createParentDirs(outputFile)
+        Files.asByteSink(outputFile).writeFrom(zipInputStream)
+      }
+    }
+
+    // If classes.jar does not exist, create an empty one
+    val classesJar = outputDir.resolve("${SdkConstants.FD_JARS}/${SdkConstants.FN_CLASSES_JAR}")
+    if (!classesJar.exists()) {
+      Files.createParentDirs(classesJar)
+      classesJar.writeBytes(emptyJar)
+    }
+  }
+}
+
+private val emptyJar: ByteArray =
+  // Note:
+  //  - A jar doesn't need a manifest entry, but if we ever want to create a manifest entry, be
+  //    sure to set a fixed timestamp for it so that the jar is deterministic.
+  //  - This empty jar takes up only ~22 bytes, so we don't need to GC it at the end of the build.
+  ByteArrayOutputStream().apply { JarOutputStream(this).use {} }.toByteArray()
diff --git a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java b/buildSrc/src/main/java/org/robolectric/gradle/agp/GenericTransformParameters.kt
similarity index 65%
rename from buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java
rename to buildSrc/src/main/java/org/robolectric/gradle/agp/GenericTransformParameters.kt
index 820532311..7cf5ae0e4 100644
--- a/buildSrc/src/main/groovy/org/robolectric/gradle/agp/GenericTransformParameters.java
+++ b/buildSrc/src/main/java/org/robolectric/gradle/agp/GenericTransformParameters.kt
@@ -19,15 +19,13 @@
  * https://cs.android.com/android-studio/platform/tools/base/+/mirror-goog-studio-main:build-system/gradle-core/src/main/java/com/android/build/gradle/internal/dependency/GenericTransformParameters.kt;bpv=0
  */
 
-package org.robolectric.gradle.agp;
+package org.robolectric.gradle.agp
 
-import org.gradle.api.artifacts.transform.TransformParameters;
-import org.gradle.api.provider.Property;
-import org.gradle.api.tasks.Internal;
+import org.gradle.api.artifacts.transform.TransformParameters
+import org.gradle.api.provider.Property
+import org.gradle.api.tasks.Internal
 
-/** Generic {@link TransformParameters} for all of our Artifact Transforms. */
-// TODO Keep the original Kotlin implementation when `buildSrc` is migrated to Kotlin.
-public interface GenericTransformParameters extends TransformParameters {
-  @Internal
-  Property<String> getProjectName();
+/** Generic [TransformParameters] for all of our Artifact Transforms. */
+interface GenericTransformParameters : TransformParameters {
+  @get:Internal val projectName: Property<String>
 }
diff --git a/dependencies.gradle b/dependencies.gradle
deleted file mode 100644
index 86602da99..000000000
--- a/dependencies.gradle
+++ /dev/null
@@ -1,9 +0,0 @@
-ext {
-    // https://github.com/gradle/gradle/issues/21267
-    axtCoreVersion = libs.versions.androidx.test.core.get()
-    axtJunitVersion = libs.versions.androidx.test.ext.junit.get()
-    axtMonitorVersion = libs.versions.androidx.test.monitor.get()
-    axtRunnerVersion = libs.versions.androidx.test.runner.get()
-    axtTruthVersion = libs.versions.androidx.test.ext.truth.get()
-    espressoVersion = libs.versions.androidx.test.espresso.get()
-}
diff --git a/errorprone/build.gradle b/errorprone/build.gradle
deleted file mode 100644
index 6f8428d63..000000000
--- a/errorprone/build.gradle
+++ /dev/null
@@ -1,43 +0,0 @@
-import org.gradle.internal.jvm.Jvm
-
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-// Disable annotation processor for tests
-compileTestJava {
-    options.compilerArgs.add("-proc:none")
-}
-
-test {
-    enabled = false
-}
-
-dependencies {
-    // Project dependencies
-    implementation project(":annotations")
-    implementation project(":shadowapi")
-
-    // Compile dependencies
-    implementation libs.error.prone.annotations
-    implementation libs.error.prone.refaster
-    implementation libs.error.prone.check.api
-    compileOnly libs.auto.service.annotations
-    compileOnly(AndroidSdk.MAX_SDK.coordinates)
-
-    annotationProcessor libs.auto.service
-    annotationProcessor libs.error.prone.core
-
-    // in jdk 9, tools.jar disappears!
-    def toolsJar = Jvm.current().getToolsJar()
-    if (toolsJar != null) {
-        compile files(toolsJar)
-    }
-
-    // Testing dependencies
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.error.prone.test.helpers
-    testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
-}
diff --git a/errorprone/build.gradle.kts b/errorprone/build.gradle.kts
new file mode 100644
index 000000000..ad3f3165f
--- /dev/null
+++ b/errorprone/build.gradle.kts
@@ -0,0 +1,39 @@
+import org.gradle.internal.jvm.Jvm
+
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+// Disable annotation processor for tests
+tasks.compileTestJava.configure { options.compilerArgs.add("-proc:none") }
+
+tasks.test.configure { enabled = false }
+
+dependencies {
+  // Project dependencies
+  implementation(project(":annotations"))
+  implementation(project(":shadowapi"))
+
+  // Compile dependencies
+  implementation(libs.error.prone.annotations)
+  implementation(libs.error.prone.refaster)
+  implementation(libs.error.prone.check.api)
+  compileOnly(libs.auto.service.annotations)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  annotationProcessor(libs.auto.service)
+  annotationProcessor(libs.error.prone.core)
+
+  // In JDK 9, tools.jar disappears!
+  val toolsJar = Jvm.current().getToolsJar()
+  if (toolsJar != null) {
+    "compile"(files(toolsJar))
+  }
+
+  // Testing dependencies
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.error.prone.test.helpers)
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+}
diff --git a/gradle.properties b/gradle.properties
index f31bcb2c8..124dca9e4 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
-thisVersion=4.13-SNAPSHOT
+thisVersion=4.14-SNAPSHOT
 
 # This project uses AndroidX instead of Support Libraries
 # https://developer.android.com/jetpack/androidx/migrate#migrate_an_existing_project_using_android_studio
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 49280f850..511e5ca26 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,10 +1,13 @@
 [versions]
-robolectric-nativeruntime-dist-compat = "1.0.14"
+robolectric-nativeruntime-dist-compat = "1.0.16"
 
 # https://developer.android.com/studio/releases
-android-gradle = "8.5.0"
+android-gradle = "8.6.0"
 
-android-tools-common = "31.5.0"
+android-tools-common = "31.6.0"
+
+# The runtime dependency for Android classes when Robolectric tests are run
+androidstubs = "34"
 
 # https://github.com/google/conscrypt/tags
 conscrypt = "2.5.2"
@@ -26,16 +29,16 @@ error-prone-javac = "9+181-r4173-1"
 error-prone-gradle = "3.1.0"
 
 # https://kotlinlang.org/docs/releases.html#release-details
-kotlin = "2.0.0"
+kotlin = "2.0.20"
 
 # https://github.com/Kotlin/kotlinx.coroutines/releases/
-kotlinx-coroutines = '1.8.1'
+kotlinx-coroutines = '1.9.0'
 
 # https://github.com/diffplug/spotless/blob/main/plugin-gradle/CHANGES.md
 spotless-gradle = "6.25.0"
 
 # https://detekt.dev/changelog
-detekt-gradle = "1.23.6"
+detekt-gradle = "1.23.7"
 
 # https://hc.apache.org/news.html
 apache-http-core = "4.0.1"
@@ -76,7 +79,7 @@ javax-inject = "1"
 junit4 = "4.13.2"
 
 # https://github.com/google/libphonenumber/releases
-libphonenumber = "8.13.40"
+libphonenumber = "8.13.46"
 
 # https://github.com/mockito/mockito/releases
 mockito = "4.11.0"
@@ -85,7 +88,7 @@ mockito = "4.11.0"
 mockk = "1.13.7"
 
 # https://github.com/takahirom/roborazzi/releases
-roborazzi = "1.20.0"
+roborazzi = "1.26.0"
 
 # https://square.github.io/okhttp/changelogs/changelog/
 okhttp = "4.12.0"
@@ -93,27 +96,32 @@ okhttp = "4.12.0"
 # https://github.com/powermock/powermock/releases
 powermock = "2.0.9"
 
+snakeyaml = "2.3"
+
 sqlite4java = "1.0.392"
 
 # https://developer.android.com/jetpack/androidx/versions
-androidx-annotation = "1.8.0"
+androidx-annotation = "1.8.2"
 androidx-appcompat = "1.7.0"
 androidx-biometric = "1.1.0"
 androidx-constraintlayout = "2.1.4"
 androidx-core = "1.13.1"
-androidx-fragment = "1.8.1"
+androidx-fragment = "1.8.3"
 androidx-multidex = "2.0.1"
 androidx-window = "1.3.0"
 androidx-room = "2.6.1"
 
+# https://maven.google.com/web/index.html?q=multidex#com.android.support:multidex
+android-multidex = "1.0.3"
+
 # https://github.com/android/android-test/tags
-androidx-test-core = "1.5.0"
-androidx-test-espresso = "3.5.1"
-androidx-test-ext-junit = "1.1.5"
-androidx-test-ext-truth = "1.5.0"
-androidx-test-monitor = "1.6.1"
-androidx-test-runner = "1.5.2"
-androidx-test-services = "1.4.2"
+androidx-test-core = "1.6.1"
+androidx-test-espresso = "3.6.1"
+androidx-test-ext-junit = "1.2.1"
+androidx-test-ext-truth = "1.6.0"
+androidx-test-monitor = "1.7.2"
+androidx-test-runner = "1.6.2"
+androidx-test-services = "1.5.0"
 
 # for shadows/playservices/build.gradle
 androidx-fragment-for-shadows = "1.2.0"
@@ -143,7 +151,6 @@ apache-http-client = { module = "org.apache.httpcomponents:httpclient", version.
 asm = { module = "org.ow2.asm:asm", version.ref = "asm" }
 asm-commons = { module = "org.ow2.asm:asm-commons", version.ref = "asm" }
 asm-util = { module = "org.ow2.asm:asm-util", version.ref = "asm" }
-asm-tree = { module = "org.ow2.asm:asm-tree", version.ref = "asm" }
 
 compile-testing = { module = "com.google.testing.compile:compile-testing", version.ref = "compile-testing" }
 
@@ -183,6 +190,8 @@ powermock-classloading-xstream = { module = "org.powermock:powermock-classloadin
 
 robolectric-nativeruntime-dist-compat = { module = "org.robolectric:nativeruntime-dist-compat", version.ref = "robolectric-nativeruntime-dist-compat" }
 
+snakeyaml = {module = "org.yaml:snakeyaml", version.ref="snakeyaml" }
+
 sqlite4java = { module = "com.almworks.sqlite4java:sqlite4java", version.ref = "sqlite4java" }
 sqlite4java-osx = { module = "com.almworks.sqlite4java:libsqlite4java-osx", version.ref = "sqlite4java" }
 sqlite4java-linux-amd64 = { module = "com.almworks.sqlite4java:libsqlite4java-linux-amd64", version.ref = "sqlite4java" }
@@ -230,6 +239,10 @@ play-services-basement-for-shadows = { module = "com.google.android.gms:play-ser
 
 play-services-basement = { module = "com.google.android.gms:play-services-basement", version.ref = "play-services-basement" }
 
+android-multidex = { module = "com.android.support:multidex", version.ref = "android-multidex" }
+
+spotless = { module = "com.diffplug.spotless:spotless-plugin-gradle", version.ref = "spotless-gradle" }
+
 [bundles]
 play-services-for-shadows = ["androidx-fragment-for-shadows", "play-services-auth-for-shadows", "play-services-base-for-shadows", "play-services-basement-for-shadows"]
 powermock = ["powermock-module-junit4", "powermock-module-junit4-rule", "powermock-api-mockito2", "powermock-classloading-xstream"]
@@ -240,12 +253,9 @@ android-library = { id = "com.android.library", version.ref = "android-gradle" }
 application = { id = "application" }
 detekt = { id = "io.gitlab.arturbosch.detekt", version.ref = "detekt-gradle" }
 error-prone = { id = "net.ltgt.errorprone", version.ref = "error-prone-gradle" }
-groovy = { id = "groovy" }
 idea = { id = "idea" }
 jacoco = { id = "jacoco" }
 java = { id = "java" }
-java-gradle-plugin = { id = "java-gradle-plugin" }
-java-library = { id = "java-library" }
 kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
 kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
 robolectric-android-project = { id = "org.robolectric.gradle.AndroidProjectConfigPlugin" }
@@ -256,4 +266,3 @@ robolectric-spotless = { id = "org.robolectric.gradle.SpotlessPlugin" }
 robolectric-shadows = { id = "org.robolectric.gradle.ShadowsPlugin" }
 robolectric-javadoc = { id = "org.robolectric.gradle.AggregateJavadocPlugin" }
 roborazzi = { id = "io.github.takahirom.roborazzi", version.ref = "roborazzi" }
-spotless = { id = "com.diffplug.spotless", version.ref = "spotless-gradle" }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index e6441136f..a4b76b953 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a4413138c..0aaefbcaf 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.8-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.1-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/gradlew b/gradlew
index b740cf133..f5feea6d6 100755
--- a/gradlew
+++ b/gradlew
@@ -15,6 +15,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
+# SPDX-License-Identifier: Apache-2.0
+#
 
 ##############################################################################
 #
@@ -84,7 +86,8 @@ done
 # shellcheck disable=SC2034
 APP_BASE_NAME=${0##*/}
 # Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
-APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit
+APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
+' "$PWD" ) || exit
 
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD=maximum
diff --git a/gradlew.bat b/gradlew.bat
index 7101f8e46..9b42019c7 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -13,6 +13,8 @@
 @rem See the License for the specific language governing permissions and
 @rem limitations under the License.
 @rem
+@rem SPDX-License-Identifier: Apache-2.0
+@rem
 
 @if "%DEBUG%"=="" @echo off
 @rem ##########################################################################
diff --git a/integration_tests/agp/build.gradle b/integration_tests/agp/build.gradle
deleted file mode 100644
index 27a85fa98..000000000
--- a/integration_tests/agp/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.agp'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions.unitTests.includeAndroidResources true
-}
-
-dependencies {
-    // Testing dependencies
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation project(":integration_tests:agp:testsupport")
-
-    testImplementation libs.junit4
-    testImplementation libs.androidx.test.core
-    testImplementation libs.androidx.test.runner
-    testImplementation libs.androidx.test.ext.junit
-}
diff --git a/integration_tests/agp/build.gradle.kts b/integration_tests/agp/build.gradle.kts
new file mode 100644
index 000000000..173340558
--- /dev/null
+++ b/integration_tests/agp/build.gradle.kts
@@ -0,0 +1,33 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.agp"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  // Testing dependencies
+  testImplementation(project(":testapp"))
+  testImplementation(project(":robolectric"))
+  testImplementation(project(":integration_tests:agp:testsupport"))
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.test.runner)
+  testImplementation(libs.androidx.test.ext.junit)
+}
diff --git a/integration_tests/agp/testsupport/build.gradle b/integration_tests/agp/testsupport/build.gradle
deleted file mode 100644
index 080a6186c..000000000
--- a/integration_tests/agp/testsupport/build.gradle
+++ /dev/null
@@ -1,22 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.agp.testsupport'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-}
-
-dependencies {
-    api project(":integration_tests:agp")
-}
diff --git a/integration_tests/agp/testsupport/build.gradle.kts b/integration_tests/agp/testsupport/build.gradle.kts
new file mode 100644
index 000000000..ff9790564
--- /dev/null
+++ b/integration_tests/agp/testsupport/build.gradle.kts
@@ -0,0 +1,17 @@
+plugins { alias(libs.plugins.android.library) }
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.agp.testsupport"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions.targetSdk = 34
+}
+
+dependencies { api(project(":integration_tests:agp")) }
diff --git a/integration_tests/androidx/build.gradle b/integration_tests/androidx/build.gradle
deleted file mode 100644
index c2b458de9..000000000
--- a/integration_tests/androidx/build.gradle
+++ /dev/null
@@ -1,45 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.androidx'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-
-}
-
-dependencies {
-    implementation libs.kotlinx.coroutines.android
-    implementation libs.androidx.appcompat
-    implementation libs.androidx.window
-
-    // Testing dependencies
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.androidx.test.core
-    testImplementation libs.androidx.core
-    testImplementation libs.androidx.test.runner
-    testImplementation libs.androidx.test.rules
-    testImplementation libs.androidx.test.espresso.intents
-    testImplementation libs.androidx.test.ext.truth
-    testImplementation libs.androidx.test.ext.junit
-    testImplementation libs.truth
-}
diff --git a/integration_tests/androidx/build.gradle.kts b/integration_tests/androidx/build.gradle.kts
new file mode 100644
index 000000000..138dab3a5
--- /dev/null
+++ b/integration_tests/androidx/build.gradle.kts
@@ -0,0 +1,40 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.androidx"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  implementation(libs.kotlinx.coroutines.android)
+  implementation(libs.androidx.appcompat)
+  implementation(libs.androidx.window)
+
+  // Testing dependencies
+  testImplementation(project(":testapp"))
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.core)
+  testImplementation(libs.androidx.test.runner)
+  testImplementation(libs.androidx.test.rules)
+  testImplementation(libs.androidx.test.espresso.intents)
+  testImplementation(libs.androidx.test.ext.truth)
+  testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.truth)
+}
diff --git a/integration_tests/androidx_test/build.gradle b/integration_tests/androidx_test/build.gradle
deleted file mode 100644
index 71bd9aecb..000000000
--- a/integration_tests/androidx_test/build.gradle
+++ /dev/null
@@ -1,76 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-    alias(libs.plugins.robolectric.gradle.managed.device)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integration.axt'
-
-    defaultConfig {
-        testApplicationId 'org.robolectric.integrationtests.axt'
-        minSdk 21
-        targetSdk 34
-        multiDexEnabled true
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-        testInstrumentationRunnerArguments useTestStorageService: 'true'
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-    sourceSets {
-        String sharedTestDir = 'src/sharedTest/'
-        String sharedTestSourceDir = sharedTestDir + 'java'
-        String sharedTestResourceDir = sharedTestDir + 'resources'
-        String sharedAndroidManifest = sharedTestDir + "AndroidManifest.xml"
-        test.resources.srcDirs += sharedTestResourceDir
-        test.java.srcDirs += sharedTestSourceDir
-        test.manifest.srcFile sharedAndroidManifest
-        androidTest.resources.srcDirs += sharedTestResourceDir
-        androidTest.java.srcDirs += sharedTestSourceDir
-        androidTest.manifest.srcFile sharedAndroidManifest
-    }
-}
-
-dependencies {
-    implementation libs.androidx.appcompat
-    implementation libs.androidx.constraintlayout
-    implementation libs.androidx.multidex
-
-    // Testing dependencies
-    testImplementation project(":robolectric")
-    testImplementation libs.androidx.test.runner
-    testImplementation libs.junit4
-    testImplementation libs.androidx.test.rules
-    testImplementation libs.androidx.test.espresso.intents
-    testImplementation libs.androidx.test.espresso.core
-    testImplementation libs.androidx.test.ext.truth
-    testImplementation libs.androidx.test.core
-    testImplementation libs.androidx.biometric
-    testImplementation libs.androidx.fragment
-    testImplementation libs.androidx.fragment.testing
-    testImplementation libs.androidx.test.ext.junit
-    testImplementation libs.truth
-
-    androidTestImplementation project(':annotations')
-    androidTestImplementation libs.androidx.test.runner
-    androidTestImplementation libs.junit4
-    androidTestImplementation libs.androidx.test.rules
-    androidTestImplementation libs.androidx.test.espresso.intents
-    androidTestImplementation libs.androidx.test.espresso.core
-    androidTestImplementation libs.androidx.test.ext.truth
-    androidTestImplementation libs.androidx.test.core
-    androidTestImplementation libs.androidx.test.ext.junit
-    androidTestImplementation platform(libs.kotlin.bom)
-    androidTestImplementation libs.truth
-    androidTestUtil libs.androidx.test.services
-}
diff --git a/integration_tests/androidx_test/build.gradle.kts b/integration_tests/androidx_test/build.gradle.kts
new file mode 100644
index 000000000..a9e52232e
--- /dev/null
+++ b/integration_tests/androidx_test/build.gradle.kts
@@ -0,0 +1,77 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.gradle.managed.device)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integration.axt"
+
+  defaultConfig {
+    testApplicationId = "org.robolectric.integrationtests.axt"
+    minSdk = 21
+    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArguments["useTestStorageService"] = "true"
+  }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+
+  sourceSets {
+    val sharedTestDir = "src/sharedTest/"
+    val sharedTestSourceDir = sharedTestDir + "java"
+    val sharedTestResourceDir = sharedTestDir + "resources"
+    val sharedAndroidManifest = sharedTestDir + "AndroidManifest.xml"
+
+    val test by getting
+    test.resources.srcDirs(sharedTestResourceDir)
+    test.java.srcDirs(sharedTestSourceDir)
+    test.manifest.srcFile(sharedAndroidManifest)
+
+    val androidTest by getting
+    androidTest.resources.srcDirs(sharedTestResourceDir)
+    androidTest.java.srcDirs(sharedTestSourceDir)
+    androidTest.manifest.srcFile(sharedAndroidManifest)
+  }
+}
+
+dependencies {
+  implementation(libs.androidx.appcompat)
+  implementation(libs.androidx.constraintlayout)
+
+  // Testing dependencies
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.androidx.test.runner)
+  testImplementation(libs.junit4)
+  testImplementation(libs.androidx.test.rules)
+  testImplementation(libs.androidx.test.espresso.intents)
+  testImplementation(libs.androidx.test.espresso.core)
+  testImplementation(libs.androidx.test.ext.truth)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.biometric)
+  testImplementation(libs.androidx.fragment)
+  testImplementation(libs.androidx.fragment.testing)
+  testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.truth)
+
+  androidTestImplementation(project(":annotations"))
+  androidTestImplementation(libs.androidx.test.runner)
+  androidTestImplementation(libs.junit4)
+  androidTestImplementation(libs.androidx.test.rules)
+  androidTestImplementation(libs.androidx.test.espresso.intents)
+  androidTestImplementation(libs.androidx.test.espresso.core)
+  androidTestImplementation(libs.androidx.test.ext.truth)
+  androidTestImplementation(libs.androidx.test.core)
+  androidTestImplementation(libs.androidx.test.ext.junit)
+  androidTestImplementation(platform(libs.kotlin.bom))
+  androidTestImplementation(libs.truth)
+  androidTestUtil(libs.androidx.test.services)
+}
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
index aecda6eec..aa1b70db7 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithMenuTest.java
@@ -5,21 +5,18 @@ import static androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
 import static androidx.test.espresso.action.ViewActions.click;
 import static androidx.test.espresso.matcher.ViewMatchers.withText;
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
 import androidx.test.core.app.ActivityScenario;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.TextLayoutMode;
 import org.robolectric.annotation.TextLayoutMode.Mode;
 
 /** Test Espresso on Robolectric interoperability for menus. */
 @RunWith(AndroidJUnit4.class)
 @TextLayoutMode(Mode.REALISTIC)
-@LooperMode(PAUSED)
 public class EspressoWithMenuTest {
 
   @Test
diff --git a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
index 7025be530..c2d68ea86 100644
--- a/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
+++ b/integration_tests/androidx_test/src/test/java/org/robolectric/integrationtests/axt/EspressoWithToolbarMenuTest.java
@@ -5,14 +5,12 @@ import static androidx.test.espresso.Espresso.openActionBarOverflowOrOptionsMenu
 import static androidx.test.espresso.action.ViewActions.click;
 import static androidx.test.espresso.matcher.ViewMatchers.withText;
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
 import androidx.test.core.app.ActivityScenario;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.TextLayoutMode;
 import org.robolectric.annotation.TextLayoutMode.Mode;
 import org.robolectric.shadows.ShadowViewConfiguration;
@@ -20,7 +18,6 @@ import org.robolectric.shadows.ShadowViewConfiguration;
 /** Test Espresso on Robolectric interoperability for toolbar menus. */
 @RunWith(AndroidJUnit4.class)
 @TextLayoutMode(Mode.REALISTIC)
-@LooperMode(PAUSED)
 public class EspressoWithToolbarMenuTest {
   @Test
   public void appCompatToolbarMenuClick() {
diff --git a/integration_tests/ctesque/Android.bp b/integration_tests/ctesque/Android.bp
index 01e2c82f5..099286628 100644
--- a/integration_tests/ctesque/Android.bp
+++ b/integration_tests/ctesque/Android.bp
@@ -8,9 +8,11 @@ android_robolectric_test {
         "src/sharedTest/**/*.java",
         "src/sharedTest/**/*.kt",
     ],
-    // TODO(b/325659920) To be add back once we properly support RNR in Android.
     exclude_srcs: [
-        "src/sharedTest/java/android/database/SQLiteDatabaseTest.java",
+        // TODO:  fix missing a local resource
+        "src/sharedTest/java/android/telephony/PhoneNumberUtilsTest.java",
+        // TODO:  tries to load the android native runtime and dies
+        "src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java",
     ],
     static_libs: [
         "androidx.core_core",
diff --git a/integration_tests/ctesque/build.gradle b/integration_tests/ctesque/build.gradle
deleted file mode 100644
index 019007b5e..000000000
--- a/integration_tests/ctesque/build.gradle
+++ /dev/null
@@ -1,73 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-    alias(libs.plugins.robolectric.gradle.managed.device)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.ctesque'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-    }
-
-    lintOptions {
-        abortOnError false
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-
-    compileOptions {
-        sourceCompatibility 1.8
-        targetCompatibility 1.8
-    }
-
-    aaptOptions {
-        noCompress 'txt'
-    }
-
-    sourceSets {
-        String sharedTestDir = 'src/sharedTest/'
-        String sharedTestSourceDir = sharedTestDir + 'java'
-        String sharedTestResourceDir = sharedTestDir + 'resources'
-        test.resources.srcDirs += sharedTestResourceDir
-        test.java.srcDirs += sharedTestSourceDir
-        androidTest.resources.srcDirs += sharedTestResourceDir
-        androidTest.java.srcDirs += sharedTestSourceDir
-    }
-}
-
-dependencies {
-    implementation project(':testapp')
-
-    testImplementation project(':robolectric')
-    testImplementation libs.junit4
-    testImplementation libs.androidx.test.monitor
-    testImplementation libs.androidx.test.runner
-    testImplementation libs.androidx.test.rules
-    testImplementation libs.androidx.test.ext.junit
-    testImplementation libs.androidx.test.ext.truth
-    testImplementation libs.androidx.test.core
-    testImplementation libs.androidx.test.espresso.core
-    testImplementation libs.truth
-    testImplementation libs.guava
-
-    // Testing dependencies
-    androidTestImplementation project(':shadowapi')
-    androidTestImplementation libs.androidx.test.monitor
-    androidTestImplementation libs.androidx.test.runner
-    androidTestImplementation libs.androidx.test.rules
-    androidTestImplementation libs.androidx.test.ext.junit
-    androidTestImplementation libs.androidx.test.ext.truth
-    androidTestImplementation libs.androidx.test.espresso.core
-    androidTestImplementation libs.truth
-    androidTestImplementation libs.guava
-    androidTestUtil libs.androidx.test.services
-}
diff --git a/integration_tests/ctesque/build.gradle.kts b/integration_tests/ctesque/build.gradle.kts
new file mode 100644
index 000000000..7ef425532
--- /dev/null
+++ b/integration_tests/ctesque/build.gradle.kts
@@ -0,0 +1,71 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.gradle.managed.device)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.ctesque"
+
+  defaultConfig {
+    minSdk = 21
+    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+  }
+
+  lint { abortOnError = false }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  androidResources { noCompress.add("txt") }
+
+  sourceSets {
+    val sharedTestDir = "src/sharedTest/"
+    val sharedTestSourceDir = sharedTestDir + "java"
+    val sharedTestResourceDir = sharedTestDir + "resources"
+
+    val test by getting
+    test.resources.srcDirs(sharedTestResourceDir)
+    test.java.srcDirs(sharedTestSourceDir)
+
+    val androidTest by getting
+    androidTest.resources.srcDirs(sharedTestResourceDir)
+    androidTest.java.srcDirs(sharedTestSourceDir)
+  }
+}
+
+dependencies {
+  implementation(project(":testapp"))
+
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.androidx.test.monitor)
+  testImplementation(libs.androidx.test.runner)
+  testImplementation(libs.androidx.test.rules)
+  testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.androidx.test.ext.truth)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.test.espresso.core)
+  testImplementation(libs.truth)
+  testImplementation(libs.guava)
+
+  // Testing dependencies
+  androidTestImplementation(project(":shadowapi"))
+  androidTestImplementation(libs.androidx.test.monitor)
+  androidTestImplementation(libs.androidx.test.runner)
+  androidTestImplementation(libs.androidx.test.rules)
+  androidTestImplementation(libs.androidx.test.ext.junit)
+  androidTestImplementation(libs.androidx.test.ext.truth)
+  androidTestImplementation(libs.androidx.test.espresso.core)
+  androidTestImplementation(libs.truth)
+  androidTestImplementation(libs.guava)
+  androidTestUtil(libs.androidx.test.services)
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/AccessibilityManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/AccessibilityManagerTest.java
new file mode 100644
index 000000000..11d4ed7d6
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/AccessibilityManagerTest.java
@@ -0,0 +1,73 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.accessibilityservice.AccessibilityServiceInfo;
+import android.content.Context;
+import android.view.accessibility.AccessibilityManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link AccessibilityManager}. */
+@RunWith(AndroidJUnit4.class)
+public class AccessibilityManagerTest {
+
+  @Test
+  public void accessibilityManager_applicationInstance_isSameAsActivityInstance() {
+    AccessibilityManager applicationAccessibilityManager =
+        (AccessibilityManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.ACCESSIBILITY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccessibilityManager activityAccessibilityManager =
+                (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
+            assertThat(applicationAccessibilityManager)
+                .isSameInstanceAs(activityAccessibilityManager);
+          });
+    }
+  }
+
+  @Test
+  public void accessibilityManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccessibilityManager activityAccessibilityManager =
+                (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
+            AccessibilityManager anotherActivityAccessibilityManager =
+                (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
+            assertThat(anotherActivityAccessibilityManager)
+                .isSameInstanceAs(activityAccessibilityManager);
+          });
+    }
+  }
+
+  @Test
+  public void accessibilityManager_instance_hasSameAccessibilityServices() {
+    AccessibilityManager applicationAccessibilityManager =
+        (AccessibilityManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.ACCESSIBILITY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AccessibilityManager activityAccessibilityManager =
+                (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
+
+            List<AccessibilityServiceInfo> applicationServices =
+                applicationAccessibilityManager.getInstalledAccessibilityServiceList();
+            List<AccessibilityServiceInfo> activityServices =
+                activityAccessibilityManager.getInstalledAccessibilityServiceList();
+
+            assertThat(activityServices).isEqualTo(applicationServices);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/CarrierConfigManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/CarrierConfigManagerTest.java
new file mode 100644
index 000000000..36c25b39f
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/CarrierConfigManagerTest.java
@@ -0,0 +1,97 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest;
+import android.content.Context;
+import android.os.Parcel;
+import android.os.PersistableBundle;
+import android.telephony.CarrierConfigManager;
+import android.telephony.SubscriptionManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link CarrierConfigManager}. */
+@RunWith(AndroidJUnit4.class)
+public class CarrierConfigManagerTest {
+
+  @Rule
+  public GrantPermissionRule mRuntimePermissionRule =
+      GrantPermissionRule.grant(Manifest.permission.READ_PHONE_STATE);
+
+  @Test
+  public void carrierConfigManager_applicationInstance_isNotSameAsActivityInstance() {
+    CarrierConfigManager applicationCarrierConfigManager =
+        (CarrierConfigManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CarrierConfigManager activityCarrierConfigManager =
+                (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            assertThat(applicationCarrierConfigManager)
+                .isNotSameInstanceAs(activityCarrierConfigManager);
+          });
+    }
+  }
+
+  @Test
+  public void carrierConfigManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CarrierConfigManager activityCarrierConfigManager =
+                (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            CarrierConfigManager anotherActivityCarrierConfigManager =
+                (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+            assertThat(anotherActivityCarrierConfigManager)
+                .isSameInstanceAs(activityCarrierConfigManager);
+          });
+    }
+  }
+
+  @Test
+  public void carrierConfigManager_instance_retrievesSameConfigs() {
+    CarrierConfigManager applicationCarrierConfigManager =
+        (CarrierConfigManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CarrierConfigManager activityCarrierConfigManager =
+                (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+            int subId = SubscriptionManager.getDefaultSubscriptionId();
+
+            PersistableBundle applicationConfigs =
+                applicationCarrierConfigManager.getConfigForSubId(subId);
+            PersistableBundle activityConfigs =
+                activityCarrierConfigManager.getConfigForSubId(subId);
+
+            Parcel applicationParcel = Parcel.obtain();
+            Parcel activityParcel = Parcel.obtain();
+
+            applicationConfigs.writeToParcel(applicationParcel, 0);
+            activityConfigs.writeToParcel(activityParcel, 0);
+
+            byte[] applicationBytes = applicationParcel.marshall();
+            byte[] activityBytes = activityParcel.marshall();
+
+            assertThat(activityBytes).isEqualTo(applicationBytes);
+
+            applicationParcel.recycle();
+            activityParcel.recycle();
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ConnectivityManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ConnectivityManagerTest.java
new file mode 100644
index 000000000..0665a37cb
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ConnectivityManagerTest.java
@@ -0,0 +1,83 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest;
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.os.Build;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link ConnectivityManager}. */
+@RunWith(AndroidJUnit4.class)
+public class ConnectivityManagerTest {
+
+  @Rule
+  public GrantPermissionRule mRuntimePermissionRule =
+      GrantPermissionRule.grant(Manifest.permission.ACCESS_NETWORK_STATE);
+
+  @Test
+  public void connectivityManager_applicationInstance_behaviorBasedOnSdkVersion() {
+    ConnectivityManager applicationConnectivityManager =
+        ApplicationProvider.getApplicationContext().getSystemService(ConnectivityManager.class);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ConnectivityManager activityConnectivityManager =
+                activity.getSystemService(ConnectivityManager.class);
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+              assertThat(applicationConnectivityManager)
+                  .isNotSameInstanceAs(activityConnectivityManager);
+            } else {
+              assertThat(applicationConnectivityManager)
+                  .isSameInstanceAs(activityConnectivityManager);
+            }
+          });
+    }
+  }
+
+  @Test
+  public void connectivityManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ConnectivityManager activityConnectivityManager =
+                (ConnectivityManager) activity.getSystemService(Context.CONNECTIVITY_SERVICE);
+            ConnectivityManager anotherActivityConnectivityManager =
+                (ConnectivityManager) activity.getSystemService(Context.CONNECTIVITY_SERVICE);
+            assertThat(anotherActivityConnectivityManager)
+                .isSameInstanceAs(activityConnectivityManager);
+          });
+    }
+  }
+
+  @Test
+  public void connectivityManager_instance_retrievesSameActiveNetwork() {
+    ConnectivityManager applicationConnectivityManager =
+        (ConnectivityManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ConnectivityManager activityConnectivityManager =
+                (ConnectivityManager) activity.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+            Network applicationActiveNetwork = applicationConnectivityManager.getActiveNetwork();
+            Network activityActiveNetwork = activityConnectivityManager.getActiveNetwork();
+
+            assertThat(activityActiveNetwork).isEqualTo(applicationActiveNetwork);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
index b6943308d..b903c6841 100644
--- a/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ContextTest.java
@@ -5,23 +5,84 @@ import static com.google.common.truth.Truth.assertThat;
 import android.Manifest;
 import android.accounts.Account;
 import android.accounts.AccountManager;
+import android.app.admin.DeviceAdminReceiver;
+import android.app.admin.DevicePolicyManager;
+import android.app.role.RoleManager;
+import android.app.slice.Slice;
+import android.app.slice.SliceManager;
+import android.app.slice.SliceSpec;
+import android.app.usage.UsageStatsManager;
+import android.appwidget.AppWidgetHost;
+import android.appwidget.AppWidgetManager;
+import android.appwidget.AppWidgetProvider;
+import android.appwidget.AppWidgetProviderInfo;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.ClipData;
+import android.content.ClipboardManager;
+import android.content.ComponentName;
 import android.content.Context;
+import android.content.pm.CrossProfileApps;
+import android.content.pm.LauncherApps;
+import android.hardware.Sensor;
+import android.hardware.SensorManager;
+import android.hardware.biometrics.BiometricManager;
+import android.hardware.camera2.CameraManager;
+import android.hardware.fingerprint.FingerprintManager;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbManager;
 import android.media.AudioManager;
+import android.media.MediaRouter;
+import android.net.Uri;
+import android.os.BatteryManager;
+import android.os.Build;
+import android.os.DropBoxManager;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.os.health.HealthStats;
+import android.os.health.SystemHealthManager;
+import android.os.storage.StorageManager;
+import android.os.storage.StorageVolume;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.telephony.euicc.EuiccManager;
+import android.util.ArraySet;
+import android.view.accessibility.CaptioningManager;
+import android.view.autofill.AutofillManager;
+import android.widget.RemoteViews;
 import androidx.test.core.app.ActivityScenario;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
 import androidx.test.rule.GrantPermissionRule;
+import com.google.common.truth.Truth;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.testapp.TestActivity;
+import org.robolectric.util.ReflectionHelpers;
 
+/** Compatibility test for {@link Context}. */
 @RunWith(AndroidJUnit4.class)
 public class ContextTest {
+  private static final int APP_WIDGET_HOST_ID = 1;
+
   @Rule
   public GrantPermissionRule mRuntimePermissionRule =
       GrantPermissionRule.grant(
-          Manifest.permission.MODIFY_AUDIO_SETTINGS, Manifest.permission.GET_ACCOUNTS);
+          Manifest.permission.BLUETOOTH,
+          Manifest.permission.BLUETOOTH_ADMIN,
+          Manifest.permission.MODIFY_AUDIO_SETTINGS,
+          Manifest.permission.GET_ACCOUNTS,
+          Manifest.permission.USE_BIOMETRIC,
+          Manifest.permission.INTERNET,
+          Manifest.permission.READ_PHONE_STATE,
+          Manifest.permission.WRITE_EXTERNAL_STORAGE,
+          Manifest.permission.READ_EXTERNAL_STORAGE);
 
   @Test
   public void audioManager_applicationInstance_isNotSameAsActivityInstance() {
@@ -123,4 +184,1497 @@ public class ContextTest {
           });
     }
   }
+
+  @Test
+  public void batteryManager_applicationInstance_isNotSameAsActivityInstance() {
+    BatteryManager applicationBatteryManager =
+        (BatteryManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.BATTERY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BatteryManager activityBatteryManager =
+                (BatteryManager) activity.getSystemService(Context.BATTERY_SERVICE);
+            assertThat(applicationBatteryManager).isNotSameInstanceAs(activityBatteryManager);
+          });
+    }
+  }
+
+  @Test
+  public void batteryManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BatteryManager activityBatteryManager =
+                (BatteryManager) activity.getSystemService(Context.BATTERY_SERVICE);
+            BatteryManager anotherActivityBatteryManager =
+                (BatteryManager) activity.getSystemService(Context.BATTERY_SERVICE);
+            assertThat(anotherActivityBatteryManager).isSameInstanceAs(activityBatteryManager);
+          });
+    }
+  }
+
+  @Test
+  public void alarmManager_applicationInstance_isNotSameAsActivityInstance() {
+    AlarmManager applicationAlarmManager =
+        (AlarmManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AlarmManager activityAlarmManager =
+                (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
+            assertThat(applicationAlarmManager).isNotSameInstanceAs(activityAlarmManager);
+          });
+    }
+  }
+
+  @Test
+  public void alarmManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AlarmManager activityAlarmManager =
+                (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
+            AlarmManager anotherActivityAlarmManager =
+                (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
+            assertThat(anotherActivityAlarmManager).isSameInstanceAs(activityAlarmManager);
+          });
+    }
+  }
+
+  @Test
+  public void alarmManager_instance_retrievesSameAlarmClockInfo() {
+    AlarmManager applicationAlarmManager =
+        (AlarmManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AlarmManager activityAlarmManager =
+                (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
+
+            AlarmManager.AlarmClockInfo applicationAlarmClock =
+                applicationAlarmManager.getNextAlarmClock();
+            AlarmManager.AlarmClockInfo activityAlarmClock =
+                activityAlarmManager.getNextAlarmClock();
+
+            assertThat(activityAlarmClock).isEqualTo(applicationAlarmClock);
+          });
+    }
+  }
+
+  @Test
+  public void clipboardManager_applicationInstance_isNotSameAsActivityInstance() {
+    ClipboardManager applicationClipboardManager =
+        (ClipboardManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ClipboardManager activityClipboardManager =
+                (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+            assertThat(applicationClipboardManager).isNotSameInstanceAs(activityClipboardManager);
+          });
+    }
+  }
+
+  @Test
+  public void clipboardManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ClipboardManager activityClipboardManager =
+                (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+            ClipboardManager anotherActivityClipboardManager =
+                (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+            assertThat(anotherActivityClipboardManager).isSameInstanceAs(activityClipboardManager);
+          });
+    }
+  }
+
+  @Test
+  public void clipboardManager_instance_retrievesSamePrimaryClip() {
+    ClipboardManager applicationClipboardManager =
+        (ClipboardManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.CLIPBOARD_SERVICE);
+    ClipData clipData = ClipData.newPlainText("label", "text");
+    applicationClipboardManager.setPrimaryClip(clipData);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ClipboardManager activityClipboardManager =
+                (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+
+            ClipData applicationClipData = applicationClipboardManager.getPrimaryClip();
+            ClipData activityClipData = activityClipboardManager.getPrimaryClip();
+
+            assertThat(activityClipData.toString()).isEqualTo(applicationClipData.toString());
+          });
+    }
+  }
+
+  @Test
+  public void keyguardManager_applicationInstance_isNotSameAsActivityInstance() {
+    KeyguardManager applicationKeyguardManager =
+        (KeyguardManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            KeyguardManager activityKeyguardManager =
+                (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
+            assertThat(applicationKeyguardManager).isNotSameInstanceAs(activityKeyguardManager);
+          });
+    }
+  }
+
+  @Test
+  public void keyguardManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            KeyguardManager activityKeyguardManager =
+                (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
+            KeyguardManager anotherActivityKeyguardManager =
+                (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
+            assertThat(anotherActivityKeyguardManager).isSameInstanceAs(activityKeyguardManager);
+          });
+    }
+  }
+
+  @Test
+  public void keyguardManager_isKeyguardLocked_retrievesSameState() {
+    KeyguardManager applicationKeyguardManager =
+        (KeyguardManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            KeyguardManager activityKeyguardManager =
+                (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
+
+            boolean applicationIsKeyguardLocked = applicationKeyguardManager.isKeyguardLocked();
+            boolean activityIsKeyguardLocked = activityKeyguardManager.isKeyguardLocked();
+
+            assertThat(activityIsKeyguardLocked).isEqualTo(applicationIsKeyguardLocked);
+          });
+    }
+  }
+
+  @Test
+  public void devicePolicyManager_applicationInstance_isNotSameAsActivityInstance() {
+    DevicePolicyManager applicationDpm =
+        (DevicePolicyManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.DEVICE_POLICY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DevicePolicyManager activityDpm =
+                (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
+            assertThat(applicationDpm).isNotSameInstanceAs(activityDpm);
+          });
+    }
+  }
+
+  @Test
+  public void devicePolicyManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DevicePolicyManager activityDpm =
+                (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
+            DevicePolicyManager anotherActivityDpm =
+                (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
+            assertThat(anotherActivityDpm).isSameInstanceAs(activityDpm);
+          });
+    }
+  }
+
+  @Test
+  public void devicePolicyManager_instance_retrievesSameAdminStatus() {
+    DevicePolicyManager applicationDpm =
+        (DevicePolicyManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.DEVICE_POLICY_SERVICE);
+    ComponentName testAdminComponent =
+        new ComponentName(ApplicationProvider.getApplicationContext(), DeviceAdminReceiver.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DevicePolicyManager activityDpm =
+                (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
+
+            boolean applicationAdminActive = applicationDpm.isAdminActive(testAdminComponent);
+            boolean activityAdminActive = activityDpm.isAdminActive(testAdminComponent);
+
+            assertThat(activityAdminActive).isEqualTo(applicationAdminActive);
+          });
+    }
+  }
+
+  @Test
+  public void autofillManager_applicationInstance_isNotSameAsActivityInstance() {
+    AutofillManager applicationAutofillManager =
+        ApplicationProvider.getApplicationContext().getSystemService(AutofillManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AutofillManager activityAutofillManager =
+                activity.getSystemService(AutofillManager.class);
+            assertThat(applicationAutofillManager).isNotSameInstanceAs(activityAutofillManager);
+          });
+    }
+  }
+
+  @Test
+  public void autofillManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AutofillManager activityAutofillManager =
+                activity.getSystemService(AutofillManager.class);
+            AutofillManager anotherActivityAutofillManager =
+                activity.getSystemService(AutofillManager.class);
+            assertThat(anotherActivityAutofillManager).isSameInstanceAs(activityAutofillManager);
+          });
+    }
+  }
+
+  @Test
+  public void autofillManager_instance_retrievesSameAutofillService() {
+    AutofillManager applicationAutofillManager =
+        ApplicationProvider.getApplicationContext().getSystemService(AutofillManager.class);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AutofillManager activityAutofillManager =
+                activity.getSystemService(AutofillManager.class);
+
+            boolean applicationAutofillServiceAvailable =
+                applicationAutofillManager.isAutofillSupported();
+            boolean activityAutofillServiceAvailable =
+                activityAutofillManager.isAutofillSupported();
+
+            assertThat(activityAutofillServiceAvailable)
+                .isEqualTo(applicationAutofillServiceAvailable);
+          });
+    }
+  }
+
+  @Test
+  public void downloadManager_applicationInstance_isNotSameAsActivityInstance() {
+    DownloadManager applicationDownloadManager =
+        (DownloadManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DownloadManager activityDownloadManager =
+                (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
+            assertThat(applicationDownloadManager).isNotSameInstanceAs(activityDownloadManager);
+          });
+    }
+  }
+
+  @Test
+  public void downloadManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DownloadManager activityDownloadManager =
+                (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
+            DownloadManager anotherActivityDownloadManager =
+                (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
+            assertThat(anotherActivityDownloadManager).isSameInstanceAs(activityDownloadManager);
+          });
+    }
+  }
+
+  @Test
+  public void downloadManager_instance_retrievesSameMimeTypeForDownloadedFile() {
+    final long testId = 1L;
+    DownloadManager applicationDownloadManager =
+        (DownloadManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DOWNLOAD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DownloadManager activityDownloadManager =
+                (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
+
+            String applicationMimeType =
+                applicationDownloadManager.getMimeTypeForDownloadedFile(testId);
+            String activityMimeType = activityDownloadManager.getMimeTypeForDownloadedFile(testId);
+
+            assertThat(activityMimeType).isEqualTo(applicationMimeType);
+          });
+    }
+  }
+
+  @Test
+  public void fingerprintManager_applicationInstance_isNotSameAsActivityInstance() {
+    FingerprintManager applicationFingerprintManager =
+        (FingerprintManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.FINGERPRINT_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FingerprintManager activityFingerprintManager =
+                (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
+            assertThat(applicationFingerprintManager)
+                .isNotSameInstanceAs(activityFingerprintManager);
+          });
+    }
+  }
+
+  @Test
+  public void fingerprintManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FingerprintManager activityFingerprintManager =
+                (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
+            FingerprintManager anotherActivityFingerprintManager =
+                (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
+            assertThat(anotherActivityFingerprintManager)
+                .isSameInstanceAs(activityFingerprintManager);
+          });
+    }
+  }
+
+  @Test
+  public void fingerprintManager_instance_hasConsistentFingerprintState() {
+    FingerprintManager applicationFingerprintManager =
+        (FingerprintManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.FINGERPRINT_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FingerprintManager activityFingerprintManager =
+                (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
+
+            boolean isApplicationFingerprintAvailable =
+                applicationFingerprintManager.isHardwareDetected();
+            boolean isActivityFingerprintAvailable =
+                activityFingerprintManager.isHardwareDetected();
+
+            assertThat(isActivityFingerprintAvailable).isEqualTo(isApplicationFingerprintAvailable);
+
+            boolean hasApplicationEnrolledFingerprints =
+                applicationFingerprintManager.hasEnrolledFingerprints();
+            boolean hasActivityEnrolledFingerprints =
+                activityFingerprintManager.hasEnrolledFingerprints();
+
+            assertThat(hasActivityEnrolledFingerprints)
+                .isEqualTo(hasApplicationEnrolledFingerprints);
+          });
+    }
+  }
+
+  @Test
+  public void activityManager_applicationInstance_isNotSameAsActivityInstance() {
+    ActivityManager applicationActivityManager =
+        (ActivityManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ActivityManager activityActivityManager =
+                (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
+            assertThat(applicationActivityManager).isNotSameInstanceAs(activityActivityManager);
+          });
+    }
+  }
+
+  @Test
+  public void activityManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ActivityManager activityActivityManager =
+                (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
+            ActivityManager anotherActivityActivityManager =
+                (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
+            assertThat(anotherActivityActivityManager).isSameInstanceAs(activityActivityManager);
+          });
+    }
+  }
+
+  @Test
+  public void activityManager_instance_retrievesConsistentLowRamDeviceStatus() {
+    ActivityManager applicationActivityManager =
+        (ActivityManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ActivityManager activityActivityManager =
+                (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
+
+            boolean applicationLowRamStatus = applicationActivityManager.isLowRamDevice();
+            boolean activityLowRamStatus = activityActivityManager.isLowRamDevice();
+
+            assertThat(activityLowRamStatus).isEqualTo(applicationLowRamStatus);
+          });
+    }
+  }
+
+  @Test
+  public void cameraManager_applicationInstance_isNotSameAsActivityInstance() {
+    CameraManager applicationCameraManager =
+        (CameraManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.CAMERA_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CameraManager activityCameraManager =
+                (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
+            assertThat(applicationCameraManager).isNotSameInstanceAs(activityCameraManager);
+          });
+    }
+  }
+
+  @Test
+  public void cameraManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CameraManager activityCameraManager =
+                (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
+            CameraManager anotherActivityCameraManager =
+                (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
+            assertThat(anotherActivityCameraManager).isSameInstanceAs(activityCameraManager);
+          });
+    }
+  }
+
+  @Test
+  public void appWidgetManager_applicationInstance_isNotSameAsActivityInstance() {
+    AppWidgetManager applicationAppWidgetManager =
+        (AppWidgetManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.APPWIDGET_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppWidgetManager activityAppWidgetManager =
+                (AppWidgetManager) activity.getSystemService(Context.APPWIDGET_SERVICE);
+            assertThat(applicationAppWidgetManager).isNotSameInstanceAs(activityAppWidgetManager);
+          });
+    }
+  }
+
+  @Test
+  public void appWidgetManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppWidgetManager activityAppWidgetManager =
+                (AppWidgetManager) activity.getSystemService(Context.APPWIDGET_SERVICE);
+            AppWidgetManager anotherActivityAppWidgetManager =
+                (AppWidgetManager) activity.getSystemService(Context.APPWIDGET_SERVICE);
+            assertThat(anotherActivityAppWidgetManager).isSameInstanceAs(activityAppWidgetManager);
+          });
+    }
+  }
+
+  @Test
+  public void appWidgetManager_instance_retrievesSameAppWidgets() {
+    Context context = ApplicationProvider.getApplicationContext();
+    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+
+    ComponentName providerComponent = new ComponentName(context, TestAppWidgetProvider.class);
+    AppWidgetProviderInfo appWidgetProviderInfo = new AppWidgetProviderInfo();
+    appWidgetProviderInfo.provider = providerComponent;
+    appWidgetProviderInfo.updatePeriodMillis = 0;
+    appWidgetProviderInfo.initialLayout = android.R.layout.simple_list_item_1;
+
+    AppWidgetHost appWidgetHost = new AppWidgetHost(context, APP_WIDGET_HOST_ID);
+
+    int appWidgetId = appWidgetHost.allocateAppWidgetId();
+    appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId, providerComponent);
+
+    appWidgetManager.updateAppWidget(
+        appWidgetId,
+        new RemoteViews(context.getPackageName(), android.R.layout.simple_list_item_1));
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppWidgetManager activityAppWidgetManager =
+                (AppWidgetManager) activity.getSystemService(Context.APPWIDGET_SERVICE);
+
+            int[] applicationAppWidgets = appWidgetManager.getAppWidgetIds(providerComponent);
+            int[] activityAppWidgets = activityAppWidgetManager.getAppWidgetIds(providerComponent);
+
+            Truth.assertThat(activityAppWidgets).isEqualTo(applicationAppWidgets);
+
+            appWidgetHost.deleteAppWidgetId(appWidgetId);
+          });
+    }
+  }
+
+  @Test
+  public void biometricManager_applicationInstance_isNotSameAsActivityInstance() {
+    BiometricManager applicationBiometricManager =
+        (BiometricManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.BIOMETRIC_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BiometricManager activityBiometricManager =
+                (BiometricManager) activity.getSystemService(Context.BIOMETRIC_SERVICE);
+            assertThat(applicationBiometricManager).isNotSameInstanceAs(activityBiometricManager);
+          });
+    }
+  }
+
+  @Test
+  public void biometricManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BiometricManager activityBiometricManager =
+                (BiometricManager) activity.getSystemService(Context.BIOMETRIC_SERVICE);
+            BiometricManager anotherActivityBiometricManager =
+                (BiometricManager) activity.getSystemService(Context.BIOMETRIC_SERVICE);
+            assertThat(anotherActivityBiometricManager).isSameInstanceAs(activityBiometricManager);
+          });
+    }
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
+  public void biometricManager_instance_retrievesSameAuthenticationResult_withAuthenticators() {
+    BiometricManager applicationBiometricManager =
+        (BiometricManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.BIOMETRIC_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BiometricManager activityBiometricManager =
+                (BiometricManager) activity.getSystemService(Context.BIOMETRIC_SERVICE);
+
+            int authenticators = BiometricManager.Authenticators.BIOMETRIC_WEAK;
+            int applicationCanAuthenticate =
+                applicationBiometricManager.canAuthenticate(authenticators);
+            int activityCanAuthenticate = activityBiometricManager.canAuthenticate(authenticators);
+
+            assertThat(activityCanAuthenticate).isEqualTo(applicationCanAuthenticate);
+          });
+    }
+  }
+
+  @Test
+  public void bluetoothManager_applicationInstance_isNotSameAsActivityInstance() {
+    BluetoothManager applicationBluetoothManager =
+        (BluetoothManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BluetoothManager activityBluetoothManager =
+                (BluetoothManager) activity.getSystemService(Context.BLUETOOTH_SERVICE);
+            assertThat(applicationBluetoothManager).isNotSameInstanceAs(activityBluetoothManager);
+          });
+    }
+  }
+
+  @Test
+  public void bluetoothManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BluetoothManager activityBluetoothManager =
+                (BluetoothManager) activity.getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothManager anotherActivityBluetoothManager =
+                (BluetoothManager) activity.getSystemService(Context.BLUETOOTH_SERVICE);
+            assertThat(anotherActivityBluetoothManager).isSameInstanceAs(activityBluetoothManager);
+          });
+    }
+  }
+
+  @Test
+  @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.Q)
+  public void bluetoothManager_instance_retrievesSameAdapter() {
+    BluetoothManager applicationBluetoothManager =
+        (BluetoothManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+
+    BluetoothAdapter applicationAdapter = applicationBluetoothManager.getAdapter();
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            BluetoothManager activityBluetoothManager =
+                (BluetoothManager) activity.getSystemService(Context.BLUETOOTH_SERVICE);
+
+            BluetoothAdapter activityAdapter = activityBluetoothManager.getAdapter();
+
+            assertThat(applicationAdapter).isEqualTo(activityAdapter);
+          });
+    }
+  }
+
+  @Test
+  public void appOpsManager_applicationInstance_isNotSameAsActivityInstance() {
+    AppOpsManager applicationAppOpsManager =
+        (AppOpsManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.APP_OPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppOpsManager activityAppOpsManager =
+                (AppOpsManager) activity.getSystemService(Context.APP_OPS_SERVICE);
+            assertThat(applicationAppOpsManager).isNotSameInstanceAs(activityAppOpsManager);
+          });
+    }
+  }
+
+  @Test
+  public void appOpsManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppOpsManager activityAppOpsManager =
+                (AppOpsManager) activity.getSystemService(Context.APP_OPS_SERVICE);
+            AppOpsManager anotherActivityAppOpsManager =
+                (AppOpsManager) activity.getSystemService(Context.APP_OPS_SERVICE);
+            assertThat(anotherActivityAppOpsManager).isSameInstanceAs(activityAppOpsManager);
+          });
+    }
+  }
+
+  @Test
+  public void appOpsManager_instance_retrievesSameOps() {
+    AppOpsManager applicationAppOpsManager =
+        (AppOpsManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.APP_OPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            AppOpsManager activityAppOpsManager =
+                (AppOpsManager) activity.getSystemService(Context.APP_OPS_SERVICE);
+
+            String opCode = AppOpsManager.OPSTR_CAMERA;
+            int applicationOpMode =
+                applicationAppOpsManager.checkOpNoThrow(
+                    opCode, android.os.Process.myUid(), "com.example.app");
+            int activityOpMode =
+                activityAppOpsManager.checkOpNoThrow(
+                    opCode, android.os.Process.myUid(), "com.example.app");
+
+            assertThat(activityOpMode).isEqualTo(applicationOpMode);
+          });
+    }
+  }
+
+  @Test
+  public void euiccManager_applicationInstance_isNotSameAsActivityInstance() {
+    EuiccManager applicationEuiccManager =
+        (EuiccManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            EuiccManager activityEuiccManager =
+                (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
+            assertThat(applicationEuiccManager).isNotSameInstanceAs(activityEuiccManager);
+          });
+    }
+  }
+
+  @Test
+  public void euiccManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            EuiccManager activityEuiccManager =
+                (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
+            EuiccManager anotherActivityEuiccManager =
+                (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
+            assertThat(anotherActivityEuiccManager).isSameInstanceAs(activityEuiccManager);
+          });
+    }
+  }
+
+  @Test
+  public void euiccManager_instance_getsEid() {
+    EuiccManager applicationEuiccManager =
+        (EuiccManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            EuiccManager activityEuiccManager =
+                (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
+
+            String applicationEid = applicationEuiccManager.getEid();
+            String activityEid = activityEuiccManager.getEid();
+
+            assertThat(activityEid).isEqualTo(applicationEid);
+          });
+    }
+  }
+
+  @Test
+  public void crossProfileApps_applicationInstance_isNotSameAsActivityInstance() {
+    CrossProfileApps applicationCrossProfileApps =
+        (CrossProfileApps)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CrossProfileApps activityCrossProfileApps =
+                (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+            assertThat(applicationCrossProfileApps).isNotSameInstanceAs(activityCrossProfileApps);
+          });
+    }
+  }
+
+  @Test
+  public void crossProfileApps_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CrossProfileApps activityCrossProfileApps =
+                (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+            CrossProfileApps anotherActivityCrossProfileApps =
+                (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+            assertThat(anotherActivityCrossProfileApps).isSameInstanceAs(activityCrossProfileApps);
+          });
+    }
+  }
+
+  @Test
+  public void crossProfileApps_instance_retrievesSameTargetUserProfiles() {
+    CrossProfileApps applicationCrossProfileApps =
+        (CrossProfileApps)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CrossProfileApps activityCrossProfileApps =
+                (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+
+            List<UserHandle> applicationTargetUserProfiles =
+                applicationCrossProfileApps.getTargetUserProfiles();
+            List<UserHandle> activityTargetUserProfiles =
+                activityCrossProfileApps.getTargetUserProfiles();
+
+            assertThat(activityTargetUserProfiles).isEqualTo(applicationTargetUserProfiles);
+          });
+    }
+  }
+
+  @Test
+  public void launcherApps_applicationInstance_isNotSameAsActivityInstance() {
+    LauncherApps applicationLauncherApps =
+        (LauncherApps)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.LAUNCHER_APPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LauncherApps activityLauncherApps =
+                (LauncherApps) activity.getSystemService(Context.LAUNCHER_APPS_SERVICE);
+            assertThat(applicationLauncherApps).isNotSameInstanceAs(activityLauncherApps);
+          });
+    }
+  }
+
+  @Test
+  public void launcherApps_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LauncherApps activityLauncherApps =
+                (LauncherApps) activity.getSystemService(Context.LAUNCHER_APPS_SERVICE);
+            LauncherApps anotherActivityLauncherApps =
+                (LauncherApps) activity.getSystemService(Context.LAUNCHER_APPS_SERVICE);
+            assertThat(anotherActivityLauncherApps).isSameInstanceAs(activityLauncherApps);
+          });
+    }
+  }
+
+  @Test
+  public void launcherApps_instance_retrievesSameProfiles() {
+    LauncherApps applicationLauncherApps =
+        (LauncherApps)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.LAUNCHER_APPS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LauncherApps activityLauncherApps =
+                (LauncherApps) activity.getSystemService(Context.LAUNCHER_APPS_SERVICE);
+
+            List<UserHandle> applicationProfiles = applicationLauncherApps.getProfiles();
+            List<UserHandle> activityProfiles = activityLauncherApps.getProfiles();
+
+            assertThat(applicationProfiles).isNotEmpty();
+            assertThat(activityProfiles).isNotEmpty();
+
+            assertThat(activityProfiles).isEqualTo(applicationProfiles);
+          });
+    }
+  }
+
+  @Test
+  public void dropBoxManager_applicationInstance_isNotSameAsActivityInstance() {
+    DropBoxManager applicationDropBoxManager =
+        (DropBoxManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DropBoxManager activityDropBoxManager =
+                (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
+            assertThat(applicationDropBoxManager).isNotSameInstanceAs(activityDropBoxManager);
+          });
+    }
+  }
+
+  @Test
+  public void dropBoxManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DropBoxManager activityDropBoxManager =
+                (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
+            DropBoxManager anotherActivityDropBoxManager =
+                (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
+            assertThat(anotherActivityDropBoxManager).isSameInstanceAs(activityDropBoxManager);
+          });
+    }
+  }
+
+  @Test
+  public void dropBoxManager_instance_retrievesSameEntry_noPermissionRequired() {
+    DropBoxManager applicationDropBoxManager =
+        (DropBoxManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
+
+    String tag = "testTag";
+    String data = "testData";
+    applicationDropBoxManager.addText(tag, data);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            DropBoxManager activityDropBoxManager =
+                (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
+
+            boolean applicationTagEnabled = applicationDropBoxManager.isTagEnabled(tag);
+            boolean activityTagEnabled = activityDropBoxManager.isTagEnabled(tag);
+
+            assertThat(activityTagEnabled).isEqualTo(applicationTagEnabled);
+          });
+    }
+  }
+
+  @Test
+  public void mediaRouter_applicationInstance_isNotSameAsActivityInstance() {
+    MediaRouter applicationMediaRouter =
+        (MediaRouter)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.MEDIA_ROUTER_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaRouter activityMediaRouter =
+                (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
+            assertThat(applicationMediaRouter).isNotSameInstanceAs(activityMediaRouter);
+          });
+    }
+  }
+
+  @Test
+  public void mediaRouter_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaRouter activityMediaRouter =
+                (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
+            MediaRouter anotherActivityMediaRouter =
+                (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
+            assertThat(anotherActivityMediaRouter).isSameInstanceAs(activityMediaRouter);
+          });
+    }
+  }
+
+  @Test
+  public void mediaRouter_instance_retrievesSameDefaultRoute() {
+    MediaRouter applicationMediaRouter =
+        (MediaRouter)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.MEDIA_ROUTER_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaRouter activityMediaRouter =
+                (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
+
+            MediaRouter.RouteInfo applicationDefaultRoute =
+                applicationMediaRouter.getDefaultRoute();
+            MediaRouter.RouteInfo activityDefaultRoute = activityMediaRouter.getDefaultRoute();
+
+            assertThat(activityDefaultRoute).isEqualTo(applicationDefaultRoute);
+          });
+    }
+  }
+
+  @Test
+  public void captioningManager_applicationInstance_isNotSameAsActivityInstance() {
+    CaptioningManager applicationCaptioningManager =
+        (CaptioningManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CAPTIONING_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CaptioningManager activityCaptioningManager =
+                (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
+
+            assertThat(applicationCaptioningManager).isNotSameInstanceAs(activityCaptioningManager);
+          });
+    }
+  }
+
+  @Test
+  public void captioningManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CaptioningManager activityCaptioningManager =
+                (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
+
+            CaptioningManager anotherActivityCaptioningManager =
+                (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
+
+            assertThat(anotherActivityCaptioningManager)
+                .isSameInstanceAs(activityCaptioningManager);
+          });
+    }
+  }
+
+  @Test
+  public void captioningManager_instance_retrievesSameValues() {
+    CaptioningManager applicationCaptioningManager =
+        (CaptioningManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.CAPTIONING_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            CaptioningManager activityCaptioningManager =
+                (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
+
+            boolean applicationisEnabled = applicationCaptioningManager.isEnabled();
+            boolean activityisEnabled = activityCaptioningManager.isEnabled();
+
+            assertThat(applicationisEnabled).isEqualTo(activityisEnabled);
+          });
+    }
+  }
+
+  @Test
+  public void sensorManager_applicationInstance_isNotSameAsActivityInstance() {
+    SensorManager applicationSensorManager =
+        (SensorManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SensorManager activitySensorManager =
+                (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
+
+            assertThat(applicationSensorManager).isNotSameInstanceAs(activitySensorManager);
+          });
+    }
+  }
+
+  @Test
+  public void sensorManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SensorManager activitySensorManager =
+                (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
+
+            SensorManager anotherActivitySensorManager =
+                (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
+
+            assertThat(anotherActivitySensorManager).isSameInstanceAs(activitySensorManager);
+          });
+    }
+  }
+
+  @Test
+  public void sensorManager_instance_retrievesSameValues() {
+    SensorManager applicationSensorManager =
+        (SensorManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SensorManager activitySensorManager =
+                (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
+
+            List<Sensor> applicationSensors =
+                applicationSensorManager.getSensorList(Sensor.TYPE_ALL);
+            List<Sensor> activitySensors = activitySensorManager.getSensorList(Sensor.TYPE_ALL);
+
+            for (int i = 0; i < applicationSensors.size(); i++) {
+              Sensor appSensor = applicationSensors.get(i);
+              Sensor actSensor = activitySensors.get(i);
+
+              assertThat(appSensor.getName()).isEqualTo(actSensor.getName());
+              assertThat(appSensor.getType()).isEqualTo(actSensor.getType());
+              assertThat(appSensor.getMaximumRange()).isEqualTo(actSensor.getMaximumRange());
+              assertThat(appSensor.getResolution()).isEqualTo(actSensor.getResolution());
+              assertThat(appSensor.getPower()).isEqualTo(actSensor.getPower());
+              assertThat(appSensor.getMinDelay()).isEqualTo(actSensor.getMinDelay());
+            }
+          });
+    }
+  }
+
+  @Test
+  public void roleManager_applicationInstance_isNotSameAsActivityInstance() {
+    RoleManager applicationRoleManager =
+        (RoleManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ROLE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RoleManager activityRoleManager =
+                (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
+            assertThat(applicationRoleManager).isNotSameInstanceAs(activityRoleManager);
+          });
+    }
+  }
+
+  @Test
+  public void roleManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RoleManager activityRoleManager =
+                (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
+            RoleManager anotherActivityRoleManager =
+                (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
+            assertThat(anotherActivityRoleManager).isSameInstanceAs(activityRoleManager);
+          });
+    }
+  }
+
+  @Test
+  public void roleManager_instance_retrievesSameRoles() {
+    RoleManager applicationRoleManager =
+        (RoleManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.ROLE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RoleManager activityRoleManager =
+                (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
+
+            boolean applicationRoleHeld = applicationRoleManager.isRoleHeld(RoleManager.ROLE_SMS);
+            boolean activityRoleHeld = activityRoleManager.isRoleHeld(RoleManager.ROLE_SMS);
+
+            assertThat(activityRoleHeld).isEqualTo(applicationRoleHeld);
+          });
+    }
+  }
+
+  @Test
+  public void sliceManager_applicationInstance_isNotSameAsActivityInstance() {
+    SliceManager applicationSliceManager =
+        ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SliceManager activitySliceManager = activity.getSystemService(SliceManager.class);
+            assertThat(applicationSliceManager).isNotSameInstanceAs(activitySliceManager);
+          });
+    }
+  }
+
+  @Test
+  public void sliceManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SliceManager activitySliceManager = activity.getSystemService(SliceManager.class);
+            SliceManager anotherActivitySliceManager =
+                activity.getSystemService(SliceManager.class);
+            assertThat(anotherActivitySliceManager).isSameInstanceAs(activitySliceManager);
+          });
+    }
+  }
+
+  @Test
+  public void usbManager_applicationInstance_isNotSameAsActivityInstance() {
+    UsbManager applicationUsbManager =
+        (UsbManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UsbManager activityUsbManager =
+                (UsbManager) activity.getSystemService(Context.USB_SERVICE);
+            assertThat(applicationUsbManager).isNotSameInstanceAs(activityUsbManager);
+          });
+    }
+  }
+
+  @Test
+  public void usbManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UsbManager activityUsbManager =
+                (UsbManager) activity.getSystemService(Context.USB_SERVICE);
+            UsbManager anotherActivityUsbManager =
+                (UsbManager) activity.getSystemService(Context.USB_SERVICE);
+            assertThat(anotherActivityUsbManager).isSameInstanceAs(activityUsbManager);
+          });
+    }
+  }
+
+  @Test
+  public void usbManager_instance_retrievesSameUsbDevices() {
+    UsbManager applicationUsbManager =
+        (UsbManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USB_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UsbManager activityUsbManager =
+                (UsbManager) activity.getSystemService(Context.USB_SERVICE);
+
+            HashMap<String, UsbDevice> applicationDevices = applicationUsbManager.getDeviceList();
+            HashMap<String, UsbDevice> activityDevices = activityUsbManager.getDeviceList();
+
+            assertThat(activityDevices).isEqualTo(applicationDevices);
+          });
+    }
+  }
+
+  @Test
+  public void sliceManager_instance_retrievesSameSlice() {
+    SliceManager applicationSliceManager =
+        ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
+    Uri testUri = Uri.parse("content://com.example.slice/test"); // Replace with a valid test URI
+    Set<SliceSpec> testSpecs = new ArraySet<>();
+
+    Slice applicationSlice = applicationSliceManager.bindSlice(testUri, testSpecs);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SliceManager activitySliceManager = activity.getSystemService(SliceManager.class);
+
+            Slice activitySlice = activitySliceManager.bindSlice(testUri, testSpecs);
+
+            assertThat(activitySlice).isEqualTo(applicationSlice);
+          });
+    }
+  }
+
+  @Test
+  public void storageManager_applicationInstance_isNotSameAsActivityInstance() {
+    StorageManager applicationStorageManager =
+        (StorageManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.STORAGE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            StorageManager activityStorageManager =
+                (StorageManager) activity.getSystemService(Context.STORAGE_SERVICE);
+            assertThat(applicationStorageManager).isNotSameInstanceAs(activityStorageManager);
+          });
+    }
+  }
+
+  @Test
+  public void storageManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            StorageManager activityStorageManager =
+                (StorageManager) activity.getSystemService(Context.STORAGE_SERVICE);
+            StorageManager anotherActivityStorageManager =
+                (StorageManager) activity.getSystemService(Context.STORAGE_SERVICE);
+            assertThat(anotherActivityStorageManager).isSameInstanceAs(activityStorageManager);
+          });
+    }
+  }
+
+  @Test
+  public void storageManager_instance_retrievesSameVolumes() {
+    StorageManager applicationStorageManager =
+        (StorageManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.STORAGE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            StorageManager activityStorageManager =
+                (StorageManager) activity.getSystemService(Context.STORAGE_SERVICE);
+
+            List<StorageVolume> applicationVolumes = applicationStorageManager.getStorageVolumes();
+            List<StorageVolume> activityVolumes = activityStorageManager.getStorageVolumes();
+
+            assertThat(activityVolumes).isEqualTo(applicationVolumes);
+          });
+    }
+  }
+
+  @Test
+  public void usageStatsManager_applicationInstance_isNotSameAsActivityInstance() {
+    UsageStatsManager applicationUsageStatsManager =
+        (UsageStatsManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.USAGE_STATS_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UsageStatsManager activityUsageStatsManager =
+                (UsageStatsManager) activity.getSystemService(Context.USAGE_STATS_SERVICE);
+            assertThat(applicationUsageStatsManager).isNotSameInstanceAs(activityUsageStatsManager);
+          });
+    }
+  }
+
+  @Test
+  public void usageStatsManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UsageStatsManager activityUsageStatsManager =
+                (UsageStatsManager) activity.getSystemService(Context.USAGE_STATS_SERVICE);
+            UsageStatsManager anotherActivityUsageStatsManager =
+                (UsageStatsManager) activity.getSystemService(Context.USAGE_STATS_SERVICE);
+            assertThat(anotherActivityUsageStatsManager)
+                .isSameInstanceAs(activityUsageStatsManager);
+          });
+    }
+  }
+
+  @Test
+  public void userManager_isUserAGoat_consistentAcrossContexts() {
+    UserManager applicationUserManager =
+        (UserManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UserManager activityUserManager =
+                (UserManager) activity.getSystemService(Context.USER_SERVICE);
+
+            boolean isGoatApplication = applicationUserManager.isUserAGoat();
+            boolean isGoatActivity = activityUserManager.isUserAGoat();
+
+            assertThat(isGoatApplication).isEqualTo(isGoatActivity);
+          });
+    }
+  }
+
+  @Test
+  public void subscriptionManager_applicationInstance_isNotSameAsActivityInstance() {
+    SubscriptionManager applicationSubscriptionManager =
+        (SubscriptionManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SubscriptionManager activitySubscriptionManager =
+                (SubscriptionManager)
+                    activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+            assertThat(applicationSubscriptionManager)
+                .isNotSameInstanceAs(activitySubscriptionManager);
+          });
+    }
+  }
+
+  @Test
+  public void subscriptionManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SubscriptionManager activitySubscriptionManager =
+                (SubscriptionManager)
+                    activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+            SubscriptionManager anotherActivitySubscriptionManager =
+                (SubscriptionManager)
+                    activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+            assertThat(anotherActivitySubscriptionManager)
+                .isSameInstanceAs(activitySubscriptionManager);
+          });
+    }
+  }
+
+  @Test
+  public void subscriptionManager_instance_retrievesSameDefaultSubscriptionInfo() {
+    int defaultSubscriptionId = SubscriptionManager.getDefaultSubscriptionId();
+    SubscriptionManager applicationSubscriptionManager =
+        (SubscriptionManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SubscriptionManager activitySubscriptionManager =
+                (SubscriptionManager)
+                    activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+
+            SubscriptionInfo applicationSubscriptionInfo =
+                applicationSubscriptionManager.getActiveSubscriptionInfo(defaultSubscriptionId);
+            SubscriptionInfo activitySubscriptionInfo =
+                activitySubscriptionManager.getActiveSubscriptionInfo(defaultSubscriptionId);
+
+            assertThat(applicationSubscriptionInfo).isEqualTo(activitySubscriptionInfo);
+          });
+    }
+  }
+
+  @Test
+  public void telephonyManager_applicationInstance_isNotSameAsActivityInstance() {
+    TelephonyManager applicationTelephonyManager =
+        (TelephonyManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelephonyManager activityTelephonyManager =
+                (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+            assertThat(applicationTelephonyManager).isNotSameInstanceAs(activityTelephonyManager);
+          });
+    }
+  }
+
+  @Test
+  public void telephonyManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelephonyManager activityTelephonyManager =
+                (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+            TelephonyManager anotherActivityTelephonyManager =
+                (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+            assertThat(anotherActivityTelephonyManager).isSameInstanceAs(activityTelephonyManager);
+          });
+    }
+  }
+
+  @Test
+  public void telephonyManager_instance_retrievesSamePhoneCount() {
+    TelephonyManager applicationTelephonyManager =
+        (TelephonyManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelephonyManager activityTelephonyManager =
+                (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+
+            int applicationPhoneCount = applicationTelephonyManager.getPhoneCount();
+            int activityPhoneCount = activityTelephonyManager.getPhoneCount();
+
+            assertThat(activityPhoneCount).isEqualTo(applicationPhoneCount);
+          });
+    }
+  }
+
+  @Test
+  public void systemHealthManager_applicationInstance_isNotSameAsActivityInstance() {
+    SystemHealthManager applicationSystemHealthManager =
+        (SystemHealthManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SystemHealthManager activitySystemHealthManager =
+                (SystemHealthManager) activity.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+            assertThat(applicationSystemHealthManager)
+                .isNotSameInstanceAs(activitySystemHealthManager);
+          });
+    }
+  }
+
+  @Test
+  public void systemHealthManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SystemHealthManager activitySystemHealthManager =
+                (SystemHealthManager) activity.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+            SystemHealthManager anotherActivitySystemHealthManager =
+                (SystemHealthManager) activity.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+            assertThat(anotherActivitySystemHealthManager)
+                .isSameInstanceAs(activitySystemHealthManager);
+          });
+    }
+  }
+
+  @Test
+  public void systemHealthManager_instance_retrievesSameUidSnapshot() {
+    SystemHealthManager applicationSystemHealthManager =
+        (SystemHealthManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SystemHealthManager activitySystemHealthManager =
+                (SystemHealthManager) activity.getSystemService(Context.SYSTEM_HEALTH_SERVICE);
+
+            HealthStats applicationHealthStats = applicationSystemHealthManager.takeMyUidSnapshot();
+            HealthStats activityHealthStats = activitySystemHealthManager.takeMyUidSnapshot();
+
+            try {
+              Object applicationField =
+                  ReflectionHelpers.getField(applicationHealthStats, "desiredField");
+              Object activityField =
+                  ReflectionHelpers.getField(activityHealthStats, "desiredField");
+
+              assertThat(applicationField).isEqualTo(activityField);
+            } catch (RuntimeException e) {
+              e.printStackTrace();
+            }
+          });
+    }
+  }
+
+  private static class TestAppWidgetProvider extends AppWidgetProvider {
+    @Override
+    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
+      for (int appWidgetId : appWidgetIds) {
+        RemoteViews views =
+            new RemoteViews(context.getPackageName(), android.R.layout.simple_list_item_1);
+        views.setTextViewText(android.R.id.text1, "Test Widget");
+        appWidgetManager.updateAppWidget(appWidgetId, views);
+      }
+    }
+  }
 }
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/FileIntegrityManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/FileIntegrityManagerTest.java
new file mode 100644
index 000000000..ec7a8f9a9
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/FileIntegrityManagerTest.java
@@ -0,0 +1,75 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.os.Build;
+import android.security.FileIntegrityManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link FileIntegrityManager}. */
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+public class FileIntegrityManagerTest {
+
+  @Test
+  public void fileIntegrityManager_applicationInstance_isNotSameAsActivityInstance() {
+    FileIntegrityManager applicationFileIntegrityManager =
+        (FileIntegrityManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.FILE_INTEGRITY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FileIntegrityManager activityFileIntegrityManager =
+                (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
+
+            assertThat(applicationFileIntegrityManager)
+                .isNotSameInstanceAs(activityFileIntegrityManager);
+          });
+    }
+  }
+
+  @Test
+  public void fileIntegrityManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FileIntegrityManager activityFileIntegrityManager =
+                (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
+            FileIntegrityManager anotherActivityFileIntegrityManager =
+                (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
+            assertThat(anotherActivityFileIntegrityManager)
+                .isSameInstanceAs(activityFileIntegrityManager);
+          });
+    }
+  }
+
+  @Test
+  public void fileIntegrityManager_instance_retrievesSameValues() {
+    FileIntegrityManager applicationFileIntegrityManager =
+        (FileIntegrityManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.FILE_INTEGRITY_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            FileIntegrityManager activityFileIntegrityManager =
+                (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
+
+            boolean applicationApkVeritySupported =
+                applicationFileIntegrityManager.isApkVeritySupported();
+            boolean activityApkVeritySupported =
+                activityFileIntegrityManager.isApkVeritySupported();
+
+            assertThat(activityApkVeritySupported).isEqualTo(applicationApkVeritySupported);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/InputMethodManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/InputMethodManagerTest.java
new file mode 100644
index 000000000..6da629a71
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/InputMethodManagerTest.java
@@ -0,0 +1,68 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.view.inputmethod.InputMethodManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link InputMethodManager}. */
+@RunWith(AndroidJUnit4.class)
+public class InputMethodManagerTest {
+  @Test
+  public void inputMethodManager_applicationInstance_isSameAsActivityInstance() {
+    InputMethodManager applicationInputMethodManager =
+        (InputMethodManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.INPUT_METHOD_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            InputMethodManager activityInputMethodManager =
+                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+            assertThat(applicationInputMethodManager).isSameInstanceAs(activityInputMethodManager);
+          });
+    }
+  }
+
+  @Test
+  public void inputMethodManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            InputMethodManager activityInputMethodManager =
+                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+            InputMethodManager anotherActivityInputMethodManager =
+                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+            assertThat(anotherActivityInputMethodManager)
+                .isSameInstanceAs(activityInputMethodManager);
+          });
+    }
+  }
+
+  @Test
+  public void inputMethodManager_retrievesSameIsAcceptingText() {
+    InputMethodManager applicationInputMethodManager =
+        (InputMethodManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.INPUT_METHOD_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            InputMethodManager activityInputMethodManager =
+                (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+
+            boolean applicationIsAcceptingText = applicationInputMethodManager.isAcceptingText();
+            boolean activityIsAcceptingText = activityInputMethodManager.isAcceptingText();
+
+            assertThat(activityIsAcceptingText).isEqualTo(applicationIsAcceptingText);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/LocaleManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/LocaleManagerTest.java
new file mode 100644
index 000000000..8d7d69237
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/LocaleManagerTest.java
@@ -0,0 +1,70 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.os.Build;
+import android.os.LocaleList;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link LocaleManager}. */
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+public class LocaleManagerTest {
+
+  @Test
+  public void localeManager_applicationInstance_isNotSameAsActivityInstance() {
+    LocaleManager applicationLocaleManager =
+        (LocaleManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.LOCALE_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LocaleManager activityLocaleManager =
+                (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
+            assertThat(applicationLocaleManager).isNotSameInstanceAs(activityLocaleManager);
+          });
+    }
+  }
+
+  @Test
+  public void localeManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LocaleManager activityLocaleManager =
+                (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
+            LocaleManager anotherActivityLocaleManager =
+                (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
+            assertThat(anotherActivityLocaleManager).isSameInstanceAs(activityLocaleManager);
+          });
+    }
+  }
+
+  @Test
+  public void localeManager_instance_retrievesSameApplicationLocales() {
+    LocaleManager applicationLocaleManager =
+        (LocaleManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.LOCALE_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            LocaleManager activityLocaleManager =
+                (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
+
+            LocaleList applicationLocales = applicationLocaleManager.getApplicationLocales();
+            LocaleList activityLocales = activityLocaleManager.getApplicationLocales();
+
+            assertThat(activityLocales).isEqualTo(applicationLocales);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/MediaSessionManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/MediaSessionManagerTest.java
new file mode 100644
index 000000000..ff6fce21f
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/MediaSessionManagerTest.java
@@ -0,0 +1,74 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.media.session.MediaSessionManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link MediaSessionManager}. */
+@RunWith(AndroidJUnit4.class)
+public class MediaSessionManagerTest {
+
+  @Test
+  public void mediaSessionManager_applicationInstance_isNotSameAsActivityInstance() {
+    MediaSessionManager applicationMediaSessionManager =
+        (MediaSessionManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.MEDIA_SESSION_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaSessionManager activityMediaSessionManager =
+                (MediaSessionManager) activity.getSystemService(Context.MEDIA_SESSION_SERVICE);
+            assertThat(applicationMediaSessionManager)
+                .isNotSameInstanceAs(activityMediaSessionManager);
+          });
+    }
+  }
+
+  @Test
+  public void mediaSessionManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaSessionManager activityMediaSessionManager =
+                (MediaSessionManager) activity.getSystemService(Context.MEDIA_SESSION_SERVICE);
+            MediaSessionManager anotherActivityMediaSessionManager =
+                (MediaSessionManager) activity.getSystemService(Context.MEDIA_SESSION_SERVICE);
+            assertThat(anotherActivityMediaSessionManager)
+                .isSameInstanceAs(activityMediaSessionManager);
+          });
+    }
+  }
+
+  @Test
+  public void mediaSessionManager_isTrustedForMediaControl_retrievesCorrectTrustStatus() {
+    MediaSessionManager applicationMediaSessionManager =
+        (MediaSessionManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.MEDIA_SESSION_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            MediaSessionManager activityMediaSessionManager =
+                (MediaSessionManager) activity.getSystemService(Context.MEDIA_SESSION_SERVICE);
+
+            MediaSessionManager.RemoteUserInfo userInfo =
+                new MediaSessionManager.RemoteUserInfo("com.example.package", 1234, 5678);
+
+            boolean applicationIsTrusted =
+                applicationMediaSessionManager.isTrustedForMediaControl(userInfo);
+            boolean activityIsTrusted =
+                activityMediaSessionManager.isTrustedForMediaControl(userInfo);
+
+            assertThat(activityIsTrusted).isEqualTo(applicationIsTrusted);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/NotificationManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/NotificationManagerTest.java
new file mode 100644
index 000000000..7920dd038
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/NotificationManagerTest.java
@@ -0,0 +1,76 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link NotificationManager}. */
+@RunWith(AndroidJUnit4.class)
+public class NotificationManagerTest {
+
+  @Test
+  public void notificationManager_applicationInstance_isNotSameAsActivityInstance() {
+    NotificationManager applicationNotificationManager =
+        (NotificationManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.NOTIFICATION_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            NotificationManager activityNotificationManager =
+                (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
+            assertThat(applicationNotificationManager)
+                .isNotSameInstanceAs(activityNotificationManager);
+          });
+    }
+  }
+
+  @Test
+  public void notificationManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            NotificationManager activityNotificationManager =
+                (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
+            NotificationManager anotherActivityNotificationManager =
+                (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
+            assertThat(anotherActivityNotificationManager)
+                .isSameInstanceAs(activityNotificationManager);
+          });
+    }
+  }
+
+  @Test
+  public void notificationManager_createAndRetrieveChannel() {
+    NotificationManager applicationNotificationManager =
+        (NotificationManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.NOTIFICATION_SERVICE);
+
+    NotificationChannel testChannel =
+        new NotificationChannel(
+            "test_channel_id", "Test Channel", NotificationManager.IMPORTANCE_DEFAULT);
+    applicationNotificationManager.createNotificationChannel(testChannel);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            NotificationManager activityNotificationManager =
+                (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
+
+            NotificationChannel applicationChannel =
+                applicationNotificationManager.getNotificationChannel("test_channel_id");
+            NotificationChannel activityChannel =
+                activityNotificationManager.getNotificationChannel("test_channel_id");
+
+            assertThat(activityChannel).isEqualTo(applicationChannel);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/PowerManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/PowerManagerTest.java
new file mode 100644
index 000000000..d0d6dcc82
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/PowerManagerTest.java
@@ -0,0 +1,65 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.os.PowerManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link PowerManager}. */
+@RunWith(AndroidJUnit4.class)
+public class PowerManagerTest {
+
+  @Test
+  public void powerManager_applicationInstance_isNotSameAsActivityInstance() {
+    PowerManager applicationPowerManager =
+        (PowerManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.POWER_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            PowerManager activityPowerManager =
+                (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
+            assertThat(applicationPowerManager).isNotSameInstanceAs(activityPowerManager);
+          });
+    }
+  }
+
+  @Test
+  public void powerManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            PowerManager activityPowerManager =
+                (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
+            PowerManager anotherActivityPowerManager =
+                (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
+            assertThat(anotherActivityPowerManager).isSameInstanceAs(activityPowerManager);
+          });
+    }
+  }
+
+  @Test
+  public void powerManager_instance_checkIsInteractive() {
+    PowerManager applicationPowerManager =
+        (PowerManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.POWER_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            PowerManager activityPowerManager =
+                (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
+
+            boolean applicationIsInteractive = applicationPowerManager.isInteractive();
+            boolean activityIsInteractive = activityPowerManager.isInteractive();
+
+            assertThat(activityIsInteractive).isEqualTo(applicationIsInteractive);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/RestrictionsManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/RestrictionsManagerTest.java
new file mode 100644
index 000000000..e1b934ef2
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/RestrictionsManagerTest.java
@@ -0,0 +1,74 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.RestrictionsManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link RestrictionsManager}. */
+@RunWith(AndroidJUnit4.class)
+public class RestrictionsManagerTest {
+
+  @Test
+  public void restrictionsManager_applicationInstance_isNotSameAsActivityInstance() {
+    RestrictionsManager applicationRestrictionsManager =
+        (RestrictionsManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.RESTRICTIONS_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RestrictionsManager activityRestrictionsManager =
+                (RestrictionsManager) activity.getSystemService(Context.RESTRICTIONS_SERVICE);
+
+            assertThat(applicationRestrictionsManager)
+                .isNotSameInstanceAs(activityRestrictionsManager);
+          });
+    }
+  }
+
+  @Test
+  public void restrictionsManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RestrictionsManager activityRestrictionsManager =
+                (RestrictionsManager) activity.getSystemService(Context.RESTRICTIONS_SERVICE);
+            RestrictionsManager anotherActivityRestrictionsManager =
+                (RestrictionsManager) activity.getSystemService(Context.RESTRICTIONS_SERVICE);
+
+            assertThat(anotherActivityRestrictionsManager)
+                .isSameInstanceAs(activityRestrictionsManager);
+          });
+    }
+  }
+
+  @Test
+  public void restrictionsManager_hasRestrictionsProvider_isConsistentAcrossContexts() {
+    RestrictionsManager applicationRestrictionsManager =
+        (RestrictionsManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.RESTRICTIONS_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            RestrictionsManager activityRestrictionsManager =
+                (RestrictionsManager) activity.getSystemService(Context.RESTRICTIONS_SERVICE);
+
+            boolean applicationHasProvider =
+                applicationRestrictionsManager.hasRestrictionsProvider();
+            boolean activityHasProvider = activityRestrictionsManager.hasRestrictionsProvider();
+
+            assertThat(activityHasProvider).isEqualTo(applicationHasProvider);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/SearchManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/SearchManagerTest.java
new file mode 100644
index 000000000..266905e89
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/SearchManagerTest.java
@@ -0,0 +1,68 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.ComponentName;
+import android.content.Context;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link SearchManager}. */
+@RunWith(AndroidJUnit4.class)
+public class SearchManagerTest {
+
+  @Test
+  public void searchManager_applicationInstance_isNotSameAsActivityInstance() {
+    SearchManager applicationSearchManager =
+        (SearchManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SEARCH_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SearchManager activitySearchManager =
+                (SearchManager) activity.getSystemService(Context.SEARCH_SERVICE);
+            assertThat(applicationSearchManager).isNotSameInstanceAs(activitySearchManager);
+          });
+    }
+  }
+
+  @Test
+  public void searchManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SearchManager activitySearchManager =
+                (SearchManager) activity.getSystemService(Context.SEARCH_SERVICE);
+            SearchManager anotherActivitySearchManager =
+                (SearchManager) activity.getSystemService(Context.SEARCH_SERVICE);
+            assertThat(anotherActivitySearchManager).isSameInstanceAs(activitySearchManager);
+          });
+    }
+  }
+
+  @Test
+  public void searchManager_globalSearchActivity_retrievesSameValues() {
+    SearchManager applicationSearchManager =
+        (SearchManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SEARCH_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            SearchManager activitySearchManager =
+                (SearchManager) activity.getSystemService(Context.SEARCH_SERVICE);
+
+            ComponentName applicationGlobalSearchActivity =
+                applicationSearchManager.getGlobalSearchActivity();
+            ComponentName activityGlobalSearchActivity =
+                activitySearchManager.getGlobalSearchActivity();
+
+            assertThat(applicationGlobalSearchActivity).isEqualTo(activityGlobalSearchActivity);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/ShortcutManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/ShortcutManagerTest.java
new file mode 100644
index 000000000..62e9fe3d7
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/ShortcutManagerTest.java
@@ -0,0 +1,66 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.content.pm.ShortcutManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link ShortcutManager}. */
+@RunWith(AndroidJUnit4.class)
+public class ShortcutManagerTest {
+
+  @Test
+  public void shortcutManager_applicationInstance_isNotSameAsActivityInstance() {
+    ShortcutManager applicationShortcutManager =
+        (ShortcutManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SHORTCUT_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ShortcutManager activityShortcutManager =
+                (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
+            assertThat(applicationShortcutManager).isNotSameInstanceAs(activityShortcutManager);
+          });
+    }
+  }
+
+  @Test
+  public void shortcutManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ShortcutManager activityShortcutManager =
+                (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
+            ShortcutManager anotherActivityShortcutManager =
+                (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
+            assertThat(anotherActivityShortcutManager).isSameInstanceAs(activityShortcutManager);
+          });
+    }
+  }
+
+  @Test
+  public void shortcutManager_instance_checksRateLimiting() {
+    ShortcutManager applicationShortcutManager =
+        (ShortcutManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.SHORTCUT_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            ShortcutManager activityShortcutManager =
+                (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
+
+            boolean applicationRateLimiting = applicationShortcutManager.isRateLimitingActive();
+            boolean activityRateLimiting = activityShortcutManager.isRateLimitingActive();
+
+            assertThat(activityRateLimiting).isEqualTo(applicationRateLimiting);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/StatusBarManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/StatusBarManagerTest.java
new file mode 100644
index 000000000..8c7363dd3
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/StatusBarManagerTest.java
@@ -0,0 +1,45 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link StatusBarManager}. */
+@RunWith(AndroidJUnit4.class)
+public class StatusBarManagerTest {
+  @Test
+  public void statusBarManager_applicationInstance_isNotSameAsActivityInstance() {
+    StatusBarManager applicationStatusBarManager =
+        (StatusBarManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.STATUS_BAR_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            StatusBarManager activityStatusBarManager =
+                (StatusBarManager) activity.getSystemService(Context.STATUS_BAR_SERVICE);
+            assertThat(applicationStatusBarManager).isNotSameInstanceAs(activityStatusBarManager);
+          });
+    }
+  }
+
+  @Test
+  public void statusBarManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            StatusBarManager activityStatusBarManager =
+                (StatusBarManager) activity.getSystemService(Context.STATUS_BAR_SERVICE);
+            StatusBarManager anotherActivityStatusBarManager =
+                (StatusBarManager) activity.getSystemService(Context.STATUS_BAR_SERVICE);
+            assertThat(anotherActivityStatusBarManager).isSameInstanceAs(activityStatusBarManager);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/TelecomManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/TelecomManagerTest.java
new file mode 100644
index 000000000..ff6e20d24
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/TelecomManagerTest.java
@@ -0,0 +1,65 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.telecom.TelecomManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link TelecomManager}. */
+@RunWith(AndroidJUnit4.class)
+public class TelecomManagerTest {
+
+  @Test
+  public void telecomManager_applicationInstance_isNotSameAsActivityInstance() {
+    TelecomManager applicationTelecomManager =
+        (TelecomManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.TELECOM_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelecomManager activityTelecomManager =
+                (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
+            assertThat(applicationTelecomManager).isNotSameInstanceAs(activityTelecomManager);
+          });
+    }
+  }
+
+  @Test
+  public void telecomManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelecomManager activityTelecomManager =
+                (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
+            TelecomManager anotherActivityTelecomManager =
+                (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
+            assertThat(anotherActivityTelecomManager).isSameInstanceAs(activityTelecomManager);
+          });
+    }
+  }
+
+  @Test
+  public void telecomManager_instance_retrievesSameDefaultDialer() {
+    TelecomManager applicationTelecomManager =
+        (TelecomManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.TELECOM_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TelecomManager activityTelecomManager =
+                (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
+
+            String applicationDefaultDialer = applicationTelecomManager.getDefaultDialerPackage();
+            String activityDefaultDialer = activityTelecomManager.getDefaultDialerPackage();
+
+            assertThat(activityDefaultDialer).isEqualTo(applicationDefaultDialer);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/TranslationManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/TranslationManagerTest.java
new file mode 100644
index 000000000..8bdcd4bc8
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/TranslationManagerTest.java
@@ -0,0 +1,86 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import android.os.Build;
+import android.view.translation.TranslationCapability;
+import android.view.translation.TranslationManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import java.util.Set;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link TranslationManager}. */
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+public class TranslationManagerTest {
+  private final Context application = ApplicationProvider.getApplicationContext();
+  private boolean hasTranslationManager = false;
+
+  @Before
+  public void setUp() {
+    // TranslationManager is not always bound into Android device.
+    hasTranslationManager = application.getSystemService(TranslationManager.class) != null;
+  }
+
+  @Test
+  public void translationManager_applicationInstance_isNotSameAsActivityInstance() {
+    assumeTrue(hasTranslationManager);
+    TranslationManager applicationTranslationManager =
+        application.getSystemService(TranslationManager.class);
+    assertThat(applicationTranslationManager).isNotNull();
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TranslationManager activityTranslationManager =
+                activity.getSystemService(TranslationManager.class);
+            assertThat(applicationTranslationManager)
+                .isNotSameInstanceAs(activityTranslationManager);
+          });
+    }
+  }
+
+  @Test
+  public void translationManager_activityInstance_isSameAsActivityInstance() {
+    assumeTrue(hasTranslationManager);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TranslationManager activityTranslationManager =
+                activity.getSystemService(TranslationManager.class);
+            TranslationManager anotherActivityTranslationManager =
+                activity.getSystemService(TranslationManager.class);
+            assertThat(anotherActivityTranslationManager)
+                .isSameInstanceAs(activityTranslationManager);
+          });
+    }
+  }
+
+  @Test
+  public void translationManager_instance_retrievesSameCapabilities() {
+    assumeTrue(hasTranslationManager);
+    TranslationManager applicationTranslationManager =
+        application.getSystemService(TranslationManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            TranslationManager activityTranslationManager =
+                activity.getSystemService(TranslationManager.class);
+
+            Set<TranslationCapability> applicationCapabilities =
+                applicationTranslationManager.getOnDeviceTranslationCapabilities(1, 2);
+            Set<TranslationCapability> activityCapabilities =
+                activityTranslationManager.getOnDeviceTranslationCapabilities(1, 2);
+
+            assertThat(activityCapabilities).isEqualTo(applicationCapabilities);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/UserManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/UserManagerTest.java
new file mode 100644
index 000000000..21aae4550
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/UserManagerTest.java
@@ -0,0 +1,67 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.os.UserManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link UserManager}. */
+@RunWith(AndroidJUnit4.class)
+public class UserManagerTest {
+
+  @Test
+  public void userManager_activityInstance_isSameAsAnotherActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UserManager activityUserManager =
+                (UserManager) activity.getSystemService(Context.USER_SERVICE);
+            UserManager anotherActivityUserManager =
+                (UserManager) activity.getSystemService(Context.USER_SERVICE);
+            assertThat(anotherActivityUserManager).isSameInstanceAs(activityUserManager);
+          });
+    }
+  }
+
+  @Test
+  public void userManager_applicationInstance_isNotSameAsActivityInstance() {
+    UserManager applicationUserManager =
+        (UserManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UserManager activityUserManager =
+                (UserManager) activity.getSystemService(Context.USER_SERVICE);
+            assertThat(applicationUserManager).isNotSameInstanceAs(activityUserManager);
+          });
+    }
+  }
+
+  @Test
+  public void userManager_isUserAGoat_consistentAcrossContexts() {
+    UserManager applicationUserManager =
+        (UserManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            UserManager activityUserManager =
+                (UserManager) activity.getSystemService(Context.USER_SERVICE);
+
+            boolean isUserAGoatApplication = applicationUserManager.isUserAGoat();
+            boolean isUserAGoatActivity = activityUserManager.isUserAGoat();
+
+            assertThat(isUserAGoatApplication).isEqualTo(isUserAGoatActivity);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/VcnManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/VcnManagerTest.java
new file mode 100644
index 000000000..31a51ce7e
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/VcnManagerTest.java
@@ -0,0 +1,69 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.vcn.VcnManager;
+import android.os.Build;
+import android.os.ParcelUuid;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link VcnManager}. */
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+@RunWith(AndroidJUnit4.class)
+public class VcnManagerTest {
+
+  @Test
+  public void vcnManager_applicationInstance_isNotSameAsActivityInstance() {
+    VcnManager applicationVcnManager =
+        ApplicationProvider.getApplicationContext().getSystemService(VcnManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VcnManager activityVcnManager = activity.getSystemService(VcnManager.class);
+            assertThat(applicationVcnManager).isNotSameInstanceAs(activityVcnManager);
+          });
+    }
+  }
+
+  @Test
+  public void vcnManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VcnManager activityVcnManager = activity.getSystemService(VcnManager.class);
+            VcnManager anotherActivityVcnManager = activity.getSystemService(VcnManager.class);
+            assertThat(anotherActivityVcnManager).isSameInstanceAs(activityVcnManager);
+          });
+    }
+  }
+
+  @Test
+  public void vcnManager_instance_retrievesSameConfiguredSubscriptionGroups() {
+    VcnManager applicationVcnManager =
+        ApplicationProvider.getApplicationContext().getSystemService(VcnManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VcnManager activityVcnManager = activity.getSystemService(VcnManager.class);
+
+            List<ParcelUuid> applicationConfiguredSubscriptionGroups =
+                applicationVcnManager.getConfiguredSubscriptionGroups();
+            List<ParcelUuid> activityConfiguredSubscriptionGroups =
+                activityVcnManager.getConfiguredSubscriptionGroups();
+
+            assertThat(applicationConfiguredSubscriptionGroups).isNotNull();
+            assertThat(activityConfiguredSubscriptionGroups).isNotNull();
+
+            assertThat(activityConfiguredSubscriptionGroups)
+                .isEqualTo(applicationConfiguredSubscriptionGroups);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/VirtualDeviceManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/VirtualDeviceManagerTest.java
new file mode 100644
index 000000000..d012e5a43
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/VirtualDeviceManagerTest.java
@@ -0,0 +1,79 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.companion.virtual.VirtualDevice;
+import android.companion.virtual.VirtualDeviceManager;
+import android.content.Context;
+import android.os.Build;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link VirtualDeviceManager}. */
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+public class VirtualDeviceManagerTest {
+
+  @Test
+  public void virtualDeviceManager_applicationInstance_isNotSameAsActivityInstance() {
+    VirtualDeviceManager applicationVirtualDeviceManager =
+        (VirtualDeviceManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VirtualDeviceManager activityVirtualDeviceManager =
+                (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+            assertThat(applicationVirtualDeviceManager)
+                .isNotSameInstanceAs(activityVirtualDeviceManager);
+          });
+    }
+  }
+
+  @Test
+  public void virtualDeviceManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VirtualDeviceManager activityVirtualDeviceManager =
+                (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+            VirtualDeviceManager anotherActivityVirtualDeviceManager =
+                (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+            assertThat(anotherActivityVirtualDeviceManager)
+                .isSameInstanceAs(activityVirtualDeviceManager);
+          });
+    }
+  }
+
+  @Test
+  public void virtualDeviceManager_instance_retrievesSameVirtualDevices() {
+    VirtualDeviceManager applicationVirtualDeviceManager =
+        (VirtualDeviceManager)
+            ApplicationProvider.getApplicationContext()
+                .getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VirtualDeviceManager activityVirtualDeviceManager =
+                (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+
+            List<VirtualDevice> applicationVirtualDevices =
+                applicationVirtualDeviceManager.getVirtualDevices();
+            List<VirtualDevice> activityVirtualDevices =
+                activityVirtualDeviceManager.getVirtualDevices();
+
+            assertThat(applicationVirtualDevices).isNotNull();
+            assertThat(activityVirtualDevices).isNotNull();
+
+            assertThat(activityVirtualDevices).isEqualTo(applicationVirtualDevices);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/VpnManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/VpnManagerTest.java
new file mode 100644
index 000000000..34c71f672
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/VpnManagerTest.java
@@ -0,0 +1,66 @@
+package android.app;
+
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.VpnManager;
+import android.net.VpnProfileState;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SdkSuppress;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link VpnManager}. */
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = R)
+public class VpnManagerTest {
+
+  @Test
+  public void vpnManager_applicationInstance_isNotSameAsActivityInstance() {
+    VpnManager applicationVpnManager =
+        ApplicationProvider.getApplicationContext().getSystemService(VpnManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VpnManager activityVpnManager = activity.getSystemService(VpnManager.class);
+            assertThat(applicationVpnManager).isNotSameInstanceAs(activityVpnManager);
+          });
+    }
+  }
+
+  @Test
+  public void vpnManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VpnManager activityVpnManager = activity.getSystemService(VpnManager.class);
+            VpnManager anotherActivityVpnManager = activity.getSystemService(VpnManager.class);
+            assertThat(anotherActivityVpnManager).isSameInstanceAs(activityVpnManager);
+          });
+    }
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = TIRAMISU)
+  public void vpnManager_instance_retrievesSameProfileState() {
+    VpnManager applicationVpnManager =
+        ApplicationProvider.getApplicationContext().getSystemService(VpnManager.class);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            VpnManager activityVpnManager = activity.getSystemService(VpnManager.class);
+
+            VpnProfileState applicationProfileState =
+                applicationVpnManager.getProvisionedVpnProfileState();
+            VpnProfileState activityProfileState =
+                activityVpnManager.getProvisionedVpnProfileState();
+
+            assertThat(activityProfileState).isEqualTo(applicationProfileState);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/WallpaperManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/WallpaperManagerTest.java
new file mode 100644
index 000000000..24a631de6
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/WallpaperManagerTest.java
@@ -0,0 +1,85 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.content.Context;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link WallpaperManager}. */
+@RunWith(AndroidJUnit4.class)
+public class WallpaperManagerTest {
+  private WallpaperManager wallpaperManager;
+  private boolean isWallpaperSupported = false;
+
+  @Before
+  public void setUp() {
+    // Test code can't access com.android.internal config value to check whether the current running
+    // Android
+    // supports WallpaperManagerService, and it uses returned WallpaperManager's flag to check it.
+    Object manager =
+        ApplicationProvider.getApplicationContext().getSystemService(Context.WALLPAPER_SERVICE);
+    if (manager != null) {
+      wallpaperManager = (WallpaperManager) manager;
+    }
+
+    isWallpaperSupported = wallpaperManager != null && wallpaperManager.isWallpaperSupported();
+  }
+
+  @Test
+  public void wallpaperManager_applicationInstance_matchesExpectedBehavior() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WallpaperManager activityWallpaperManager =
+                (WallpaperManager) activity.getSystemService(Context.WALLPAPER_SERVICE);
+            // If WallpaperManagerService is not supported by the device, it returns a special
+            // WindowManager implementation called DisabledWallpaperManager, and it uses
+            // singleton for all Context instances.
+            if (isWallpaperSupported) {
+              assertThat(wallpaperManager).isNotSameInstanceAs(activityWallpaperManager);
+            } else {
+              assertThat(wallpaperManager).isSameInstanceAs(activityWallpaperManager);
+            }
+          });
+    }
+  }
+
+  @Test
+  public void wallpaperManager_activityInstance_isSameAsActivityInstance() {
+    assumeTrue(isWallpaperSupported);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WallpaperManager activityWallpaperManager =
+                (WallpaperManager) activity.getSystemService(Context.WALLPAPER_SERVICE);
+            WallpaperManager anotherActivityWallpaperManager =
+                (WallpaperManager) activity.getSystemService(Context.WALLPAPER_SERVICE);
+            assertThat(anotherActivityWallpaperManager).isSameInstanceAs(activityWallpaperManager);
+          });
+    }
+  }
+
+  @Test
+  public void wallpaperManager_instance_retrievesSameWallpaper() {
+    assumeTrue(isWallpaperSupported);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WallpaperManager activityWallpaperManager =
+                (WallpaperManager) activity.getSystemService(Context.WALLPAPER_SERVICE);
+
+            WallpaperInfo applicationWallpaper = wallpaperManager.getWallpaperInfo();
+            WallpaperInfo activityWallpaper = activityWallpaperManager.getWallpaperInfo();
+
+            assertThat(activityWallpaper).isEqualTo(applicationWallpaper);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/WifiAwareManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/WifiAwareManagerTest.java
new file mode 100644
index 000000000..db35da0f2
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/WifiAwareManagerTest.java
@@ -0,0 +1,90 @@
+package android.app;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+import android.Manifest;
+import android.content.Context;
+import android.net.wifi.aware.AwareResources;
+import android.net.wifi.aware.WifiAwareManager;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link WifiAwareManager}. */
+@RunWith(AndroidJUnit4.class)
+public class WifiAwareManagerTest {
+  private final Context application = ApplicationProvider.getApplicationContext();
+  private boolean hasWifiAwareManager = false;
+
+  @Rule
+  public GrantPermissionRule mRuntimePermissionRule =
+      GrantPermissionRule.grant(
+          Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.CHANGE_WIFI_STATE);
+
+  @Before
+  public void setUp() {
+    // WifiAwareManager is not always bound into Android device.
+    hasWifiAwareManager = application.getSystemService(WifiAwareManager.class) != null;
+  }
+
+  @Test
+  public void wifiAwareManager_applicationInstance_isSameAsActivityInstance() {
+    assumeTrue(hasWifiAwareManager);
+    WifiAwareManager applicationWifiAwareManager =
+        (WifiAwareManager) application.getSystemService(Context.WIFI_AWARE_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiAwareManager activityWifiAwareManager =
+                (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
+            assertThat(applicationWifiAwareManager).isSameInstanceAs(activityWifiAwareManager);
+          });
+    }
+  }
+
+  @Test
+  public void wifiAwareManager_activityInstance_isSameAsActivityInstance() {
+    assumeTrue(hasWifiAwareManager);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiAwareManager activityWifiAwareManager =
+                (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
+            WifiAwareManager anotherActivityWifiAwareManager =
+                (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
+            assertThat(anotherActivityWifiAwareManager).isSameInstanceAs(activityWifiAwareManager);
+          });
+    }
+  }
+
+  @Test
+  public void wifiAwareManager_instance_getAvailableAwareResourcesIsConsistent() {
+    assumeTrue(hasWifiAwareManager);
+    WifiAwareManager applicationWifiAwareManager =
+        (WifiAwareManager) application.getSystemService(Context.WIFI_AWARE_SERVICE);
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiAwareManager activityWifiAwareManager =
+                (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
+
+            assertThat(activityWifiAwareManager).isNotNull();
+
+            AwareResources applicationAwareResources =
+                applicationWifiAwareManager.getAvailableAwareResources();
+            AwareResources activityAwareResources =
+                activityWifiAwareManager.getAvailableAwareResources();
+
+            assertThat(activityAwareResources).isEqualTo(applicationAwareResources);
+          });
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/androidTest/java/android/app/WifiP2pManagerTest.java b/integration_tests/ctesque/src/androidTest/java/android/app/WifiP2pManagerTest.java
new file mode 100644
index 000000000..1141736d7
--- /dev/null
+++ b/integration_tests/ctesque/src/androidTest/java/android/app/WifiP2pManagerTest.java
@@ -0,0 +1,109 @@
+package android.app;
+
+import static android.os.Looper.getMainLooper;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.Manifest;
+import android.content.Context;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.os.Build;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.rule.GrantPermissionRule;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.testapp.TestActivity;
+
+/** Compatibility test for {@link WifiP2pManager}. */
+@RunWith(AndroidJUnit4.class)
+public class WifiP2pManagerTest {
+
+  @Rule
+  public GrantPermissionRule mRuntimePermissionRule =
+      GrantPermissionRule.grant(
+          Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.CHANGE_WIFI_STATE);
+
+  @Test
+  public void wifiP2pManager_applicationInstance_isSameOrDifferentAsActivityInstance() {
+    WifiP2pManager applicationWifiP2pManager =
+        (WifiP2pManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.WIFI_P2P_SERVICE);
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiP2pManager activityWifiP2pManager =
+                (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+              assertThat(applicationWifiP2pManager).isNotSameInstanceAs(activityWifiP2pManager);
+            } else {
+              assertThat(applicationWifiP2pManager).isSameInstanceAs(activityWifiP2pManager);
+            }
+          });
+    }
+  }
+
+  @Test
+  public void wifiP2pManager_activityInstance_isSameAsActivityInstance() {
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiP2pManager activityWifiP2pManager =
+                (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
+            WifiP2pManager anotherActivityWifiP2pManager =
+                (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
+            assertThat(anotherActivityWifiP2pManager).isSameInstanceAs(activityWifiP2pManager);
+          });
+    }
+  }
+
+  @Test
+  public void wifiP2pManager_instance_retrievesSameGroupInfo() throws InterruptedException {
+    WifiP2pManager applicationWifiP2pManager =
+        (WifiP2pManager)
+            ApplicationProvider.getApplicationContext().getSystemService(Context.WIFI_P2P_SERVICE);
+    WifiP2pManager.Channel applicationChannel =
+        applicationWifiP2pManager.initialize(
+            ApplicationProvider.getApplicationContext(), getMainLooper(), null);
+
+    CountDownLatch latch = new CountDownLatch(2);
+    final String[] applicationGroupNameHolder = new String[1];
+    final String[] activityGroupNameHolder = new String[1];
+
+    applicationWifiP2pManager.requestGroupInfo(
+        applicationChannel,
+        group -> {
+          if (group != null) {
+            applicationGroupNameHolder[0] = group.getNetworkName();
+          }
+          latch.countDown();
+        });
+
+    try (ActivityScenario<TestActivity> scenario = ActivityScenario.launch(TestActivity.class)) {
+      scenario.onActivity(
+          activity -> {
+            WifiP2pManager activityWifiP2pManager =
+                (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
+            WifiP2pManager.Channel activityChannel =
+                activityWifiP2pManager.initialize(activity, activity.getMainLooper(), null);
+
+            activityWifiP2pManager.requestGroupInfo(
+                activityChannel,
+                group -> {
+                  if (group != null) {
+                    activityGroupNameHolder[0] = group.getNetworkName();
+                  }
+                  latch.countDown();
+                });
+          });
+    }
+
+    latch.await(5, TimeUnit.SECONDS);
+
+    assertThat(applicationGroupNameHolder[0]).isEqualTo(activityGroupNameHolder[0]);
+  }
+}
diff --git a/integration_tests/ctesque/src/main/AndroidManifest.xml b/integration_tests/ctesque/src/main/AndroidManifest.xml
index 56305cad8..b4850e371 100644
--- a/integration_tests/ctesque/src/main/AndroidManifest.xml
+++ b/integration_tests/ctesque/src/main/AndroidManifest.xml
@@ -3,7 +3,18 @@
   Manifest for ctesque tests
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android">
+  <uses-permission android:name="android.permission.BLUETOOTH" />
+  <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
   <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
   <uses-permission android:name="android.permission.GET_ACCOUNTS" />
+  <uses-permission android:name="android.permission.INTERNET" />
+  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+  <uses-permission android:name="android.permission.USE_BIOMETRIC" />
+  <uses-permission android:name="android.permission.READ_PHONE_STATE" />
+  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+  <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
   <application />
 </manifest>
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java b/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
index 44eb1a5a0..ecbd2860b 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/app/InstrumentationTest.java
@@ -3,7 +3,6 @@ package android.app;
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
 import android.os.Handler;
 import android.os.Looper;
@@ -12,14 +11,12 @@ import java.util.ArrayList;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.LooperMode;
 
 /**
  * Tests to verify android.app.Instrumentation APIs behave consistently between Robolectric and
  * device.
  */
 @RunWith(AndroidJUnit4.class)
-@LooperMode(PAUSED)
 public final class InstrumentationTest {
 
   /**
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
index 9dddc1e33..d0b4d7094 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/content/res/AssetManagerTest.java
@@ -7,6 +7,7 @@ import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.io.CharStreams;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -68,6 +69,22 @@ public class AssetManagerTest {
     assertThat(assetFileDescriptor.getLength()).isEqualTo(11);
   }
 
+  @Test
+  public void openFd_readLargeAsset() throws Exception {
+    try (AssetFileDescriptor assetFileDescriptor = assetManager.openFd("robolectric.png")) {
+      FileInputStream fis = assetFileDescriptor.createInputStream();
+      ByteArrayOutputStream bos = new ByteArrayOutputStream();
+      int read = 0;
+      // choose a buffer size < file length
+      byte[] buf = new byte[8192];
+      while ((read = fis.read(buf)) > 0) {
+        bos.write(buf, 0, read);
+      }
+      byte[] output = bos.toByteArray();
+      assertThat(output).hasLength(23447);
+    }
+  }
+
   @Test
   public void open_shouldProvideFileDescriptor() throws Exception {
     File file =
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
index bd08d5712..a2ff08f65 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/database/SQLiteDatabaseTest.java
@@ -4,11 +4,13 @@ import static android.os.Build.VERSION_CODES.M;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertThrows;
+import static org.junit.Assume.assumeTrue;
 
 import android.content.ContentValues;
 import android.database.sqlite.SQLiteConstraintException;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
+import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.SdkSuppress;
@@ -18,6 +20,7 @@ import com.google.common.base.Throwables;
 import com.google.common.io.ByteStreams;
 import java.io.File;
 import java.io.PrintStream;
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.concurrent.ExecutorService;
@@ -35,7 +38,8 @@ public class SQLiteDatabaseTest {
   private File databasePath;
 
   @Before
-  public void setUp() {
+  public void setUp() throws Exception {
+    assumeTrue(isNativeSqliteMode());
     databasePath = ApplicationProvider.getApplicationContext().getDatabasePath("database.db");
     databasePath.getParentFile().mkdirs();
 
@@ -50,10 +54,31 @@ public class SQLiteDatabaseTest {
             + ");");
   }
 
+  /**
+   * If running on Robolectric, this test only works in RobolectriSQLite native mode. Attempt to
+   * figure this out
+   */
+  private boolean isNativeSqliteMode() throws IllegalAccessException, NoSuchFieldException {
+    if (!Build.FINGERPRINT.contains("robolectric")) {
+      // not robolectric, using native sql of course
+      return true;
+    }
+    Field internalRoboField = CursorWindow.class.getField("__robo_data__");
+    return internalRoboField
+        .get(new CursorWindow("cw"))
+        .getClass()
+        .getName()
+        .contains("ShadowNativeCursorWindow");
+  }
+
   @After
   public void tearDown() {
-    database.close();
-    assertThat(databasePath.delete()).isTrue();
+    if (database != null) {
+      database.close();
+    }
+    if (databasePath != null) {
+      assertThat(databasePath.delete()).isTrue();
+    }
   }
 
   @Test
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java
new file mode 100644
index 000000000..e81fda489
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsConstantsTest.java
@@ -0,0 +1,70 @@
+package android.system.ctesque;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.system.OsConstants;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests to verify {@link OsConstants} is consistent on both Robolectric and emulator. */
+@RunWith(AndroidJUnit4.class)
+public final class OsConstantsTest {
+
+  // list of OsConstants field names that are expected to be 0
+  private static final Set<String> zeroValFields =
+      Set.of(
+          "AF_UNSPEC",
+          "CAP_CHOWN",
+          "EXIT_SUCCESS",
+          "F_DUPFD",
+          "F_OK",
+          "F_RDLCK",
+          "ICMP_ECHOREPLY",
+          "IPPROTO_IP",
+          "NETLINK_ROUTE",
+          "O_RDONLY",
+          "PROT_NONE",
+          "RT_SCOPE_UNIVERSE",
+          "SEEK_SET",
+          "SHUT_RD",
+          "STDIN_FILENO",
+          "_SC_ARG_MAX");
+
+  @Test
+  public void valuesAreDistinct() throws Exception {
+    assertThat(OsConstants.errnoName(OsConstants.EAGAIN)).isEqualTo("EAGAIN");
+    assertThat(OsConstants.errnoName(OsConstants.EBADF)).isEqualTo("EBADF");
+  }
+
+  // spot check a few constants
+  @Test
+  public void valuesAreExpected() {
+    assertThat(OsConstants.S_IFMT).isEqualTo(0x000f000);
+    assertThat(OsConstants.S_IFDIR).isEqualTo(0x0004000);
+    assertThat(OsConstants.S_IFREG).isEqualTo(0x0008000);
+    assertThat(OsConstants.S_IFLNK).isEqualTo(0x000a000);
+  }
+
+  // spot check constants are non-zero. This is to check case where a new constant
+  // is added in a new SDK and there isn't support to populate it in the shadow yet
+  @Test
+  public void checkUninitialized() throws IllegalAccessException {
+    List<String> uninitializedFields = new ArrayList<>();
+    for (Field field : OsConstants.class.getDeclaredFields()) {
+
+      if (field.getType().equals(int.class) && Modifier.isStatic(field.getModifiers())) {
+        if (field.getInt(null) == 0) {
+          uninitializedFields.add(field.getName());
+        }
+      }
+    }
+    uninitializedFields.removeAll(zeroValFields);
+    assertThat(uninitializedFields).isEmpty();
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsTest.java b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsTest.java
new file mode 100644
index 000000000..208666d3a
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/system/ctesque/OsTest.java
@@ -0,0 +1,149 @@
+package android.system.ctesque;
+
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.R;
+import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assume.assumeTrue;
+
+import android.os.Build.VERSION;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+import android.system.StructStat;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.RandomAccessFile;
+import java.time.Duration;
+import java.util.Arrays;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class OsTest {
+
+  private File file;
+  private String path;
+
+  @Before
+  public void setUp() throws Exception {
+    assumeTrue(VERSION.SDK_INT >= O); // Robolectric only has realistic support for O and up
+    File outputDir = getApplicationContext().getCacheDir();
+    this.file = File.createTempFile("OsTest", ".txt", outputDir);
+    this.path = file.getAbsolutePath();
+    try (FileOutputStream outputStream = new FileOutputStream(file)) {
+      outputStream.write("some UTF-8\u202Fcontent in a file".getBytes(UTF_8));
+    }
+  }
+
+  @After
+  public void tearDown() {
+    if (file != null && file.exists()) {
+      file.delete();
+    }
+  }
+
+  @Test
+  public void rootIsExecutable() throws Exception {
+    int fileMode = Os.stat("/").st_mode;
+    assertThat(fileMode & OsConstants.S_IXUSR).isEqualTo(OsConstants.S_IXUSR);
+    assertThat(fileMode & OsConstants.S_IXGRP).isEqualTo(OsConstants.S_IXGRP);
+    assertThat(fileMode & OsConstants.S_IXOTH).isEqualTo(OsConstants.S_IXOTH);
+  }
+
+  @Test
+  public void getStat_returnCorrectMode() throws Exception {
+    StructStat stat = Os.stat(path);
+    // S_IFREG means regular file
+    assertThat(stat.st_mode & OsConstants.S_IFREG).isEqualTo(OsConstants.S_IFREG);
+  }
+
+  @Test
+  public void getStat_returnCorrectSize() throws Exception {
+    StructStat stat = Os.stat(path);
+    assertThat(stat.st_size).isEqualTo(file.length());
+  }
+
+  @Test
+  public void getStat_returnCorrectModifiedTime() throws Exception {
+    StructStat stat = Os.stat(path);
+    assertThat(stat.st_mtime).isEqualTo(Duration.ofMillis(file.lastModified()).getSeconds());
+  }
+
+  @Test
+  public void getStat_executableFalse() throws Exception {
+    int fileMode = Os.stat(path).st_mode;
+    assertThat(fileMode & OsConstants.S_IXUSR).isEqualTo(0);
+
+    assertTrue(file.setExecutable(true));
+    fileMode = Os.stat(path).st_mode;
+    assertThat(fileMode & OsConstants.S_IXUSR).isEqualTo(OsConstants.S_IXUSR);
+  }
+
+  @Test
+  public void memfdCreate_returnNoneNullFileDescriptor() throws Exception {
+    assumeTrue(VERSION.SDK_INT >= R);
+    FileDescriptor arscFile = Os.memfd_create("remote_views_theme_colors.arsc", /* flags= */ 0);
+    assertThat(arscFile).isNotNull();
+  }
+
+  @Test
+  public void pread_validateExtractsContentWithOffset() throws Exception {
+    try (FileInputStream fis = new FileInputStream(file)) {
+      FileDescriptor fd = fis.getFD();
+      assertThat(fd.valid()).isTrue();
+
+      final int bytesCount = "content".length();
+      final int bytesOffset = 5;
+      final byte[] buffer = new byte[bytesCount + 2 * bytesOffset];
+      Arrays.fill(buffer, (byte) '-');
+
+      final int offsetInFile = "some UTF-8\u202F".getBytes(UTF_8).length;
+
+      assertThat(Os.pread(fd, buffer, bytesOffset, bytesCount, offsetInFile)).isEqualTo(bytesCount);
+      assertThat(new String(buffer, UTF_8)).isEqualTo("-----content-----");
+    }
+  }
+
+  @Test
+  public void pread_handleFNF() throws Exception {
+    // API 21 throws IOException not ErrnoException
+    assumeTrue(VERSION.SDK_INT > LOLLIPOP);
+    try (FileInputStream fis = new FileInputStream(file)) {
+      FileDescriptor fd = fis.getFD();
+      assertThat(fd.valid()).isTrue();
+
+      // Delete the file under test.
+      fis.close();
+      assertThat(file.delete()).isTrue();
+
+      final byte[] buffer = new byte[10];
+      Arrays.fill(buffer, (byte) '-');
+      assertThrows(ErrnoException.class, () -> Os.pread(fd, buffer, 0, 5, 0));
+    }
+  }
+
+  // verify pread can be called multiple continuous times
+  // this is intended to verify behavior when reading from a large file
+  @Test
+  public void pread_chained() throws Exception {
+    FileDescriptor fd = new RandomAccessFile(file, "r").getFD();
+
+    final byte[] buffer = new byte[10];
+    int read = 1;
+    int offset = 0;
+    while (read > 0) {
+      read = Os.pread(fd, buffer, 0, 5, offset);
+      offset += read;
+    }
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/telephony/PhoneNumberUtilsTest.java b/integration_tests/ctesque/src/sharedTest/java/android/telephony/PhoneNumberUtilsTest.java
new file mode 100644
index 000000000..765ceb43a
--- /dev/null
+++ b/integration_tests/ctesque/src/sharedTest/java/android/telephony/PhoneNumberUtilsTest.java
@@ -0,0 +1,20 @@
+package android.telephony;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Tests that Robolectric's android.telephony.PhoneNumberUtils support is consistent with device.
+ */
+@RunWith(AndroidJUnit4.class)
+public class PhoneNumberUtilsTest {
+  // This test requires the libphonenumber metadata in the Android SDK.
+  @Test
+  public void formatNumber() {
+    String number1 = "+16501230003";
+    assertThat(PhoneNumberUtils.formatNumber(number1, "us")).isEqualTo("+1 650-123-0003");
+  }
+}
diff --git a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
index 073f050bf..1629210e9 100644
--- a/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
+++ b/integration_tests/ctesque/src/sharedTest/java/android/view/accessibility/AccessibilityNodeInfoTest.java
@@ -18,13 +18,18 @@ package android.view.accessibility;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.os.Build;
+import android.os.Parcel;
 import android.view.View;
+import androidx.test.core.app.ActivityScenario;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.SdkSuppress;
 import androidx.test.platform.app.InstrumentationRegistry;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.testapp.ActivityWithAnotherTheme;
+import org.robolectric.util.ReflectionHelpers;
 
 /**
  * CTS for {@link AccessibilityNodeInfo}.
@@ -53,4 +58,60 @@ public class AccessibilityNodeInfoTest {
 
     assertThat(secondInfo.getWindowId()).isEqualTo(firstInfo.getWindowId());
   }
+
+  /** Pre-O, the window id is set to Integer.MAX_VALUE. Post-O, the window id is set to -1. */
+  @Test
+  public void obtain_noArgs_windowId() {
+    assertThat(AccessibilityNodeInfo.obtain().getWindowId())
+        .isEqualTo(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ? -1 : Integer.MAX_VALUE);
+  }
+
+  @Test
+  public void obtain_withWindow_returnsWindowId() {
+    try (ActivityScenario<ActivityWithAnotherTheme> scenario =
+        ActivityScenario.launch(ActivityWithAnotherTheme.class)) {
+      scenario.onActivity(
+          activity -> {
+            View rootView = activity.findViewById(android.R.id.content);
+            AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(rootView);
+            long sourceNodeId = ReflectionHelpers.getField(node, "mSourceNodeId");
+            assertThat(sourceNodeId).isNotEqualTo(-1);
+          });
+    }
+  }
+
+  @Test
+  public void getText_afterCreateFromParcel() {
+    AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain();
+    node.setText("hello world");
+    node.setContentDescription("hello world");
+
+    Parcel parcel = Parcel.obtain();
+    node.writeToParcel(parcel, /* flags= */ 0);
+    parcel.setDataPosition(0);
+    final AccessibilityNodeInfo node2 = AccessibilityNodeInfo.CREATOR.createFromParcel(parcel);
+
+    assertThat(node.getText().toString()).isEqualTo(node2.getText().toString());
+    assertThat(node.getContentDescription().toString())
+        .isEqualTo(node2.getContentDescription().toString());
+  }
+
+  @Test
+  @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  @Config(minSdk = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+  @GraphicsMode(GraphicsMode.Mode.NATIVE)
+  public void directAccessibilityConnection_queryChildCount() {
+    try (ActivityScenario<ActivityWithAnotherTheme> scenario =
+        ActivityScenario.launch(ActivityWithAnotherTheme.class)) {
+      scenario.onActivity(
+          activity -> {
+            View rootView = activity.findViewById(android.R.id.content);
+            AccessibilityNodeInfo node = rootView.createAccessibilityNodeInfo();
+            node.setQueryFromAppProcessEnabled(rootView, true);
+            assertThat(node.getChildCount()).isEqualTo(1);
+            assertThat(node.getChild(0)).isNotNull();
+            assertThat(node.getWindowId()).isEqualTo(-1);
+          });
+    }
+  }
 }
diff --git a/integration_tests/dependency-on-stubs/build.gradle b/integration_tests/dependency-on-stubs/build.gradle
deleted file mode 100644
index a4b40f1a0..000000000
--- a/integration_tests/dependency-on-stubs/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-// test with a project that depends on the stubs jar, not org.robolectric:android-all
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions.unitTests.includeAndroidResources true
-}
-
-dependencies {
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-}
diff --git a/integration_tests/dependency-on-stubs/build.gradle.kts b/integration_tests/dependency-on-stubs/build.gradle.kts
new file mode 100644
index 000000000..743cec6ce
--- /dev/null
+++ b/integration_tests/dependency-on-stubs/build.gradle.kts
@@ -0,0 +1,29 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+// test with a project that depends on the stubs jar, not org.robolectric:android-all
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
diff --git a/integration_tests/jacoco-offline/build.gradle b/integration_tests/jacoco-offline/build.gradle
deleted file mode 100644
index 5f047b57f..000000000
--- a/integration_tests/jacoco-offline/build.gradle
+++ /dev/null
@@ -1,94 +0,0 @@
-plugins {
-    alias(libs.plugins.jacoco)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-def jacocoVersion = libs.versions.jacoco.get()
-
-jacoco {
-    toolVersion = jacocoVersion
-}
-
-configurations {
-    jacocoAnt
-    jacocoRuntime
-}
-
-dependencies {
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation "org.jacoco:org.jacoco.agent:$jacocoVersion:runtime"
-}
-
-def unitTestTaskName = "test"
-
-def compileSourceTaskName = "classes"
-
-def javaDir = layout.buildDirectory.dir("classes/java/main").get().asFile
-
-def kotlinDir = layout.buildDirectory.dir("classes/kotlin/main").get().asFile
-
-def jacocoInstrumentedClassesOutputDir = layout.buildDirectory.dir("$jacocoVersion/classes/java/classes-instrumented").get().asFile
-
-// make sure it's evaluated after the AGP evaluation.
-afterEvaluate {
-    tasks.named(compileSourceTaskName).configure { task ->
-        task.doLast {
-            println "[JaCoCo]:Generating JaCoCo instrumented classes for the build."
-
-            if (jacocoInstrumentedClassesOutputDir.exists()) {
-                println "[JaCoCo]:Classes had been instrumented."
-                return
-            }
-
-            ant.taskdef(name: 'instrument',
-                    classname: 'org.jacoco.ant.InstrumentTask',
-                    classpath: configurations.jacocoAnt.asPath)
-
-            if (javaDir.exists()) {
-                ant.instrument(destdir: jacocoInstrumentedClassesOutputDir.path) {
-                    fileset(
-                            dir: javaDir.path,
-                            excludes: []
-                    )
-                }
-            } else {
-                println "Classes directory with path: $javaDir does not existed."
-            }
-
-            if (kotlinDir.exists()) {
-                ant.instrument(destdir: jacocoInstrumentedClassesOutputDir.path) {
-                    fileset(
-                            dir: kotlinDir.path,
-                            excludes: []
-                    )
-                }
-            } else {
-                println "Classes directory with path: $kotlinDir does not existed."
-            }
-        }
-    }
-
-    def executionDataFilePath = layout.buildDirectory.dir("jacoco").get().file("${unitTestTaskName}.exec").getAsFile().path
-
-    // put JaCoCo instrumented classes and JaCoCoRuntime to the beginning of the JVM classpath.
-    tasks.named(unitTestTaskName).configure { task ->
-        task.doFirst {
-            jacoco {
-                // disable JaCoCo on-the-fly from Gradle JaCoCo plugin.
-                enabled = false
-            }
-
-            println "[JaCoCo]:Modifying classpath of tests JVM."
-
-            systemProperty 'jacoco-agent.destfile', executionDataFilePath
-
-            classpath = files(jacocoInstrumentedClassesOutputDir.path) + classpath + configurations.jacocoRuntime
-
-            println "Final test JVM classpath is ${classpath.getAsPath()}"
-        }
-    }
-}
diff --git a/integration_tests/jacoco-offline/build.gradle.kts b/integration_tests/jacoco-offline/build.gradle.kts
new file mode 100644
index 000000000..6a57af439
--- /dev/null
+++ b/integration_tests/jacoco-offline/build.gradle.kts
@@ -0,0 +1,86 @@
+plugins {
+  alias(libs.plugins.jacoco)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+val jacocoVersion = libs.versions.jacoco.get()
+val jacocoAnt: Configuration by configurations.getting
+val jacocoRuntime: Configuration by configurations.creating
+
+jacoco { toolVersion = jacocoVersion }
+
+dependencies {
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation("org.jacoco:org.jacoco.agent:$jacocoVersion:runtime")
+}
+
+val unitTestTaskName = "test"
+val javaDir = layout.buildDirectory.dir("classes/java/main").get().asFile
+val kotlinDir = layout.buildDirectory.dir("classes/kotlin/main").get().asFile
+val jacocoInstrumentedClassesOutputDir =
+  layout.buildDirectory.dir("$jacocoVersion/classes/java/classes-instrumented").get().asFile
+
+// Make sure it's evaluated after the AGP evaluation.
+afterEvaluate {
+  tasks.classes.configure {
+    doLast {
+      logger.debug("[JaCoCo] Generating JaCoCo instrumented classes for the build.")
+
+      if (jacocoInstrumentedClassesOutputDir.exists()) {
+        logger.debug("[JaCoCo] Classes had been instrumented.")
+        return@doLast
+      }
+
+      ant.withGroovyBuilder {
+        "taskdef"(
+          "name" to "instrument",
+          "classname" to "org.jacoco.ant.InstrumentTask",
+          "classpath" to jacocoAnt.asPath,
+        )
+      }
+
+      if (javaDir.exists()) {
+        ant.withGroovyBuilder {
+          "instrument"("destdir" to jacocoInstrumentedClassesOutputDir.path) {
+            "fileset"("dir" to javaDir.path, "excludes" to "")
+          }
+        }
+      } else {
+        logger.debug("[JaCoCo] Classes directory with path '{}' does not exist.", javaDir)
+      }
+
+      if (kotlinDir.exists()) {
+        ant.withGroovyBuilder {
+          "instrument"("destdir" to jacocoInstrumentedClassesOutputDir.path) {
+            "fileset"("dir" to kotlinDir.path, "excludes" to "")
+          }
+        }
+      } else {
+        logger.debug("[JaCoCo] Classes directory with path '{}' does not exist.", kotlinDir)
+      }
+    }
+  }
+
+  val executionDataFilePath =
+    layout.buildDirectory.dir("jacoco").get().file("${unitTestTaskName}.exec").asFile.path
+
+  // Put JaCoCo instrumented classes and JaCoCoRuntime at the beginning of the JVM classpath.
+  tasks.named<Test>(unitTestTaskName).configure {
+    doFirst {
+      // Disable JaCoCo on-the-fly from Gradle JaCoCo plugin.
+      extensions.configure<JacocoTaskExtension> { isEnabled = false }
+
+      logger.debug("[JaCoCo] Modifying classpath of tests JVM.")
+
+      systemProperty("jacoco-agent.destfile", executionDataFilePath)
+
+      classpath = files(jacocoInstrumentedClassesOutputDir.path) + classpath + jacocoRuntime
+
+      logger.debug("[JaCoCo] Final test JVM classpath is ${classpath.asPath}")
+    }
+  }
+}
diff --git a/integration_tests/kotlin/build.gradle b/integration_tests/kotlin/build.gradle
deleted file mode 100644
index 7bdd8fcf9..000000000
--- a/integration_tests/kotlin/build.gradle
+++ /dev/null
@@ -1,30 +0,0 @@
-import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-
-plugins {
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.jvm)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-compileKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-compileTestKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-    implementation libs.androidx.annotation
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.kotlin.stdlib
-    testImplementation libs.kotlinx.coroutines.android
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation "androidx.test:core:$axtCoreVersion@aar"
-}
diff --git a/integration_tests/kotlin/build.gradle.kts b/integration_tests/kotlin/build.gradle.kts
new file mode 100644
index 000000000..339f8dd1f
--- /dev/null
+++ b/integration_tests/kotlin/build.gradle.kts
@@ -0,0 +1,28 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins {
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.jvm)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+val axtCoreVersion: String by rootProject.extra
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  implementation(libs.androidx.annotation)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.kotlin.stdlib)
+  testImplementation(libs.kotlinx.coroutines.android)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation("androidx.test:core:$axtCoreVersion@aar")
+}
diff --git a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
index 1a9641a04..5f4cb201d 100644
--- a/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
+++ b/integration_tests/kotlin/src/test/kotlin/org/robolectric/integrationtests/kotlin/CustomShadowImageViewTest.kt
@@ -18,7 +18,8 @@ class CustomShadowImageViewTest {
   fun `use custom ShadowImageView`() {
     val activity = Robolectric.setupActivity(Activity::class.java)
     val imageView = ImageView(activity)
-    (activity.findViewById(android.R.id.content) as ViewGroup).addView(imageView)
+    val viewGroup: ViewGroup = activity.findViewById(android.R.id.content)!!
+    viewGroup.addView(imageView)
     val shadowImageView = Shadow.extract<CustomShadowImageView>(imageView)
     assertThat(shadowImageView).isNotNull()
     assertThat(shadowImageView.realImageView).isSameInstanceAs(imageView)
diff --git a/integration_tests/libphonenumber/build.gradle b/integration_tests/libphonenumber/build.gradle
deleted file mode 100644
index 8e567a8d5..000000000
--- a/integration_tests/libphonenumber/build.gradle
+++ /dev/null
@@ -1,13 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    api libs.junit4
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.truth
-    testImplementation libs.libphonenumber
-}
diff --git a/integration_tests/libphonenumber/build.gradle.kts b/integration_tests/libphonenumber/build.gradle.kts
new file mode 100644
index 000000000..93dc9b1ce
--- /dev/null
+++ b/integration_tests/libphonenumber/build.gradle.kts
@@ -0,0 +1,11 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  api(libs.junit4)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.truth)
+  testImplementation(libs.libphonenumber)
+}
diff --git a/integration_tests/memoryleaks/build.gradle b/integration_tests/memoryleaks/build.gradle
deleted file mode 100644
index 643717f70..000000000
--- a/integration_tests/memoryleaks/build.gradle
+++ /dev/null
@@ -1,35 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.memoryleaks'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-}
-
-dependencies {
-    // Testing dependencies
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.guava.testlib
-    testImplementation libs.androidx.fragment
-    testImplementation libs.truth
-}
diff --git a/integration_tests/memoryleaks/build.gradle.kts b/integration_tests/memoryleaks/build.gradle.kts
new file mode 100644
index 000000000..f282286fa
--- /dev/null
+++ b/integration_tests/memoryleaks/build.gradle.kts
@@ -0,0 +1,31 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.memoryleaks"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  // Testing dependencies
+  testImplementation(project(":testapp"))
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.guava.testlib)
+  testImplementation(libs.androidx.fragment)
+  testImplementation(libs.truth)
+}
diff --git a/integration_tests/mockito-experimental/build.gradle b/integration_tests/mockito-experimental/build.gradle
deleted file mode 100644
index a185073ac..000000000
--- a/integration_tests/mockito-experimental/build.gradle
+++ /dev/null
@@ -1,14 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito.inline
-}
diff --git a/integration_tests/mockito-experimental/build.gradle.kts b/integration_tests/mockito-experimental/build.gradle.kts
new file mode 100644
index 000000000..76e7c4e41
--- /dev/null
+++ b/integration_tests/mockito-experimental/build.gradle.kts
@@ -0,0 +1,12 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito.inline)
+}
diff --git a/integration_tests/mockito-kotlin/build.gradle b/integration_tests/mockito-kotlin/build.gradle
deleted file mode 100644
index 52d8e586c..000000000
--- a/integration_tests/mockito-kotlin/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-
-plugins {
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.jvm)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-compileKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-compileTestKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation "androidx.test.ext:junit:$axtJunitVersion@aar"
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.kotlin.stdlib
-    testImplementation libs.mockito
-}
diff --git a/integration_tests/mockito-kotlin/build.gradle.kts b/integration_tests/mockito-kotlin/build.gradle.kts
new file mode 100644
index 000000000..ef5c4ec6e
--- /dev/null
+++ b/integration_tests/mockito-kotlin/build.gradle.kts
@@ -0,0 +1,27 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins {
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.jvm)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+val axtJunitVersion: String by rootProject.extra
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.kotlin.stdlib)
+  testImplementation(libs.mockito)
+}
diff --git a/integration_tests/mockito/build.gradle b/integration_tests/mockito/build.gradle
deleted file mode 100644
index 17b387d2e..000000000
--- a/integration_tests/mockito/build.gradle
+++ /dev/null
@@ -1,14 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-}
diff --git a/integration_tests/mockito/build.gradle.kts b/integration_tests/mockito/build.gradle.kts
new file mode 100644
index 000000000..c105728d9
--- /dev/null
+++ b/integration_tests/mockito/build.gradle.kts
@@ -0,0 +1,12 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+}
diff --git a/integration_tests/mockk/build.gradle b/integration_tests/mockk/build.gradle
deleted file mode 100644
index 770a390e0..000000000
--- a/integration_tests/mockk/build.gradle
+++ /dev/null
@@ -1,27 +0,0 @@
-import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-
-plugins {
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.jvm)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-compileKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-compileTestKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockk
-}
diff --git a/integration_tests/mockk/build.gradle.kts b/integration_tests/mockk/build.gradle.kts
new file mode 100644
index 000000000..f378aa030
--- /dev/null
+++ b/integration_tests/mockk/build.gradle.kts
@@ -0,0 +1,23 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins {
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.jvm)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockk)
+}
diff --git a/integration_tests/multidex/build.gradle.kts b/integration_tests/multidex/build.gradle.kts
new file mode 100644
index 000000000..9f5792bb2
--- /dev/null
+++ b/integration_tests/multidex/build.gradle.kts
@@ -0,0 +1,40 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "android.support.multidex"
+
+  defaultConfig {
+    minSdk = 21
+    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+  }
+
+  lint { abortOnError = false }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+}
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.androidx.test.runner)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.androidx.multidex)
+  testImplementation(libs.android.multidex)
+}
diff --git a/integration_tests/multidex/src/test/AndroidManifest.xml b/integration_tests/multidex/src/test/AndroidManifest.xml
index 9a55a085e..ced50f900 100644
--- a/integration_tests/multidex/src/test/AndroidManifest.xml
+++ b/integration_tests/multidex/src/test/AndroidManifest.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="org.robolectric.integrationtests.multidex">
+    xmlns:android="http://schemas.android.com/apk/res/android">
 
   <uses-sdk
       android:minSdkVersion="21"
@@ -11,6 +10,6 @@
 
   <instrumentation
       android:name="androidx.test.runner.AndroidJUnitRunner"
-      android:targetPackage="org.robolectric.integrationtests.multidex"/>
+      android:targetPackage="android.support.multidex" />
 
 </manifest>
diff --git a/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java
new file mode 100644
index 000000000..df355e36d
--- /dev/null
+++ b/integration_tests/multidex/src/test/java/android/support/multidex/MultiDexTest.java
@@ -0,0 +1,17 @@
+package android.support.multidex;
+
+import static android.support.multidex.MultiDex.install;
+import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Integration tests for android.support.multidex.MultiDex Robolectric. */
+@RunWith(AndroidJUnit4.class)
+public class MultiDexTest {
+  @Test
+  public void testIntendedFailEmpty() {
+    install(getApplicationContext());
+  }
+}
diff --git a/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java
new file mode 100644
index 000000000..5e3e982e6
--- /dev/null
+++ b/integration_tests/multidex/src/test/java/androidx/multidex/MultiDexTest.java
@@ -0,0 +1,17 @@
+package androidx.multidex;
+
+import static androidx.multidex.MultiDex.install;
+import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Integration tests for androidx.multidex.MultiDex Robolectric. */
+@RunWith(AndroidJUnit4.class)
+public class MultiDexTest {
+  @Test
+  public void testIntendedFailEmpty() {
+    install(getApplicationContext());
+  }
+}
diff --git a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java b/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java
deleted file mode 100644
index d0dcd2014..000000000
--- a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/MultiDexTest.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.robolectric.integrationtests.multidex;
-
-import android.support.multidex.MultiDex;
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Integration tests for MultiDex Robolectric. */
-@RunWith(AndroidJUnit4.class)
-public class MultiDexTest {
-
-  @Test
-  public void testIntendedFailEmpty() {
-    MultiDex.install(ApplicationProvider.getApplicationContext());
-  }
-}
diff --git a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/robolectric.properties b/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/robolectric.properties
deleted file mode 100644
index 5b66826f3..000000000
--- a/integration_tests/multidex/src/test/java/org/robolectric/integrationtests/multidex/robolectric.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-sdk=ALL_SDKS
-# make Robolectric match the emulator used
-qualifiers=w480dp-h800dp
diff --git a/integration_tests/nativegraphics/build.gradle b/integration_tests/nativegraphics/build.gradle
deleted file mode 100644
index 6822a8182..000000000
--- a/integration_tests/nativegraphics/build.gradle
+++ /dev/null
@@ -1,40 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.shadows'
-
-    defaultConfig {
-        minSdk 26
-        targetSdk 34
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-            all {
-                systemProperty 'robolectric.graphicsMode', 'NATIVE'
-            }
-        }
-    }
-
-    compileOptions {
-        sourceCompatibility 11
-        targetCompatibility 11
-    }
-}
-
-dependencies {
-    testImplementation AndroidSdk.MAX_SDK.coordinates
-    testImplementation project(':robolectric')
-
-    testImplementation libs.androidx.core
-    testImplementation libs.androidx.test.ext.junit
-    testImplementation libs.truth
-    testImplementation libs.junit4
-    testImplementation libs.mockito
-    testImplementation libs.guava.testlib
-}
diff --git a/integration_tests/nativegraphics/build.gradle.kts b/integration_tests/nativegraphics/build.gradle.kts
new file mode 100644
index 000000000..c49126a43
--- /dev/null
+++ b/integration_tests/nativegraphics/build.gradle.kts
@@ -0,0 +1,36 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.shadows"
+
+  defaultConfig { minSdk = 26 }
+
+  testOptions {
+    targetSdk = 34
+    unitTests {
+      isIncludeAndroidResources = true
+      all { it.systemProperty("robolectric.graphicsMode", "NATIVE") }
+    }
+  }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_11
+    targetCompatibility = JavaVersion.VERSION_11
+  }
+}
+
+dependencies {
+  testImplementation(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(project(":robolectric"))
+
+  testImplementation(libs.androidx.core)
+  testImplementation(libs.androidx.test.ext.junit)
+  testImplementation(libs.truth)
+  testImplementation(libs.junit4)
+  testImplementation(libs.mockito)
+  testImplementation(libs.guava.testlib)
+}
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
index 08c71dbfe..d1f47a6cf 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeAnimatedImageDrawableTest.java
@@ -1,19 +1,18 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.TruthJUnit.assume;
 
 import android.content.res.Resources;
 import android.graphics.drawable.AnimatedImageDrawable;
-import java.util.Locale;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.OsUtil;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = P)
@@ -24,7 +23,7 @@ public class ShadowNativeAnimatedImageDrawableTest {
   public void setup() {
     // The native code behind AnimatedImageDrawable makes use of Linux-specific APIs (epoll),
     // so it doesn't work on Mac at the moment.
-    assume().that(OS_NAME.value().toLowerCase(Locale.US)).doesNotContain("mac");
+    assume().that(OsUtil.isLinux()).isTrue();
     resources = RuntimeEnvironment.getApplication().getResources();
   }
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
index a1dfc566e..bf0170a91 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeBitmapTest.java
@@ -986,7 +986,7 @@ public class ShadowNativeBitmapTest {
         assertFalse(bitmap.isPremultiplied());
         break;
       case ALPHA_8:
-        // ALPHA_8 behaves mostly the same as 8888, except for premultiplied. Fall through.
+      // ALPHA_8 behaves mostly the same as 8888, except for premultiplied. Fall through.
       case ARGB_8888:
         // Since 565 is necessarily opaque, we revert to hasAlpha when switching to a type
         // that can have alpha.
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeCanvasTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeCanvasTest.java
index d4804b59a..e755ccf16 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeCanvasTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeCanvasTest.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.O_MR1;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.graphics.Bitmap;
@@ -13,6 +14,8 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = O)
@@ -25,6 +28,15 @@ public class ShadowNativeCanvasTest {
     assertThat(bm.getPixel(0, 0)).isEqualTo(Color.BLUE);
   }
 
+  @Config(minSdk = O, maxSdk = O_MR1)
+  @Test
+  public void setHighContrastText_preP() {
+    Bitmap bm = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
+    Canvas canvas = new Canvas(bm);
+    ReflectionHelpers.callInstanceMethod(
+        canvas, "setHighContrastText", ClassParameter.from(boolean.class, true));
+  }
+
   @Test
   public void testDrawPaint() {
     Bitmap bm = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
index 5ab1fc47e..9aac3a05f 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeColorSpaceTest.java
@@ -35,7 +35,9 @@ import java.util.function.DoubleUnaryOperator;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = O)
@@ -75,15 +77,20 @@ public class ShadowNativeColorSpaceTest {
   @Test
   public void testNamedColorSpaces() {
     for (ColorSpace.Named named : ColorSpace.Named.values()) {
-      // OK_LAB is behind a feature flag that is not yet enabled by default.
-      if (Objects.equals(named.toString(), "OK_LAB")) {
+      // OK_LAB is behind a feature flag that is not yet enabled by default on V.
+      if (Objects.equals(named.toString(), "OK_LAB")
+          && RuntimeEnvironment.getApiLevel() <= V.SDK_INT) {
+        continue;
+      }
+      // DISPLAY_BT2020 is behind a feature flag that is not yet enabled by default.
+      if (Objects.equals(named.toString(), "DISPLAY_BT2020")) {
         continue;
       }
 
       ColorSpace colorSpace = ColorSpace.get(named);
       assertNotNull(colorSpace.getName());
       assertNotNull(colorSpace);
-      assertEquals(named.ordinal(), colorSpace.getId());
+      assertEquals(named + " ordinal does not match", named.ordinal(), colorSpace.getId());
       assertTrue(colorSpace.getComponentCount() >= 1);
       assertTrue(colorSpace.getComponentCount() <= 4);
     }
@@ -341,14 +348,19 @@ public class ShadowNativeColorSpaceTest {
   @Test
   @Config(minSdk = Q)
   public void testIsSRGB() {
-    for (ColorSpace.Named e : ColorSpace.Named.values()) {
-      // OK_LAB is behind a feature flag that is not yet enabled by default.
-      if (Objects.equals(e.toString(), "OK_LAB")) {
+    for (ColorSpace.Named named : ColorSpace.Named.values()) {
+      // OK_LAB is behind a feature flag that is not yet enabled by default on V.
+      if (Objects.equals(named.toString(), "OK_LAB")
+          && RuntimeEnvironment.getApiLevel() <= V.SDK_INT) {
+        continue;
+      }
+      // DISPLAY_BT2020 is behind a feature flag that is not yet enabled by default.
+      if (Objects.equals(named.toString(), "DISPLAY_BT2020")) {
         continue;
       }
 
-      ColorSpace colorSpace = ColorSpace.get(e);
-      if (e == ColorSpace.Named.SRGB) {
+      ColorSpace colorSpace = ColorSpace.get(named);
+      if (named == ColorSpace.Named.SRGB) {
         assertTrue(colorSpace.isSrgb());
       } else {
         assertFalse("Incorrectly treating " + colorSpace + " as SRGB!", colorSpace.isSrgb());
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
index 37764e3df..94da9cc26 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeHardwareRendererTest.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -21,12 +20,14 @@ import android.view.Choreographer;
 import android.view.Surface;
 import java.nio.ByteOrder;
 import java.nio.IntBuffer;
-import java.util.Locale;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.OsUtil;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @Config(minSdk = Q)
 @RunWith(RobolectricTestRunner.class)
@@ -110,12 +111,12 @@ public class ShadowNativeHardwareRendererTest {
 
       // Check that the pixel at (0, 0) is white.
       assertThat(Integer.toHexString(dstImageData[0])).isEqualTo("ffffffff");
-      if (isMac()) {
-        // Check for red pixels in ABGR format on Mac.
+      if (OsUtil.isMac() && RuntimeEnvironment.getApiLevel() < V.SDK_INT) {
+        // Check for red pixels in ABGR format on Mac for U and below.
         assertThat(Integer.toHexString(dstImageData[1])).isEqualTo("ff0000ff");
         assertThat(Integer.toHexString(dstImageData[2])).isEqualTo("ff0000ff");
       } else {
-        // Check for red pixels in ARGB format on Linux/Windows.
+        // Check for red pixels in ARGB format on Linux/Windows, and for Mac for V and above.
         assertThat(Integer.toHexString(dstImageData[1])).isEqualTo("ffff0000");
         assertThat(Integer.toHexString(dstImageData[2])).isEqualTo("ffff0000");
       }
@@ -166,8 +167,4 @@ public class ShadowNativeHardwareRendererTest {
   interface HardwareRendererReflector {
     void setWideGamut(boolean wideGamut);
   }
-
-  private static boolean isMac() {
-    return OS_NAME.value().toLowerCase(Locale.ROOT).contains("mac");
-  }
 }
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
index 0eab7ad5a..19e391729 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeImageDecoderTest.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertSame;
 import static org.junit.Assert.assertEquals;
@@ -24,13 +23,13 @@ import java.nio.ByteBuffer;
 import java.nio.file.Files;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Locale;
 import java.util.function.IntFunction;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.OsUtil;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @Config(minSdk = P)
@@ -77,7 +76,7 @@ public class ShadowNativeImageDecoderTest {
                 new Record(R.drawable.webp_test, 640, 480, "image/webp", false, false, SRGB)));
 
     // x-adobe-dng is not supported on Windows
-    if (!OS_NAME.value().toLowerCase(Locale.ROOT).contains("win")) {
+    if (!OsUtil.isWindows()) {
       records.add(new Record(R.raw.sample_1mp, 600, 338, "image/x-adobe-dng", false, false, SRGB));
     }
 
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
index aea232219..12ec2b0ef 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativePathIteratorTest.java
@@ -41,7 +41,6 @@ import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.versioning.AndroidVersions.U;
-import org.robolectric.versioning.AndroidVersions.V;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = U.SDK_INT)
@@ -173,8 +172,7 @@ public class ShadowNativePathIteratorTest {
     assertEquals(PathIterator.VERB_DONE, segment.getVerb());
   }
 
-  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
-  @Config(minSdk = V.SDK_INT)
+  @Config(minSdk = U.SDK_INT)
   @Test
   public void testIterable() {
     mPath.lineTo(100f, 200f);
@@ -248,8 +246,7 @@ public class ShadowNativePathIteratorTest {
     assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
   }
 
-  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
-  @Config(minSdk = V.SDK_INT)
+  @Config(minSdk = U.SDK_INT)
   @Test
   public void testConic() {
     mPath.conicTo(100f, 200f, 300f, 400f, 2f);
@@ -335,8 +332,7 @@ public class ShadowNativePathIteratorTest {
     assertEquals(PathIterator.VERB_DONE, iterator.next().getVerb());
   }
 
-  // TODO(hoisie): Enable for U when Path.getGenerationId is supported in RNG
-  @Config(minSdk = V.SDK_INT)
+  @Config(minSdk = U.SDK_INT)
   @Test
   public void testPathModification() {
     mPath.lineTo(100f, 200f);
@@ -395,8 +391,7 @@ public class ShadowNativePathIteratorTest {
     }
   }
 
-  // TODO(hoisie): Enable for U when Path.conicTo is supported in RNG
-  @Config(minSdk = V.SDK_INT)
+  @Config(minSdk = U.SDK_INT)
   @Test
   public void testRecreation() {
     mPath.moveTo(10f, 10f);
diff --git a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
index 2091749d7..807ef97d7 100644
--- a/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
+++ b/integration_tests/nativegraphics/src/test/java/org/robolectric/shadows/ShadowNativeRuntimeShaderTest.java
@@ -3,16 +3,15 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static com.google.common.truth.TruthJUnit.assume;
 
 import android.graphics.RuntimeShader;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import java.util.Locale;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.OsUtil;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.U;
@@ -56,7 +55,7 @@ public class ShadowNativeRuntimeShaderTest {
   @Before
   public void setup() {
     // The native code behind RuntimeShader is currently not supported on Mac.
-    assume().that(OS_NAME.value().toLowerCase(Locale.US)).doesNotContain("mac");
+    assume().that(OsUtil.isMac()).isFalse();
   }
 
   @Config(minSdk = S, maxSdk = S_V2)
diff --git a/integration_tests/play_services/build.gradle b/integration_tests/play_services/build.gradle
deleted file mode 100644
index 2c2111bf8..000000000
--- a/integration_tests/play_services/build.gradle
+++ /dev/null
@@ -1,15 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    api project(":shadows:playservices")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.play.services.basement
-}
diff --git a/integration_tests/play_services/build.gradle.kts b/integration_tests/play_services/build.gradle.kts
new file mode 100644
index 000000000..2a6391d2a
--- /dev/null
+++ b/integration_tests/play_services/build.gradle.kts
@@ -0,0 +1,13 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  api(project(":shadows:playservices"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.play.services.basement)
+}
diff --git a/integration_tests/powermock/build.gradle b/integration_tests/powermock/build.gradle
deleted file mode 100644
index 1c5d3fae4..000000000
--- a/integration_tests/powermock/build.gradle
+++ /dev/null
@@ -1,14 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.junit4
-    testImplementation libs.truth
-
-    testImplementation libs.bundles.powermock
-}
diff --git a/integration_tests/powermock/build.gradle.kts b/integration_tests/powermock/build.gradle.kts
new file mode 100644
index 000000000..0be556faa
--- /dev/null
+++ b/integration_tests/powermock/build.gradle.kts
@@ -0,0 +1,11 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.bundles.powermock)
+}
diff --git a/integration_tests/roborazzi/build.gradle b/integration_tests/roborazzi/build.gradle
deleted file mode 100644
index 54c0dc029..000000000
--- a/integration_tests/roborazzi/build.gradle
+++ /dev/null
@@ -1,58 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.android)
-    alias(libs.plugins.robolectric.android.project)
-    alias(libs.plugins.robolectric.spotless)
-    alias(libs.plugins.roborazzi)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integration.roborazzi'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    kotlinOptions {
-        jvmTarget = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-            all {
-                // For Roborazzi users, please use Roborazzi plugin and gradle.properties instead of this.
-                // https://takahirom.github.io/roborazzi/how-to-use.html#roborazzi-gradle-properties-options
-
-                // Change naming strategy of screenshots.
-                // org.robolectric.....RoborazziCaptureTest.checkDialogRendering.png -> RoborazziCaptureTest.checkDialogRendering.png
-                systemProperty 'roborazzi.record.namingStrategy', 'testClassAndMethod'
-
-                // Use RoborazziRule's base path when you use captureRoboImage(path).
-                systemProperty 'roborazzi.record.filePathStrategy', 'relativePathFromRoborazziContextOutputDirectory'
-            }
-        }
-    }
-    androidComponents {
-        beforeVariants(selector().all()) { variantBuilder ->
-            // Roborazzi does not support AndroidTest.
-            variantBuilder.enableAndroidTest = false
-        }
-    }
-}
-dependencies {
-    api project(":robolectric")
-    testImplementation libs.androidx.test.core
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.roborazzi
-    testImplementation libs.roborazzi.rule
-}
diff --git a/integration_tests/roborazzi/build.gradle.kts b/integration_tests/roborazzi/build.gradle.kts
new file mode 100644
index 000000000..b49fcad85
--- /dev/null
+++ b/integration_tests/roborazzi/build.gradle.kts
@@ -0,0 +1,60 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.android)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.spotless)
+  alias(libs.plugins.roborazzi)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integration.roborazzi"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  kotlinOptions { jvmTarget = "1.8" }
+
+  testOptions {
+    targetSdk = 34
+    unitTests {
+      isIncludeAndroidResources = true
+      all {
+        // For Roborazzi users, please use Roborazzi plugin and gradle.properties instead of this.
+        // https://takahirom.github.io/roborazzi/how-to-use.html#roborazzi-gradle-properties-options
+
+        // Change naming strategy of screenshots.
+        // org.robolectric.....RoborazziCaptureTest.checkDialogRendering.png ->
+        // RoborazziCaptureTest.checkDialogRendering.png
+        it.systemProperty("roborazzi.record.namingStrategy", "testClassAndMethod")
+
+        // Use RoborazziRule's base path when you use captureRoboImage(path).
+        it.systemProperty(
+          "roborazzi.record.filePathStrategy",
+          "relativePathFromRoborazziContextOutputDirectory",
+        )
+      }
+    }
+  }
+
+  androidComponents {
+    beforeVariants(selector().all()) { variantBuilder ->
+      // Roborazzi does not support AndroidTest.
+      variantBuilder.enableAndroidTest = false
+    }
+  }
+}
+
+dependencies {
+  api(project(":robolectric"))
+  testImplementation(libs.androidx.test.core)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.roborazzi)
+  testImplementation(libs.roborazzi.rule)
+}
diff --git a/integration_tests/room/build.gradle b/integration_tests/room/build.gradle
deleted file mode 100644
index 418c20e9f..000000000
--- a/integration_tests/room/build.gradle
+++ /dev/null
@@ -1,36 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.robolectric.android.project)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.integrationtests.room'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-}
-
-dependencies {
-    // Testing dependencies
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.guava.testlib
-    testImplementation libs.truth
-    implementation libs.androidx.room.runtime
-    annotationProcessor libs.androidx.room.compiler
-}
diff --git a/integration_tests/room/build.gradle.kts b/integration_tests/room/build.gradle.kts
new file mode 100644
index 000000000..21b977dbd
--- /dev/null
+++ b/integration_tests/room/build.gradle.kts
@@ -0,0 +1,32 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.room"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  // Testing dependencies
+  testImplementation(project(":testapp"))
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.guava.testlib)
+  testImplementation(libs.truth)
+  implementation(libs.androidx.room.runtime)
+  annotationProcessor(libs.androidx.room.compiler)
+}
diff --git a/integration_tests/sdkcompat/build.gradle b/integration_tests/sdkcompat/build.gradle
deleted file mode 100644
index 09700a5db..000000000
--- a/integration_tests/sdkcompat/build.gradle
+++ /dev/null
@@ -1,39 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.android)
-    alias(libs.plugins.robolectric.android.project)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-
-android {
-    compileSdk 29
-    namespace 'org.robolectric.integrationtests.sdkcompat'
-
-    defaultConfig {
-        minSdk 21
-        // We must keep targetSdk to 29 for compatibility testing purpose
-        targetSdk 29
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    kotlinOptions {
-        jvmTarget = '1.8'
-    }
-
-    testOptions.unitTests.includeAndroidResources true
-}
-
-dependencies {
-    implementation libs.kotlin.stdlib
-
-    testImplementation project(":testapp")
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-}
diff --git a/integration_tests/sdkcompat/build.gradle.kts b/integration_tests/sdkcompat/build.gradle.kts
new file mode 100644
index 000000000..142c089d7
--- /dev/null
+++ b/integration_tests/sdkcompat/build.gradle.kts
@@ -0,0 +1,37 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.android)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+android {
+  //noinspection GradleDependency keep compileSdk to 29 for compatibility testing purpose
+  compileSdk = 29
+  namespace = "org.robolectric.integrationtests.sdkcompat"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  kotlinOptions { jvmTarget = "1.8" }
+
+  testOptions {
+    // We must keep targetSdk to 29 for compatibility testing purpose
+    targetSdk = 29
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  implementation(libs.kotlin.stdlib)
+
+  testImplementation(project(":testapp"))
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
diff --git a/integration_tests/security-providers/build.gradle b/integration_tests/security-providers/build.gradle
deleted file mode 100644
index 7a3b0a231..000000000
--- a/integration_tests/security-providers/build.gradle
+++ /dev/null
@@ -1,15 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":robolectric")
-    api libs.junit4
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation libs.truth
-    testImplementation libs.conscrypt.openjdk.uber
-    testImplementation libs.okhttp
-    testImplementation platform(libs.okhttp.bom)
-}
diff --git a/integration_tests/security-providers/build.gradle.kts b/integration_tests/security-providers/build.gradle.kts
new file mode 100644
index 000000000..e0001bf4a
--- /dev/null
+++ b/integration_tests/security-providers/build.gradle.kts
@@ -0,0 +1,13 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+dependencies {
+  api(project(":robolectric"))
+  api(libs.junit4)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(libs.truth)
+  testImplementation(libs.conscrypt.openjdk.uber)
+  testImplementation(libs.okhttp)
+  testImplementation(platform(libs.okhttp.bom))
+}
diff --git a/integration_tests/sparsearray/build.gradle b/integration_tests/sparsearray/build.gradle
deleted file mode 100644
index fd6f19705..000000000
--- a/integration_tests/sparsearray/build.gradle
+++ /dev/null
@@ -1,44 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.android)
-    alias(libs.plugins.robolectric.android.project)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.sparsearray'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-    }
-
-    compileOptions {
-        sourceCompatibility = '1.8'
-        targetCompatibility = '1.8'
-    }
-
-    kotlinOptions {
-        jvmTarget = '1.8'
-    }
-
-    testOptions {
-        unitTests {
-            includeAndroidResources = true
-        }
-    }
-}
-
-dependencies {
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-    implementation project(path: ':shadowapi', configuration: 'default')
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.kotlin.stdlib
-}
diff --git a/integration_tests/sparsearray/build.gradle.kts b/integration_tests/sparsearray/build.gradle.kts
new file mode 100644
index 000000000..18479c8b9
--- /dev/null
+++ b/integration_tests/sparsearray/build.gradle.kts
@@ -0,0 +1,38 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.android)
+  alias(libs.plugins.robolectric.android.project)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.sparsearray"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  kotlinOptions { jvmTarget = "1.8" }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  implementation(project(path = ":shadowapi", configuration = "default"))
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.kotlin.stdlib)
+}
diff --git a/integration_tests/testparameterinjector/build.gradle.kts b/integration_tests/testparameterinjector/build.gradle.kts
new file mode 100644
index 000000000..d3a8371ed
--- /dev/null
+++ b/integration_tests/testparameterinjector/build.gradle.kts
@@ -0,0 +1,29 @@
+plugins {
+  alias(libs.plugins.android.library)
+  alias(libs.plugins.robolectric.android.project)
+}
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.integrationtests.testparameterinjector"
+
+  defaultConfig { minSdk = 21 }
+
+  compileOptions {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+  }
+
+  testOptions {
+    targetSdk = 34
+    unitTests.isIncludeAndroidResources = true
+  }
+}
+
+dependencies {
+  // Testing dependencies
+  testImplementation(project(":robolectric"))
+  testImplementation("com.google.testparameterinjector:test-parameter-injector:1.18@jar")
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
diff --git a/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java b/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java
new file mode 100644
index 000000000..aef0a6b64
--- /dev/null
+++ b/integration_tests/testparameterinjector/src/test/java/org/robolectric/integrationtests/testparameterinjector/RobolectricTestParameterInjectorTest.java
@@ -0,0 +1,235 @@
+package org.robolectric.integrationtests.testparameterinjector;
+
+import static android.os.Build.VERSION_CODES.S;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Build.VERSION;
+import com.google.testing.junit.testparameterinjector.TestParameter;
+import java.util.ArrayList;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.Description;
+import org.junit.runner.RunWith;
+import org.junit.runner.Runner;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.JUnit4;
+import org.robolectric.RobolectricTestParameterInjector;
+import org.robolectric.annotation.Config;
+
+@SuppressWarnings({"TestMethodWithIncorrectSignature", "UnconstructableJUnitTestCase"})
+@RunWith(JUnit4.class)
+public class RobolectricTestParameterInjectorTest {
+  private final RunNotifier runNotifier = new RunNotifier();
+
+  @Before
+  public void setup() {
+    runNotifier.addListener(
+        new RunListener() {
+          @Override
+          public void testFailure(Failure failure) throws Exception {
+            throw new AssertionError("Unexpected test failure: " + failure, failure.getException());
+          }
+        });
+  }
+
+  @Ignore
+  public static class NoInjection {
+    @Config(sdk = S)
+    @Test
+    public void test() {
+      assertThat(VERSION.SDK_INT).isEqualTo(S);
+    }
+  }
+
+  @Test
+  public void noInjection() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(NoInjection.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(1);
+  }
+
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class InjectedMethod {
+    @Test
+    public void test(@TestParameter boolean param) {
+      assertThat(param).isAnyOf(true, false);
+    }
+  }
+
+  @Test
+  public void injectedMethod() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(InjectedMethod.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(2);
+    ArrayList<Description> descriptions = runner.getDescription().getChildren();
+    // In gradle it's test[false], in bazel it's test[param=false].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false\\]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true\\]");
+  }
+
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class InjectedField {
+    @TestParameter({"hello", "world"})
+    String param;
+
+    @Test
+    public void test() {
+      assertThat(param).isAnyOf("hello", "world");
+    }
+  }
+
+  @Test
+  public void injectedField() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(InjectedField.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(2);
+
+    assertThat(runner.testCount()).isEqualTo(2);
+    ArrayList<Description> descriptions = runner.getDescription().getChildren();
+    assertThat(descriptions.get(0).getMethodName()).isEqualTo("test[hello]");
+    assertThat(descriptions.get(1).getMethodName()).isEqualTo("test[world]");
+  }
+
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class InjectedConstructor {
+    private final int param;
+
+    public InjectedConstructor(@TestParameter({"1", "2"}) int param) {
+      this.param = param;
+    }
+
+    @Test
+    public void test() {
+      assertThat(param).isAnyOf(1, 2);
+    }
+  }
+
+  @Test
+  public void injectedConstructor() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(InjectedConstructor.class);
+
+    runner.run(runNotifier);
+    assertThat(runner.testCount()).isEqualTo(2);
+    ArrayList<Description> descriptions = runner.getDescription().getChildren();
+    // In gradle it's test[1], in bazel it's test[param=1].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?1\\]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?2\\]");
+  }
+
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class InjectedEnum {
+    enum Value {
+      ONE,
+      TWO
+    }
+
+    @Test
+    public void test(@TestParameter Value param) {
+      assertThat(param).isAnyOf(Value.ONE, Value.TWO);
+    }
+  }
+
+  @Test
+  public void injectedEnum() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(InjectedEnum.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(2);
+
+    ArrayList<Description> descriptions = runner.getDescription().getChildren();
+    assertThat(descriptions.get(0).getMethodName()).isEqualTo("test[ONE]");
+    assertThat(descriptions.get(1).getMethodName()).isEqualTo("test[TWO]");
+  }
+
+  @Ignore
+  public static class MultiSdk {
+    @Test
+    @Config(sdk = {28, 31})
+    public void test(@TestParameter boolean param) {
+      assertThat(param).isAnyOf(true, false);
+      assertThat(VERSION.SDK_INT).isAnyOf(28, 31);
+    }
+  }
+
+  @Test
+  public void multiSdk() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(MultiSdk.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(4);
+
+    ArrayList<Description> descriptions = runner.getDescription().getChildren();
+    // In gradle it's test[false][28], in bazel it's test[param=false][28].
+    assertThat(descriptions.get(0).getMethodName()).matches("test\\[(param=)?false\\]\\[28\\]");
+    assertThat(descriptions.get(1).getMethodName()).matches("test\\[(param=)?true\\]\\[28\\]");
+    assertThat(descriptions.get(2).getMethodName()).matches("test\\[(param=)?false\\]");
+    assertThat(descriptions.get(3).getMethodName()).matches("test\\[(param=)?true\\]");
+  }
+
+  // Simulate behavior of proto lite enum toString which includes the object hashcode (proto lite
+  // toString tries to avoid dep on enum name so that the name can be stripped by appreduce).
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class HashCodeToString {
+    enum HashCodeToStringValue {
+      ONE,
+      TWO;
+
+      @Override
+      public String toString() {
+        return "" + super.hashCode();
+      }
+    }
+
+    @Test
+    public void test(@TestParameter HashCodeToStringValue param) {
+      assertThat(param).isAnyOf(HashCodeToStringValue.ONE, HashCodeToStringValue.TWO);
+    }
+  }
+
+  @Test
+  public void hashCodeToString() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(HashCodeToString.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(2);
+  }
+
+  @Ignore
+  public static class Base {
+    @Test
+    public void test() {}
+  }
+
+  @Ignore
+  @Config(sdk = Config.NEWEST_SDK)
+  public static class Child extends Base {
+    @Override
+    public void test() {}
+  }
+
+  @Test
+  public void overridden() throws Exception {
+    Runner runner = new RobolectricTestParameterInjector(Child.class);
+
+    runner.run(runNotifier);
+
+    assertThat(runner.testCount()).isEqualTo(1);
+  }
+}
diff --git a/integration_tests/versioning/build.gradle b/integration_tests/versioning/build.gradle
deleted file mode 100644
index b33bdcbd4..000000000
--- a/integration_tests/versioning/build.gradle
+++ /dev/null
@@ -1,20 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-configurations {
-    earlyRuntime
-}
-
-dependencies {
-    // compile against latest Android SDK (AndroidSdk.s.coordinates) { force = true }
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation project(":robolectric")
-    testImplementation libs.truth
-    testImplementation "androidx.test.ext:junit:$axtJunitVersion@aar"
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates // compile against latest Android SDK
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates // run against whatever this JDK supports
-}
-
-
diff --git a/integration_tests/versioning/build.gradle.kts b/integration_tests/versioning/build.gradle.kts
new file mode 100644
index 000000000..160d4dd95
--- /dev/null
+++ b/integration_tests/versioning/build.gradle.kts
@@ -0,0 +1,14 @@
+plugins { alias(libs.plugins.robolectric.java.module) }
+
+val earlyRuntime by configurations.registering
+val axtJunitVersion: String by rootProject.extra
+
+dependencies {
+  // compile against latest Android SDK (AndroidSdk.s.coordinates) { force = true }
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.truth)
+  testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates) // run against whatever this JDK supports
+}
diff --git a/junit/build.gradle b/junit/build.gradle
deleted file mode 100644
index c378838c1..000000000
--- a/junit/build.gradle
+++ /dev/null
@@ -1,15 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":annotations")
-    api project(":sandbox")
-    api project(":pluginapi")
-    api project(":shadowapi")
-    api project(":utils:reflector")
-
-    compileOnly libs.findbugs.jsr305
-    compileOnly libs.junit4
-}
diff --git a/junit/build.gradle.kts b/junit/build.gradle.kts
new file mode 100644
index 000000000..ba9e960e8
--- /dev/null
+++ b/junit/build.gradle.kts
@@ -0,0 +1,15 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  api(project(":annotations"))
+  api(project(":sandbox"))
+  api(project(":pluginapi"))
+  api(project(":shadowapi"))
+  api(project(":utils:reflector"))
+
+  compileOnly(libs.findbugs.jsr305)
+  compileOnly(libs.junit4)
+}
diff --git a/nativeruntime/build.gradle b/nativeruntime/build.gradle
deleted file mode 100644
index 13eea5f8b..000000000
--- a/nativeruntime/build.gradle
+++ /dev/null
@@ -1,77 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-if (System.getenv('PUBLISH_NATIVERUNTIME_DIST_COMPAT') == "true") {
-    apply plugin: 'maven-publish'
-    apply plugin: "signing"
-
-    publishing {
-        publications {
-            nativeRuntimeDist(MavenPublication) {
-                artifact System.env["NATIVERUNTIME_DIST_COMPAT_JAR"]
-                artifactId 'nativeruntime-dist-compat'
-                version System.env["NATIVERUNTIME_DIST_COMPAT_VERSION"]
-
-                pom {
-                    name = "Robolectric Nativeruntime Distribution Compat"
-                    description = "Robolectric Nativeruntime Distribution Compat"
-                    url = "https://source.android.com/"
-                    inceptionYear = "2008"
-                    licenses {
-                        license {
-                            name = "Apache 2.0"
-                            url = "http://www.apache.org/licenses/LICENSE-2.0"
-                            comments = "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
-                            distribution = "repo"
-                        }
-                    }
-
-                    scm {
-                        url = "https://android.googlesource.com/platform/manifest.git"
-                        connection = "https://android.googlesource.com/platform/manifest.git"
-                    }
-
-                    developers {
-                        developer {
-                            name = "The Android Open Source Projects"
-                        }
-                    }
-                }
-            }
-        }
-        repositories {
-            maven {
-                url = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-
-                credentials {
-                    username = System.properties["sonatype-login"] ?: System.env['SONATYPE_LOGIN']
-                    password = System.properties["sonatype-password"] ?: System.env['SONATYPE_PASSWORD']
-                }
-            }
-        }
-    }
-
-    signing {
-        sign publishing.publications.nativeRuntimeDist
-    }
-}
-
-dependencies {
-    api project(":utils")
-    api project(":utils:reflector")
-    api libs.guava
-
-    implementation libs.robolectric.nativeruntime.dist.compat
-
-    annotationProcessor libs.auto.service
-    compileOnly libs.auto.service.annotations
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-}
diff --git a/nativeruntime/build.gradle.kts b/nativeruntime/build.gradle.kts
new file mode 100644
index 000000000..249d5ebd3
--- /dev/null
+++ b/nativeruntime/build.gradle.kts
@@ -0,0 +1,80 @@
+import java.net.URI
+
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+if (System.getenv("PUBLISH_NATIVERUNTIME_DIST_COMPAT") == "true") {
+  pluginManager.apply("maven-publish")
+  pluginManager.apply("signing")
+
+  publishing {
+    publications {
+      register<MavenPublication>("nativeRuntimeDist") {
+        val nativeRuntimeDistCompatJar = System.getenv("NATIVERUNTIME_DIST_COMPAT_JAR")
+        val nativeRuntimeDistCompatVersion = System.getenv("NATIVERUNTIME_DIST_COMPAT_VERSION")
+
+        artifact(nativeRuntimeDistCompatJar)
+        artifactId = "nativeruntime-dist-compat"
+        version = nativeRuntimeDistCompatVersion
+
+        pom {
+          name = "Robolectric Nativeruntime Distribution Compat"
+          description = "Robolectric Nativeruntime Distribution Compat"
+          url = "https://source.android.com/"
+          inceptionYear = "2008"
+
+          licenses {
+            license {
+              name = "Apache 2.0"
+              url = "http://www.apache.org/licenses/LICENSE-2.0"
+              comments =
+                "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
+              distribution = "repo"
+            }
+          }
+
+          scm {
+            url = "https://android.googlesource.com/platform/manifest.git"
+            connection = "https://android.googlesource.com/platform/manifest.git"
+          }
+
+          developers { developer { name = "The Android Open Source Projects" } }
+        }
+      }
+    }
+
+    repositories {
+      maven {
+        url = URI("https://oss.sonatype.org/service/local/staging/deploy/maven2/")
+
+        credentials {
+          username = System.getProperty("sonatype-login") ?: System.getenv("SONATYPE_LOGIN")
+          password = System.getProperty("sonatype-password") ?: System.getenv("SONATYPE_PASSWORD")
+        }
+      }
+    }
+
+    signing { sign(publications.getByName("nativeRuntimeDist")) }
+  }
+}
+
+dependencies {
+  api(project(":shadowapi"))
+  api(project(":utils"))
+  api(project(":utils:reflector"))
+  api(libs.guava)
+
+  implementation(libs.robolectric.nativeruntime.dist.compat)
+
+  annotationProcessor(libs.auto.service)
+  compileOnly(libs.auto.service.annotations)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
index 78c9b20a8..ab79e8803 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/DefaultNativeRuntimeLoader.java
@@ -5,9 +5,11 @@ import static com.google.common.base.StandardSystemProperty.OS_ARCH;
 import static com.google.common.base.StandardSystemProperty.OS_NAME;
 
 import android.database.CursorWindow;
+import android.graphics.Typeface;
 import android.os.Build;
 import com.google.auto.service.AutoService;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.io.Files;
 import com.google.common.io.Resources;
@@ -22,12 +24,16 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Iterator;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Stream;
 import javax.annotation.Priority;
 import org.robolectric.pluginapi.NativeRuntimeLoader;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.OsUtil;
 import org.robolectric.util.PerfStatsCollector;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.TempDirectory;
 import org.robolectric.util.inject.Injector;
 
@@ -40,6 +46,91 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   private static final AtomicReference<NativeRuntimeLoader> nativeRuntimeLoader =
       new AtomicReference<>();
 
+  protected static final String METHOD_BINDING_FORMAT = "$$robo$$${method}$nativeBinding";
+
+  // Core classes for which native methods are to be registered for Android V and above.
+  protected static final ImmutableList<String> CORE_CLASS_NATIVES =
+      ImmutableList.copyOf(
+          new String[] {
+            "android.animation.PropertyValuesHolder",
+            "android.database.CursorWindow",
+            "android.database.sqlite.SQLiteConnection",
+            "android.database.sqlite.SQLiteRawStatement",
+            "android.media.ImageReader",
+            "android.view.Surface",
+            "com.android.internal.util.VirtualRefBasePtr",
+            "libcore.util.NativeAllocationRegistry",
+          });
+
+  // Graphics classes for which native methods are to be registered.
+  protected static final ImmutableList<String> GRAPHICS_CLASS_NATIVES =
+      ImmutableList.copyOf(
+          new String[] {
+            "android.graphics.Bitmap",
+            "android.graphics.BitmapFactory",
+            "android.graphics.ByteBufferStreamAdaptor",
+            "android.graphics.Camera",
+            "android.graphics.Canvas",
+            "android.graphics.CanvasProperty",
+            "android.graphics.Color",
+            "android.graphics.ColorFilter",
+            "android.graphics.ColorSpace",
+            "android.graphics.CreateJavaOutputStreamAdaptor",
+            "android.graphics.DrawFilter",
+            "android.graphics.FontFamily",
+            "android.graphics.Gainmap",
+            "android.graphics.Graphics",
+            "android.graphics.HardwareRenderer",
+            "android.graphics.HardwareRendererObserver",
+            "android.graphics.ImageDecoder",
+            "android.graphics.Interpolator",
+            "android.graphics.MaskFilter",
+            "android.graphics.Matrix",
+            "android.graphics.NinePatch",
+            "android.graphics.Paint",
+            "android.graphics.Path",
+            "android.graphics.PathEffect",
+            "android.graphics.PathIterator",
+            "android.graphics.PathMeasure",
+            "android.graphics.Picture",
+            "android.graphics.RecordingCanvas",
+            "android.graphics.Region",
+            "android.graphics.RenderEffect",
+            "android.graphics.RenderNode",
+            "android.graphics.Shader",
+            "android.graphics.Typeface",
+            "android.graphics.YuvImage",
+            "android.graphics.animation.NativeInterpolatorFactory",
+            "android.graphics.animation.RenderNodeAnimator",
+            "android.graphics.drawable.AnimatedVectorDrawable",
+            "android.graphics.drawable.AnimatedImageDrawable",
+            "android.graphics.drawable.VectorDrawable",
+            "android.graphics.fonts.Font",
+            "android.graphics.fonts.FontFamily",
+            "android.graphics.text.LineBreaker",
+            "android.graphics.text.MeasuredText",
+            "android.graphics.text.TextRunShaper",
+            "android.util.PathParser",
+          });
+
+  /**
+   * {@link #DEFERRED_STATIC_INITIALIZERS} that invoke their own native methods in static
+   * initializers. Unlike libcore, registering JNI on the JVM causes static initialization to be
+   * performed on the class. Because of this, static initializers cannot invoke the native methods
+   * of the class under registration. Executing these static initializers must be deferred until
+   * after JNI has been registered.
+   */
+  protected static final ImmutableList<String> DEFERRED_STATIC_INITIALIZERS =
+      ImmutableList.copyOf(
+          new String[] {
+            "android.graphics.FontFamily",
+            "android.graphics.Path",
+            "android.graphics.PathIterator",
+            "android.graphics.Typeface",
+            "android.graphics.text.MeasuredText$Builder",
+            "android.media.ImageReader",
+          });
+
   private TempDirectory extractDirectory;
 
   public static void injectAndLoad() {
@@ -75,12 +166,22 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
               "loadNativeRuntime",
               () -> {
                 extractDirectory = new TempDirectory("nativeruntime");
-                System.setProperty("icu.locale.default", Locale.getDefault().toLanguageTag());
                 if (Build.VERSION.SDK_INT >= O) {
+                  // Only copy fonts if graphics is supported, not just SQLite.
                   maybeCopyFonts(extractDirectory);
                 }
                 maybeCopyIcuData(extractDirectory);
+                if (isAndroidVOrGreater()) {
+                  System.setProperty("core_native_classes", String.join(",", CORE_CLASS_NATIVES));
+                  System.setProperty(
+                      "graphics_native_classes", String.join(",", GRAPHICS_CLASS_NATIVES));
+                  System.setProperty("method_binding_format", METHOD_BINDING_FORMAT);
+                }
                 loadLibrary(extractDirectory);
+                if (isAndroidVOrGreater()) {
+                  invokeDeferredStaticInitializers();
+                  Typeface.loadPreinstalledSystemFontMap();
+                }
               });
     } catch (IOException e) {
       throw new AssertionError("Unable to load Robolectric native runtime library", e);
@@ -91,14 +192,16 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   private void maybeCopyIcuData(TempDirectory tempDirectory) throws IOException {
     URL icuDatUrl;
     try {
-      icuDatUrl = Resources.getResource("icu/icudt68l.dat");
+      icuDatUrl =
+          Resources.getResource(isAndroidVOrGreater() ? "icu/icudt75l.dat" : "icu/icudt68l.dat");
     } catch (IllegalArgumentException e) {
       return;
     }
     Path icuPath = tempDirectory.create("icu");
-    Path icuDatPath = icuPath.resolve("icudt68l.dat");
+    Path icuDatPath = icuPath.resolve(isAndroidVOrGreater() ? "icudt75l.dat" : "icudt68l.dat");
     Resources.asByteSource(icuDatUrl).copyTo(Files.asByteSink(icuDatPath.toFile()));
     System.setProperty("icu.data.path", icuDatPath.toAbsolutePath().toString());
+    System.setProperty("icu.locale.default", Locale.getDefault().toLanguageTag());
   }
 
   /**
@@ -146,33 +249,39 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   }
 
   private void loadLibrary(TempDirectory tempDirectory) throws IOException {
-    String libraryName = System.mapLibraryName("robolectric-nativeruntime");
-    Path libraryPath = tempDirectory.getBasePath().resolve(libraryName);
+    Path libraryPath = tempDirectory.getBasePath().resolve(libraryName());
     URL libraryResource = Resources.getResource(nativeLibraryPath());
     Resources.asByteSource(libraryResource).copyTo(Files.asByteSink(libraryPath.toFile()));
     System.load(libraryPath.toAbsolutePath().toString());
   }
 
   private static boolean isSupported() {
-    return ("mac".equals(osName()) && ("aarch64".equals(arch()) || "x86_64".equals(arch())))
-        || ("linux".equals(osName()) && "x86_64".equals(arch()))
-        || ("windows".equals(osName()) && "x86_64".equals(arch()));
+    return (OsUtil.isMac()
+            && (Objects.equals(arch(), "aarch64") || Objects.equals(arch(), "x86_64")))
+        || (OsUtil.isLinux() && Objects.equals(arch(), "x86_64"))
+        || (OsUtil.isWindows() && Objects.equals(arch(), "x86_64"));
   }
 
   private static String nativeLibraryPath() {
-    String os = osName();
-    String arch = arch();
-    return String.format(
-        "native/%s/%s/%s", os, arch, System.mapLibraryName("robolectric-nativeruntime"));
+    return String.format("native/%s/%s/%s", osName(), arch(), libraryName());
+  }
+
+  protected static String libraryName() {
+    if (isAndroidVOrGreater()) {
+      // For V and above, hwui's android_graphics_HardwareRenderer.cpp has shared library symbol
+      // lookup logic that assumes that Windows library name is "libandroid_runtime.dll".
+      return System.mapLibraryName(OsUtil.isWindows() ? "libandroid_runtime" : "android_runtime");
+    } else {
+      return System.mapLibraryName("robolectric-nativeruntime");
+    }
   }
 
   private static String osName() {
-    String osName = OS_NAME.value().toLowerCase(Locale.US);
-    if (osName.contains("linux")) {
+    if (OsUtil.isLinux()) {
       return "linux";
-    } else if (osName.contains("mac")) {
+    } else if (OsUtil.isMac()) {
       return "mac";
-    } else if (osName.contains("win")) {
+    } else if (OsUtil.isWindows()) {
       return "windows";
     }
     return "unknown";
@@ -200,4 +309,15 @@ public class DefaultNativeRuntimeLoader implements NativeRuntimeLoader {
   static void resetLoaded() {
     loaded.set(false);
   }
+
+  protected void invokeDeferredStaticInitializers() {
+    for (String className : DEFERRED_STATIC_INITIALIZERS) {
+      ReflectionHelpers.callStaticMethod(
+          Shadow.class.getClassLoader(), className, "__staticInitializer__");
+    }
+  }
+
+  private static boolean isAndroidVOrGreater() {
+    return Build.VERSION.SDK_INT >= /* VANILLA_ICE_CREAM */ 35;
+  }
 }
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java
index b8c21f0d5..d5f075839 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathIteratorNatives.java
@@ -14,6 +14,8 @@ public final class PathIteratorNatives {
 
   public static native int nNext(long nativeIterator, long pointsAddress);
 
+  public static native int nNextHost(long nativeIterator, float[] pointsArray);
+
   public static native int nPeek(long nativeIterator);
 
   private PathIteratorNatives() {}
diff --git a/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathNatives.java b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathNatives.java
index 0870f6bf7..bf8b245bd 100644
--- a/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathNatives.java
+++ b/nativeruntime/src/main/java/org/robolectric/nativeruntime/PathNatives.java
@@ -34,6 +34,12 @@ public final class PathNatives {
 
   public static native void nRQuadTo(long nPath, float dx1, float dy1, float dx2, float dy2);
 
+  public static native void nConicTo(
+      long nPath, float x1, float y1, float x2, float y2, float weight);
+
+  public static native void nRConicTo(
+      long nPath, float dx1, float dy1, float dx2, float dy2, float weight);
+
   public static native void nCubicTo(
       long nPath, float x1, float y1, float x2, float y2, float x3, float y3);
 
@@ -93,6 +99,10 @@ public final class PathNatives {
 
   public static native boolean nIsRect(long nPath, RectF rect);
 
+  public static native int nGetGenerationID(long nativePath);
+
+  public static native boolean nIsInterpolatable(long startPath, long endPath);
+
   public static native void nReset(long nPath);
 
   public static native void nRewind(long nPath);
@@ -107,5 +117,8 @@ public final class PathNatives {
 
   public static native float[] nApproximate(long nPath, float error);
 
+  public static native boolean nInterpolate(
+      long startPath, long endPath, float t, long interpolatedPath);
+
   private PathNatives() {}
 }
diff --git a/nativeruntime/src/main/resources/arsc/Android.bp b/nativeruntime/src/main/resources/arsc/Android.bp
index 6d627ffe5..e1fa16506 100644
--- a/nativeruntime/src/main/resources/arsc/Android.bp
+++ b/nativeruntime/src/main/resources/arsc/Android.bp
@@ -19,7 +19,7 @@ genrule {
     cmd: "mkdir -p $(genDir)/values; echo '<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
         " <resources>" +
         " <public type=\"string\" name=\"config_bodyFontFamily\" id=\"0x010401fe\" /> " +
-        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x01040273\" /> " +
+        " <public type=\"string\" name=\"config_headlineFontFamily\" id=\"0x01040274\" /> " +
         " </resources>' > $(out)",
 }
 
diff --git a/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf
new file mode 100644
index 000000000..95243cde8
Binary files /dev/null and b/nativeruntime/src/main/resources/fonts/GoogleSansFlexClock-Regular.ttf differ
diff --git a/nativeruntime/src/main/resources/fonts/fonts.xml b/nativeruntime/src/main/resources/fonts/fonts.xml
index 27d865694..5004d86b4 100644
--- a/nativeruntime/src/main/resources/fonts/fonts.xml
+++ b/nativeruntime/src/main/resources/fonts/fonts.xml
@@ -1626,6 +1626,15 @@
     <family customizationType="new-named-family" name="google-sans-clock">
         <font>GoogleSansClock-Regular.ttf</font>
     </family>
+    
+    <family-list customizationType="new-named-family" name="google-sans-flex-clock">
+        <family>
+            <font>GoogleSansFlexClock-Regular.ttf</font>
+        </family>
+        <family>
+            <font>GoogleSansClock-Regular.ttf</font>
+        </family>
+    </family-list>
 
     <family customizationType="new-named-family" name="google-sans-bold">
         <font weight="700" style="normal">GoogleSans-Regular.ttf
diff --git a/pluginapi/build.gradle b/pluginapi/build.gradle
deleted file mode 100644
index f3ffe7625..000000000
--- a/pluginapi/build.gradle
+++ /dev/null
@@ -1,14 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    compileOnly libs.findbugs.jsr305
-    api project(":annotations")
-    api libs.guava
-
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-}
diff --git a/pluginapi/build.gradle.kts b/pluginapi/build.gradle.kts
new file mode 100644
index 000000000..9dd5c1130
--- /dev/null
+++ b/pluginapi/build.gradle.kts
@@ -0,0 +1,14 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  compileOnly(libs.findbugs.jsr305)
+  api(project(":annotations"))
+  api(libs.guava)
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+}
diff --git a/plugins/maven-dependency-resolver/build.gradle b/plugins/maven-dependency-resolver/build.gradle
deleted file mode 100644
index 4f23a8368..000000000
--- a/plugins/maven-dependency-resolver/build.gradle
+++ /dev/null
@@ -1,36 +0,0 @@
-import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-
-plugins {
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.jvm)
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-tasks.withType(GenerateModuleMetadata).configureEach {
-    // We don't want to release gradle module metadata now to avoid
-    // potential compatibility problems.
-    enabled = false
-}
-
-compileKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-compileTestKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-dependencies {
-    api project(":pluginapi")
-    api project(":utils")
-    api libs.auto.value.annotations
-    api libs.guava
-    annotationProcessor libs.auto.value
-
-    testImplementation libs.junit4
-    testImplementation libs.mockito
-    testImplementation libs.truth
-    testImplementation libs.kotlin.stdlib
-}
diff --git a/plugins/maven-dependency-resolver/build.gradle.kts b/plugins/maven-dependency-resolver/build.gradle.kts
new file mode 100644
index 000000000..900932d75
--- /dev/null
+++ b/plugins/maven-dependency-resolver/build.gradle.kts
@@ -0,0 +1,32 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins {
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.jvm)
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+tasks.withType<GenerateModuleMetadata>().configureEach {
+  // We don't want to release Gradle module metadata now to avoid
+  // potential compatibility problems.
+  enabled = false
+}
+
+tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+dependencies {
+  api(project(":pluginapi"))
+  api(project(":utils"))
+  api(libs.auto.value.annotations)
+  api(libs.guava)
+  annotationProcessor(libs.auto.value)
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.mockito)
+  testImplementation(libs.truth)
+  testImplementation(libs.kotlin.stdlib)
+}
diff --git a/preinstrumented/build.gradle b/preinstrumented/build.gradle
deleted file mode 100644
index a24212320..000000000
--- a/preinstrumented/build.gradle
+++ /dev/null
@@ -1,154 +0,0 @@
-plugins {
-    alias(libs.plugins.application)
-    alias(libs.plugins.java)
-}
-
-ext {
-    javaMainClass = "org.robolectric.preinstrumented.JarInstrumentor"
-}
-
-application {
-    mainClassName = javaMainClass
-}
-
-java {
-    sourceCompatibility = JavaVersion.VERSION_1_8
-    targetCompatibility = JavaVersion.VERSION_1_8
-}
-
-dependencies {
-    implementation libs.guava
-    implementation project(":sandbox")
-
-    testImplementation libs.junit4
-    testImplementation libs.mockito
-}
-
-tasks.register('instrumentAll') {
-    dependsOn ':prefetchSdks'
-    dependsOn 'build'
-
-    doLast {
-        def androidAllMavenLocal = "${System.getProperty('user.home')}/.m2/repository/org/robolectric/android-all"
-
-        sdksToInstrument().each { androidSdk ->
-            println("Instrumenting ${androidSdk.coordinates}")
-            def inputPath = "${androidAllMavenLocal}/${androidSdk.version}/${androidSdk.jarFileName}"
-            def outputPath = layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
-
-            javaexec {
-                classpath = sourceSets.main.runtimeClasspath
-                main = javaMainClass
-                args = [inputPath, outputPath]
-            }
-        }
-    }
-}
-
-tasks.register('emptySourcesJar', Jar) {
-    archiveClassifier = "sources"
-}
-
-tasks.register('emptyJavadocJar', Jar) {
-    archiveClassifier = "javadoc"
-}
-
-// Avoid publishing the preinstrumented jars by default. They are published
-// manually when the instrumentation configuration changes to maximize gradle
-// and maven caching.
-if (System.getenv('PUBLISH_PREINSTRUMENTED_JARS') == "true") {
-    apply plugin: 'maven-publish'
-    apply plugin: "signing"
-
-
-    publishing {
-        publications {
-            sdksToInstrument().each { androidSdk ->
-                "sdk${androidSdk.apiLevel}"(MavenPublication) {
-                    artifact layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
-                    artifactId 'android-all-instrumented'
-                    artifact emptySourcesJar
-                    artifact emptyJavadocJar
-                    version androidSdk.preinstrumentedVersion
-
-                    pom {
-                        name = "Google Android ${androidSdk.androidVersion} instrumented android-all library"
-                        description = "Google Android ${androidSdk.androidVersion} framework jars transformed with Robolectric instrumentation."
-                        url = "https://source.android.com/"
-                        inceptionYear = "2008"
-
-                        licenses {
-                            license {
-                                name = "Apache 2.0"
-                                url = "http://www.apache.org/licenses/LICENSE-2.0"
-                                comments = "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
-                                distribution = "repo"
-                            }
-                        }
-
-                        scm {
-                            url = "https://android.googlesource.com/platform/manifest.git"
-                            connection = "https://android.googlesource.com/platform/manifest.git"
-                        }
-
-                        developers {
-                            developer {
-                                name = "The Android Open Source Projects"
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        repositories {
-            maven {
-                url = "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
-
-                credentials {
-                    username = System.properties["sonatype-login"] ?: System.env['SONATYPE_LOGIN']
-                    password = System.properties["sonatype-password"] ?: System.env['SONATYPE_PASSWORD']
-                }
-            }
-        }
-    }
-
-    signing {
-        // Skip signing if a signing key is not configured.
-        required { project.hasProperty("signing.keyId") }
-        sdksToInstrument().each { androidSdk ->
-            sign publishing.publications."sdk${androidSdk.apiLevel}"
-        }
-    }
-
-
-    // Workaround for https://github.com/gradle/gradle/issues/26132
-    // For some reason, Gradle has inferred that all publishing tasks depend on all signing tasks,
-    // so we must explicitly declare this here.
-    afterEvaluate {
-        tasks.configureEach {
-            if (name.startsWith("publishSdk")) {
-                sdksToInstrument().each { androidSdk ->
-                    dependsOn(tasks.named("signSdk${androidSdk.apiLevel}Publication"))
-                }
-            }
-        }
-    }
-}
-
-static def sdksToInstrument() {
-    var result = AndroidSdk.ALL_SDKS
-    var preInstrumentedSdkVersions = (System.getenv('PREINSTRUMENTED_SDK_VERSIONS') ?: "")
-    if (preInstrumentedSdkVersions.length() > 0) {
-        var sdkFilter = preInstrumentedSdkVersions.split(",").collect { it as Integer }
-        if (sdkFilter.size > 0) {
-            result = result.findAll { sdkFilter.contains(it.apiLevel) }
-        }
-    }
-    return result
-}
-
-clean.doFirst {
-    AndroidSdk.ALL_SDKS.each { androidSdk ->
-        delete layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName)
-    }
-}
diff --git a/preinstrumented/build.gradle.kts b/preinstrumented/build.gradle.kts
new file mode 100644
index 000000000..7587fd668
--- /dev/null
+++ b/preinstrumented/build.gradle.kts
@@ -0,0 +1,152 @@
+import java.net.URI
+
+plugins {
+  alias(libs.plugins.application)
+  alias(libs.plugins.java)
+}
+
+val javaMainClass = "org.robolectric.preinstrumented.JarInstrumentor"
+
+application { mainClass.set(javaMainClass) }
+
+java {
+  sourceCompatibility = JavaVersion.VERSION_1_8
+  targetCompatibility = JavaVersion.VERSION_1_8
+}
+
+dependencies {
+  implementation(libs.guava)
+  implementation(project(":sandbox"))
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.mockito)
+}
+
+val instrumentAll by
+  tasks.registering {
+    dependsOn(":prefetchSdks", "build")
+
+    doLast {
+      val androidAllMavenLocal =
+        "${System.getProperty("user.home")}/.m2/repository/org/robolectric/android-all"
+      sdksToInstrument().forEach { androidSdk ->
+        logger.debug("Instrumenting ${androidSdk.coordinates}")
+
+        val inputPath = "$androidAllMavenLocal/${androidSdk.version}/${androidSdk.jarFileName}"
+        val outputPath =
+          layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
+
+        javaexec {
+          classpath = sourceSets.getByName("main").runtimeClasspath
+          mainClass.set(javaMainClass)
+          args = listOf(inputPath, outputPath)
+        }
+      }
+    }
+  }
+
+val emptySourcesJar by tasks.registering(Jar::class) { archiveClassifier.set("sources") }
+
+val emptyJavadocJar by tasks.registering(Jar::class) { archiveClassifier.set("javadoc") }
+
+// Avoid publishing the preinstrumented jars by default. They are published
+// manually when the instrumentation configuration changes to maximize Gradle
+// and Maven caching.
+if (System.getenv("PUBLISH_PREINSTRUMENTED_JARS") == "true") {
+  pluginManager.apply("maven-publish")
+  pluginManager.apply("signing")
+
+  extensions.configure<PublishingExtension> {
+    publications {
+      sdksToInstrument().forEach { androidSdk ->
+        register<MavenPublication>("sdk${androidSdk.apiLevel}") {
+          artifact(
+            layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName).get().asFile.path
+          )
+          artifactId = "android-all-instrumented"
+          artifact(emptySourcesJar)
+          artifact(emptyJavadocJar)
+          version = androidSdk.preinstrumentedVersion
+
+          pom {
+            name = "Google Android ${androidSdk.androidVersion} instrumented android-all library"
+            description =
+              "Google Android ${androidSdk.androidVersion} framework jars transformed with Robolectric instrumentation."
+            url = "https://source.android.com/"
+            inceptionYear = "2008"
+
+            licenses {
+              license {
+                name = "Apache 2.0"
+                url = "http://www.apache.org/licenses/LICENSE-2.0"
+                comments =
+                  "While the EULA for the Android SDK restricts distribution of those binaries, the source code is licensed under Apache 2.0 which allows compiling binaries from source and then distributing those versions."
+                distribution = "repo"
+              }
+            }
+
+            scm {
+              url = "https://android.googlesource.com/platform/manifest.git"
+              connection = "https://android.googlesource.com/platform/manifest.git"
+            }
+
+            developers { developer { name = "The Android Open Source Projects" } }
+          }
+        }
+      }
+    }
+
+    repositories {
+      maven {
+        url = URI("https://oss.sonatype.org/service/local/staging/deploy/maven2/")
+
+        credentials {
+          username = System.getProperty("sonatype-login") ?: System.getenv("SONATYPE_LOGIN")
+          password = System.getProperty("sonatype-password") ?: System.getenv("SONATYPE_PASSWORD")
+        }
+      }
+    }
+
+    project.extensions.configure<SigningExtension> {
+      // Skip signing if a signing key is not configured.
+      setRequired { hasProperty("signing.keyId") }
+
+      sdksToInstrument().forEach { androidSdk ->
+        sign(publications.getByName("sdk${androidSdk.apiLevel}"))
+      }
+    }
+  }
+
+  // Workaround for https://github.com/gradle/gradle/issues/26132
+  // For some reason, Gradle has inferred that all publishing tasks depend on all signing tasks,
+  // so we must explicitly declare this here.
+  afterEvaluate {
+    tasks.configureEach {
+      if (name.startsWith("publishSdk")) {
+        sdksToInstrument().forEach { androidSdk ->
+          dependsOn(tasks.named("signSdk${androidSdk.apiLevel}Publication"))
+        }
+      }
+    }
+  }
+}
+
+fun sdksToInstrument(): List<AndroidSdk> {
+  val sdkFilter =
+    System.getenv("PREINSTRUMENTED_SDK_VERSIONS").orEmpty().split(',').mapNotNull {
+      it.toIntOrNull()
+    }
+  if (sdkFilter.isNotEmpty()) {
+    return AndroidSdk.ALL_SDKS.filter { it.apiLevel in sdkFilter }
+  }
+
+  return AndroidSdk.ALL_SDKS
+}
+
+tasks.named("clean") {
+  doFirst {
+    AndroidSdk.ALL_SDKS.forEach { androidSdk ->
+      delete(layout.buildDirectory.file(androidSdk.preinstrumentedJarFileName))
+    }
+  }
+}
diff --git a/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java b/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
index d0665562b..2b07e0ab0 100644
--- a/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
+++ b/preinstrumented/src/main/java/org/robolectric/preinstrumented/JarInstrumentor.java
@@ -1,13 +1,21 @@
 package org.robolectric.preinstrumented;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.io.ByteStreams;
+import com.google.common.io.Files;
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.file.Path;
 import java.util.Enumeration;
+import java.util.List;
 import java.util.Locale;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
@@ -34,6 +42,13 @@ public class JarInstrumentor {
   private final ClassInstrumentor classInstrumentor;
   private final InstrumentationConfiguration instrumentationConfiguration;
 
+  private boolean hasPackagesToKeepFile;
+  private ImmutableSet<String> packagesToKeep = ImmutableSet.of();
+
+  private boolean hasResourcesToKeepFile;
+  private ImmutableSet<String> resourceFilesToKeep = ImmutableSet.of();
+  private ImmutableSet<String> resourceDirsToKeep = ImmutableSet.of();
+
   public static void main(String[] args) throws IOException, ClassNotFoundException {
     new JarInstrumentor().processCommandLine(args);
   }
@@ -50,16 +65,55 @@ public class JarInstrumentor {
 
   @VisibleForTesting
   void processCommandLine(String[] args) throws IOException, ClassNotFoundException {
-    if (args.length == 2) {
-      File sourceFile = new File(args[0]);
-      File destJarFile = new File(args[1]);
-
-      instrumentJar(sourceFile, destJarFile);
-      return;
+    if (args.length < 2) {
+      System.err.println(
+          "Usage: JarInstrumentor"
+              + " [--packages_to_keep=file path containing package list]"
+              + " [--resources_to_keep=file path containing resource list]"
+              + " <source jar> <dest jar> ");
+      exit(1);
     }
+    File sourceFile = null;
+    File destFile = null;
 
-    System.err.println("Usage: JarInstrumentor <source jar> <dest jar> ");
-    exit(1);
+    for (String arg : args) {
+      if (arg.startsWith("--packages_to_keep=")) {
+        File packagesToKeepFile = new File(arg.substring(arg.indexOf('=') + 1));
+        if (!packagesToKeepFile.exists()) {
+          System.err.println("Packages file does not exist: " + packagesToKeepFile);
+          exit(1);
+          return;
+        }
+        hasPackagesToKeepFile = true;
+        packagesToKeep = ImmutableSet.copyOf(Files.readLines(packagesToKeepFile, UTF_8));
+        Preconditions.checkState(!packagesToKeep.isEmpty(), "Package files must be non-empty.");
+      } else if (arg.startsWith("--resources_to_keep=")) {
+        File resourcesToKeepFile = new File(arg.substring(arg.indexOf('=') + 1));
+        if (!resourcesToKeepFile.exists()) {
+          System.err.println("Resources file does not exist: " + resourcesToKeepFile);
+          exit(1);
+          return;
+        }
+        List<String> resourceFiles = Files.readLines(resourcesToKeepFile, UTF_8);
+        resourceFilesToKeep =
+            ImmutableSet.copyOf(Iterables.filter(resourceFiles, s -> !s.endsWith("/")));
+        resourceDirsToKeep =
+            ImmutableSet.copyOf(Iterables.filter(resourceFiles, s -> s.endsWith("/")));
+        Preconditions.checkState(
+            !resourceFilesToKeep.isEmpty() && !resourceDirsToKeep.isEmpty(),
+            "Resource files and directories must be specified.");
+        hasResourcesToKeepFile = true;
+      } else if (arg.startsWith("--")) {
+        System.err.println("Unknown flag: " + arg);
+        exit(1);
+        return;
+      } else if (sourceFile == null) {
+        sourceFile = new File(arg);
+      } else if (destFile == null) {
+        destFile = new File(arg);
+      }
+    }
+    instrumentJar(sourceFile, destFile);
   }
 
   /** Calls {@link System#exit(int)}. Overridden during tests to avoid exiting during tests. */
@@ -104,11 +158,24 @@ public class JarInstrumentor {
         JarEntry jarEntry = entries.nextElement();
 
         String name = jarEntry.getName();
+        Path normalizedPath = new File(destJarFile.getParentFile(), name).toPath().normalize();
+        if (!normalizedPath.startsWith(destJarFile.getParentFile().toPath())) {
+          throw new IOException("Bad zip entry: " + name);
+        }
         if (name.endsWith("/")) {
+          // Copy directories
           jarOut.putNextEntry(createJarEntry(jarEntry));
         } else if (name.endsWith(".class")) {
           String className = name.substring(0, name.length() - ".class".length()).replace('/', '.');
 
+          int lastDotIndex = className.lastIndexOf('.');
+          if (lastDotIndex != -1) {
+            String packageName = className.substring(0, lastDotIndex);
+            if (hasPackagesToKeepFile && !packagesToKeep.contains(packageName)) {
+              continue;
+            }
+          }
+
           try {
             byte[] classBytes = getClassBytes(className, jarFile);
             ClassDetails classDetails = new ClassDetails(classBytes);
@@ -126,10 +193,23 @@ public class JarInstrumentor {
                 "Skipping instrumenting due to NegativeArraySizeException for class: " + className);
           }
         } else {
-          // resources & stuff
-          jarOut.putNextEntry(createJarEntry(jarEntry));
-          ByteStreams.copy(jarFile.getInputStream(jarEntry), jarOut);
-          nonClassCount++;
+          boolean shouldKeep = true;
+          if (hasResourcesToKeepFile) {
+            shouldKeep = false;
+            if (resourceFilesToKeep.contains(name)) {
+              shouldKeep = true;
+            }
+            for (String dir : resourceDirsToKeep) {
+              if (name.startsWith(dir)) {
+                shouldKeep = true;
+              }
+            }
+          }
+          if (shouldKeep) {
+            jarOut.putNextEntry(createJarEntry(jarEntry));
+            ByteStreams.copy(jarFile.getInputStream(jarEntry), jarOut);
+            nonClassCount++;
+          }
         }
       }
     }
diff --git a/processor/build.gradle b/processor/build.gradle
deleted file mode 100644
index d5897d019..000000000
--- a/processor/build.gradle
+++ /dev/null
@@ -1,59 +0,0 @@
-import org.gradle.internal.jvm.Jvm
-
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-class GenerateSdksFileTask extends DefaultTask {
-    @OutputFile
-    File outFile
-
-    @TaskAction
-    void writeProperties() throws Exception {
-        File outDir = outFile.parentFile
-        if (!outDir.directory) outDir.mkdirs()
-        outFile.withPrintWriter { out ->
-            out << "# GENERATED by ${this} -- do not edit\n"
-
-            AndroidSdk.ALL_SDKS.each { androidSdk ->
-                def config = project.configurations.create("processor_sdk${androidSdk.apiLevel}")
-                project.dependencies.add("processor_sdk${androidSdk.apiLevel}", androidSdk.coordinates)
-                def sdkPath = config.files.first().getAbsolutePath()
-                out << "${sdkPath}\n"
-            }
-        }
-    }
-}
-
-task('generateSdksFile', type: GenerateSdksFileTask) {
-    outFile = project.rootProject.layout.buildDirectory.file('sdks.txt').get().asFile
-}
-
-tasks.named("classes").configure { task ->
-    task.dependsOn(generateSdksFile)
-}
-
-dependencies {
-    api project(":annotations")
-    api project(":shadowapi")
-
-    compileOnly libs.findbugs.jsr305
-    api libs.asm
-    api libs.asm.commons
-    api libs.asm.util
-    api libs.guava
-    api libs.gson
-    implementation libs.auto.common
-
-    def toolsJar = Jvm.current().getToolsJar()
-    if (toolsJar != null) {
-        implementation files(toolsJar)
-    }
-
-    testImplementation libs.javax.annotation.jsr250.api
-    testImplementation libs.junit4
-    testImplementation libs.mockito
-    testImplementation libs.compile.testing
-    testImplementation libs.truth
-}
diff --git a/processor/build.gradle.kts b/processor/build.gradle.kts
new file mode 100644
index 000000000..341fd8d4f
--- /dev/null
+++ b/processor/build.gradle.kts
@@ -0,0 +1,62 @@
+import org.gradle.internal.jvm.Jvm
+
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+abstract class GenerateSdksFileTask : DefaultTask() {
+  @get:OutputFile abstract var outFile: File
+
+  @TaskAction
+  @Throws(Exception::class)
+  fun writeProperties() {
+    val outDir = outFile.parentFile
+    if (!outDir.isDirectory) {
+      outDir.mkdirs()
+    }
+
+    outFile.printWriter().use { out ->
+      out.write("# GENERATED by $this -- do not edit\n")
+
+      AndroidSdk.ALL_SDKS.forEach { androidSdk ->
+        val config = project.configurations.create("processor_sdk${androidSdk.apiLevel}")
+        project.dependencies.add("processor_sdk${androidSdk.apiLevel}", androidSdk.coordinates)
+
+        val sdkPath = config.files.first().absolutePath
+        out.write("$sdkPath\n")
+      }
+    }
+  }
+}
+
+val generateSdksFile by
+  tasks.registering(GenerateSdksFileTask::class) {
+    outFile = project.rootProject.layout.buildDirectory.file("sdks.txt").get().asFile
+  }
+
+tasks.classes.configure { dependsOn(generateSdksFile) }
+
+dependencies {
+  api(project(":annotations"))
+  api(project(":shadowapi"))
+
+  compileOnly(libs.findbugs.jsr305)
+  api(libs.asm)
+  api(libs.asm.commons)
+  api(libs.asm.util)
+  api(libs.guava)
+  api(libs.gson)
+  implementation(libs.auto.common)
+
+  val toolsJar = Jvm.current().getToolsJar()
+  if (toolsJar != null) {
+    implementation(files(toolsJar))
+  }
+
+  testImplementation(libs.javax.annotation.jsr250.api)
+  testImplementation(libs.junit4)
+  testImplementation(libs.mockito)
+  testImplementation(libs.compile.testing)
+  testImplementation(libs.truth)
+}
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
index a5ec0e18d..a3ac0e992 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/RobolectricProcessor.java
@@ -44,6 +44,8 @@ public class RobolectricProcessor extends AbstractProcessor {
   private static final String SDKS_FILE = "org.robolectric.annotation.processing.sdks";
   private static final String DISABLE_INDEVELOPMENT =
       "org.robolectric.annotation.processing.disableInDevelopment";
+  private static final String ALLOW_LOOSE_SIGNATURES =
+      "org.robolectric.annotation.processing.allowLooseSignatures";
 
   /** required for Android Development. */
   private static final String VALIDATE_COMPILE_SDKS =
@@ -67,6 +69,7 @@ public class RobolectricProcessor extends AbstractProcessor {
   private boolean allowInDev;
   private String overrideSdkLocation;
   private int overrideSdkInt;
+  private boolean allowLooseSignatures;
 
   /** Default constructor. */
   public RobolectricProcessor() {}
@@ -101,7 +104,8 @@ public class RobolectricProcessor extends AbstractProcessor {
 
     addValidator(new ImplementationValidator(modelBuilder, environment));
     addValidator(
-        new ImplementsValidator(modelBuilder, environment, sdkCheckMode, sdkStore, allowInDev));
+        new ImplementsValidator(
+            modelBuilder, environment, sdkCheckMode, sdkStore, allowInDev, allowLooseSignatures));
     addValidator(new RealObjectValidator(modelBuilder, environment));
     addValidator(new ResetterValidator(modelBuilder, environment));
   }
@@ -156,6 +160,8 @@ public class RobolectricProcessor extends AbstractProcessor {
       this.priority = Integer.parseInt(options.getOrDefault(PRIORITY, "0"));
       this.allowInDev =
           !"true".equalsIgnoreCase(options.getOrDefault(DISABLE_INDEVELOPMENT, "false"));
+      this.allowLooseSignatures =
+          "true".equalsIgnoreCase(options.getOrDefault(ALLOW_LOOSE_SIGNATURES, "false"));
       if (this.shadowPackage == null) {
         throw new IllegalArgumentException("no package specified for " + PACKAGE_OPT);
       }
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
index e10b0d044..6d4af25a5 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/ImplementsValidator.java
@@ -45,6 +45,7 @@ public class ImplementsValidator extends Validator {
   private final Kind checkKind;
   private final SdkStore sdkStore;
   private final boolean allowInDev;
+  private final boolean allowLooseSignatures;
 
   /** Supported modes for validation of {@link Implementation} methods against SDKs. */
   public enum SdkCheckMode {
@@ -58,7 +59,8 @@ public class ImplementsValidator extends Validator {
       ProcessingEnvironment env,
       SdkCheckMode sdkCheckMode,
       SdkStore sdkStore,
-      boolean allowInDev) {
+      boolean allowInDev,
+      boolean allowLooseSignatures) {
     super(modelBuilder, env, IMPLEMENTS_CLASS);
 
     this.env = env;
@@ -66,6 +68,7 @@ public class ImplementsValidator extends Validator {
     this.checkKind = sdkCheckMode == SdkCheckMode.WARN ? Kind.WARNING : Kind.ERROR;
     this.sdkStore = sdkStore;
     this.allowInDev = allowInDev;
+    this.allowLooseSignatures = allowLooseSignatures;
   }
 
   private TypeElement getClassNameTypeElement(AnnotationValue cv) {
@@ -148,6 +151,11 @@ public class ImplementsValidator extends Validator {
         Helpers.getAnnotationTypeMirrorValue(am, "looseSignatures");
     boolean looseSignatures =
         looseSignaturesAttr != null && (Boolean) looseSignaturesAttr.getValue();
+    if (looseSignatures && !allowLooseSignatures) {
+      error(
+          "looseSignatures is no longer allowed. Please use @ClassName or"
+              + " @Implementation(methodName = ...) instead.");
+    }
     String sdkClassNameFq = sdkClassNameFq(av, cv);
     validateShadow(sdkClassNameFq, shadowType, minSdk, maxSdk, looseSignatures, allowInDev);
 
diff --git a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
index 8b5273ab5..31ed3481c 100644
--- a/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
+++ b/processor/src/main/java/org/robolectric/annotation/processing/validator/SdkStore.java
@@ -56,6 +56,8 @@ import org.robolectric.versioning.AndroidVersions;
 /** Encapsulates a collection of Android framework jars. */
 public class SdkStore {
 
+  private static final String VALID_CLASS_NAME_ANNOTATION_CHARS = "^[a-zA-Z0-9_$.;\\[\\]]+$";
+
   private final Set<Sdk> sdks = new TreeSet<>();
   private boolean loaded = false;
 
@@ -593,21 +595,18 @@ public class SdkStore {
         String paramType = canonicalize(varTypeMirror);
 
         // If parameter is annotated with @ClassName, then use the indicated type instead.
-        List<? extends AnnotationMirror> annotationMirrors = variableElement.getAnnotationMirrors();
-        for (AnnotationMirror am : annotationMirrors) {
-          if (am.getAnnotationType().toString().equals(ClassName.class.getName())) {
-            Map<? extends ExecutableElement, ? extends AnnotationValue> annotationEntries =
-                am.getElementValues();
-            Set<? extends ExecutableElement> keys = annotationEntries.keySet();
-            for (ExecutableElement key : keys) {
-              if ("value()".equals(key.toString())) {
-                AnnotationValue annotationValue = annotationEntries.get(key);
-                paramType = annotationValue.getValue().toString().replace('$', '.');
-                break;
-              }
-            }
-            break;
+        ClassName className = variableElement.getAnnotation(ClassName.class);
+        if (className != null) {
+          if (!className.value().matches(VALID_CLASS_NAME_ANNOTATION_CHARS)) {
+            throw new RuntimeException(
+                "Invalid @ClassName annotation '"
+                    + paramType
+                    + "' in "
+                    + methodElement.getEnclosingElement().getSimpleName()
+                    + "."
+                    + methodElement.getSimpleName());
           }
+          paramType = className.value().replace('$', '.');
         }
 
         String paramTypeWithoutGenerics = typeWithoutGenerics(paramType);
@@ -668,14 +667,36 @@ public class SdkStore {
     private final boolean isStatic;
     private final String returnType;
 
+    /** Create a MethodExtraInfo from ASM in-memory representation (an Android framework method). */
     public MethodExtraInfo(MethodNode method) {
       this.isStatic = (method.access & Opcodes.ACC_STATIC) != 0;
       this.returnType = typeWithoutGenerics(normalize(Type.getReturnType(method.desc)));
     }
 
+    /** Create a MethodExtraInfo from AST (an @Implementation method in a shadow class). */
     public MethodExtraInfo(ExecutableElement methodElement) {
       this.isStatic = methodElement.getModifiers().contains(Modifier.STATIC);
-      this.returnType = typeWithoutGenerics(canonicalize(methodElement.getReturnType()));
+
+      TypeMirror rtType = methodElement.getReturnType();
+      String rt = canonicalize(rtType);
+      // If return type is annotated with @ClassName, then use the indicated type instead.
+      List<? extends AnnotationMirror> annotationMirrors = rtType.getAnnotationMirrors();
+      for (AnnotationMirror am : annotationMirrors) {
+        if (am.getAnnotationType().toString().equals(ClassName.class.getName())) {
+          Map<? extends ExecutableElement, ? extends AnnotationValue> annotationEntries =
+              am.getElementValues();
+          Set<? extends ExecutableElement> keys = annotationEntries.keySet();
+          for (ExecutableElement key : keys) {
+            if ("value()".equals(key.toString())) {
+              AnnotationValue annotationValue = annotationEntries.get(key);
+              rt = annotationValue.getValue().toString().replace('$', '.');
+              break;
+            }
+          }
+          break;
+        }
+      }
+      this.returnType = typeWithoutGenerics(rt);
     }
 
     @Override
diff --git a/resources/build.gradle b/resources/build.gradle
deleted file mode 100644
index 4c0ee24ae..000000000
--- a/resources/build.gradle
+++ /dev/null
@@ -1,21 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api project(":utils")
-    api project(":annotations")
-    api project(":pluginapi")
-
-    api libs.auto.value.annotations
-    api libs.guava
-    compileOnly libs.findbugs.jsr305
-
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.compile.testing
-    testImplementation libs.mockito
-
-    annotationProcessor libs.auto.value
-}
diff --git a/resources/build.gradle.kts b/resources/build.gradle.kts
new file mode 100644
index 000000000..56f600b06
--- /dev/null
+++ b/resources/build.gradle.kts
@@ -0,0 +1,21 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  api(project(":utils"))
+  api(project(":annotations"))
+  api(project(":pluginapi"))
+
+  api(libs.auto.value.annotations)
+  api(libs.guava)
+  compileOnly(libs.findbugs.jsr305)
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.compile.testing)
+  testImplementation(libs.mockito)
+
+  annotationProcessor(libs.auto.value)
+}
diff --git a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
index 82e6ca95d..553418a44 100644
--- a/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
+++ b/resources/src/main/java/org/robolectric/res/android/ConfigDescription.java
@@ -117,7 +117,7 @@ public class ConfigDescription {
                 set_script(subtags[1]);
                 break;
               }
-              // fall through
+            // fall through
             case 5:
             case 6:
             case 7:
diff --git a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
index 275c884fd..304348cc1 100644
--- a/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
+++ b/resources/src/main/java/org/robolectric/res/android/CppApkAssets.java
@@ -24,7 +24,6 @@ import org.robolectric.res.android.Asset.AccessMode;
 import org.robolectric.res.android.CppAssetManager.FileType;
 import org.robolectric.res.android.Idmap.LoadedIdmap;
 import org.robolectric.res.android.ZipFileRO.ZipEntryRO;
-import org.robolectric.util.PerfStatsCollector;
 
 //
 // #ifndef APKASSETS_H_
@@ -234,25 +233,6 @@ public class CppApkAssets {
       LoadedIdmap loaded_idmap,
       boolean system,
       boolean load_as_shared_library) {
-    return PerfStatsCollector.getInstance()
-        .measure(
-            "load binary " + (system ? "framework" : "app") + " resources",
-            () ->
-                LoadImpl_measured(
-                    fd, path, idmap_asset, loaded_idmap, system, load_as_shared_library));
-  }
-
-  // std::unique_ptr<const ApkAssets> ApkAssets::LoadImpl(
-  //     unique_fd fd, const std::string& path, std::unique_ptr<Asset> idmap_asset,
-  //     std::unique_ptr<const LoadedIdmap> loaded_idmap, bool system, bool load_as_shared_library)
-  // {
-  static CppApkAssets LoadImpl_measured(
-      int fd,
-      String path,
-      Asset idmap_asset,
-      LoadedIdmap loaded_idmap,
-      boolean system,
-      boolean load_as_shared_library) {
     Ref<ZipArchiveHandle> unmanaged_handle = new Ref<>(null);
     int result;
     if (fd >= 0) {
@@ -284,7 +264,7 @@ public class CppApkAssets {
 
     // Open the resource table via mmap unless it is compressed. This logic is taken care of by
     // Open.
-    loaded_apk.resources_asset_ = loaded_apk.Open(kResourcesArsc, Asset.AccessMode.ACCESS_BUFFER);
+    loaded_apk.resources_asset_ = loaded_apk.Open(kResourcesArsc, AccessMode.ACCESS_BUFFER);
     if (loaded_apk.resources_asset_ == null) {
       System.err.println("Failed to open '" + kResourcesArsc + "' in APK '" + path + "'.");
       return null;
@@ -313,6 +293,11 @@ public class CppApkAssets {
     return loaded_apk;
   }
 
+  // std::unique_ptr<const ApkAssets> ApkAssets::LoadImpl(
+  //     unique_fd fd, const std::string& path, std::unique_ptr<Asset> idmap_asset,
+  //     std::unique_ptr<const LoadedIdmap> loaded_idmap, bool system, bool load_as_shared_library)
+  // {
+
   private static String ErrorCodeString(int result) {
     return "Error " + result;
   }
diff --git a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
index af11726a0..15eb5b6c4 100644
--- a/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
+++ b/resources/src/main/java/org/robolectric/res/android/DynamicRefTable.java
@@ -159,7 +159,7 @@ public class DynamicRefTable {
     switch (dataType) {
       case ATTRIBUTE:
         resolvedType = DataType.ATTRIBUTE.code();
-        // fallthrough
+      // fallthrough
       case REFERENCE:
         if (!mAppAsLib) {
           return NO_ERROR;
@@ -170,7 +170,7 @@ public class DynamicRefTable {
         break;
       case DYNAMIC_ATTRIBUTE:
         resolvedType = DataType.ATTRIBUTE.code();
-        // fallthrough
+      // fallthrough
       case DYNAMIC_REFERENCE:
         break;
       default:
diff --git a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
index 177149ea3..9778051f9 100644
--- a/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
+++ b/resources/src/main/java/org/robolectric/res/android/ResTable_config.java
@@ -1967,7 +1967,7 @@ public class ResTable_config {
           }
           break;
         }
-        // fall through
+      // fall through
       case 5:
       case 6:
       case 7:
diff --git a/robolectric/Android.bp b/robolectric/Android.bp
index 5cfacb4cf..906896b7a 100644
--- a/robolectric/Android.bp
+++ b/robolectric/Android.bp
@@ -37,6 +37,7 @@ java_library_host {
         "asm-9.6",
         "jsr305",
         "conscrypt-unbundled",
+        "TestParameterInjector",
         "robolectric-host-androidx_test_espresso",
         "robolectric-host-android_all",
     ],
@@ -91,6 +92,7 @@ java_test_host {
         "robolectric-ant-1.8.0",
         "asm-9.6",
         "jsr305",
+        "TestParameterInjector",
         "robolectric-host-androidx_test_espresso",
         "robolectric-host-androidx-test-ext-truth_upstream",
     ],
diff --git a/robolectric/build.gradle b/robolectric/build.gradle
deleted file mode 100644
index 8393d29b0..000000000
--- a/robolectric/build.gradle
+++ /dev/null
@@ -1,49 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    annotationProcessor libs.auto.service
-    annotationProcessor libs.error.prone.core
-
-    api project(":annotations")
-    api project(":junit")
-    api project(":pluginapi")
-    api project(":resources")
-    api project(":sandbox")
-    api project(":utils")
-    api project(":utils:reflector")
-    api project(":plugins:maven-dependency-resolver")
-    api libs.javax.inject
-    compileOnly libs.auto.service.annotations
-    api libs.javax.annotation.api
-
-    // We need to have shadows-framework.jar on the runtime system classpath so ServiceLoader
-    //   can find its META-INF/services/org.robolectric.shadows.ShadowAdapter.
-    api project(":shadows:framework")
-
-    implementation libs.conscrypt.openjdk.uber
-    api libs.bcprov.jdk18on
-    compileOnly libs.findbugs.jsr305
-
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-    compileOnly libs.junit4
-    compileOnly libs.androidx.annotation
-
-    api "androidx.test:monitor:$axtMonitorVersion@aar"
-    implementation "androidx.test.espresso:espresso-idling-resource:$espressoVersion@aar"
-
-    testImplementation libs.androidx.annotation
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-    testImplementation libs.hamcrest.junit
-    testImplementation "androidx.test:core:$axtCoreVersion@aar"
-    testImplementation "androidx.test.ext:junit:$axtJunitVersion@aar"
-    testImplementation "androidx.test.ext:truth:$axtTruthVersion@aar"
-    testImplementation "androidx.test:runner:$axtRunnerVersion@aar"
-    testImplementation libs.guava
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates // compile against latest Android SDK
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates // run against whatever this JDK supports
-}
\ No newline at end of file
diff --git a/robolectric/build.gradle.kts b/robolectric/build.gradle.kts
new file mode 100644
index 000000000..8b0a2ab6d
--- /dev/null
+++ b/robolectric/build.gradle.kts
@@ -0,0 +1,77 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+val axtCoreVersion: String by rootProject.extra
+val axtJunitVersion: String by rootProject.extra
+val axtMonitorVersion: String by rootProject.extra
+val axtRunnerVersion: String by rootProject.extra
+val axtTruthVersion: String by rootProject.extra
+val espressoVersion: String by rootProject.extra
+
+dependencies {
+  annotationProcessor(libs.auto.service)
+  annotationProcessor(libs.error.prone.core)
+
+  api(project(":annotations"))
+  api(project(":junit"))
+  api(project(":pluginapi"))
+  api(project(":resources"))
+  api(project(":sandbox"))
+  api(project(":utils"))
+  api(project(":utils:reflector"))
+  api(project(":plugins:maven-dependency-resolver"))
+  api(libs.javax.inject)
+  compileOnly(libs.auto.service.annotations)
+  api(libs.javax.annotation.api)
+
+  // We need to have shadows-framework.jar on the runtime system classpath so ServiceLoader
+  //   can find its META-INF/services/org.robolectric.shadows.ShadowAdapter.
+  api(project(":shadows:framework"))
+
+  implementation(libs.conscrypt.openjdk.uber)
+  implementation(libs.snakeyaml)
+
+  api(libs.bcprov.jdk18on)
+  compileOnly(libs.findbugs.jsr305)
+
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  compileOnly(libs.junit4)
+  compileOnly(libs.androidx.annotation)
+
+  api("androidx.test:monitor:$axtMonitorVersion@aar")
+  implementation("androidx.test.espresso:espresso-idling-resource:$espressoVersion@aar")
+  implementation("com.google.testparameterinjector:test-parameter-injector:1.18@jar")
+
+  testImplementation(libs.androidx.annotation)
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+  testImplementation(libs.hamcrest.junit)
+  testImplementation("androidx.test:core:$axtCoreVersion@aar")
+  testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
+  testImplementation("androidx.test.ext:truth:$axtTruthVersion@aar")
+  testImplementation("androidx.test:runner:$axtRunnerVersion@aar")
+  testImplementation(libs.guava)
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates) // compile against latest Android SDK
+  testRuntimeOnly(androidStubsJar())
+}
+
+fun androidStubsJar(): ConfigurableFileCollection {
+  val androidStubsVersion = libs.versions.androidstubs.get()
+  if ("ANDROID_HOME" !in System.getenv()) {
+    throw GradleException("Environment variable ANDROID_HOME is not set.")
+  }
+
+  val androidJarPath =
+    "${System.getenv("ANDROID_HOME")}/platforms/android-$androidStubsVersion/android.jar"
+  val androidJar = file(androidJarPath)
+  if (!androidJar.exists()) {
+    throw GradleException(
+      "android.jar $androidStubsVersion not found at $androidJarPath. Download it through Android SDK Manager, or install the `Android SDK Command-line tools` and run `sdkmanager \"platforms;android-$androidStubsVersion\"`."
+    )
+  }
+
+  return files(androidJarPath)
+}
diff --git a/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
index b44276828..33b7dbd31 100644
--- a/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/ParameterizedRobolectricTestRunner.java
@@ -38,6 +38,8 @@ import org.robolectric.util.ReflectionHelpers;
  * <p>This class takes care of the fact that the test runner and the test class are actually loaded
  * from different class loaders and therefore parameter objects created by one cannot be assigned to
  * instances of the other.
+ *
+ * <p>See also {@link RobolectricTestParameterInjector} for a more modern alternative.
  */
 public final class ParameterizedRobolectricTestRunner extends Suite {
 
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java b/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java
new file mode 100644
index 000000000..2b5e0f634
--- /dev/null
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestParameterInjector.java
@@ -0,0 +1,226 @@
+package org.robolectric;
+
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.toList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.junit.testparameterinjector.TestParameter;
+import com.google.testing.junit.testparameterinjector.TestParameterInjector;
+import com.google.testing.junit.testparameterinjector.TestParameters;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.IntStream;
+import org.junit.runners.model.FrameworkMethod;
+import org.junit.runners.model.InitializationError;
+import org.junit.runners.model.Statement;
+import org.robolectric.internal.bytecode.InstrumentationConfiguration;
+
+/**
+ * A {@link RobolectricTestRunner} that supports {@link TestParameterInjector} parameter injection.
+ *
+ * <p>This runner provides several benefits over the {@link ParameterizedRobolectricTestRunner}, in
+ * particular:
+ *
+ * <ul>
+ *   <li>It provides convenient syntax for supporting field parameter injection.
+ *   <li>It allows parameterizing individual test methods using {@link TestParameter}.
+ *   <li>It provides easy to use declarative syntax for parameter combinations using {@link
+ *       TestParameters}.
+ * </ul>
+ *
+ * <p>See https://github.com/google/TestParameterInjector for more details.
+ */
+public final class RobolectricTestParameterInjector extends RobolectricTestRunner {
+  private final DelegateTestParameterInjector testParameterInjector;
+
+  public RobolectricTestParameterInjector(Class<?> testClass) throws InitializationError {
+    super(testClass);
+    testParameterInjector = new DelegateTestParameterInjector(testClass);
+  }
+
+  @Override
+  protected void validateConstructor(List<Throwable> errors) {
+    // Allow TestParameterInjector to handle validation.
+  }
+
+  @Override
+  protected void validateTestMethods(List<Throwable> errors) {
+    // Allow TestParameterInjector to handle validation.
+  }
+
+  @Override
+  protected InstrumentationConfiguration createClassLoaderConfig(FrameworkMethod method) {
+    return new InstrumentationConfiguration.Builder(super.createClassLoaderConfig(method))
+        .doNotAcquireClass(DelegateTestRunner.class)
+        .build();
+  }
+
+  @Override
+  protected ImmutableList<FrameworkMethod> getChildren() {
+    // Instantiate test parameter injector to collect the parameterized test method list, and expand
+    // it out for each sdk that the Robolectric runner is running. Unfortunately instantiating the
+    // test parameter injector here means that we cannot inject Android objects, but this is a
+    // similar limitation to the regular Robolectric test runner which doesn't support static
+    // allocation or references to Android objects.
+    Map<Method, List<FrameworkMethod>> injectedMethodsMap =
+        testParameterInjector.computeTestMethods().stream()
+            .collect(groupingBy(FrameworkMethod::getMethod));
+    return ImmutableList.copyOf(
+        super.getChildren().stream()
+            .map(RobolectricFrameworkMethod.class::cast)
+            .map(Objects::requireNonNull)
+            .flatMap(
+                robolectricFrameworkMethod -> {
+                  List<FrameworkMethod> injectedMethods =
+                      Objects.requireNonNull(
+                          injectedMethodsMap.get(robolectricFrameworkMethod.getMethod()));
+                  return IntStream.range(0, injectedMethods.size())
+                      .mapToObj(
+                          index ->
+                              new RobolectricInjectedFrameworkMethod(
+                                  robolectricFrameworkMethod, injectedMethods.get(index), index));
+                })
+            .collect(toList()));
+  }
+
+  @Override
+  protected HelperTestRunner getHelperTestRunner(Class<?> sandboxedTestClass)
+      throws InitializationError {
+    return new DelegateHelperTestRunner(sandboxedTestClass);
+  }
+
+  /** Interface to allow sandboxed injected runner to be accessed from the helper runner. */
+  public interface DelegateTestRunner {
+    List<FrameworkMethod> computeTestMethods();
+
+    Statement methodBlock(FrameworkMethod method);
+
+    Statement methodInvoker(FrameworkMethod method, Object test);
+  }
+
+  /**
+   * Proxy for TestParameterInjector to allow the classloader to load TestParameterInjector in the
+   * SDK sandbox.
+   */
+  private static final class DelegateTestParameterInjector implements DelegateTestRunner {
+    private final TestParameterInjector delegate;
+
+    DelegateTestParameterInjector(Class<?> klass) throws InitializationError {
+      delegate = new TestParameterInjector(klass);
+    }
+
+    @Override
+    public List<FrameworkMethod> computeTestMethods() {
+      return delegate.computeTestMethods();
+    }
+
+    @Override
+    public Statement methodBlock(FrameworkMethod method) {
+      return delegate.methodBlock(method);
+    }
+
+    @Override
+    public Statement methodInvoker(FrameworkMethod method, Object test) {
+      return delegate.methodInvoker(method, test);
+    }
+  }
+
+  /**
+   * Helper test runner that delegates to a test parameter injector that has been class loaded in
+   * the SDK sandbox.
+   */
+  private static final class DelegateHelperTestRunner extends HelperTestRunner {
+    private final DelegateTestRunner testParameterInjector;
+    private final Map<Method, List<FrameworkMethod>> injectedMethods;
+
+    public DelegateHelperTestRunner(Class<?> bootstrappedTestClass) throws InitializationError {
+      super(bootstrappedTestClass);
+      testParameterInjector = createSandboxedDelegateTestParameterInjector(bootstrappedTestClass);
+      injectedMethods =
+          testParameterInjector.computeTestMethods().stream()
+              .collect(groupingBy(FrameworkMethod::getMethod));
+    }
+
+    @Override
+    protected void validateConstructor(List<Throwable> errors) {
+      // Allow TestParameterInjector to handle validation.
+    }
+
+    @Override
+    protected void validateTestMethods(List<Throwable> errors) {
+      // Allow TestParameterInjector to handle validation.
+    }
+
+    @Override
+    protected Statement methodBlock(FrameworkMethod method) {
+      RobolectricInjectedFrameworkMethod robolectricInjectedFrameworkMethod =
+          (RobolectricInjectedFrameworkMethod) frameworkMethod;
+      // Map the method to one that has been class loaded in ths SDK sandbox.
+      return testParameterInjector.methodBlock(
+          Objects.requireNonNull(injectedMethods.get(method.getMethod()))
+              .get(robolectricInjectedFrameworkMethod.getInjectedMethodIndex()));
+    }
+
+    @Override
+    protected Statement methodInvoker(FrameworkMethod method, Object test) {
+      return testParameterInjector.methodInvoker(method, test);
+    }
+
+    private static DelegateTestRunner createSandboxedDelegateTestParameterInjector(
+        Class<?> sandboxedTestClass) {
+      // Use reflection to class load an instance of the TestParameterInjector with the sandboxed
+      // class loader, this allows it to inject objects using the sandboxed class loader into the
+      // test class and methods.
+      try {
+        ClassLoader cl = Objects.requireNonNull(sandboxedTestClass.getClassLoader());
+        Class<?> injectorClass = cl.loadClass(DelegateTestParameterInjector.class.getName());
+        Constructor<?> injectorConstructor = injectorClass.getDeclaredConstructor(Class.class);
+        injectorConstructor.setAccessible(true);
+        return (DelegateTestRunner) injectorConstructor.newInstance(sandboxedTestClass);
+      } catch (ReflectiveOperationException e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+
+  private static final class RobolectricInjectedFrameworkMethod extends RobolectricFrameworkMethod {
+    private final FrameworkMethod injectedMethod;
+    private final int injectedMethodIndex;
+
+    RobolectricInjectedFrameworkMethod(
+        RobolectricFrameworkMethod other, FrameworkMethod injectedMethod, int injectedMethodIndex) {
+      super(other);
+      this.injectedMethod = injectedMethod;
+      this.injectedMethodIndex = injectedMethodIndex;
+    }
+
+    FrameworkMethod getInjectedMethod() {
+      return injectedMethod;
+    }
+
+    int getInjectedMethodIndex() {
+      return injectedMethodIndex;
+    }
+
+    @Override
+    public String getName() {
+      // Both names are in the format "test[foo]" so strip the method name and concat them.
+      return injectedMethod.getName() + super.getName().substring(getMethod().getName().length());
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(super.hashCode(), injectedMethod);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      return super.equals(o)
+          && o instanceof RobolectricInjectedFrameworkMethod
+          && injectedMethod.equals(((RobolectricInjectedFrameworkMethod) o).getInjectedMethod());
+    }
+  }
+}
diff --git a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
index 31e65fbcb..920a0a6a9 100644
--- a/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
+++ b/robolectric/src/main/java/org/robolectric/RobolectricTestRunner.java
@@ -14,8 +14,11 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
+import java.util.ServiceLoader;
 import javax.annotation.Nonnull;
 import javax.annotation.Priority;
+import org.junit.runner.notification.RunListener;
+import org.junit.runner.notification.RunNotifier;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.InitializationError;
 import org.junit.runners.model.Statement;
@@ -115,6 +118,23 @@ public class RobolectricTestRunner extends SandboxTestRunner {
     this.androidConfigurer = injector.getInstance(AndroidConfigurer.class);
   }
 
+  @Override
+  public void run(RunNotifier notifier) {
+    ServiceLoader<RunListener> sl =
+        ServiceLoader.load(RunListener.class, Thread.currentThread().getContextClassLoader());
+    for (RunListener listener : sl) {
+      if (!listener.getClass().getPackageName().startsWith("org.robolectric")) {
+        Logger.warn(
+            "Adding a non-robolectric maintained RunListener"
+                + " (via Plugins/ServiceLoader) can lead to instability, use at your own risk.\n"
+                + "Listener is question : "
+                + listener.getClass().getName());
+      }
+      notifier.addListener(listener);
+    }
+    super.run(notifier);
+  }
+
   /**
    * Create a {@link ClassHandler} appropriate for the given arguments.
    *
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
index d435b212c..186ddcc03 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilder.java
@@ -4,7 +4,13 @@ import android.annotation.IdRes;
 import android.util.AttributeSet;
 import org.robolectric.Robolectric;
 
-/** Builder of {@link AttributeSet}s. */
+/**
+ * Builder of {@link AttributeSet}s.
+ *
+ * @deprecated use Xml.asAttributeSet instead. Not supported in {@link
+ *     org.robolectric.annotation.ResourcesMode.Mode.NATIVE}
+ */
+@Deprecated
 public interface AttributeSetBuilder extends Robolectric.AttributeSetBuilder {
 
   /**
diff --git a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
index 129e01e49..21b684182 100644
--- a/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
+++ b/robolectric/src/main/java/org/robolectric/android/AttributeSetBuilderImpl.java
@@ -81,8 +81,13 @@ public class AttributeSetBuilderImpl implements AttributeSetBuilder {
     public ArscResourceResolver(Context context) {
       this.context = context;
 
-      ShadowAssetManager.ArscBase shadowArscAssetManager = Shadow.extract(context.getAssets());
-      this.resTable = shadowArscAssetManager.getCompileTimeResTable();
+      ShadowAssetManager shadowAssetManager = Shadow.extract(context.getAssets());
+      if (shadowAssetManager instanceof ShadowAssetManager.ArscBase) {
+        this.resTable = ((ShadowAssetManager.ArscBase) shadowAssetManager).getCompileTimeResTable();
+      } else {
+        throw new IllegalStateException(
+            "AttributeSetBuilder is only supported in BINARY resources mode");
+      }
     }
 
     @Override
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
index f501b9495..7c08982b2 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/AndroidTestEnvironment.java
@@ -397,7 +397,9 @@ public class AndroidTestEnvironment implements TestEnvironment {
 
     Package parsedPackage;
 
-    RuntimeEnvironment.compileTimeSystemResourcesFile = compileSdk.getJarPath();
+    // lazy load the compile sdk jar path. It should only be needed when the deprecated
+    // AttributeSetBuilder is used
+    RuntimeEnvironment.setCompileTimeSystemResources(compileSdk::getJarPath);
 
     Path packageFile = appManifest.getApkFile();
     if (packageFile != null) {
diff --git a/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java b/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
index 711ffcc1e..a3d13b542 100644
--- a/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
+++ b/robolectric/src/main/java/org/robolectric/android/internal/RoboMonitoringInstrumentation.java
@@ -427,7 +427,11 @@ public class RoboMonitoringInstrumentation extends Instrumentation {
     for (ActivityController<?> controller : controllers) {
       if (createdActivities.contains(controller)) {
         Activity activity = controller.get();
-        controller.configurationChange(newConfig, newMetrics, changedConfig);
+        if (System.getProperty("robolectric.configurationChangeFix", "true").equals("true")) {
+          controller.configurationChange(newConfig, newMetrics);
+        } else {
+          controller.configurationChange(newConfig, newMetrics, changedConfig);
+        }
         // If the activity is recreated then make the new activity visible, this should be done by
         // configurationChange but there's a pre-existing TODO to address this and it will require
         // more work to make it function correctly.
diff --git a/robolectric/src/main/java/org/robolectric/plugins/ConscryptModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/ConscryptModeConfigurer.java
index 3cadd963d..54fa65b2c 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/ConscryptModeConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/ConscryptModeConfigurer.java
@@ -1,7 +1,6 @@
 package org.robolectric.plugins;
 
 import static com.google.common.base.StandardSystemProperty.OS_ARCH;
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 
 import com.google.auto.service.AutoService;
 import java.util.Locale;
@@ -10,6 +9,7 @@ import org.robolectric.annotation.ConscryptMode;
 import org.robolectric.annotation.ConscryptMode.Mode;
 import org.robolectric.pluginapi.config.Configurer;
 import org.robolectric.plugins.config.SingleValueConfigurer;
+import org.robolectric.util.OsUtil;
 
 /** Provides configuration to Robolectric for its @{@link ConscryptMode} annotation. */
 @AutoService(Configurer.class)
@@ -27,9 +27,8 @@ public class ConscryptModeConfigurer
   }
 
   private static ConscryptMode.Mode defaultValue(Properties properties) {
-    String os = properties.getProperty(OS_NAME.key(), "").toLowerCase(Locale.US);
-    String arch = properties.getProperty(OS_ARCH.key(), "").toLowerCase(Locale.US);
-    if (os.contains("mac") && arch.equals("aarch64")) {
+    String arch = properties.getProperty(OS_ARCH.key(), "").toLowerCase(Locale.ROOT);
+    if (OsUtil.isMac() && arch.equals("aarch64")) {
       return Mode.OFF;
     }
     return Mode.ON;
diff --git a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
index 159c5defc..48b6d70ef 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/DefaultSdkProvider.java
@@ -31,6 +31,7 @@ import org.robolectric.versioning.AndroidVersions.S;
 import org.robolectric.versioning.AndroidVersions.Sv2;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /**
  * Robolectric's default {@link SdkProvider}.
@@ -45,7 +46,7 @@ public class DefaultSdkProvider implements SdkProvider {
 
   private static final int RUNNING_JAVA_VERSION = Util.getJavaVersion();
 
-  private static final int PREINSTRUMENTED_VERSION = 6;
+  private static final int PREINSTRUMENTED_VERSION = 7;
 
   private final DependencyResolver dependencyResolver;
 
@@ -75,6 +76,7 @@ public class DefaultSdkProvider implements SdkProvider {
     knownSdks.put(Sv2.SDK_INT, new DefaultSdk(Sv2.SDK_INT, "12.1", "8229987", "REL", 9));
     knownSdks.put(T.SDK_INT, new DefaultSdk(T.SDK_INT, "13", "9030017", "Tiramisu", 9));
     knownSdks.put(U.SDK_INT, new DefaultSdk(U.SDK_INT, "14", "10818077", "REL", 17));
+    knownSdks.put(V.SDK_INT, new DefaultSdk(V.SDK_INT, "15", "12650502", "REL", 17));
   }
 
   @Override
diff --git a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
index 9aecebfac..ccd2e07d3 100644
--- a/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
+++ b/robolectric/src/main/java/org/robolectric/plugins/SQLiteModeConfigurer.java
@@ -1,15 +1,14 @@
 package org.robolectric.plugins;
 
-import static com.google.common.base.StandardSystemProperty.OS_NAME;
 
 import com.google.auto.service.AutoService;
-import java.util.Locale;
 import java.util.Properties;
 import javax.annotation.Nonnull;
 import org.robolectric.annotation.SQLiteMode;
 import org.robolectric.annotation.SQLiteMode.Mode;
 import org.robolectric.pluginapi.config.Configurer;
 import org.robolectric.plugins.config.SingleValueConfigurer;
+import org.robolectric.util.OsUtil;
 
 /** Provides configuration to Robolectric for its @{@link SQLiteMode} annotation. */
 @AutoService(Configurer.class)
@@ -20,7 +19,7 @@ public class SQLiteModeConfigurer extends SingleValueConfigurer<SQLiteMode, SQLi
     super(
         SQLiteMode.class,
         SQLiteMode.Mode.class,
-        defaultValue(systemProperties),
+        defaultValue(),
         propertyFileLoader,
         systemProperties);
   }
@@ -31,10 +30,9 @@ public class SQLiteModeConfigurer extends SingleValueConfigurer<SQLiteMode, SQLi
   }
 
   @Nonnull
-  private static final SQLiteMode.Mode defaultValue(Properties properties) {
-    String os = properties.getProperty(OS_NAME.key(), "").toLowerCase(Locale.US);
+  private static final SQLiteMode.Mode defaultValue() {
     // NATIVE SQLite mode not supported on Windows
-    if (os.contains("win")) {
+    if (OsUtil.isWindows()) {
       return Mode.LEGACY;
     }
     return Mode.NATIVE;
diff --git a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
index d86ed9565..3c07cad03 100644
--- a/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/AttributeSetBuilderTest.java
@@ -15,10 +15,13 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 import org.robolectric.res.AttributeResource;
 
 /** Tests for {@link Robolectric#buildAttributeSet()} */
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class AttributeSetBuilderTest {
 
   private static final String APP_NS = RES_AUTO_NS_URI;
diff --git a/robolectric/src/test/java/org/robolectric/MethodNameTest.java b/robolectric/src/test/java/org/robolectric/MethodNameTest.java
new file mode 100644
index 000000000..98b9fe124
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/MethodNameTest.java
@@ -0,0 +1,33 @@
+package org.robolectric;
+
+import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.S;
+
+import android.content.Intent;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.Reflector;
+
+/** Tests for @{@link Direct} annotation incorporated inside {@link Reflector}. */
+@RunWith(AndroidJUnit4.class)
+public class MethodNameTest {
+  @Config(sdk = S, shadows = ShadowThrowingIntent.class)
+  @Test
+  public void methodName_shouldNotInvokeOlderSdks() {
+    Intent intent = new Intent();
+    intent.setAction("test"); // should not crash
+  }
+
+  @Implements(Intent.class)
+  public static class ShadowThrowingIntent {
+    @Implementation(minSdk = LOLLIPOP, maxSdk = LOLLIPOP, methodName = "setAction")
+    protected void setActionImpl(String action) {
+      throw new RuntimeException("Should never get called");
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java b/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java
deleted file mode 100644
index f916b0e8c..000000000
--- a/robolectric/src/test/java/org/robolectric/ParameterizedRobolectricTestRunnerClassLoaderTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.robolectric;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
-/**
- * Parameterized tests using an Android class originally created outside of the Robolectric
- * classloader.
- */
-@RunWith(ParameterizedRobolectricTestRunner.class)
-public final class ParameterizedRobolectricTestRunnerClassLoaderTest {
-
-  private final Uri uri;
-
-  public ParameterizedRobolectricTestRunnerClassLoaderTest(Uri uri) {
-    this.uri = uri;
-  }
-
-  @Test
-  @Config(manifest = Config.NONE)
-  public void parse() {
-    Uri currentUri = Uri.parse("http://host/");
-    assertThat(currentUri).isEqualTo(uri);
-  }
-
-  @ParameterizedRobolectricTestRunner.Parameters
-  public static Collection getTestData() {
-    Object[][] data = {{Uri.parse("http://host/")}};
-    return Arrays.asList(data);
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
index 0efe5be94..d7e457b55 100644
--- a/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
+++ b/robolectric/src/test/java/org/robolectric/internal/bytecode/ShadowWranglerUnitTest.java
@@ -9,8 +9,6 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import org.robolectric.android.AndroidSdkShadowMatcher;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
 import org.robolectric.interceptors.AndroidInterceptors;
 import org.robolectric.sandbox.ShadowMatcher;
 import org.robolectric.util.Function;
@@ -77,32 +75,4 @@ public class ShadowWranglerUnitTest {
 
     assertThat(result).isNull();
   }
-
-  public static class DummyClass {}
-
-  @Implements(value = DummyClass.class, minSdk = 19, maxSdk = 21)
-  public static class ShadowDummyClass {
-    @Implementation(minSdk = 20, maxSdk = 20)
-    protected void __constructor__() {}
-
-    @Implementation
-    protected void methodWithoutRange() {}
-
-    @Implementation(minSdk = 20, maxSdk = 20)
-    protected void methodFor20() {}
-
-    @Implementation(minSdk = 20)
-    protected void methodMin20() {}
-
-    @Implementation(maxSdk = 20)
-    protected void methodMax20() {}
-  }
-
-  public static class ChildOfDummyClass extends DummyClass {}
-
-  @Implements(value = ChildOfDummyClass.class, minSdk = 20, maxSdk = 21)
-  public static class ShadowChildOfDummyClass {
-    @Implementation
-    protected void methodWithoutRange() {}
-  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java b/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
index 58301de54..21966034e 100644
--- a/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
+++ b/robolectric/src/test/java/org/robolectric/plugins/SQLiteModeConfigurerTest.java
@@ -1,5 +1,6 @@
 package org.robolectric.plugins;
 
+import static com.google.common.base.StandardSystemProperty.OS_NAME;
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.Properties;
@@ -31,17 +32,20 @@ public class SQLiteModeConfigurerTest {
 
   @Test
   public void osArchSpecificConfig() {
-    Properties systemProperties1 = new Properties();
-    systemProperties1.setProperty("os.name", "Mac OS X");
-    SQLiteModeConfigurer configurer1 =
-        new SQLiteModeConfigurer(systemProperties1, new PackagePropertiesLoader());
-    assertThat(configurer1.defaultConfig()).isSameInstanceAs(Mode.NATIVE);
-
-    Properties systemProperties2 = new Properties();
-    systemProperties2.setProperty("os.name", "Windows 7");
-    SQLiteModeConfigurer configurer2 =
-        new SQLiteModeConfigurer(systemProperties2, new PackagePropertiesLoader());
-
-    assertThat(configurer2.defaultConfig()).isSameInstanceAs(Mode.LEGACY);
+    String oldName = OS_NAME.value();
+    try {
+      System.setProperty("os.name", "Mac OS X");
+      SQLiteModeConfigurer configurer1 =
+          new SQLiteModeConfigurer(System.getProperties(), new PackagePropertiesLoader());
+      assertThat(configurer1.defaultConfig()).isSameInstanceAs(Mode.NATIVE);
+
+      System.setProperty("os.name", "Windows 7");
+      SQLiteModeConfigurer configurer2 =
+          new SQLiteModeConfigurer(System.getProperties(), new PackagePropertiesLoader());
+
+      assertThat(configurer2.defaultConfig()).isSameInstanceAs(Mode.LEGACY);
+    } finally {
+      System.setProperty("os.name", oldName);
+    }
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ApkAssetsCacheTest.java b/robolectric/src/test/java/org/robolectric/shadows/ApkAssetsCacheTest.java
index 4b4e0aea1..6d77856d2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ApkAssetsCacheTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ApkAssetsCacheTest.java
@@ -16,6 +16,8 @@ import org.junit.runners.MethodSorters;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.annotation.LooperMode;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowAssetManager._AssetManager28_;
 
@@ -23,6 +25,7 @@ import org.robolectric.shadows.ShadowAssetManager._AssetManager28_;
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = P)
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
+@ResourcesMode(Mode.BINARY)
 public class ApkAssetsCacheTest {
   private static String propertyName() {
     return "org.robolectric.ApkAssetsCacheTest.ptrs" + RuntimeEnvironment.getApiLevel();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/AssetManagerCachingTest.java b/robolectric/src/test/java/org/robolectric/shadows/AssetManagerCachingTest.java
index d0171913f..c55ae92cd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/AssetManagerCachingTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/AssetManagerCachingTest.java
@@ -13,12 +13,15 @@ import org.junit.runner.RunWith;
 import org.junit.runners.MethodSorters;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.versioning.AndroidVersions.P;
 
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = P.SDK_INT)
+@ResourcesMode(Mode.BINARY)
 public class AssetManagerCachingTest {
   private static final AtomicLong systemNativePtr = new AtomicLong();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java
new file mode 100644
index 000000000..0d4feb557
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/InputDeviceBuilderTest.java
@@ -0,0 +1,71 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.view.InputDevice;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.U;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(minSdk = U.SDK_INT)
+public class InputDeviceBuilderTest {
+
+  @Test
+  public void testBuild() {
+    final InputDevice device =
+        InputDeviceBuilder.newBuilder()
+            .setId(2)
+            .setControllerNumber(43)
+            .setName("Test Device ")
+            .setVendorId(44)
+            .setProductId(45)
+            .setDescriptor("descriptor")
+            .setExternal(true)
+            .setSources(InputDevice.SOURCE_HDMI)
+            .setKeyboardType(InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC)
+            .setHasVibrator(true)
+            .setHasMicrophone(true)
+            .build();
+
+    assertDevice(device);
+  }
+
+  private void assertDevice(InputDevice device) {
+    assertThat(device.getId()).isEqualTo(2);
+
+    assertThat(device.getControllerNumber()).isEqualTo(43);
+    assertThat(device.getName()).isEqualTo("Test Device ");
+    assertThat(device.getVendorId()).isEqualTo(44);
+    assertThat(device.getProductId()).isEqualTo(45);
+    assertThat(device.getDescriptor()).isEqualTo("descriptor");
+
+    assertThat(device.getSources()).isEqualTo(InputDevice.SOURCE_HDMI);
+    assertThat(device.getKeyboardType()).isEqualTo(InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC);
+    assertThat(device.getVibrator().hasVibrator()).isEqualTo(true);
+    assertThat(device.hasMicrophone()).isEqualTo(true);
+  }
+
+  // regression test that directly using the platform InputDevice.Builder is functioning correctly.
+  @Test
+  public void platformBuilder() {
+    final InputDevice device =
+        new InputDevice.Builder()
+            .setId(2)
+            .setControllerNumber(43)
+            .setName("Test Device ")
+            .setVendorId(44)
+            .setProductId(45)
+            .setDescriptor("descriptor")
+            .setExternal(true)
+            .setSources(InputDevice.SOURCE_HDMI)
+            .setKeyboardType(InputDevice.KEYBOARD_TYPE_NON_ALPHABETIC)
+            .setHasVibrator(true)
+            .setHasMicrophone(true)
+            .build();
+
+    assertDevice(device);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
index 27f3fabd2..e3d8f7299 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityManagerTest.java
@@ -8,6 +8,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.accessibilityservice.AccessibilityServiceInfo;
+import android.app.Activity;
 import android.content.Context;
 import android.content.pm.ServiceInfo;
 import android.view.accessibility.AccessibilityEvent;
@@ -21,6 +22,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ReflectionHelpers;
 
@@ -266,4 +268,35 @@ public class ShadowAccessibilityManagerTest {
                 AccessibilityServiceInfo.FEEDBACK_SPOKEN))
         .isEmpty();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void accessibilityManager_activityContextEnabled_differentInstancesHaveSameServices() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      AccessibilityManager applicationAccessibilityManager =
+          (AccessibilityManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.ACCESSIBILITY_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      AccessibilityManager activityAccessibilityManager =
+          (AccessibilityManager) activity.getSystemService(Context.ACCESSIBILITY_SERVICE);
+
+      assertThat(applicationAccessibilityManager).isSameInstanceAs(activityAccessibilityManager);
+
+      List<AccessibilityServiceInfo> applicationServices =
+          applicationAccessibilityManager.getInstalledAccessibilityServiceList();
+      List<AccessibilityServiceInfo> activityServices =
+          activityAccessibilityManager.getInstalledAccessibilityServiceList();
+
+      assertThat(activityServices).isEqualTo(applicationServices);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
index e80484ef5..869e9359d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityNodeInfoTest.java
@@ -9,6 +9,7 @@ import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.graphics.Rect;
 import android.os.Parcel;
 import android.view.View;
@@ -17,10 +18,10 @@ import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
 import android.view.accessibility.AccessibilityWindowInfo;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
@@ -34,15 +35,9 @@ public class ShadowAccessibilityNodeInfoTest {
   @Before
   public void setUp() {
     ShadowAccessibilityNodeInfo.resetObtainedInstances();
-    assertThat(ShadowAccessibilityNodeInfo.areThereUnrecycledNodes(true)).isEqualTo(false);
     node = AccessibilityNodeInfo.obtain();
   }
 
-  @Test
-  public void shouldHaveObtainedNode() {
-    assertThat(ShadowAccessibilityNodeInfo.areThereUnrecycledNodes(false)).isEqualTo(true);
-  }
-
   @Test
   public void shouldHaveZeroBounds() {
     Rect outBounds = new Rect();
@@ -73,8 +68,8 @@ public class ShadowAccessibilityNodeInfoTest {
     node.writeToParcel(p, 0);
     p.setDataPosition(0);
     AccessibilityNodeInfo anotherNode = AccessibilityNodeInfo.CREATOR.createFromParcel(p);
-    assertThat(node).isEqualTo(anotherNode);
-    node.setContentDescription(null);
+    assertThat(node.getContentDescription().toString())
+        .isEqualTo(anotherNode.getContentDescription().toString());
   }
 
   @Test
@@ -110,30 +105,24 @@ public class ShadowAccessibilityNodeInfoTest {
     node = AccessibilityNodeInfo.obtain();
     node.setClickable(false);
     shadow = shadowOf(node);
-    shadow.setPasteable(false);
     assertThat(node.isClickable()).isEqualTo(false);
-    assertThat(shadow.isPasteable()).isEqualTo(false);
     node.setText("Test");
-    shadow.setTextSelectionSetable(true);
     node.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
     node.setTextSelection(0, 1);
     assertThat(node.getActions()).isEqualTo(AccessibilityNodeInfo.ACTION_SET_SELECTION);
     assertThat(node.getTextSelectionStart()).isEqualTo(0);
     assertThat(node.getTextSelectionEnd()).isEqualTo(1);
-    AccessibilityWindowInfo window = ShadowAccessibilityWindowInfo.obtain();
+    AccessibilityWindowInfo window = AccessibilityWindowInfo.obtain();
     shadow.setAccessibilityWindowInfo(window);
     assertThat(node.getWindow()).isEqualTo(window);
     shadow.setAccessibilityWindowInfo(null);
     // Remove action was added in API 21
     node.removeAction(AccessibilityAction.ACTION_SET_SELECTION);
-    shadow.setPasteable(true);
-    shadow.setTextSelectionSetable(false);
     node.addAction(AccessibilityNodeInfo.ACTION_PASTE);
     assertThat(node.getActions()).isEqualTo(AccessibilityNodeInfo.ACTION_PASTE);
     node.setClickable(true);
     assertThat(node.isClickable()).isEqualTo(true);
     node.setClickable(false);
-    shadow.setPasteable(false);
     node.removeAction(AccessibilityNodeInfo.ACTION_PASTE);
     node.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
     assertThat(node.getActions()).isEqualTo(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
@@ -299,19 +288,31 @@ public class ShadowAccessibilityNodeInfoTest {
     assertThat(root.getChild(0).isHeading()).isTrue();
   }
 
+  @Test
+  public void getSourceNodeId_notZero() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    View view = activity.findViewById(android.R.id.content);
+    AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(view);
+    assertThat(node.getSourceNodeId()).isNotEqualTo(0);
+  }
+
   @Test
   public void testConstructor() {
     AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain();
-    assertThat(node.getWindowId()).isEqualTo(AccessibilityWindowInfo.UNDEFINED_WINDOW_ID);
+    assertThat(node.getWindowId())
+        .isEqualTo(RuntimeEnvironment.getApiLevel() >= O ? -1 : Integer.MAX_VALUE);
     if (RuntimeEnvironment.getApiLevel() >= O) {
       // This constant does not exists pre-O.
       assertThat(node.getSourceNodeId()).isEqualTo(AccessibilityNodeInfo.UNDEFINED_NODE_ID);
     }
   }
 
-  @After
-  public void tearDown() {
-    ShadowAccessibilityNodeInfo.resetObtainedInstances();
-    assertThat(ShadowAccessibilityNodeInfo.areThereUnrecycledNodes(true)).isEqualTo(false);
+  @Test
+  public void obtainWithNode_afterSetSealed() {
+    AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain();
+    node.setSealed(true);
+    assertThat(node.isSealed()).isTrue();
+    AccessibilityNodeInfo node2 = AccessibilityNodeInfo.obtain(node);
+    assertThat(node2.isSealed()).isTrue();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
index 803599825..54f632d48 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAccessibilityWindowInfoTest.java
@@ -1,5 +1,7 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
@@ -9,16 +11,16 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowAccessibilityWindowInfoTest {
+  private AccessibilityWindowInfo window;
   private ShadowAccessibilityWindowInfo shadow;
 
   @Before
   public void setUp() {
-    ShadowAccessibilityWindowInfo.resetObtainedInstances();
-    assertThat(ShadowAccessibilityWindowInfo.areThereUnrecycledWindows(true)).isEqualTo(false);
-    AccessibilityWindowInfo window = ShadowAccessibilityWindowInfo.obtain();
+    window = AccessibilityWindowInfo.obtain();
     assertThat(window).isNotNull();
     shadow = shadowOf(window);
   }
@@ -42,12 +44,13 @@ public class ShadowAccessibilityWindowInfoTest {
     assertThat(shadow.getAnchor()).isEqualTo(node);
   }
 
+  @Config(minSdk = N)
   @Test
   public void testSetTitle() {
-    assertThat(shadow.getTitle()).isNull();
+    assertThat(window.getTitle()).isNull();
     CharSequence title = "Title";
-    shadow.setTitle(title);
-    assertThat(shadow.getTitle().toString()).isEqualTo(title.toString());
+    window.setTitle(title);
+    assertThat(window.getTitle().toString()).isEqualTo(title.toString());
   }
 
   @Test
@@ -57,10 +60,20 @@ public class ShadowAccessibilityWindowInfoTest {
     assertThat(shadow.getChild(0)).isEqualTo(window);
   }
 
+  @Config(minSdk = O)
   @Test
   public void testSetPictureInPicture() {
-    assertThat(shadow.isInPictureInPictureMode()).isFalse();
-    shadow.setPictureInPicture(true);
-    assertThat(shadow.isInPictureInPictureMode()).isTrue();
+    assertThat(window.isInPictureInPictureMode()).isFalse();
+    window.setPictureInPicture(true);
+    assertThat(window.isInPictureInPictureMode()).isTrue();
+  }
+
+  @Test
+  public void shadowFieldsClearedAfterRecycle() {
+    AccessibilityWindowInfo window2 = AccessibilityWindowInfo.obtain();
+    shadow.addChild(window2);
+    assertThat(shadow.getChild(0)).isEqualTo(window2);
+    window.recycle();
+    assertThat(shadow.getChild(0)).isNull();
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
index ccdf1b069..73c8eb831 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityManagerTest.java
@@ -13,6 +13,7 @@ import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.ActivityManager.AppTask;
 import android.app.ActivityManager.RecentTaskInfo;
@@ -34,8 +35,10 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.InOrder;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowActivityManagerTest {
@@ -479,4 +482,32 @@ public class ShadowActivityManagerTest {
     info.importanceReasonComponent = name;
     return info;
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void activityManager_activityContextEnabled_retrievesConsistentLowRamDeviceStatus() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      ActivityManager applicationActivityManager =
+          (ActivityManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.ACTIVITY_SERVICE);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      ActivityManager activityActivityManager =
+          (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);
+
+      boolean applicationLowRamStatus = applicationActivityManager.isLowRamDevice();
+      boolean activityLowRamStatus = activityActivityManager.isLowRamDevice();
+
+      assertThat(activityLowRamStatus).isEqualTo(applicationLowRamStatus);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
index aff6272ba..56b7cec6f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowActivityTest.java
@@ -82,6 +82,7 @@ import org.robolectric.annotation.Config;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.fakes.RoboSplashScreen;
+import org.robolectric.shadows.ShadowActivity.IntentForResult;
 import org.robolectric.shadows.ShadowActivity.IntentSenderRequest;
 import org.robolectric.util.TestRunnable;
 
@@ -143,6 +144,77 @@ public class ShadowActivityTest {
     }
   }
 
+  @Test
+  public void createRootActivity_moveTaskToBackNonRoot_shouldMoveTaskToBack() {
+    try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
+      activity = controller.get();
+      controller.create();
+      shadowOf(activity).setIsTaskRoot(true);
+
+      boolean isTaskMovedToBack = activity.moveTaskToBack(/* nonRoot= */ true);
+
+      assertThat(isTaskMovedToBack).isTrue();
+      assertThat(shadowOf(activity).isTaskMovedToBack()).isTrue();
+    }
+  }
+
+  @Test
+  public void createNonRootActivity_moveTaskToBackNonRoot_shouldMoveTaskToBack() {
+    try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
+      activity = controller.get();
+      controller.create();
+      shadowOf(activity).setIsTaskRoot(false);
+
+      boolean isTaskMovedToBack = activity.moveTaskToBack(/* nonRoot= */ true);
+
+      assertThat(isTaskMovedToBack).isTrue();
+      assertThat(shadowOf(activity).isTaskMovedToBack()).isTrue();
+    }
+  }
+
+  @Test
+  public void createNonRootActivity_moveTaskToBackRoot_shouldNotMoveTaskToBack() {
+    try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
+      activity = controller.get();
+      controller.create();
+      shadowOf(activity).setIsTaskRoot(false);
+
+      boolean isTaskMovedToBack = activity.moveTaskToBack(/* nonRoot= */ false);
+
+      assertThat(isTaskMovedToBack).isFalse();
+      assertThat(shadowOf(activity).isTaskMovedToBack()).isFalse();
+    }
+  }
+
+  @Test
+  public void createRootActivity_moveTaskToBackRoot_shouldMoveTaskToBack() {
+    try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
+      activity = controller.get();
+      controller.create();
+      shadowOf(activity).setIsTaskRoot(true);
+
+      boolean isTaskMovedToBack = activity.moveTaskToBack(/* nonRoot= */ false);
+
+      assertThat(isTaskMovedToBack).isTrue();
+      assertThat(shadowOf(activity).isTaskMovedToBack()).isTrue();
+    }
+  }
+
+  @Test
+  public void createNonRootActivity_moveTaskToBackNonRootThenRoot_moveTaskToBacksReturnTrue() {
+    try (ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class)) {
+      activity = controller.get();
+      controller.create();
+      shadowOf(activity).setIsTaskRoot(false);
+
+      boolean isTaskMovedToBackNonRoot = activity.moveTaskToBack(/* nonRoot= */ true);
+      boolean isTaskMovedToBackRoot = activity.moveTaskToBack(/* nonRoot= */ false);
+
+      assertThat(isTaskMovedToBackNonRoot).isTrue();
+      assertThat(isTaskMovedToBackRoot).isTrue();
+    }
+  }
+
   public static final class LabelTestActivity1 extends Activity {}
 
   public static final class LabelTestActivity2 extends Activity {}
@@ -203,6 +275,20 @@ public class ShadowActivityTest {
             "onActivityResult called with requestCode -1, resultCode -1, intent data content:foo");
   }
 
+  @Test
+  public void startActivity_optionsRecordedInIntentForResult() {
+    TranscriptActivity activity = Robolectric.setupActivity(TranscriptActivity.class);
+
+    Bundle options = new Bundle();
+    options.putString("key", "value");
+    activity.startActivity(new Intent().setType("image/*"), options);
+
+    IntentForResult intentForResult = shadowOf(activity).peekNextStartedActivityForResult();
+    assertThat(intentForResult).isNotNull();
+    assertThat(intentForResult.options).isNotNull();
+    assertThat(intentForResult.options.getString("key")).isEqualTo("value");
+  }
+
   public static class TranscriptActivity extends Activity {
     final List<String> transcript = new ArrayList<>();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
index d1da6964c..069453b58 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAlarmManagerTest.java
@@ -8,6 +8,7 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.AlarmManager;
 import android.app.AlarmManager.AlarmClockInfo;
 import android.app.AlarmManager.OnAlarmListener;
@@ -30,6 +31,7 @@ import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm;
 
@@ -663,6 +665,35 @@ public class ShadowAlarmManagerTest {
     assertThat(alarm.getTag()).isEqualTo("tag");
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void alarmManager_instance_retrievesSameAlarmClockInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+
+    try {
+      AlarmManager applicationAlarmManager =
+          (AlarmManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      AlarmManager activityAlarmManager =
+          (AlarmManager) activity.getSystemService(Context.ALARM_SERVICE);
+
+      AlarmManager.AlarmClockInfo applicationAlarmClock =
+          applicationAlarmManager.getNextAlarmClock();
+      AlarmManager.AlarmClockInfo activityAlarmClock = activityAlarmManager.getNextAlarmClock();
+
+      assertThat(activityAlarmClock).isEqualTo(applicationAlarmClock);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   private class TestBroadcastListener extends BroadcastReceiver implements AutoCloseable {
 
     private final Runnable alarm;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
index 4281e891d..35c43920a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAmbientContextManagerTest.java
@@ -1,7 +1,9 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
+import android.app.Activity;
 import android.app.PendingIntent;
 import android.app.ambientcontext.AmbientContextEvent;
 import android.app.ambientcontext.AmbientContextEventRequest;
@@ -14,10 +16,16 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -181,4 +189,57 @@ public class ShadowAmbientContextManagerTest {
 
     assertThat(lastRequestedEventCodes).containsExactlyElementsIn(requestedEventCodes);
   }
+
+  @Test
+  public void ambientContextManager_activityContextEnabled_differentInstancesQueryStatus() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      AmbientContextManager applicationAmbientContextManager =
+          RuntimeEnvironment.getApplication().getSystemService(AmbientContextManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      AmbientContextManager activityAmbientContextManager =
+          activity.getSystemService(AmbientContextManager.class);
+
+      assertThat(applicationAmbientContextManager)
+          .isNotSameInstanceAs(activityAmbientContextManager);
+
+      CountDownLatch latch = new CountDownLatch(2);
+      AtomicInteger applicationStatus = new AtomicInteger();
+      AtomicInteger activityStatus = new AtomicInteger();
+
+      Executor executor = Executors.newSingleThreadExecutor();
+
+      Set<Integer> eventTypes =
+          Set.of(AmbientContextEvent.EVENT_COUGH, AmbientContextEvent.EVENT_SNORE);
+
+      applicationAmbientContextManager.queryAmbientContextServiceStatus(
+          eventTypes,
+          executor,
+          status -> {
+            applicationStatus.set(status);
+            latch.countDown();
+          });
+
+      activityAmbientContextManager.queryAmbientContextServiceStatus(
+          eventTypes,
+          executor,
+          status -> {
+            activityStatus.set(status);
+            latch.countDown();
+          });
+
+      latch.await();
+
+      assertThat(applicationStatus.get()).isEqualTo(activityStatus.get());
+    } catch (Exception e) {
+      fail("Test failed due to exception: " + e.getMessage());
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationUtilsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationUtilsTest.java
deleted file mode 100644
index a429301d3..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAnimationUtilsTest.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.R;
-import android.app.Activity;
-import android.view.animation.AnimationUtils;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-
-@RunWith(AndroidJUnit4.class)
-public class ShadowAnimationUtilsTest {
-
-  @Test
-  public void loadAnimation_shouldCreateAnimation() {
-    assertThat(
-            AnimationUtils.loadAnimation(Robolectric.setupActivity(Activity.class), R.anim.fade_in))
-        .isNotNull();
-  }
-
-  @Test
-  public void loadLayoutAnimation_shouldCreateAnimation() {
-    assertThat(AnimationUtils.loadLayoutAnimation(Robolectric.setupActivity(Activity.class), 1))
-        .isNotNull();
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
index 5cb24b077..ce7c0dd98 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppOpsManagerTest.java
@@ -15,6 +15,7 @@ import static android.app.AppOpsManager.OP_FINE_LOCATION;
 import static android.app.AppOpsManager.OP_GPS;
 import static android.app.AppOpsManager.OP_SEND_SMS;
 import static android.app.AppOpsManager.OP_VIBRATE;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
@@ -27,6 +28,7 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowAppOpsManager.DURATION;
 import static org.robolectric.shadows.ShadowAppOpsManager.OP_TIME;
 
+import android.app.Activity;
 import android.app.AppOpsManager;
 import android.app.AppOpsManager.OnOpChangedListener;
 import android.app.AppOpsManager.OpEntry;
@@ -45,6 +47,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
+import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowAppOpsManager.ModeAndException;
 import org.robolectric.util.ReflectionHelpers;
@@ -755,4 +759,47 @@ public class ShadowAppOpsManagerTest {
     }
     return false;
   }
+
+  @Test
+  @Config(minSdk = R)
+  public void reset_clearsOnOpNotedCallback() {
+    AppOpsManager.OnOpNotedCallback callback = mock(AppOpsManager.OnOpNotedCallback.class);
+    appOps.setOnOpNotedCallback(directExecutor(), callback);
+    ShadowAppOpsManager.reset();
+    appOps.setOnOpNotedCallback(directExecutor(), callback); // should not throw an exception
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void appOpsManager_activityContextEnabled_differentInstancesRetrieveOps() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      // Get the AppOpsManager instances
+      AppOpsManager applicationAppOpsManager =
+          ApplicationProvider.getApplicationContext().getSystemService(AppOpsManager.class);
+      ShadowAppOpsManager shadowApplicationAppOpsManager =
+          Shadows.shadowOf(applicationAppOpsManager);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      AppOpsManager activityAppOpsManager = activity.getSystemService(AppOpsManager.class);
+      ShadowAppOpsManager shadowActivityAppOpsManager = Shadows.shadowOf(activityAppOpsManager);
+
+      int[] ops = {
+        AppOpsManager.OP_COARSE_LOCATION, AppOpsManager.OP_FINE_LOCATION, AppOpsManager.OP_CAMERA
+      };
+
+      List<PackageOps> applicationPackageOpsList =
+          shadowApplicationAppOpsManager.getPackagesForOps(ops);
+      List<PackageOps> activityPackageOpsList = shadowActivityAppOpsManager.getPackagesForOps(ops);
+
+      assertThat(activityPackageOpsList).isEqualTo(applicationPackageOpsList);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
index 10e11912c..3f62ecdeb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAppWidgetManagerTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.L;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Looper.getMainLooper;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -14,6 +15,7 @@ import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.PendingIntent;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetProvider;
@@ -40,6 +42,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -545,6 +548,31 @@ public class ShadowAppWidgetManagerTest {
     }
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void appWidgetManager_activityContextEnabled_sharedState() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      AppWidgetManager applicationAppWidgetManager =
+          context.getSystemService(AppWidgetManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      AppWidgetManager activityAppWidgetManager = activity.getSystemService(AppWidgetManager.class);
+
+      assertThat(applicationAppWidgetManager).isNotSameInstanceAs(activityAppWidgetManager);
+
+      applicationAppWidgetManager.updateAppWidgetOptions(1, null);
+
+      assertThat(activityAppWidgetManager.getAppWidgetOptions(1)).isNotNull();
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   public static class SpanishTestAppWidgetProvider extends AppWidgetProvider {
     @Override
     public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
index 1f80a7385..b00adbf0e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAssetManagerTest.java
@@ -20,8 +20,11 @@ import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class ShadowAssetManagerTest {
 
   @Rule public ExpectedException expectedException = ExpectedException.none();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
index 5b2bb532d..d59095ce0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioManagerTest.java
@@ -40,6 +40,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -173,6 +174,7 @@ public class ShadowAudioManagerTest {
         case AudioManager.STREAM_NOTIFICATION:
         case AudioManager.STREAM_RING:
         case AudioManager.STREAM_SYSTEM:
+        case AudioManager.STREAM_ASSISTANT:
         case AudioManager.STREAM_VOICE_CALL:
         case AudioManager.STREAM_ACCESSIBILITY:
           assertThat(audioManager.getStreamMaxVolume(stream))
@@ -247,6 +249,7 @@ public class ShadowAudioManagerTest {
               .isEqualTo(ShadowAudioManager.MAX_VOLUME_MUSIC_DTMF);
           break;
 
+        case AudioManager.STREAM_ASSISTANT:
         case AudioManager.STREAM_ALARM:
         case AudioManager.STREAM_NOTIFICATION:
         case AudioManager.STREAM_RING:
@@ -1592,6 +1595,136 @@ public class ShadowAudioManagerTest {
     }
   }
 
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_registerListener_getCalls() throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioDeviceInfo device = createAudioDevice(DEVICE_OUT_BLUETOOTH_SCO);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener);
+    shadowOf(audioManager).callOnCommunicationDeviceChangedListeners(device);
+
+    verify(mockListener).onCommunicationDeviceChanged(device);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_unregisterListener_noCalls() throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioDeviceInfo device = createAudioDevice(DEVICE_OUT_BLUETOOTH_SCO);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener);
+    audioManager.removeOnCommunicationDeviceChangedListener(mockListener);
+    shadowOf(audioManager).callOnCommunicationDeviceChangedListeners(device);
+
+    verifyNoMoreInteractions(mockListener);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_severalListener_allGetCalls() throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener1 =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioManager.OnCommunicationDeviceChangedListener mockListener2 =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioDeviceInfo device = createAudioDevice(DEVICE_OUT_BLUETOOTH_SCO);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener1);
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener2);
+    shadowOf(audioManager).callOnCommunicationDeviceChangedListeners(device);
+
+    verify(mockListener1).onCommunicationDeviceChanged(device);
+    verify(mockListener2).onCommunicationDeviceChanged(device);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void
+      onCommunicationDeviceChangedListener_oneOfSeveralListenerRemoved_onlyRegisterdGetCalls()
+          throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener1 =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioManager.OnCommunicationDeviceChangedListener mockListener2 =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+    AudioDeviceInfo device = createAudioDevice(DEVICE_OUT_BLUETOOTH_SCO);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener1);
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener2);
+    audioManager.removeOnCommunicationDeviceChangedListener(mockListener1);
+    shadowOf(audioManager).callOnCommunicationDeviceChangedListeners(device);
+
+    verifyNoMoreInteractions(mockListener1);
+    verify(mockListener2).onCommunicationDeviceChanged(device);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_callWithNullAudioDeviceInfo_receiveNull()
+      throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener);
+    shadowOf(audioManager).callOnCommunicationDeviceChangedListeners(null);
+
+    verify(mockListener).onCommunicationDeviceChanged(null);
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_removeBeforeAddingListener_throwsException()
+      throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+
+    Assert.assertThrows(
+        IllegalArgumentException.class,
+        () -> audioManager.removeOnCommunicationDeviceChangedListener(mockListener));
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_addSameTwice_throwsException() throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+
+    audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener);
+    Assert.assertThrows(
+        IllegalArgumentException.class,
+        () -> audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), mockListener));
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_addNullListener_throwsException()
+      throws Exception {
+    Assert.assertThrows(
+        NullPointerException.class,
+        () -> audioManager.addOnCommunicationDeviceChangedListener(directExecutor(), null));
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_addNullExecutor_throwsException()
+      throws Exception {
+    AudioManager.OnCommunicationDeviceChangedListener mockListener =
+        mock(AudioManager.OnCommunicationDeviceChangedListener.class);
+
+    Assert.assertThrows(
+        NullPointerException.class,
+        () -> audioManager.addOnCommunicationDeviceChangedListener(null, mockListener));
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void onCommunicationDeviceChangedListener_removeNull_throwsException() throws Exception {
+    Assert.assertThrows(
+        NullPointerException.class,
+        () -> audioManager.removeOnCommunicationDeviceChangedListener(null));
+  }
+
   private static AudioDeviceInfo createAudioDevice(int type) throws ReflectiveOperationException {
     AudioDeviceInfo info = Shadow.newInstanceOf(AudioDeviceInfo.class);
     Field portField = AudioDeviceInfo.class.getDeclaredField("mPort");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
index 841606630..7d2368f12 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAudioTrackTest.java
@@ -650,6 +650,32 @@ public class ShadowAudioTrackTest implements ShadowAudioTrack.OnAudioDataWritten
     assertThat(listenerCounter2.get()).isEqualTo(2);
   }
 
+  @Test
+  @Config(minSdk = N)
+  public void play_illegalStateOnPlayEnabled_throws() {
+    ShadowAudioTrack.enableIllegalStateOnPlay(/* enabled= */ true);
+    AudioTrack audioTrack = new AudioTrack.Builder().build();
+    assertThrows(IllegalStateException.class, audioTrack::play);
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void play_illegalStateOnPlayEnabled_thenDisabled_notThrowing() {
+    ShadowAudioTrack.enableIllegalStateOnPlay(/* enabled= */ true);
+    AudioTrack audioTrack = new AudioTrack.Builder().build();
+    ShadowAudioTrack.enableIllegalStateOnPlay(/* enabled= */ false);
+    audioTrack.play();
+  }
+
+  @Test
+  @Config(minSdk = N)
+  public void play_illegalStateOnPlayEnabled_reset_notThrowing() {
+    ShadowAudioTrack.enableIllegalStateOnPlay(/* enabled= */ true);
+    AudioTrack audioTrack = new AudioTrack.Builder().build();
+    ShadowAudioTrack.resetTest();
+    audioTrack.play();
+  }
+
   @Override
   @Config(minSdk = Q)
   public void onAudioDataWritten(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
index 419923b42..b946f6c2c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowAutofillManagerTest.java
@@ -3,8 +3,11 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
 import android.view.autofill.AutofillManager;
@@ -12,6 +15,7 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Unit test for {@link ShadowAutofillManager}. */
@@ -55,4 +59,31 @@ public class ShadowAutofillManagerTest {
     shadowOf(autofillManager).setEnabled(false);
     assertThat(autofillManager.isEnabled()).isFalse();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void autofillManager_activityContextEnabled_differentInstancesRetrieveSameInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      AutofillManager applicationAutofillManager = context.getSystemService(AutofillManager.class);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      AutofillManager activityAutofillManager = activity.getSystemService(AutofillManager.class);
+
+      assertNotSame(applicationAutofillManager, activityAutofillManager);
+
+      assertEquals(
+          applicationAutofillManager.isAutofillSupported(),
+          activityAutofillManager.isAutofillSupported());
+      assertEquals(applicationAutofillManager.isEnabled(), activityAutofillManager.isEnabled());
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
index c820cf9ba..45a4383c1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBatteryManagerTest.java
@@ -6,6 +6,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.BatteryManager;
 import androidx.test.core.app.ApplicationProvider;
@@ -13,13 +14,14 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowBatteryManagerTest {
+  private static final int TEST_ID = 123;
   private BatteryManager batteryManager;
   private ShadowBatteryManager shadowBatteryManager;
-  private static final int TEST_ID = 123;
 
   @Before
   public void before() {
@@ -92,4 +94,30 @@ public class ShadowBatteryManagerTest {
     assertThrows(
         IllegalArgumentException.class, () -> shadowBatteryManager.setChargeTimeRemaining(-100L));
   }
+
+  @Test
+  @Config(minSdk = P)
+  public void batteryManager_activityContextEnabled_sharedState() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      Context context = ApplicationProvider.getApplicationContext();
+      BatteryManager applicationBatteryManager = context.getSystemService(BatteryManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      BatteryManager activityBatteryManager = activity.getSystemService(BatteryManager.class);
+
+      assertThat(applicationBatteryManager).isNotSameInstanceAs(activityBatteryManager);
+
+      ShadowBatteryManager shadowApplicationBatteryManager = shadowOf(applicationBatteryManager);
+      shadowApplicationBatteryManager.setIsCharging(true);
+
+      assertThat(activityBatteryManager.isCharging()).isTrue();
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
index 801eb9db4..191166284 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBiometricManagerTest.java
@@ -9,12 +9,14 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.hardware.biometrics.BiometricManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -101,4 +103,30 @@ public class ShadowBiometricManagerTest {
 
     assertThat(biometricManager.canAuthenticate(authenticators)).isEqualTo(BIOMETRIC_SUCCESS);
   }
+
+  @Test
+  public void biometricManager_activityContextEnabled_differentInstancesRetrieveSameResult() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      BiometricManager applicationBiometricManager =
+          ApplicationProvider.getApplicationContext().getSystemService(BiometricManager.class);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      BiometricManager activityBiometricManager = activity.getSystemService(BiometricManager.class);
+
+      assertThat(applicationBiometricManager).isNotSameInstanceAs(activityBiometricManager);
+
+      int applicationCanAuthenticate = applicationBiometricManager.canAuthenticate();
+      int activityCanAuthenticate = activityBiometricManager.canAuthenticate();
+
+      assertThat(activityCanAuthenticate).isEqualTo(applicationCanAuthenticate);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
index 2bb381b58..2df0f1f9d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapDrawableTest.java
@@ -17,9 +17,13 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Shadows;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowBitmapDrawableTest {
   private final Resources resources = ApplicationProvider.getApplicationContext().getResources();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
index 7128bd769..18fce06c0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapFactoryTest.java
@@ -34,8 +34,11 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowBitmapFactoryTest {
   private static final int TEST_JPEG_WIDTH = 50;
   private static final int TEST_JPEG_HEIGHT = 50;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
index bd76ad8b9..d8c2629dc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBitmapTest.java
@@ -26,9 +26,12 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowBitmapTest {
   @Test
   public void shouldCreateScaledBitmap() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeBroadcastTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeBroadcastTest.java
new file mode 100644
index 000000000..ad8ec0dba
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothLeBroadcastTest.java
@@ -0,0 +1,295 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.bluetooth.BluetoothLeAudioContentMetadata;
+import android.bluetooth.BluetoothLeBroadcast;
+import android.bluetooth.BluetoothLeBroadcastSettings;
+import android.bluetooth.BluetoothLeBroadcastSubgroupSettings;
+import android.bluetooth.BluetoothStatusCodes;
+import android.os.Build.VERSION_CODES;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadow.api.Shadow;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE)
+public class ShadowBluetoothLeBroadcastTest {
+  private ShadowBluetoothLeBroadcast shadowBluetoothLeBroadcast;
+  private ExecutorService executors;
+  private CountDownLatch latch;
+
+  @Before
+  public void setUp() {
+    shadowBluetoothLeBroadcast = Shadow.extract(Shadow.newInstanceOf(BluetoothLeBroadcast.class));
+    executors = Executors.newSingleThreadExecutor();
+    latch = new CountDownLatch(1);
+  }
+
+  @Test
+  public void testRegisterCallback_success() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    assertThat(shadowBluetoothLeBroadcast.getCallbackExecutorMap()).containsKey(callback);
+  }
+
+  @Test
+  public void testRegisterCallback_nullPara() {
+    assertThrows(
+        NullPointerException.class, () -> shadowBluetoothLeBroadcast.registerCallback(null, null));
+    assertThrows(
+        NullPointerException.class,
+        () -> shadowBluetoothLeBroadcast.registerCallback(executors, null));
+    assertThrows(
+        NullPointerException.class,
+        () ->
+            shadowBluetoothLeBroadcast.registerCallback(
+                null, mock(BluetoothLeBroadcast.Callback.class)));
+  }
+
+  @Test
+  public void testUnregisterCallback_success() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    assertThat(shadowBluetoothLeBroadcast.getCallbackExecutorMap()).containsKey(callback);
+    shadowBluetoothLeBroadcast.unregisterCallback(callback);
+    assertThat(shadowBluetoothLeBroadcast.getCallbackExecutorMap()).isEmpty();
+  }
+
+  @Test
+  public void testUnregisterCallback_nullPara() {
+    assertThrows(
+        NullPointerException.class, () -> shadowBluetoothLeBroadcast.unregisterCallback(null));
+  }
+
+  @Test
+  public void testStartBroadcast_success() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+    BluetoothLeBroadcastSettings.Builder broadcastSettingsBuilder =
+        new BluetoothLeBroadcastSettings.Builder();
+    BluetoothLeAudioContentMetadata contentMetadata =
+        new BluetoothLeAudioContentMetadata.Builder()
+            .setProgramInfo("Test Program Info")
+            .setLanguage("deu")
+            .build();
+    BluetoothLeBroadcastSubgroupSettings.Builder builderSubgroup =
+        new BluetoothLeBroadcastSubgroupSettings.Builder()
+            .setPreferredQuality(0)
+            .setContentMetadata(contentMetadata);
+    BluetoothLeBroadcastSubgroupSettings[] subgroupSettings =
+        new BluetoothLeBroadcastSubgroupSettings[] {builderSubgroup.build()};
+    for (BluetoothLeBroadcastSubgroupSettings setting : subgroupSettings) {
+      broadcastSettingsBuilder.addSubgroupSettings(setting);
+    }
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastStarted(anyInt(), anyInt());
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.startBroadcast(broadcastSettingsBuilder.build());
+    waitForLatch(1);
+    verify(callback).onBroadcastStarted(BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST, 0);
+  }
+
+  @Test
+  public void testStartBroadcast_failure_nullSettings() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastStartFailed(anyInt());
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.startBroadcast(null);
+    waitForLatch(1);
+    verify(callback).onBroadcastStartFailed(BluetoothStatusCodes.ERROR_LE_BROADCAST_INVALID_CODE);
+  }
+
+  @Test
+  public void testStopBroadcast_success() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+    BluetoothLeBroadcastSettings.Builder broadcastSettingsBuilder =
+        new BluetoothLeBroadcastSettings.Builder();
+    BluetoothLeAudioContentMetadata contentMetadata =
+        new BluetoothLeAudioContentMetadata.Builder()
+            .setProgramInfo("Test Program Info")
+            .setLanguage("deu")
+            .build();
+    BluetoothLeBroadcastSubgroupSettings.Builder builderSubgroup =
+        new BluetoothLeBroadcastSubgroupSettings.Builder()
+            .setPreferredQuality(0)
+            .setContentMetadata(contentMetadata);
+    BluetoothLeBroadcastSubgroupSettings[] subgroupSettings =
+        new BluetoothLeBroadcastSubgroupSettings[] {builderSubgroup.build()};
+    for (BluetoothLeBroadcastSubgroupSettings setting : subgroupSettings) {
+      broadcastSettingsBuilder.addSubgroupSettings(setting);
+    }
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastStopped(anyInt(), anyInt());
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.startBroadcast(broadcastSettingsBuilder.build());
+
+    shadowBluetoothLeBroadcast.stopBroadcast(0);
+    waitForLatch(1);
+    verify(callback).onBroadcastStopped(BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST, 0);
+  }
+
+  @Test
+  public void testStopBroadcast_twice_secondCallFail() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+    BluetoothLeBroadcastSettings.Builder broadcastSettingsBuilder =
+        new BluetoothLeBroadcastSettings.Builder();
+    BluetoothLeAudioContentMetadata contentMetadata =
+        new BluetoothLeAudioContentMetadata.Builder()
+            .setProgramInfo("Test Program Info")
+            .setLanguage("deu")
+            .build();
+    BluetoothLeBroadcastSubgroupSettings.Builder builderSubgroup =
+        new BluetoothLeBroadcastSubgroupSettings.Builder()
+            .setPreferredQuality(0)
+            .setContentMetadata(contentMetadata);
+    BluetoothLeBroadcastSubgroupSettings[] subgroupSettings =
+        new BluetoothLeBroadcastSubgroupSettings[] {builderSubgroup.build()};
+    for (BluetoothLeBroadcastSubgroupSettings setting : subgroupSettings) {
+      broadcastSettingsBuilder.addSubgroupSettings(setting);
+    }
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastStopFailed(anyInt());
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.startBroadcast(broadcastSettingsBuilder.build());
+    shadowBluetoothLeBroadcast.stopBroadcast(0);
+
+    shadowBluetoothLeBroadcast.stopBroadcast(0);
+    waitForLatch(1);
+    verify(callback).onBroadcastStopFailed(anyInt());
+  }
+
+  @Test
+  public void testStopBroadcast_failure_noCallback() {
+    assertThrows(IllegalStateException.class, () -> shadowBluetoothLeBroadcast.stopBroadcast(0));
+  }
+
+  @Test
+  public void testUpdateBroadcast_nullSettings() {
+    assertThrows(
+        NullPointerException.class, () -> shadowBluetoothLeBroadcast.updateBroadcast(0, null));
+  }
+
+  @Test
+  public void testUpdateBroadcast_success() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+    BluetoothLeBroadcastSettings.Builder broadcastSettingsBuilder =
+        new BluetoothLeBroadcastSettings.Builder();
+    BluetoothLeAudioContentMetadata contentMetadata =
+        new BluetoothLeAudioContentMetadata.Builder()
+            .setProgramInfo("Test Program Info")
+            .setLanguage("deu")
+            .build();
+    BluetoothLeBroadcastSubgroupSettings.Builder builderSubgroup =
+        new BluetoothLeBroadcastSubgroupSettings.Builder()
+            .setPreferredQuality(0)
+            .setContentMetadata(contentMetadata);
+    BluetoothLeBroadcastSubgroupSettings[] subgroupSettings =
+        new BluetoothLeBroadcastSubgroupSettings[] {builderSubgroup.build()};
+    for (BluetoothLeBroadcastSubgroupSettings setting : subgroupSettings) {
+      broadcastSettingsBuilder.addSubgroupSettings(setting);
+    }
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastUpdated(anyInt(), anyInt());
+
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.startBroadcast(broadcastSettingsBuilder.build());
+    shadowBluetoothLeBroadcast.updateBroadcast(0, broadcastSettingsBuilder.build());
+
+    waitForLatch(1);
+    verify(callback).onBroadcastUpdated(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testUpdateBroadcast_fail() {
+    BluetoothLeBroadcast.Callback callback = mock(BluetoothLeBroadcast.Callback.class);
+    BluetoothLeBroadcastSettings.Builder broadcastSettingsBuilder =
+        new BluetoothLeBroadcastSettings.Builder();
+    BluetoothLeAudioContentMetadata contentMetadata =
+        new BluetoothLeAudioContentMetadata.Builder()
+            .setProgramInfo("Test Program Info")
+            .setLanguage("deu")
+            .build();
+    BluetoothLeBroadcastSubgroupSettings.Builder builderSubgroup =
+        new BluetoothLeBroadcastSubgroupSettings.Builder()
+            .setPreferredQuality(0)
+            .setContentMetadata(contentMetadata);
+    BluetoothLeBroadcastSubgroupSettings[] subgroupSettings =
+        new BluetoothLeBroadcastSubgroupSettings[] {builderSubgroup.build()};
+    for (BluetoothLeBroadcastSubgroupSettings setting : subgroupSettings) {
+      broadcastSettingsBuilder.addSubgroupSettings(setting);
+    }
+
+    doAnswer(
+            invocation -> {
+              latch.countDown();
+              return null;
+            })
+        .when(callback)
+        .onBroadcastUpdateFailed(anyInt(), anyInt());
+
+    shadowBluetoothLeBroadcast.registerCallback(executors, callback);
+    shadowBluetoothLeBroadcast.updateBroadcast(0, broadcastSettingsBuilder.build());
+
+    waitForLatch(1);
+    verify(callback).onBroadcastUpdateFailed(anyInt(), anyInt());
+  }
+
+  @Test
+  public void testGetCallbackExecutorMap_returnEmptyMap() {
+    assertThat(shadowBluetoothLeBroadcast.getCallbackExecutorMap()).isEmpty();
+  }
+
+  private void waitForLatch(int timeoutSeconds) {
+    try {
+      boolean completed = latch.await(timeoutSeconds, SECONDS);
+      assertThat(completed).isTrue();
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
index 4fb52e0e3..2fc4ee73d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBluetoothManagerTest.java
@@ -7,6 +7,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothGattServer;
@@ -14,6 +15,7 @@ import android.bluetooth.BluetoothGattServerCallback;
 import android.bluetooth.BluetoothManager;
 import android.bluetooth.BluetoothProfile;
 import android.content.Context;
+import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -21,6 +23,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
@@ -156,4 +159,32 @@ public class ShadowBluetoothManagerTest {
     assertThat(gattServer).isNotNull();
     assertThat(shadowOf(gattServer).getGattServerCallback()).isSameInstanceAs(callback);
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O)
+  public void bluetoothManager_activityContextEnabled_retrievesSameAdapter() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+
+    try {
+      BluetoothManager applicationBluetoothManager =
+          (BluetoothManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.BLUETOOTH_SERVICE);
+
+      BluetoothAdapter applicationAdapter = applicationBluetoothManager.getAdapter();
+      activity = Robolectric.setupActivity(Activity.class);
+      BluetoothManager activityBluetoothManager = activity.getSystemService(BluetoothManager.class);
+
+      BluetoothAdapter activityAdapter = activityBluetoothManager.getAdapter();
+
+      assertThat(applicationAdapter).isEqualTo(activityAdapter);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
index 62e25aba5..b5b7b09c2 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowBuildTest.java
@@ -157,6 +157,27 @@ public class ShadowBuildTest {
     assertThat(Build.SUPPORTED_ABIS).isEqualTo(new String[] {"x86"});
   }
 
+  @Test
+  @Config(minSdk = S)
+  public void systemOnChipManufacturer() {
+    ShadowBuild.setSystemOnChipManufacturer("manufacturer");
+    assertThat(Build.SOC_MANUFACTURER).isEqualTo("manufacturer");
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void systemOnChipModel() {
+    ShadowBuild.setSystemOnChipModel("model");
+    assertThat(Build.SOC_MODEL).isEqualTo("model");
+  }
+
+  @Test
+  @Config(minSdk = S)
+  public void odmSku() {
+    ShadowBuild.setOdmSku("odm_sku");
+    assertThat(Build.ODM_SKU).isEqualTo("odm_sku");
+  }
+
   /** Verifies that each test gets a fresh set of Build values. */
   private void checkValues() {
     assertThat(Build.FINGERPRINT).isEqualTo("robolectric");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
index a08e6b6b0..d4a2522aa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCameraManagerTest.java
@@ -8,6 +8,7 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.hardware.camera2.CameraAccessException;
 import android.hardware.camera2.CameraCharacteristics;
@@ -21,6 +22,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowCameraManager}. */
@@ -250,7 +252,7 @@ public class ShadowCameraManagerTest {
   public void resetter_closesCameras() throws Exception {
     shadowOf(cameraManager).addCamera(CAMERA_ID_0, characteristics);
     CameraDevice.StateCallback mockCallback = mock(CameraDevice.StateCallback.class);
-    cameraManager.openCamera(CAMERA_ID_0, mockCallback, new Handler());
+    cameraManager.openCamera(CAMERA_ID_0, mockCallback, new Handler(Looper.myLooper()));
     shadowOf(Looper.myLooper()).idle();
     ArgumentCaptor<CameraDevice> cameraDeviceCaptor = ArgumentCaptor.forClass(CameraDevice.class);
     verify(mockCallback).onOpened(cameraDeviceCaptor.capture());
@@ -406,4 +408,42 @@ public class ShadowCameraManagerTest {
 
     verify(mockCallback, never()).onTorchModeChanged(CAMERA_ID_0, torchEnabled);
   }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void cameraManager_activityContextEnabled_differentInstancesRetrieveCameraIdList()
+      throws Exception {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      CameraManager applicationCameraManager =
+          (CameraManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.CAMERA_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      CameraManager activityCameraManager =
+          (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);
+
+      assertThat(applicationCameraManager).isNotSameInstanceAs(activityCameraManager);
+
+      CameraCharacteristics characteristics =
+          ShadowCameraCharacteristics.newCameraCharacteristics();
+      shadowOf(applicationCameraManager).addCamera(CAMERA_ID_0, characteristics);
+      shadowOf(activityCameraManager).addCamera(CAMERA_ID_1, characteristics);
+
+      String[] applicationCameraIdList = applicationCameraManager.getCameraIdList();
+      String[] activityCameraIdList = activityCameraManager.getCameraIdList();
+
+      assertThat(activityCameraIdList.length).isEqualTo(2);
+      assertThat(activityCameraIdList[0]).isEqualTo(CAMERA_ID_0);
+      assertThat(activityCameraIdList[1]).isEqualTo(CAMERA_ID_1);
+
+      assertThat(activityCameraIdList).isEqualTo(applicationCameraIdList);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
index d4f95fa10..4ccb81aba 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCanvasTest.java
@@ -19,10 +19,13 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowCanvas.RoundRectPaintHistoryEvent;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowCanvasTest {
   private Bitmap targetBitmap;
   private Bitmap imageBitmap;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
index bb9e408fd..e8d34942d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCaptioningManagerTest.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.Looper;
 import android.provider.Settings;
@@ -21,6 +22,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
@@ -186,4 +188,39 @@ public final class ShadowCaptioningManagerTest {
     shadowOf(Looper.getMainLooper()).idle();
     assertThat(captioningChangeListener.systemAudioCaptioningUiEnabled).isEqualTo(false);
   }
+
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void captioningManager_activityContextEnabled_differentInstancesRetrieveValues() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      CaptioningManager applicationCaptioningManager =
+          (CaptioningManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.CAPTIONING_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      CaptioningManager activityCaptioningManager =
+          (CaptioningManager) activity.getSystemService(Context.CAPTIONING_SERVICE);
+
+      boolean applicationCaptioningEnabled =
+          applicationCaptioningManager.isSystemAudioCaptioningEnabled();
+      boolean activityCaptioningEnabled =
+          activityCaptioningManager.isSystemAudioCaptioningEnabled();
+
+      boolean applicationCaptioningUiEnabled =
+          applicationCaptioningManager.isSystemAudioCaptioningUiEnabled();
+      boolean activityCaptioningUiEnabled =
+          activityCaptioningManager.isSystemAudioCaptioningUiEnabled();
+
+      assertThat(applicationCaptioningEnabled).isEqualTo(activityCaptioningEnabled);
+      assertThat(applicationCaptioningUiEnabled).isEqualTo(activityCaptioningUiEnabled);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
index 5285bde71..a78289fad 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCardEmulationTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Activity;
 import android.app.Application;
@@ -15,6 +16,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Test the shadow implementation of {@link CardEmulation}. */
 @RunWith(AndroidJUnit4.class)
@@ -68,4 +72,24 @@ public final class ShadowCardEmulationTest {
     assertThat(cardEmulation.categoryAllowsForegroundPreference(CardEmulation.CATEGORY_PAYMENT))
         .isFalse();
   }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void getShouldDefaultToObserveModeForService_shouldReturnDefaultToObserveMode() {
+    final CardEmulationVReflector cardEmulationVReflector =
+        reflector(CardEmulationVReflector.class, cardEmulation);
+    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isFalse();
+
+    cardEmulationVReflector.setShouldDefaultToObserveModeForService(service, true);
+    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isTrue();
+
+    cardEmulationVReflector.setShouldDefaultToObserveModeForService(service, false);
+    assertThat(ShadowCardEmulation.getShouldDefaultToObserveModeForService(service)).isFalse();
+  }
+
+  // TODO: delete when this test compiles against V sdk
+  @ForType(CardEmulation.class)
+  interface CardEmulationVReflector {
+    boolean setShouldDefaultToObserveModeForService(ComponentName component, boolean enable);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
index 416bb6200..a60ed5212 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCarrierConfigManagerTest.java
@@ -1,18 +1,23 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
+import android.os.Parcel;
 import android.os.PersistableBundle;
 import android.telephony.CarrierConfigManager;
+import android.telephony.SubscriptionManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Junit test for {@link ShadowCarrierConfigManager}. */
@@ -153,4 +158,49 @@ public class ShadowCarrierConfigManagerTest {
     assertThat(verifyBundle.getInt(INT_KEY)).isEqualTo(INT_VALUE);
     assertThat(verifyBundle.getBoolean(BOOLEAN_KEY)).isEqualTo(BOOLEAN_VALUE);
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void carrierConfigManager_activityContextEnabled_retrievesSameConfigs() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      CarrierConfigManager applicationCarrierConfigManager =
+          (CarrierConfigManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      CarrierConfigManager activityCarrierConfigManager =
+          (CarrierConfigManager) activity.getSystemService(Context.CARRIER_CONFIG_SERVICE);
+
+      assertThat(applicationCarrierConfigManager).isNotSameInstanceAs(activityCarrierConfigManager);
+
+      int subId = SubscriptionManager.getDefaultSubscriptionId();
+
+      PersistableBundle applicationConfigs =
+          applicationCarrierConfigManager.getConfigForSubId(subId);
+      PersistableBundle activityConfigs = activityCarrierConfigManager.getConfigForSubId(subId);
+
+      Parcel applicationParcel = Parcel.obtain();
+      Parcel activityParcel = Parcel.obtain();
+
+      applicationConfigs.writeToParcel(applicationParcel, 0);
+      activityConfigs.writeToParcel(activityParcel, 0);
+
+      byte[] applicationBytes = applicationParcel.marshall();
+      byte[] activityBytes = activityParcel.marshall();
+
+      assertThat(activityBytes).isEqualTo(applicationBytes);
+
+      applicationParcel.recycle();
+      activityParcel.recycle();
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
index ff359a00e..f793b5139 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowChoreographerTest.java
@@ -53,7 +53,7 @@ public class ShadowChoreographerTest {
     ShadowChoreographer.setPaused(true);
     ShadowChoreographer.setFrameDelay(Duration.ofMillis(15));
     long startTime = ShadowSystem.nanoTime();
-    AtomicLong frameTimeNanos = new AtomicLong();
+    AtomicLong frameTimeNanos = new AtomicLong(-1);
 
     Choreographer.getInstance().postFrameCallback(frameTimeNanos::set);
     ShadowSystemClock.advanceBy(Duration.ofMillis(15));
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
index f081b4b74..c9b5be115 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowClipboardManagerTest.java
@@ -18,7 +18,9 @@ import java.time.Duration;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowClipboardManagerTest {
@@ -153,4 +155,34 @@ public class ShadowClipboardManagerTest {
     assertThat(clipboardManager.getPrimaryClipDescription().getTimestamp())
         .isEqualTo(currentUptimeMs + 42 * 1000);
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void clipboardManager_instance_retrievesSamePrimaryClip() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    TestActivity activity = null;
+    try {
+      ClipboardManager applicationClipboardManager =
+          (ClipboardManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.CLIPBOARD_SERVICE);
+      ClipData clipData = ClipData.newPlainText("label", "text");
+      applicationClipboardManager.setPrimaryClip(clipData);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      ClipboardManager activityClipboardManager =
+          (ClipboardManager) activity.getSystemService(Context.CLIPBOARD_SERVICE);
+
+      ClipData applicationClipData = applicationClipboardManager.getPrimaryClip();
+      ClipData activityClipData = activityClipboardManager.getPrimaryClip();
+
+      assertThat(activityClipData.toString()).isEqualTo(applicationClipData.toString());
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
index a39023624..305a33f39 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowColorDisplayManagerTest.java
@@ -4,18 +4,23 @@ import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.shadow.api.Shadow.extract;
 
+import android.app.Activity;
 import android.hardware.display.ColorDisplayManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Optional;
 import org.junit.Before;
+import org.junit.FixMethodOrder;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Tests for ShadowColorDisplayManager. */
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = Q)
+@FixMethodOrder(MethodSorters.NAME_ASCENDING) // getAppSaturationLevel_afterReset* depends on order
 public class ShadowColorDisplayManagerTest {
 
   private static final String PACKAGE_NAME = "test_package_name";
@@ -134,7 +139,49 @@ public class ShadowColorDisplayManagerTest {
     assertThat(getShadowColorDisplayManager().getTransformCapabilities()).isEqualTo(0x0);
   }
 
+  @Test
+  public void getAppSaturationLevel_afterReset_shouldBeDefault1() {
+    instance.get().setAppSaturationLevel(PACKAGE_NAME, 50);
+    assertThat(getShadowColorDisplayManager().getAppSaturationLevel(PACKAGE_NAME)).isEqualTo(50);
+  }
+
+  @Test
+  public void getAppSaturationLevel_afterReset_shouldBeDefault2() {
+    // A reset should have occurred
+    assertThat(getShadowColorDisplayManager().getAppSaturationLevel(PACKAGE_NAME)).isEqualTo(100);
+  }
+
   private ShadowColorDisplayManager getShadowColorDisplayManager() {
-    return (ShadowColorDisplayManager) extract(instance.get());
+    return extract(instance.get());
+  }
+
+  @Test
+  public void colorDisplayManager_activityContextEnabled_differentInstancesRetrieveSettings() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      ColorDisplayManager appColorDisplayManager =
+          ApplicationProvider.getApplicationContext().getSystemService(ColorDisplayManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      ColorDisplayManager activityColorDisplayManager =
+          activity.getSystemService(ColorDisplayManager.class);
+
+      assertThat(appColorDisplayManager).isNotSameInstanceAs(activityColorDisplayManager);
+
+      boolean appNightDisplayActivated =
+          ((ShadowColorDisplayManager) extract(appColorDisplayManager)).isNightDisplayActivated();
+      boolean activityNightDisplayActivated =
+          ((ShadowColorDisplayManager) extract(activityColorDisplayManager))
+              .isNightDisplayActivated();
+
+      assertThat(activityNightDisplayActivated).isEqualTo(appNightDisplayActivated);
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
index 2553aebb3..2f9b24b8c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowConnectivityManagerTest.java
@@ -16,6 +16,7 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
@@ -26,6 +27,8 @@ import android.net.NetworkCapabilities;
 import android.net.NetworkInfo;
 import android.net.NetworkRequest;
 import android.net.ProxyInfo;
+import android.os.Build;
+import android.os.Build.VERSION_CODES;
 import android.os.Handler;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
@@ -35,7 +38,10 @@ import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 import org.robolectric.util.ReflectionHelpers;
 
 @RunWith(AndroidJUnit4.class)
@@ -725,6 +731,34 @@ public class ShadowConnectivityManagerTest {
     assertThat(connectivityManager.getDefaultProxy()).isNull();
   }
 
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void connectivityManager_instanceBasedOnSdkVersion() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      activity = Robolectric.setupActivity(TestActivity.class);
+      ConnectivityManager activityConnectivityManager =
+          (ConnectivityManager) activity.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+      if (Build.VERSION.SDK_INT >= S) {
+        assertThat(connectivityManager).isNotSameInstanceAs(activityConnectivityManager);
+      } else {
+        assertThat(connectivityManager).isSameInstanceAs(activityConnectivityManager);
+      }
+      Network applicationActiveNetwork = connectivityManager.getActiveNetwork();
+      Network activityActiveNetwork = activityConnectivityManager.getActiveNetwork();
+
+      assertThat(activityActiveNetwork).isEqualTo(applicationActiveNetwork);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   @Test
   public void setDefaultNetworkActive_isActiveTrue_triggersOnAvailableInCallbacks() {
     NetworkRequest.Builder builder = new NetworkRequest.Builder();
@@ -794,4 +828,22 @@ public class ShadowConnectivityManagerTest {
     verify(callback1, never()).onAvailable(shadowConnectivityManager.getActiveNetwork());
     verify(callback2, never()).onAvailable(shadowConnectivityManager.getActiveNetwork());
   }
+
+  @Test
+  public void defaults_afterReset() {
+    ShadowConnectivityManager.reset();
+    assertThat(connectivityManager.getAllNetworkInfo()).hasLength(2);
+    assertThat(connectivityManager.getAllNetworks()).hasLength(2);
+    assertThat(connectivityManager.isDefaultNetworkActive()).isTrue();
+    if (RuntimeEnvironment.getApiLevel() >= M) {
+      assertThat(connectivityManager.getActiveNetwork()).isNotNull();
+    }
+  }
+
+  @Config(minSdk = M)
+  @Test
+  public void getActiveNetwork_afterSetActiveNetworkInfoNull() {
+    shadowOf(connectivityManager).setActiveNetworkInfo(null);
+    assertThat(connectivityManager.getActiveNetwork()).isNull();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
index f8371cbab..6f0f5f77e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContentResolverTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.content.ContentResolver.QUERY_ARG_SQL_SELECTION;
 import static android.content.ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS;
 import static android.content.ContentResolver.QUERY_ARG_SQL_SORT_ORDER;
+import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
 import static com.google.common.truth.Truth.assertThat;
@@ -692,6 +693,29 @@ public class ShadowContentResolverTest {
     assertThat(uri.observer).isNull();
   }
 
+  @Test
+  @Config(minSdk = N)
+  public void notifyChangeWithFlags_shouldTrackNotifiedUris() {
+    contentResolver.notifyChange(Uri.parse("foo"), null, ContentResolver.NOTIFY_SYNC_TO_NETWORK);
+    contentResolver.notifyChange(Uri.parse("bar"), null, ContentResolver.NOTIFY_UPDATE);
+
+    assertThat(shadowContentResolver.getNotifiedUris().size()).isEqualTo(2);
+
+    ShadowContentResolver.NotifiedUri uri = shadowContentResolver.getNotifiedUris().get(0);
+
+    assertThat(uri.uri.toString()).isEqualTo("foo");
+    assertThat(uri.syncToNetwork).isTrue();
+    assertThat(uri.observer).isNull();
+    assertThat(uri.flags).isEqualTo(ContentResolver.NOTIFY_SYNC_TO_NETWORK);
+
+    uri = shadowContentResolver.getNotifiedUris().get(1);
+
+    assertThat(uri.uri.toString()).isEqualTo("bar");
+    assertThat(uri.syncToNetwork).isFalse();
+    assertThat(uri.observer).isNull();
+    assertThat(uri.flags).isEqualTo(ContentResolver.NOTIFY_UPDATE);
+  }
+
   @SuppressWarnings("serial")
   @Test
   public void applyBatchForRegisteredProvider()
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
index caca2bd8d..70ac9d737 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextHubManagerTest.java
@@ -9,6 +9,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
+import android.app.Activity;
 import android.content.Context;
 import android.hardware.location.ContextHubClient;
 import android.hardware.location.ContextHubClientCallback;
@@ -25,6 +26,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -165,6 +167,38 @@ public class ShadowContextHubManagerTest {
     assertThat(info).isNull();
   }
 
+  @Test
+  @Config(minSdk = 30)
+  public void contextHubManager_instance_retrievesSameContextHubInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+
+    try {
+      ContextHubManager applicationContextHubManager =
+          context.getSystemService(ContextHubManager.class);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      ContextHubManager activityContextHubManager =
+          activity.getSystemService(ContextHubManager.class);
+
+      assertThat(applicationContextHubManager).isNotSameInstanceAs(activityContextHubManager);
+
+      List<ContextHubInfo> applicationContextHubs = applicationContextHubManager.getContextHubs();
+      List<ContextHubInfo> activityContextHubs = activityContextHubManager.getContextHubs();
+
+      assertThat(applicationContextHubs).isNotEmpty();
+      assertThat(activityContextHubs).isNotEmpty();
+
+      assertThat(activityContextHubs).isEqualTo(applicationContextHubs);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   @Test
   @Config(minSdk = Build.VERSION_CODES.P)
   public void broadcastsFromContextHub_notifiesClient() {
@@ -237,4 +271,25 @@ public class ShadowContextHubManagerTest {
     verify(callback, never()).onNanoAppEnabled(any(), anyLong());
     verify(callback, never()).onNanoAppDisabled(any(), anyLong());
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.S)
+  public void checkNanoAppLoadedState() {
+    ContextHubManager contextHubManager = context.getSystemService(ContextHubManager.class);
+    ContextHubClientCallback callback = mock(ContextHubClientCallback.class);
+    contextHubManager.createClient(null, callback);
+    List<ContextHubInfo> contextHubInfoList = contextHubManager.getContextHubs();
+
+    ShadowContextHubManager shadowManager = Shadow.extract(contextHubManager);
+    shadowManager.broadcastClientAuthorizationChanged(1, 2);
+
+    long nanoAppId = 5;
+    int nanoAppVersion = 1;
+    shadowManager.addNanoApp(
+        contextHubInfoList.get(0), /* nanoAppUid= */ 0, nanoAppId, nanoAppVersion);
+    assertThat(shadowManager.nanoAppIsLoaded(nanoAppId)).isTrue();
+
+    shadowManager.unloadNanoApp(contextHubInfoList.get(0), nanoAppId);
+    assertThat(shadowManager.nanoAppIsLoaded(nanoAppId)).isFalse();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
index 5ef5e86fe..688d50acd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextTest.java
@@ -23,6 +23,8 @@ import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 /** Tests of the {@link ShadowContextImpl} class */
 @RunWith(AndroidJUnit4.class)
@@ -270,6 +272,7 @@ public class ShadowContextTest {
   }
 
   @Test
+  @ResourcesMode(Mode.BINARY)
   public void obtainStyledAttributes_shouldExtractAttributesFromAttributeSet() {
     AttributeSet roboAttributeSet =
         Robolectric.buildAttributeSet()
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
index d0caf82d3..fb7ded1fd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowContextWrapperTest.java
@@ -11,7 +11,6 @@ import static org.junit.Assert.assertTrue;
 import static org.robolectric.Robolectric.buildActivity;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
 import android.app.Activity;
@@ -242,7 +241,6 @@ public class ShadowContextWrapperTest {
   }
 
   @Test
-  @LooperMode(PAUSED)
   public void sendBroadcast_shouldSendIntentUsingHandlerIfOneIsProvided()
       throws InterruptedException {
     HandlerThread handlerThread = new HandlerThread("test");
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
index 6507e5bca..59011e083 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowCrossProfileAppsTest.java
@@ -26,11 +26,13 @@ import android.os.Process;
 import android.os.UserHandle;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.Shadows;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -685,4 +687,35 @@ public class ShadowCrossProfileAppsTest {
     }
     fail("did not throw " + clazz.getName());
   }
+
+  @Test
+  public void
+      crossProfileApps_activityContextEnabled_differentInstancesRetrieveTargetUserProfiles() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      CrossProfileApps applicationCrossProfileApps =
+          (CrossProfileApps)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      CrossProfileApps activityCrossProfileApps =
+          (CrossProfileApps) activity.getSystemService(Context.CROSS_PROFILE_APPS_SERVICE);
+
+      assertThat(applicationCrossProfileApps).isNotSameInstanceAs(activityCrossProfileApps);
+
+      List<UserHandle> applicationTargetUserProfiles =
+          applicationCrossProfileApps.getTargetUserProfiles();
+      List<UserHandle> activityTargetUserProfiles =
+          activityCrossProfileApps.getTargetUserProfiles();
+
+      assertThat(activityTargetUserProfiles).isEqualTo(applicationTargetUserProfiles);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
index fea652f74..4d9e156a5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDevicePolicyManagerTest.java
@@ -34,9 +34,12 @@ import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.accounts.Account;
+import android.app.Activity;
 import android.app.Application;
 import android.app.KeyguardManager;
+import android.app.admin.DeviceAdminReceiver;
 import android.app.admin.DevicePolicyManager;
+import android.app.admin.SystemUpdateInfo;
 import android.app.admin.SystemUpdatePolicy;
 import android.content.ComponentName;
 import android.content.Context;
@@ -65,6 +68,7 @@ import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -98,7 +102,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isDeviceOwnerAppShouldReturnFalseForNonDeviceOwnerApp() {
-    // GIVEN an test package which is not the device owner app of the device
+    // GIVEN a test package which is not the device owner app of the device
     String testPackage = testComponent.getPackageName();
 
     // WHEN DevicePolicyManager#isDeviceOwnerApp is called with it
@@ -108,7 +112,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isDeviceOwnerShouldReturnFalseForProfileOwner() {
-    // GIVEN an test package which is the profile owner app of the device
+    // GIVEN a test package which is the profile owner app of the device
     String testPackage = testComponent.getPackageName();
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
 
@@ -119,7 +123,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isDeviceOwnerShouldReturnTrueForDeviceOwner() {
-    // GIVEN an test package which is the device owner app of the device
+    // GIVEN a test package which is the device owner app of the device
     String testPackage = testComponent.getPackageName();
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
@@ -130,7 +134,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void getDeviceOwnerShouldReturnDeviceOwnerPackageName() {
-    // GIVEN an test package which is the device owner app of the device
+    // GIVEN a test package which is the device owner app of the device
     String testPackage = testComponent.getPackageName();
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
@@ -167,7 +171,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isProfileOwnerAppShouldReturnFalseForNonProfileOwnerApp() {
-    // GIVEN an test package which is not the profile owner app of the device
+    // GIVEN a test package which is not the profile owner app of the device
     String testPackage = testComponent.getPackageName();
 
     // WHEN DevicePolicyManager#isProfileOwnerApp is called with it
@@ -177,7 +181,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isProfileOwnerShouldReturnFalseForDeviceOwner() {
-    // GIVEN an test package which is the device owner app of the device
+    // GIVEN a test package which is the device owner app of the device
     String testPackage = testComponent.getPackageName();
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
@@ -188,7 +192,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void isProfileOwnerShouldReturnTrueForProfileOwner() {
-    // GIVEN an test package which is the profile owner app of the device
+    // GIVEN a test package which is the profile owner app of the device
     String testPackage = testComponent.getPackageName();
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
 
@@ -199,7 +203,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void getProfileOwnerShouldReturnDeviceOwnerComponentName() {
-    // GIVEN an test package which is the profile owner app of the device
+    // GIVEN a test package which is the profile owner app of the device
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
 
     // WHEN DevicePolicyManager#getProfileOwner is called
@@ -281,7 +285,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void getActiveAdminsShouldReturnDeviceOwner() {
-    // GIVEN an test package which is the device owner app of the device
+    // GIVEN a test package which is the device owner app of the device
     shadowOf(devicePolicyManager).setDeviceOwner(testComponent);
 
     // WHEN DevicePolicyManager#getActiveAdmins is called
@@ -291,7 +295,7 @@ public final class ShadowDevicePolicyManagerTest {
 
   @Test
   public void getActiveAdminsShouldReturnProfileOwner() {
-    // GIVEN an test package which is the profile owner app of the device
+    // GIVEN a test package which is the profile owner app of the device
     shadowOf(devicePolicyManager).setProfileOwner(testComponent);
 
     // WHEN DevicePolicyManager#getActiveAdmins is called
@@ -2729,4 +2733,85 @@ public final class ShadowDevicePolicyManagerTest {
       public void onServiceDisconnected(ComponentName name) {}
     };
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void devicePolicyManager_instance_retrievesSameAdminStatus() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      DevicePolicyManager applicationDpm =
+          (DevicePolicyManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.DEVICE_POLICY_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+
+      DevicePolicyManager activityDpm =
+          (DevicePolicyManager) activity.getSystemService(Context.DEVICE_POLICY_SERVICE);
+
+      ComponentName testAdminComponent =
+          new ComponentName(ApplicationProvider.getApplicationContext(), DeviceAdminReceiver.class);
+
+      boolean applicationAdminActive = applicationDpm.isAdminActive(testAdminComponent);
+      boolean activityAdminActive = activityDpm.isAdminActive(testAdminComponent);
+
+      assertThat(activityAdminActive).isEqualTo(applicationAdminActive);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void notifyPendingSystemUpdate_unknownSecurityStatus_setsPendingSystemUpdate() {
+    long updateTime = 123456L;
+
+    devicePolicyManager.notifyPendingSystemUpdate(updateTime);
+
+    SystemUpdateInfo systemUpdateInfo = devicePolicyManager.getPendingSystemUpdate(null);
+    assertThat(systemUpdateInfo.getReceivedTime()).isEqualTo(updateTime);
+    assertThat(systemUpdateInfo.getSecurityPatchState())
+        .isEqualTo(SystemUpdateInfo.SECURITY_PATCH_STATE_UNKNOWN);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void notifyPendingSystemUpdate_securityPatch_setsPendingSystemUpdate() {
+    long updateTime = 123456L;
+
+    devicePolicyManager.notifyPendingSystemUpdate(updateTime, /* isSecurityPatch= */ true);
+
+    SystemUpdateInfo systemUpdateInfo = devicePolicyManager.getPendingSystemUpdate(null);
+    assertThat(systemUpdateInfo.getReceivedTime()).isEqualTo(updateTime);
+    assertThat(systemUpdateInfo.getSecurityPatchState())
+        .isEqualTo(SystemUpdateInfo.SECURITY_PATCH_STATE_TRUE);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void notifyPendingSystemUpdate_notSecurityPatch_setsPendingSystemUpdate() {
+    long updateTime = 123456L;
+
+    devicePolicyManager.notifyPendingSystemUpdate(updateTime, /* isSecurityPatch= */ false);
+
+    SystemUpdateInfo systemUpdateInfo = devicePolicyManager.getPendingSystemUpdate(null);
+    assertThat(systemUpdateInfo.getReceivedTime()).isEqualTo(updateTime);
+    assertThat(systemUpdateInfo.getSecurityPatchState())
+        .isEqualTo(SystemUpdateInfo.SECURITY_PATCH_STATE_FALSE);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void setPendingSystemUpdate_null_clearsPendingSystemUpdate() {
+    devicePolicyManager.notifyPendingSystemUpdate(123456L);
+
+    shadowOf(devicePolicyManager).setPendingSystemUpdate(null);
+
+    assertThat(devicePolicyManager.getPendingSystemUpdate(null)).isNull();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java
index d8383d0c4..d6e54d3e0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDisplayManagerGlobalTest.java
@@ -1,11 +1,17 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.S;
+import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
+import android.annotation.RequiresApi;
 import android.content.Context;
 import android.graphics.Rect;
 import android.graphics.SurfaceTexture;
@@ -23,6 +29,7 @@ import android.view.Surface;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.concurrent.Executor;
+import javax.annotation.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RuntimeEnvironment;
@@ -49,7 +56,7 @@ public class ShadowDisplayManagerGlobalTest {
   }
 
   @Test
-  @Config(minSdk = TIRAMISU)
+  @Config(minSdk = P)
   public void testVirtualDisplay_create() {
     Surface surface = new Surface(new SurfaceTexture(0));
     VirtualDisplay virtualDisplay = createVirtualDisplay(surface);
@@ -71,7 +78,7 @@ public class ShadowDisplayManagerGlobalTest {
   }
 
   @Test
-  @Config(minSdk = TIRAMISU)
+  @Config(minSdk = P)
   public void testVirtualDisplay_resize() {
     VirtualDisplay virtualDisplay = createVirtualDisplay(null);
 
@@ -88,7 +95,7 @@ public class ShadowDisplayManagerGlobalTest {
   }
 
   @Test
-  @Config(minSdk = TIRAMISU)
+  @Config(minSdk = P)
   public void testVirtualDisplay_release() {
     VirtualDisplay virtualDisplay = createVirtualDisplay(null);
     int displayId = virtualDisplay.getDisplay().getDisplayId();
@@ -98,7 +105,7 @@ public class ShadowDisplayManagerGlobalTest {
   }
 
   @Test
-  @Config(minSdk = TIRAMISU)
+  @Config(minSdk = Q)
   public void testVirtualDisplay_setSurfaceTogglesState() {
     Surface surface = new Surface(new SurfaceTexture(0));
     VirtualDisplay virtualDisplay = createVirtualDisplay(surface);
@@ -117,19 +124,48 @@ public class ShadowDisplayManagerGlobalTest {
     verify(listener).onDisplayChanged(virtualDisplay.getDisplay().getDisplayId());
   }
 
-  private VirtualDisplay createVirtualDisplay(Surface surface) {
-    VirtualDisplayConfig config =
-        new VirtualDisplayConfig.Builder("name", DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_DPI)
-            .setSurface(surface)
-            .setFlags(123)
-            .build();
-    if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
+  private VirtualDisplay createVirtualDisplay(@Nullable Surface surface) {
+    if (RuntimeEnvironment.getApiLevel() <= Q) {
       return ReflectionHelpers.callInstanceMethod(
           DisplayManagerGlobal.getInstance(),
           "createVirtualDisplay",
           ClassParameter.from(Context.class, getApplicationContext()),
           ClassParameter.from(MediaProjection.class, null),
-          ClassParameter.from(VirtualDisplayConfig.class, config),
+          ClassParameter.from(String.class, "name"),
+          ClassParameter.from(int.class, DISPLAY_WIDTH),
+          ClassParameter.from(int.class, DISPLAY_HEIGHT),
+          ClassParameter.from(int.class, DISPLAY_DPI),
+          ClassParameter.from(Surface.class, surface),
+          ClassParameter.from(int.class, 123),
+          ClassParameter.from(VirtualDisplay.Callback.class, mock(VirtualDisplay.Callback.class)),
+          ClassParameter.from(Handler.class, Handler.getMain()),
+          ClassParameter.from(String.class, "123"));
+    } else if (RuntimeEnvironment.getApiLevel() <= S) {
+      return ReflectionHelpers.callInstanceMethod(
+          DisplayManagerGlobal.getInstance(),
+          "createVirtualDisplay",
+          ClassParameter.from(Context.class, getApplicationContext()),
+          ClassParameter.from(MediaProjection.class, null),
+          ClassParameter.from(VirtualDisplayConfig.class, createConfig(surface)),
+          ClassParameter.from(VirtualDisplay.Callback.class, mock(VirtualDisplay.Callback.class)),
+          ClassParameter.from(Handler.class, Handler.getMain()));
+    } else if (RuntimeEnvironment.getApiLevel() <= S_V2) {
+      return ReflectionHelpers.callInstanceMethod(
+          DisplayManagerGlobal.getInstance(),
+          "createVirtualDisplay",
+          ClassParameter.from(Context.class, getApplicationContext()),
+          ClassParameter.from(MediaProjection.class, null),
+          ClassParameter.from(VirtualDisplayConfig.class, createConfig(surface)),
+          ClassParameter.from(VirtualDisplay.Callback.class, mock(VirtualDisplay.Callback.class)),
+          ClassParameter.from(Handler.class, Handler.getMain()),
+          ClassParameter.from(Context.class, getApplicationContext()));
+    } else if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
+      return ReflectionHelpers.callInstanceMethod(
+          DisplayManagerGlobal.getInstance(),
+          "createVirtualDisplay",
+          ClassParameter.from(Context.class, getApplicationContext()),
+          ClassParameter.from(MediaProjection.class, null),
+          ClassParameter.from(VirtualDisplayConfig.class, createConfig(surface)),
           ClassParameter.from(VirtualDisplay.Callback.class, mock(VirtualDisplay.Callback.class)),
           ClassParameter.from(Executor.class, MoreExecutors.directExecutor()),
           ClassParameter.from(Context.class, getApplicationContext()));
@@ -138,9 +174,17 @@ public class ShadowDisplayManagerGlobalTest {
           .createVirtualDisplay(
               getApplicationContext(),
               null,
-              config,
+              createConfig(surface),
               mock(VirtualDisplay.Callback.class),
               MoreExecutors.directExecutor());
     }
   }
+
+  @RequiresApi(R)
+  private static VirtualDisplayConfig createConfig(@Nullable Surface surface) {
+    return new VirtualDisplayConfig.Builder("name", DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_DPI)
+        .setSurface(surface)
+        .setFlags(123)
+        .build();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
index dd0be08e6..938891f4e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDownloadManagerTest.java
@@ -6,18 +6,24 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.DownloadManager;
+import android.content.Context;
 import android.database.Cursor;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Environment;
 import android.util.Pair;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowDownloadManager.CompletedDownload;
 import org.robolectric.shadows.ShadowDownloadManager.ShadowRequest;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowDownloadManagerTest {
@@ -412,4 +418,34 @@ public class ShadowDownloadManagerTest {
 
     assertThat(manager.getCompletedDownloadsCount()).isEqualTo(0);
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O)
+  public void downloadManager_activityContextEnabled_retrievesSameMimeTypeForDownloadedFile() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      DownloadManager applicationDownloadManager =
+          (DownloadManager)
+              RuntimeEnvironment.getApplication().getSystemService(Context.DOWNLOAD_SERVICE);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      DownloadManager activityDownloadManager =
+          (DownloadManager) activity.getSystemService(Context.DOWNLOAD_SERVICE);
+
+      assertThat(applicationDownloadManager).isNotSameInstanceAs(activityDownloadManager);
+
+      final long testId = 1L;
+      String applicationMimeType = applicationDownloadManager.getMimeTypeForDownloadedFile(testId);
+      String activityMimeType = activityDownloadManager.getMimeTypeForDownloadedFile(testId);
+
+      assertThat(activityMimeType).isEqualTo(applicationMimeType);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
index d51bc8059..61784b4c7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowDropBoxManagerTest.java
@@ -1,9 +1,11 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.DropBoxManager;
 import android.os.DropBoxManager.Entry;
@@ -15,6 +17,8 @@ import java.io.InputStreamReader;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 /** Unit tests for {@see ShadowDropboxManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -86,11 +90,11 @@ public class ShadowDropBoxManagerTest {
     assertThat(entry.getTimeMillis()).isEqualTo(3);
   }
 
-  @Test()
+  @Test
   public void resetClearsData() {
     shadowDropBoxManager.addData(TAG, 1, DATA);
 
-    shadowDropBoxManager.reset();
+    ShadowDropBoxManager.reset();
 
     assertThat(manager.getNextEntry(null, 0)).isNull();
   }
@@ -115,4 +119,35 @@ public class ShadowDropBoxManagerTest {
     assertThat(manager.getNextEntry(null, baseTimestamp + 99)).isNotNull();
     assertThat(manager.getNextEntry(null, baseTimestamp + 100)).isNull();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void dropBoxManager_activityContextEnabled_differentInstancesVerifyTagEnabled() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      DropBoxManager applicationDropBoxManager =
+          (DropBoxManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.DROPBOX_SERVICE);
+
+      String tag = "testTag";
+      String data = "testData";
+      applicationDropBoxManager.addText(tag, data);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      DropBoxManager activityDropBoxManager =
+          (DropBoxManager) activity.getSystemService(Context.DROPBOX_SERVICE);
+
+      boolean applicationTagEnabled = applicationDropBoxManager.isTagEnabled(tag);
+      boolean activityTagEnabled = activityDropBoxManager.isTagEnabled(tag);
+
+      assertThat(activityTagEnabled).isEqualTo(applicationTagEnabled);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
index 95d892567..74edc8a41 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEditTextTest.java
@@ -14,8 +14,11 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class ShadowEditTextTest {
   private EditText editText;
   private Application context;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
index fb1e6c9df..e07c300f0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowEuiccManagerTest.java
@@ -6,12 +6,15 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
+import android.content.Context;
 import android.telephony.euicc.EuiccManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Junit test for {@link ShadowEuiccManager}. */
@@ -57,4 +60,31 @@ public class ShadowEuiccManagerTest {
 
     assertThat(euiccManager.createForCardId(cardId)).isEqualTo(mockEuiccManager);
   }
+
+  @Test
+  public void euiccManager_activityContextEnabled_differentInstancesRetrieveEids() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      EuiccManager applicationEuiccManager =
+          (EuiccManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.EUICC_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      EuiccManager activityEuiccManager =
+          (EuiccManager) activity.getSystemService(Context.EUICC_SERVICE);
+
+      assertThat(applicationEuiccManager).isNotSameInstanceAs(activityEuiccManager);
+
+      String applicationEid = applicationEuiccManager.getEid();
+      String activityEid = activityEuiccManager.getEid();
+
+      assertThat(activityEid).isEqualTo(applicationEid);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
index 36cc4e026..168a4ce29 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFileIntegrityManagerTest.java
@@ -3,14 +3,18 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
+import android.content.Context;
 import android.security.FileIntegrityManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = R)
@@ -36,4 +40,34 @@ public final class ShadowFileIntegrityManagerTest {
 
     assertThat(fileIntegrityManager.isApkVeritySupported()).isFalse();
   }
+
+  @Test
+  public void fileIntegrityManager_activityContextEnabled_retrievesSameValues() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      FileIntegrityManager applicationFileIntegrityManager =
+          (FileIntegrityManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.FILE_INTEGRITY_SERVICE);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      FileIntegrityManager activityFileIntegrityManager =
+          (FileIntegrityManager) activity.getSystemService(Context.FILE_INTEGRITY_SERVICE);
+
+      assertThat(applicationFileIntegrityManager).isNotSameInstanceAs(activityFileIntegrityManager);
+
+      boolean applicationApkVeritySupported =
+          applicationFileIntegrityManager.isApkVeritySupported();
+      boolean activityApkVeritySupported = activityFileIntegrityManager.isApkVeritySupported();
+
+      assertThat(activityApkVeritySupported).isEqualTo(applicationApkVeritySupported);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
index 76b080b28..5af94004d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFingerprintManagerTest.java
@@ -6,6 +6,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.hardware.fingerprint.FingerprintManager;
 import android.hardware.fingerprint.FingerprintManager.AuthenticationCallback;
@@ -19,7 +20,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = M)
@@ -120,4 +123,40 @@ public class ShadowFingerprintManagerTest {
   public void getSensorPropertiesInternal_notNull() {
     assertThat(manager.getSensorPropertiesInternal()).isNotNull();
   }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.O)
+  public void fingerprintManager_activityContextEnabled_differentInstancesHaveConsistentState() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+
+    Activity activity = null;
+    try {
+      FingerprintManager applicationFingerprintManager =
+          (FingerprintManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.FINGERPRINT_SERVICE);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      FingerprintManager activityFingerprintManager =
+          (FingerprintManager) activity.getSystemService(Context.FINGERPRINT_SERVICE);
+
+      boolean isApplicationFingerprintAvailable =
+          applicationFingerprintManager.isHardwareDetected();
+      boolean isActivityFingerprintAvailable = activityFingerprintManager.isHardwareDetected();
+      assertThat(isActivityFingerprintAvailable).isEqualTo(isApplicationFingerprintAvailable);
+
+      boolean hasApplicationEnrolledFingerprints =
+          applicationFingerprintManager.hasEnrolledFingerprints();
+      boolean hasActivityEnrolledFingerprints =
+          activityFingerprintManager.hasEnrolledFingerprints();
+      assertThat(hasActivityEnrolledFingerprints).isEqualTo(hasApplicationEnrolledFingerprints);
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowFontBuilderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowFontBuilderTest.java
index 9f3daf23a..cfc1cb516 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowFontBuilderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowFontBuilderTest.java
@@ -12,11 +12,14 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.util.TestUtil;
 
 /** Tests for {@link org.robolectric.shadows.ShadowFontBuilder} */
 @RunWith(AndroidJUnit4.class)
 @Config(minSdk = Q)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowFontBuilderTest {
   private File fontFile;
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageReaderTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageReaderTest.java
index b3aee4ca8..ba3f79044 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageReaderTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageReaderTest.java
@@ -15,9 +15,12 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 /** Tests for {@link ShadowImageReader}. */
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowImageReaderTest {
   private static final int WIDTH = 640;
   private static final int HEIGHT = 480;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
index cd5838294..9ec083ab7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowImageViewTest.java
@@ -15,8 +15,12 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowImageViewTest {
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
index 11ccfda69..0e60524bf 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowInputMethodManagerTest.java
@@ -1,10 +1,12 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import android.app.Activity;
+import android.content.Context;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
@@ -20,7 +22,9 @@ import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowInputMethodManagerTest {
@@ -49,7 +53,7 @@ public class ShadowInputMethodManagerTest {
   }
 
   @Test
-  public void hideSoftInputFromWindow_shouldNotifiyResult_hidden() {
+  public void hideSoftInputFromWindow_shouldNotifyResult_hidden() {
     manager.showSoftInput(null, 0);
 
     CapturingResultReceiver resultReceiver =
@@ -151,6 +155,37 @@ public class ShadowInputMethodManagerTest {
     shadow.sendAppPrivateCommand(expectedView, expectedAction, expectedBundle);
   }
 
+  @Test
+  @Config(minSdk = O)
+  public void
+      inputMethodManager_activityContextEnabled_differentInstancesRetrieveInputMethodList() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      InputMethodManager applicationInputMethodManager =
+          (InputMethodManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.INPUT_METHOD_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      InputMethodManager activityInputMethodManager =
+          (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
+
+      assertThat(applicationInputMethodManager).isSameInstanceAs(activityInputMethodManager);
+
+      boolean applicationIsAcceptingText = applicationInputMethodManager.isAcceptingText();
+      boolean activityIsAcceptingText = activityInputMethodManager.isAcceptingText();
+
+      assertThat(activityIsAcceptingText).isEqualTo(applicationIsAcceptingText);
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
   private static class CapturingResultReceiver extends ResultReceiver {
 
     private int resultCode = -1;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowInsetsControllerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowInsetsControllerTest.java
deleted file mode 100644
index 45c428416..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowInsetsControllerTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.app.Activity;
-import android.os.Build;
-import android.view.WindowInsets;
-import android.view.WindowInsetsController;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.android.controller.ActivityController;
-import org.robolectric.annotation.Config;
-
-@RunWith(AndroidJUnit4.class)
-@Config(minSdk = Build.VERSION_CODES.R)
-public class ShadowInsetsControllerTest {
-  private ActivityController<Activity> activityController;
-  private Activity activity;
-  private WindowInsetsController controller;
-
-  @Before
-  public void setUp() {
-    activityController = Robolectric.buildActivity(Activity.class);
-    activityController.setup();
-
-    activity = activityController.get();
-    controller = activity.getWindow().getInsetsController();
-  }
-
-  @Test
-  public void statusBar_show_hide_trackedByWindowInsets() {
-    // Responds to hide.
-    controller.hide(WindowInsets.Type.statusBars());
-    assertStatusBarVisibility(/* isVisible= */ false);
-
-    // Responds to show.
-    controller.show(WindowInsets.Type.statusBars());
-    assertStatusBarVisibility(/* isVisible= */ true);
-
-    // Does not respond to different type.
-    controller.hide(WindowInsets.Type.navigationBars());
-    assertStatusBarVisibility(/* isVisible= */ true);
-  }
-
-  @Test
-  public void navigationBar_show_hide_trackedByWindowInsets() {
-    // Responds to hide.
-    controller.hide(WindowInsets.Type.navigationBars());
-    assertNavigationBarVisibility(/* isVisible= */ false);
-
-    // Responds to show.
-    controller.show(WindowInsets.Type.navigationBars());
-    assertNavigationBarVisibility(/* isVisible= */ true);
-
-    // Does not respond to different type.
-    controller.hide(WindowInsets.Type.statusBars());
-    assertNavigationBarVisibility(/* isVisible= */ true);
-  }
-
-  private void assertStatusBarVisibility(boolean isVisible) {
-    WindowInsets insets = activity.getWindow().getDecorView().getRootWindowInsets();
-    assertThat(insets.isVisible(WindowInsets.Type.statusBars())).isEqualTo(isVisible);
-  }
-
-  private void assertNavigationBarVisibility(boolean isVisible) {
-    WindowInsets insets = activity.getWindow().getDecorView().getRootWindowInsets();
-    assertThat(insets.isVisible(WindowInsets.Type.navigationBars())).isEqualTo(isVisible);
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
index f24fcddf6..ebb5a3b29 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowKeyguardManagerTest.java
@@ -13,6 +13,7 @@ import static org.robolectric.Shadows.shadowOf;
 import android.app.Activity;
 import android.app.KeyguardManager;
 import android.app.KeyguardManager.KeyguardDismissCallback;
+import android.content.Context;
 import android.content.Intent;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -21,6 +22,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowKeyguardManagerTest {
@@ -190,4 +192,31 @@ public class ShadowKeyguardManagerTest {
     keyguardLock.disableKeyguard();
     assertThat(shadowOf(manager.newKeyguardLock("tag")).isEnabled()).isFalse();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void keyguardManager_activityContextEnabled_retrievesSameState() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      KeyguardManager applicationKeyguardManager =
+          (KeyguardManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.KEYGUARD_SERVICE);
+      activity = Robolectric.setupActivity(TestActivity.class);
+      KeyguardManager activityKeyguardManager =
+          (KeyguardManager) activity.getSystemService(Context.KEYGUARD_SERVICE);
+
+      boolean applicationIsKeyguardLocked = applicationKeyguardManager.isKeyguardLocked();
+      boolean activityIsKeyguardLocked = activityKeyguardManager.isKeyguardLocked();
+
+      assertThat(activityIsKeyguardLocked).isEqualTo(applicationIsKeyguardLocked);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
index 22583c456..e84a340ce 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLauncherAppsTest.java
@@ -16,6 +16,7 @@ import static org.junit.Assert.assertTrue;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.ActivityInfo;
@@ -44,6 +45,7 @@ import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -448,4 +450,34 @@ public class ShadowLauncherAppsTest {
           ClassParameter.from(LauncherActivityInfoInternal.class, launcherActivityInfoInternal));
     }
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void launcherApps_activityContextEnabled_differentInstancesRetrieveProfiles() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+
+    try {
+      LauncherApps applicationLauncherApps =
+          ApplicationProvider.getApplicationContext().getSystemService(LauncherApps.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      LauncherApps activityLauncherApps = activity.getSystemService(LauncherApps.class);
+
+      assertThat(applicationLauncherApps).isNotSameInstanceAs(activityLauncherApps);
+
+      List<UserHandle> applicationProfiles = applicationLauncherApps.getProfiles();
+      List<UserHandle> activityProfiles = activityLauncherApps.getProfiles();
+
+      assertThat(applicationProfiles).isNotEmpty();
+      assertThat(activityProfiles).isNotEmpty();
+
+      assertThat(activityProfiles).isEqualTo(applicationProfiles);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
index 2ece00783..a7960b30e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyChoreographerTest.java
@@ -8,11 +8,11 @@ import static org.mockito.Mockito.verify;
 
 import android.view.Choreographer;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.time.Duration;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
-import org.robolectric.util.TimeUtils;
 
 /** Unit tests for {@link ShadowLegacyChoreographer}. */
 @RunWith(AndroidJUnit4.class)
@@ -21,7 +21,7 @@ public class ShadowLegacyChoreographerTest {
 
   @Test
   public void setFrameInterval_shouldUpdateFrameInterval() {
-    final long frameInterval = 10 * TimeUtils.NANOS_PER_MS;
+    final long frameInterval = Duration.ofMillis(10).toNanos();
     ShadowLegacyChoreographer.setFrameInterval(frameInterval);
 
     final Choreographer instance = ShadowLegacyChoreographer.getInstance();
@@ -47,6 +47,7 @@ public class ShadowLegacyChoreographerTest {
     assertThat(ShadowLegacyChoreographer.getFrameInterval()).isEqualTo(1);
 
     ShadowLegacyChoreographer.reset();
-    assertThat(ShadowLegacyChoreographer.getFrameInterval()).isEqualTo(10 * TimeUtils.NANOS_PER_MS);
+    assertThat(ShadowLegacyChoreographer.getFrameInterval())
+        .isEqualTo(Duration.ofMillis(10).toNanos());
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
index d606aacfc..48a5053f4 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLegacyMessageQueueTest.java
@@ -4,6 +4,7 @@ import static android.os.Build.VERSION_CODES.M;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
+import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 import static org.robolectric.util.ReflectionHelpers.callInstanceMethod;
 import static org.robolectric.util.ReflectionHelpers.setField;
@@ -21,7 +22,6 @@ import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.LooperMode.Mode;
 import org.robolectric.shadow.api.Shadow;
@@ -260,7 +260,7 @@ public class ShadowLegacyMessageQueueTest {
   }
 
   private static int postSyncBarrier(MessageQueue queue) {
-    if (RuntimeEnvironment.getApiLevel() >= M) {
+    if (getApiLevel() >= M) {
       return queue.postSyncBarrier();
     } else {
       return ReflectionHelpers.callInstanceMethod(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLinuxTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLinuxTest.java
deleted file mode 100644
index aa75f2195..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLinuxTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package org.robolectric.shadows;
-
-import static android.os.Build.VERSION_CODES.O;
-import static android.os.Build.VERSION_CODES.R;
-import static com.google.common.truth.Truth.assertThat;
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-import android.system.StructStat;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import java.io.File;
-import java.io.FileDescriptor;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.time.Duration;
-import java.util.Arrays;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
-/** Unit tests for {@code ShadowLinux}. */
-@RunWith(AndroidJUnit4.class)
-@Config(minSdk = O)
-public final class ShadowLinuxTest {
-  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();
-
-  private File file;
-  private String path;
-  private ShadowLinux shadowLinux;
-
-  @Before
-  public void setUp() throws Exception {
-    shadowLinux = new ShadowLinux();
-    file = tempFolder.newFile("ShadowLinuxTest");
-    path = file.getAbsolutePath();
-    try (FileOutputStream outputStream = new FileOutputStream(file)) {
-      outputStream.write("some UTF-8\u202Fcontent in a file".getBytes(UTF_8));
-    }
-  }
-
-  @Test
-  public void getStat_returnCorrectMode() throws Exception {
-    StructStat stat = shadowLinux.stat(path);
-    assertThat(stat.st_mode).isEqualTo(OsConstantsValues.S_IFREG_VALUE);
-  }
-
-  @Test
-  public void getStat_returnCorrectSize() throws Exception {
-    StructStat stat = shadowLinux.stat(path);
-    assertThat(stat.st_size).isEqualTo(file.length());
-  }
-
-  @Test
-  public void getStat_returnCorrectModifiedTime() throws Exception {
-    StructStat stat = shadowLinux.stat(path);
-    assertThat(stat.st_mtime).isEqualTo(Duration.ofMillis(file.lastModified()).getSeconds());
-  }
-
-  @Test
-  @Config(minSdk = R)
-  public void memfdCreate_returnNoneNullFileDescriptor() throws Exception {
-    FileDescriptor arscFile =
-        shadowLinux.memfd_create("remote_views_theme_colors.arsc", /* flags= */ 0);
-    assertThat(arscFile).isNotNull();
-  }
-
-  @Test
-  public void pread_validateExtractsContentWithOffset() throws Exception {
-    try (FileInputStream fis = new FileInputStream(file)) {
-      FileDescriptor fd = fis.getFD();
-      assertThat(fd.valid()).isTrue();
-
-      final int bytesCount = "content".length();
-      final int bytesOffset = 5;
-      final byte[] buffer = new byte[bytesCount + 2 * bytesOffset];
-      Arrays.fill(buffer, (byte) '-');
-
-      final int offsetInFile = "some UTF-8\u202F".getBytes(UTF_8).length;
-
-      assertThat(shadowLinux.pread(fd, buffer, bytesOffset, bytesCount, offsetInFile))
-          .isEqualTo(bytesCount);
-      assertThat(new String(buffer, UTF_8)).isEqualTo("-----content-----");
-    }
-  }
-
-  @Test
-  public void pread_handleFNF() throws Exception {
-    try (FileInputStream fis = new FileInputStream(file)) {
-      FileDescriptor fd = fis.getFD();
-      assertThat(fd.valid()).isTrue();
-
-      // Delete the file under test.
-      fis.close();
-      assertThat(file.delete()).isTrue();
-
-      final byte[] buffer = new byte[10];
-      Arrays.fill(buffer, (byte) '-');
-      assertThat(shadowLinux.pread(fd, buffer, 0, 5, 0)).isEqualTo(-1);
-    }
-  }
-
-  @Test
-  public void pread_readPastEnd() throws Exception {
-    try (FileInputStream fis = new FileInputStream(file)) {
-      FileDescriptor fd = fis.getFD();
-      assertThat(fd.valid()).isTrue();
-
-      final byte[] buffer = new byte[10];
-      Arrays.fill(buffer, (byte) '-');
-      assertThat(shadowLinux.pread(fd, buffer, 0, 5, 500)).isEqualTo(-1);
-    }
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
index e53b3dd53..ed2e34e5b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLocaleManagerTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
+import android.app.Activity;
 import android.app.LocaleManager;
 import android.content.Context;
 import android.os.Build.VERSION_CODES;
@@ -11,6 +12,7 @@ import androidx.test.core.app.ApplicationProvider;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -91,4 +93,31 @@ public final class ShadowLocaleManagerTest {
     assertThat(localeList.size()).isEqualTo(1);
     assertThat(localeList.get(0).getLanguage()).isEqualTo("zh");
   }
+
+  @Test
+  public void localeManager_activityContextEnabled_differentInstancesRetrieveLocales() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      LocaleManager applicationLocaleManager =
+          (LocaleManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.LOCALE_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      LocaleManager activityLocaleManager =
+          (LocaleManager) activity.getSystemService(Context.LOCALE_SERVICE);
+
+      assertThat(applicationLocaleManager).isNotSameInstanceAs(activityLocaleManager);
+
+      LocaleList applicationLocales = applicationLocaleManager.getApplicationLocales();
+      LocaleList activityLocales = activityLocaleManager.getApplicationLocales();
+
+      assertThat(activityLocales).isEqualTo(applicationLocales);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
index 01054fd75..e1169fd77 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLogTest.java
@@ -20,6 +20,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowLog.LogItem;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.versioning.AndroidVersions.L;
 
 @RunWith(AndroidJUnit4.class)
@@ -146,12 +147,13 @@ public class ShadowLogTest {
 
     TerribleFailureHandler prevWtfHandler =
         Log.setWtfHandler(
-            new TerribleFailureHandler() {
-              @Override
-              public void onTerribleFailure(String tag, TerribleFailure what, boolean system) {
-                captured[0] = what.getMessage();
-              }
-            });
+            ReflectionHelpers.createDelegatingProxy(
+                TerribleFailureHandler.class,
+                new Object() {
+                  public void onTerribleFailure(String tag, TerribleFailure what, boolean system) {
+                    captured[0] = what.getMessage();
+                  }
+                }));
 
     Log.wtf("tag", "msg", throwable);
     // assert that the new handler captures the message
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
index 494882a4a..bf0ea60c0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowLooperResetterTest.java
@@ -11,6 +11,7 @@ import android.os.HandlerThread;
 import android.os.SystemClock;
 import android.view.Choreographer;
 import java.time.Duration;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -27,7 +28,6 @@ import org.junit.runner.notification.RunNotifier;
 import org.junit.runners.JUnit4;
 import org.junit.runners.model.InitializationError;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.util.TimeUtils;
 
 /** A specialized test for verifying that looper state is cleared properly between tests. */
 @RunWith(JUnit4.class)
@@ -228,7 +228,7 @@ public class ShadowLooperResetterTest {
       // ensure callback happened and that clock is consistent with Choreographer's frame time
       // tracking
       assertThat(frameTimeNanosResult.get())
-          .isEqualTo(SystemClock.uptimeMillis() * TimeUtils.NANOS_PER_MS);
+          .isEqualTo(Duration.ofMillis(SystemClock.uptimeMillis()).toNanos());
 
       // Now set Choreographer so it expects there is a pending vsync+frame callback.
       // Choreographer will ignore vsync+frame requests if there is already one pending.
@@ -299,7 +299,7 @@ public class ShadowLooperResetterTest {
       // ensure callback happened and that clock is consistent with Choreographer's frame time
       // tracking
       assertThat(frameTimeNanosResult.get())
-          .isEqualTo(SystemClock.uptimeMillis() * TimeUtils.NANOS_PER_MS);
+          .isEqualTo(Duration.ofMillis(SystemClock.uptimeMillis()).toNanos());
 
       // Now set Choreographer so it expects there is a pending vsync+frame callback.
       // Choreographer will ignore vsync+frame requests if there is already one pending.
@@ -333,4 +333,88 @@ public class ShadowLooperResetterTest {
     // run and assert no failures
     runner.run(runNotifier);
   }
+
+  /**
+   * Test that holds static reference to Choreographer. Robolectric should clear Choreographer state
+   * between tests
+   */
+  public static class StaticChoreographerResetTest {
+
+    // use a static thread so both tests share the same Looper + Choreographer
+    @SuppressWarnings("NonFinalStaticField")
+    static HandlerThread handlerThread;
+
+    @SuppressWarnings("NonFinalStaticField")
+    static Choreographer choreographer;
+
+    @Before
+    public void init() throws InterruptedException {
+      if (handlerThread == null) {
+        handlerThread = new HandlerThread("ChoreographerResetTest");
+        handlerThread.start();
+        CountDownLatch latch = new CountDownLatch(1);
+        new Handler(handlerThread.getLooper())
+            .post(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    choreographer = Choreographer.getInstance();
+                    latch.countDown();
+                  }
+                });
+        latch.await();
+      }
+    }
+
+    @AfterClass
+    public static void shutDown() throws InterruptedException {
+      handlerThread.quit();
+      handlerThread.join();
+    }
+
+    private void doPostToChoreographerTest() {
+      checkNotNull(handlerThread.getLooper());
+      Handler handler = new Handler(handlerThread.getLooper());
+
+      AtomicLong frameTimeNanosResult = new AtomicLong(-1);
+      // you can only access Choreographer from Looper thread
+      handler.post(() -> choreographer.postFrameCallback(frameTimeNanosResult::set));
+      shadowOf(handlerThread.getLooper()).idle();
+
+      // ensure callback happened and that clock is consistent with Choreographer's frame time
+      // tracking
+      assertThat(frameTimeNanosResult.get())
+          .isEqualTo(Duration.ofMillis(SystemClock.uptimeMillis()).toNanos());
+
+      // Now set Choreographer so it expects there is a pending vsync+frame callback.
+      // Choreographer will ignore vsync+frame requests if there is already one pending.
+      // If Choreographer state isn't clearly properly between tests the next test will fail.
+
+      // Setting Choreographer into paused mode makes this test deterministic, as vsync callbacks
+      // won't occur until clock has been incremented.
+      ShadowChoreographer.setPaused(true);
+      ShadowChoreographer.setFrameDelay(Duration.ofMillis(16));
+
+      handler.post(() -> choreographer.postFrameCallback(frameTimeNanos -> {}));
+      shadowOf(handlerThread.getLooper()).idle();
+    }
+
+    @Test
+    public void postToChoreographerTest() {
+      doPostToChoreographerTest();
+    }
+
+    @Test
+    public void anotherPostToChoreographerTest() {
+      doPostToChoreographerTest();
+    }
+  }
+
+  @Test
+  public void staticChoreographerPost() throws InitializationError {
+    Runner runner = new RobolectricTestRunner(StaticChoreographerResetTest.class);
+
+    // run and assert no failures
+    runner.run(runNotifier);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixTest.java
index aae056334..d5167ce79 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMatrixTest.java
@@ -8,9 +8,12 @@ import android.graphics.RectF;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowMatrixTest {
   private static final float EPSILON = 1e-7f;
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
index 0b23bbe90..84a1540cb 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaPlayerTest.java
@@ -7,6 +7,7 @@ import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
@@ -145,6 +146,24 @@ public class ShadowMediaPlayerTest {
     assertThat(mp.getAudioSessionId()).isEqualTo(42);
   }
 
+  @Test
+  public void create_withResourceIdAudioAttributesAndAudioSessionId_shouldSetAudioAttributes() {
+    Application context = ApplicationProvider.getApplicationContext();
+    ShadowMediaPlayer.addMediaInfo(
+        DataSource.toDataSource("android.resource://" + context.getPackageName() + "/123"),
+        new ShadowMediaPlayer.MediaInfo(100, 10));
+
+    AudioAttributes audioAttributes =
+        new AudioAttributes.Builder()
+            .setUsage(AudioAttributes.USAGE_MEDIA)
+            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
+            .build();
+    MediaPlayer mp = MediaPlayer.create(context, 123, audioAttributes, 42);
+
+    ShadowMediaPlayer shadow = shadowOf(mp);
+    assertThat(shadow.getAudioAttributes()).isEqualTo(audioAttributes);
+  }
+
   @Test
   public void testInitialState() {
     assertThat(shadowMediaPlayer.getState()).isEqualTo(IDLE);
@@ -676,6 +695,23 @@ public class ShadowMediaPlayerTest {
     testStates("stop", EnumSet.of(IDLE, INITIALIZED, ERROR), onErrorTester, STOPPED);
   }
 
+  @Test
+  public void testSetAudioAttributes() {
+    AudioAttributes audioAttributes =
+        new AudioAttributes.Builder()
+            .setUsage(AudioAttributes.USAGE_MEDIA)
+            .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
+            .build();
+    mediaPlayer.setAudioAttributes(audioAttributes);
+
+    assertThat(shadowMediaPlayer.getAudioAttributes()).isEqualTo(audioAttributes);
+  }
+
+  @Test
+  public void testSetAudioAttributes_nullAudioAttributes_throwsIllegalArgumentException() {
+    assertThrows(IllegalArgumentException.class, () -> mediaPlayer.setAudioAttributes(null));
+  }
+
   @Test
   public void testCurrentPosition() {
     int[] positions = {0, 1, 2, 1024};
@@ -767,7 +803,7 @@ public class ShadowMediaPlayerTest {
     // to play it safe but reasonable, by looking at whether the PREPARED or
     // INITIALIZED are allowed (ie, the two states that PREPARING
     // sites between). Only if both these states are allowed is
-    // PREPARING allowed too, if either PREPARED or INITALIZED is
+    // PREPARING allowed too, if either PREPARED or INITIALIZED is
     // disallowed then so is PREPARING.
     if (invalid.contains(PREPARED) || invalid.contains(INITIALIZED)) {
       invalid.add(PREPARING);
@@ -934,7 +970,7 @@ public class ShadowMediaPlayerTest {
       mediaPlayer.seekTo(-1);
       shadowMediaPlayer.invokeSeekCompleteListener();
 
-      assertWithMessage("Current postion while " + state)
+      assertWithMessage("Current position while " + state)
           .that(mediaPlayer.getCurrentPosition())
           .isEqualTo(0);
       assertWithMessage("Final state " + state).that(shadowMediaPlayer.getState()).isEqualTo(state);
@@ -952,7 +988,7 @@ public class ShadowMediaPlayerTest {
       mediaPlayer.seekTo(1001);
       shadowMediaPlayer.invokeSeekCompleteListener();
 
-      assertWithMessage("Current postion while " + state)
+      assertWithMessage("Current position while " + state)
           .that(mediaPlayer.getCurrentPosition())
           .isEqualTo(1000);
       assertWithMessage("Final state " + state).that(shadowMediaPlayer.getState()).isEqualTo(state);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
index 41e5b3b7b..15252bc16 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaRouterTest.java
@@ -3,9 +3,11 @@ package org.robolectric.shadows;
 import static android.media.MediaRouter.ROUTE_TYPE_LIVE_AUDIO;
 import static android.media.MediaRouter.ROUTE_TYPE_LIVE_VIDEO;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.media.MediaRouter;
 import android.media.MediaRouter.RouteInfo;
@@ -14,6 +16,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowMediaRouter}. */
@@ -126,4 +129,34 @@ public final class ShadowMediaRouterTest {
     mediaRouter.selectRoute(ROUTE_TYPE_LIVE_AUDIO, bluetoothRoute);
     assertThat(shadowOf(mediaRouter).isBluetoothRouteSelected(ROUTE_TYPE_LIVE_AUDIO)).isTrue();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void mediaRouter_activityContextEnabled_differentInstancesRetrieveDefaultRoute() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      MediaRouter applicationMediaRouter =
+          (MediaRouter)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.MEDIA_ROUTER_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      MediaRouter activityMediaRouter =
+          (MediaRouter) activity.getSystemService(Context.MEDIA_ROUTER_SERVICE);
+
+      assertThat(applicationMediaRouter).isNotSameInstanceAs(activityMediaRouter);
+
+      MediaRouter.RouteInfo applicationDefaultRoute = applicationMediaRouter.getDefaultRoute();
+      MediaRouter.RouteInfo activityDefaultRoute = activityMediaRouter.getDefaultRoute();
+
+      assertThat(activityDefaultRoute).isEqualTo(applicationDefaultRoute);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
index bc96883ad..85de8c537 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowMediaSessionManagerTest.java
@@ -1,7 +1,9 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.content.Context;
 import android.media.session.MediaController;
 import android.media.session.MediaSession;
@@ -13,7 +15,10 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.Shadows;
+import org.robolectric.annotation.Config;
 
 /** Tests for {@link ShadowMediaSessionManager} */
 @RunWith(AndroidJUnit4.class)
@@ -58,4 +63,33 @@ public class ShadowMediaSessionManagerTest {
     Shadows.shadowOf(mediaSessionManager).addController(mediaController);
     assertThat(changedMediaControllers).containsExactly(mediaController);
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void mediaSessionManager_activityContextEnabled_differentInstancesRetrieveSessions() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      MediaSessionManager applicationMediaSessionManager =
+          RuntimeEnvironment.getApplication().getSystemService(MediaSessionManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      MediaSessionManager activityMediaSessionManager =
+          activity.getSystemService(MediaSessionManager.class);
+
+      assertThat(applicationMediaSessionManager).isNotSameInstanceAs(activityMediaSessionManager);
+
+      List<MediaController> applicationControllers =
+          applicationMediaSessionManager.getActiveSessions(null);
+      List<MediaController> activityControllers =
+          activityMediaSessionManager.getActiveSessions(null);
+
+      assertThat(activityControllers).isEqualTo(applicationControllers);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
index ba00473bd..89a74872c 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkCapabilitiesTest.java
@@ -114,6 +114,13 @@ public class ShadowNetworkCapabilitiesTest {
     assertThat(networkCapabilities.getLinkDownstreamBandwidthKbps()).isEqualTo(100);
   }
 
+  @Test
+  public void setLinkUpstreamBandwidthKbps() {
+    NetworkCapabilities networkCapabilities = ShadowNetworkCapabilities.newInstance();
+    shadowOf(networkCapabilities).setLinkUpstreamBandwidthKbps(100);
+    assertThat(networkCapabilities.getLinkUpstreamBandwidthKbps()).isEqualTo(100);
+  }
+
   @Test
   public void resetCapabilities_resetsCapabilities() {
     NetworkCapabilities networkCapabilities = ShadowNetworkCapabilities.newInstance();
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
index e9a951236..a703469b3 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNetworkScoreManagerTest.java
@@ -1,13 +1,18 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.content.Context;
 import android.net.NetworkScoreManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
 /** ShadowNetworkScoreManagerTest tests {@link ShadowNetworkScoreManager}. */
@@ -34,4 +39,32 @@ public final class ShadowNetworkScoreManagerTest {
     ShadowNetworkScoreManager m = Shadow.extract(networkScoreManager);
     assertThat(m.isScoringEnabled()).isFalse();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void
+      networkScoreManager_activityContextEnabled_differentInstancesRetrieveActiveScorerPackage() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      NetworkScoreManager applicationNetworkScoreManager =
+          RuntimeEnvironment.getApplication().getSystemService(NetworkScoreManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      NetworkScoreManager activityNetworkScoreManager =
+          activity.getSystemService(NetworkScoreManager.class);
+
+      assertThat(applicationNetworkScoreManager).isNotSameInstanceAs(activityNetworkScoreManager);
+
+      String applicationScorerPackage = applicationNetworkScoreManager.getActiveScorerPackage();
+      String activityScorerPackage = activityNetworkScoreManager.getActiveScorerPackage();
+
+      assertThat(activityScorerPackage).isEqualTo(applicationScorerPackage);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
index 6d926fdb0..a636fc7c8 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNfcAdapterTest.java
@@ -6,6 +6,7 @@ import static org.mockito.ArgumentMatchers.same;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Activity;
 import android.app.Application;
@@ -24,6 +25,8 @@ import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowNfcAdapterTest {
@@ -257,4 +260,55 @@ public class ShadowNfcAdapterTest {
 
     assertThat(adapter.getNfcAntennaInfo()).isEqualTo(info);
   }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void isObserveModeSupported_shouldReturnSupportedState() {
+    final NfcAdapter adapter = NfcAdapter.getDefaultAdapter(context);
+    final NfcAdapterVReflector adapterReflector = reflector(NfcAdapterVReflector.class, adapter);
+    assertThat(adapterReflector.isObserveModeSupported()).isFalse();
+
+    shadowOf(adapter).setObserveModeSupported(true);
+    assertThat(adapterReflector.isObserveModeSupported()).isTrue();
+
+    shadowOf(adapter).setObserveModeSupported(false);
+    assertThat(adapterReflector.isObserveModeSupported()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void isObserveModeEnabled_shouldReturnEnabledState() {
+    final NfcAdapter adapter = NfcAdapter.getDefaultAdapter(context);
+    final NfcAdapterVReflector adapterReflector = reflector(NfcAdapterVReflector.class, adapter);
+    shadowOf(adapter).setObserveModeSupported(true);
+    assertThat(adapterReflector.isObserveModeEnabled()).isFalse();
+
+    adapterReflector.setObserveModeEnabled(true);
+    assertThat(adapterReflector.isObserveModeEnabled()).isTrue();
+
+    adapterReflector.setObserveModeEnabled(false);
+    assertThat(adapterReflector.isObserveModeEnabled()).isFalse();
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void setObserveModeEnabled_notSupported_doesNothing() {
+    final NfcAdapter adapter = NfcAdapter.getDefaultAdapter(context);
+    final NfcAdapterVReflector adapterReflector = reflector(NfcAdapterVReflector.class, adapter);
+    shadowOf(adapter).setObserveModeSupported(false);
+    assertThat(adapterReflector.isObserveModeEnabled()).isFalse();
+
+    adapterReflector.setObserveModeEnabled(true);
+    assertThat(adapterReflector.isObserveModeEnabled()).isFalse();
+  }
+
+  // TODO: delete when this test compiles against V sdk
+  @ForType(NfcAdapter.class)
+  interface NfcAdapterVReflector {
+    boolean isObserveModeSupported();
+
+    boolean isObserveModeEnabled();
+
+    void setObserveModeEnabled(boolean enabled);
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
index 7e9ce69a3..864d9c258 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowNotificationManagerTest.java
@@ -2,14 +2,15 @@ package org.robolectric.shadows;
 
 import static android.app.NotificationManager.INTERRUPTION_FILTER_ALL;
 import static android.app.NotificationManager.INTERRUPTION_FILTER_PRIORITY;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
+import android.app.Activity;
 import android.app.AutomaticZenRule;
 import android.app.Notification;
 import android.app.NotificationChannel;
@@ -32,11 +33,10 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.LooperMode;
 
 @RunWith(AndroidJUnit4.class)
-@LooperMode(PAUSED)
 public class ShadowNotificationManagerTest {
   private NotificationManager notificationManager;
   private Notification notification1 = new Notification();
@@ -94,6 +94,14 @@ public class ShadowNotificationManagerTest {
     assertThat(channel.getImportance()).isEqualTo(1);
   }
 
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O)
+  public void getImportance_afterReset() {
+    assertThat(notificationManager.getImportance()).isEqualTo(NotificationManager.IMPORTANCE_NONE);
+    ShadowNotificationManager.reset();
+    assertThat(notificationManager.getImportance()).isEqualTo(NotificationManager.IMPORTANCE_NONE);
+  }
+
   @Test
   @Config(minSdk = Build.VERSION_CODES.O)
   public void createNotificationChannel_updateChannel() {
@@ -814,4 +822,39 @@ public class ShadowNotificationManagerTest {
     }
     return null;
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void notificationManager_activityContext_enabled_differentInstancesRetrieveChannels() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      NotificationManager applicationNotificationManager =
+          (NotificationManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.NOTIFICATION_SERVICE);
+
+      NotificationChannel testChannel =
+          new NotificationChannel(
+              "test_channel_id", "Test Channel", NotificationManager.IMPORTANCE_DEFAULT);
+      applicationNotificationManager.createNotificationChannel(testChannel);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      NotificationManager activityNotificationManager =
+          (NotificationManager) activity.getSystemService(Context.NOTIFICATION_SERVICE);
+
+      NotificationChannel applicationChannel =
+          applicationNotificationManager.getNotificationChannel("test_channel_id");
+      NotificationChannel activityChannel =
+          activityNotificationManager.getNotificationChannel("test_channel_id");
+
+      assertThat(activityChannel).isEqualTo(applicationChannel);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowOsConstantsTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowOsConstantsTest.java
deleted file mode 100644
index bc3bf9a4e..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowOsConstantsTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.shadows.OsConstantsValues.OPEN_MODE_VALUES;
-
-import android.system.OsConstants;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Unit tests for {@link ShadowOsConstants}. */
-@RunWith(AndroidJUnit4.class)
-public final class ShadowOsConstantsTest {
-
-  @Test
-  public void valuesAreDistinct() throws Exception {
-    assertThat(OsConstants.errnoName(OsConstants.EAGAIN)).isEqualTo("EAGAIN");
-    assertThat(OsConstants.errnoName(OsConstants.EBADF)).isEqualTo("EBADF");
-  }
-
-  @Test
-  public void valuesAreExpected() {
-    assertThat(OsConstants.S_IFMT).isEqualTo(OsConstantsValues.S_IFMT_VALUE);
-    assertThat(OsConstants.S_IFDIR).isEqualTo(OsConstantsValues.S_IFDIR_VALUE);
-    assertThat(OsConstants.S_IFREG).isEqualTo(OsConstantsValues.S_IFREG_VALUE);
-    assertThat(OsConstants.S_IFLNK).isEqualTo(OsConstantsValues.S_IFLNK_VALUE);
-
-    assertThat(OsConstants.O_RDONLY).isEqualTo(OPEN_MODE_VALUES.get("O_RDONLY"));
-    assertThat(OsConstants.O_WRONLY).isEqualTo(OPEN_MODE_VALUES.get("O_WRONLY"));
-    assertThat(OsConstants.O_RDWR).isEqualTo(OPEN_MODE_VALUES.get("O_RDWR"));
-    assertThat(OsConstants.O_ACCMODE).isEqualTo(OPEN_MODE_VALUES.get("O_ACCMODE"));
-    assertThat(OsConstants.O_CREAT).isEqualTo(OPEN_MODE_VALUES.get("O_CREAT"));
-    assertThat(OsConstants.O_EXCL).isEqualTo(OPEN_MODE_VALUES.get("O_EXCL"));
-    assertThat(OsConstants.O_TRUNC).isEqualTo(OPEN_MODE_VALUES.get("O_TRUNC"));
-    assertThat(OsConstants.O_APPEND).isEqualTo(OPEN_MODE_VALUES.get("O_APPEND"));
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
index 0ffa3c05a..e27e27bf5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPackageManagerTest.java
@@ -119,6 +119,7 @@ import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 import org.junit.After;
 import org.junit.Assert;
@@ -1894,6 +1895,22 @@ public class ShadowPackageManagerTest {
     assertThat(services.get(0).nonLocalizedLabel.toString()).isEqualTo(TEST_PACKAGE_LABEL);
   }
 
+  @Test
+  @Config(minSdk = TIRAMISU)
+  public void queryIntentServices_Match_withResolveInfoFlags() {
+    Intent i = new Intent(Intent.ACTION_MAIN, null);
+
+    ResolveInfo info = new ResolveInfo();
+    info.serviceInfo = new ServiceInfo();
+    info.nonLocalizedLabel = TEST_PACKAGE_LABEL;
+
+    shadowOf(packageManager).addResolveInfoForIntent(i, info);
+
+    List<ResolveInfo> services = packageManager.queryIntentServices(i, ResolveInfoFlags.of(0));
+    assertThat(services).hasSize(1);
+    assertThat(services.get(0).nonLocalizedLabel.toString()).isEqualTo(TEST_PACKAGE_LABEL);
+  }
+
   @Test
   public void queryIntentServices_fromManifest() {
     Intent i = new Intent("org.robolectric.ACTION_DIFFERENT_PACKAGE");
@@ -3015,7 +3032,7 @@ public class ShadowPackageManagerTest {
   public void getResourcesForApplication_ApkNotPresent() {
     ApplicationInfo applicationInfo =
         ApplicationInfoBuilder.newBuilder().setPackageName("com.not.present").build();
-    applicationInfo.sourceDir = applicationInfo.publicSourceDir = "/some/nonexistant/path";
+    applicationInfo.sourceDir = applicationInfo.publicSourceDir = "/some/nonexistent/path";
 
     try {
       packageManager.getResourcesForApplication(applicationInfo);
@@ -3135,7 +3152,7 @@ public class ShadowPackageManagerTest {
   @Config(minSdk = N, maxSdk = N_MR1) // Functionality removed in O
   public void whenPackageNotPresent_getPackageSizeInfo_callsBackWithFailure() throws Exception {
     IPackageStatsObserver packageStatsObserver = mock(IPackageStatsObserver.class);
-    packageManager.getPackageSizeInfo("nonexistant.package", packageStatsObserver);
+    packageManager.getPackageSizeInfo("nonexistent.package", packageStatsObserver);
     shadowMainLooper().idle();
 
     verify(packageStatsObserver).onGetStatsCompleted(packageStatsCaptor.capture(), eq(false));
@@ -3148,7 +3165,7 @@ public class ShadowPackageManagerTest {
       throws Exception {
     shadowMainLooper().pause();
     IPackageStatsObserver packageStatsObserver = mock(IPackageStatsObserver.class);
-    packageManager.getPackageSizeInfo("nonexistant.package", packageStatsObserver);
+    packageManager.getPackageSizeInfo("nonexistent.package", packageStatsObserver);
 
     verifyNoMoreInteractions(packageStatsObserver);
 
@@ -4690,6 +4707,38 @@ public class ShadowPackageManagerTest {
         .inOrder();
   }
 
+  @Test
+  public void reQueryOverriddenIntents_shouldReturnsDifferentInstancesOfSameParcelables() {
+    Intent intent = new Intent(Intent.ACTION_VIEW);
+    ResolveInfo resolveInfo = new ResolveInfo();
+    resolveInfo.activityInfo = new ActivityInfo();
+    resolveInfo.activityInfo.packageName = "test.package";
+    resolveInfo.activityInfo.name = "test.activity";
+    shadowOf(packageManager).addResolveInfoForIntent(intent, resolveInfo);
+
+    List<ResolveInfo> resolveInfoList1 = packageManager.queryIntentActivities(intent, 0);
+    List<ResolveInfo> resolveInfoList2 = packageManager.queryIntentActivities(intent, 0);
+
+    assertThat(resolveInfoList1).hasSize(1);
+    assertThat(resolveInfoList2).hasSize(1);
+    assertThat(resolveInfoList1).containsNoneIn(resolveInfoList2);
+
+    Iterator<ResolveInfo> iterator1 = resolveInfoList1.iterator();
+    Iterator<ResolveInfo> iterator2 = resolveInfoList2.iterator();
+    while (iterator1.hasNext() && iterator2.hasNext()) {
+      ResolveInfo parcellable1 = iterator1.next();
+      ResolveInfo parcellable2 = iterator2.next();
+      ActivityInfo activityInfo1 = parcellable1.activityInfo;
+      ActivityInfo activityInfo2 = parcellable2.activityInfo;
+
+      assertThat(activityInfo1.packageName).isEqualTo("test.package");
+      assertThat(activityInfo1.name).isEqualTo("test.activity");
+
+      assertThat(activityInfo1.packageName).isEqualTo(activityInfo2.packageName);
+      assertThat(activityInfo1.name).isEqualTo(activityInfo2.name);
+    }
+  }
+
   private static PackageInfo createPackageInfoWithPackageName(String packageName) {
     PackageInfo packageInfo = new PackageInfo();
     packageInfo.packageName = packageName;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
index d7577f001..2c7c3276a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPaintTest.java
@@ -10,8 +10,11 @@ import android.graphics.Paint;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowPaintTest {
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
index 8d64f4912..ec210a1fc 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPathTest.java
@@ -15,9 +15,12 @@ import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.versioning.AndroidVersions.U;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowPathTest {
 
   private static final float ERROR_TOLERANCE = 0.5f;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
index 42171f2a9..4886be128 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedAsyncTaskTest.java
@@ -5,7 +5,6 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
 import android.os.AsyncTask;
@@ -22,12 +21,10 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.android.util.concurrent.PausedExecutorService;
-import org.robolectric.annotation.LooperMode;
 import org.robolectric.util.Join;
 
 /** Unit tests for {@link ShadowPausedAsyncTask}. */
 @RunWith(AndroidJUnit4.class)
-@LooperMode(PAUSED)
 public class ShadowPausedAsyncTaskTest {
   private List<String> transcript;
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedMessageQueueTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedMessageQueueTest.java
index c0a86f05f..bb7af45f9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedMessageQueueTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedMessageQueueTest.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
 import android.os.Handler;
 import android.os.Looper;
@@ -15,13 +14,11 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.annotation.LooperMode;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
 @RunWith(AndroidJUnit4.class)
-@LooperMode(PAUSED)
 public class ShadowPausedMessageQueueTest {
   private MessageQueue queue;
   private ShadowPausedMessageQueue shadowQueue;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
index 7eaa98896..6152d5472 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPausedSystemClockTest.java
@@ -6,7 +6,6 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.robolectric.annotation.LooperMode.Mode.PAUSED;
 
 import android.os.SystemClock;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -20,11 +19,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
-import org.robolectric.annotation.LooperMode;
 import org.robolectric.internal.bytecode.RobolectricInternals;
 
 @RunWith(AndroidJUnit4.class)
-@LooperMode(PAUSED)
 public class ShadowPausedSystemClockTest {
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
index 61cbb18c1..682536893 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPendingIntentTest.java
@@ -33,6 +33,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowActivity.IntentForResult;
 
 @SuppressWarnings("deprecation")
 @RunWith(AndroidJUnit4.class)
@@ -737,6 +738,44 @@ public class ShadowPendingIntentTest {
     assertThat(sendOptions.getBoolean(keyDontSendToRestrictedApps)).isTrue();
   }
 
+  /** Verify options are sent along with the Activity PendingIntent. */
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.M)
+  public void send_activityWithOptions() throws CanceledException {
+    Intent intent = new Intent().setPackage("dummy.package");
+    Bundle creatorOptions = new Bundle();
+    creatorOptions.putBoolean("creator", true);
+    PendingIntent pendingIntent =
+        PendingIntent.getActivity(
+            context, /* requestCode= */ 0, intent, /* flags= */ 0, creatorOptions);
+
+    // Add an option when sending the Activity PendingIntent.
+    Bundle senderOptions = new Bundle();
+    senderOptions.putBoolean("sender", true);
+
+    // Send the pendingIntent with options.
+    pendingIntent.send(
+        context,
+        /* code= */ 0,
+        intent,
+        /* onFinished= */ null,
+        /* handler= */ null,
+        /* requiredPermission= */ null,
+        senderOptions);
+    // Verify that PendingIntent.getOptions() are from the creator.
+    assertThat(shadowOf(pendingIntent).getOptions()).isNotNull();
+    assertThat(shadowOf(pendingIntent).getOptions().keySet()).containsExactly("creator");
+
+    // Verify senderOptions are used when sending the PendingIntent.
+    ShadowApplication shadowApplication = shadowOf((Application) context);
+    IntentForResult intentForResult = shadowApplication.peekNextStartedActivityForResult();
+    assertThat(intentForResult).isNotNull();
+    assertThat(intentForResult.intent).isNotNull();
+    assertThat(intentForResult.intent.getPackage()).isEqualTo("dummy.package");
+    assertThat(intentForResult.options).isNotNull();
+    assertThat(intentForResult.options.keySet()).containsExactly("sender");
+  }
+
   @Test
   public void send_withOnFinishedCallback_callbackSavedForLaterInvocation()
       throws CanceledException {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPorterDuffColorFilterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPorterDuffColorFilterTest.java
index c22aa38b3..eea490750 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPorterDuffColorFilterTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPorterDuffColorFilterTest.java
@@ -10,8 +10,11 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowPorterDuffColorFilterTest {
   @Test
   public void constructor_shouldWork() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPosixTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPosixTest.java
deleted file mode 100644
index b9965735e..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPosixTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.system.StructStat;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.time.Duration;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.util.ReflectionHelpers;
-
-/** Unit tests for ShadowPosix to check values returned from stat() call. */
-@RunWith(AndroidJUnit4.class)
-public final class ShadowPosixTest {
-  private File file;
-  private String path;
-
-  @Before
-  public void setUp() throws Exception {
-    file = File.createTempFile("ShadowPosixTest", null);
-    path = file.getAbsolutePath();
-    try (FileOutputStream outputStream = new FileOutputStream(file)) {
-      outputStream.write(1234);
-    }
-  }
-
-  @Test
-  public void getStatAtLeastLollipop_returnCorrectMode() throws Exception {
-    StructStat stat = (StructStat) ShadowPosix.stat(path);
-    assertThat(stat.st_mode).isEqualTo(OsConstantsValues.S_IFREG_VALUE);
-  }
-
-  @Test
-  public void getStatAtLeastLollipop_returnCorrectSize() throws Exception {
-    StructStat stat = (StructStat) ShadowPosix.stat(path);
-    assertThat(stat.st_size).isEqualTo(file.length());
-  }
-
-  @Test
-  public void getStatAtLeastLollipop_returnCorrectModifiedTime() throws Exception {
-    StructStat stat = (StructStat) ShadowPosix.stat(path);
-    assertThat(stat.st_mtime).isEqualTo(Duration.ofMillis(file.lastModified()).getSeconds());
-  }
-
-  @Test
-  public void getStatBelowLollipop_returnCorrectMode() throws Exception {
-    Object stat = ShadowPosix.stat(path);
-    int mode = ReflectionHelpers.getField(stat, "st_mode");
-    assertThat(mode).isEqualTo(OsConstantsValues.S_IFREG_VALUE);
-  }
-
-  @Test
-  public void getStatBelowLollipop_returnCorrectSize() throws Exception {
-    Object stat = ShadowPosix.stat(path);
-    long size = ReflectionHelpers.getField(stat, "st_size");
-    assertThat(size).isEqualTo(file.length());
-  }
-
-  @Test
-  public void getStatBelowtLollipop_returnCorrectModifiedTime() throws Exception {
-    Object stat = ShadowPosix.stat(path);
-    long modifiedTime = ReflectionHelpers.getField(stat, "st_mtime");
-    assertThat(modifiedTime).isEqualTo(Duration.ofMillis(file.lastModified()).getSeconds());
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
index ffad2f518..1b838672a 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPowerManagerTest.java
@@ -4,6 +4,7 @@ import static android.content.Intent.ACTION_SCREEN_OFF;
 import static android.content.Intent.ACTION_SCREEN_ON;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
@@ -17,6 +18,7 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.Application;
 import android.content.Context;
 import android.content.Intent;
@@ -32,6 +34,7 @@ import java.time.Duration;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -52,7 +55,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void acquire_shouldAcquireAndReleaseReferenceCountedLock() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     assertThat(lock.isHeld()).isFalse();
     lock.acquire();
     assertThat(lock.isHeld()).isTrue();
@@ -84,7 +87,7 @@ public class ShadowPowerManagerTest {
     ShadowPowerManager.reset();
     assertThat(ShadowPowerManager.getLatestWakeLock()).isNull();
 
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     lock.acquire();
 
     assertThat(ShadowPowerManager.getLatestWakeLock()).isNotNull();
@@ -103,18 +106,18 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void newWakeLock_shouldCreateWakeLock() {
-    assertThat(powerManager.newWakeLock(0, "TAG")).isNotNull();
+    assertThat(powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG")).isNotNull();
   }
 
   @Test
   public void newWakeLock_shouldSetWakeLockTag() {
-    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(0, "FOO");
+    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "FOO");
     assertThat(shadowOf(wakeLock).getTag()).isEqualTo("FOO");
   }
 
   @Test
   public void newWakeLock_shouldAcquireAndReleaseNonReferenceCountedLock() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     lock.setReferenceCounted(false);
 
     assertThat(lock.isHeld()).isFalse();
@@ -130,7 +133,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void newWakeLock_shouldThrowRuntimeExceptionIfLockIsUnderlocked() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     try {
       lock.release();
       fail();
@@ -152,7 +155,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isReferenceCounted_shouldGetAndSet() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     assertThat(shadowOf(lock).isReferenceCounted()).isTrue();
     lock.setReferenceCounted(false);
     assertThat(shadowOf(lock).isReferenceCounted()).isFalse();
@@ -225,7 +228,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void workSource_shouldGetAndSet() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     WorkSource workSource = new WorkSource();
     assertThat(shadowOf(lock).getWorkSource()).isNull();
     lock.setWorkSource(workSource);
@@ -253,6 +256,16 @@ public class ShadowPowerManagerTest {
     assertThat(powerManager.isDeviceIdleMode()).isFalse();
   }
 
+  @Test
+  @Config(minSdk = M)
+  public void setIsDeviceIdleMode_broadcastsChange() {
+    shadowOf(powerManager).setIsDeviceIdleMode(true);
+    assertThat(shadowOf(context).getBroadcastIntents())
+        .comparingElementsUsing(Correspondence.from(Intent::filterEquals, "is filterEqual to"))
+        .contains(new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
+    shadowOf(context).clearBroadcastIntents();
+  }
+
   @Test
   @Config(minSdk = N)
   public void isLightDeviceIdleMode_shouldGetAndSet() {
@@ -280,7 +293,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void acquire_shouldIncreaseTimesHeld() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
 
     assertThat(shadowOf(lock).getTimesHeld()).isEqualTo(0);
 
@@ -293,7 +306,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void release_shouldNotDecreaseTimesHeld() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     lock.acquire();
     lock.acquire();
 
@@ -460,7 +473,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void releaseWithFlags() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     lock.acquire();
 
     lock.release(PowerManager.RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY);
@@ -470,7 +483,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void release() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TAG");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TAG");
     lock.acquire();
 
     lock.release();
@@ -524,7 +537,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isHeld_neverAcquired_returnsFalse() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
     lock.setReferenceCounted(false);
 
     assertThat(lock.isHeld()).isFalse();
@@ -532,7 +545,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isHeld_wakeLockTimeout_returnsFalse() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
     lock.setReferenceCounted(false);
 
     lock.acquire(100);
@@ -543,7 +556,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isHeld_wakeLockJustTimeout_returnsTrue() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
     lock.setReferenceCounted(false);
 
     lock.acquire(100);
@@ -554,7 +567,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isHeld_wakeLockNotTimeout_returnsTrue() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
     lock.setReferenceCounted(false);
 
     lock.acquire(100);
@@ -565,7 +578,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void isHeld_unlimitedWakeLockAcquired_returnsTrue() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
     lock.setReferenceCounted(false);
 
     lock.acquire();
@@ -576,7 +589,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void release_isRefCounted_dequeueTheSmallestTimeoutLock() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
 
     // There are 2 wake lock acquires when calling release(). The wake lock with the smallest
     // timeout timestamp is release first.
@@ -590,7 +603,7 @@ public class ShadowPowerManagerTest {
 
   @Test
   public void release_isRefCounted_dequeueTimeoutLockBeforeUnlimited() {
-    PowerManager.WakeLock lock = powerManager.newWakeLock(0, "TIMEOUT");
+    PowerManager.WakeLock lock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, "TIMEOUT");
 
     // There are 2 wake lock acquires when calling release(). The lock with timeout 100ms will be
     // released first.
@@ -730,4 +743,32 @@ public class ShadowPowerManagerTest {
     lock.release();
     assertThat(shadowLock.isAcquired()).isFalse();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void powerManager_activityContextEnabled_checkIsInteractive() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      PowerManager applicationPowerManager =
+          (PowerManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.POWER_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      PowerManager activityPowerManager =
+          (PowerManager) activity.getSystemService(Context.POWER_SERVICE);
+
+      assertThat(applicationPowerManager).isNotSameInstanceAs(activityPowerManager);
+
+      boolean applicationIsInteractive = applicationPowerManager.isInteractive();
+      boolean activityIsInteractive = activityPowerManager.isInteractive();
+
+      assertThat(activityIsInteractive).isEqualTo(applicationIsInteractive);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
index 8ba073c85..36ab74fed 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowPreferenceGroupTest.java
@@ -15,8 +15,11 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class ShadowPreferenceGroupTest {
 
   private TestPreferenceGroup group;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
index 937143702..c4e7cdc58 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowProgressBarTest.java
@@ -13,8 +13,11 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class ShadowProgressBarTest {
 
   private int[] testValues = {0, 1, 2, 100};
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java
new file mode 100644
index 000000000..c0955c347
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowQueuedWorkResetterTest.java
@@ -0,0 +1,79 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.O;
+import static com.google.common.truth.Truth.assertThat;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.app.QueuedWork;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runner.Runner;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunListener;
+import org.junit.runner.notification.RunNotifier;
+import org.junit.runners.JUnit4;
+import org.junit.runners.model.InitializationError;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.shadows.ShadowQueuedWork.QueuedWorkReflector;
+
+/** A specialized test for verifying that QueuedWork state is cleared properly between tests. */
+@RunWith(JUnit4.class)
+public class ShadowQueuedWorkResetterTest {
+  private final RunNotifier runNotifier = new RunNotifier();
+
+  @Before
+  public void setup() {
+    runNotifier.addListener(
+        new RunListener() {
+          @Override
+          public void testFailure(Failure failure) throws Exception {
+            throw new AssertionError("Unexpected test failure: " + failure, failure.getException());
+          }
+        });
+  }
+
+  /**
+   * Basic test class that interacts with QueuedWork in two different tests, to ensure QueuedWork
+   * remains functional after reset and doesn't leak threads/loopers.
+   */
+  public static class BasicQueuedWorkTest {
+
+    private static final AtomicInteger initialLooperCount = new AtomicInteger(-1);
+
+    private void doPostToQueuedWorkTest() throws InterruptedException {
+      AtomicBoolean wasRun = new AtomicBoolean(false);
+      if (RuntimeEnvironment.getApiLevel() < O) {
+        reflector(QueuedWorkReflector.class).add(() -> wasRun.set(true));
+      } else {
+        QueuedWork.addFinisher(() -> wasRun.set(true));
+      }
+      QueuedWork.waitToFinish();
+      initialLooperCount.compareAndSet(-1, ShadowLooper.getAllLoopers().size());
+
+      assertThat(wasRun.get()).isTrue();
+      assertThat(ShadowLooper.getAllLoopers()).hasSize(initialLooperCount.get());
+    }
+
+    @Test
+    public void postToQueuedTest() throws InterruptedException {
+      doPostToQueuedWorkTest();
+    }
+
+    @Test
+    public void anotherPostToQueuedWorkTest() throws InterruptedException {
+      doPostToQueuedWorkTest();
+    }
+  }
+
+  @Test
+  public void basicPostAndRun() throws InitializationError {
+    Runner runner = new RobolectricTestRunner(BasicQueuedWorkTest.class);
+
+    // run and assert no failures
+    runner.run(runNotifier);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRcsUceAdapterSTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRcsUceAdapterSTest.java
index 5ad1f3cd5..8f7b11cf0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRcsUceAdapterSTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRcsUceAdapterSTest.java
@@ -22,6 +22,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowRcsUceAdapter.CapabilityFailureInfo;
+import org.robolectric.util.ReflectionHelpers;
 
 /**
  * Unit tests for {@link ShadowRcsUceAdapter} on S. Split out from ShadowRcsUceAdapterTest since the
@@ -59,10 +60,13 @@ public class ShadowRcsUceAdapterSTest {
     RcsContactUceCapability capability =
         new RcsContactUceCapability.OptionsBuilder(URI).addFeatureTag(FEATURE_TAG).build();
     ShadowRcsUceAdapter.setCapabilitiesForUri(URI, capability);
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(capability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(capability));
 
-    rcsUceAdapter.requestCapabilities(ImmutableList.of(URI), executorService, verifierCallback);
+    rcsUceAdapter.requestCapabilities(
+        ImmutableList.of(URI),
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -77,11 +81,13 @@ public class ShadowRcsUceAdapterSTest {
     RcsContactUceCapability otherEmptyCapability =
         new RcsContactUceCapability.OptionsBuilder(OTHER_URI).build();
     ShadowRcsUceAdapter.setCapabilitiesForUri(URI, capability);
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(otherEmptyCapability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(otherEmptyCapability));
 
     rcsUceAdapter.requestCapabilities(
-        ImmutableList.of(OTHER_URI), executorService, verifierCallback);
+        ImmutableList.of(OTHER_URI),
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -92,9 +98,12 @@ public class ShadowRcsUceAdapterSTest {
   public void setCapabilitiesFailureForUri_requestCapabilities_failsForUri() throws Exception {
     CapabilityFailureInfo failureInfo = CapabilityFailureInfo.create(ERROR_CODE, RETRY_MILLIS);
     ShadowRcsUceAdapter.setCapabilitiesFailureForUri(URI, failureInfo);
-    ErrorVerifierCallback verifierCallback = new ErrorVerifierCallback(failureInfo);
+    ErrorVerifierCallbackDelegate verifierCallback = new ErrorVerifierCallbackDelegate(failureInfo);
 
-    rcsUceAdapter.requestCapabilities(ImmutableList.of(URI), executorService, verifierCallback);
+    rcsUceAdapter.requestCapabilities(
+        ImmutableList.of(URI),
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -108,11 +117,13 @@ public class ShadowRcsUceAdapterSTest {
     ShadowRcsUceAdapter.setCapabilitiesFailureForUri(URI, failureInfo);
     RcsContactUceCapability otherEmptyCapability =
         new RcsContactUceCapability.OptionsBuilder(OTHER_URI).build();
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(otherEmptyCapability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(otherEmptyCapability));
 
     rcsUceAdapter.requestCapabilities(
-        ImmutableList.of(OTHER_URI), executorService, verifierCallback);
+        ImmutableList.of(OTHER_URI),
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -125,10 +136,13 @@ public class ShadowRcsUceAdapterSTest {
     RcsContactUceCapability capability =
         new RcsContactUceCapability.OptionsBuilder(URI).addFeatureTag(FEATURE_TAG).build();
     ShadowRcsUceAdapter.setCapabilitiesForUri(URI, capability);
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(capability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(capability));
 
-    rcsUceAdapter.requestAvailability(URI, executorService, verifierCallback);
+    rcsUceAdapter.requestAvailability(
+        URI,
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -143,10 +157,13 @@ public class ShadowRcsUceAdapterSTest {
     RcsContactUceCapability otherEmptyCapability =
         new RcsContactUceCapability.OptionsBuilder(OTHER_URI).build();
     ShadowRcsUceAdapter.setCapabilitiesForUri(URI, capability);
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(otherEmptyCapability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(otherEmptyCapability));
 
-    rcsUceAdapter.requestAvailability(OTHER_URI, executorService, verifierCallback);
+    rcsUceAdapter.requestAvailability(
+        OTHER_URI,
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -157,9 +174,12 @@ public class ShadowRcsUceAdapterSTest {
   public void setCapabilitiesFailureForUri_requestAvailability_failsForUri() throws Exception {
     CapabilityFailureInfo failureInfo = CapabilityFailureInfo.create(ERROR_CODE, RETRY_MILLIS);
     ShadowRcsUceAdapter.setCapabilitiesFailureForUri(URI, failureInfo);
-    ErrorVerifierCallback verifierCallback = new ErrorVerifierCallback(failureInfo);
+    ErrorVerifierCallbackDelegate verifierCallback = new ErrorVerifierCallbackDelegate(failureInfo);
 
-    rcsUceAdapter.requestAvailability(URI, executorService, verifierCallback);
+    rcsUceAdapter.requestAvailability(
+        URI,
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
@@ -173,27 +193,29 @@ public class ShadowRcsUceAdapterSTest {
     ShadowRcsUceAdapter.setCapabilitiesFailureForUri(URI, failureInfo);
     RcsContactUceCapability otherEmptyCapability =
         new RcsContactUceCapability.OptionsBuilder(OTHER_URI).build();
-    SuccessfulCapabilityVerifierCallback verifierCallback =
-        new SuccessfulCapabilityVerifierCallback(ImmutableList.of(otherEmptyCapability));
+    SuccessfulCapabilityVerifierCallbackDelegate verifierCallback =
+        new SuccessfulCapabilityVerifierCallbackDelegate(ImmutableList.of(otherEmptyCapability));
 
-    rcsUceAdapter.requestAvailability(OTHER_URI, executorService, verifierCallback);
+    rcsUceAdapter.requestAvailability(
+        OTHER_URI,
+        executorService,
+        ReflectionHelpers.createDelegatingProxy(CapabilitiesCallback.class, verifierCallback));
     executorService.shutdown();
     executorService.awaitTermination(10, SECONDS);
 
     verifierCallback.assertExchangeSuccessfullyCompleted();
   }
 
-  private static class SuccessfulCapabilityVerifierCallback implements CapabilitiesCallback {
+  private static class SuccessfulCapabilityVerifierCallbackDelegate {
     private final List<RcsContactUceCapability> expectedCapabilities;
     private int currentIndex = 0;
     private boolean onCompleteCalled = false;
 
-    private SuccessfulCapabilityVerifierCallback(
+    private SuccessfulCapabilityVerifierCallbackDelegate(
         List<RcsContactUceCapability> expectedCapabilities) {
       this.expectedCapabilities = expectedCapabilities;
     }
 
-    @Override
     public void onCapabilitiesReceived(List<RcsContactUceCapability> contactCapabilities) {
       if (onCompleteCalled) {
         Assert.fail();
@@ -205,12 +227,10 @@ public class ShadowRcsUceAdapterSTest {
       }
     }
 
-    @Override
     public void onComplete() {
       onCompleteCalled = true;
     }
 
-    @Override
     public void onError(int i, long l) {
       Assert.fail();
     }
@@ -221,25 +241,22 @@ public class ShadowRcsUceAdapterSTest {
     }
   }
 
-  private static class ErrorVerifierCallback implements CapabilitiesCallback {
+  private static class ErrorVerifierCallbackDelegate {
     private final CapabilityFailureInfo failureInfo;
     private boolean onErrorCalled = false;
 
-    private ErrorVerifierCallback(CapabilityFailureInfo failureInfo) {
+    private ErrorVerifierCallbackDelegate(CapabilityFailureInfo failureInfo) {
       this.failureInfo = failureInfo;
     }
 
-    @Override
     public void onCapabilitiesReceived(List<RcsContactUceCapability> contactCapabilities) {
       Assert.fail();
     }
 
-    @Override
     public void onComplete() {
       Assert.fail();
     }
 
-    @Override
     public void onError(int errorCode, long retryMillis) {
       assertThat(errorCode).isEqualTo(failureInfo.errorCode());
       assertThat(retryMillis).isEqualTo(failureInfo.retryMillis());
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeAnimatorTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeAnimatorTest.java
index d19bb672b..b0a72dda5 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeAnimatorTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeAnimatorTest.java
@@ -14,8 +14,11 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowRenderNodeAnimatorTest {
   private Activity activity;
   private View view;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeTest.java
index addc4f31a..36525f490 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRenderNodeTest.java
@@ -15,6 +15,8 @@ import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.util.ReflectionHelpers;
 
 /**
@@ -22,6 +24,7 @@ import org.robolectric.util.ReflectionHelpers;
  * RenderNode} was moved to a public API to open access to it.
  */
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public final class ShadowRenderNodeTest {
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
index 5f9ceabe4..f9ad43163 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowResourcesTest.java
@@ -33,8 +33,11 @@ import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.ResourcesMode;
+import org.robolectric.annotation.ResourcesMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@ResourcesMode(Mode.BINARY)
 public class ShadowResourcesTest {
   private static final int FIRST_RESOURCE_COLOR_ID = android.R.color.system_neutral1_0;
   private static final int LAST_RESOURCE_COLOR_ID = android.R.color.system_accent3_1000;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
index 8712a45e9..114ecfab6 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRestrictionsManagerTest.java
@@ -1,8 +1,10 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.content.RestrictionEntry;
 import android.content.RestrictionsManager;
@@ -13,6 +15,8 @@ import com.google.common.collect.Iterables;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
 
 @RunWith(AndroidJUnit4.class)
 public final class ShadowRestrictionsManagerTest {
@@ -48,4 +52,31 @@ public final class ShadowRestrictionsManagerTest {
 
     assertThat(restrictionEntry.getKey()).isEqualTo("restrictionKey");
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void restrictionsManager_activityContextEnabled_hasConsistentRestrictionsProvider() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      RestrictionsManager applicationRestrictionsManager =
+          ApplicationProvider.getApplicationContext().getSystemService(RestrictionsManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      RestrictionsManager activityRestrictionsManager =
+          activity.getSystemService(RestrictionsManager.class);
+
+      assertThat(applicationRestrictionsManager).isNotSameInstanceAs(activityRestrictionsManager);
+
+      boolean applicationHasProvider = applicationRestrictionsManager.hasRestrictionsProvider();
+      boolean activityHasProvider = activityRestrictionsManager.hasRestrictionsProvider();
+
+      assertThat(activityHasProvider).isEqualTo(applicationHasProvider);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
index df472eb36..7e9fbd63f 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRoleManagerTest.java
@@ -6,6 +6,7 @@ import static org.junit.Assert.assertThrows;
 import static org.robolectric.RuntimeEnvironment.getApplication;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.role.RoleManager;
 import android.content.Context;
 import android.os.Build;
@@ -15,7 +16,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit tests for {@link org.robolectric.shadows.ShadowRoleManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -127,4 +130,30 @@ public final class ShadowRoleManagerTest {
                 .setDefaultApplication(
                     "bogus.role", "test.app", 0, directExecutor(), result -> {}));
   }
+
+  @Test
+  public void roleManager_activityContextEnabled_differentInstancesRetrieveRoles() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      RoleManager applicationRoleManager = roleManager;
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      RoleManager activityRoleManager =
+          (RoleManager) activity.getSystemService(Context.ROLE_SERVICE);
+
+      assertThat(applicationRoleManager).isNotSameInstanceAs(activityRoleManager);
+
+      boolean applicationRoleHeld = applicationRoleManager.isRoleHeld(RoleManager.ROLE_SMS);
+      boolean activityRoleHeld = activityRoleManager.isRoleHeld(RoleManager.ROLE_SMS);
+
+      assertThat(activityRoleHeld).isEqualTo(applicationRoleHeld);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
index 0e714e074..73ea33044 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowRollbackManagerTest.java
@@ -4,6 +4,8 @@ import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.shadow.api.Shadow.extract;
 
+import android.app.Activity;
+import android.content.Context;
 import android.content.rollback.RollbackInfo;
 import android.content.rollback.RollbackManager;
 import androidx.test.core.app.ApplicationProvider;
@@ -13,6 +15,8 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowRollbackManager}. */
@@ -69,4 +73,36 @@ public final class ShadowRollbackManagerTest {
         .getConstructor(int.class, List.class, boolean.class, List.class, int.class)
         .newInstance(1, ImmutableList.of(), false, ImmutableList.of(), 2);
   }
+
+  @Test
+  public void rollbackManager_reloadPersistedData_differentInstancesRetrieveRollbacks() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      RollbackManager applicationRollbackManager =
+          (RollbackManager)
+              RuntimeEnvironment.getApplication().getSystemService(Context.ROLLBACK_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      RollbackManager activityRollbackManager =
+          (RollbackManager) activity.getSystemService(Context.ROLLBACK_SERVICE);
+
+      assertThat(applicationRollbackManager).isNotSameInstanceAs(activityRollbackManager);
+
+      List<RollbackInfo> applicationAvailableRollbacks =
+          applicationRollbackManager.getAvailableRollbacks();
+      List<RollbackInfo> activityAvailableRollbacks =
+          activityRollbackManager.getAvailableRollbacks();
+
+      assertThat(applicationAvailableRollbacks).isNotNull();
+      assertThat(activityAvailableRollbacks).isNotNull();
+
+      assertThat(activityAvailableRollbacks).isEqualTo(applicationAvailableRollbacks);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
index d0e3e61bb..3a5c837d9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSafetyCenterManagerTest.java
@@ -4,6 +4,8 @@ import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
+import android.app.Activity;
+import android.content.Context;
 import android.os.Build.VERSION_CODES;
 import android.safetycenter.SafetyCenterManager;
 import android.safetycenter.SafetyEvent;
@@ -13,7 +15,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.function.ThrowingRunnable;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -490,4 +494,31 @@ public final class ShadowSafetyCenterManagerTest {
     IllegalArgumentException e = assertThrows(IllegalArgumentException.class, runnable);
     assertThat(e).hasMessageThat().contains(safetySourceId);
   }
+
+  @Test
+  public void safetyCenterManager_activityContextEnabled_differentInstancesCheckEnabled() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SafetyCenterManager applicationSafetyCenterManager =
+          (SafetyCenterManager)
+              RuntimeEnvironment.getApplication().getSystemService(Context.SAFETY_CENTER_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      SafetyCenterManager activitySafetyCenterManager =
+          (SafetyCenterManager) activity.getSystemService(Context.SAFETY_CENTER_SERVICE);
+
+      assertThat(applicationSafetyCenterManager).isNotSameInstanceAs(activitySafetyCenterManager);
+
+      boolean applicationEnabled = applicationSafetyCenterManager.isSafetyCenterEnabled();
+      boolean activityEnabled = activitySafetyCenterManager.isSafetyCenterEnabled();
+
+      assertThat(activityEnabled).isEqualTo(applicationEnabled);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
index 6c5c6ac2d..7a2cb28b9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowScrollViewTest.java
@@ -11,8 +11,12 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowScrollViewTest {
   @Test
   public void shouldSmoothScrollTo() {
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java
new file mode 100644
index 000000000..7bea08531
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSearchManagerTest.java
@@ -0,0 +1,46 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.O;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.Activity;
+import android.app.SearchManager;
+import android.content.ComponentName;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+
+@RunWith(AndroidJUnit4.class)
+public class ShadowSearchManagerTest {
+
+  @Test
+  @Config(minSdk = O)
+  public void
+      searchManager_activityContextEnabled_differentInstancesRetrieveGlobalSearchActivity() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SearchManager applicationSearchManager =
+          RuntimeEnvironment.getApplication().getSystemService(SearchManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      SearchManager activitySearchManager = activity.getSystemService(SearchManager.class);
+
+      assertThat(applicationSearchManager).isNotSameInstanceAs(activitySearchManager);
+
+      ComponentName applicationGlobalSearchActivity =
+          applicationSearchManager.getGlobalSearchActivity();
+      ComponentName activityGlobalSearchActivity = activitySearchManager.getGlobalSearchActivity();
+
+      assertThat(activityGlobalSearchActivity).isEqualTo(applicationGlobalSearchActivity);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
index a1c949aa6..e698662c7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSensorManagerTest.java
@@ -3,10 +3,12 @@ package org.robolectric.shadows;
 import static android.hardware.Sensor.TYPE_ACCELEROMETER;
 import static android.hardware.Sensor.TYPE_ALL;
 import static android.hardware.Sensor.TYPE_GYROSCOPE;
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.hardware.Sensor;
 import android.hardware.SensorDirectChannel;
@@ -26,7 +28,9 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowSensorManagerTest {
@@ -330,4 +334,44 @@ public class ShadowSensorManagerTest {
       return latestSensorEvent;
     }
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void sensorManager_activityContextEnabled_retrievesSameSensors() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SensorManager applicationSensorManager =
+          (SensorManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.SENSOR_SERVICE);
+      activity = Robolectric.setupActivity(TestActivity.class);
+      SensorManager activitySensorManager =
+          (SensorManager) activity.getSystemService(Context.SENSOR_SERVICE);
+
+      assertThat(applicationSensorManager).isNotSameInstanceAs(activitySensorManager);
+
+      List<Sensor> applicationSensors = applicationSensorManager.getSensorList(Sensor.TYPE_ALL);
+      List<Sensor> activitySensors = activitySensorManager.getSensorList(Sensor.TYPE_ALL);
+
+      assertThat(activitySensors).hasSize(applicationSensors.size());
+
+      for (int i = 0; i < applicationSensors.size(); i++) {
+        Sensor appSensor = applicationSensors.get(i);
+        Sensor actSensor = activitySensors.get(i);
+
+        assertThat(appSensor.getName()).isEqualTo(actSensor.getName());
+        assertThat(appSensor.getType()).isEqualTo(actSensor.getType());
+        assertThat(appSensor.getMaximumRange()).isEqualTo(actSensor.getMaximumRange());
+        assertThat(appSensor.getResolution()).isEqualTo(actSensor.getResolution());
+        assertThat(appSensor.getPower()).isEqualTo(actSensor.getPower());
+        assertThat(appSensor.getMinDelay()).isEqualTo(actSensor.getMinDelay());
+      }
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceManagerTest.java
index 8c172775c..e02bcbbaa 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowServiceManagerTest.java
@@ -4,8 +4,11 @@ import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import android.content.Context;
+import android.os.Binder;
 import android.os.Build.VERSION_CODES;
 import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
 import android.os.ServiceManager;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.android.internal.view.IInputMethodManager;
@@ -15,6 +18,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Tests for {@link ShadowServiceManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -26,6 +30,14 @@ public final class ShadowServiceManagerTest {
     assertThat(ServiceManager.getService(Context.SENSOR_PRIVACY_SERVICE)).isNotNull();
   }
 
+  @Test
+  @Config(sdk = V.SDK_INT)
+  public void getSensitiveContentProtectionManager_returnsSomething() {
+    // TODO: replace with Context.SENSITIVE_CONTENT_PROTECTION_SERVICE once this test compiles
+    // against V
+    assertThat(ServiceManager.getService("sensitive_content_protection_service")).isNotNull();
+  }
+
   @Test
   public void getService_available_shouldReturnNonNull() {
     assertThat(ServiceManager.getService(Context.INPUT_METHOD_SERVICE)).isNotNull();
@@ -69,4 +81,44 @@ public final class ShadowServiceManagerTest {
     e.awaitTermination(10, SECONDS);
     assertThat(thrownException.get()).isNull();
   }
+
+  @Test
+  public void addService_concrete_shouldReturnService() throws RemoteException {
+    StubbedInterface expectedStub = new StubbedInterface();
+    ShadowServiceManager.addBinderService("activity_task", IStubbedInterface.class, expectedStub);
+
+    IBinder iBinder = ServiceManager.getService("activity_task");
+    IStubbedInterface foundStub = StubbedInterface.Stub.asInterface(iBinder);
+
+    foundStub.reportCalled();
+    assertThat(expectedStub.called).isTrue();
+  }
+
+  // Stub interface to test that the service is returned correctly
+  private static class StubbedInterface implements IStubbedInterface {
+
+    IBinder binder = new Binder();
+    boolean called = false;
+
+    public abstract static class Stub extends Binder implements IStubbedInterface {
+      public static IStubbedInterface asInterface(IBinder obj) {
+        IInterface inter = obj.queryLocalInterface(IStubbedInterface.class.getCanonicalName());
+        return (IStubbedInterface) inter;
+      }
+    }
+
+    @Override
+    public IBinder asBinder() {
+      return binder;
+    }
+
+    @Override
+    public void reportCalled() {
+      called = true;
+    }
+  }
+
+  interface IStubbedInterface extends IInterface {
+    void reportCalled() throws RemoteException;
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
index b72345309..cf3c34ac0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSharedPreferencesTest.java
@@ -146,6 +146,7 @@ public class ShadowSharedPreferencesTest {
     editor.commit();
 
     assertThat(sharedPreferences.getString("deleteMe", null)).isNull();
+    assertThat(sharedPreferences.contains("deleteMe")).isFalse();
   }
 
   @Test
@@ -156,6 +157,7 @@ public class ShadowSharedPreferencesTest {
     editor.commit();
 
     assertThat(sharedPreferences.getStringSet("deleteMe", null)).isNull();
+    assertThat(sharedPreferences.contains("deleteMe")).isFalse();
   }
 
   @Test
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
index f42d9e1cb..3e496a901 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowShortcutManagerTest.java
@@ -4,12 +4,14 @@ import static android.content.pm.ShortcutManager.FLAG_MATCH_CACHED;
 import static android.content.pm.ShortcutManager.FLAG_MATCH_DYNAMIC;
 import static android.content.pm.ShortcutManager.FLAG_MATCH_MANIFEST;
 import static android.content.pm.ShortcutManager.FLAG_MATCH_PINNED;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.R;
 import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.content.pm.ShortcutInfo;
 import android.content.pm.ShortcutManager;
@@ -22,6 +24,7 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -386,4 +389,34 @@ public final class ShadowShortcutManagerTest {
         .setLongLabel(longLabel)
         .build();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void shortcutManager_activityContextEnabled_differentInstancesCheckRateLimiting() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      ShortcutManager applicationShortcutManager =
+          (ShortcutManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.SHORTCUT_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      ShortcutManager activityShortcutManager =
+          (ShortcutManager) activity.getSystemService(Context.SHORTCUT_SERVICE);
+
+      assertThat(applicationShortcutManager).isNotSameInstanceAs(activityShortcutManager);
+
+      boolean applicationRateLimiting = applicationShortcutManager.isRateLimitingActive();
+      boolean activityRateLimiting = activityShortcutManager.isRateLimitingActive();
+
+      assertThat(activityRateLimiting).isEqualTo(applicationRateLimiting);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
index e057a29fd..d94063c71 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSliceManagerTest.java
@@ -3,19 +3,23 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.slice.SliceManager;
 import android.app.slice.SliceSpec;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build.VERSION_CODES;
+import android.util.ArraySet;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 
@@ -93,4 +97,41 @@ public final class ShadowSliceManagerTest {
     assertThat(sliceManager.getPinnedSlices()).isEmpty();
     assertThat(sliceManager.getPinnedSpecs(sliceUri1)).isEmpty();
   }
+
+  @Test
+  public void sliceManager_activityContextEnabled_differentInstancesRetrieveSlices() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SliceManager applicationSliceManager =
+          ApplicationProvider.getApplicationContext().getSystemService(SliceManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      SliceManager activitySliceManager = activity.getSystemService(SliceManager.class);
+
+      assertThat(applicationSliceManager).isNotSameInstanceAs(activitySliceManager);
+
+      Uri testUri = Uri.parse("content://com.example.slice/uri");
+
+      Set<SliceSpec> specs = new ArraySet<>();
+      specs.add(new SliceSpec("v1", 1));
+
+      applicationSliceManager.pinSlice(testUri, specs);
+      activitySliceManager.unpinSlice(testUri);
+
+      Set<SliceSpec> applicationSpecs = applicationSliceManager.getPinnedSpecs(testUri);
+      Set<SliceSpec> activitySpecs = activitySliceManager.getPinnedSpecs(testUri);
+      assertThat(applicationSpecs).isEqualTo(activitySpecs);
+
+      List<Uri> applicationPinnedSlices = applicationSliceManager.getPinnedSlices();
+      List<Uri> activityPinnedSlices = activitySliceManager.getPinnedSlices();
+      assertThat(applicationPinnedSlices).isEqualTo(activityPinnedSlices);
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
index 1c895bb27..50ada18f9 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatsManagerTest.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static com.google.common.truth.Truth.assertThat;
 
 import android.app.StatsManager;
-import android.content.Context;
 import android.os.Build;
 import androidx.test.core.app.ApplicationProvider;
 import org.junit.Test;
@@ -11,25 +10,35 @@ import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-/** Tests for {@link ShadowStatsManager} */
+/** Tests for {@link ShadowStatsManager}. */
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = Build.VERSION_CODES.P)
 public final class ShadowStatsManagerTest {
 
   @Test
   public void testGetMetadata() throws Exception {
-    Context context = ApplicationProvider.getApplicationContext();
-    StatsManager statsManager = context.getSystemService(StatsManager.class);
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     byte[] metadataBytes = new byte[] {1, 2, 3, 4, 5};
     ShadowStatsManager.setStatsMetadata(metadataBytes);
 
     assertThat(statsManager.getMetadata()).isEqualTo(metadataBytes);
   }
 
+  @Test
+  public void testGetStatsMetadata() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    byte[] metadataBytes = new byte[] {1, 2, 3, 4, 5};
+    ShadowStatsManager.setStatsMetadata(metadataBytes);
+
+    assertThat(statsManager.getStatsMetadata()).isEqualTo(metadataBytes);
+  }
+
   @Test
   public void testGetReports_multipleReports() throws Exception {
-    Context context = ApplicationProvider.getApplicationContext();
-    StatsManager statsManager = context.getSystemService(StatsManager.class);
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     long reportId1 = 1L;
     long reportId2 = 2L;
     byte[] report1Bytes = new byte[] {1, 2, 3, 4, 5};
@@ -43,8 +52,8 @@ public final class ShadowStatsManagerTest {
 
   @Test
   public void testGetReports_clearsExistingReport() throws Exception {
-    Context context = ApplicationProvider.getApplicationContext();
-    StatsManager statsManager = context.getSystemService(StatsManager.class);
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     long reportId1 = 1L;
     byte[] report1Bytes = new byte[] {1, 2, 3, 4, 5};
     ShadowStatsManager.addReportData(reportId1, report1Bytes);
@@ -53,10 +62,41 @@ public final class ShadowStatsManagerTest {
     assertThat(statsManager.getReports(reportId1)).isEqualTo(new byte[] {});
   }
 
+  @Test
+  public void testAddConfig() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long configId1 = 1L;
+    long configId2 = 2L;
+    byte[] config1Bytes = new byte[] {1, 2, 3, 4, 5};
+    byte[] config2Bytes = new byte[] {1, 2, 3};
+    statsManager.addConfig(configId1, config1Bytes);
+    statsManager.addConfig(configId2, config2Bytes);
+
+    assertThat(ShadowStatsManager.getConfigData(configId1)).isEqualTo(config1Bytes);
+    assertThat(ShadowStatsManager.getConfigData(configId2)).isEqualTo(config2Bytes);
+  }
+
+  @Test
+  public void testRemoveConfig() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long configId1 = 1L;
+    long configId2 = 2L;
+    byte[] config1Bytes = new byte[] {1, 2, 3, 4, 5};
+    byte[] config2Bytes = new byte[] {1, 2, 3};
+    statsManager.addConfig(configId1, config1Bytes);
+    statsManager.addConfig(configId2, config2Bytes);
+    statsManager.removeConfig(configId1);
+
+    assertThat(ShadowStatsManager.getConfigData(configId1)).isEqualTo(new byte[] {});
+    assertThat(ShadowStatsManager.getConfigData(configId2)).isEqualTo(config2Bytes);
+  }
+
   @Test
   public void testReset_clearsReports() throws Exception {
-    Context context = ApplicationProvider.getApplicationContext();
-    StatsManager statsManager = context.getSystemService(StatsManager.class);
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     long reportId1 = 1L;
     byte[] report1Bytes = new byte[] {1, 2, 3, 4, 5};
     ShadowStatsManager.addReportData(reportId1, report1Bytes);
@@ -68,8 +108,8 @@ public final class ShadowStatsManagerTest {
 
   @Test
   public void testReset_clearsMetadata() throws Exception {
-    Context context = ApplicationProvider.getApplicationContext();
-    StatsManager statsManager = context.getSystemService(StatsManager.class);
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
     byte[] metadataBytes = new byte[] {1, 2, 3, 4, 5};
     ShadowStatsManager.setStatsMetadata(metadataBytes);
 
@@ -77,4 +117,17 @@ public final class ShadowStatsManagerTest {
 
     assertThat(statsManager.getMetadata()).isEqualTo(new byte[] {});
   }
+
+  @Test
+  public void testReset_clearsConfigs() throws Exception {
+    StatsManager statsManager =
+        ApplicationProvider.getApplicationContext().getSystemService(StatsManager.class);
+    long config1Id = 1L;
+    byte[] config1Bytes = new byte[] {1, 2, 3, 4, 5};
+    statsManager.addConfig(config1Id, config1Bytes);
+
+    ShadowStatsManager.reset();
+
+    assertThat(ShadowStatsManager.getConfigData(config1Id)).isEqualTo(new byte[] {});
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
index a602c54a7..7aa82d259 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStatusBarManagerTest.java
@@ -1,17 +1,20 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.app.StatusBarManager;
 import android.content.Context;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -28,7 +31,7 @@ public final class ShadowStatusBarManagerTest {
   private final ShadowStatusBarManager shadowStatusBarManager = Shadow.extract(statusBarManager);
 
   @Test
-  public void getDisable() throws ClassNotFoundException {
+  public void getDisable() {
     statusBarManager.disable(ShadowStatusBarManager.DEFAULT_DISABLE_MASK);
     assertThat(shadowStatusBarManager.getDisableFlags())
         .isEqualTo(ShadowStatusBarManager.DEFAULT_DISABLE_MASK);
@@ -36,7 +39,7 @@ public final class ShadowStatusBarManagerTest {
 
   @Test
   @Config(minSdk = M)
-  public void getDisable2() throws ClassNotFoundException {
+  public void getDisable2() {
     statusBarManager.disable2(ShadowStatusBarManager.DEFAULT_DISABLE2_MASK);
     assertThat(shadowStatusBarManager.getDisable2Flags())
         .isEqualTo(ShadowStatusBarManager.DEFAULT_DISABLE2_MASK);
@@ -67,15 +70,61 @@ public final class ShadowStatusBarManagerTest {
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void getNavBarMode_returnsNavBarMode() throws Exception {
+  public void getNavBarMode_returnsNavBarMode() {
     statusBarManager.setNavBarMode(TEST_NAV_BAR_MODE);
     assertThat(shadowStatusBarManager.getNavBarMode()).isEqualTo(TEST_NAV_BAR_MODE);
   }
 
   @Config(minSdk = TIRAMISU)
   @Test
-  public void setNavBarMode_storesNavBarMode() throws Exception {
+  public void setNavBarMode_storesNavBarMode() {
     shadowStatusBarManager.setNavBarMode(TEST_NAV_BAR_MODE);
     assertThat(shadowStatusBarManager.getNavBarMode()).isEqualTo(TEST_NAV_BAR_MODE);
   }
+
+  @Test
+  public void reset_returnsExpectedDefaultModes() {
+    assertThat(shadowStatusBarManager.getNavBarMode())
+        .isEqualTo(StatusBarManager.NAV_BAR_MODE_DEFAULT);
+    assertThat(shadowStatusBarManager.getDisableFlags()).isEqualTo(StatusBarManager.DISABLE_NONE);
+    assertThat(shadowStatusBarManager.getDisable2Flags()).isEqualTo(StatusBarManager.DISABLE2_NONE);
+  }
+
+  @Test
+  @Config(minSdk = O)
+  public void statusBarManager_activityContextEnabled_performOperations() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      StatusBarManager applicationStatusBarManager =
+          RuntimeEnvironment.getApplication().getSystemService(StatusBarManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      StatusBarManager activityStatusBarManager = activity.getSystemService(StatusBarManager.class);
+
+      assertThat(applicationStatusBarManager).isNotSameInstanceAs(activityStatusBarManager);
+
+      ShadowStatusBarManager applicationShadowStatusBarManager =
+          Shadow.extract(applicationStatusBarManager);
+      ShadowStatusBarManager activityShadowStatusBarManager =
+          Shadow.extract(activityStatusBarManager);
+
+      applicationStatusBarManager.disable(StatusBarManager.DISABLE_EXPAND);
+      assertThat(applicationShadowStatusBarManager.getDisableFlags())
+          .isEqualTo(StatusBarManager.DISABLE_EXPAND);
+      assertThat(activityShadowStatusBarManager.getDisableFlags())
+          .isEqualTo(StatusBarManager.DISABLE_EXPAND);
+
+      activityShadowStatusBarManager.disable2(StatusBarManager.DISABLE2_GLOBAL_ACTIONS);
+      assertThat(applicationShadowStatusBarManager.getDisable2Flags())
+          .isEqualTo(StatusBarManager.DISABLE2_GLOBAL_ACTIONS);
+      assertThat(activityShadowStatusBarManager.getDisable2Flags())
+          .isEqualTo(StatusBarManager.DISABLE2_GLOBAL_ACTIONS);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
index cd7841598..bf26b777e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowStorageManagerTest.java
@@ -1,12 +1,14 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.RuntimeEnvironment.getApplication;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.Parcel;
 import android.os.UserHandle;
@@ -19,6 +21,8 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.ReflectionHelpers;
 
@@ -133,4 +137,31 @@ public class ShadowStorageManagerTest {
             "volume" + " " + description, file, description, userHandle, "mounted");
     return storageVolumeBuilder.build();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void storageManager_activityContextEnabled_differentInstancesRetrieveVolumes() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      StorageManager applicationStorageManager =
+          RuntimeEnvironment.getApplication().getSystemService(StorageManager.class);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      StorageManager activityStorageManager = activity.getSystemService(StorageManager.class);
+
+      assertThat(applicationStorageManager).isNotSameInstanceAs(activityStorageManager);
+
+      List<StorageVolume> applicationVolumes = applicationStorageManager.getStorageVolumes();
+      List<StorageVolume> activityVolumes = activityStorageManager.getStorageVolumes();
+
+      assertThat(activityVolumes).isEqualTo(applicationVolumes);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
index 8ebde3424..92dc8fb14 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSubscriptionManagerTest.java
@@ -2,16 +2,20 @@ package org.robolectric.shadows;
 
 import static android.content.Context.TELEPHONY_SUBSCRIPTION_SERVICE;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
+import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
 import android.telephony.SubscriptionInfo;
@@ -20,8 +24,11 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowSubscriptionManager.SubscriptionInfoBuilder;
+import org.robolectric.shadows.testing.TestActivity;
 
 /** Test for {@link ShadowSubscriptionManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -398,6 +405,80 @@ public class ShadowSubscriptionManagerTest {
         .isEqualTo(ShadowSubscriptionManager.INVALID_PHONE_INDEX);
   }
 
+  @Test
+  public void getSubId() {
+    // Explicitly callable without any permissions.
+    shadowOf(subscriptionManager).setReadPhoneStatePermission(false);
+
+    assertThat(SubscriptionManager.getSubId(/* slotIndex= */ 0)).isNull();
+
+    shadowOf(subscriptionManager)
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(123)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo(),
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(456)
+                .setSimSlotIndex(1)
+                .buildSubscriptionInfo());
+    int[] subId = SubscriptionManager.getSubId(/* slotIndex= */ 0);
+    assertThat(subId).hasLength(1);
+    assertThat(subId[0]).isEqualTo(123);
+
+    assertThat(SubscriptionManager.getSubId(/* slotIndex= */ 2)).isNull();
+  }
+
+  @Test
+  @Config(minSdk = Q)
+  public void getSubscriptionIds() {
+    // Explicitly callable without any permissions.
+    shadowOf(subscriptionManager).setReadPhoneStatePermission(false);
+
+    assertThat(subscriptionManager.getSubscriptionIds(/* slotIndex= */ 0)).isNull();
+
+    shadowOf(subscriptionManager)
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(123)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo(),
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(456)
+                .setSimSlotIndex(1)
+                .buildSubscriptionInfo());
+    int[] subId = subscriptionManager.getSubscriptionIds(/* slotIndex= */ 0);
+    assertThat(subId).hasLength(1);
+    assertThat(subId[0]).isEqualTo(123);
+
+    assertThat(subscriptionManager.getSubscriptionIds(/* slotIndex= */ 2)).isNull();
+  }
+
+  @Test
+  @Config(minSdk = UPSIDE_DOWN_CAKE)
+  public void getSubscriptionId() {
+    // Explicitly callable without any permissions.
+    shadowOf(subscriptionManager).setReadPhoneStatePermission(false);
+
+    assertThat(SubscriptionManager.getSubscriptionId(/* slotIndex= */ 0))
+        .isEqualTo(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+
+    shadowOf(subscriptionManager)
+        .setActiveSubscriptionInfos(
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(123)
+                .setSimSlotIndex(0)
+                .buildSubscriptionInfo(),
+            SubscriptionInfoBuilder.newBuilder()
+                .setId(456)
+                .setSimSlotIndex(1)
+                .buildSubscriptionInfo());
+    assertThat(SubscriptionManager.getSubscriptionId(/* slotIndex= */ 0)).isEqualTo(123);
+
+    assertThat(SubscriptionManager.getSubscriptionId(/* slotIndex= */ 2))
+        .isEqualTo(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+  }
+
   @Test
   public void setMcc() {
     assertThat(
@@ -518,4 +599,37 @@ public class ShadowSubscriptionManagerTest {
       subscriptionChangedCount++;
     }
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void
+      subscriptionManager_activityContextEnabled_differentInstancesRetrieveDefaultSubscriptionInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SubscriptionManager applicationSubscriptionManager =
+          (SubscriptionManager)
+              RuntimeEnvironment.getApplication()
+                  .getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+      activity = Robolectric.setupActivity(TestActivity.class);
+      SubscriptionManager activitySubscriptionManager =
+          (SubscriptionManager) activity.getSystemService(Context.TELEPHONY_SUBSCRIPTION_SERVICE);
+
+      assertThat(applicationSubscriptionManager).isNotSameInstanceAs(activitySubscriptionManager);
+
+      int defaultSubscriptionId = SubscriptionManager.getDefaultSubscriptionId();
+      SubscriptionInfo applicationDefaultSubscriptionInfo =
+          applicationSubscriptionManager.getActiveSubscriptionInfo(defaultSubscriptionId);
+      SubscriptionInfo activityDefaultSubscriptionInfo =
+          activitySubscriptionManager.getActiveSubscriptionInfo(defaultSubscriptionId);
+
+      assertThat(applicationDefaultSubscriptionInfo).isEqualTo(activityDefaultSubscriptionInfo);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
index 983a4441f..ecc7f2344 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTest.java
@@ -22,9 +22,12 @@ import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 /** Tests for {@link ShadowSurface}. */
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowSurfaceTest {
   private final SurfaceTexture texture = new SurfaceTexture(0);
   private final Surface surface = new Surface(texture);
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTextureTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTextureTest.java
index b3811789e..d7fbfddcd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTextureTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSurfaceTextureTest.java
@@ -12,9 +12,12 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 /** Tests for {@link ShadowSurfaceTexture}. */
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowSurfaceTextureTest {
   private final SurfaceTexture surfaceTexture = new SurfaceTexture(0);
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
index 6a95c9229..79bd67c6b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowSystemHealthManagerTest.java
@@ -1,8 +1,10 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.content.Context;
 import android.os.Process;
 import android.os.health.HealthStats;
@@ -12,6 +14,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -72,4 +75,32 @@ public final class ShadowSystemHealthManagerTest {
     assertThat(stats[1]).isEqualTo(MY_UID_HEALTH_STATS);
     assertThat(stats[2]).isEqualTo(OTHER_UID_2_HEALTH_STATS);
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void
+      systemHealthManager_activityContextEnabled_differentInstancesRetrieveSameUidSnapshot() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      SystemHealthManager applicationSystemHealthManager =
+          ApplicationProvider.getApplicationContext().getSystemService(SystemHealthManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      SystemHealthManager activitySystemHealthManager =
+          activity.getSystemService(SystemHealthManager.class);
+
+      assertThat(applicationSystemHealthManager).isNotSameInstanceAs(activitySystemHealthManager);
+
+      HealthStats applicationHealthStats = applicationSystemHealthManager.takeMyUidSnapshot();
+      HealthStats activityHealthStats = activitySystemHealthManager.takeMyUidSnapshot();
+
+      assertThat(activityHealthStats).isEqualTo(applicationHealthStats);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
index 534526be6..f00e06f56 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelecomManagerTest.java
@@ -15,12 +15,14 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.telecom.ConnectionRequest;
 import android.telecom.PhoneAccount;
@@ -38,9 +40,11 @@ import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
+import org.robolectric.Robolectric;
 import org.robolectric.android.controller.ServiceController;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowTelecomManager.CallRequestMode;
+import org.robolectric.shadows.testing.TestActivity;
 import org.robolectric.shadows.testing.TestConnectionService;
 
 @RunWith(AndroidJUnit4.class)
@@ -748,4 +752,31 @@ public class ShadowTelecomManagerTest {
   private static PhoneAccountHandle createHandle(String packageName, String className, String id) {
     return new PhoneAccountHandle(new ComponentName(packageName, className), id);
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.O)
+  public void telecomManager_activityContextEnabled_differentInstancesRetrieveDefaultDialer() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      TelecomManager applicationTelecomManager =
+          (TelecomManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.TELECOM_SERVICE);
+
+      activity = Robolectric.setupActivity(TestActivity.class);
+      TelecomManager activityTelecomManager =
+          (TelecomManager) activity.getSystemService(Context.TELECOM_SERVICE);
+
+      String applicationDefaultDialer = applicationTelecomManager.getDefaultDialerPackage();
+      String activityDefaultDialer = activityTelecomManager.getDefaultDialerPackage();
+
+      assertThat(activityDefaultDialer).isEqualTo(applicationDefaultDialer);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
index ead36aeea..cc4cdce9b 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTelephonyManagerTest.java
@@ -45,6 +45,7 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowTelephonyManager.createTelephonyDisplayInfo;
 
 import android.Manifest.permission;
+import android.app.Activity;
 import android.app.Application;
 import android.content.ComponentName;
 import android.content.Context;
@@ -70,7 +71,6 @@ import android.telephony.TelephonyCallback.ServiceStateListener;
 import android.telephony.TelephonyCallback.SignalStrengthsListener;
 import android.telephony.TelephonyDisplayInfo;
 import android.telephony.TelephonyManager;
-import android.telephony.TelephonyManager.AuthenticationFailureReason;
 import android.telephony.TelephonyManager.BootstrapAuthenticationCallback;
 import android.telephony.TelephonyManager.CellInfoCallback;
 import android.telephony.UiccSlotInfo;
@@ -90,6 +90,7 @@ import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
@@ -1323,14 +1324,7 @@ public class ShadowTelephonyManagerTest {
   @Test
   @Config(minSdk = S)
   public void getBootstrapAuthenticationCallback() {
-    BootstrapAuthenticationCallback callback =
-        new BootstrapAuthenticationCallback() {
-          @Override
-          public void onKeysAvailable(byte[] gbaKey, String transactionId) {}
-
-          @Override
-          public void onAuthenticationFailure(@AuthenticationFailureReason int reason) {}
-        };
+    BootstrapAuthenticationCallback callback = mock(BootstrapAuthenticationCallback.class);
 
     telephonyManager.bootstrapAuthenticationRequest(
         TelephonyManager.APPTYPE_ISIM,
@@ -1547,4 +1541,33 @@ public class ShadowTelephonyManagerTest {
   public void rebootModem_noModifyPhoneStatePermission_throwsSecurityException() {
     assertThrows(SecurityException.class, () -> shadowTelephonyManager.rebootModem());
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void telephonyManager_activityContextEnabled_differentInstancesRetrievePhoneCount() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      TelephonyManager applicationTelephonyManager =
+          (TelephonyManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.TELEPHONY_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      TelephonyManager activityTelephonyManager =
+          (TelephonyManager) activity.getSystemService(Context.TELEPHONY_SERVICE);
+
+      assertThat(applicationTelephonyManager).isNotSameInstanceAs(activityTelephonyManager);
+
+      int applicationPhoneCount = applicationTelephonyManager.getPhoneCount();
+      int activityPhoneCount = activityTelephonyManager.getPhoneCount();
+
+      assertThat(activityPhoneCount).isEqualTo(applicationPhoneCount);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextClassifierServiceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextClassifierServiceTest.java
new file mode 100644
index 000000000..60e859b06
--- /dev/null
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextClassifierServiceTest.java
@@ -0,0 +1,45 @@
+package org.robolectric.shadows;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.view.textclassifier.TextClassifier;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public final class ShadowTextClassifierServiceTest {
+  TextClassifier textClassifier = new TextClassifier() {};
+  Context context;
+
+  @Before
+  public void setUp() {
+    context = ApplicationProvider.getApplicationContext();
+  }
+
+  @Test
+  public void setDefaultTextClassifierService_returnsDefaultTextClassifier() {
+    ShadowTextClassifierService.setDefaultTextClassifierImplementation(textClassifier);
+
+    assertThat(ShadowTextClassifierService.getDefaultTextClassifierImplementation(context))
+        .isEqualTo(textClassifier);
+  }
+
+  @Test
+  public void resetTextClassifierService_returnsNoOpTextClassifier() {
+    ShadowTextClassifierService.setDefaultTextClassifierImplementation(textClassifier);
+    ShadowTextClassifierService.reset();
+
+    assertThat(ShadowTextClassifierService.getDefaultTextClassifierImplementation(context))
+        .isEqualTo(TextClassifier.NO_OP);
+  }
+
+  @Test
+  public void getDefaultTextClassifierImplementation_returnsNoOpTextClassifier() {
+    assertThat(ShadowTextClassifierService.getDefaultTextClassifierImplementation(context))
+        .isEqualTo(TextClassifier.NO_OP);
+  }
+}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
index 752ea8cdf..e54d01ad1 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTextViewTest.java
@@ -47,9 +47,13 @@ import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.robolectric.R;
 import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadow.api.Shadow;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowTextViewTest {
 
   private static final String INITIAL_TEXT = "initial text";
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
index 0c146d724..998f83063 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowThemeTest.java
@@ -22,6 +22,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.shadows.testing.TestActivity;
 import org.xmlpull.v1.XmlPullParser;
 
@@ -202,6 +203,7 @@ public class ShadowThemeTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void whenStyleSpecifiesAttr_obtainStyledAttribute_findsCorrectValue() {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.Theme_Robolectric, false);
@@ -253,6 +255,7 @@ public class ShadowThemeTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void whenAttrSetAttrSpecifiesAttr_obtainStyledAttribute_returnsItsValue() {
     Resources.Theme theme = resources.newTheme();
     theme.applyStyle(R.style.Theme_Robolectric, false);
@@ -272,6 +275,7 @@ public class ShadowThemeTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void dimenRef() {
     AttributeSet attributeSet =
         Robolectric.buildAttributeSet()
@@ -285,6 +289,7 @@ public class ShadowThemeTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void dimenRefRef() {
     AttributeSet attributeSet =
         Robolectric.buildAttributeSet()
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
index 14aa24297..57c743e84 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTimeManagerTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.app.time.TimeManager;
 import android.app.time.TimeZoneCapabilitiesAndConfig;
 import android.app.time.TimeZoneConfiguration;
@@ -10,6 +11,7 @@ import androidx.test.core.app.ApplicationProvider;
 import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
@@ -56,4 +58,35 @@ public final class ShadowTimeManagerTest {
 
     assertThat(capabilitiesAndConfig.getConfiguration()).isEqualTo(updatedConfiguration);
   }
+
+  @Test
+  @Config(minSdk = Build.VERSION_CODES.S)
+  public void timeManager_activityContextEnabled_differentInstancesRetrieveTimeZoneCapabilities() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      TimeManager applicationTimeManager =
+          ApplicationProvider.getApplicationContext().getSystemService(TimeManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      TimeManager activityTimeManager = activity.getSystemService(TimeManager.class);
+
+      TimeZoneConfiguration timeZoneConfiguration = new TimeZoneConfiguration.Builder().build();
+      applicationTimeManager.updateTimeZoneConfiguration(timeZoneConfiguration);
+
+      assertThat(applicationTimeManager).isNotSameInstanceAs(activityTimeManager);
+
+      TimeZoneCapabilitiesAndConfig applicationCapabilities =
+          applicationTimeManager.getTimeZoneCapabilitiesAndConfig();
+      TimeZoneCapabilitiesAndConfig activityCapabilities =
+          activityTimeManager.getTimeZoneCapabilitiesAndConfig();
+
+      assertThat(activityCapabilities).isEqualTo(applicationCapabilities);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
index acbef389b..05046fc2e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTranslationManagerTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.icu.util.ULocale;
 import android.os.Build.VERSION_CODES;
 import android.view.translation.TranslationCapability;
@@ -10,8 +11,10 @@ import android.view.translation.TranslationSpec;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableSet;
+import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -54,4 +57,34 @@ public class ShadowTranslationManagerTest {
                 TranslationSpec.DATA_FORMAT_TEXT, TranslationSpec.DATA_FORMAT_TEXT))
         .isEqualTo(capabilities);
   }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.S)
+  public void translationManager_activityContextEnabled_differentInstancesRetrieveCapabilities() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      TranslationManager applicationTranslationManager =
+          ApplicationProvider.getApplicationContext().getSystemService(TranslationManager.class);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      TranslationManager activityTranslationManager =
+          activity.getSystemService(TranslationManager.class);
+
+      assertThat(applicationTranslationManager).isNotSameInstanceAs(activityTranslationManager);
+
+      Set<TranslationCapability> applicationCapabilities =
+          applicationTranslationManager.getOnDeviceTranslationCapabilities(1, 2);
+      Set<TranslationCapability> activityCapabilities =
+          activityTranslationManager.getOnDeviceTranslationCapabilities(1, 2);
+
+      assertThat(activityCapabilities).isEqualTo(applicationCapabilities);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
index bc47297bd..3f082bfca 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypedArrayTest.java
@@ -13,6 +13,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.res.AttributeResource;
 
 @RunWith(AndroidJUnit4.class)
@@ -42,6 +43,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getInt_withFlags_shouldReturnValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -60,6 +62,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getResourceId_shouldReturnActualValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -78,6 +81,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getFraction_shouldReturnGivenValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -94,6 +98,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getDimension_shouldReturnGivenValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -103,6 +108,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getDrawable_withExplicitColorValue_shouldReturnColorDrawable() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -115,6 +121,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getTextArray_whenNoSuchAttribute_shouldReturnNull() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -130,6 +137,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void getTextArray_shouldReturnValues() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -141,6 +149,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void hasValue_withValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -158,6 +167,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void hasValue_withNullValue() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
@@ -169,6 +179,7 @@ public class ShadowTypedArrayTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void shouldEnumeratePresentValues() {
     TypedArray typedArray =
         context.obtainStyledAttributes(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
index 504acb9ad..0eaf7e037 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowTypefaceTest.java
@@ -20,11 +20,16 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.shadows.ShadowLog.LogItem;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.TestUtil;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+@ResourcesMode(ResourcesMode.Mode.BINARY)
 public class ShadowTypefaceTest {
 
   private File fontFile;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
index 6ecfd1e2e..41be49195 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsageStatsManagerTest.java
@@ -8,7 +8,9 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.app.Activity;
 import android.app.Application;
 import android.app.PendingIntent;
 import android.app.usage.BroadcastResponseStats;
@@ -16,8 +18,10 @@ import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
 import android.app.usage.UsageStats;
 import android.app.usage.UsageStatsManager;
+import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
+import android.os.PersistableBundle;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.collect.ImmutableList;
@@ -29,11 +33,17 @@ import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowUsageStatsManager.AppUsageLimitObserver;
 import org.robolectric.shadows.ShadowUsageStatsManager.AppUsageObserver;
+import org.robolectric.shadows.ShadowUsageStatsManager.EventReflector;
 import org.robolectric.shadows.ShadowUsageStatsManager.UsageSessionObserver;
 import org.robolectric.shadows.ShadowUsageStatsManager.UsageStatsBuilder;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Test for {@link ShadowUsageStatsManager}. */
 @RunWith(AndroidJUnit4.class)
@@ -1030,4 +1040,132 @@ public class ShadowUsageStatsManagerTest {
     assertThat(usageStatsManager.queryBroadcastResponseStats(null, BUCKET_ID_1))
         .containsExactly(app1Stats, app2Stats);
   }
+
+  @Test
+  @Config(minSdk = 28)
+  public void usageStatsManager_activityContextEnabled_differentInstancesRetrieveBuckets() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      UsageStatsManager applicationUsageStatsManager =
+          (UsageStatsManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.USAGE_STATS_SERVICE);
+
+      activity = Robolectric.setupActivity(Activity.class);
+      UsageStatsManager activityUsageStatsManager =
+          (UsageStatsManager) activity.getSystemService(Context.USAGE_STATS_SERVICE);
+
+      assertThat(applicationUsageStatsManager).isNotSameInstanceAs(activityUsageStatsManager);
+
+      int applicationBucket = applicationUsageStatsManager.getAppStandbyBucket();
+      int activityBucket = activityUsageStatsManager.getAppStandbyBucket();
+
+      assertThat(applicationBucket).isEqualTo(activityBucket);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
+
+  @Test
+  @Config(minSdk = V.SDK_INT)
+  public void testQueryEvents_newApiV_shouldReturn() throws Exception {
+    // These events should be returned.
+    shadowOf(usageStatsManager)
+        .addEvent(
+            ShadowUsageStatsManager.EventBuilder.buildEvent()
+                .setTimeStamp(1000L)
+                .setPackage(TEST_PACKAGE_NAME1)
+                .setEventType(Event.MOVE_TO_BACKGROUND)
+                .build());
+    shadowOf(usageStatsManager)
+        .addEvent(
+            ShadowUsageStatsManager.EventBuilder.buildEvent()
+                .setTimeStamp(1001L)
+                .setPackage(TEST_PACKAGE_NAME1)
+                .setEventType(Event.MOVE_TO_FOREGROUND)
+                .build());
+    PersistableBundle extras = new PersistableBundle();
+    extras.putString("fakekey", "fakevalue");
+    shadowOf(usageStatsManager)
+        .addEvent(
+            ShadowUsageStatsManager.EventBuilder.buildEvent()
+                .setTimeStamp(1500L)
+                .setPackage(TEST_PACKAGE_NAME2)
+                .setEventType(Event.USER_INTERACTION)
+                .setExtras(extras)
+                .build());
+
+    // These events should be filtered out.
+    // Timestamp too late.
+    shadowOf(usageStatsManager)
+        .addEvent(
+            ShadowUsageStatsManager.EventBuilder.buildEvent()
+                .setTimeStamp(3000L)
+                .setPackage(TEST_PACKAGE_NAME1)
+                .setEventType(Event.USER_INTERACTION)
+                .build());
+    // Wrong type.
+    shadowOf(usageStatsManager)
+        .addEvent(
+            ShadowUsageStatsManager.EventBuilder.buildEvent()
+                .setTimeStamp(1000L)
+                .setEventType(Event.SYSTEM_INTERACTION)
+                .build());
+
+    Object queryBuilder =
+        reflector(UsageEventsQueryBuilderReflector.class).newBuilder(1000L, 2000L);
+    UsageEventsQueryBuilderReflector queryBuilderReflector =
+        reflector(UsageEventsQueryBuilderReflector.class, queryBuilder);
+    queryBuilderReflector.setEventTypes(
+        Event.MOVE_TO_BACKGROUND, Event.MOVE_TO_FOREGROUND, Event.USER_INTERACTION);
+    UsageEvents events =
+        reflector(UsageStatsManagerReflector.class, usageStatsManager)
+            .queryEvents(queryBuilderReflector.build());
+
+    Event event = new Event();
+
+    assertThat(events.hasNextEvent()).isTrue();
+    assertThat(events.getNextEvent(event)).isTrue();
+    assertThat(event.getPackageName()).isEqualTo(TEST_PACKAGE_NAME1);
+    assertThat(event.getTimeStamp()).isEqualTo(1000L);
+    assertThat(event.getEventType()).isEqualTo(Event.MOVE_TO_BACKGROUND);
+
+    assertThat(events.hasNextEvent()).isTrue();
+    assertThat(events.getNextEvent(event)).isTrue();
+    assertThat(event.getPackageName()).isEqualTo(TEST_PACKAGE_NAME1);
+    assertThat(event.getTimeStamp()).isEqualTo(1001L);
+    assertThat(event.getEventType()).isEqualTo(Event.MOVE_TO_FOREGROUND);
+
+    assertThat(events.hasNextEvent()).isTrue();
+    assertThat(events.getNextEvent(event)).isTrue();
+    assertThat(event.getPackageName()).isEqualTo(TEST_PACKAGE_NAME2);
+    assertThat(event.getTimeStamp()).isEqualTo(1500L);
+    assertThat(event.getEventType()).isEqualTo(Event.USER_INTERACTION);
+    EventReflector eventReflector = reflector(EventReflector.class, event);
+    extras = eventReflector.getExtras();
+    assertThat(extras.getString("fakekey")).isEqualTo("fakevalue");
+
+    assertThat(events.hasNextEvent()).isFalse();
+  }
+
+  // TODO: remove reflection calls once Android V is fully supported.
+  @ForType(UsageStatsManager.class)
+  interface UsageStatsManagerReflector {
+    UsageEvents queryEvents(@WithType("android.app.usage.UsageEventsQuery") Object query);
+  }
+
+  @ForType(className = "android.app.usage.UsageEventsQuery$Builder")
+  interface UsageEventsQueryBuilderReflector {
+    @Constructor
+    Object newBuilder(long beginTimeMillis, long endTimeMillis);
+
+    Object setEventTypes(int... eventTypes);
+
+    Object build();
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
index 14fd8f692..97668305d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUsbManagerTest.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static com.google.common.truth.Truth.assertThat;
@@ -11,6 +12,7 @@ import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.util.ReflectionHelpers.getStaticField;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.app.Activity;
 import android.content.Context;
 import android.hardware.usb.UsbAccessory;
 import android.hardware.usb.UsbDevice;
@@ -23,6 +25,7 @@ import android.os.ParcelFileDescriptor;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.stream.Collectors;
 import org.junit.Before;
@@ -30,6 +33,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowUsbManager._UsbManagerQ_;
@@ -242,4 +246,30 @@ public class ShadowUsbManagerTest {
   private _UsbManager_ _usbManager_() {
     return reflector(_UsbManager_.class, usbManager);
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void usbManager_activityContextEnabled_differentInstancesRetrieveSameUsbDevices() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      UsbManager applicationUsbManager =
+          ApplicationProvider.getApplicationContext().getSystemService(UsbManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      UsbManager activityUsbManager = activity.getSystemService(UsbManager.class);
+
+      assertThat(applicationUsbManager).isNotSameInstanceAs(activityUsbManager);
+
+      HashMap<String, UsbDevice> applicationDevices = applicationUsbManager.getDeviceList();
+      HashMap<String, UsbDevice> activityDevices = activityUsbManager.getDeviceList();
+
+      assertThat(activityDevices).isEqualTo(applicationDevices);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
index e0019b359..2acbdbae0 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUserManagerTest.java
@@ -13,6 +13,7 @@ import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
 import android.Manifest.permission;
+import android.app.Activity;
 import android.app.Application;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -37,6 +38,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowUserManager.UserState;
@@ -61,6 +63,23 @@ public class ShadowUserManagerTest {
     userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
   }
 
+  /**
+   * {@link ShadowUserManager} should support methods getting invoked when UserManager objects are
+   * returned from package contexts.
+   *
+   * <p>The root cause of this issue is that calling {@link Context#getApplicationContext()} returns
+   * null on a package context.
+   */
+  @Config(minSdk = R)
+  @Test
+  public void packageContextImpl_isUserOfType() throws Exception {
+    Context packageContext =
+        context.createPackageContextAsUser(
+            context.getPackageName(), 0, UserHandle.of(/* userId= */ 0));
+    UserManager packageUserManager = packageContext.getSystemService(UserManager.class);
+    assertThat(packageUserManager.isUserOfType("sdfasdfsadf")).isFalse();
+  }
+
   @Test
   public void shouldGetUserProfiles() {
     assertThat(userManager.getUserProfiles()).contains(Process.myUserHandle());
@@ -694,7 +713,7 @@ public class ShadowUserManagerTest {
     shadowOf(userManager)
         .addProfile(TEST_USER_HANDLE, PROFILE_USER_HANDLE, PROFILE_USER_NAME, PROFILE_USER_FLAGS);
 
-    // getProfiles(userId) include user itself and asssociated profiles.
+    // getProfiles(userId) include user itself and associated profiles.
     assertThat(userManager.getProfiles(TEST_USER_HANDLE).get(0).id).isEqualTo(TEST_USER_HANDLE);
     assertThat(userManager.getProfiles(TEST_USER_HANDLE).get(1).id).isEqualTo(PROFILE_USER_HANDLE);
   }
@@ -1162,4 +1181,32 @@ public class ShadowUserManagerTest {
             .getInternalMutablePackageInfo(context.getPackageName());
     packageInfo.requestedPermissions = permissions;
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void userManager_activityContextEnabled_consistentAcrossContexts() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      UserManager applicationUserManager =
+          (UserManager)
+              ApplicationProvider.getApplicationContext().getSystemService(Context.USER_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      UserManager activityUserManager =
+          (UserManager) activity.getSystemService(Context.USER_SERVICE);
+
+      assertThat(applicationUserManager).isNotSameInstanceAs(activityUserManager);
+
+      boolean isAdminApplication = applicationUserManager.isAdminUser();
+      boolean isAdminActivity = activityUserManager.isAdminUser();
+
+      assertThat(isAdminActivity).isEqualTo(isAdminApplication);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
index 28605e0f1..b4488aa00 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowUwbManagerTest.java
@@ -13,6 +13,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import android.app.Activity;
 import android.os.PersistableBundle;
 import android.uwb.RangingSession;
 import android.uwb.UwbManager;
@@ -23,9 +24,12 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentMatcher;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit tests for {@link ShadowUwbManager}. */
 @RunWith(RobolectricTestRunner.class)
@@ -217,4 +221,29 @@ public class ShadowUwbManagerTest {
   private static ArgumentMatcher<PersistableBundle> checkParams(String name) {
     return params -> getName(params).equals(name);
   }
+
+  @Test
+  public void uwbManager_activityContextEnabled_differentInstancesRetrieveSpecificationInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      UwbManager applicationUwbManager =
+          RuntimeEnvironment.getApplication().getSystemService(UwbManager.class);
+      activity = Robolectric.setupActivity(TestActivity.class);
+      UwbManager activityUwbManager = activity.getSystemService(UwbManager.class);
+
+      assertThat(applicationUwbManager).isNotSameInstanceAs(activityUwbManager);
+
+      PersistableBundle applicationSpecificationInfo = applicationUwbManager.getSpecificationInfo();
+      PersistableBundle activitySpecificationInfo = activityUwbManager.getSpecificationInfo();
+
+      assertThat(activitySpecificationInfo).isEqualTo(applicationSpecificationInfo);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
index bf59fd388..6f9b86b9e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVcnManagerTest.java
@@ -5,6 +5,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.verify;
 import static org.robolectric.shadow.api.Shadow.extract;
 
+import android.app.Activity;
 import android.net.vcn.VcnConfig;
 import android.net.vcn.VcnManager;
 import android.net.vcn.VcnManager.VcnStatusCallback;
@@ -12,6 +13,7 @@ import android.os.ParcelUuid;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.common.util.concurrent.MoreExecutors;
+import java.util.List;
 import java.util.concurrent.Executor;
 import org.junit.Before;
 import org.junit.Rule;
@@ -20,6 +22,7 @@ import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowVcnManager}. */
@@ -89,4 +92,34 @@ public final class ShadowVcnManagerTest {
 
     assertThat(instance.getConfiguredSubscriptionGroups()).isEmpty();
   }
+
+  @Test
+  public void vcnManager_activityContextEnabled_differentInstancesRetrieveSubscriptionGroups() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      VcnManager applicationVcnManager =
+          ApplicationProvider.getApplicationContext().getSystemService(VcnManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      VcnManager activityVcnManager = activity.getSystemService(VcnManager.class);
+
+      assertThat(applicationVcnManager).isNotSameInstanceAs(activityVcnManager);
+
+      List<ParcelUuid> applicationConfiguredSubscriptionGroups =
+          applicationVcnManager.getConfiguredSubscriptionGroups();
+      List<ParcelUuid> activityConfiguredSubscriptionGroups =
+          activityVcnManager.getConfiguredSubscriptionGroups();
+
+      assertThat(applicationConfiguredSubscriptionGroups).isNotNull();
+      assertThat(activityConfiguredSubscriptionGroups).isNotNull();
+      assertThat(activityConfiguredSubscriptionGroups)
+          .isEqualTo(applicationConfiguredSubscriptionGroups);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
index de7d531f7..de8411d5d 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewGroupTest.java
@@ -36,8 +36,12 @@ import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowViewGroupTest {
   private String defaultLineSeparator;
   private ViewGroup root;
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewRootImplTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewRootImplTest.java
deleted file mode 100644
index e10cbb3fa..000000000
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewRootImplTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.robolectric.shadows;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.app.Activity;
-import android.os.Build;
-import android.view.View;
-import android.view.WindowInsets;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
-import org.robolectric.android.controller.ActivityController;
-import org.robolectric.annotation.Config;
-
-@RunWith(AndroidJUnit4.class)
-public class ShadowViewRootImplTest {
-  private ActivityController<Activity> activityController;
-  private Activity activity;
-  private View rootView;
-
-  @Before
-  public void setUp() {
-    activityController = Robolectric.buildActivity(Activity.class);
-    activityController.setup();
-
-    activity = activityController.get();
-    rootView = activity.getWindow().getDecorView();
-  }
-
-  @Test
-  @Config(minSdk = Build.VERSION_CODES.R)
-  public void setIsStatusBarVisible_impactsGetWindowInsets() {
-    ShadowViewRootImpl.setIsStatusBarVisible(false);
-    WindowInsets windowInsets = rootView.getRootWindowInsets();
-    assertThat(windowInsets.isVisible(WindowInsets.Type.statusBars())).isFalse();
-
-    ShadowViewRootImpl.setIsStatusBarVisible(true);
-    windowInsets = rootView.getRootWindowInsets();
-    assertThat(windowInsets.isVisible(WindowInsets.Type.statusBars())).isTrue();
-  }
-
-  @Test
-  @Config(minSdk = Build.VERSION_CODES.R)
-  public void setIsNavigationBarVisible_impactsGetWindowInsets() {
-    ShadowViewRootImpl.setIsNavigationBarVisible(false);
-    WindowInsets windowInsets = rootView.getRootWindowInsets();
-    assertThat(windowInsets.isVisible(WindowInsets.Type.navigationBars())).isFalse();
-
-    ShadowViewRootImpl.setIsNavigationBarVisible(true);
-    windowInsets = rootView.getRootWindowInsets();
-    assertThat(windowInsets.isVisible(WindowInsets.Type.navigationBars())).isTrue();
-  }
-}
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
index 3949aff92..5104e9a9e 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowViewTest.java
@@ -60,9 +60,14 @@ import org.robolectric.R;
 import org.robolectric.Robolectric;
 import org.robolectric.android.DeviceConfig;
 import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
+import org.robolectric.annotation.ResourcesMode;
 import org.robolectric.util.TestRunnable;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowViewTest {
   private View view;
   private List<String> transcript;
@@ -356,6 +361,7 @@ public class ShadowViewTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void shouldAddOnClickListenerFromAttribute() throws Exception {
     AttributeSet attrs =
         Robolectric.buildAttributeSet().addAttribute(android.R.attr.onClick, "clickMe").build();
@@ -365,6 +371,7 @@ public class ShadowViewTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void shouldCallOnClickWithAttribute() throws Exception {
     MyActivity myActivity = buildActivity(MyActivity.class).create().get();
 
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
index be82bbb4a..bfbc202fe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVirtualDeviceManagerTest.java
@@ -10,6 +10,7 @@ import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
+import android.app.Activity;
 import android.app.PendingIntent;
 import android.companion.virtual.VirtualDeviceManager;
 import android.companion.virtual.VirtualDeviceManager.VirtualDevice;
@@ -40,6 +41,7 @@ import android.view.MotionEvent;
 import android.view.Surface;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.time.Duration;
+import java.util.List;
 import java.util.function.IntConsumer;
 import org.junit.Before;
 import org.junit.Rule;
@@ -50,9 +52,11 @@ import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowVirtualDeviceManager.ShadowVirtualDevice;
+import org.robolectric.shadows.testing.TestActivity;
 
 /** Unit test for ShadowVirtualDeviceManager and ShadowVirtualDevice. */
 @Config(minSdk = UPSIDE_DOWN_CAKE)
@@ -356,4 +360,33 @@ public class ShadowVirtualDeviceManagerTest {
     assertThat(virtualDisplay.getDisplay().getName()).isEqualTo("name");
     assertThat(virtualDisplay.getDisplay().getFlags()).isEqualTo(123);
   }
+
+  @Test
+  public void virtualDeviceManager_activityContextEnabled_retrievesSameVirtualDevices() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      VirtualDeviceManager applicationVirtualDeviceManager =
+          (VirtualDeviceManager)
+              RuntimeEnvironment.getApplication().getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+      activity = Robolectric.setupActivity(TestActivity.class);
+      VirtualDeviceManager activityVirtualDeviceManager =
+          (VirtualDeviceManager) activity.getSystemService(Context.VIRTUAL_DEVICE_SERVICE);
+
+      List<android.companion.virtual.VirtualDevice> applicationVirtualDevices =
+          applicationVirtualDeviceManager.getVirtualDevices();
+      List<android.companion.virtual.VirtualDevice> activityVirtualDevices =
+          activityVirtualDeviceManager.getVirtualDevices();
+
+      assertThat(applicationVirtualDevices).isNotNull();
+      assertThat(activityVirtualDevices).isNotNull();
+      assertThat(activityVirtualDevices).isEqualTo(applicationVirtualDevices);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
index b47f5a1dc..731827b62 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowVpnManagerTest.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.app.Activity;
 import android.content.Intent;
 import android.net.Ikev2VpnProfile;
 import android.net.VpnManager;
@@ -12,6 +13,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
@@ -92,4 +94,31 @@ public class ShadowVpnManagerTest {
     assertThat(state.isAlwaysOn()).isFalse();
     assertThat(state.isLockdownEnabled()).isFalse();
   }
+
+  @Test
+  @Config(minSdk = VERSION_CODES.TIRAMISU)
+  public void vpnManager_activityContextEnabled_differentInstancesInteract() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      VpnManager applicationVpnManager =
+          RuntimeEnvironment.getApplication().getSystemService(VpnManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      VpnManager activityVpnManager = activity.getSystemService(VpnManager.class);
+
+      assertThat(applicationVpnManager).isNotSameInstanceAs(activityVpnManager);
+
+      VpnProfileState applicationProfileState =
+          applicationVpnManager.getProvisionedVpnProfileState();
+      VpnProfileState activityProfileState = activityVpnManager.getProvisionedVpnProfileState();
+
+      assertThat(activityProfileState).isEqualTo(applicationProfileState);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
index 313114ddf..97bebbbfe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWallpaperManagerTest.java
@@ -2,14 +2,18 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.truth.Truth.assertThat;
 import static junit.framework.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 
+import android.app.Activity;
 import android.app.Application;
+import android.app.WallpaperInfo;
 import android.app.WallpaperManager;
 import android.content.ComponentName;
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.os.Binder;
 import android.os.Bundle;
@@ -28,10 +32,15 @@ import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
 import org.robolectric.shadows.ShadowWallpaperManager.WallpaperCommandRecord;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
+
 public class ShadowWallpaperManagerTest {
 
   private static final Bitmap TEST_IMAGE_1 = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888);
@@ -576,4 +585,32 @@ public class ShadowWallpaperManagerTest {
     bitmap.compress(Bitmap.CompressFormat.PNG, /* quality= */ 0, stream);
     return stream.toByteArray();
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void wallpaperManager_activityContextEnabled_retrievesSameWallpaper() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      activity = Robolectric.setupActivity(Activity.class);
+      WallpaperManager applicationWallpaperManager =
+          (WallpaperManager) application.getSystemService(Context.WALLPAPER_SERVICE);
+      WallpaperManager activityWallpaperManager =
+          (WallpaperManager) activity.getSystemService(Context.WALLPAPER_SERVICE);
+
+      assertThat(applicationWallpaperManager).isNotSameInstanceAs(activityWallpaperManager);
+
+      // Adjusted for WallpaperManager, as direct comparison methods are not available
+      WallpaperInfo applicationWallpaper = manager.getWallpaperInfo();
+      WallpaperInfo activityWallpaper = activityWallpaperManager.getWallpaperInfo();
+
+      assertThat(activityWallpaper).isEqualTo(applicationWallpaper);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
index 8d8f24a36..628a1e7de 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWearableSensingManagerTest.java
@@ -6,12 +6,14 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import android.app.Activity;
 import android.app.wearable.WearableSensingManager;
 import android.content.Context;
 import android.os.ParcelFileDescriptor;
 import android.os.PersistableBundle;
 import android.os.SharedMemory;
 import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import org.junit.Rule;
 import org.junit.Test;
@@ -19,7 +21,9 @@ import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.junit.MockitoJUnit;
 import org.mockito.junit.MockitoRule;
+import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
 
@@ -102,4 +106,45 @@ public class ShadowWearableSensingManagerTest {
 
     shadowWearableSensingManager.getLastSharedMemory();
   }
+
+  @Test
+  public void wearableSensingManager_activityContextEnabled_differentInstancesProvideDataStream() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      WearableSensingManager applicationWearableSensingManager =
+          RuntimeEnvironment.getApplication().getSystemService(WearableSensingManager.class);
+      activity = Robolectric.setupActivity(Activity.class);
+      WearableSensingManager activityWearableSensingManager =
+          activity.getSystemService(WearableSensingManager.class);
+
+      assertThat(applicationWearableSensingManager)
+          .isNotSameInstanceAs(activityWearableSensingManager);
+
+      ParcelFileDescriptor applicationPfd =
+          ParcelFileDescriptor.adoptFd(-1); // Placeholder descriptor
+      ParcelFileDescriptor activityPfd = ParcelFileDescriptor.adoptFd(-1); // Placeholder descriptor
+      Executor executor = Runnable::run; // Simple executor for test purposes
+
+      final int[] applicationStatus = new int[1];
+      final int[] activityStatus = new int[1];
+
+      Consumer<Integer> applicationStatusConsumer = status -> applicationStatus[0] = status;
+      Consumer<Integer> activityStatusConsumer = status -> activityStatus[0] = status;
+
+      applicationWearableSensingManager.provideDataStream(
+          applicationPfd, executor, applicationStatusConsumer);
+      activityWearableSensingManager.provideDataStream(
+          activityPfd, executor, activityStatusConsumer);
+
+      assertThat(activityStatus[0]).isEqualTo(applicationStatus[0]);
+
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
index 1c7ce687c..8e07b6e98 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiAwareManagerTest.java
@@ -5,6 +5,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
+import android.app.Activity;
 import android.content.Context;
 import android.net.wifi.aware.AttachCallback;
 import android.net.wifi.aware.DiscoverySessionCallback;
@@ -23,6 +24,7 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
 import org.robolectric.annotation.Config;
 
 /** Test for {@link ShadowWifiAwareManager} */
@@ -194,4 +196,32 @@ public final class ShadowWifiAwareManagerTest {
       subscribeSuccess = true;
     }
   }
+
+  @Test
+  public void wifiAwareManager_activityContextEnabled_differentInstancesIsAvailable() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+    Activity activity = null;
+    try {
+      WifiAwareManager applicationWifiAwareManager =
+          (WifiAwareManager)
+              ApplicationProvider.getApplicationContext()
+                  .getSystemService(Context.WIFI_AWARE_SERVICE);
+      activity = Robolectric.setupActivity(Activity.class);
+      WifiAwareManager activityWifiAwareManager =
+          (WifiAwareManager) activity.getSystemService(Context.WIFI_AWARE_SERVICE);
+
+      assertThat(applicationWifiAwareManager).isNotSameInstanceAs(activityWifiAwareManager);
+
+      boolean applicationIsAvailable = applicationWifiAwareManager.isAvailable();
+      boolean activityIsAvailable = activityWifiAwareManager.isAvailable();
+
+      assertThat(activityIsAvailable).isEqualTo(applicationIsAvailable);
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
index 252112cf6..7f453b634 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiManagerTest.java
@@ -56,6 +56,7 @@ import org.mockito.ArgumentCaptor;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.versioning.AndroidVersions.U;
 
 @RunWith(AndroidJUnit4.class)
@@ -929,7 +930,8 @@ public class ShadowWifiManagerTest {
                 List.of(WifiSsid.fromBytes(new byte[] {3, 2, 5})),
                 /* frequencies= */ null,
                 /* executor= */ null,
-                new TestPnoScanResultsCallback()));
+                ReflectionHelpers.createDelegatingProxy(
+                    PnoScanResultsCallback.class, new TestPnoScanResultsCallbackDelegate())));
   }
 
   @Test
@@ -942,7 +944,8 @@ public class ShadowWifiManagerTest {
                 /* ssids= */ null,
                 /* frequencies= */ null,
                 Executors.newSingleThreadExecutor(),
-                new TestPnoScanResultsCallback()));
+                ReflectionHelpers.createDelegatingProxy(
+                    PnoScanResultsCallback.class, new TestPnoScanResultsCallbackDelegate())));
   }
 
   @Test
@@ -955,7 +958,8 @@ public class ShadowWifiManagerTest {
                 /* ssids= */ List.of(),
                 /* frequencies= */ null,
                 Executors.newSingleThreadExecutor(),
-                new TestPnoScanResultsCallback()));
+                ReflectionHelpers.createDelegatingProxy(
+                    PnoScanResultsCallback.class, new TestPnoScanResultsCallbackDelegate())));
   }
 
   @Test
@@ -971,7 +975,8 @@ public class ShadowWifiManagerTest {
                     WifiSsid.fromBytes(new byte[] {90, 81, 72, 63, 54})),
                 /* frequencies= */ null,
                 Executors.newSingleThreadExecutor(),
-                new TestPnoScanResultsCallback()));
+                ReflectionHelpers.createDelegatingProxy(
+                    PnoScanResultsCallback.class, new TestPnoScanResultsCallbackDelegate())));
   }
 
   @Test
@@ -986,13 +991,16 @@ public class ShadowWifiManagerTest {
                     WifiSsid.fromBytes(new byte[] {9, 8, 7, 6})),
                 new int[] {5160, 5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320, 5340, 5360},
                 Executors.newSingleThreadExecutor(),
-                new TestPnoScanResultsCallback()));
+                ReflectionHelpers.createDelegatingProxy(
+                    PnoScanResultsCallback.class, new TestPnoScanResultsCallbackDelegate())));
   }
 
   @Test
   @Config(minSdk = TIRAMISU)
   public void setExternalPnoScanRequest_validRequest_successCallbackInvoked() throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
 
     wifiManager.setExternalPnoScanRequest(
         List.of(WifiSsid.fromBytes(new byte[] {1, 2, 3})),
@@ -1000,7 +1008,7 @@ public class ShadowWifiManagerTest {
         Executors.newSingleThreadExecutor(),
         callback);
 
-    assertThat(callback.successfulRegistrations.take()).isNotNull();
+    assertThat(delegate.successfulRegistrations.take()).isNotNull();
   }
 
   @Test
@@ -1008,7 +1016,9 @@ public class ShadowWifiManagerTest {
   public void
       setExternalPnoScanRequest_outstandingRequest_failureCallbackInvokedWithAlreadyRegisteredStatus()
           throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
 
     wifiManager.setExternalPnoScanRequest(
         List.of(WifiSsid.fromBytes(new byte[] {1, 2, 3})),
@@ -1022,7 +1032,7 @@ public class ShadowWifiManagerTest {
         Executors.newSingleThreadExecutor(),
         callback);
 
-    assertThat(callback.failedRegistrations.take())
+    assertThat(delegate.failedRegistrations.take())
         .isEqualTo(PnoScanResultsCallback.REGISTER_PNO_CALLBACK_ALREADY_REGISTERED);
   }
 
@@ -1030,7 +1040,9 @@ public class ShadowWifiManagerTest {
   @Config(minSdk = TIRAMISU)
   public void setExternalPnoScanRequest_differentUid_failureCallbackInvokedWithBusyStatus()
       throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
 
     wifiManager.setExternalPnoScanRequest(
         List.of(WifiSsid.fromBytes(new byte[] {1, 2, 3})),
@@ -1051,7 +1063,7 @@ public class ShadowWifiManagerTest {
         Executors.newSingleThreadExecutor(),
         callback);
 
-    assertThat(callback.failedRegistrations.take())
+    assertThat(delegate.failedRegistrations.take())
         .isEqualTo(PnoScanResultsCallback.REGISTER_PNO_CALLBACK_RESOURCE_BUSY);
   }
 
@@ -1059,7 +1071,9 @@ public class ShadowWifiManagerTest {
   @Config(minSdk = TIRAMISU)
   public void clearExternalPnoScanRequest_outstandingRequest_callbackInvokedWithUnregisteredStatus()
       throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
 
     wifiManager.setExternalPnoScanRequest(
         List.of(WifiSsid.fromBytes(new byte[] {1, 2, 3})),
@@ -1068,14 +1082,16 @@ public class ShadowWifiManagerTest {
         callback);
     wifiManager.clearExternalPnoScanRequest();
 
-    assertThat(callback.removedRegistrations.take())
+    assertThat(delegate.removedRegistrations.take())
         .isEqualTo(PnoScanResultsCallback.REMOVE_PNO_CALLBACK_UNREGISTERED);
   }
 
   @Test
   @Config(minSdk = TIRAMISU)
   public void clearExternalPnoScanRequest_wrongUid_callbackNotInvoked() throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
     ExecutorService executor = Executors.newSingleThreadExecutor();
 
     wifiManager.setExternalPnoScanRequest(
@@ -1096,13 +1112,15 @@ public class ShadowWifiManagerTest {
     executor.shutdown();
 
     assertThat(executor.awaitTermination(5, MINUTES)).isTrue();
-    assertThat(callback.removedRegistrations).isEmpty();
+    assertThat(delegate.removedRegistrations).isEmpty();
   }
 
   @Test
   @Config(minSdk = TIRAMISU)
   public void networksFoundFromPnoScan_matchingSsid_availableCallbackInvoked() throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
     WifiSsid wifiSsid = WifiSsid.fromBytes(new byte[] {1, 2, 3});
     ScanResult scanResult = new ScanResult();
     scanResult.setWifiSsid(wifiSsid);
@@ -1111,14 +1129,16 @@ public class ShadowWifiManagerTest {
         List.of(wifiSsid), /* frequencies= */ null, Executors.newSingleThreadExecutor(), callback);
     shadowOf(wifiManager).networksFoundFromPnoScan(List.of(scanResult));
 
-    assertThat(callback.incomingScanResults.take()).containsExactly(scanResult);
+    assertThat(delegate.incomingScanResults.take()).containsExactly(scanResult);
   }
 
   @Test
   @Config(minSdk = TIRAMISU)
   public void networksFoundFromPnoScan_matchingSsid_removedCallbackInvokedWithDeliveredStatus()
       throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
     WifiSsid wifiSsid = WifiSsid.fromBytes(new byte[] {1, 2, 3});
     ScanResult scanResult = new ScanResult();
     scanResult.setWifiSsid(wifiSsid);
@@ -1127,14 +1147,16 @@ public class ShadowWifiManagerTest {
         List.of(wifiSsid), /* frequencies= */ null, Executors.newSingleThreadExecutor(), callback);
     shadowOf(wifiManager).networksFoundFromPnoScan(List.of(scanResult));
 
-    assertThat(callback.removedRegistrations.take())
+    assertThat(delegate.removedRegistrations.take())
         .isEqualTo(PnoScanResultsCallback.REMOVE_PNO_CALLBACK_RESULTS_DELIVERED);
   }
 
   @Test
   @Config(minSdk = TIRAMISU)
   public void networksFoundFromPnoScan_matchingSsid_scanResultsAvailableBroadcastSent() {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
     WifiSsid wifiSsid = WifiSsid.fromBytes(new byte[] {1, 2, 3});
     ScanResult scanResult = new ScanResult();
     scanResult.setWifiSsid(wifiSsid);
@@ -1157,7 +1179,9 @@ public class ShadowWifiManagerTest {
   @Config(minSdk = TIRAMISU)
   public void networksFoundFromPnoScan_noMatchingSsid_availableCallbackNotInvoked()
       throws Exception {
-    TestPnoScanResultsCallback callback = new TestPnoScanResultsCallback();
+    TestPnoScanResultsCallbackDelegate delegate = new TestPnoScanResultsCallbackDelegate();
+    PnoScanResultsCallback callback =
+        ReflectionHelpers.createDelegatingProxy(PnoScanResultsCallback.class, delegate);
     ExecutorService executor = Executors.newSingleThreadExecutor();
     WifiSsid wifiSsid = WifiSsid.fromBytes(new byte[] {1, 2, 3});
     WifiSsid otherWifiSsid = WifiSsid.fromBytes(new byte[] {9, 8, 7, 6});
@@ -1171,7 +1195,7 @@ public class ShadowWifiManagerTest {
     executor.shutdown();
 
     assertThat(executor.awaitTermination(5, MINUTES)).isTrue();
-    assertThat(callback.incomingScanResults).isEmpty();
+    assertThat(delegate.incomingScanResults).isEmpty();
   }
 
   @Test
@@ -1368,28 +1392,24 @@ public class ShadowWifiManagerTest {
     }
   }
 
-  private class TestPnoScanResultsCallback implements PnoScanResultsCallback {
+  private static class TestPnoScanResultsCallbackDelegate {
     LinkedBlockingQueue<List<ScanResult>> incomingScanResults = new LinkedBlockingQueue<>();
     LinkedBlockingQueue<Object> successfulRegistrations = new LinkedBlockingQueue<>();
     LinkedBlockingQueue<Integer> failedRegistrations = new LinkedBlockingQueue<>();
     LinkedBlockingQueue<Integer> removedRegistrations = new LinkedBlockingQueue<>();
 
-    @Override
     public void onScanResultsAvailable(List<ScanResult> scanResults) {
       incomingScanResults.add(scanResults);
     }
 
-    @Override
     public void onRegisterSuccess() {
       successfulRegistrations.add(new Object());
     }
 
-    @Override
     public void onRegisterFailed(int reason) {
       failedRegistrations.add(reason);
     }
 
-    @Override
     public void onRemoved(int reason) {
       removedRegistrations.add(reason);
     }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
index c1a9d322c..88743c1f7 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiP2pManagerTest.java
@@ -1,24 +1,34 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.O;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadows.ShadowLooper.shadowMainLooper;
 
-import android.app.Application;
+import android.app.Activity;
 import android.content.Context;
 import android.net.wifi.p2p.WifiP2pGroup;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.os.Build;
+import android.os.Looper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.testing.TestActivity;
 
 @RunWith(AndroidJUnit4.class)
 public class ShadowWifiP2pManagerTest {
 
+  private Context context;
   private WifiP2pManager manager;
   private ShadowWifiP2pManager shadowManager;
   @Mock private WifiP2pManager.ChannelListener mockListener;
@@ -27,7 +37,7 @@ public class ShadowWifiP2pManagerTest {
   @Before
   public void setUp() {
     MockitoAnnotations.initMocks(this);
-    Application context = ApplicationProvider.getApplicationContext();
+    context = ApplicationProvider.getApplicationContext();
     manager = (WifiP2pManager) context.getSystemService(Context.WIFI_P2P_SERVICE);
     shadowManager = shadowOf(manager);
     channel = manager.initialize(context, context.getMainLooper(), mockListener);
@@ -158,4 +168,62 @@ public class ShadowWifiP2pManagerTest {
       this.group = group;
     }
   }
+
+  @Test
+  @Config(minSdk = O)
+  public void wifiP2pManager_activityContextEnabled_retrievesSameGroupInfo() {
+    String originalProperty = System.getProperty("robolectric.createActivityContexts", "");
+    System.setProperty("robolectric.createActivityContexts", "true");
+
+    WifiP2pManager.Channel applicationChannel =
+        manager.initialize(context, Looper.getMainLooper(), null);
+
+    CountDownLatch latch = new CountDownLatch(2);
+    final String[] applicationGroupNameHolder = new String[1];
+    final String[] activityGroupNameHolder = new String[1];
+
+    manager.requestGroupInfo(
+        applicationChannel,
+        group -> {
+          if (group != null) {
+            applicationGroupNameHolder[0] = group.getNetworkName();
+          }
+          latch.countDown();
+        });
+
+    Activity activity = null;
+    try {
+      activity = Robolectric.setupActivity(TestActivity.class);
+      WifiP2pManager activityWifiP2pManager =
+          (WifiP2pManager) activity.getSystemService(Context.WIFI_P2P_SERVICE);
+      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+        assertThat(manager).isNotSameInstanceAs(activityWifiP2pManager);
+      } else {
+        assertThat(manager).isSameInstanceAs(activityWifiP2pManager);
+      }
+
+      WifiP2pManager.Channel activityChannel =
+          activityWifiP2pManager.initialize(activity, activity.getMainLooper(), null);
+
+      activityWifiP2pManager.requestGroupInfo(
+          activityChannel,
+          group -> {
+            if (group != null) {
+              activityGroupNameHolder[0] = group.getNetworkName();
+            }
+            latch.countDown();
+          });
+
+      latch.await(5, TimeUnit.SECONDS); // Adjust timeout as necessary
+
+      assertThat(applicationGroupNameHolder[0]).isEqualTo(activityGroupNameHolder[0]);
+    } catch (InterruptedException e) {
+      fail("Failed because of latch interrupt");
+    } finally {
+      if (activity != null) {
+        activity.finish();
+      }
+      System.setProperty("robolectric.createActivityContexts", originalProperty);
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
index a383bff78..e4ddbff35 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWifiScannerTest.java
@@ -8,6 +8,7 @@ import android.content.Context;
 import android.net.wifi.ScanResult;
 import android.net.wifi.WifiScanner;
 import android.net.wifi.WifiScanner.ScanData;
+import android.net.wifi.WifiScanner.ScanListener;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import com.google.common.collect.ImmutableList;
@@ -18,6 +19,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Config;
+import org.robolectric.util.ReflectionHelpers;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(minSdk = VERSION_CODES.N)
@@ -45,13 +47,14 @@ public class ShadowWifiScannerTest {
   @Test
   @Config(minSdk = VERSION_CODES.N_MR1, maxSdk = VERSION_CODES.Q)
   public void setScanResults_invokesListeners() {
-    ScanDataListener listener = new ScanDataListener();
+    ScanDataListenerDelegate listener = new ScanDataListenerDelegate();
 
     WifiScanner scanner =
         (WifiScanner)
             RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
 
-    scanner.registerScanListener(listener);
+    scanner.registerScanListener(
+        ReflectionHelpers.createDelegatingProxy(ScanListener.class, listener));
     ((ShadowWifiScanner) extract(scanner)).setScanResults(SCAN_RESULTS);
 
     ScanData[] scanData = listener.scanData;
@@ -68,13 +71,15 @@ public class ShadowWifiScannerTest {
   @Test
   @Config(minSdk = VERSION_CODES.R)
   public void setScanResultsR_invokesListeners() {
-    ScanDataListener listener = new ScanDataListener();
+    ScanDataListenerDelegate listener = new ScanDataListenerDelegate();
 
     WifiScanner scanner =
         (WifiScanner)
             RuntimeEnvironment.getApplication().getSystemService(Context.WIFI_SCANNING_SERVICE);
 
-    scanner.registerScanListener(MoreExecutors.directExecutor(), listener);
+    scanner.registerScanListener(
+        MoreExecutors.directExecutor(),
+        ReflectionHelpers.createDelegatingProxy(ScanListener.class, listener));
     ((ShadowWifiScanner) extract(scanner)).setScanResults(SCAN_RESULTS);
 
     ScanData[] scanData = listener.scanData;
@@ -136,24 +141,19 @@ public class ShadowWifiScannerTest {
     return ImmutableList.of(scanResult);
   }
 
-  private static class ScanDataListener implements WifiScanner.ScanListener {
+  private static class ScanDataListenerDelegate {
     public ScanData[] scanData = null;
 
-    @Override
     public void onSuccess() {}
 
-    @Override
     public void onFailure(int reason, String description) {}
 
-    @Override
     public void onPeriodChanged(int periodInMs) {}
 
-    @Override
     public void onResults(ScanData[] results) {
       scanData = results;
     }
 
-    @Override
     public void onFullResult(ScanResult fullScanResult) {}
   }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
index 6092630c1..1409453fe 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ShadowWindowManagerGlobalTest.java
@@ -1,10 +1,21 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
+import static org.robolectric.Robolectric.buildActivity;
+import static org.robolectric.shadows.ShadowLooper.idleMainLooper;
+import static org.robolectric.shadows.SystemUi.STANDARD_STATUS_BAR;
+import static org.robolectric.shadows.SystemUi.THREE_BUTTON_NAVIGATION;
+import static org.robolectric.shadows.SystemUi.systemUiForDefaultDisplay;
 
 import android.app.Activity;
 import android.content.ClipData;
+import android.graphics.Color;
 import android.graphics.Rect;
 import android.os.Build.VERSION_CODES;
 import android.os.Bundle;
@@ -14,6 +25,9 @@ import android.view.View;
 import android.view.View.DragShadowBuilder;
 import android.view.View.OnTouchListener;
 import android.view.ViewConfiguration;
+import android.view.Window;
+import android.view.WindowInsets;
+import android.view.WindowManager;
 import android.window.BackEvent;
 import android.window.OnBackAnimationCallback;
 import android.window.OnBackInvokedDispatcher;
@@ -32,8 +46,13 @@ import org.robolectric.Robolectric;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
+import org.robolectric.annotation.GraphicsMode;
+import org.robolectric.annotation.GraphicsMode.Mode;
+import org.robolectric.shadows.SystemUi.NavigationBar;
+import org.robolectric.shadows.SystemUi.StatusBar;
 
 @RunWith(AndroidJUnit4.class)
+@GraphicsMode(Mode.LEGACY)
 public class ShadowWindowManagerGlobalTest {
 
   @Before
@@ -268,4 +287,147 @@ public class ShadowWindowManagerGlobalTest {
       onBackCancelledCalled = true;
     }
   }
+
+  @Test
+  public void windowInsets() {
+    systemUiForDefaultDisplay().setBehavior(STANDARD_STATUS_BAR, THREE_BUTTON_NAVIGATION);
+    ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
+
+    controller.setup();
+    idleMainLooper();
+
+    StatusBar statusBar = systemUiForDefaultDisplay().getStatusBar();
+    NavigationBar navBar = systemUiForDefaultDisplay().getNavigationBar();
+    assertThat(controller.get().systemInsets)
+        .isEqualTo(new Rect(0, statusBar.getSize(), 0, navBar.getSize()));
+    assertThat(controller.get().windowInsets).isNotNull();
+  }
+
+  @Config(minSdk = R)
+  @Test
+  public void windowInsetsController_hideStatusBar() {
+    systemUiForDefaultDisplay().setBehavior(STANDARD_STATUS_BAR, THREE_BUTTON_NAVIGATION);
+    ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
+    controller.setup();
+    idleMainLooper();
+
+    controller.get().getWindow().getInsetsController().hide(WindowInsets.Type.statusBars());
+    idleMainLooper();
+
+    assertThat(controller.get().windowInsets.getInsets(WindowInsets.Type.statusBars()).top)
+        .isEqualTo(0);
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.statusBars())).isFalse();
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.navigationBars()))
+        .isTrue();
+  }
+
+  @Config(minSdk = R)
+  @Test
+  public void windowInsetsController_hideSystemBars() {
+    systemUiForDefaultDisplay().setBehavior(STANDARD_STATUS_BAR, THREE_BUTTON_NAVIGATION);
+    ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
+    controller.setup();
+    idleMainLooper();
+
+    controller.get().getWindow().getInsetsController().hide(WindowInsets.Type.systemBars());
+    idleMainLooper();
+
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.statusBars())).isFalse();
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.navigationBars()))
+        .isFalse();
+  }
+
+  @Config(minSdk = R)
+  @Test
+  public void windowInsetsController_toggleStatusBar() {
+    ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
+    controller.setup();
+    idleMainLooper();
+
+    controller.get().getWindow().getInsetsController().hide(WindowInsets.Type.statusBars());
+    idleMainLooper();
+    controller.get().getWindow().getInsetsController().show(WindowInsets.Type.statusBars());
+    idleMainLooper();
+
+    assertThat(controller.get().windowInsets.isVisible(WindowInsets.Type.statusBars()))
+        .isEqualTo(true);
+  }
+
+  @Config(minSdk = R)
+  @Test
+  public void windowInsetsController_twoWindows_toggleStatusBar() {
+    ActivityController<WindowInsetsActivity> controller = buildActivity(WindowInsetsActivity.class);
+    controller.setup();
+    idleMainLooper();
+    ActivityController<WindowInsetsActivity> controller2 =
+        buildActivity(WindowInsetsActivity.class);
+    controller2.setup();
+    idleMainLooper();
+
+    controller2.get().getWindow().getInsetsController().hide(WindowInsets.Type.statusBars());
+    idleMainLooper();
+
+    assertThat(controller2.get().windowInsets.isVisible(WindowInsets.Type.statusBars()))
+        .isEqualTo(false);
+  }
+
+  public static final class WindowInsetsActivity extends Activity {
+    Rect systemInsets;
+    WindowInsets windowInsets;
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+      setEdgeToEdge(getWindow());
+      super.onCreate(savedInstanceState);
+      setContentView(
+          new View(this) {
+            @Override
+            public WindowInsets onApplyWindowInsets(WindowInsets insets) {
+              windowInsets = insets;
+              return super.onApplyWindowInsets(insets);
+            }
+
+            @Override
+            protected boolean fitSystemWindows(Rect insets) {
+              systemInsets = new Rect(insets);
+              return super.fitSystemWindows(insets);
+            }
+          });
+    }
+  }
+
+  // This sets similar properties to the androidx edgeToEdge API.
+  private static void setEdgeToEdge(Window window) {
+    if (RuntimeEnvironment.getApiLevel() <= Q) {
+      window
+          .getDecorView()
+          .setSystemUiVisibility(
+              window.getDecorView().getSystemUiVisibility()
+                  | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+                  | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                  | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
+    } else if (RuntimeEnvironment.getApiLevel() <= UPSIDE_DOWN_CAKE) {
+      window
+          .getDecorView()
+          .setSystemUiVisibility(
+              window.getDecorView().getSystemUiVisibility() | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
+      window.setDecorFitsSystemWindows(false);
+    } else {
+      window.setDecorFitsSystemWindows(false);
+    }
+    if (RuntimeEnvironment.getApiLevel() <= LOLLIPOP_MR1) {
+      window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
+      window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
+    } else {
+      window.setStatusBarColor(Color.TRANSPARENT);
+      window.setNavigationBarColor(Color.TRANSPARENT);
+    }
+    if (RuntimeEnvironment.getApiLevel() > R) {
+      window.getAttributes().layoutInDisplayCutoutMode =
+          WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;
+    } else if (RuntimeEnvironment.getApiLevel() > P) {
+      window.getAttributes().layoutInDisplayCutoutMode =
+          WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;
+    }
+  }
 }
diff --git a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
index b5ab1b886..8a98071dd 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/ViewStubTest.java
@@ -17,8 +17,10 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
 
 @RunWith(AndroidJUnit4.class)
+
 public class ViewStubTest {
   private Context ctxt;
 
@@ -53,6 +55,7 @@ public class ViewStubTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void shouldApplyAttributes() {
     ViewStub viewStub =
         new ViewStub(
diff --git a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
index e973056b6..76cdfeb97 100644
--- a/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
+++ b/robolectric/src/test/java/org/robolectric/shadows/XmlPullParserTest.java
@@ -15,10 +15,12 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.R;
 import org.robolectric.Robolectric;
+import org.robolectric.annotation.ResourcesMode;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 @RunWith(AndroidJUnit4.class)
+
 public class XmlPullParserTest {
 
   // emulator output:
@@ -97,6 +99,7 @@ public class XmlPullParserTest {
   }
 
   @Test
+  @ResourcesMode(ResourcesMode.Mode.BINARY)
   public void buildAttrSet() {
     XmlResourceParser parser =
         (XmlResourceParser)
diff --git a/sandbox/build.gradle b/sandbox/build.gradle
deleted file mode 100644
index 7c2ffca70..000000000
--- a/sandbox/build.gradle
+++ /dev/null
@@ -1,27 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    annotationProcessor libs.auto.service
-    annotationProcessor libs.error.prone.core
-
-    api project(":annotations")
-    api project(":utils")
-    api project(":shadowapi")
-    api project(":utils:reflector")
-    compileOnly libs.auto.service.annotations
-    api libs.javax.annotation.api
-    api libs.javax.inject
-
-    api libs.asm
-    api libs.asm.commons
-    api libs.guava
-    compileOnly libs.findbugs.jsr305
-
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-    testImplementation project(":junit")
-}
diff --git a/sandbox/build.gradle.kts b/sandbox/build.gradle.kts
new file mode 100644
index 000000000..50dc26fb5
--- /dev/null
+++ b/sandbox/build.gradle.kts
@@ -0,0 +1,27 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  annotationProcessor(libs.auto.service)
+  annotationProcessor(libs.error.prone.core)
+
+  api(project(":annotations"))
+  api(project(":utils"))
+  api(project(":shadowapi"))
+  api(project(":utils:reflector"))
+  compileOnly(libs.auto.service.annotations)
+  api(libs.javax.annotation.api)
+  api(libs.javax.inject)
+
+  api(libs.asm)
+  api(libs.asm.commons)
+  api(libs.guava)
+  compileOnly(libs.findbugs.jsr305)
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+  testImplementation(project(":junit"))
+}
diff --git a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
index da2322c1e..4d1ea859b 100644
--- a/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
+++ b/sandbox/src/main/java/org/robolectric/config/AndroidConfigurer.java
@@ -7,7 +7,6 @@ import org.robolectric.internal.bytecode.InstrumentationConfiguration;
 import org.robolectric.internal.bytecode.Interceptors;
 import org.robolectric.internal.bytecode.MethodRef;
 import org.robolectric.internal.bytecode.ShadowProviders;
-import org.robolectric.util.Util;
 
 /** Instruments the Android jars */
 public class AndroidConfigurer {
@@ -77,9 +76,7 @@ public class AndroidConfigurer {
         .addClassNameTranslation("java.lang.UnsafeByteSequence", Object.class.getName())
         .addClassNameTranslation("java.util.jar.StrictJarFile", Object.class.getName());
 
-    if (Util.getJavaVersion() >= 9) {
-      builder.addClassNameTranslation("sun.misc.Cleaner", "java.lang.ref.Cleaner$Cleanable");
-    }
+    builder.addClassNameTranslation("sun.misc.Cleaner", "java.lang.ref.Cleaner$Cleanable");
 
     // Don't acquire legacy support packages.
     builder
diff --git a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
index e1eab842e..e75beb577 100644
--- a/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
+++ b/sandbox/src/main/java/org/robolectric/interceptors/AndroidInterceptors.java
@@ -22,7 +22,6 @@ import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Locale;
 import javax.annotation.Nullable;
 import org.robolectric.fakes.CleanerCompat;
@@ -30,31 +29,26 @@ import org.robolectric.internal.bytecode.Interceptor;
 import org.robolectric.internal.bytecode.MethodRef;
 import org.robolectric.internal.bytecode.MethodSignature;
 import org.robolectric.util.Function;
-import org.robolectric.util.Util;
 
 public class AndroidInterceptors {
   private static final MethodHandles.Lookup lookup = MethodHandles.lookup();
 
   public static Collection<Interceptor> all() {
-    List<Interceptor> interceptors =
-        new ArrayList<>(
-            asList(
-                new LinkedHashMapEldestInterceptor(),
-                new SystemTimeInterceptor(),
-                new SystemArrayCopyInterceptor(),
-                new LocaleAdjustLanguageCodeInterceptor(),
-                new SystemLogInterceptor(),
-                new FileDescriptorInterceptor(),
-                new NoOpInterceptor(),
-                new SocketInterceptor(),
-                new ReferenceRefersToInterceptor(),
-                new NioUtilsFreeDirectBufferInterceptor()));
-
-    if (Util.getJavaVersion() >= 9) {
-      interceptors.add(new CleanerInterceptor());
-    }
-
-    return interceptors;
+    return new ArrayList<>(
+        asList(
+            new LinkedHashMapEldestInterceptor(),
+            new SystemTimeInterceptor(),
+            new SystemArrayCopyInterceptor(),
+            new LocaleAdjustLanguageCodeInterceptor(),
+            new SystemLogInterceptor(),
+            new FileDescriptorInterceptor(),
+            new NoOpInterceptor(),
+            new SocketInterceptor(),
+            new ReferenceRefersToInterceptor(),
+            new NioUtilsFreeDirectBufferInterceptor(),
+            new NioUtilsUnsafeArrayInterceptor(),
+            new NioUtilsUnsafeArrayOffsetInterceptor(),
+            new CleanerInterceptor()));
   }
 
   /**
@@ -83,9 +77,17 @@ public class AndroidInterceptors {
 
     static Object setInt(FileDescriptor input, int value) {
       try {
-        input.getClass().getDeclaredField("fd").setInt(input, value);
-      } catch (Exception e) {
-        // Ignore
+        final Object obj =
+            Class.forName("jdk.internal.access.SharedSecrets")
+                .getMethod("getJavaIOFileDescriptorAccess")
+                .invoke(null);
+        Class.forName("jdk.internal.access.JavaIOFileDescriptorAccess")
+            .getMethod("set", FileDescriptor.class, int.class)
+            .invoke(obj, input, value);
+      } catch (ReflectiveOperationException e) {
+        throw new RuntimeException(
+            "Failed to interact with raw FileDescriptor internals;" + " perhaps JRE has changed?",
+            e);
       }
       return null;
     }
@@ -530,4 +532,53 @@ public class AndroidInterceptors {
       return lookup.findStatic(getClass(), METHOD, methodType(void.class, ByteBuffer.class));
     }
   }
+
+  /** AndroidInterceptor for NioUtils.unsafeArray. */
+  public static class NioUtilsUnsafeArrayInterceptor extends Interceptor {
+    private static final String METHOD = "unsafeArray";
+
+    public NioUtilsUnsafeArrayInterceptor() {
+      super(new MethodRef("java.nio.NioUtils", METHOD));
+    }
+
+    @SuppressWarnings("ByteBufferBackingArray")
+    static byte[] unsafeArray(ByteBuffer buffer) {
+      return buffer.array();
+    }
+
+    @Override
+    public Function<Object, Object> handle(MethodSignature methodSignature) {
+      return (theClass, value, params) -> unsafeArray((ByteBuffer) value);
+    }
+
+    @Override
+    public MethodHandle getMethodHandle(String methodName, MethodType type)
+        throws NoSuchMethodException, IllegalAccessException {
+      return lookup.findStatic(getClass(), METHOD, methodType(byte[].class, ByteBuffer.class));
+    }
+  }
+
+  /** AndroidInterceptor for NioUtils.unsafeArrayOffset. */
+  public static class NioUtilsUnsafeArrayOffsetInterceptor extends Interceptor {
+    private static final String METHOD = "unsafeArrayOffset";
+
+    public NioUtilsUnsafeArrayOffsetInterceptor() {
+      super(new MethodRef("java.nio.NioUtils", METHOD));
+    }
+
+    static int unsafeArrayOffset(ByteBuffer buffer) {
+      return buffer.arrayOffset();
+    }
+
+    @Override
+    public Function<Object, Object> handle(MethodSignature methodSignature) {
+      return (theClass, value, params) -> unsafeArrayOffset((ByteBuffer) value);
+    }
+
+    @Override
+    public MethodHandle getMethodHandle(String methodName, MethodType type)
+        throws NoSuchMethodException, IllegalAccessException {
+      return lookup.findStatic(getClass(), METHOD, methodType(int.class, ByteBuffer.class));
+    }
+  }
 }
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
index 646e6edac..9f4178bbb 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ClassInstrumentor.java
@@ -634,22 +634,22 @@ public class ClassInstrumentor {
           break;
 
         case Opcodes.GETFIELD:
-          /* falls through */
+        /* falls through */
         case Opcodes.PUTFIELD:
-          /* falls through */
+        /* falls through */
         case Opcodes.GETSTATIC:
-          /* falls through */
+        /* falls through */
         case Opcodes.PUTSTATIC:
           FieldInsnNode fieldInsnNode = (FieldInsnNode) node;
           fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc); // todo test
           break;
 
         case Opcodes.INVOKESTATIC:
-          /* falls through */
+        /* falls through */
         case Opcodes.INVOKEINTERFACE:
-          /* falls through */
+        /* falls through */
         case Opcodes.INVOKESPECIAL:
-          /* falls through */
+        /* falls through */
         case Opcodes.INVOKEVIRTUAL:
           MethodInsnNode targetMethod = (MethodInsnNode) node;
           targetMethod.desc = mutableClass.config.remapParams(targetMethod.desc);
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
index e99d354e8..b1f8bdb28 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/InstrumentationConfiguration.java
@@ -158,6 +158,12 @@ public class InstrumentationConfiguration {
    * @return True if the resource should be loaded.
    */
   public boolean shouldAcquireResource(String name) {
+    if (name.contains("android_runtime")) {
+      return true;
+    }
+    if (name.contains("icudt75l.dat")) {
+      return true;
+    }
     return RESOURCES_TO_ALWAYS_ACQUIRE.contains(name);
   }
 
diff --git a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
index 1be9a90e3..1ca60f529 100644
--- a/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
+++ b/sandbox/src/main/java/org/robolectric/internal/bytecode/ShadowWrangler.java
@@ -9,7 +9,6 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 
 import com.google.auto.service.AutoService;
 import com.google.errorprone.annotations.Keep;
-import java.lang.annotation.Annotation;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
@@ -18,6 +17,7 @@ import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.lang.reflect.Parameter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -30,7 +30,6 @@ import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.sandbox.ShadowMatcher;
 import org.robolectric.util.Function;
 import org.robolectric.util.PerfStatsCollector;
-import org.robolectric.util.Util;
 
 /**
  * ShadowWrangler matches shadowed classes up with corresponding shadows based on a {@link
@@ -72,24 +71,6 @@ public class ShadowWrangler implements ClassHandler {
 
   private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
 
-  // Required to support the equivalent of MethodHandles.privateLookupIn in Java 8. It allows
-  // calling protected constructors using incokespecial.
-  private static final boolean HAS_PRIVATE_LOOKUP_IN = Util.getJavaVersion() >= 9;
-  private static final Constructor<MethodHandles.Lookup> JAVA_8_LOOKUP_CTOR;
-
-  static {
-    if (!HAS_PRIVATE_LOOKUP_IN) {
-      try {
-        JAVA_8_LOOKUP_CTOR = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class);
-        JAVA_8_LOOKUP_CTOR.setAccessible(true);
-      } catch (NoSuchMethodException e) {
-        throw new AssertionError(e);
-      }
-    } else {
-      JAVA_8_LOOKUP_CTOR = null;
-    }
-  }
-
   private static final Class<?>[] NO_ARGS = new Class<?>[0];
   static final Object NO_SHADOW = new Object();
   private static final MethodHandle NO_SHADOW_HANDLE = constant(Object.class, NO_SHADOW);
@@ -213,7 +194,7 @@ public class ShadowWrangler implements ClassHandler {
                 // the wrong constructor may be called in situations where constructors with
                 // identical signatures are shadowed in object hierarchies.
                 mh =
-                    privateLookupFor(shadowMethod.getDeclaringClass())
+                    MethodHandles.privateLookupIn(shadowMethod.getDeclaringClass(), LOOKUP)
                         .unreflectSpecial(shadowMethod, shadowMethod.getDeclaringClass());
               } else {
                 mh = LOOKUP.unreflect(shadowMethod);
@@ -229,18 +210,15 @@ public class ShadowWrangler implements ClassHandler {
             });
   }
 
-  private MethodHandles.Lookup privateLookupFor(Class<?> lookupClass)
-      throws IllegalAccessException {
-    if (HAS_PRIVATE_LOOKUP_IN) {
-      return MethodHandles.privateLookupIn(lookupClass, LOOKUP);
-    }
-    try {
-      return JAVA_8_LOOKUP_CTOR.newInstance(lookupClass);
-    } catch (ReflectiveOperationException e) {
-      throw new LinkageError(e.getMessage(), e);
-    }
-  }
-
+  /**
+   * Return a method handle of the shadow class which matches the given function signature of the
+   * shadowed class.
+   *
+   * @param definingClass The shadowed class
+   * @param name The name of the method
+   * @param paramTypes The parameter list of the method
+   * @return A method handle of the corresponding shadow class
+   */
   protected Method pickShadowMethod(Class<?> definingClass, String name, Class<?>[] paramTypes) {
     ShadowInfo shadowInfo = getExactShadowInfo(definingClass);
     if (shadowInfo == null) {
@@ -268,6 +246,8 @@ public class ShadowWrangler implements ClassHandler {
    *
    * <p>If the shadow class allows loose signatures, search for them.
    *
+   * <p>If the shadow class has function using @ClassName matches the requirement, return it
+   *
    * <p>If the shadow class doesn't have such a method, but does have a superclass which implements
    * the same class as it, call ourself recursively with the shadow superclass.
    */
@@ -317,8 +297,11 @@ public class ShadowWrangler implements ClassHandler {
         continue;
       }
 
-      if (Arrays.equals(method.getParameterTypes(), paramClasses)
-          && shadowMatcher.matches(method)) {
+      if (!shadowMatcher.matches(method)) {
+        continue;
+      }
+
+      if (Arrays.equals(method.getParameterTypes(), paramClasses)) {
         // Found an exact match, we can exit early.
         foundMethod = method;
         break;
@@ -332,13 +315,13 @@ public class ShadowWrangler implements ClassHandler {
             break;
           }
         }
-        if (allParameterTypesAreObject && shadowMatcher.matches(method)) {
+        if (allParameterTypesAreObject) {
           // Found a looseSignatures match, but continue looking for an exact match.
           foundMethod = method;
         }
       } else {
         // Or maybe support @ClassName.
-        if (parameterClassNameMatch(method, paramClasses) && shadowMatcher.matches(method)) {
+        if (parameterClassNameMatch(method, paramClasses)) {
           // Found a @ClassName match, but continue looking for an exact match.
           foundMethod = method;
         }
@@ -356,6 +339,9 @@ public class ShadowWrangler implements ClassHandler {
         if (mappedMethodName.isEmpty() || !mappedMethodName.equals(methodName)) {
           continue;
         }
+        if (!shadowMatcher.matches(method)) {
+          continue;
+        }
         if (Arrays.equals(method.getParameterTypes(), paramClasses)
             || parameterClassNameMatch(method, paramClasses)) {
           foundMethod = method;
@@ -377,30 +363,24 @@ public class ShadowWrangler implements ClassHandler {
    * matches {@code paramClasses}.
    */
   private boolean parameterClassNameMatch(Method method, Class<?>[] paramClasses) {
-    Class<?>[] parameterTypes = method.getParameterTypes();
-    if (parameterTypes.length != paramClasses.length) {
+    Parameter[] params = method.getParameters();
+    if (params.length != paramClasses.length) {
       return false;
     }
 
-    Annotation[][] annotations = method.getParameterAnnotations();
-    for (int i = 0; i < paramClasses.length; ++i) {
-      if (parameterTypes[i].equals(paramClasses[i])) {
+    for (int i = 0; i < params.length; ++i) {
+      if (params[i].getType().equals(paramClasses[i])) {
         continue;
       }
-      if (!parameterTypes[i].equals(Object.class)) {
+      if (!params[i].getType().equals(Object.class)) {
         return false; // @ClassName only applicable to parameter of Object type
       }
-      boolean matches = false;
-      for (Annotation annotation : annotations[i]) {
-        if (annotation instanceof ClassName) {
-          matches = ((ClassName) annotation).value().equals(paramClasses[i].getName());
-          break;
-        }
-      }
-      if (!matches) {
+      ClassName className = params[i].getAnnotation(ClassName.class);
+      if (className == null || !className.value().equals(paramClasses[i].getName())) {
         return false;
       }
     }
+
     return true;
   }
 
diff --git a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
index 39630fd27..24fcc74ee 100644
--- a/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
+++ b/sandbox/src/test/java/org/robolectric/ShadowWranglerIntegrationTest.java
@@ -6,6 +6,9 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -347,6 +350,17 @@ public class ShadowWranglerIntegrationTest {
     }
   }
 
+  @Instrument
+  public static class AClassWithGenericFunctionParam {
+    public CharSequence aMethod(List<CharSequence> strs) {
+      String ret = "";
+      for (CharSequence s : strs) {
+        ret = ret + s;
+      }
+      return ret;
+    }
+  }
+
   @Implements(value = AClassWithDifficultArgs.class, looseSignatures = true)
   public static class ShadowAClassWithDifficultArgs {
     @Implementation
@@ -367,12 +381,53 @@ public class ShadowWranglerIntegrationTest {
     assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
   }
 
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassNameButUnmatchedReturn.class)
+  @Test
+  public void methodMatch_functionReturnTypeNotMatch_callShadowMethod() {
+    // Shadow method with different function return type would still be deemed as a match,
+    // as long as the type runtime castable to shadowed method function return type.
+    assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
+  }
+
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassNameWithMultipleAnnotation.class)
+  @Test
+  public void methodMatch_classNameAnnotatedAndMultipleAnnotations_shouldMatch() {
+    assertThat(new AClassWithDifficultArgs().aMethod("bc"))
+        .isEqualTo("ClassNameAnnotatedMultiAnnotation-bc");
+  }
+
+  @SandboxConfig(shadows = ShadowAClassWithDifficultArgsReturnTypeUseClassName.class)
+  @Test
+  public void methodMatch_classNameAnnotatedForParamsAndReturn_shouldMatch() {
+    assertThat(new AClassWithDifficultArgs().aMethod("bc"))
+        .isEqualTo("ClassNameAnnotatedParamsAndReturn-bc");
+  }
+
   @SandboxConfig(shadows = ShadowAClassWithDifficultArgsUseClassNameWithMethodRename.class)
   @Test
   public void methodMatch_classNameAnnotatedMatchesSupportMethodRename() {
     assertThat(new AClassWithDifficultArgs().aMethod("bc")).isEqualTo("ClassNameAnnotated-bc");
   }
 
+  @SandboxConfig(shadows = ShadowAClassWithGenericFunctionParamUseClassNameWithTypeArgument.class)
+  @Test
+  public void methodMatch_classNameAnnotatedWithGeneric() {
+    List<CharSequence> para = new ArrayList<>();
+    para.add("ab");
+    para.add("cd");
+    assertThat(new AClassWithGenericFunctionParam().aMethod(para)).isEqualTo("abcd");
+  }
+
+  @SandboxConfig(shadows = ShadowAClassWithGenericFunctionParamUseClassNameTypeErasure.class)
+  @Test
+  public void methodMatch_classNameAnnotatedWithGenericTypeErasure() {
+    List<CharSequence> para = new ArrayList<>();
+    para.add("ab");
+    para.add("cd");
+    assertThat(new AClassWithGenericFunctionParam().aMethod(para))
+        .isEqualTo("ClassNameGenericAnnotated");
+  }
+
   @Implements(value = AClassWithDifficultArgs.class)
   public static class ShadowAClassWithDifficultArgsWithMethodRename {
     @Implementation(methodName = "aMethod")
@@ -384,20 +439,66 @@ public class ShadowWranglerIntegrationTest {
   @Implements(value = AClassWithDifficultArgs.class)
   public static class ShadowAClassWithDifficultArgsUseClassName {
 
+    protected @ClassName("java.lang.CharSequence") Object aMethod(
+        @ClassName("java.lang.CharSequence") Object s) {
+      return "ClassNameAnnotated-" + s;
+    }
+  }
+
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsUseClassNameButUnmatchedReturn {
+
     protected Object aMethod(@ClassName("java.lang.CharSequence") Object s) {
       return "ClassNameAnnotated-" + s;
     }
   }
 
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsReturnTypeUseClassName {
+
+    protected @ClassName("java.lang.CharSequence") Object aMethod(
+        @ClassName("java.lang.CharSequence") Object s) {
+      return "ClassNameAnnotatedParamsAndReturn-" + s;
+    }
+  }
+
+  @Implements(value = AClassWithDifficultArgs.class)
+  public static class ShadowAClassWithDifficultArgsUseClassNameWithMultipleAnnotation {
+
+    protected @ClassName("java.lang.CharSequence") Object aMethod(
+        @Nullable @ClassName("java.lang.CharSequence") Object s) {
+      return "ClassNameAnnotatedMultiAnnotation-" + s;
+    }
+  }
+
   @Implements(value = AClassWithDifficultArgs.class)
   public static class ShadowAClassWithDifficultArgsUseClassNameWithMethodRename {
 
     @Implementation(methodName = "aMethod")
-    protected Object renamedMethod(@ClassName("java.lang.CharSequence") Object s) {
+    protected @ClassName("java.lang.CharSequence") Object renamedMethod(
+        @ClassName("java.lang.CharSequence") Object s) {
       return "ClassNameAnnotated-" + s;
     }
   }
 
+  @Implements(value = AClassWithGenericFunctionParam.class)
+  public static class ShadowAClassWithGenericFunctionParamUseClassNameWithTypeArgument {
+
+    protected @ClassName("java.lang.CharSequence") Object aMethod(
+        @ClassName("java.util.List<java.lang.CharSequence>") Object s) {
+      return "ClassNameGenericAnnotated-" + s;
+    }
+  }
+
+  @Implements(value = AClassWithGenericFunctionParam.class)
+  public static class ShadowAClassWithGenericFunctionParamUseClassNameTypeErasure {
+
+    protected @ClassName("java.lang.CharSequence") Object aMethod(
+        @ClassName("java.util.List") Object s) {
+      return "ClassNameGenericAnnotated";
+    }
+  }
+
   @Test
   @SandboxConfig(shadows = ShadowOfAClassWithStaticInitializer.class)
   public void classesWithInstrumentedShadowsDontDoubleInitialize() {
diff --git a/scripts/install-android-prebuilt.sh b/scripts/install-android-prebuilt.sh
index 555ef054d..2f290aeca 100755
--- a/scripts/install-android-prebuilt.sh
+++ b/scripts/install-android-prebuilt.sh
@@ -34,6 +34,13 @@ ANDROID_ALL_SRC=android-all-${ROBOLECTRIC_VERSION}-sources.jar
 ANDROID_ALL_DOC=android-all-${ROBOLECTRIC_VERSION}-javadoc.jar
 ANDROID_BUNDLE=android-all-${ROBOLECTRIC_VERSION}-bundle.jar
 
+generate_empty_sources() {
+    TMP=`mktemp --directory`
+    cd ${TMP}
+    jar cf ${JAR_DIR}/${ANDROID_ALL_SRC} .
+    cd ${JAR_DIR}; rm -rf ${TMP}
+}
+
 generate_empty_javadoc() {
     TMP=`mktemp --directory`
     cd ${TMP}
@@ -81,6 +88,7 @@ mavenize() {
 }
 
 generate_empty_javadoc
+generate_empty_sources
 build_signed_packages
 mavenize
 
diff --git a/settings.gradle b/settings.gradle
deleted file mode 100644
index 256cd155a..000000000
--- a/settings.gradle
+++ /dev/null
@@ -1,65 +0,0 @@
-import org.gradle.api.initialization.resolve.RepositoriesMode
-
-pluginManagement {
-    repositories {
-        gradlePluginPortal()
-        google()
-        mavenCentral()
-    }
-}
-
-dependencyResolutionManagement {
-    repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
-
-    repositories {
-        google()
-        mavenCentral()
-    }
-}
-
-rootProject.name = 'robolectric'
-
-include ":robolectric"
-include ":sandbox"
-include ":junit"
-include ":utils"
-include ":utils:reflector"
-include ":pluginapi"
-include ":plugins:maven-dependency-resolver"
-include ":preinstrumented"
-include ":processor"
-include ":resources"
-include ":annotations"
-include ":shadows:framework"
-include ":shadows:httpclient"
-include ":shadows:multidex"
-include ":shadows:playservices"
-include ":shadows:versioning"
-include ":shadowapi"
-include ":errorprone"
-include ":nativeruntime"
-include ":integration_tests:agp"
-include ":integration_tests:agp:testsupport"
-include ":integration_tests:dependency-on-stubs"
-include ":integration_tests:kotlin"
-include ":integration_tests:libphonenumber"
-include ":integration_tests:memoryleaks"
-include ":integration_tests:mockito"
-include ":integration_tests:mockito-kotlin"
-include ":integration_tests:mockito-experimental"
-include ":integration_tests:powermock"
-include ":integration_tests:roborazzi"
-include ':integration_tests:androidx'
-include ':integration_tests:androidx_test'
-include ':integration_tests:ctesque'
-include ':integration_tests:security-providers'
-include ":integration_tests:mockk"
-include ":integration_tests:jacoco-offline"
-include ':integration_tests:sdkcompat'
-include ":integration_tests:multidex"
-include ":integration_tests:play_services"
-include ":integration_tests:sparsearray"
-include ":integration_tests:nativegraphics"
-include ":integration_tests:room"
-include ":integration_tests:versioning"
-include ':testapp'
diff --git a/settings.gradle.kts b/settings.gradle.kts
new file mode 100644
index 000000000..ca5e97855
--- /dev/null
+++ b/settings.gradle.kts
@@ -0,0 +1,64 @@
+pluginManagement {
+  repositories {
+    gradlePluginPortal()
+    google()
+    mavenCentral()
+  }
+}
+
+dependencyResolutionManagement {
+  repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
+
+  repositories {
+    google()
+    mavenCentral()
+  }
+}
+
+rootProject.name = "robolectric"
+
+include(
+  ":robolectric",
+  ":sandbox",
+  ":junit",
+  ":utils",
+  ":utils:reflector",
+  ":pluginapi",
+  ":plugins:maven-dependency-resolver",
+  ":preinstrumented",
+  ":processor",
+  ":resources",
+  ":annotations",
+  ":shadows:framework",
+  ":shadows:httpclient",
+  ":shadows:multidex",
+  ":shadows:playservices",
+  ":shadowapi",
+  ":errorprone",
+  ":nativeruntime",
+  ":integration_tests:agp",
+  ":integration_tests:agp:testsupport",
+  ":integration_tests:dependency-on-stubs",
+  ":integration_tests:kotlin",
+  ":integration_tests:libphonenumber",
+  ":integration_tests:memoryleaks",
+  ":integration_tests:mockito",
+  ":integration_tests:mockito-kotlin",
+  ":integration_tests:mockito-experimental",
+  ":integration_tests:powermock",
+  ":integration_tests:roborazzi",
+  ":integration_tests:androidx",
+  ":integration_tests:androidx_test",
+  ":integration_tests:ctesque",
+  ":integration_tests:security-providers",
+  ":integration_tests:mockk",
+  ":integration_tests:jacoco-offline",
+  ":integration_tests:sdkcompat",
+  ":integration_tests:multidex",
+  ":integration_tests:play_services",
+  ":integration_tests:sparsearray",
+  ":integration_tests:nativegraphics",
+  ":integration_tests:room",
+  ":integration_tests:versioning",
+  ":testapp",
+)
diff --git a/shadowapi/build.gradle b/shadowapi/build.gradle
deleted file mode 100644
index c293673c1..000000000
--- a/shadowapi/build.gradle
+++ /dev/null
@@ -1,14 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    compileOnly libs.findbugs.jsr305
-
-    api project(":annotations")
-    api project(":utils")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-}
diff --git a/shadowapi/build.gradle.kts b/shadowapi/build.gradle.kts
new file mode 100644
index 000000000..c5f5595a7
--- /dev/null
+++ b/shadowapi/build.gradle.kts
@@ -0,0 +1,14 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  compileOnly(libs.findbugs.jsr305)
+
+  api(project(":annotations"))
+  api(project(":utils"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+}
diff --git a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
index 2163d4ce1..73141f13d 100644
--- a/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
+++ b/shadowapi/src/main/java/org/robolectric/util/ReflectionHelpers.java
@@ -534,6 +534,45 @@ public class ReflectionHelpers {
     }
   }
 
+  /**
+   * Reflectively check if a class has a given constructor.
+   *
+   * @param parameterTypes in order parameters of the constructor.
+   * @param clazzName Target class name.
+   * @return boolean to indicate whether the constructor exists or not on the clazz.
+   */
+  public static boolean hasConstructor(String clazzName, Class<?>... parameterTypes) {
+    Class<?> clazz =
+        ReflectionHelpers.loadClass(Thread.currentThread().getContextClassLoader(), clazzName);
+    return hasConstructor(clazz, parameterTypes);
+  }
+
+  /**
+   * Reflectively check if a class has a given constructor.
+   *
+   * @param parameterTypes in order parameters of the constructor.
+   * @param clazz Target class.
+   * @return boolean to indicate whether the constructor exists or not on the clazz.
+   */
+  public static boolean hasConstructor(Class<?> clazz, Class<?>... parameterTypes) {
+    for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {
+      Class<?>[] paramTypes = constructor.getParameterTypes();
+      if (paramTypes.length == parameterTypes.length) {
+        boolean match = true;
+        for (int i = 0; i < paramTypes.length; i++) {
+          if (!paramTypes[i].isAssignableFrom(parameterTypes[i])) {
+            match = false;
+            break;
+          }
+        }
+        if (match) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+
   private static <R, E extends Exception> R traverseClassHierarchy(
       Class<?> targetClass, Class<? extends E> exceptionClass, InsideTraversal<R> insideTraversal)
       throws Exception {
diff --git a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
index eb18eab1b..cc6c43952 100644
--- a/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
+++ b/shadowapi/src/test/java/org/robolectric/util/ReflectionHelpersTest.java
@@ -16,6 +16,16 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 @RunWith(JUnit4.class)
 public class ReflectionHelpersTest {
 
+  @Test
+  public void hasConstructor() {
+    assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, String.class)).isTrue();
+    assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, int.class)).isTrue();
+    assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, int.class, int.class))
+        .isFalse();
+    assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, double.class)).isFalse();
+    assertThat(ReflectionHelpers.hasConstructor(ExampleClass.class, Object.class)).isFalse();
+  }
+
   @Test
   public void getFieldReflectively_getsPrivateFields() {
     ExampleDescendant example = new ExampleDescendant();
diff --git a/shadows/framework/Android.bp b/shadows/framework/Android.bp
index 532f969eb..1b4ec63b8 100644
--- a/shadows/framework/Android.bp
+++ b/shadows/framework/Android.bp
@@ -63,5 +63,9 @@ java_library {
         "auto_value_builder_plugin_1.9",
         "Robolectric_processor_upstream",
     ],
-
+    errorprone: {
+        javacflags: [
+            "-Xep:ImpossibleNullComparison:WARN",
+        ],
+    },
 }
diff --git a/shadows/framework/build.gradle b/shadows/framework/build.gradle
deleted file mode 100644
index e25b4f280..000000000
--- a/shadows/framework/build.gradle
+++ /dev/null
@@ -1,66 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.shadows)
-}
-
-shadows {
-    packageName "org.robolectric"
-    sdkCheckMode "ERROR"
-}
-
-configurations {
-    sqlite4java
-}
-
-def sqlite4javaVersion = libs.versions.sqlite4java.get()
-
-tasks.register('copySqliteNatives', Copy) {
-    from project.configurations.sqlite4java {
-        include '**/*.dll'
-        include '**/*.so'
-        include '**/*.dylib'
-        rename { String filename ->
-            def filenameMatch = filename =~ /^([^\-]+)-(.+)-${sqlite4javaVersion}\.(.+)/
-            if (filenameMatch) {
-                def platformFilename = filenameMatch[0][1]
-                def platformFolder = filenameMatch[0][2]
-                def platformExtension = filenameMatch[0][3]
-
-                "${platformFolder}/${platformFilename}.${platformExtension}"
-            }
-        }
-    }
-    into project.file(layout.buildDirectory.dir("resources/main/sqlite4java"))
-}
-
-jar {
-    dependsOn copySqliteNatives
-}
-
-javadoc {
-    dependsOn copySqliteNatives
-}
-
-dependencies {
-    api project(":annotations")
-    api project(":nativeruntime")
-    api project(":resources")
-    api project(":pluginapi")
-    api project(":sandbox")
-    api project(":shadowapi")
-    api project(":utils")
-    api project(":utils:reflector")
-
-    api "androidx.test:monitor:$axtMonitorVersion@aar"
-
-    implementation libs.error.prone.annotations
-    compileOnly libs.findbugs.jsr305
-    api libs.sqlite4java
-    compileOnly(AndroidSdk.MAX_SDK.coordinates)
-    api libs.icu4j
-    api libs.auto.value.annotations
-    annotationProcessor libs.auto.value
-
-    sqlite4java libs.bundles.sqlite4java.native
-}
diff --git a/shadows/framework/build.gradle.kts b/shadows/framework/build.gradle.kts
new file mode 100644
index 000000000..d788f454c
--- /dev/null
+++ b/shadows/framework/build.gradle.kts
@@ -0,0 +1,65 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.shadows)
+}
+
+shadows {
+  packageName = "org.robolectric"
+  sdkCheckMode = "ERROR"
+}
+
+val sqlite4java = configurations.create("sqlite4java")
+val sqlite4javaVersion = libs.versions.sqlite4java.get()
+
+val copySqliteNatives by
+  tasks.registering(Copy::class) {
+    from(sqlite4java) {
+      include("**/*.dll")
+      include("**/*.so")
+      include("**/*.dylib")
+
+      rename { filename ->
+        val filenameMatch = "^([^\\-]+)-(.+)-${sqlite4javaVersion}\\.(.+)".toRegex().find(filename)
+        if (filenameMatch != null) {
+          val platformFilename = filenameMatch.groupValues[1]
+          val platformFolder = filenameMatch.groupValues[2]
+          val platformExtension = filenameMatch.groupValues[3]
+
+          "$platformFolder/$platformFilename.$platformExtension"
+        } else {
+          filename
+        }
+      }
+    }
+    into(project.file(layout.buildDirectory.dir("resources/main/sqlite4java")))
+  }
+
+tasks.jar.configure { dependsOn(copySqliteNatives) }
+
+tasks.javadoc.configure { dependsOn(copySqliteNatives) }
+
+val axtMonitorVersion: String by rootProject.extra
+
+dependencies {
+  api(project(":annotations"))
+  api(project(":nativeruntime"))
+  api(project(":resources"))
+  api(project(":pluginapi"))
+  api(project(":sandbox"))
+  api(project(":shadowapi"))
+  api(project(":utils"))
+  api(project(":utils:reflector"))
+
+  api("androidx.test:monitor:$axtMonitorVersion@aar")
+
+  implementation(libs.error.prone.annotations)
+  compileOnly(libs.findbugs.jsr305)
+  api(libs.sqlite4java)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+  api(libs.icu4j)
+  api(libs.auto.value.annotations)
+  annotationProcessor(libs.auto.value)
+
+  sqlite4java(libs.bundles.sqlite4java.native)
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
index 4b6d31b23..756160826 100644
--- a/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
+++ b/shadows/framework/src/main/java/org/robolectric/RuntimeEnvironment.java
@@ -1,11 +1,14 @@
 package org.robolectric;
 
+import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.annotation.LooperMode.Mode.LEGACY;
 import static org.robolectric.shadows.ShadowLooper.assertLooperMode;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.Application;
 import android.app.ResourcesManager;
 import android.content.Context;
+import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -20,6 +23,7 @@ import org.robolectric.shadows.ShadowInstrumentation;
 import org.robolectric.shadows.ShadowView;
 import org.robolectric.util.Scheduler;
 import org.robolectric.util.TempDirectory;
+import org.robolectric.util.reflector.ForType;
 
 public class RuntimeEnvironment {
   /**
@@ -43,10 +47,10 @@ public class RuntimeEnvironment {
   private static Scheduler masterScheduler;
   private static TempDirectory tempDirectory = new TempDirectory("no-test-yet");
   private static Path androidFrameworkJar;
-  public static Path compileTimeSystemResourcesFile;
 
   private static Supplier<Application> applicationSupplier;
   private static final Object supplierLock = new Object();
+  private static Supplier<Path> compileTimeSystemResourcesSupplier;
 
   /**
    * Get a reference to the {@link Application} under test.
@@ -227,9 +231,17 @@ public class RuntimeEnvironment {
   private static void updateConfiguration(
       Configuration configuration, DisplayMetrics displayMetrics) {
     // Update the resources last so that listeners will have a consistent environment.
-    // TODO(paulsowden): Can we call ResourcesManager.getInstance().applyConfigurationToResources()?
     if (ResourcesManager.getInstance().getConfiguration() != null) {
-      ResourcesManager.getInstance().getConfiguration().updateFrom(configuration);
+      if (System.getProperty("robolectric.configurationChangeFix", "true").equals("true")) {
+        if (getApiLevel() <= Q) {
+          reflector(ResourcesManagerReflector.class, ResourcesManager.getInstance())
+              .applyConfigurationToResourcesLocked(configuration, null);
+        } else {
+          ResourcesManager.getInstance().applyConfigurationToResources(configuration, null);
+        }
+      } else {
+        ResourcesManager.getInstance().getConfiguration().updateFrom(configuration);
+      }
     }
     Resources.getSystem().updateConfiguration(configuration, displayMetrics);
     if (RuntimeEnvironment.application != null) {
@@ -287,4 +299,24 @@ public class RuntimeEnvironment {
   public static Path getAndroidFrameworkJarPath() {
     return RuntimeEnvironment.androidFrameworkJar;
   }
+
+  /** internal use only */
+  public static void setCompileTimeSystemResources(
+      Supplier<Path> compileTimeSystemResourcesSupplier) {
+    RuntimeEnvironment.compileTimeSystemResourcesSupplier = compileTimeSystemResourcesSupplier;
+  }
+
+  /**
+   * @deprecated obsolete do not use
+   */
+  @Deprecated
+  public static Path getCompileTimeSystemResourcesPath() {
+    return compileTimeSystemResourcesSupplier.get();
+  }
+
+  @ForType(ResourcesManager.class)
+  interface ResourcesManagerReflector {
+    boolean applyConfigurationToResourcesLocked(
+        Configuration configuration, CompatibilityInfo compatibilityInfo);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
index 1381b2e22..6463bace8 100644
--- a/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
+++ b/shadows/framework/src/main/java/org/robolectric/android/controller/ActivityController.java
@@ -20,7 +20,6 @@ import android.content.pm.ActivityInfo;
 import android.content.pm.ActivityInfo.Config;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
-import android.content.res.Resources;
 import android.os.Bundle;
 import android.util.DisplayMetrics;
 import android.view.Display;
@@ -235,7 +234,6 @@ public class ActivityController<T extends Activity>
     // root can be null if activity does not have content attached, or if looper is paused.
     // this is unusual but leave the check here for legacy compatibility
     if (root != null) {
-      callDispatchResized(root);
       shadowMainLooper.idleIfPaused();
     }
     return this;
@@ -366,13 +364,8 @@ public class ActivityController<T extends Activity>
   /**
    * Performs a configuration change on the Activity. See {@link #configurationChange(Configuration,
    * DisplayMetrics, int)}. The configuration is taken from the application's configuration.
-   *
-   * <p>Generally this method should be avoided due to the way Robolectric shares the application
-   * context with activitys by default, this will result in the configuration diff producing no
-   * indicated change and Robolectric will not recreate the activity. Instead prefer to use {@link
-   * #configurationChange(Configuration, DisplayMetrics, int)} and provide an explicit configuration
-   * and diff.
    */
+  @CanIgnoreReturnValue
   public ActivityController<T> configurationChange() {
     return configurationChange(component.getApplicationContext().getResources().getConfiguration());
   }
@@ -381,19 +374,40 @@ public class ActivityController<T extends Activity>
    * Performs a configuration change on the Activity. See {@link #configurationChange(Configuration,
    * DisplayMetrics, int)}. The changed configuration is calculated based on the activity's existing
    * configuration.
-   *
-   * <p>When using {@link RuntimeEnvironment#setQualifiers(String)} prefer to use the {@link
-   * #configurationChange(Configuration, DisplayMetrics, int)} method and calculate the
-   * configuration diff manually, due to the way Robolectric uses the application context for
-   * activitys by default the configuration diff will otherwise be incorrectly calculated and the
-   * activity will not get recreqted if it doesn't handle configuration change.
    */
+  @CanIgnoreReturnValue
   public ActivityController<T> configurationChange(final Configuration newConfiguration) {
-    Resources resources = component.getResources();
-    return configurationChange(
-        newConfiguration,
-        resources.getDisplayMetrics(),
-        resources.getConfiguration().diff(newConfiguration));
+    return configurationChange(newConfiguration, component.getResources().getDisplayMetrics());
+  }
+
+  /**
+   * Performs a configuration change on the Activity.
+   *
+   * <p>If the activity is configured to handle changes without being recreated, {@link
+   * Activity#onConfigurationChanged(Configuration)} will be called. Otherwise, the activity is
+   * recreated as described <a
+   * href="https://developer.android.com/guide/topics/resources/runtime-changes.html">here</a>.
+   *
+   * <p>Typically configuration should be applied using {@link RuntimeEnvironment#setQualifiers} and
+   * then propagated to the activity controller, e.g.
+   *
+   * <pre>{@code
+   * RuntimeEnvironment.setQualifiers("+ar-rXB");
+   * activityController.configurationChange();
+   * }</pre>
+   *
+   * @param newConfiguration The new configuration to be set.
+   * @return ActivityController instance
+   */
+  @CanIgnoreReturnValue
+  public ActivityController<T> configurationChange(
+      Configuration newConfiguration, DisplayMetrics newMetrics) {
+    ActivityReflector activityReflector = reflector(ActivityReflector.class, component);
+    Configuration currentConfig =
+        System.getProperty("robolectric.configurationChangeFix", "true").equals("true")
+            ? activityReflector.getCurrentConfig()
+            : component.getResources().getConfiguration();
+    return configurationChange(newConfiguration, newMetrics, currentConfig.diff(newConfiguration));
   }
 
   /**
@@ -421,13 +435,12 @@ public class ActivityController<T extends Activity>
    *     {@link Configuration#diff(Configuration)}). This will be used to determine whether the
    *     activity handles the configuration change or not, and whether it must be recreated.
    * @return ActivityController instance
+   * @deprecated The config change should be calculated internally by the activity controller based
+   *     on the previous configuration, use {@link #configurationChange(Configuration,
+   *     DisplayMetrics)} instead.
    */
-  // TODO: Passing in the changed config explicitly should be unnecessary (i.e. the controller
-  //  should be able to diff against the current activity configuration), but due to the way
-  //  Robolectric uses the application context as the default activity context the application
-  //  context may be updated before entering this method (e.g. if RuntimeEnvironment#setQualifiers
-  //  was called before calling this method). When this issue is fixed this method should be
-  //  deprecated and removed.
+  @Deprecated
+  @CanIgnoreReturnValue
   public ActivityController<T> configurationChange(
       Configuration newConfiguration, DisplayMetrics newMetrics, @Config int changedConfig) {
     component.getResources().updateConfiguration(newConfiguration, newMetrics);
@@ -440,6 +453,9 @@ public class ActivityController<T extends Activity>
         == filteredChanges) {
       shadowMainLooper.runPaused(
           () -> {
+            reflector(ActivityReflector.class, component)
+                .getCurrentConfig()
+                .setTo(newConfiguration);
             component.onConfigurationChanged(newConfiguration);
             ViewRootImpl root = getViewRoot();
             if (root != null) {
@@ -585,15 +601,15 @@ public class ActivityController<T extends Activity>
     switch (originalState) {
       case INITIAL:
         create();
-        // fall through
+      // fall through
       case CREATED:
       case RESTARTED:
         start();
         postCreate(null);
-        // fall through
+      // fall through
       case STARTED:
         resume();
-        // fall through
+      // fall through
       default:
         // fall through
     }
@@ -613,10 +629,10 @@ public class ActivityController<T extends Activity>
       case STARTED:
       case RESUMED:
         pause();
-        // fall through
+      // fall through
       case PAUSED:
         stop();
-        // fall through
+      // fall through
       case STOPPED:
         break;
       default:
@@ -678,16 +694,16 @@ public class ActivityController<T extends Activity>
         return;
       case RESUMED:
         pause();
-        // fall through
+      // fall through
       case PAUSED:
-        // fall through
+      // fall through
       case RESTARTED:
-        // fall through
+      // fall through
       case STARTED:
         stop();
-        // fall through
+      // fall through
       case STOPPED:
-        // fall through
+      // fall through
       case CREATED:
         break;
     }
@@ -712,4 +728,10 @@ public class ActivityController<T extends Activity>
     @Accessor("activity")
     Object getActivity();
   }
+
+  @ForType(Activity.class)
+  interface ActivityReflector {
+    @Accessor("mCurrentConfig")
+    Configuration getCurrentConfig();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
index 4b9217ae8..ac4ef50bc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/AssociationInfoBuilder.java
@@ -1,12 +1,17 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.companion.AssociationInfo;
+import android.graphics.drawable.Icon;
 import android.net.MacAddress;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Constructor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Builder for {@link AssociationInfo}. */
@@ -109,6 +114,28 @@ public class AssociationInfoBuilder {
     try {
       MacAddress macAddress =
           deviceMacAddress == null ? null : MacAddress.fromString(deviceMacAddress);
+
+      if (getNumOfConstructorParams() == 16) {
+        return reflector(AssociationInfoReflector.class)
+            .nwwAssociationInfoPostV(
+                id,
+                userId,
+                packageName,
+                tag,
+                macAddress,
+                displayName,
+                deviceProfile,
+                associatedDevice,
+                selfManaged,
+                notifyOnDeviceNearby,
+                revoked,
+                pending,
+                approvedMs,
+                lastTimeConnectedMs,
+                systemDataSyncFlags,
+                null /* icon */);
+      }
+      // TODO: convert the rest of this logic to use number of parameters and reflector
       if (RuntimeEnvironment.getApiLevel() <= TIRAMISU) {
         // We have two different constructors for AssociationInfo across
         // T branches. aosp has the constructor that takes a new "revoked" parameter.
@@ -202,4 +229,36 @@ public class AssociationInfoBuilder {
       throw new RuntimeException(e);
     }
   }
+
+  private static int getNumOfConstructorParams() {
+    for (java.lang.reflect.Constructor<?> constructor :
+        AssociationInfo.class.getDeclaredConstructors()) {
+      if (constructor.getParameterCount() > 1) {
+        return constructor.getParameterCount();
+      }
+    }
+    throw new IllegalStateException("Could not find a AssociationInfo constructor");
+  }
+
+  @ForType(AssociationInfo.class)
+  interface AssociationInfoReflector {
+    @Constructor
+    AssociationInfo nwwAssociationInfoPostV(
+        int id,
+        int userId,
+        String packageName,
+        String tag,
+        MacAddress macAddress,
+        CharSequence displayName,
+        String deviceProfile,
+        @WithType("android.companion.AssociatedDevice") Object associatedDevice,
+        boolean selfManaged,
+        boolean notifyOnDeviceNearby,
+        boolean revoked,
+        boolean pending,
+        long timeApprovedMs,
+        long lastTimeConnectedMs,
+        int systemDataSyncFlags,
+        Icon icon);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/InputDeviceBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/InputDeviceBuilder.java
new file mode 100644
index 000000000..874ececcf
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/InputDeviceBuilder.java
@@ -0,0 +1,133 @@
+package org.robolectric.shadows;
+
+import android.view.InputDevice;
+import android.view.KeyCharacterMap;
+
+/**
+ * Builder for {@link android.view.InputDevice}.
+ *
+ * <p>This exposes the setters for public InputDevice attributes. Its implemented by wrapping the
+ * hidden android.view.InputDevice.Builder. Tests building against the android platform source
+ * should just use that API instead.
+ *
+ * <p>Only supported when running on SDKs >= 34
+ */
+public class InputDeviceBuilder {
+
+  private InputDeviceBuilder() {}
+
+  public static InputDeviceBuilder newBuilder() {
+    return new InputDeviceBuilder();
+  }
+
+  private final InputDevice.Builder delegate = new InputDevice.Builder();
+
+  /**
+   * @see InputDevice#getId()
+   */
+  public InputDeviceBuilder setId(int id) {
+    delegate.setId(id);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getControllerNumber()
+   */
+  public InputDeviceBuilder setControllerNumber(int controllerNumber) {
+    delegate.setControllerNumber(controllerNumber);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getName()
+   */
+  public InputDeviceBuilder setName(String name) {
+    delegate.setName(name);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getVendorId()
+   */
+  public InputDeviceBuilder setVendorId(int vendorId) {
+    delegate.setVendorId(vendorId);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getProductId()
+   */
+  public InputDeviceBuilder setProductId(int productId) {
+    delegate.setProductId(productId);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getDescriptor()
+   */
+  public InputDeviceBuilder setDescriptor(String descriptor) {
+    delegate.setDescriptor(descriptor);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#isExternal()
+   */
+  public InputDeviceBuilder setExternal(boolean external) {
+    delegate.setExternal(external);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getSources()
+   */
+  public InputDeviceBuilder setSources(int sources) {
+    delegate.setSources(sources);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getKeyboardType()
+   */
+  public InputDeviceBuilder setKeyboardType(int keyboardType) {
+    delegate.setKeyboardType(keyboardType);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getKeyCharacterMap()
+   */
+  public InputDeviceBuilder setKeyCharacterMap(KeyCharacterMap keyCharacterMap) {
+    delegate.setKeyCharacterMap(keyCharacterMap);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getVibrator()
+   */
+  public InputDeviceBuilder setHasVibrator(boolean hasVibrator) {
+    delegate.setHasVibrator(hasVibrator);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#hasMicrophone()
+   */
+  public InputDeviceBuilder setHasMicrophone(boolean hasMicrophone) {
+    delegate.setHasMicrophone(hasMicrophone);
+    return this;
+  }
+
+  /**
+   * @see InputDevice#getMotionRanges()
+   */
+  public InputDeviceBuilder addMotionRange(
+      int axis, int source, float min, float max, float flat, float fuzz, float resolution) {
+    delegate.addMotionRange(axis, source, min, max, flat, fuzz, resolution);
+    return this;
+  }
+
+  public InputDevice build() {
+    return delegate.build();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/OsConstantsValues.java b/shadows/framework/src/main/java/org/robolectric/shadows/OsConstantsValues.java
deleted file mode 100644
index 0532c4fc3..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/OsConstantsValues.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.robolectric.shadows;
-
-import com.google.common.collect.ImmutableMap;
-import java.io.File;
-
-/**
- * Provides a utility class for OsConstants See
- * https://unix.superglobalmegacorp.com/Net2/newsrc/sys/stat.h.html.
- */
-final class OsConstantsValues {
-
-  private OsConstantsValues() {}
-
-  // Type of file.
-  public static final String S_IFMT = "S_IFMT";
-
-  // Directory.
-  public static final String S_IFDIR = "S_IFDIR";
-
-  // Regular file.
-  public static final String S_IFREG = "S_IFREG";
-
-  // Symbolic link.
-  public static final String S_IFLNK = "S_IFLNK";
-
-  // Type of file value.
-  public static final int S_IFMT_VALUE = 0x0170000;
-
-  // Directory value.
-  public static final int S_IFDIR_VALUE = 0x0040000;
-
-  // Regular file value.
-  public static final int S_IFREG_VALUE = 0x0100000;
-
-  // Link value.
-  public static final int S_IFLNK_VALUE = 0x0120000;
-
-  // File open mode values from
-  // https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/fcntl.h
-  static final ImmutableMap<String, Integer> OPEN_MODE_VALUES =
-      new ImmutableMap.Builder<String, Integer>()
-          .put("O_RDONLY", 0x0000)
-          .put("O_WRONLY", 0x0001)
-          .put("O_RDWR", 0x0002)
-          .put("O_ACCMODE", 0x0003)
-          .put("O_CREAT", 0x0100)
-          .put("O_EXCL", 0x0200)
-          .put("O_TRUNC", 0x1000)
-          .put("O_APPEND", 0x2000)
-          .build();
-
-  /** Returns the st_mode for the path. */
-  public static int getMode(String path) {
-    if (path == null) {
-      return 0;
-    }
-
-    File file = new File(path);
-    if (file.isDirectory()) {
-      return S_IFDIR_VALUE;
-    }
-    if (file.isFile()) {
-      return S_IFREG_VALUE;
-    }
-    if (!canonicalize(path).equals(path)) {
-      return S_IFLNK_VALUE;
-    }
-    return 0;
-  }
-
-  private static String canonicalize(String path) {
-    try {
-      return new File(path).getCanonicalPath();
-    } catch (Throwable t) {
-      throw new RuntimeException(t);
-    }
-  }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
index 86ad50c43..7e88a6eec 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ResourceModeShadowPicker.java
@@ -51,7 +51,7 @@ public class ResourceModeShadowPicker<T> implements ShadowPicker<T> {
 
   @Override
   public Class<? extends T> pickShadowClass() {
-    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT
+    if (RuntimeEnvironment.getApiLevel() > V.SDK_INT
         && nativeShadowClass != null
         && ConfigurationRegistry.get(ResourcesMode.Mode.class) == Mode.NATIVE) {
       return nativeShadowClass;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
index f2f53a073..558574434 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityManager.java
@@ -8,16 +8,20 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.accessibilityservice.AccessibilityServiceInfo;
 import android.content.Context;
 import android.content.pm.ServiceInfo;
+import android.graphics.Matrix;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.util.ArrayMap;
 import android.util.Log;
+import android.view.MagnificationSpec;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.view.accessibility.AccessibilityManager.AccessibilityStateChangeListener;
 import android.view.accessibility.AccessibilityManager.TouchExplorationStateChangeListener;
 import android.view.accessibility.IAccessibilityManager;
+import android.view.accessibility.IAccessibilityManager.WindowTransformationSpec;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -25,6 +29,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import javax.annotation.Nullable;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -36,6 +41,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.U;
 
 @Implements(AccessibilityManager.class)
 public class ShadowAccessibilityManager {
@@ -43,14 +49,15 @@ public class ShadowAccessibilityManager {
   private static final Object sInstanceSync = new Object();
 
   @RealObject AccessibilityManager realAccessibilityManager;
-  private final List<AccessibilityEvent> sentAccessibilityEvents = new ArrayList<>();
-  private boolean enabled;
-  private List<AccessibilityServiceInfo> installedAccessibilityServiceList = new ArrayList<>();
-  private List<AccessibilityServiceInfo> enabledAccessibilityServiceList = new ArrayList<>();
-  private List<ServiceInfo> accessibilityServiceList = new ArrayList<>();
-  private final HashMap<AccessibilityStateChangeListener, Handler>
+  private static final List<AccessibilityEvent> sentAccessibilityEvents = new ArrayList<>();
+  private static boolean enabled;
+  private static List<AccessibilityServiceInfo> installedAccessibilityServiceList =
+      new ArrayList<>();
+  private static List<AccessibilityServiceInfo> enabledAccessibilityServiceList = new ArrayList<>();
+  private static List<ServiceInfo> accessibilityServiceList = new ArrayList<>();
+  private static final HashMap<AccessibilityStateChangeListener, Handler>
       onAccessibilityStateChangeListeners = new HashMap<>();
-  private boolean touchExplorationEnabled;
+  private static boolean touchExplorationEnabled;
 
   private static boolean isAccessibilityButtonSupported = true;
 
@@ -59,6 +66,13 @@ public class ShadowAccessibilityManager {
     synchronized (sInstanceSync) {
       sInstance = null;
     }
+    sentAccessibilityEvents.clear();
+    enabled = false;
+    installedAccessibilityServiceList.clear();
+    enabledAccessibilityServiceList.clear();
+    accessibilityServiceList.clear();
+    onAccessibilityStateChangeListeners.clear();
+    touchExplorationEnabled = false;
     isAccessibilityButtonSupported = true;
   }
 
@@ -124,6 +138,7 @@ public class ShadowAccessibilityManager {
   }
 
   public void setAccessibilityServiceList(List<ServiceInfo> accessibilityServiceList) {
+    Preconditions.checkNotNull(accessibilityServiceList);
     this.accessibilityServiceList = new ArrayList<>(accessibilityServiceList);
   }
 
@@ -131,19 +146,13 @@ public class ShadowAccessibilityManager {
   @Implementation
   protected List<AccessibilityServiceInfo> getEnabledAccessibilityServiceList(
       int feedbackTypeFlags) {
-    // TODO(hoisie): prohibit null values for enabledAccessibilityServiceList
-    if (enabledAccessibilityServiceList == null) {
-      return null;
-    }
     return Collections.unmodifiableList(enabledAccessibilityServiceList);
   }
 
   public void setEnabledAccessibilityServiceList(
       List<AccessibilityServiceInfo> enabledAccessibilityServiceList) {
-    this.enabledAccessibilityServiceList =
-        enabledAccessibilityServiceList == null
-            ? null
-            : new ArrayList<>(enabledAccessibilityServiceList);
+    Preconditions.checkNotNull(enabledAccessibilityServiceList);
+    this.enabledAccessibilityServiceList = new ArrayList<>(enabledAccessibilityServiceList);
   }
 
   @Implementation
@@ -153,6 +162,7 @@ public class ShadowAccessibilityManager {
 
   public void setInstalledAccessibilityServiceList(
       List<AccessibilityServiceInfo> installedAccessibilityServiceList) {
+    Preconditions.checkNotNull(installedAccessibilityServiceList);
     this.installedAccessibilityServiceList = new ArrayList<>(installedAccessibilityServiceList);
   }
 
@@ -225,6 +235,23 @@ public class ShadowAccessibilityManager {
     setTouchExplorationEnabled(true);
   }
 
+  /**
+   * This shadow method is required because {@link
+   * android.view.accessibility.DirectAccessibilityConnection} calls it to determine if any
+   * transformations have occurred on this window.
+   */
+  @Implementation(minSdk = U.SDK_INT)
+  protected @ClassName("android.view.accessibility.IAccessibilityManager.WindowTransformationSpec")
+  Object getWindowTransformationSpec(int windowId) {
+    // Return a value that represents no transformation.
+    WindowTransformationSpec spec = new WindowTransformationSpec();
+    spec.magnificationSpec = new MagnificationSpec();
+    float[] matrix = new float[9];
+    Matrix.IDENTITY_MATRIX.getValues(matrix);
+    spec.transformationMatrix = matrix;
+    return spec;
+  }
+
   /**
    * Sets that the system navigation area is supported accessibility button; controls the return
    * value of {@link AccessibilityManager#isAccessibilityButtonSupported()}.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
index 07666610a..195ef089f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityNodeInfo.java
@@ -1,30 +1,20 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static android.os.Build.VERSION_CODES.N;
-import static android.os.Build.VERSION_CODES.O;
-import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.R;
-import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.RuntimeEnvironment.getApiLevel;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.graphics.Rect;
 import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
 import android.util.Pair;
-import android.util.SparseArray;
 import android.view.View;
 import android.view.accessibility.AccessibilityNodeInfo;
-import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
 import android.view.accessibility.AccessibilityWindowInfo;
+import com.google.common.base.Preconditions;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -33,10 +23,11 @@ import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
-import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.U;
 
 /**
  * Properties of {@link android.view.accessibility.AccessibilityNodeInfo} that are normally locked
@@ -46,33 +37,9 @@ import org.robolectric.util.reflector.Static;
  */
 @Implements(AccessibilityNodeInfo.class)
 public class ShadowAccessibilityNodeInfo {
-  // Map of obtained instances of the class along with stack traces of how they were obtained
-  private static final Map<StrictEqualityNodeWrapper, StackTraceElement[]> obtainedInstances =
-      new HashMap<>();
-
-  private static final SparseArray<StrictEqualityNodeWrapper> orderedInstances =
-      new SparseArray<>();
-
-  public static final Parcelable.Creator<AccessibilityNodeInfo> CREATOR =
-      new Parcelable.Creator<AccessibilityNodeInfo>() {
-
-        @Override
-        public AccessibilityNodeInfo createFromParcel(Parcel source) {
-          return obtain(orderedInstances.get(source.readInt()).mInfo);
-        }
-
-        @Override
-        public AccessibilityNodeInfo[] newArray(int size) {
-          return new AccessibilityNodeInfo[size];
-        }
-      };
 
   private static int sAllocationCount = 0;
 
-  private static final int PASTEABLE_MASK = 0x00000040;
-
-  private static final int TEXT_SELECTION_SETABLE_MASK = 0x00000100;
-
   /**
    * Uniquely identifies the origin of the AccessibilityNodeInfo for equality testing. Two instances
    * that come from the same node info should have the same ID.
@@ -103,38 +70,110 @@ public class ShadowAccessibilityNodeInfo {
 
   private OnPerformActionListener actionListener;
 
+  private static boolean queryFromAppProcessWasEnabled;
+
   @RealObject private AccessibilityNodeInfo realAccessibilityNodeInfo;
 
   @ReflectorObject AccessibilityNodeInfoReflector accessibilityNodeInfoReflector;
 
-  @Implementation
-  protected void __constructor__() {
-    reflector(AccessibilityNodeInfoReflector.class).setCreator(ShadowAccessibilityNodeInfo.CREATOR);
-    Shadow.invokeConstructor(AccessibilityNodeInfo.class, realAccessibilityNodeInfo);
-  }
-
   @Implementation
   protected static AccessibilityNodeInfo obtain(AccessibilityNodeInfo info) {
+    if (useRealAni()) {
+      return reflector(AccessibilityNodeInfoReflector.class).obtain(info);
+    }
+    // We explicitly avoid allocating the AccessibilityNodeInfo from the actual pool by using
+    // the private constructor. Not doing so affects test suites which use both shadow and
+    // non-shadow objects.
+    final AccessibilityNodeInfo newInfo;
+    if (RuntimeEnvironment.getApiLevel() >= R) {
+      newInfo = reflector(AccessibilityNodeInfoReflector.class).newInstance(info);
+    } else {
+      newInfo = Shadow.newInstanceOf(AccessibilityNodeInfo.class);
+      reflector(AccessibilityNodeInfoReflector.class, newInfo).init(info);
+    }
+
+    final ShadowAccessibilityNodeInfo newShadow = Shadow.extract(newInfo);
     final ShadowAccessibilityNodeInfo shadowInfo = Shadow.extract(info);
-    final AccessibilityNodeInfo obtainedInstance = shadowInfo.getClone();
+    newShadow.mOriginNodeId = shadowInfo.mOriginNodeId;
+    newShadow.text = shadowInfo.text;
+    newShadow.performedActionAndArgsList = shadowInfo.performedActionAndArgsList;
+    newShadow.parent = shadowInfo.parent;
+    newShadow.labelFor = (shadowInfo.labelFor == null) ? null : obtain(shadowInfo.labelFor);
+    newShadow.labeledBy = (shadowInfo.labeledBy == null) ? null : obtain(shadowInfo.labeledBy);
+    newShadow.view = shadowInfo.view;
+    newShadow.actionListener = shadowInfo.actionListener;
+
+    if (shadowInfo.children != null) {
+      newShadow.children = new ArrayList<>();
+      newShadow.children.addAll(shadowInfo.children);
+    } else {
+      newShadow.children = null;
+    }
 
-    sAllocationCount++;
+    newShadow.refreshReturnValue = shadowInfo.refreshReturnValue;
+
+    if (getApiLevel() >= LOLLIPOP_MR1) {
+      newShadow.traversalAfter =
+          (shadowInfo.traversalAfter == null) ? null : obtain(shadowInfo.traversalAfter);
+      newShadow.traversalBefore =
+          (shadowInfo.traversalBefore == null) ? null : obtain(shadowInfo.traversalBefore);
+    }
+    if (shadowInfo.accessibilityWindowInfo != null) {
+      newShadow.accessibilityWindowInfo =
+          ShadowAccessibilityWindowInfo.obtain(shadowInfo.accessibilityWindowInfo);
+    }
+
+    ShadowAccessibilityNodeInfo.sAllocationCount++;
     if (shadowInfo.mOriginNodeId == 0) {
       shadowInfo.mOriginNodeId = sAllocationCount;
     }
-    StrictEqualityNodeWrapper wrapper = new StrictEqualityNodeWrapper(obtainedInstance);
-    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());
-    orderedInstances.put(sAllocationCount, wrapper);
-    return obtainedInstance;
+    return newInfo;
   }
 
   @Implementation
   protected static AccessibilityNodeInfo obtain(View view) {
-    // We explicitly avoid allocating the AccessibilityNodeInfo from the actual pool by using the
-    // private constructor. Not doing so affects test suites which use both shadow and
-    // non-shadow objects.
+    if (useRealAni()) {
+      return reflector(AccessibilityNodeInfoReflector.class).obtain(view);
+    }
+    // Call the constructor directly to avoid using the object pool.
+    final AccessibilityNodeInfo obtainedInstance =
+        ReflectionHelpers.callConstructor(AccessibilityNodeInfo.class);
+    obtainedInstance.setSource(view);
+    initShadow(obtainedInstance);
+    return obtainedInstance;
+  }
+
+  @Implementation
+  protected static AccessibilityNodeInfo obtain(View root, int virtualDescendantId) {
+    if (useRealAni()) {
+      return reflector(AccessibilityNodeInfoReflector.class).obtain(root, virtualDescendantId);
+    }
+
+    // Call the constructor directly to avoid using the object pool.
     final AccessibilityNodeInfo obtainedInstance =
         ReflectionHelpers.callConstructor(AccessibilityNodeInfo.class);
+    obtainedInstance.setSource(root, virtualDescendantId);
+    initShadow(obtainedInstance);
+    return obtainedInstance;
+  }
+
+  @Implementation
+  protected static AccessibilityNodeInfo obtain() {
+    if (useRealAni()) {
+      return reflector(AccessibilityNodeInfoReflector.class).obtain();
+    }
+    AccessibilityNodeInfo obtainedInstance =
+        ReflectionHelpers.callConstructor(AccessibilityNodeInfo.class);
+    initShadow(obtainedInstance);
+    // TODO(hoisie): Remove this hack. It was added many years ago for and is highly inconsistent
+    // with real Android. It is a broken and arbitrary way to make ANI objects not be
+    // considered equal to each other.
+    ShadowAccessibilityNodeInfo shadowObtained = Shadow.extract(obtainedInstance);
+    shadowObtained.view = new View(RuntimeEnvironment.getApplication().getApplicationContext());
+    return obtainedInstance;
+  }
+
+  private static void initShadow(AccessibilityNodeInfo obtainedInstance) {
     final ShadowAccessibilityNodeInfo shadowObtained = Shadow.extract(obtainedInstance);
 
     /*
@@ -148,68 +187,22 @@ public class ShadowAccessibilityNodeInfo {
      */
     shadowObtained.performedActionAndArgsList = new ArrayList<>();
 
-    shadowObtained.view = view;
     sAllocationCount++;
     if (shadowObtained.mOriginNodeId == 0) {
       shadowObtained.mOriginNodeId = sAllocationCount;
     }
-    StrictEqualityNodeWrapper wrapper = new StrictEqualityNodeWrapper(obtainedInstance);
-    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());
-    orderedInstances.put(sAllocationCount, wrapper);
-    return obtainedInstance;
   }
 
-  @Implementation
-  protected static AccessibilityNodeInfo obtain() {
-    return obtain(new View(RuntimeEnvironment.getApplication().getApplicationContext()));
-  }
-
-  @Implementation
-  protected static AccessibilityNodeInfo obtain(View root, int virtualDescendantId) {
-    AccessibilityNodeInfo node = obtain(root);
-    return node;
-  }
-
-  /**
-   * Check for leaked objects that were {@code obtain}ed but never {@code recycle}d.
-   *
-   * @param printUnrecycledNodesToSystemErr - if true, stack traces of calls to {@code obtain} that
-   *     lack matching calls to {@code recycle} are dumped to System.err.
-   * @return {@code true} if there are unrecycled nodes
-   */
-  public static boolean areThereUnrecycledNodes(boolean printUnrecycledNodesToSystemErr) {
-    if (printUnrecycledNodesToSystemErr) {
-      for (final StrictEqualityNodeWrapper wrapper : obtainedInstances.keySet()) {
-        final ShadowAccessibilityNodeInfo shadow = Shadow.extract(wrapper.mInfo);
-
-        System.err.printf(
-            "Leaked contentDescription = %s. Stack trace:%n",
-            shadow.realAccessibilityNodeInfo.getContentDescription());
-        for (final StackTraceElement stackTraceElement : obtainedInstances.get(wrapper)) {
-          System.err.println(stackTraceElement.toString());
-        }
-      }
-    }
-
-    return (obtainedInstances.size() != 0);
-  }
-
-  /**
-   * Clear list of obtained instance objects. {@code areThereUnrecycledNodes} will always return
-   * false if called immediately afterwards.
-   */
   @Resetter
   public static void resetObtainedInstances() {
-    obtainedInstances.clear();
-    orderedInstances.clear();
+    queryFromAppProcessWasEnabled = false;
   }
 
   @Implementation
   protected void recycle() {
-    final StrictEqualityNodeWrapper wrapper =
-        new StrictEqualityNodeWrapper(realAccessibilityNodeInfo);
-    if (!obtainedInstances.containsKey(wrapper)) {
-      throw new IllegalStateException();
+    if (useRealAni()) {
+      accessibilityNodeInfoReflector.recycle();
+      return;
     }
 
     if (labelFor != null) {
@@ -228,21 +221,13 @@ public class ShadowAccessibilityNodeInfo {
         traversalBefore.recycle();
       }
     }
-
-    obtainedInstances.remove(wrapper);
-    int keyOfWrapper = -1;
-    for (int i = 0; i < orderedInstances.size(); i++) {
-      int key = orderedInstances.keyAt(i);
-      if (orderedInstances.get(key).equals(wrapper)) {
-        keyOfWrapper = key;
-        break;
-      }
-    }
-    orderedInstances.remove(keyOfWrapper);
   }
 
   @Implementation
   protected int getChildCount() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getChildCount();
+    }
     if (children == null) {
       return 0;
     }
@@ -252,6 +237,9 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected AccessibilityNodeInfo getChild(int index) {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getChild(index);
+    }
     if (children == null) {
       return null;
     }
@@ -266,6 +254,9 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected AccessibilityNodeInfo getParent() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getParent();
+    }
     if (parent == null) {
       return null;
     }
@@ -275,43 +266,39 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected boolean refresh() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.refresh();
+    }
     return refreshReturnValue;
   }
 
   public void setRefreshReturnValue(boolean refreshReturnValue) {
+    checkRealAniDisabled();
     this.refreshReturnValue = refreshReturnValue;
   }
 
-  public boolean isPasteable() {
-    return (accessibilityNodeInfoReflector.getBooleanProperties() & PASTEABLE_MASK) != 0;
-  }
-
-  public boolean isTextSelectionSetable() {
-    return (accessibilityNodeInfoReflector.getBooleanProperties() & TEXT_SELECTION_SETABLE_MASK)
-        != 0;
-  }
-
-  public void setTextSelectionSetable(boolean isTextSelectionSetable) {
-    accessibilityNodeInfoReflector.setBooleanProperty(
-        TEXT_SELECTION_SETABLE_MASK, isTextSelectionSetable);
-  }
-
-  public void setPasteable(boolean isPasteable) {
-    accessibilityNodeInfoReflector.setBooleanProperty(PASTEABLE_MASK, isPasteable);
-  }
-
   @Implementation
   protected void setText(CharSequence t) {
-    text = t;
+    // Call the original method to set the underlying fields.
+    accessibilityNodeInfoReflector.setText(t);
+    if (!useRealAni()) {
+      text = t;
+    }
   }
 
   @Implementation
   protected CharSequence getText() {
+    if (useRealAni() || text == null) {
+      return accessibilityNodeInfoReflector.getText();
+    }
     return text;
   }
 
   @Implementation
   protected AccessibilityNodeInfo getLabelFor() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getLabelFor();
+    }
     if (labelFor == null) {
       return null;
     }
@@ -320,6 +307,8 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   public void setLabelFor(AccessibilityNodeInfo info) {
+    checkRealAniDisabled();
+
     if (labelFor != null) {
       labelFor.recycle();
     }
@@ -329,6 +318,9 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected AccessibilityNodeInfo getLabeledBy() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getLabeledBy();
+    }
     if (labeledBy == null) {
       return null;
     }
@@ -337,6 +329,7 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   public void setLabeledBy(AccessibilityNodeInfo info) {
+    checkRealAniDisabled();
     if (labeledBy != null) {
       labeledBy.recycle();
     }
@@ -346,6 +339,9 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation(minSdk = LOLLIPOP_MR1)
   protected AccessibilityNodeInfo getTraversalAfter() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getTraversalAfter();
+    }
     if (traversalAfter == null) {
       return null;
     }
@@ -355,6 +351,10 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation(minSdk = LOLLIPOP_MR1)
   protected void setTraversalAfter(View view, int virtualDescendantId) {
+    if (useRealAni()) {
+      accessibilityNodeInfoReflector.setTraversalAfter(view, virtualDescendantId);
+      return;
+    }
     if (this.traversalAfter != null) {
       this.traversalAfter.recycle();
     }
@@ -372,6 +372,7 @@ public class ShadowAccessibilityNodeInfo {
    * @see #getTraversalAfter()
    */
   public void setTraversalAfter(AccessibilityNodeInfo info) {
+    checkRealAniDisabled();
     if (this.traversalAfter != null) {
       this.traversalAfter.recycle();
     }
@@ -381,6 +382,9 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation(minSdk = LOLLIPOP_MR1)
   protected AccessibilityNodeInfo getTraversalBefore() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getTraversalBefore();
+    }
     if (traversalBefore == null) {
       return null;
     }
@@ -390,6 +394,10 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation(minSdk = LOLLIPOP_MR1)
   protected void setTraversalBefore(View info, int virtualDescendantId) {
+    if (useRealAni()) {
+      accessibilityNodeInfoReflector.setTraversalBefore(info, virtualDescendantId);
+      return;
+    }
     if (this.traversalBefore != null) {
       this.traversalBefore.recycle();
     }
@@ -407,6 +415,7 @@ public class ShadowAccessibilityNodeInfo {
    * @see #getTraversalBefore()
    */
   public void setTraversalBefore(AccessibilityNodeInfo info) {
+    checkRealAniDisabled();
     if (this.traversalBefore != null) {
       this.traversalBefore.recycle();
     }
@@ -416,36 +425,55 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected void setSource(View source) {
-    this.view = source;
+    accessibilityNodeInfoReflector.setSource(source);
+    if (!useRealAni()) {
+      this.view = source;
+    }
   }
 
   @Implementation
   protected void setSource(View root, int virtualDescendantId) {
-    this.view = root;
+    accessibilityNodeInfoReflector.setSource(root, virtualDescendantId);
+    if (!useRealAni()) {
+      this.view = root;
+    }
   }
 
   @Implementation
   protected AccessibilityWindowInfo getWindow() {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.getWindow();
+    }
     return accessibilityWindowInfo;
   }
 
   /** Returns the id of the window from which the info comes. */
   @Implementation
   protected int getWindowId() {
-    return (accessibilityWindowInfo == null) ? -1 : accessibilityWindowInfo.getId();
+    if (useRealAni() || accessibilityWindowInfo == null) {
+      return accessibilityNodeInfoReflector.getWindowId();
+    }
+    return accessibilityWindowInfo.getId();
   }
 
   public void setAccessibilityWindowInfo(AccessibilityWindowInfo info) {
+    checkRealAniDisabled();
     accessibilityWindowInfo = info;
   }
 
   @Implementation
   protected boolean performAction(int action) {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.performAction(action);
+    }
     return performAction(action, null);
   }
 
   @Implementation
   protected boolean performAction(int action, Bundle arguments) {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.performAction(action, arguments);
+    }
     if (performedActionAndArgsList == null) {
       performedActionAndArgsList = new ArrayList<>();
     }
@@ -458,9 +486,13 @@ public class ShadowAccessibilityNodeInfo {
    * Equality check based on reference equality of the Views from which these instances were
    * created, or the equality of their assigned IDs.
    */
+  @SuppressWarnings("EqualsHashCode")
   @Implementation
   @Override
   public boolean equals(Object object) {
+    if (useRealAni()) {
+      return accessibilityNodeInfoReflector.equals(object);
+    }
     if (!(object instanceof AccessibilityNodeInfo)) {
       return false;
     }
@@ -477,22 +509,13 @@ public class ShadowAccessibilityNodeInfo {
     throw new IllegalStateException("Node has neither an ID nor View");
   }
 
-  @Implementation
-  @Override
-  public int hashCode() {
-    // This is 0 for a reason. If you change it, you will break the obtained
-    // instances map in a manner that is remarkably difficult to debug.
-    // Having a dynamic hash code keeps this object from being located
-    // in the map if it was mutated after being obtained.
-    return 0;
-  }
-
   /**
    * Add a child node to this one. Also initializes the parent field of the child.
    *
    * @param child The node to be added as a child.
    */
   public void addChild(AccessibilityNodeInfo child) {
+    checkRealAniDisabled();
     if (children == null) {
       children = new ArrayList<>();
     }
@@ -504,20 +527,27 @@ public class ShadowAccessibilityNodeInfo {
 
   @Implementation
   protected void addChild(View child) {
-    AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(child);
-    addChild(node);
+    accessibilityNodeInfoReflector.addChild(child);
+    if (!useRealAni()) {
+      AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(child);
+      addChild(node);
+    }
   }
 
   @Implementation
   protected void addChild(View root, int virtualDescendantId) {
-    AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(root, virtualDescendantId);
-    addChild(node);
+    accessibilityNodeInfoReflector.addChild(root, virtualDescendantId);
+    if (!useRealAni()) {
+      AccessibilityNodeInfo node = AccessibilityNodeInfo.obtain(root, virtualDescendantId);
+      addChild(node);
+    }
   }
 
   /**
    * @return The list of arguments for the various calls to performAction. Unmodifiable.
    */
   public List<Integer> getPerformedActions() {
+    checkRealAniDisabled();
     if (performedActionAndArgsList == null) {
       performedActionAndArgsList = new ArrayList<>();
     }
@@ -536,6 +566,7 @@ public class ShadowAccessibilityNodeInfo {
    * @return The list of arguments for the various calls to performAction. Unmodifiable.
    */
   public List<Pair<Integer, Bundle>> getPerformedActionsWithArgs() {
+    checkRealAniDisabled();
     if (performedActionAndArgsList == null) {
       performedActionAndArgsList = new ArrayList<>();
     }
@@ -543,131 +574,16 @@ public class ShadowAccessibilityNodeInfo {
   }
 
   /**
-   * @return A shallow copy.
+   * After {@link AccessibilityNodeInfo#setQueryFromAppProcessEnabled(View, boolean)} is called, we
+   * will have direct access to the real {@link AccessibilityNodeInfo} hierarchy, so we want all
+   * future interactions with ANI to use the real object.
    */
-  private AccessibilityNodeInfo getClone() {
-    // We explicitly avoid allocating the AccessibilityNodeInfo from the actual pool by using
-    // the private constructor. Not doing so affects test suites which use both shadow and
-    // non-shadow objects.
-    final AccessibilityNodeInfo newInfo =
-        ReflectionHelpers.callConstructor(AccessibilityNodeInfo.class);
-    final ShadowAccessibilityNodeInfo newShadow = Shadow.extract(newInfo);
-
-    newShadow.mOriginNodeId = mOriginNodeId;
-    Rect boundsInScreen = new Rect();
-    realAccessibilityNodeInfo.getBoundsInScreen(boundsInScreen);
-    newInfo.setBoundsInScreen(boundsInScreen);
-    newShadow.accessibilityNodeInfoReflector.setBooleanProperties(
-        accessibilityNodeInfoReflector.getBooleanProperties());
-    newInfo.setContentDescription(realAccessibilityNodeInfo.getContentDescription());
-    newShadow.text = text;
-    newShadow.performedActionAndArgsList = performedActionAndArgsList;
-    newShadow.parent = parent;
-    newInfo.setClassName(realAccessibilityNodeInfo.getClassName());
-    newShadow.labelFor = (labelFor == null) ? null : obtain(labelFor);
-    newShadow.labeledBy = (labeledBy == null) ? null : obtain(labeledBy);
-    newShadow.view = view;
-    newShadow.actionListener = actionListener;
-    newShadow.accessibilityNodeInfoReflector.setActionsList(
-        new ArrayList<>(realAccessibilityNodeInfo.getActionList()));
-
-    if (children != null) {
-      newShadow.children = new ArrayList<>();
-      newShadow.children.addAll(children);
-    } else {
-      newShadow.children = null;
+  @Implementation(minSdk = U.SDK_INT)
+  protected void setQueryFromAppProcessEnabled(View view, boolean enabled) {
+    accessibilityNodeInfoReflector.setQueryFromAppProcessEnabled(view, enabled);
+    if (enabled) {
+      queryFromAppProcessWasEnabled = true;
     }
-
-    newShadow.refreshReturnValue = refreshReturnValue;
-    newInfo.setMovementGranularities(realAccessibilityNodeInfo.getMovementGranularities());
-    newInfo.setPackageName(realAccessibilityNodeInfo.getPackageName());
-    newInfo.setViewIdResourceName(realAccessibilityNodeInfo.getViewIdResourceName());
-    newInfo.setTextSelection(
-        realAccessibilityNodeInfo.getTextSelectionStart(),
-        realAccessibilityNodeInfo.getTextSelectionEnd());
-    newInfo.setCollectionInfo(realAccessibilityNodeInfo.getCollectionInfo());
-    newInfo.setCollectionItemInfo(realAccessibilityNodeInfo.getCollectionItemInfo());
-    newInfo.setInputType(realAccessibilityNodeInfo.getInputType());
-    newInfo.setLiveRegion(realAccessibilityNodeInfo.getLiveRegion());
-    newInfo.setRangeInfo(realAccessibilityNodeInfo.getRangeInfo());
-    newShadow.realAccessibilityNodeInfo.getExtras().putAll(realAccessibilityNodeInfo.getExtras());
-    newInfo.setMaxTextLength(realAccessibilityNodeInfo.getMaxTextLength());
-    newInfo.setError(realAccessibilityNodeInfo.getError());
-
-    if (getApiLevel() >= LOLLIPOP_MR1) {
-      newShadow.traversalAfter = (traversalAfter == null) ? null : obtain(traversalAfter);
-      newShadow.traversalBefore = (traversalBefore == null) ? null : obtain(traversalBefore);
-    }
-    if (accessibilityWindowInfo != null) {
-      newShadow.accessibilityWindowInfo =
-          ShadowAccessibilityWindowInfo.obtain(accessibilityWindowInfo);
-    }
-    if (getApiLevel() >= N) {
-      newInfo.setDrawingOrder(realAccessibilityNodeInfo.getDrawingOrder());
-    }
-    if (getApiLevel() >= O) {
-      newInfo.setHintText(realAccessibilityNodeInfo.getHintText());
-    }
-    if (getApiLevel() >= P) {
-      newInfo.setTooltipText(realAccessibilityNodeInfo.getTooltipText());
-      newInfo.setPaneTitle(realAccessibilityNodeInfo.getPaneTitle());
-    }
-    if (getApiLevel() >= R) {
-      newInfo.setStateDescription(realAccessibilityNodeInfo.getStateDescription());
-    }
-    if (getApiLevel() >= UPSIDE_DOWN_CAKE) {
-      newInfo.setContainerTitle(realAccessibilityNodeInfo.getContainerTitle());
-    }
-
-    return newInfo;
-  }
-
-  /**
-   * Private class to keep different nodes referring to the same view straight in the
-   * mObtainedInstances map.
-   */
-  private static class StrictEqualityNodeWrapper {
-    public final AccessibilityNodeInfo mInfo;
-
-    public StrictEqualityNodeWrapper(AccessibilityNodeInfo info) {
-      mInfo = info;
-    }
-
-    @Override
-    @SuppressWarnings("ReferenceEquality")
-    public boolean equals(Object object) {
-      if (object == null) {
-        return false;
-      }
-      if (!(object instanceof StrictEqualityNodeWrapper)) {
-        return false;
-      }
-      final StrictEqualityNodeWrapper wrapper = (StrictEqualityNodeWrapper) object;
-      return mInfo == wrapper.mInfo;
-    }
-
-    @Override
-    public int hashCode() {
-      return mInfo.hashCode();
-    }
-  }
-
-  @Implementation
-  protected int describeContents() {
-    return 0;
-  }
-
-  @Implementation
-  protected void writeToParcel(Parcel dest, int flags) {
-    StrictEqualityNodeWrapper wrapper = new StrictEqualityNodeWrapper(realAccessibilityNodeInfo);
-    int keyOfWrapper = -1;
-    for (int i = 0; i < orderedInstances.size(); i++) {
-      if (orderedInstances.valueAt(i).equals(wrapper)) {
-        keyOfWrapper = orderedInstances.keyAt(i);
-        break;
-      }
-    }
-    dest.writeInt(keyOfWrapper);
   }
 
   /**
@@ -676,6 +592,7 @@ public class ShadowAccessibilityNodeInfo {
    * @param listener The listener.
    */
   public void setOnPerformActionListener(OnPerformActionListener listener) {
+    checkRealAniDisabled();
     actionListener = listener;
   }
 
@@ -683,51 +600,121 @@ public class ShadowAccessibilityNodeInfo {
     boolean onPerformAccessibilityAction(int action, Bundle arguments);
   }
 
-  @Override
-  @Implementation
-  public String toString() {
-    return "ShadowAccessibilityNodeInfo@"
-        + System.identityHashCode(this)
-        + ":{text:"
-        + text
-        + ", className:"
-        + realAccessibilityNodeInfo.getClassName()
-        + "}";
-  }
-
   @ForType(AccessibilityNodeInfo.class)
   interface AccessibilityNodeInfoReflector {
+    @Direct
     @Static
-    @Accessor("CREATOR")
-    void setCreator(Parcelable.Creator<AccessibilityNodeInfo> creator);
+    AccessibilityNodeInfo obtain(AccessibilityNodeInfo info);
 
+    @Direct
     @Static
-    AccessibilityAction getActionSingleton(int id);
+    AccessibilityNodeInfo obtain(View view);
 
-    @Accessor("mBooleanProperties")
-    int getBooleanProperties();
+    @Direct
+    @Static
+    AccessibilityNodeInfo obtain();
+
+    @Direct
+    @Static
+    AccessibilityNodeInfo obtain(View root, int virtualDescendantId);
+
+    @Direct
+    void recycle();
+
+    @Direct
+    int getChildCount();
+
+    @Direct
+    AccessibilityNodeInfo getChild(int index);
+
+    @Direct
+    AccessibilityNodeInfo getParent();
+
+    @Direct
+    boolean refresh();
+
+    @Direct
+    void setText(CharSequence t);
+
+    @Direct
+    CharSequence getText();
+
+    @Direct
+    AccessibilityNodeInfo getLabelFor();
+
+    @Direct
+    AccessibilityNodeInfo getLabeledBy();
+
+    @Direct
+    AccessibilityNodeInfo getTraversalAfter();
+
+    @Direct
+    void setTraversalAfter(View view, int virtualDescendantId);
+
+    @Direct
+    AccessibilityNodeInfo getTraversalBefore();
+
+    @Direct
+    void setTraversalBefore(View info, int virtualDescendantId);
+
+    @Direct
+    void setSource(View source);
+
+    @Direct
+    void setSource(View root, int virtualDescendantId);
+
+    @Direct
+    AccessibilityWindowInfo getWindow();
+
+    @Direct
+    int getWindowId();
 
-    @Accessor("mBooleanProperties")
-    void setBooleanProperties(int properties);
+    @Direct
+    boolean performAction(int action);
 
-    void setBooleanProperty(int property, boolean value);
+    @Direct
+    boolean performAction(int action, Bundle arguments);
 
-    @Accessor("mActions")
-    void setActionsList(ArrayList<AccessibilityAction> actions);
+    @Override
+    @Direct
+    boolean equals(Object object);
 
-    @Accessor("mActions")
-    void setActionsMask(int actions); // pre-L
+    @Override
+    @Direct
+    int hashCode();
 
     @Direct
-    void getBoundsInScreen(Rect outBounds);
+    void addChild(View child);
 
     @Direct
-    void getBoundsInParent(Rect outBounds);
+    void addChild(View child, int id);
 
+    @Override
     @Direct
-    void setBoundsInScreen(Rect b);
+    String toString();
+
+    @Constructor
+    AccessibilityNodeInfo newInstance(AccessibilityNodeInfo other);
+
+    void init(AccessibilityNodeInfo other);
 
     @Direct
-    void setBoundsInParent(Rect b);
+    void setQueryFromAppProcessEnabled(View view, boolean enabled);
+  }
+
+  static boolean useRealAni() {
+    return queryFromAppProcessWasEnabled
+        || Boolean.parseBoolean(System.getProperty("robolectric.useRealAni", "false"));
+  }
+
+  static void checkRealAniDisabled() {
+    Preconditions.checkState(
+        !queryFromAppProcessWasEnabled,
+        "This API is not supported after a call to"
+            + " AccessibilityNodeInfo#setQueryFromAppProcessEnabled.");
+    boolean useRealAni =
+        Boolean.parseBoolean(System.getProperty("robolectric.useRealAni", "false"));
+    Preconditions.checkState(
+        !useRealAni, "This API is not supported when 'robolectric.useRealAni' is true");
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
index b3bb4fff6..16c4da75e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityRecord.java
@@ -23,7 +23,6 @@ public class ShadowAccessibilityRecord {
   private View sourceRoot;
   private int virtualDescendantId;
   private AccessibilityNodeInfo sourceNode;
-  private int windowId = -1;
 
   @Implementation
   protected void init(AccessibilityRecord model) {
@@ -32,7 +31,6 @@ public class ShadowAccessibilityRecord {
     sourceRoot = modelShadow.sourceRoot;
     virtualDescendantId = modelShadow.virtualDescendantId;
     sourceNode = modelShadow.sourceNode;
-    windowId = modelShadow.windowId;
 
     // Copy realRecord fields.
     reflector(AccessibilityRecordReflector.class, realRecord).init(model);
@@ -79,14 +77,9 @@ public class ShadowAccessibilityRecord {
    */
   @Implementation
   public void setWindowId(int id) {
-    windowId = id;
+    reflector(AccessibilityRecordReflector.class, realRecord).setWindowId(id);
   }
 
-  /** Returns the id of the window from which the event comes. */
-  @Implementation
-  protected int getWindowId() {
-    return windowId;
-  }
 
   public View getSourceRoot() {
     return sourceRoot;
@@ -107,5 +100,8 @@ public class ShadowAccessibilityRecord {
 
     @Direct
     void init(AccessibilityRecord model);
+
+    @Direct
+    void setWindowId(int id);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
index abf053771..0fc91fd07 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAccessibilityWindowInfo.java
@@ -3,22 +3,24 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
+import static org.robolectric.shadows.ShadowAccessibilityNodeInfo.checkRealAniDisabled;
+import static org.robolectric.shadows.ShadowAccessibilityNodeInfo.useRealAni;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Rect;
+import android.os.Build.VERSION_CODES;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityWindowInfo;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
-import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
 
 /**
  * Shadow of {@link android.view.accessibility.AccessibilityWindowInfo} that allows a test to set
@@ -26,10 +28,6 @@ import org.robolectric.util.reflector.ForType;
  */
 @Implements(value = AccessibilityWindowInfo.class)
 public class ShadowAccessibilityWindowInfo {
-
-  private static final Map<StrictEqualityWindowWrapper, StackTraceElement[]> obtainedInstances =
-      new HashMap<>();
-
   private List<AccessibilityWindowInfo> children = null;
 
   private AccessibilityWindowInfo parent = null;
@@ -38,153 +36,43 @@ public class ShadowAccessibilityWindowInfo {
 
   private AccessibilityNodeInfo anchorNode = null;
 
-  private Rect boundsInScreen = new Rect();
-
-  private int type = AccessibilityWindowInfo.TYPE_APPLICATION;
-
-  private int layer = 0;
-
-  private CharSequence title = null;
-
-  private boolean isAccessibilityFocused = false;
-
-  private boolean isActive = false;
+  private Rect boundsInScreenOverride;
 
-  private boolean isFocused = false;
-
-  private boolean isPictureInPicture = false;
-
-  @RealObject private AccessibilityWindowInfo mRealAccessibilityWindowInfo;
-
-  @Implementation
-  protected void __constructor__() {}
-
-  @Implementation
-  protected static AccessibilityWindowInfo obtain() {
-    final AccessibilityWindowInfo obtainedInstance =
-        ReflectionHelpers.callConstructor(AccessibilityWindowInfo.class);
-    StrictEqualityWindowWrapper wrapper = new StrictEqualityWindowWrapper(obtainedInstance);
-    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());
-    return obtainedInstance;
-  }
+  @RealObject private AccessibilityWindowInfo realAccessibilityWindowInfo;
 
   @Implementation
   protected static AccessibilityWindowInfo obtain(AccessibilityWindowInfo window) {
-    final ShadowAccessibilityWindowInfo shadowInfo = Shadow.extract(window);
-    final AccessibilityWindowInfo obtainedInstance = shadowInfo.getClone();
-    StrictEqualityWindowWrapper wrapper = new StrictEqualityWindowWrapper(obtainedInstance);
-    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());
-    return obtainedInstance;
-  }
+    final AccessibilityWindowInfo newInstance =
+        reflector(AccessibilityWindowInfoReflector.class).obtain(window);
 
-  private AccessibilityWindowInfo getClone() {
-    final AccessibilityWindowInfo newInfo =
-        ReflectionHelpers.callConstructor(AccessibilityWindowInfo.class);
-    final ShadowAccessibilityWindowInfo newShadow = Shadow.extract(newInfo);
-
-    newShadow.boundsInScreen = new Rect(boundsInScreen);
-    newShadow.parent = parent;
-    newShadow.rootNode = rootNode;
-    newShadow.anchorNode = anchorNode;
-    newShadow.type = type;
-    newShadow.layer = layer;
-    newShadow.setId(getId());
-    newShadow.title = title;
-    newShadow.isAccessibilityFocused = isAccessibilityFocused;
-    newShadow.isActive = isActive;
-    newShadow.isFocused = isFocused;
-    if (children != null) {
-      newShadow.children = new ArrayList<>(children);
-    } else {
-      newShadow.children = null;
+    if (useRealAni()) {
+      return newInstance;
     }
 
-    return newInfo;
-  }
-
-  /**
-   * Clear list of obtained instance objects. {@code areThereUnrecycledWindows} will always return
-   * false if called immediately afterwards.
-   */
-  public static void resetObtainedInstances() {
-    obtainedInstances.clear();
-  }
+    final ShadowAccessibilityWindowInfo shadowInfo = Shadow.extract(window);
+    final ShadowAccessibilityWindowInfo newShadow = Shadow.extract(newInstance);
 
-  /**
-   * Check for leaked objects that were {@code obtain}ed but never {@code recycle}d.
-   *
-   * @param printUnrecycledWindowsToSystemErr - if true, stack traces of calls to {@code obtain}
-   *     that lack matching calls to {@code recycle} are dumped to System.err.
-   * @return {@code true} if there are unrecycled windows
-   */
-  public static boolean areThereUnrecycledWindows(boolean printUnrecycledWindowsToSystemErr) {
-    if (printUnrecycledWindowsToSystemErr) {
-      for (final StrictEqualityWindowWrapper wrapper : obtainedInstances.keySet()) {
-        final ShadowAccessibilityWindowInfo shadow = Shadow.extract(wrapper.mInfo);
-
-        System.err.println(
-            String.format(
-                "Leaked type = %d, id = %d. Stack trace:",
-                shadow.getType(), wrapper.mInfo.getId()));
-        for (final StackTraceElement stackTraceElement : obtainedInstances.get(wrapper)) {
-          System.err.println(stackTraceElement.toString());
-        }
-      }
+    if (shadowInfo.boundsInScreenOverride != null) {
+      newShadow.boundsInScreenOverride = new Rect(shadowInfo.boundsInScreenOverride);
     }
+    newShadow.parent = shadowInfo.parent;
+    newShadow.rootNode = shadowInfo.rootNode;
+    newShadow.anchorNode = shadowInfo.anchorNode;
 
-    return (obtainedInstances.size() != 0);
-  }
-
-  @SuppressWarnings("ReferenceEquality")
-  public boolean deepEquals(Object object) {
-    if (!(object instanceof AccessibilityWindowInfo)) {
-      return false;
+    if (shadowInfo.children != null) {
+      newShadow.children = new ArrayList<>(shadowInfo.children);
+    } else {
+      newShadow.children = null;
     }
-
-    final AccessibilityWindowInfo window = (AccessibilityWindowInfo) object;
-    final ShadowAccessibilityWindowInfo otherShadow = Shadow.extract(window);
-
-    boolean areEqual = (type == otherShadow.getType());
-    areEqual &=
-        (parent == null)
-            ? (otherShadow.getParent() == null)
-            : parent.equals(otherShadow.getParent());
-    areEqual &=
-        (rootNode == null)
-            ? (otherShadow.getRoot() == null)
-            : rootNode.equals(otherShadow.getRoot());
-    areEqual &=
-        (anchorNode == null)
-            ? (otherShadow.getAnchor() == null)
-            : anchorNode.equals(otherShadow.getAnchor());
-    areEqual &= (layer == otherShadow.getLayer());
-    areEqual &= (getId() == otherShadow.getId());
-    areEqual &= (title == otherShadow.getTitle());
-    areEqual &= (isAccessibilityFocused == otherShadow.isAccessibilityFocused());
-    areEqual &= (isActive == otherShadow.isActive());
-    areEqual &= (isFocused == otherShadow.isFocused());
-    Rect anotherBounds = new Rect();
-    otherShadow.getBoundsInScreen(anotherBounds);
-    areEqual &= (boundsInScreen.equals(anotherBounds));
-    return areEqual;
-  }
-
-  @Override
-  @Implementation
-  public int hashCode() {
-    // This is 0 for a reason. If you change it, you will break the obtained instances map in
-    // a manner that is remarkably difficult to debug. Having a dynamic hash code keeps this
-    // object from being located in the map if it was mutated after being obtained.
-    return 0;
-  }
-
-  @Implementation
-  protected int getType() {
-    return type;
+    return newInstance;
   }
 
   @Implementation
   protected int getChildCount() {
+    if (useRealAni()) {
+      return reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getChildCount();
+    }
     if (children == null) {
       return 0;
     }
@@ -194,6 +82,10 @@ public class ShadowAccessibilityWindowInfo {
 
   @Implementation
   protected AccessibilityWindowInfo getChild(int index) {
+    if (useRealAni()) {
+      return reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getChild(index);
+    }
     if (children == null) {
       return null;
     }
@@ -203,105 +95,96 @@ public class ShadowAccessibilityWindowInfo {
 
   @Implementation
   protected AccessibilityWindowInfo getParent() {
+    if (useRealAni()) {
+      return reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getParent();
+    }
     return parent;
   }
 
   @Implementation
   protected AccessibilityNodeInfo getRoot() {
+    if (useRealAni()) {
+      return reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getRoot();
+    }
     return (rootNode == null) ? null : AccessibilityNodeInfo.obtain(rootNode);
   }
 
   @Implementation(minSdk = N)
   protected AccessibilityNodeInfo getAnchor() {
+    if (useRealAni()) {
+      return reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getAnchor();
+    }
     return (anchorNode == null) ? null : AccessibilityNodeInfo.obtain(anchorNode);
   }
 
-  @Implementation
-  protected boolean isActive() {
-    return isActive;
-  }
-
-  @Implementation
-  protected int getId() {
-    return reflector(AccessibilityWindowInfoReflector.class, mRealAccessibilityWindowInfo).getId();
-  }
-
   @Implementation
   protected void getBoundsInScreen(Rect outBounds) {
-    if (boundsInScreen == null) {
-      outBounds.setEmpty();
+    if (useRealAni() || boundsInScreenOverride == null) {
+      reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .getBoundsInScreen(outBounds);
     } else {
-      outBounds.set(boundsInScreen);
+      outBounds.set(boundsInScreenOverride);
     }
   }
 
-  @Implementation
-  protected int getLayer() {
-    return layer;
-  }
-
-  /** Returns the title of this window, or {@code null} if none is available. */
-  @Implementation(minSdk = N)
-  protected CharSequence getTitle() {
-    return title;
-  }
-
-  @Implementation
-  protected boolean isFocused() {
-    return isFocused;
-  }
-
-  @Implementation
-  protected boolean isAccessibilityFocused() {
-    return isAccessibilityFocused;
-  }
-
-  @Implementation(minSdk = O)
-  protected boolean isInPictureInPictureMode() {
-    return isPictureInPicture;
-  }
-
   @Implementation
   protected void recycle() {
-    // This shadow does not track recycling of windows.
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).recycle();
+    // Clear shadow fields.
+    children = null;
+    parent = null;
+    rootNode = null;
+    anchorNode = null;
+    boundsInScreenOverride = null;
   }
 
   public void setRoot(AccessibilityNodeInfo root) {
+    checkRealAniDisabled();
     rootNode = root;
   }
 
   public void setAnchor(AccessibilityNodeInfo anchor) {
+    checkRealAniDisabled();
     anchorNode = anchor;
   }
 
   @Implementation
   public void setType(int value) {
-    type = value;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).setType(value);
   }
 
   @Implementation(maxSdk = Q)
   public void setBoundsInScreen(Rect bounds) {
-    boundsInScreen.set(bounds);
+    if (RuntimeEnvironment.getApiLevel() <= Q) {
+      reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+          .setBoundsInScreen(bounds);
+    } else {
+      boundsInScreenOverride = bounds;
+    }
   }
 
   @Implementation
   public void setAccessibilityFocused(boolean value) {
-    isAccessibilityFocused = value;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+        .setAccessibilityFocused(value);
   }
 
   @Implementation
   public void setActive(boolean value) {
-    isActive = value;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).setActive(value);
   }
 
   @Implementation
   public void setId(int value) {
-    reflector(AccessibilityWindowInfoReflector.class, mRealAccessibilityWindowInfo).setId(value);
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).setId(value);
   }
 
   @Implementation
   public void setLayer(int value) {
-    layer = value;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).setLayer(value);
   }
 
   /**
@@ -311,78 +194,93 @@ public class ShadowAccessibilityWindowInfo {
    */
   @Implementation(minSdk = N)
   public void setTitle(CharSequence value) {
-    title = value;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo).setTitle(value);
   }
 
   @Implementation
   public void setFocused(boolean focused) {
-    isFocused = focused;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+        .setFocused(focused);
   }
 
   @Implementation(minSdk = O)
   public void setPictureInPicture(boolean pictureInPicture) {
-    isPictureInPicture = pictureInPicture;
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+        .setPictureInPicture(pictureInPicture);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.R)
+  public void setDisplayId(int displayId) {
+    reflector(AccessibilityWindowInfoReflector.class, realAccessibilityWindowInfo)
+        .setDisplayId(displayId);
   }
 
   public void addChild(AccessibilityWindowInfo child) {
+    checkRealAniDisabled();
     if (children == null) {
       children = new ArrayList<>();
     }
 
     children.add(child);
-    ((ShadowAccessibilityWindowInfo) Shadow.extract(child)).parent = mRealAccessibilityWindowInfo;
+    ((ShadowAccessibilityWindowInfo) Shadow.extract(child)).parent = realAccessibilityWindowInfo;
   }
 
-  /**
-   * Private class to keep different windows referring to the same window straight in the
-   * mObtainedInstances map.
-   */
-  private static class StrictEqualityWindowWrapper {
-    public final AccessibilityWindowInfo mInfo;
+  @ForType(AccessibilityWindowInfo.class)
+  interface AccessibilityWindowInfoReflector {
 
-    public StrictEqualityWindowWrapper(AccessibilityWindowInfo info) {
-      mInfo = info;
-    }
+    @Direct
+    void setId(int value);
 
-    @Override
-    @SuppressWarnings("ReferenceEquality")
-    public boolean equals(Object object) {
-      if (object == null) {
-        return false;
-      }
-
-      if (!(object instanceof StrictEqualityWindowWrapper)) {
-        return false;
-      }
-      final StrictEqualityWindowWrapper wrapper = (StrictEqualityWindowWrapper) object;
-      return mInfo == wrapper.mInfo;
-    }
+    @Direct
+    void setType(int value);
 
-    @Override
-    public int hashCode() {
-      return mInfo.hashCode();
-    }
-  }
+    @Direct
+    void setAccessibilityFocused(boolean value);
 
-  @Override
-  @Implementation
-  public String toString() {
-    return "ShadowAccessibilityWindowInfo@"
-        + System.identityHashCode(this)
-        + ":{id:"
-        + getId()
-        + ", title:"
-        + title
-        + "}";
-  }
+    @Direct
+    void setActive(boolean value);
 
-  @ForType(AccessibilityWindowInfo.class)
-  interface AccessibilityWindowInfoReflector {
+    @Direct
+    void setLayer(int value);
 
     @Direct
-    int getId();
+    void setTitle(CharSequence value);
 
     @Direct
-    void setId(int value);
+    void setFocused(boolean focused);
+
+    @Direct
+    void setPictureInPicture(boolean pictureInPicture);
+
+    @Direct
+    void setDisplayId(int displayId);
+
+    @Direct
+    void setBoundsInScreen(Rect bounds);
+
+    @Direct
+    void getBoundsInScreen(Rect outBounds);
+
+    @Direct
+    int getChildCount();
+
+    @Direct
+    AccessibilityWindowInfo getChild(int index);
+
+    @Direct
+    AccessibilityWindowInfo getParent();
+
+    @Direct
+    AccessibilityNodeInfo getRoot();
+
+    @Direct
+    AccessibilityNodeInfo getAnchor();
+
+    @Direct
+    void recycle();
+
+    @Direct
+    @Static
+    AccessibilityWindowInfo obtain(AccessibilityWindowInfo window);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
index 3cc6186db..317985e6e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivity.java
@@ -61,6 +61,7 @@ import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -79,7 +80,7 @@ import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @SuppressWarnings("NewApi")
-@Implements(value = Activity.class, looseSignatures = true)
+@Implements(value = Activity.class)
 public class ShadowActivity extends ShadowContextThemeWrapper {
 
   @RealObject protected Activity realActivity;
@@ -113,6 +114,7 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
   private Object splashScreen = null;
   private boolean showWhenLocked = false;
   private boolean turnScreenOn = false;
+  private boolean isTaskMovedToBack = false;
 
   public void setApplication(Application application) {
     reflector(_Activity_.class, realActivity).setApplication(application);
@@ -423,7 +425,7 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
    * @return fake SplashScreen
    */
   @Implementation(minSdk = S)
-  protected synchronized Object getSplashScreen() {
+  protected synchronized @ClassName("android.window.SplashScreen") Object getSplashScreen() {
     if (splashScreen == null) {
       splashScreen = new RoboSplashScreen();
     }
@@ -918,10 +920,26 @@ public class ShadowActivity extends ShadowContextThemeWrapper {
 
   @Implementation
   protected boolean moveTaskToBack(boolean nonRoot) {
+    // If task has already moved to back, return true.
+    if (isTaskMovedToBack) {
+      return true;
+    }
+    // If nonRoot is false then #moveTaskToBack only works when activity is the root of the task.
+    if (!nonRoot && !mIsTaskRoot) {
+      return false;
+    }
+    isTaskMovedToBack = true;
     isInPictureInPictureMode = false;
     return true;
   }
 
+  /**
+   * @return whether the task containing this activity is moved to the back of the activity stack.
+   */
+  public boolean isTaskMovedToBack() {
+    return isTaskMovedToBack;
+  }
+
   /**
    * Gets the last startIntentSenderForResult request made to this activity.
    *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
index 1e4788579..92f4b6ed1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityManager.java
@@ -33,6 +33,7 @@ import java.util.Deque;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -45,24 +46,26 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link android.app.ActivityManager} */
-@Implements(value = ActivityManager.class, looseSignatures = true)
+@Implements(value = ActivityManager.class)
 public class ShadowActivityManager {
   private int memoryClass = 16;
-  private String backgroundPackage;
-  private ActivityManager.MemoryInfo memoryInfo;
-  private final List<ActivityManager.AppTask> appTasks = new CopyOnWriteArrayList<>();
-  private final List<ActivityManager.RecentTaskInfo> recentTasks = new CopyOnWriteArrayList<>();
-  private final List<ActivityManager.RunningTaskInfo> tasks = new CopyOnWriteArrayList<>();
-  private final List<ActivityManager.RunningServiceInfo> services = new CopyOnWriteArrayList<>();
+  private static String backgroundPackage;
+  private static ActivityManager.MemoryInfo memoryInfo;
+  private static final List<ActivityManager.AppTask> appTasks = new CopyOnWriteArrayList<>();
+  private static final List<ActivityManager.RecentTaskInfo> recentTasks =
+      new CopyOnWriteArrayList<>();
+  private static final List<ActivityManager.RunningTaskInfo> tasks = new CopyOnWriteArrayList<>();
+  private static final List<ActivityManager.RunningServiceInfo> services =
+      new CopyOnWriteArrayList<>();
   private static final List<ActivityManager.RunningAppProcessInfo> processes =
       new CopyOnWriteArrayList<>();
-  private final List<ImportanceListener> importanceListeners = new CopyOnWriteArrayList<>();
-  private final SparseIntArray uidImportances = new SparseIntArray();
+  private static final List<ImportanceListener> importanceListeners = new CopyOnWriteArrayList<>();
+  private static final SparseIntArray uidImportances = new SparseIntArray();
   @RealObject private ActivityManager realObject;
-  private Boolean isLowRamDeviceOverride = null;
+  private static Boolean isLowRamDeviceOverride = null;
   private int lockTaskModeState = ActivityManager.LOCK_TASK_MODE_NONE;
   private boolean isBackgroundRestricted;
-  private final Deque<Object> appExitInfoList = new ArrayDeque<>();
+  private static final Deque<Object> appExitInfoList = new ArrayDeque<>();
   private ConfigurationInfo configurationInfo;
   private Context context;
 
@@ -296,12 +299,15 @@ public class ShadowActivityManager {
   }
 
   @Implementation(minSdk = O)
-  protected void addOnUidImportanceListener(Object listener, Object importanceCutpoint) {
+  protected void addOnUidImportanceListener(
+      @ClassName("android.app.ActivityManager$OnUidImportanceListener") Object listener,
+      int importanceCutpoint) {
     importanceListeners.add(new ImportanceListener(listener, (Integer) importanceCutpoint));
   }
 
   @Implementation(minSdk = O)
-  protected void removeOnUidImportanceListener(Object listener) {
+  protected void removeOnUidImportanceListener(
+      @ClassName("android.app.ActivityManager$OnUidImportanceListener") Object listener) {
     importanceListeners.remove(new ImportanceListener(listener));
   }
 
@@ -347,7 +353,17 @@ public class ShadowActivityManager {
 
   @Resetter
   public static void reset() {
+    backgroundPackage = null;
+    memoryInfo = null;
+    appTasks.clear();
+    recentTasks.clear();
+    tasks.clear();
+    services.clear();
     processes.clear();
+    importanceListeners.clear();
+    uidImportances.clear();
+    appExitInfoList.clear();
+    isLowRamDeviceOverride = null;
   }
 
   /** Returns the background restriction state set by {@link #setBackgroundRestricted}. */
@@ -369,7 +385,8 @@ public class ShadowActivityManager {
    * {@code packageName} is ignored.
    */
   @Implementation(minSdk = R)
-  protected Object getHistoricalProcessExitReasons(Object packageName, Object pid, Object maxNum) {
+  protected List</*android.app.ApplicationExitInfo*/ ?> getHistoricalProcessExitReasons(
+      String packageName, int pid, int maxNum) {
     return appExitInfoList.stream()
         .filter(
             appExitInfo ->
@@ -535,7 +552,7 @@ public class ShadowActivityManager {
   }
 
   /**
-   * Helper class mimicing the package-private UidObserver class inside {@link ActivityManager}.
+   * Helper class mimicking the package-private UidObserver class inside {@link ActivityManager}.
    *
    * <p>This class is responsible for maintaining the cutpoint of the corresponding {@link
    * ActivityManager.OnUidImportanceListener} and invoking the listener only when the importance of
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
index 8b55be124..7e08ba9de 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowActivityThread.java
@@ -31,6 +31,7 @@ import java.util.List;
 import java.util.Map;
 import javax.annotation.Nonnull;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -42,14 +43,15 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Reflector;
 
-@Implements(value = ActivityThread.class, isInAndroidSdk = false, looseSignatures = true)
+/** Shadow for {@link ActivityThread}. */
+@Implements(value = ActivityThread.class, isInAndroidSdk = false)
 public class ShadowActivityThread {
   private static ApplicationInfo applicationInfo;
   @RealObject protected ActivityThread realActivityThread;
   @ReflectorObject protected _ActivityThread_ activityThreadReflector;
 
   @Implementation
-  public static Object getPackageManager() {
+  public static @ClassName("android.content.pm.IPackageManager") Object getPackageManager() {
     ClassLoader classLoader = ShadowActivityThread.class.getClassLoader();
     Class<?> iPackageManagerClass;
     try {
@@ -111,7 +113,7 @@ public class ShadowActivityThread {
   }
 
   @Implementation
-  public static Object currentActivityThread() {
+  public static @ClassName("android.app.ActivityThread") Object currentActivityThread() {
     return RuntimeEnvironment.getActivityThread();
   }
 
@@ -133,7 +135,7 @@ public class ShadowActivityThread {
   }
 
   @Implementation(minSdk = R)
-  public static Object getPermissionManager() {
+  public static @ClassName("android.permission.IPermissionManager") Object getPermissionManager() {
     ClassLoader classLoader = ShadowActivityThread.class.getClassLoader();
     Class<?> iPermissionManagerClass;
     try {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
index aac2e77f8..25642f71c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAmbientContextManager.java
@@ -11,6 +11,7 @@ import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow of {@link AmbientContextManager} */
 @Implements(
@@ -19,7 +20,7 @@ import org.robolectric.annotation.Implements;
     isInAndroidSdk = false)
 public class ShadowAmbientContextManager {
 
-  private final Object lock = new Object();
+  private static final Object lock = new Object();
 
   /**
    * Caches the last {@link AmbientContextEventRequest} passed into {@link
@@ -31,7 +32,7 @@ public class ShadowAmbientContextManager {
    */
   @GuardedBy("lock")
   @Nullable
-  private AmbientContextEventRequest lastRegisterObserverRequest;
+  private static AmbientContextEventRequest lastRegisterObserverRequest;
 
   /**
    * The ambient context service status code that will be consumed by the {@code consumer} which is
@@ -39,12 +40,12 @@ public class ShadowAmbientContextManager {
    * #registerObserver(AmbientContextEventRequest, PendingIntent, Executor, Consumer)}.
    */
   @GuardedBy("lock")
-  private Integer ambientContextServiceStatus = AmbientContextManager.STATUS_NOT_SUPPORTED;
+  private static Integer ambientContextServiceStatus = AmbientContextManager.STATUS_NOT_SUPPORTED;
 
   /** Caches the last requested event codes passed into {@link #startConsentActivity(Set)}. */
   @GuardedBy("lock")
   @Nullable
-  private Set<Integer> lastRequestedEventCodesForConsentActivity;
+  private static Set<Integer> lastRequestedEventCodesForConsentActivity;
 
   @Implementation
   protected void registerObserver(
@@ -119,4 +120,13 @@ public class ShadowAmbientContextManager {
       return lastRequestedEventCodesForConsentActivity;
     }
   }
+
+  @Resetter
+  public static void reset() {
+    synchronized (lock) {
+      lastRegisterObserverRequest = null;
+      ambientContextServiceStatus = AmbientContextManager.STATUS_NOT_SUPPORTED;
+      lastRequestedEventCodesForConsentActivity = null;
+    }
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationUtils.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationUtils.java
deleted file mode 100644
index 10e293758..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAnimationUtils.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.robolectric.shadows;
-
-import android.content.Context;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.view.animation.Interpolator;
-import android.view.animation.LayoutAnimationController;
-import android.view.animation.LinearInterpolator;
-import android.view.animation.TranslateAnimation;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
-@SuppressWarnings({"UnusedDeclaration"})
-@Implements(AnimationUtils.class)
-public class ShadowAnimationUtils {
-
-  @Implementation
-  protected static Interpolator loadInterpolator(Context context, int id) {
-    return new LinearInterpolator();
-  }
-
-  @Implementation
-  protected static LayoutAnimationController loadLayoutAnimation(Context context, int id) {
-    Animation anim = new TranslateAnimation(0, 0, 30, 0);
-    LayoutAnimationController layoutAnim = new LayoutAnimationController(anim);
-    return layoutAnim;
-  }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
index a02a6728b..52d85f279 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppOpsManager.java
@@ -51,6 +51,7 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.stream.IntStream;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -63,7 +64,7 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link AppOpsManager}. */
-@Implements(value = AppOpsManager.class, looseSignatures = true)
+@Implements(value = AppOpsManager.class)
 public class ShadowAppOpsManager {
 
   // OpEntry fields that the shadow doesn't currently allow the test to configure.
@@ -75,20 +76,20 @@ public class ShadowAppOpsManager {
 
   @RealObject private AppOpsManager realObject;
 
-  private static boolean staticallyInitialized = false;
+  private static boolean staticallyInitialized;
 
   // Recorded operations, keyed by (uid, packageName)
-  private final Multimap<Key, Integer> storedOps = HashMultimap.create();
+  private static final Multimap<Key, Integer> storedOps = HashMultimap.create();
   // (uid, packageName, opCode) => opMode
-  private final Map<Key, Integer> appModeMap = new HashMap<>();
+  private static final Map<Key, Integer> appModeMap = new HashMap<>();
 
   // (uid, packageName, opCode)
-  private final Set<Key> longRunningOp = new HashSet<>();
+  private static final Set<Key> longRunningOp = new HashSet<>();
 
-  private final Map<OnOpChangedListener, Set<Key>> appOpListeners = new ArrayMap<>();
+  private static final Map<OnOpChangedListener, Set<Key>> appOpListeners = new ArrayMap<>();
 
-  // op | (usage << 8) => ModeAndExcpetion
-  private final Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();
+  // op | (usage << 8) => ModeAndException
+  private static final Map<Integer, ModeAndException> audioRestrictions = new HashMap<>();
 
   private Context context;
 
@@ -466,18 +467,18 @@ public class ShadowAppOpsManager {
   @RequiresApi(api = S)
   @Implementation(minSdk = S)
   protected int noteProxyOpNoThrow(
-      Object op, Object attributionSource, Object message, Object ignoredSkipProxyOperation) {
-    Preconditions.checkArgument(op instanceof Integer);
+      int op,
+      @ClassName("android.content.AttributionSource") Object attributionSource,
+      String message,
+      boolean skipProxyOperation) {
     Preconditions.checkArgument(attributionSource instanceof AttributionSource);
-    Preconditions.checkArgument(message == null || message instanceof String);
-    Preconditions.checkArgument(ignoredSkipProxyOperation instanceof Boolean);
     AttributionSource castedAttributionSource = (AttributionSource) attributionSource;
     return noteProxyOpNoThrow(
-        (int) op,
+        op,
         castedAttributionSource.getNextPackageName(),
         castedAttributionSource.getNextUid(),
         castedAttributionSource.getNextAttributionTag(),
-        (String) message);
+        message);
   }
 
   @Implementation
@@ -671,7 +672,7 @@ public class ShadowAppOpsManager {
     }
   }
 
-  /** Class holding usage mode and excpetion packages. */
+  /** Class holding usage mode and exception packages. */
   public static class ModeAndException {
     public final int mode;
     public final List<String> exceptionPackages;
@@ -694,6 +695,11 @@ public class ShadowAppOpsManager {
     if (RuntimeEnvironment.getApiLevel() >= R && staticallyInitialized) {
       ReflectionHelpers.setStaticField(AppOpsManager.class, "sOnOpNotedCallback", null);
     }
+    storedOps.clear();
+    appModeMap.clear();
+    longRunningOp.clear();
+    appOpListeners.clear();
+    audioRestrictions.clear();
   }
 
   @ForType(className = "android.app.AppOpInfo")
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
index 439906678..150775e3d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAppWidgetManager.java
@@ -32,6 +32,7 @@ import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.ForType;
 
@@ -41,20 +42,29 @@ public class ShadowAppWidgetManager {
 
   @RealObject private AppWidgetManager realAppWidgetManager;
 
-  private Context context;
-  private final Map<Integer, WidgetInfo> widgetInfos = new HashMap<>();
-  private int nextWidgetId = 1;
-  private boolean alwaysRecreateViewsDuringUpdate = false;
-  private boolean allowedToBindWidgets;
-  private boolean requestPinAppWidgetSupported = false;
-  private boolean validWidgetProviderComponentName = true;
+  // AppWidgetProvider is enabled if at least one widget is active. `isWidgetsEnabled` should be set
+  //  to false if the last widget is removed (when removing widgets is implemented).
+  private static boolean isWidgetsEnabled = false;
+  private static int nextWidgetId = 1;
+  private static boolean alwaysRecreateViewsDuringUpdate = false;
+  private static boolean allowedToBindWidgets;
+  private static boolean requestPinAppWidgetSupported = false;
+  private static boolean validWidgetProviderComponentName = true;
   private final ArrayList<AppWidgetProviderInfo> installedProviders = new ArrayList<>();
   private Multimap<UserHandle, AppWidgetProviderInfo> installedProvidersForProfile =
       HashMultimap.create();
+  private Context context;
+  private final Map<Integer, WidgetInfo> widgetInfos = new HashMap<>();
 
-  // AppWidgetProvider is enabled if at least one widget is active. `isWidgetsEnabled` should be set
-  //  to false if the last widget is removed (when removing widgets is implemented).
-  private boolean isWidgetsEnabled = false;
+  @Resetter
+  public static void reset() {
+    nextWidgetId = 1;
+    alwaysRecreateViewsDuringUpdate = false;
+    allowedToBindWidgets = false;
+    requestPinAppWidgetSupported = false;
+    validWidgetProviderComponentName = true;
+    isWidgetsEnabled = false;
+  }
 
   @Implementation
   protected void __constructor__(Context context, IAppWidgetService service) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
index 950193699..35efdf2b4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplication.java
@@ -34,7 +34,6 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowActivityThread._ActivityThread_;
 import org.robolectric.shadows.ShadowActivityThread._AppBindData_;
-import org.robolectric.shadows.ShadowUserManager.UserManagerState;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Scheduler;
 import org.robolectric.util.reflector.Reflector;
@@ -47,7 +46,6 @@ public class ShadowApplication extends ShadowContextWrapper {
   private ShadowPopupMenu latestPopupMenu;
   private PopupWindow latestPopupWindow;
   private ListPopupWindow latestListPopupWindow;
-  private UserManagerState userManagerState;
 
   /**
    * @deprecated Use {@code shadowOf({@link ApplicationProvider#getApplicationContext()})} instead.
@@ -326,14 +324,6 @@ public class ShadowApplication extends ShadowContextWrapper {
     this.latestListPopupWindow = latestListPopupWindow;
   }
 
-  UserManagerState getUserManagerState() {
-    if (userManagerState == null) {
-      userManagerState = new UserManagerState();
-    }
-
-    return userManagerState;
-  }
-
   public static final class Wrapper {
     public BroadcastReceiver broadcastReceiver;
     public IntentFilter intentFilter;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
index be2a9ef27..b7c66b458 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowApplicationPackageManager.java
@@ -116,6 +116,7 @@ import java.util.concurrent.Executor;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.GetInstallerPackageNameMode;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
@@ -126,7 +127,8 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
-@Implements(value = ApplicationPackageManager.class, isInAndroidSdk = false, looseSignatures = true)
+/** Shadow for {@link ApplicationPackageManager}. */
+@Implements(value = ApplicationPackageManager.class, isInAndroidSdk = false)
 public class ShadowApplicationPackageManager extends ShadowPackageManager {
   /** Package name of the Android platform. */
   private static final String PLATFORM_PACKAGE_NAME = "android";
@@ -151,7 +153,8 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected List<PackageInfo> getInstalledPackages(Object flags) {
+  protected List<PackageInfo> getInstalledPackages(
+      @ClassName("android.content.pm.PackageManager$PackageInfoFlags") Object flags) {
     return getInstalledPackages(((PackageInfoFlags) flags).getValue());
   }
 
@@ -193,7 +196,8 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = Q)
-  protected Object getModuleInfo(String packageName, int flags) throws NameNotFoundException {
+  protected @ClassName("android.content.pm.ModuleInfo") Object getModuleInfo(
+      String packageName, int flags) throws NameNotFoundException {
     synchronized (lock) {
       // Double checks that the respective package matches and is not disabled
       getPackageInfo(packageName, flags);
@@ -476,9 +480,11 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected PackageInfo getPackageInfo(Object packageName, Object flags)
+  protected PackageInfo getPackageInfo(
+      String packageName,
+      @ClassName("android.content.pm.PackageManager$PackageInfoFlags") Object flags)
       throws NameNotFoundException {
-    return getPackageInfo((String) packageName, ((PackageInfoFlags) flags).getValue());
+    return getPackageInfo(packageName, ((PackageInfoFlags) flags).getValue());
   }
 
   private PackageInfo getPackageInfo(String packageName, long flags) throws NameNotFoundException {
@@ -582,6 +588,13 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
         ServiceInfo::new);
   }
 
+  @Implementation(minSdk = TIRAMISU)
+  protected List<ResolveInfo> queryIntentServices(
+      Intent intent,
+      @ClassName("android.content.pm.PackageManager$ResolveInfoFlags") Object flagsObject) {
+    return queryIntentServices(intent, (int) ((ResolveInfoFlags) flagsObject).getValue());
+  }
+
   private boolean hasSomeComponentInfo(ResolveInfo resolveInfo) {
 
     return resolveInfo.activityInfo != null
@@ -793,8 +806,10 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   /** Behaves as {@link #queryIntentActivities(Intent, int)} and currently ignores userId. */
   @Implementation(minSdk = TIRAMISU)
   protected List<ResolveInfo> queryIntentActivitiesAsUser(
-      /*Intent*/ Object intent, /*ResolveInfoFlags*/ Object flags, /*int*/ Object userId) {
-    return queryIntentActivities((Intent) intent, (int) ((ResolveInfoFlags) flags).getValue());
+      Intent intent,
+      @ClassName("android.content.pm.PackageManager$ResolveInfoFlags") Object flags,
+      int userId) {
+    return queryIntentActivities(intent, (int) ((ResolveInfoFlags) flags).getValue());
   }
 
   /** Returns true if intent has specified a specific component. */
@@ -909,10 +924,10 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation(minSdk = TIRAMISU)
   protected ActivityInfo getReceiverInfo(
-      /*ComponentName*/ Object component, /*ComponentInfoFlags*/ Object flags)
+      ComponentName component,
+      @ClassName("android.content.pm.PackageManager$ComponentInfoFlags") Object flags)
       throws NameNotFoundException {
-    return getReceiverInfo(
-        (ComponentName) component, (int) ((ComponentInfoFlags) flags).getValue());
+    return getReceiverInfo(component, (int) ((ComponentInfoFlags) flags).getValue());
   }
 
   @Implementation
@@ -929,8 +944,9 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation(minSdk = TIRAMISU)
   protected List<ResolveInfo> queryBroadcastReceivers(
-      /*Intent*/ Object intent, /*ResolveInfoFlags*/ Object flags) {
-    return queryBroadcastReceivers((Intent) intent, (int) ((ResolveInfoFlags) flags).getValue());
+      Intent intent,
+      @ClassName("android.content.pm.PackageManager$ResolveInfoFlags") Object flags) {
+    return queryBroadcastReceivers(intent, (int) ((ResolveInfoFlags) flags).getValue());
   }
 
   private static int matchIntentFilter(Intent intent, IntentFilter intentFilter) {
@@ -962,9 +978,10 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation(minSdk = TIRAMISU)
   protected ServiceInfo getServiceInfo(
-      /*ComponentName*/ Object component, /*ComponentInfoFlags*/ Object flags)
+      ComponentName component,
+      @ClassName("android.content.pm.PackageManager$ComponentInfoFlags") Object flags)
       throws NameNotFoundException {
-    return getServiceInfo((ComponentName) component, (int) ((ComponentInfoFlags) flags).getValue());
+    return getServiceInfo(component, (int) ((ComponentInfoFlags) flags).getValue());
   }
 
   /**
@@ -1052,7 +1069,8 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected List<ApplicationInfo> getInstalledApplications(Object flags) {
+  protected List<ApplicationInfo> getInstalledApplications(
+      @ClassName("android.content.pm.PackageManager$ApplicationInfoFlags") Object flags) {
     return getInstalledApplications(((PackageManager.ApplicationInfoFlags) flags).getValue());
   }
 
@@ -1091,7 +1109,8 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = R)
-  protected Object getInstallSourceInfo(String packageName) throws NameNotFoundException {
+  protected @ClassName("android.content.pm.InstallSourceInfo") Object getInstallSourceInfo(
+      String packageName) throws NameNotFoundException {
     if (!packageInstallSourceInfoMap.containsKey(packageName)) {
       throw new NameNotFoundException("Package is not installed: " + packageName);
     } else {
@@ -1200,7 +1219,10 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(maxSdk = M)
-  protected void getPackageSizeInfo(Object pkgName, Object uid, final Object observer) {
+  protected void getPackageSizeInfo(
+      String pkgName,
+      int uid,
+      final @ClassName("android.content.pm.IPackageStatsObserver") Object observer) {
     final PackageStats packageStats = packageStatsMap.get((String) pkgName);
     new Handler(Looper.getMainLooper())
         .post(
@@ -1215,8 +1237,11 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = N)
-  protected void getPackageSizeInfoAsUser(Object pkgName, Object uid, final Object observer) {
-    final PackageStats packageStats = packageStatsMap.get((String) pkgName);
+  protected void getPackageSizeInfoAsUser(
+      String pkgName,
+      int uid,
+      final @ClassName("android.content.pm.IPackageStatsObserver") Object observer) {
+    final PackageStats packageStats = packageStatsMap.get(pkgName);
     new Handler(Looper.getMainLooper())
         .post(
             () -> {
@@ -1384,19 +1409,20 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
     return getLaunchIntentForPackage(packageName, Intent.CATEGORY_LEANBACK_LAUNCHER);
   }
 
-  /**
-   * In Android T, the type of {@code flags} changed from {@code int} to {@link PackageInfoFlags}
-   */
   @Implementation(minSdk = N)
-  protected Object getPackageInfoAsUser(Object packageName, Object flagsObject, Object userId)
+  protected @ClassName("android.content.pm.PackageInfo") Object getPackageInfoAsUser(
+      String packageName, int flags, int userId) throws NameNotFoundException {
+    return getPackageInfo(packageName, flags);
+  }
+
+  /** In Android T, an overloaded one which has parameter type of {@link PackageInfoFlags}. */
+  @Implementation(minSdk = TIRAMISU)
+  protected @ClassName("android.content.pm.PackageInfo") Object getPackageInfoAsUser(
+      String packageName,
+      @ClassName("android.content.pm.PackageManager$PackageInfoFlags") Object flagsObject,
+      int userId)
       throws NameNotFoundException {
-    int flags;
-    if (RuntimeEnvironment.getApiLevel() >= TIRAMISU) {
-      flags = (int) ((PackageInfoFlags) flagsObject).getValue();
-    } else {
-      flags = (int) flagsObject;
-    }
-    return getPackageInfo((String) packageName, flags);
+    return getPackageInfo(packageName, ((PackageInfoFlags) flagsObject).getValue());
   }
 
   @Implementation
@@ -1419,8 +1445,11 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected Object getPackageUid(Object packageName, Object flags) throws NameNotFoundException {
-    return getPackageUid((String) packageName, (int) ((PackageInfoFlags) flags).getValue());
+  protected int getPackageUid(
+      String packageName,
+      @ClassName("android.content.pm.PackageManager$PackageInfoFlags") Object flags)
+      throws NameNotFoundException {
+    return getPackageUid(packageName, (int) ((PackageInfoFlags) flags).getValue());
   }
 
   @Implementation(minSdk = N)
@@ -1498,11 +1527,13 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected ApplicationInfo getApplicationInfo(Object packageName, Object flagsObject)
+  protected ApplicationInfo getApplicationInfo(
+      String packageName,
+      @ClassName("android.content.pm.PackageManager$ApplicationInfoFlags") Object flagsObject)
       throws NameNotFoundException {
     Preconditions.checkArgument(flagsObject instanceof PackageManager.ApplicationInfoFlags);
     PackageManager.ApplicationInfoFlags flags = (PackageManager.ApplicationInfoFlags) flagsObject;
-    return getApplicationInfo((String) packageName, (int) (flags).getValue());
+    return getApplicationInfo(packageName, (int) flags.getValue());
   }
 
   private void applyFlagsToApplicationInfo(@Nullable ApplicationInfo appInfo, long flags)
@@ -1807,13 +1838,19 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected ResolveInfo resolveActivityAsUser(Object intent, Object flags, Object userId) {
-    return resolveActivity((Intent) intent, (int) ((ResolveInfoFlags) flags).getValue());
+  protected ResolveInfo resolveActivityAsUser(
+      Intent intent,
+      @ClassName("android.content.pm.PackageManager$ResolveInfoFlags") Object flags,
+      int userId) {
+    return resolveActivity(intent, (int) ((ResolveInfoFlags) flags).getValue());
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected ResolveInfo resolveServiceAsUser(Object intent, Object flags, Object userId) {
-    return resolveService((Intent) intent, (int) ((ResolveInfoFlags) flags).getValue());
+  protected ResolveInfo resolveServiceAsUser(
+      Intent intent,
+      @ClassName("android.content.pm.PackageManager$ResolveInfoFlags") Object flags,
+      int userId) {
+    return resolveService(intent, (int) ((ResolveInfoFlags) flags).getValue());
   }
 
   @Implementation
@@ -1919,18 +1956,25 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = M)
-  protected void addOnPermissionsChangeListener(Object listener) {
+  protected void addOnPermissionsChangeListener(
+      @ClassName("android.content.pm.PackageManager$OnPermissionsChangedListener")
+          Object listener) {
     permissionListeners.add(listener);
   }
 
   @Implementation(minSdk = M)
-  protected void removeOnPermissionsChangeListener(Object listener) {
+  protected void removeOnPermissionsChangeListener(
+      @ClassName("android.content.pm.PackageManager$OnPermissionsChangedListener")
+          Object listener) {
     permissionListeners.remove(listener);
   }
 
   @Implementation(maxSdk = O_MR1)
   protected void installPackage(
-      Object packageURI, Object observer, Object flags, Object installerPackageName) {}
+      Uri packageURI,
+      @ClassName("android.content.pm.IPackageInstallObserver") Object observer,
+      int flags,
+      String installerPackageName) {}
 
   @Implementation
   protected int installExistingPackage(String packageName) throws NameNotFoundException {
@@ -1984,18 +2028,23 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = M)
-  protected void registerMoveCallback(Object callback, Object handler) {}
+  protected void registerMoveCallback(
+      @ClassName("android.content.pm.PackageManager$MoveCallback") Object callback,
+      Handler handler) {}
 
   @Implementation(minSdk = M)
-  protected void unregisterMoveCallback(Object callback) {}
+  protected void unregisterMoveCallback(
+      @ClassName("android.content.pm.PackageManager$MoveCallback") Object callback) {}
 
   @Implementation(minSdk = M)
-  protected Object movePackage(Object packageName, Object vol) {
+  protected int movePackage(
+      String packageName, @ClassName("android.os.storage.VolumeInfo") Object vol) {
     return 0;
   }
 
   @Implementation(minSdk = M)
-  protected Object getPackageCurrentVolume(Object app) {
+  protected @ClassName("android.os.storage.VolumeInfo") Object getPackageCurrentVolume(
+      @ClassName("android.content.pm.ApplicationInfo") Object app) {
     return null;
   }
 
@@ -2005,12 +2054,13 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = M)
-  protected Object movePrimaryStorage(Object vol) {
+  protected int movePrimaryStorage(@ClassName("android.os.storage.VolumeInfo") Object vol) {
     return 0;
   }
 
   @Implementation(minSdk = M)
-  protected @Nullable Object getPrimaryStorageCurrentVolume() {
+  protected @Nullable @ClassName("android.os.storage.VolumeInfo") Object
+      getPrimaryStorageCurrentVolume() {
     return null;
   }
 
@@ -2176,7 +2226,8 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
   }
 
   @Implementation(minSdk = O)
-  protected Object getChangedPackages(int sequenceNumber) {
+  protected @ClassName("android.content.pm.ChangedPackages") Object getChangedPackages(
+      int sequenceNumber) {
     if (sequenceNumber < 0 || sequenceNumberChangedPackagesMap.get(sequenceNumber).isEmpty()) {
       return null;
     }
@@ -2203,19 +2254,14 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   @Implementation(minSdk = Q)
   @HiddenApi
-  protected /* String[] */ Object setPackagesSuspended(
-      /* String[] */ Object packageNames,
-      /* boolean */ Object suspended,
-      /* PersistableBundle */ Object appExtras,
-      /* PersistableBundle */ Object launcherExtras,
-      /* SuspendDialogInfo */ Object dialogInfo) {
+  protected String[] setPackagesSuspended(
+      String[] packageNames,
+      boolean suspended,
+      PersistableBundle appExtras,
+      PersistableBundle launcherExtras,
+      @ClassName("android.content.pm.SuspendDialogInfo") Object dialogInfo) {
     return setPackagesSuspended(
-        (String[]) packageNames,
-        (boolean) suspended,
-        (PersistableBundle) appExtras,
-        (PersistableBundle) launcherExtras,
-        /* dialogMessage= */ null,
-        dialogInfo);
+        packageNames, suspended, appExtras, launcherExtras, /* dialogMessage= */ null, dialogInfo);
   }
 
   @Implementation(minSdk = R)
@@ -2408,7 +2454,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   /** Stub that will always throw. */
   @Implementation(minSdk = S)
-  protected Object /* PackageManager.Property */ getProperty(
+  protected @ClassName("android.content.pm.PackageManager$Property") Object getProperty(
       String propertyName, String packageName) throws NameNotFoundException {
     // TODO: in future read this value from parsed manifest
     throw new NameNotFoundException("unsupported");
@@ -2416,7 +2462,7 @@ public class ShadowApplicationPackageManager extends ShadowPackageManager {
 
   /** Stub that will always throw. */
   @Implementation(minSdk = S)
-  protected Object /* PackageManager.Property */ getProperty(
+  protected @ClassName("android.content.pm.PackageManager$Property") Object getProperty(
       String propertyName, ComponentName name) throws NameNotFoundException {
     // TODO: in future read this value from parsed manifest
     throw new NameNotFoundException("unsupported");
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
index 31c6b26fe..07f0eabc0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscApkAssets9.java
@@ -14,6 +14,7 @@ import java.io.FileDescriptor;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -23,6 +24,7 @@ import org.robolectric.res.android.CppApkAssets;
 import org.robolectric.res.android.Registries;
 import org.robolectric.res.android.ResXMLTree;
 import org.robolectric.shadows.ShadowApkAssets.Picker;
+import org.robolectric.util.PerfStatsCollector;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
@@ -37,8 +39,7 @@ import org.robolectric.util.reflector.Static;
     value = ApkAssets.class,
     minSdk = P,
     shadowPicker = Picker.class,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+    isInAndroidSdk = false)
 public class ShadowArscApkAssets9 extends ShadowApkAssets {
   // #define ATRACE_TAG ATRACE_TAG_RESOURCES
   //
@@ -122,39 +123,48 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
       return cachedApkAssetsPtr;
     }
 
-    ATRACE_NAME(String.format("LoadApkAssets(%s)", path));
-
-    CppApkAssets apk_assets;
-    try {
-      if (overlay) {
-        apk_assets = CppApkAssets.LoadOverlay(path, system);
-      } else if (forceSharedLib) {
-        apk_assets = CppApkAssets.LoadAsSharedLibrary(path, system);
-      } else {
-        apk_assets = CppApkAssets.Load(path, system);
-      }
-    } catch (OutOfMemoryError e) {
-      OutOfMemoryError outOfMemoryError = new OutOfMemoryError("Failed to load " + path);
-      outOfMemoryError.initCause(e);
-      throw outOfMemoryError;
-    }
-
-    if (apk_assets == null) {
-      String error_msg = String.format("Failed to load asset path %s", path);
-      throw new IOException(error_msg);
-    }
-    long ptr = Registries.NATIVE_APK_ASSETS_REGISTRY.register(apk_assets);
-    ApkAssetsCache.put(path, system, RuntimeEnvironment.getApiLevel(), ptr);
-    return ptr;
+    return PerfStatsCollector.getInstance()
+        .measure(
+            "load binary " + (system ? "framework" : "app") + " resources",
+            () -> {
+              ATRACE_NAME(String.format("LoadApkAssets(%s)", path));
+
+              CppApkAssets apk_assets;
+              try {
+                if (overlay) {
+                  apk_assets = CppApkAssets.LoadOverlay(path, system);
+                } else if (forceSharedLib) {
+                  apk_assets = CppApkAssets.LoadAsSharedLibrary(path, system);
+                } else {
+                  apk_assets = CppApkAssets.Load(path, system);
+                }
+              } catch (OutOfMemoryError e) {
+                OutOfMemoryError outOfMemoryError = new OutOfMemoryError("Failed to load " + path);
+                outOfMemoryError.initCause(e);
+                throw outOfMemoryError;
+              }
+
+              if (apk_assets == null) {
+                String error_msg = String.format("Failed to load asset path %s", path);
+                throw new IOException(error_msg);
+              }
+              long ptr = Registries.NATIVE_APK_ASSETS_REGISTRY.register(apk_assets);
+              ApkAssetsCache.put(path, system, RuntimeEnvironment.getApiLevel(), ptr);
+              return ptr;
+            });
   }
 
   @Implementation(minSdk = R)
-  protected static Object nativeLoad(
-      Object format, Object javaPath, Object flags, Object assetsProvider) throws IOException {
-    boolean system = ((int) flags & PROPERTY_SYSTEM) == PROPERTY_SYSTEM;
-    boolean overlay = ((int) flags & PROPERTY_OVERLAY) == PROPERTY_OVERLAY;
-    boolean forceSharedLib = ((int) flags & PROPERTY_DYNAMIC) == PROPERTY_DYNAMIC;
-    return nativeLoad((String) javaPath, system, forceSharedLib, overlay);
+  protected static long nativeLoad(
+      int format,
+      String javaPath,
+      int flags,
+      @ClassName("android.content.res.loader.AssetsProvider") Object assetsProvider)
+      throws IOException {
+    boolean system = (flags & PROPERTY_SYSTEM) == PROPERTY_SYSTEM;
+    boolean overlay = (flags & PROPERTY_OVERLAY) == PROPERTY_OVERLAY;
+    boolean forceSharedLib = (flags & PROPERTY_DYNAMIC) == PROPERTY_DYNAMIC;
+    return nativeLoad(javaPath, system, forceSharedLib, overlay);
   }
 
   // static jlong NativeLoadFromFd(JNIEnv* env, jclass /*clazz*/, jobject file_descriptor,
@@ -202,12 +212,12 @@ public class ShadowArscApkAssets9 extends ShadowApkAssets {
   //                             jobject file_descriptor, jstring friendly_name,
   //                             const jint property_flags, jobject assets_provider)
   @Implementation(minSdk = R)
-  protected static Object nativeLoadFd(
-      Object format,
-      Object fileDescriptor,
-      Object friendlyName,
-      Object propertyFlags,
-      Object assetsProvider)
+  protected static long nativeLoadFd(
+      int format,
+      FileDescriptor fileDescriptor,
+      String friendlyName,
+      int propertyFlags,
+      @ClassName("android.content.res.loader.AssetsProvider") Object assetsProvider)
       throws IOException {
     CppApkAssets apkAssets = CppApkAssets.loadArscFromFd((FileDescriptor) fileDescriptor);
     if (apkAssets == null) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
index b5f74bc57..efb9df55f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetInputStream.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.res.AssetManager.AssetInputStream;
-import java.io.InputStream;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.res.android.Asset;
@@ -17,11 +16,6 @@ public class ShadowArscAssetInputStream extends ShadowAssetInputStream {
 
   @RealObject private AssetInputStream realObject;
 
-  @Override
-  InputStream getDelegate() {
-    return realObject;
-  }
-
   private Asset getAsset() {
     long assetPtr = reflector(_AssetInputStream_.class, realObject).getNativeAsset();
     return Registries.NATIVE_ASSET_REGISTRY.getNativeObject(assetPtr);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
index a3e2432b9..104874187 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowArscAssetManager10.java
@@ -864,26 +864,36 @@ public class ShadowArscAssetManager10 extends ShadowAssetManager.ArscBase {
       short density,
       @NonNull TypedValue typed_value,
       boolean resolve_references) {
-    CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
-    final Ref<Res_value> value = new Ref<>(null);
-    final Ref<ResTable_config> selected_config = new Ref<>(null);
-    final Ref<Integer> flags = new Ref<>(0);
-    ApkAssetsCookie cookie =
-        assetmanager.GetResource(
-            resid, false /*may_be_bag*/, (short) (density), value, selected_config, flags);
-    if (cookie.intValue() == kInvalidCookie) {
-      return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
-    }
-
-    final Ref<Integer> ref = new Ref<>(resid);
-    if (resolve_references) {
-      cookie = assetmanager.ResolveReference(cookie, value, selected_config, flags, ref);
-      if (cookie.intValue() == kInvalidCookie) {
-        return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
-      }
-    }
-    return CopyValue(
-        cookie, value.get(), ref.get(), flags.get(), selected_config.get(), typed_value);
+    return PerfStatsCollector.getInstance()
+        .measure(
+            "binary nativeGetResourceValue",
+            () -> {
+              CppAssetManager2 assetmanager = AssetManagerFromLong(ptr);
+              final Ref<Res_value> value = new Ref<>(null);
+              final Ref<ResTable_config> selected_config = new Ref<>(null);
+              final Ref<Integer> flags = new Ref<>(0);
+              ApkAssetsCookie cookie =
+                  assetmanager.GetResource(
+                      resid,
+                      false /*may_be_bag*/,
+                      (short) (density),
+                      value,
+                      selected_config,
+                      flags);
+              if (cookie.intValue() == kInvalidCookie) {
+                return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
+              }
+
+              final Ref<Integer> ref = new Ref<>(resid);
+              if (resolve_references) {
+                cookie = assetmanager.ResolveReference(cookie, value, selected_config, flags, ref);
+                if (cookie.intValue() == kInvalidCookie) {
+                  return ApkAssetsCookieToJavaCookie(K_INVALID_COOKIE);
+                }
+              }
+              return CopyValue(
+                  cookie, value.get(), ref.get(), flags.get(), selected_config.get(), typed_value);
+            });
   }
 
   // static jint NativeGetResourceBagValue(JNIEnv* env, jclass /*clazz*/, jlong ptr, jint resid,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
index 95d7fe9ee..5e0f186c4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetInputStream.java
@@ -1,40 +1,25 @@
 package org.robolectric.shadows;
 
-import static org.robolectric.res.android.Registries.NATIVE_ASSET_REGISTRY;
-import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 
-import android.content.res.AssetManager;
-import android.content.res.AssetManager.AssetInputStream;
-import java.io.InputStream;
-import org.robolectric.res.android.Asset;
-import org.robolectric.shadow.api.Shadow;
-import org.robolectric.util.ReflectionHelpers;
 
 @SuppressWarnings("UnusedDeclaration")
 public abstract class ShadowAssetInputStream {
 
-  static AssetInputStream createAssetInputStream(
-      InputStream delegateInputStream, long assetPtr, AssetManager assetManager) {
-    Asset asset = NATIVE_ASSET_REGISTRY.getNativeObject(assetPtr);
-
-    AssetInputStream ais =
-        ReflectionHelpers.callConstructor(
-            AssetInputStream.class,
-            from(AssetManager.class, assetManager),
-            from(long.class, assetPtr));
-
-    ShadowAssetInputStream sais = Shadow.extract(ais);
-    return ais;
-  }
-
   public static class Picker extends ResourceModeShadowPicker<ShadowAssetInputStream> {
 
     public Picker() {
-      super(ShadowArscAssetInputStream.class, ShadowArscAssetInputStream.class);
+      super(
+          ShadowArscAssetInputStream.class,
+          ShadowArscAssetInputStream.class,
+          ShadowArscAssetInputStream.class,
+          ShadowArscAssetInputStream.class,
+          ShadowNativeAssetInputStream.class);
     }
   }
 
-  abstract InputStream getDelegate();
-
+  /**
+   * @deprecated should only be used in LEGACY graphics mode
+   */
+  @Deprecated
   abstract boolean isNinePatch();
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
index 63df48ee7..9769e334a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAssetManager.java
@@ -79,7 +79,7 @@ public abstract class ShadowAssetManager {
         for (AssetPath assetPath : getAssetPaths()) {
           if (assetPath.isSystem) {
             compileTimeCppAssetManager.addDefaultAssets(
-                RuntimeEnvironment.compileTimeSystemResourcesFile);
+                RuntimeEnvironment.getCompileTimeSystemResourcesPath());
           } else {
             compileTimeCppAssetManager.addAssetPath(new String8(assetPath.file), null, false);
           }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
index be14286ca..a0eb64b31 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioManager.java
@@ -39,7 +39,10 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Executor;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -50,7 +53,7 @@ import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
 
 @SuppressWarnings({"UnusedDeclaration"})
-@Implements(value = AudioManager.class, looseSignatures = true)
+@Implements(value = AudioManager.class)
 public class ShadowAudioManager {
   @RealObject AudioManager realAudioManager;
 
@@ -63,6 +66,7 @@ public class ShadowAudioManager {
   public static final ImmutableList<Integer> ALL_STREAMS =
       ImmutableList.of(
           AudioManager.STREAM_MUSIC,
+          AudioManager.STREAM_ASSISTANT,
           AudioManager.STREAM_ALARM,
           AudioManager.STREAM_NOTIFICATION,
           AudioManager.STREAM_RING,
@@ -100,6 +104,8 @@ public class ShadowAudioManager {
   private final Map<String, String> parameters = new HashMap<>();
   private final Map<Integer, Boolean> streamsMuteState = new HashMap<>();
   private final Map<String, AudioPolicy> registeredAudioPolicies = new HashMap<>();
+  private final Map<AudioManager.OnCommunicationDeviceChangedListener, Executor>
+      registeredCommunicationDeviceChangedListeners = new HashMap<>();
   private int audioSessionIdCounter = 1;
   private final Map<AudioAttributes, ImmutableList<Object>> devicesForAttributes = new HashMap<>();
   private final List<AudioDeviceInfo> outputDevicesWithDirectProfiles = new ArrayList<>();
@@ -359,12 +365,12 @@ public class ShadowAudioManager {
         continue;
       }
 
-      String[] splittedPair = pair.split("=", 0);
-      if (splittedPair.length != 2) {
+      String[] splitPair = pair.split("=", 0);
+      if (splitPair.length != 2) {
         throw new IllegalArgumentException(
             "keyValuePairs: each pair should be in the format of key=value;");
       }
-      parameters.put(splittedPair[0], splittedPair[1]);
+      parameters.put(splitPair[0], splitPair[1]);
     }
   }
 
@@ -469,7 +475,8 @@ public class ShadowAudioManager {
    */
   @Implementation(minSdk = R)
   @NonNull
-  protected List<Object> getDevicesForAttributes(@NonNull AudioAttributes attributes) {
+  protected List</*android.media.AudioDeviceAttributes*/ ?> getDevicesForAttributes(
+      @NonNull AudioAttributes attributes) {
     ImmutableList<Object> devices = devicesForAttributes.get(attributes);
     return devices == null ? defaultDevicesForAttributes : devices;
   }
@@ -506,6 +513,51 @@ public class ShadowAudioManager {
     audioDevicesForAttributes.put(attributes, devices);
   }
 
+  /**
+   * Registers a {@link AudioManager.OnCommunicationDeviceChangedListener} that can later be called
+   * with {@link #callOnCommunicationDeviceChangedListeners}. The provided executor will be used
+   * when calling {@link
+   * AudioManager.OnCommunicationDeviceChangedListener#onCommunicationDeviceChanged}
+   */
+  @Implementation(minSdk = S)
+  protected void addOnCommunicationDeviceChangedListener(
+      Executor executor, AudioManager.OnCommunicationDeviceChangedListener listener) {
+    Objects.requireNonNull(executor);
+    Objects.requireNonNull(listener);
+    if (registeredCommunicationDeviceChangedListeners.containsKey(listener)) {
+      throw new IllegalArgumentException(
+          "attempt to call addOnCommunicationDeviceChangedListener on a previously registered"
+              + " listener");
+    }
+    registeredCommunicationDeviceChangedListeners.put(listener, executor);
+  }
+
+  /**
+   * Unregisters a previously registered {@link AudioManager.OnCommunicationDeviceChangedListener}.
+   */
+  @Implementation(minSdk = S)
+  protected void removeOnCommunicationDeviceChangedListener(
+      AudioManager.OnCommunicationDeviceChangedListener listener) {
+    Objects.requireNonNull(listener);
+    if (!registeredCommunicationDeviceChangedListeners.containsKey(listener)) {
+      throw new IllegalArgumentException(
+          "attempt to call removeOnCommunicationDeviceChangedListener on an unregistered listener");
+    }
+    registeredCommunicationDeviceChangedListeners.remove(listener);
+  }
+
+  /**
+   * Calls the {@link
+   * AudioManager.OnCommunicationDeviceChangedListener#onCommunicationDeviceChanged} method on all
+   * registered {@link AudioManager.OnCommunicationDeviceChangedListener}, using their registered
+   * executors, with the provided {@link AudioDeviceInfo} as argument.
+   */
+  public void callOnCommunicationDeviceChangedListeners(AudioDeviceInfo device) {
+    registeredCommunicationDeviceChangedListeners.forEach(
+        (listener, executor) ->
+            executor.execute(() -> listener.onCommunicationDeviceChanged(device)));
+  }
+
   /**
    * Sets the list of connected input devices represented by {@link AudioDeviceInfo}.
    *
@@ -920,7 +972,8 @@ public class ShadowAudioManager {
   @HiddenApi
   @Implementation(minSdk = P)
   @RequiresPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING)
-  protected int registerAudioPolicy(@NonNull Object audioPolicy) {
+  protected int registerAudioPolicy(
+      @NonNull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
     Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     String id = getIdForAudioPolicy(audioPolicy);
@@ -934,7 +987,8 @@ public class ShadowAudioManager {
 
   @HiddenApi
   @Implementation(minSdk = Q)
-  protected void unregisterAudioPolicy(@NonNull Object audioPolicy) {
+  protected void unregisterAudioPolicy(
+      @NonNull @ClassName("android.media.audiopolicy.AudioPolicy") Object audioPolicy) {
     Preconditions.checkNotNull(audioPolicy, "Illegal null AudioPolicy argument");
     AudioPolicy policy = (AudioPolicy) audioPolicy;
     registeredAudioPolicies.remove(getIdForAudioPolicy(policy));
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
index d4fb436e0..84b91d4ea 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAudioTrack.java
@@ -1,9 +1,6 @@
 package org.robolectric.shadows;
 
-import static android.media.AudioTrack.ERROR_BAD_VALUE;
 import static android.media.AudioTrack.ERROR_DEAD_OBJECT;
-import static android.media.AudioTrack.WRITE_BLOCKING;
-import static android.media.AudioTrack.WRITE_NON_BLOCKING;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.P;
@@ -13,6 +10,7 @@ import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.robolectric.shadow.api.Shadow.directlyOn;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -27,7 +25,6 @@ import android.media.PlaybackParams;
 import android.os.Build.VERSION;
 import android.os.Handler;
 import android.os.Parcel;
-import android.util.Log;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
@@ -50,7 +47,7 @@ import org.robolectric.versioning.AndroidVersions.U;
  * other methods are expected run through the real class. The two {@link WriteMode} are treated the
  * same.
  */
-@Implements(value = AudioTrack.class, looseSignatures = true)
+@Implements(value = AudioTrack.class)
 public class ShadowAudioTrack {
 
   /**
@@ -95,6 +92,9 @@ public class ShadowAudioTrack {
       new CopyOnWriteArrayList<>();
   private static int minBufferSize = DEFAULT_MIN_BUFFER_SIZE;
 
+  @SuppressWarnings("NonFinalStaticField")
+  private static boolean illegalStateOnPlayEnabled = false;
+
   private int numBytesReceived;
   private PlaybackParams playbackParams;
   @RealObject AudioTrack audioTrack;
@@ -309,6 +309,38 @@ public class ShadowAudioTrack {
   @Implementation(minSdk = M)
   protected int native_write_byte(
       byte[] audioData, int offsetInBytes, int sizeInBytes, int format, boolean isBlocking) {
+    byte[] dataToWrite = new byte[sizeInBytes];
+    System.arraycopy(audioData, offsetInBytes, dataToWrite, /* destPos= */ 0, sizeInBytes);
+    return maybeWriteBytes(dataToWrite);
+  }
+
+  /**
+   * @see #native_write_byte(byte[], int, int, int, boolean)
+   */
+  @Implementation(minSdk = M, maxSdk = P)
+  protected int native_write_native_bytes(
+      Object audioData, int positionInBytes, int sizeInBytes, int format, boolean blocking) {
+    return maybeWriteBytes(((ByteBuffer) audioData), sizeInBytes);
+  }
+
+  /**
+   * @see #native_write_byte(byte[], int, int, int, boolean)
+   */
+  @Implementation(minSdk = Q)
+  protected int native_write_native_bytes(
+      ByteBuffer audioData, int positionInBytes, int sizeInBytes, int format, boolean blocking) {
+    return maybeWriteBytes(audioData, sizeInBytes);
+  }
+
+  private int maybeWriteBytes(ByteBuffer audioData, int sizeInBytes) {
+    int previousPosition = audioData.position();
+    byte[] dataToWrite = new byte[sizeInBytes];
+    audioData.get(dataToWrite);
+    audioData.position(previousPosition); // Restore the original position
+    return maybeWriteBytes(dataToWrite);
+  }
+
+  private int maybeWriteBytes(byte[] audioData) {
     int encoding = audioTrack.getAudioFormat();
     // Assume that offload support does not change during the lifetime of the instance.
     if ((VERSION.SDK_INT < 29 || !audioTrack.isOffloadedPlayback())
@@ -316,7 +348,13 @@ public class ShadowAudioTrack {
         && !allowedNonPcmEncodings.contains(encoding)) {
       return ERROR_DEAD_OBJECT;
     }
-    return sizeInBytes;
+
+    numBytesReceived += audioData.length;
+    for (OnAudioDataWrittenListener listener : audioDataWrittenListeners) {
+      listener.onAudioDataWritten(this, audioData, audioTrack.getFormat());
+    }
+
+    return audioData.length;
   }
 
   @Implementation(minSdk = N)
@@ -352,45 +390,18 @@ public class ShadowAudioTrack {
     return playbackParams;
   }
 
-  /**
-   * Returns the number of bytes to write, except with invalid parameters. If the {@link AudioTrack}
-   * was created for a non-PCM encoding that can no longer be played directly, it returns {@link
-   * AudioTrack#ERROR_DEAD_OBJECT}. Assumes {@link AudioTrack} is already initialized (object
-   * properly created). Do not block even if {@link AudioTrack} in offload mode is in STOPPING play
-   * state. This method returns immediately even with {@link AudioTrack#WRITE_BLOCKING}
-   */
   @Implementation
-  protected int write(@NonNull ByteBuffer audioData, int sizeInBytes, @WriteMode int writeMode) {
-    int encoding = audioTrack.getAudioFormat();
-    // Assume that offload support does not change during the lifetime of the instance.
-    if ((VERSION.SDK_INT < 29 || !audioTrack.isOffloadedPlayback())
-        && !isPcm(encoding)
-        && !allowedNonPcmEncodings.contains(encoding)) {
-      return ERROR_DEAD_OBJECT;
-    }
-    if (writeMode != WRITE_BLOCKING && writeMode != WRITE_NON_BLOCKING) {
-      Log.e(TAG, "ShadowAudioTrack.write() called with invalid blocking mode");
-      return ERROR_BAD_VALUE;
-    }
-    if (sizeInBytes < 0 || sizeInBytes > audioData.remaining()) {
-      Log.e(TAG, "ShadowAudioTrack.write() called with invalid size (" + sizeInBytes + ") value");
-      return ERROR_BAD_VALUE;
-    }
-
-    byte[] receivedBytes = new byte[sizeInBytes];
-    audioData.get(receivedBytes);
-    numBytesReceived += sizeInBytes;
-
-    for (OnAudioDataWrittenListener listener : audioDataWrittenListeners) {
-      listener.onAudioDataWritten(this, receivedBytes, audioTrack.getFormat());
-    }
-
-    return sizeInBytes;
+  protected int getPlaybackHeadPosition() {
+    return numBytesReceived / audioTrack.getFormat().getFrameSizeInBytes();
   }
 
   @Implementation
-  protected int getPlaybackHeadPosition() {
-    return numBytesReceived / audioTrack.getFormat().getFrameSizeInBytes();
+  protected void play() {
+    if (illegalStateOnPlayEnabled) {
+      throw new IllegalStateException("illegalStateOnPlayEnabled == true");
+    }
+    //noinspection ResultOfMethodCallIgnored
+    directlyOn(audioTrack, AudioTrack.class, "play");
   }
 
   @Implementation
@@ -416,12 +427,18 @@ public class ShadowAudioTrack {
     ShadowAudioTrack.audioDataWrittenListeners.remove(listener);
   }
 
+  /** Simulates an {@link AudioTrack} {@link IllegalStateException} while playing. */
+  public static void enableIllegalStateOnPlay(boolean enabled) {
+    illegalStateOnPlayEnabled = enabled;
+  }
+
   @Resetter
   public static void resetTest() {
     audioDataWrittenListeners.clear();
     clearDirectPlaybackSupportedFormats();
     clearAllowedNonPcmEncodings();
     routedDevice = null;
+    illegalStateOnPlayEnabled = false;
   }
 
   private static boolean isPcm(int encoding) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
index 93e85e85f..5178a33fe 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowAutofillManager.java
@@ -9,13 +9,21 @@ import android.service.autofill.FillEventHistory;
 import android.view.autofill.AutofillManager;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Robolectric implementation of {@link android.os.AutofillManager}. */
 @Implements(value = AutofillManager.class, minSdk = O)
 public class ShadowAutofillManager {
-  @Nullable private ComponentName autofillServiceComponentName = null;
-  private boolean autofillSupported = false;
-  private boolean enabled = false;
+  @Nullable private static ComponentName autofillServiceComponentName = null;
+  private static boolean autofillSupported = false;
+  private static boolean enabled = false;
+
+  @Resetter
+  public static void reset() {
+    autofillServiceComponentName = null;
+    autofillSupported = false;
+    enabled = false;
+  }
 
   @Implementation
   protected FillEventHistory getFillEventHistory() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataInput.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataInput.java
index 01a574ee1..a87682d73 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataInput.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBackupDataInput.java
@@ -8,13 +8,14 @@ import com.google.common.collect.ImmutableList;
 import java.io.FileDescriptor;
 import java.util.ArrayList;
 import java.util.List;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for BackupDataInput. */
-@Implements(value = BackupDataInput.class, looseSignatures = true)
+@Implements(value = BackupDataInput.class)
 public class ShadowBackupDataInput {
 
   private List<BackupDataEntity> entities = new ArrayList<>();
@@ -41,7 +42,9 @@ public class ShadowBackupDataInput {
 
   // Using loose signature because EntityHeader is a private nested class.
   @Implementation
-  protected int readNextHeader_native(Object backupReader, Object entity) {
+  protected int readNextHeader_native(
+      long backupReader,
+      @ClassName("android.app.backup.BackupDataInput$EntityHeader") Object entity) {
     if (currentBytesRead < currentBytesToRead) {
       // Return failure to read header due to unread data bytes.
       return -1;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
index 2f168385e..6484674ba 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBatteryManager.java
@@ -9,13 +9,22 @@ import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 @Implements(BatteryManager.class)
 public class ShadowBatteryManager {
-  private boolean isCharging = false;
-  private long chargeTimeRemaining = 0;
-  private final Map<Integer, Long> longProperties = new HashMap<>();
-  private final Map<Integer, Integer> intProperties = new HashMap<>();
+  private static final Map<Integer, Long> longProperties = new HashMap<>();
+  private static final Map<Integer, Integer> intProperties = new HashMap<>();
+  private static boolean isCharging = false;
+  private static long chargeTimeRemaining = 0;
+
+  @Resetter
+  public static void reset() {
+    isCharging = false;
+    chargeTimeRemaining = 0;
+    longProperties.clear();
+    intProperties.clear();
+  }
 
   @Implementation(minSdk = M)
   protected boolean isCharging() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
index 21e7d51f3..4f8286a5c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBiometricManager.java
@@ -12,6 +12,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
@@ -23,11 +24,17 @@ import org.robolectric.util.reflector.ForType;
     isInAndroidSdk = false)
 public class ShadowBiometricManager {
 
-  protected boolean biometricServiceConnected = true;
-  private int authenticatorType = BiometricManager.Authenticators.EMPTY_SET;
+  protected static boolean biometricServiceConnected = true;
+  private static int authenticatorType = BiometricManager.Authenticators.EMPTY_SET;
 
   @RealObject private BiometricManager realBiometricManager;
 
+  @Resetter
+  public static void reset() {
+    biometricServiceConnected = true;
+    authenticatorType = BiometricManager.Authenticators.EMPTY_SET;
+  }
+
   @SuppressWarnings("deprecation")
   @RequiresPermission(USE_BIOMETRIC)
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmap.java
index 931be2006..a8cc19e74 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmap.java
@@ -6,6 +6,7 @@ import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import com.google.common.base.Preconditions;
 import java.io.InputStream;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -17,7 +18,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Base class for {@link Bitmap} shadows. */
-@Implements(value = Bitmap.class, shadowPicker = Picker.class, looseSignatures = true)
+@Implements(value = Bitmap.class, shadowPicker = Picker.class)
 public abstract class ShadowBitmap {
 
   @RealObject protected Bitmap realBitmap;
@@ -136,7 +137,7 @@ public abstract class ShadowBitmap {
   public abstract void setDescription(String s);
 
   @Implementation(minSdk = U.SDK_INT)
-  protected void setGainmap(Object gainmap) {
+  protected void setGainmap(@ClassName("android.graphics.Gainmap") Object gainmap) {
     Preconditions.checkState(!realBitmap.isRecycled(), "Bitmap is recycled");
     reflector(BitmapReflector.class, realBitmap).setGainmap(gainmap);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
index 207228df3..183636434 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBitmapFactory.java
@@ -162,9 +162,6 @@ public class ShadowBitmapFactory {
       if (sais.isNinePatch()) {
         ninePatchChunk = new byte[0];
       }
-      if (sais.getDelegate() != null) {
-        is = sais.getDelegate();
-      }
     }
 
     try {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
index 21e41ae14..0d954ae47 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothAdapter.java
@@ -60,7 +60,7 @@ import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @SuppressWarnings({"UnusedDeclaration"})
-@Implements(value = BluetoothAdapter.class, looseSignatures = true)
+@Implements(value = BluetoothAdapter.class)
 public class ShadowBluetoothAdapter {
   @RealObject private BluetoothAdapter realAdapter;
 
@@ -406,17 +406,15 @@ public class ShadowBluetoothAdapter {
     return scanMode;
   }
 
-  /**
-   * Needs looseSignatures because the return value changed from {@code int} to {@link Duration}
-   * starting in T.
-   */
-  @Implementation
-  protected Object getDiscoverableTimeout() {
-    if (RuntimeEnvironment.getApiLevel() <= S_V2) {
-      return (int) discoverableTimeout.toSeconds();
-    } else {
-      return discoverableTimeout;
-    }
+  @Implementation(maxSdk = S_V2)
+  protected int getDiscoverableTimeout() {
+    return (int) discoverableTimeout.toSeconds();
+  }
+
+  /** Return value changed from {@code int} to {@link Duration} starting in T. */
+  @Implementation(minSdk = TIRAMISU, methodName = "getDiscoverableTimeout")
+  protected Duration getDiscoverableTimeoutT() {
+    return discoverableTimeout;
   }
 
   @Implementation(maxSdk = S_V2)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
index 5e88df63c..84f201404 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothDevice.java
@@ -7,6 +7,7 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -43,7 +44,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
 
 /** Shadow for {@link BluetoothDevice}. */
-@Implements(value = BluetoothDevice.class, looseSignatures = true)
+@Implements(value = BluetoothDevice.class)
 public class ShadowBluetoothDevice {
   /**
    * Interceptor interface for {@link BluetoothGatt} objects. Tests that require configuration of
@@ -110,6 +111,21 @@ public class ShadowBluetoothDevice {
     this.name = name;
   }
 
+  /**
+   * Set the alias for bluetooth device.
+   *
+   * @param alias The alias name that set to bluetooth device.
+   * @return If API is larger than or equals to S, it returns [BluetoothStatusCodes] code, otherwise
+   *     it returns boolean.
+   */
+  public Object setAlias(String alias) {
+    if (RuntimeEnvironment.getApiLevel() >= S) {
+      return setAliasS(alias);
+    } else {
+      return setAliasBeforeS(alias);
+    }
+  }
+
   /**
    * Sets the alias name of the device.
    *
@@ -119,14 +135,25 @@ public class ShadowBluetoothDevice {
    *
    * @param alias alias name.
    */
-  @Implementation
-  public Object setAlias(Object alias) {
-    this.alias = (String) alias;
-    if (RuntimeEnvironment.getApiLevel() >= S) {
-      return BluetoothStatusCodes.SUCCESS;
-    } else {
-      return true;
-    }
+  @Implementation(maxSdk = R, methodName = "setAlias")
+  protected boolean setAliasBeforeS(String alias) {
+    this.alias = alias;
+    return true;
+  }
+
+  /**
+   * Sets the alias name of the device for API >= 31.
+   *
+   * <p>Alias is the locally modified name of a remote device.
+   *
+   * <p>Alias Name is not part of the supported SDK, and accessed via reflection.
+   *
+   * @param alias alias name.
+   */
+  @Implementation(minSdk = S, methodName = "setAlias")
+  protected int setAliasS(String alias) {
+    this.alias = alias;
+    return BluetoothStatusCodes.SUCCESS;
   }
 
   /**
@@ -232,7 +259,7 @@ public class ShadowBluetoothDevice {
   /**
    * Overrides behavior of {@link BluetoothDevice#getBondState} to return pre-set result.
    *
-   * @returns Value set by calling {@link ShadowBluetoothDevice#setBondState}. If setBondState has
+   * @return Value set by calling {@link ShadowBluetoothDevice#setBondState}. If setBondState has
    *     not previously been called, will return {@link BluetoothDevice#BOND_NONE} to indicate the
    *     device is not bonded.
    */
@@ -325,7 +352,7 @@ public class ShadowBluetoothDevice {
    * Overrides behavior of {@link BluetoothDevice#fetchUuidsWithSdp}. This method updates the
    * counter which counts the number of invocations of this method.
    *
-   * @returns Value set by calling {@link ShadowBluetoothDevice#setFetchUuidsWithSdpResult}. If not
+   * @return Value set by calling {@link ShadowBluetoothDevice#setFetchUuidsWithSdpResult}. If not
    *     previously set, will return false by default.
    */
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeBroadcast.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeBroadcast.java
new file mode 100644
index 000000000..63a37cf03
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothLeBroadcast.java
@@ -0,0 +1,176 @@
+package org.robolectric.shadows;
+
+import android.bluetooth.BluetoothLeBroadcast;
+import android.bluetooth.BluetoothLeBroadcastSettings;
+import android.bluetooth.BluetoothStatusCodes;
+import android.os.Build.VERSION_CODES;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Executor;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+
+/** Shadow of {@link BluetoothLeBroadcast}. */
+@Implements(
+    value = BluetoothLeBroadcast.class,
+    minSdk = VERSION_CODES.UPSIDE_DOWN_CAKE,
+    isInAndroidSdk = false)
+public class ShadowBluetoothLeBroadcast {
+
+  private final Map<BluetoothLeBroadcast.Callback, Executor> mCallbackExecutorMap = new HashMap<>();
+  private final List<Integer> activeBroadcastIds = new ArrayList<>();
+
+  @Implementation
+  protected void registerCallback(Executor executor, BluetoothLeBroadcast.Callback callback) {
+    Objects.requireNonNull(executor, "executor cannot be null");
+    Objects.requireNonNull(callback, "callback cannot be null");
+    synchronized (mCallbackExecutorMap) {
+      if (mCallbackExecutorMap.containsKey(callback)) {
+        throw new IllegalArgumentException("This callback has already been registered");
+      }
+      mCallbackExecutorMap.put(callback, executor);
+    }
+  }
+
+  @Implementation
+  protected void unregisterCallback(BluetoothLeBroadcast.Callback callback) {
+    Objects.requireNonNull(callback, "callback cannot be null");
+    synchronized (mCallbackExecutorMap) {
+      if (mCallbackExecutorMap.remove(callback) == null) {
+        throw new IllegalArgumentException("This callback has not been registered");
+      }
+    }
+  }
+
+  @Implementation
+  protected void startBroadcast(BluetoothLeBroadcastSettings broadcastSettings) {
+    if (mCallbackExecutorMap.isEmpty()) {
+      throw new IllegalStateException("No callback was ever registered");
+    }
+
+    if (broadcastSettings == null) {
+      sendOnBroadcastStartFailed(
+          BluetoothStatusCodes.ERROR_LE_BROADCAST_INVALID_CODE, mCallbackExecutorMap);
+    } else {
+      int broadcastId = activeBroadcastIds.size();
+      activeBroadcastIds.add(broadcastId);
+      sendOnBroadcastStarted(
+          BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST, broadcastId, mCallbackExecutorMap);
+    }
+  }
+
+  @Implementation
+  protected void stopBroadcast(int broadcastId) {
+    if (mCallbackExecutorMap.isEmpty()) {
+      throw new IllegalStateException("No callback was ever registered");
+    }
+
+    if (!activeBroadcastIds.contains(broadcastId)) {
+      sendOnBroadcastStopFailed(
+          BluetoothStatusCodes.ERROR_LE_BROADCAST_INVALID_BROADCAST_ID, mCallbackExecutorMap);
+    } else {
+      activeBroadcastIds.remove(Integer.valueOf(broadcastId));
+      sendOnBroadcastStopped(
+          BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST, broadcastId, mCallbackExecutorMap);
+    }
+  }
+
+  @Implementation
+  protected void updateBroadcast(int broadcastId, BluetoothLeBroadcastSettings broadcastSettings) {
+    Objects.requireNonNull(broadcastSettings, "broadcastSettings cannot be null");
+    if (mCallbackExecutorMap.isEmpty()) {
+      throw new IllegalStateException("No callback was ever registered");
+    }
+
+    if (!activeBroadcastIds.contains(broadcastId)) {
+      sendOnBroadcastUpdateFailed(
+          BluetoothStatusCodes.ERROR_LE_BROADCAST_INVALID_BROADCAST_ID,
+          broadcastId,
+          mCallbackExecutorMap);
+    } else {
+      sendOnBroadcastUpdated(
+          BluetoothStatusCodes.REASON_LOCAL_APP_REQUEST, broadcastId, mCallbackExecutorMap);
+    }
+  }
+
+  public Map<BluetoothLeBroadcast.Callback, Executor> getCallbackExecutorMap() {
+    return mCallbackExecutorMap;
+  }
+
+  // Simulate sending onBroadcastStartFailed callback
+  private void sendOnBroadcastStartFailed(
+      int reason, Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastStartFailed(reason));
+    }
+  }
+
+  // Simulate sending onBroadcastStarted callback
+  private void sendOnBroadcastStarted(
+      int reason,
+      int broadcastId,
+      Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastStarted(reason, broadcastId));
+    }
+  }
+
+  // Simulate sending onBroadcastStopFailed callback
+  private void sendOnBroadcastStopFailed(
+      int reason, Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastStopFailed(reason));
+    }
+  }
+
+  // Simulate sending onBroadcastStopped callback
+  private void sendOnBroadcastStopped(
+      int reason,
+      int broadcastId,
+      Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastStopped(reason, broadcastId));
+    }
+  }
+
+  // Simulate sending onBroadcastUpdateFailed callback
+  private void sendOnBroadcastUpdateFailed(
+      int reason,
+      int broadcastId,
+      Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastUpdateFailed(reason, broadcastId));
+    }
+  }
+
+  // Simulate sending onBroadcastUpdated callback
+  private void sendOnBroadcastUpdated(
+      int reason,
+      int broadcastId,
+      Map<BluetoothLeBroadcast.Callback, Executor> callbackExecutorMap) {
+    for (Map.Entry<BluetoothLeBroadcast.Callback, Executor> entry :
+        callbackExecutorMap.entrySet()) {
+      BluetoothLeBroadcast.Callback callback = entry.getKey();
+      Executor executor = entry.getValue();
+      executor.execute(() -> callback.onBroadcastUpdated(reason, broadcastId));
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
index 66d464c17..b5ef6211f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBluetoothManager.java
@@ -21,6 +21,7 @@ import java.util.List;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.PerfStatsCollector;
 import org.robolectric.util.ReflectionHelpers;
@@ -36,7 +37,12 @@ public class ShadowBluetoothManager {
           BluetoothProfile.STATE_DISCONNECTED,
           BluetoothProfile.STATE_DISCONNECTING);
 
-  private final ArrayList<BleDevice> bleDevices = new ArrayList<>();
+  private static final ArrayList<BleDevice> bleDevices = new ArrayList<>();
+
+  @Resetter
+  public static void reset() {
+    bleDevices.clear();
+  }
 
   /** Used for storing registered {@link BluetoothDevice} with the specified profile and state. */
   @AutoValue
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
index 56a6b925e..ae0506afe 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowBuild.java
@@ -11,6 +11,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
@@ -219,6 +220,39 @@ public class ShadowBuild {
     radioVersionOverride = radioVersion;
   }
 
+  /**
+   * Sets the value of the {@link Build#SOC_MANUFACTURER} field.
+   *
+   * <p>It will be reset for the next test.
+   *
+   * <p>Added in API level 31.
+   */
+  public static void setSystemOnChipManufacturer(String systemOnChipManufacturer) {
+    ReflectionHelpers.setStaticField(Build.class, "SOC_MANUFACTURER", systemOnChipManufacturer);
+  }
+
+  /**
+   * Sets the value of the {@link Build#SOC_MODEL} field.
+   *
+   * <p>It will be reset for the next test.
+   *
+   * <p>Added in API level 31.
+   */
+  public static void setSystemOnChipModel(String systemOnChipModel) {
+    ReflectionHelpers.setStaticField(Build.class, "SOC_MODEL", systemOnChipModel);
+  }
+
+  /**
+   * Sets the value of the {@link Build#ODM_SKU} field.
+   *
+   * <p>It will be reset for the next test.
+   *
+   * <p>Added in API level 31.
+   */
+  public static void setOdmSku(String odmSku) {
+    reflector(_Build_.class).setOdmSku(odmSku);
+  }
+
   @Implementation
   protected static String getRadioVersion() {
     if (radioVersionOverride != null) {
@@ -247,6 +281,10 @@ public class ShadowBuild {
     @Static
     void __staticInitializer__();
 
+    @Static
+    @Accessor("ODM_SKU")
+    void setOdmSku(String odmSku);
+
     @Static
     @Direct
     String getRadioVersion();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
index 382815314..6e079d4f5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraDeviceImpl.java
@@ -20,6 +20,7 @@ import android.view.Surface;
 import com.google.common.util.concurrent.MoreExecutors;
 import java.util.List;
 import java.util.concurrent.Executor;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
@@ -33,7 +34,7 @@ import org.robolectric.util.reflector.WithType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow class for {@link CameraDeviceImpl} */
-@Implements(value = CameraDeviceImpl.class, isInAndroidSdk = false, looseSignatures = true)
+@Implements(value = CameraDeviceImpl.class, isInAndroidSdk = false)
 public class ShadowCameraDeviceImpl {
   @RealObject private CameraDeviceImpl realObject;
   private boolean closed = false;
@@ -41,24 +42,25 @@ public class ShadowCameraDeviceImpl {
   @Implementation(minSdk = V.SDK_INT)
   @InDevelopment
   protected void __constructor__(
-      Object cameraId,
-      Object callback,
-      Object executor,
-      Object characteristics,
-      Object cameraManager,
-      Object appTargetSdkVersion,
-      Object ctx,
-      Object cameraDeviceSetup) {
+      String cameraId,
+      StateCallback callback,
+      Executor executor,
+      CameraCharacteristics characteristics,
+      CameraManager cameraManager,
+      int appTargetSdkVersion,
+      Context ctx,
+      @ClassName("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
+          Object cameraDeviceSetup) {
     try {
       reflector(CameraDeviceImplReflector.class, realObject)
           .__constructor__(
-              (String) cameraId,
-              (StateCallback) callback,
-              (Executor) executor,
-              (CameraCharacteristics) characteristics,
-              (CameraManager) cameraManager,
-              (int) appTargetSdkVersion,
-              (Context) ctx,
+              cameraId,
+              callback,
+              executor,
+              characteristics,
+              cameraManager,
+              appTargetSdkVersion,
+              ctx,
               // TODO(juliansull) Remove once Robolectric compiles against Android V
               Class.forName("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
                   .cast(cameraDeviceSetup));
@@ -73,6 +75,45 @@ public class ShadowCameraDeviceImpl {
         .setDeviceExecutor(MoreExecutors.directExecutor());
   }
 
+  // TODO(congxiliu) Change minsdk to Baklava once Baklava is fully released in AOSP
+  @Implementation(minSdk = V.SDK_INT)
+  @InDevelopment
+  protected void __constructor__(
+      String cameraId,
+      StateCallback callback,
+      Executor executor,
+      CameraCharacteristics characteristics,
+      CameraManager cameraManager,
+      int appTargetSdkVersion,
+      Context ctx,
+      @ClassName("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
+          Object cameraDeviceSetup,
+      boolean unused) {
+    try {
+      reflector(CameraDeviceImplReflector.class, realObject)
+          .__constructor__(
+              cameraId,
+              callback,
+              executor,
+              characteristics,
+              cameraManager,
+              appTargetSdkVersion,
+              ctx,
+              // TODO(juliansull) Remove once Robolectric compiles against Android V
+              Class.forName("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
+                  .cast(cameraDeviceSetup),
+              unused);
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(e);
+    }
+
+    // When singleThreadedDeviceExecutor flag is set, this gets put on a background thread.
+    // This isn't necessary for Robolectric as there is no real camera, so we default back to the
+    // given executor.
+    reflector(CameraDeviceImplReflector.class, realObject)
+        .setDeviceExecutor(MoreExecutors.directExecutor());
+  }
+
   @Implementation
   protected CaptureRequest.Builder createCaptureRequest(int templateType) {
     checkIfCameraClosedOrInError();
@@ -165,6 +206,19 @@ public class ShadowCameraDeviceImpl {
         @WithType("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
             Object cameraDeviceSetup);
 
+    @Direct
+    void __constructor__(
+        String cameraId,
+        StateCallback callback,
+        Executor executor,
+        CameraCharacteristics characteristics,
+        CameraManager cameraManager,
+        int appTargetSdkVersion,
+        Context ctx,
+        @WithType("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
+            Object cameraDeviceSetup,
+        boolean unused);
+
     @Accessor("mDeviceExecutor")
     void setDeviceExecutor(Executor executor);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
index c35e202b8..58a53cc70 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCameraManager.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.NonNull;
@@ -35,31 +36,57 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow class for {@link CameraManager} */
 @Implements(value = CameraManager.class)
 public class ShadowCameraManager {
-  @RealObject private CameraManager realObject;
-
+  // Keep references to cameras so they can be closed after each test
+  protected static final Set<CameraDeviceImpl> createdCameras =
+      Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<>()));
   // LinkedHashMap used to ensure getCameraIdList returns ids in the order in which they were added
-  private final Map<String, CameraCharacteristics> cameraIdToCharacteristics =
+  private static final Map<String, CameraCharacteristics> cameraIdToCharacteristics =
       new LinkedHashMap<>();
-  private final Map<String, Boolean> cameraTorches = new HashMap<>();
-  private final Set<CameraManager.AvailabilityCallback> registeredCallbacks = new HashSet<>();
+  private static final Map<String, Boolean> cameraTorches = new HashMap<>();
+  private static final Set<CameraManager.AvailabilityCallback> registeredCallbacks =
+      new HashSet<>();
   // Cannot reference the torch callback in < Android M
-  private final Set<Object> torchCallbacks = new HashSet<>();
+  private static final Set<Object> torchCallbacks = new HashSet<>();
   // Most recent camera device opened with openCamera
-  private CameraDevice lastDevice;
+  private static CameraDevice lastDevice;
   // Most recent callback passed to openCamera
-  private CameraDevice.StateCallback lastCallback;
-  @Nullable private Executor lastCallbackExecutor;
-  @Nullable private Handler lastCallbackHandler;
+  private static CameraDevice.StateCallback lastCallback;
+  @Nullable private static Executor lastCallbackExecutor;
+  @Nullable private static Handler lastCallbackHandler;
+  @RealObject private CameraManager realObject;
 
-  // Keep references to cameras so they can be closed after each test
-  protected static final Set<CameraDeviceImpl> createdCameras =
-      Collections.synchronizedSet(Collections.newSetFromMap(new WeakHashMap<>()));
+  @Resetter
+  public static void reset() {
+    for (CameraDeviceImpl cameraDevice : createdCameras) {
+      if (cameraDevice != null) {
+        cameraDevice.close();
+      }
+    }
+    createdCameras.clear();
+    cameraIdToCharacteristics.clear();
+    cameraTorches.clear();
+    registeredCallbacks.clear();
+    torchCallbacks.clear();
+    if (lastDevice != null) {
+      lastDevice.close();
+    }
+    lastDevice = null;
+    lastCallback = null;
+    lastCallbackExecutor = null;
+    if (lastCallbackHandler != null) {
+      // Flush existing handler tasks to ensure camera related callbacks are called properly.
+      shadowOf(lastCallbackHandler.getLooper()).idle();
+      lastCallbackHandler.removeCallbacksAndMessages(null);
+    }
+    lastCallbackHandler = null;
+  }
 
   @Implementation
   @NonNull
@@ -98,8 +125,7 @@ public class ShadowCameraManager {
     return openCameraDeviceUserAsync(cameraId, callback, executor, uid, oomScoreOffset);
   }
 
-  @Implementation(minSdk = V.SDK_INT)
-  @InDevelopment
+  @Implementation(minSdk = V.SDK_INT, maxSdk = V.SDK_INT)
   protected CameraDevice openCameraDeviceUserAsync(
       String cameraId,
       CameraDevice.StateCallback callback,
@@ -110,6 +136,22 @@ public class ShadowCameraManager {
     return openCameraDeviceUserAsync(cameraId, callback, executor, uid, oomScoreOffset);
   }
 
+  // in development API has reverted back to the T signature. Just use a different method name
+  // to avoid conflicts.
+  // TODO: increment this to  minSdk next-SDK-after-V once V is fully released
+  @Implementation(methodName = "openCameraDeviceUserAsync", minSdk = Baklava.SDK_INT)
+  @InDevelopment
+  protected CameraDevice openCameraDeviceUserAsyncPostV(
+      String cameraId,
+      CameraDevice.StateCallback callback,
+      Executor executor,
+      int unusedClientUid,
+      int unusedOomScoreOffset,
+      boolean unused) {
+    return openCameraDeviceUserAsync(
+        cameraId, callback, executor, unusedClientUid, unusedOomScoreOffset);
+  }
+
   @Implementation(minSdk = Build.VERSION_CODES.S, maxSdk = Build.VERSION_CODES.TIRAMISU)
   protected CameraDevice openCameraDeviceUserAsync(
       String cameraId,
@@ -245,7 +287,20 @@ public class ShadowCameraManager {
       CameraCharacteristics characteristics,
       Context context) {
     Map<String, CameraCharacteristics> cameraCharacteristicsMap = Collections.emptyMap();
-    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT) {
+    if (RuntimeEnvironment.getApiLevel() >= Baklava.SDK_INT) {
+      return reflector(ReflectorCameraDeviceImpl.class)
+          .newCameraDeviceImplPostV(
+              cameraId,
+              callback,
+              executor,
+              characteristics,
+              realObject,
+              context.getApplicationInfo().targetSdkVersion,
+              context,
+              null,
+              false);
+
+    } else if (RuntimeEnvironment.getApiLevel() == V.SDK_INT) {
       return reflector(ReflectorCameraDeviceImpl.class)
           .newCameraDeviceImplV(
               cameraId,
@@ -351,14 +406,6 @@ public class ShadowCameraManager {
     lastCallbackExecutor = executor;
   }
 
-  @Resetter
-  public static void reset() {
-    for (CameraDeviceImpl cameraDevice : createdCameras) {
-      cameraDevice.close();
-    }
-    createdCameras.clear();
-  }
-
   @ForType(CameraDeviceImpl.class)
   interface ReflectorCameraDeviceImpl {
     @Constructor
@@ -382,6 +429,19 @@ public class ShadowCameraManager {
         Context context,
         @WithType("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
             Object cameraDeviceSetup);
+
+    @Constructor
+    CameraDeviceImpl newCameraDeviceImplPostV(
+        String cameraId,
+        CameraDevice.StateCallback callback,
+        Executor executor,
+        CameraCharacteristics characteristics,
+        CameraManager cameraManager,
+        int targetSdkVersion,
+        Context context,
+        @WithType("android.hardware.camera2.CameraDevice$CameraDeviceSetup")
+            Object cameraDeviceSetup,
+        boolean unused);
   }
 
   /** Accessor interface for {@link CameraManager}'s internals. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
index 7f919e95a..22795d84b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCardEmulation.java
@@ -10,7 +10,9 @@ import android.nfc.INfcCardEmulation;
 import android.nfc.cardemulation.CardEmulation;
 import android.provider.Settings;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
+import java.util.Set;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -19,11 +21,13 @@ import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow implementation of {@link CardEmulation}. */
 @Implements(CardEmulation.class)
 public class ShadowCardEmulation {
 
+  private static final Set<ComponentName> defaultObserveModeEnabledServices = new HashSet<>();
   private static Map<String, ComponentName> defaultServiceForCategoryMap = new HashMap<>();
   private static ComponentName preferredService = null;
 
@@ -46,6 +50,17 @@ public class ShadowCardEmulation {
     return true;
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean setShouldDefaultToObserveModeForService(
+      ComponentName service, boolean shouldDefaultToObserveMode) {
+    if (shouldDefaultToObserveMode) {
+      defaultObserveModeEnabledServices.add(service);
+    } else {
+      defaultObserveModeEnabledServices.remove(service);
+    }
+    return true;
+  }
+
   /**
    * Modifies the behavior of {@link #isDefaultServiceForCategory(ComponentName, String)} to return
    * {@code true} for the given inputs.
@@ -74,6 +89,13 @@ public class ShadowCardEmulation {
         value ? 1 : 0);
   }
 
+  /**
+   * Returns whether the given service has dynamically set observe mode to be enabled by default.
+   */
+  public static boolean getShouldDefaultToObserveModeForService(ComponentName service) {
+    return defaultObserveModeEnabledServices.contains(service);
+  }
+
   @Resetter
   public static void reset() {
     defaultServiceForCategoryMap = new HashMap<>();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
index 901097b93..3530f1099 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCarrierConfigManager.java
@@ -13,14 +13,22 @@ import java.util.HashMap;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.versioning.AndroidVersions.U;
 
 @Implements(value = CarrierConfigManager.class, minSdk = M)
 public class ShadowCarrierConfigManager {
 
-  private final HashMap<Integer, PersistableBundle> bundles = new HashMap<>();
-  private final HashMap<Integer, PersistableBundle> overrideBundles = new HashMap<>();
-  private boolean readPhoneStatePermission = true;
+  private static final HashMap<Integer, PersistableBundle> bundles = new HashMap<>();
+  private static final HashMap<Integer, PersistableBundle> overrideBundles = new HashMap<>();
+  private static boolean readPhoneStatePermission = true;
+
+  @Resetter
+  public static void reset() {
+    bundles.clear();
+    overrideBundles.clear();
+    readPhoneStatePermission = true;
+  }
 
   @VisibleForTesting static final PersistableBundle BASE;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
index 0cfeb053b..760070a3f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowChoreographer.java
@@ -1,7 +1,6 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N;
-import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static com.google.common.base.Preconditions.checkState;
@@ -206,22 +205,26 @@ public abstract class ShadowChoreographer {
     if (RuntimeEnvironment.getApiLevel() >= N) {
       ShadowBackdropFrameRenderer.reset();
     }
-    if (RuntimeEnvironment.getApiLevel() >= P) {
-      reflector(ChoreographerReflector.class).setMainInstance(null);
-    }
   }
 
   /** Accessor interface for {@link Choreographer}'s internals */
   @ForType(Choreographer.class)
   protected interface ChoreographerReflector {
-    @Accessor("sThreadInstance")
-    @Static
-    ThreadLocal<Choreographer> getThreadInstance();
 
-    // used to reset main instance
-    @Accessor("mMainInstance")
-    @Static
-    void setMainInstance(Choreographer choreographer);
+    @Accessor("mLastFrameTimeNanos")
+    void setLastFrameTimeNanos(long time);
+
+    @Accessor("mCallbackQueues")
+    Object[] getCallbackQueues();
+
+    @Accessor("mCallbackPool")
+    void setCallbackPool(Object callbackPool);
+
+    @Accessor("mFrameScheduled")
+    void setFrameScheduled(boolean frameScheduled);
+
+    @Accessor("mCallbacksRunning")
+    void setCallbacksRunning(boolean callbacksRunning);
 
     @Direct
     void doFrame(long frameTimeNanos, int frame);
@@ -235,6 +238,13 @@ public abstract class ShadowChoreographer {
     @Accessor("mDisplayEventReceiver")
     DisplayEventReceiver getReceiver();
 
+    @Accessor("sThreadInstance")
+    @Static
+    ThreadLocal<Choreographer> getThreadInstance();
+
+    @Accessor("mLooper")
+    Looper getLooper();
+
     @Direct
     void __constructor__(Looper looper);
 
@@ -243,5 +253,21 @@ public abstract class ShadowChoreographer {
 
     @Direct
     void __constructor__(Looper looper, int vsyncSource);
+
+    @Accessor("mFrameData")
+    /*android.view.Choreographer$FrameData*/ Object getFrameData();
+
+    @Accessor("mLastFrameIntervalNanos")
+    void setLastFrameIntervalNanos(long val);
+
+    @Accessor("mFrameInfo")
+    Object /* FrameInfo */ getFrameInfo();
+  }
+
+  /** Accessor interface for {@link Choreographer}'s CallbackQueue internals */
+  @ForType(className = "android.view.Choreographer$CallbackQueue")
+  protected interface CallbackQueueReflector {
+    @Accessor("mHead")
+    void setHead(Object head);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
index e90b0a426..3150f1f4f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowClipboardManager.java
@@ -16,6 +16,7 @@ import java.util.concurrent.CopyOnWriteArrayList;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.ForType;
@@ -23,10 +24,26 @@ import org.robolectric.util.reflector.ForType;
 @SuppressWarnings("UnusedDeclaration")
 @Implements(ClipboardManager.class)
 public class ShadowClipboardManager {
-  @RealObject private ClipboardManager realClipboardManager;
-  private final Collection<OnPrimaryClipChangedListener> listeners =
+  private static final Collection<OnPrimaryClipChangedListener> listeners =
       new CopyOnWriteArrayList<OnPrimaryClipChangedListener>();
-  private ClipData clip;
+  private static ClipData clip;
+  @RealObject private ClipboardManager realClipboardManager;
+
+  @Resetter
+  public static void reset() {
+    clip = null;
+    listeners.clear();
+  }
+
+  @Implementation(minSdk = P)
+  protected void clearPrimaryClip() {
+    setPrimaryClip(null);
+  }
+
+  @Implementation
+  protected ClipData getPrimaryClip() {
+    return clip;
+  }
 
   @Implementation
   protected void setPrimaryClip(ClipData clip) {
@@ -60,16 +77,6 @@ public class ShadowClipboardManager {
     }
   }
 
-  @Implementation(minSdk = P)
-  protected void clearPrimaryClip() {
-    setPrimaryClip(null);
-  }
-
-  @Implementation
-  protected ClipData getPrimaryClip() {
-    return clip;
-  }
-
   @Implementation
   protected ClipDescription getPrimaryClipDescription() {
     return clip == null ? null : clip.getDescription();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
index 866db1909..c47ef3439 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowColorDisplayManager.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.Q;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest;
 import android.annotation.RequiresPermission;
@@ -10,13 +11,19 @@ import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.WithType;
 
+/** Shadow for {@link ColorDisplayManager}. */
 @Implements(
     className = "android.hardware.display.ColorDisplayManager",
     isInAndroidSdk = false,
     minSdk = Q)
 public class ShadowColorDisplayManager {
 
+  // These member variables do not need to be static, ColorDisplayManager uses a static instance.
   private boolean isNightDisplayActivated;
   private int nightDisplayTemperature;
   private int nightDisplayAutoMode;
@@ -27,11 +34,6 @@ public class ShadowColorDisplayManager {
   // No capabilities by default
   private int transformCapabilities = 0x0;
 
-  @Implementation
-  protected void __constructor__() {
-    // Don't initialize ColorDisplayManagerInternal.
-  }
-
   @Implementation
   @SystemApi
   @RequiresPermission(Manifest.permission.CONTROL_DISPLAY_COLOR_TRANSFORMS)
@@ -116,4 +118,17 @@ public class ShadowColorDisplayManager {
   public int getSaturationLevel() {
     return saturationLevel;
   }
+
+  @Resetter
+  public static void reset() {
+    reflector(ColorDisplayManagerInternalReflector.class).setInstance(null);
+  }
+
+  @ForType(className = "android.hardware.display.ColorDisplayManager$ColorDisplayManagerInternal")
+  interface ColorDisplayManagerInternalReflector {
+    @Accessor("sInstance")
+    void setInstance(
+        @WithType("android.hardware.display.ColorDisplayManager$ColorDisplayManagerInternal")
+            Object instance);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
index bb345af45..18e62c7db 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompanionDeviceManager.java
@@ -34,13 +34,13 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 @Implements(value = CompanionDeviceManager.class, minSdk = VERSION_CODES.O)
 public class ShadowCompanionDeviceManager {
 
-  protected final Set<RoboAssociationInfo> associations = new HashSet<>();
-  protected final Set<ComponentName> hasNotificationAccess = new HashSet<>();
-  protected ComponentName lastRequestedNotificationAccess;
-  protected AssociationRequest lastAssociationRequest;
-  protected MacAddress lastSystemApiAssociationMacAddress;
-  protected CompanionDeviceManager.Callback lastAssociationCallback;
-  protected String lastObservingDevicePresenceDeviceAddress;
+  private final Set<RoboAssociationInfo> associations = new HashSet<>();
+  private final Set<ComponentName> hasNotificationAccess = new HashSet<>();
+  private ComponentName lastRequestedNotificationAccess;
+  private AssociationRequest lastAssociationRequest;
+  private MacAddress lastSystemApiAssociationMacAddress;
+  private CompanionDeviceManager.Callback lastAssociationCallback;
+  private String lastObservingDevicePresenceDeviceAddress;
 
   private static final int DEFAULT_SYSTEMDATASYNCFLAGS = -1;
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
index 268b8163b..30c679f13 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCompatibility.java
@@ -4,7 +4,6 @@ import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.compat.Compatibility;
-import android.compat.annotation.ChangeId;
 import android.os.Build.VERSION_CODES;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMap;
@@ -34,7 +33,7 @@ public class ShadowCompatibility {
   @RealObject protected static Compatibility realCompatibility;
 
   @Implementation(minSdk = VERSION_CODES.S_V2)
-  protected static boolean isChangeEnabled(@ChangeId long changeId) {
+  protected static boolean isChangeEnabled(long changeId) {
     if (changeId == CALL_ACTIVITY_RESULT_BEFORE_RESUME) {
       return false;
     } else if (ENABLED_SINCE_TARGET_SDK.containsKey(changeId)) {
@@ -60,6 +59,6 @@ public class ShadowCompatibility {
 
     @Direct
     @Static
-    boolean isChangeEnabled(@ChangeId long changeId);
+    boolean isChangeEnabled(long changeId);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
index 9380b70c4..2e9a116ba 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowConnectivityManager.java
@@ -23,6 +23,7 @@ import java.util.Set;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 
 @Implements(ConnectivityManager.class)
@@ -32,29 +33,35 @@ public class ShadowConnectivityManager {
   static final int NET_ID_WIFI = ConnectivityManager.TYPE_WIFI;
   static final int NET_ID_MOBILE = ConnectivityManager.TYPE_MOBILE;
 
-  private NetworkInfo activeNetworkInfo;
-  private boolean backgroundDataSetting;
-  private boolean networkCallbacksEnabled = true;
-  private int restrictBackgroundStatus = ConnectivityManager.RESTRICT_BACKGROUND_STATUS_DISABLED;
-  private int networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;
-  private final Map<Integer, NetworkInfo> networkTypeToNetworkInfo = new HashMap<>();
-
-  private HashSet<ConnectivityManager.NetworkCallback> networkCallbacks = new HashSet<>();
-  private final HashSet<PendingIntent> networkCallbackPendingIntents = new HashSet<>();
-
-  private final Map<Integer, Network> netIdToNetwork = new HashMap<>();
-  private final Map<Integer, NetworkInfo> netIdToNetworkInfo = new HashMap<>();
-  private Network processBoundNetwork;
-  private boolean defaultNetworkActive;
-  private HashSet<ConnectivityManager.OnNetworkActiveListener> onNetworkActiveListeners =
+  private static NetworkInfo activeNetworkInfo;
+  private static boolean backgroundDataSetting;
+  private static boolean networkCallbacksEnabled = true;
+  private static int restrictBackgroundStatus =
+      ConnectivityManager.RESTRICT_BACKGROUND_STATUS_DISABLED;
+  private static int networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;
+  private static final Map<Integer, NetworkInfo> networkTypeToNetworkInfo = new HashMap<>();
+
+  private static HashSet<ConnectivityManager.NetworkCallback> networkCallbacks = new HashSet<>();
+  private static final HashSet<PendingIntent> networkCallbackPendingIntents = new HashSet<>();
+
+  private static final Map<Integer, Network> netIdToNetwork = new HashMap<>();
+  private static final Map<Integer, NetworkInfo> netIdToNetworkInfo = new HashMap<>();
+  private static Network processBoundNetwork;
+  private static boolean defaultNetworkActive = true;
+  private static HashSet<ConnectivityManager.OnNetworkActiveListener> onNetworkActiveListeners =
       new HashSet<>();
-  private Map<Network, Boolean> reportedNetworkConnectivity = new HashMap<>();
-  private Map<Network, NetworkCapabilities> networkCapabilitiesMap = new HashMap<>();
-  private String captivePortalServerUrl = "http://10.0.0.2";
-  private final Map<Network, LinkProperties> linkPropertiesMap = new HashMap<>();
-  private final Map<Network, ProxyInfo> proxyInfoMap = new HashMap<>();
+  private static Map<Network, Boolean> reportedNetworkConnectivity = new HashMap<>();
+  private static Map<Network, NetworkCapabilities> networkCapabilitiesMap = new HashMap<>();
+  private static String captivePortalServerUrl = "http://10.0.0.2";
+  private static final Map<Network, LinkProperties> linkPropertiesMap = new HashMap<>();
+  private static final Map<Network, ProxyInfo> proxyInfoMap = new HashMap<>();
 
-  public ShadowConnectivityManager() {
+  static {
+    resetNetworkDefaults();
+  }
+
+  private static void resetNetworkDefaults() {
+    networkTypeToNetworkInfo.clear();
     NetworkInfo wifi =
         ShadowNetworkInfo.newInstance(
             NetworkInfo.DetailedState.DISCONNECTED, ConnectivityManager.TYPE_WIFI, 0, true, false);
@@ -69,10 +76,12 @@ public class ShadowConnectivityManager {
             true);
     networkTypeToNetworkInfo.put(ConnectivityManager.TYPE_MOBILE, mobile);
 
-    this.activeNetworkInfo = mobile;
+    activeNetworkInfo = mobile;
 
+    netIdToNetwork.clear();
     netIdToNetwork.put(NET_ID_WIFI, ShadowNetwork.newInstance(NET_ID_WIFI));
     netIdToNetwork.put(NET_ID_MOBILE, ShadowNetwork.newInstance(NET_ID_MOBILE));
+    netIdToNetworkInfo.clear();
     netIdToNetworkInfo.put(NET_ID_WIFI, wifi);
     netIdToNetworkInfo.put(NET_ID_MOBILE, mobile);
 
@@ -81,9 +90,30 @@ public class ShadowConnectivityManager {
     NetworkCapabilities mobileNetworkCapabilities = ShadowNetworkCapabilities.newInstance();
     shadowOf(mobileNetworkCapabilities).addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
 
+    networkCapabilitiesMap.clear();
     networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_WIFI), wifiNetworkCapabilities);
     networkCapabilitiesMap.put(netIdToNetwork.get(NET_ID_MOBILE), mobileNetworkCapabilities);
+
+    backgroundDataSetting = false;
+    networkCallbacksEnabled = true;
+    restrictBackgroundStatus = ConnectivityManager.RESTRICT_BACKGROUND_STATUS_DISABLED;
+    networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;
+
     defaultNetworkActive = true;
+
+    networkCallbacks.clear();
+    networkCallbackPendingIntents.clear();
+    onNetworkActiveListeners.clear();
+    reportedNetworkConnectivity.clear();
+    linkPropertiesMap.clear();
+    proxyInfoMap.clear();
+    processBoundNetwork = null;
+    captivePortalServerUrl = "http://10.0.0.2";
+  }
+
+  @Resetter
+  public static void reset() {
+    resetNetworkDefaults();
   }
 
   /**
@@ -209,8 +239,8 @@ public class ShadowConnectivityManager {
    */
   @Implementation(minSdk = M)
   protected Network getActiveNetwork() {
-    if (defaultNetworkActive) {
-      return netIdToNetwork.get(getActiveNetworkInfo().getType());
+    if (defaultNetworkActive && activeNetworkInfo != null) {
+      return netIdToNetwork.get(activeNetworkInfo.getType());
     }
     return null;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProvider.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProvider.java
index a92f53015..b095291e3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProvider.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentProvider.java
@@ -11,15 +11,15 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link ContentProvider}. */
-@Implements(value = ContentProvider.class, looseSignatures = true)
+@Implements(value = ContentProvider.class)
 public class ShadowContentProvider {
   @RealObject private ContentProvider realContentProvider;
 
   private String callingPackage;
 
   @Implementation(minSdk = Q, maxSdk = Q)
-  public Object setCallingPackage(Object callingPackage) {
-    this.callingPackage = (String) callingPackage;
+  public String setCallingPackage(String callingPackage) {
+    this.callingPackage = callingPackage;
     return callingPackage;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
index 7c8869b3b..2213fac12 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContentResolver.java
@@ -6,6 +6,7 @@ import static android.content.ContentResolver.QUERY_ARG_SQL_SORT_ORDER;
 import static android.content.ContentResolver.SCHEME_ANDROID_RESOURCE;
 import static android.content.ContentResolver.SCHEME_CONTENT;
 import static android.content.ContentResolver.SCHEME_FILE;
+import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -146,11 +147,13 @@ public class ShadowContentResolver {
     public final Uri uri;
     public final boolean syncToNetwork;
     public final ContentObserver observer;
+    public final int flags;
 
-    public NotifiedUri(Uri uri, ContentObserver observer, boolean syncToNetwork) {
+    public NotifiedUri(Uri uri, ContentObserver observer, int flags) {
       this.uri = uri;
-      this.syncToNetwork = syncToNetwork;
+      this.syncToNetwork = flags == ContentResolver.NOTIFY_SYNC_TO_NETWORK;
       this.observer = observer;
+      this.flags = flags;
     }
   }
 
@@ -489,9 +492,9 @@ public class ShadowContentResolver {
     }
   }
 
-  @Implementation
-  protected void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
-    notifiedUris.add(new NotifiedUri(uri, observer, syncToNetwork));
+  @Implementation(minSdk = N)
+  protected void notifyChange(Uri uri, ContentObserver observer, int flags) {
+    notifiedUris.add(new NotifiedUri(uri, observer, flags));
 
     for (ContentObserverEntry entry : contentObservers) {
       if (entry.matches(uri) && entry.observer != observer) {
@@ -503,6 +506,11 @@ public class ShadowContentResolver {
     }
   }
 
+  @Implementation
+  protected void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
+    notifyChange(uri, observer, syncToNetwork ? ContentResolver.NOTIFY_SYNC_TO_NETWORK : 0);
+  }
+
   @Implementation
   protected void notifyChange(Uri uri, ContentObserver observer) {
     notifyChange(uri, observer, false);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
index f00290050..ccc200541 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowContextHubManager.java
@@ -1,6 +1,5 @@
 package org.robolectric.shadows;
 
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.app.PendingIntent;
@@ -21,6 +20,7 @@ import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
+import com.google.common.util.concurrent.MoreExecutors;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -30,6 +30,7 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -38,27 +39,24 @@ import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowContextHubClient.ContextHubClientReflector;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
-import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link ContextHubManager}. */
-@Implements(
-    value = ContextHubManager.class,
-    minSdk = VERSION_CODES.N,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+@Implements(value = ContextHubManager.class, minSdk = VERSION_CODES.N, isInAndroidSdk = false)
 public class ShadowContextHubManager {
   private static final List<ContextHubInfo> contextHubInfoList = new ArrayList<>();
   private static final List<ContextHubClient> contextHubClientWithPendingIntentList =
       new ArrayList<>();
-
-  private final Map<Integer, NanoAppInstanceInfo> nanoAppUidToInfo = new ConcurrentHashMap<>();
-  private final Multimap<ContextHubInfo, Integer> contextHubToNanoappUid =
+  private static final Map<Integer, NanoAppInstanceInfo> nanoAppUidToInfo =
+      new ConcurrentHashMap<>();
+  private static final Multimap<ContextHubInfo, Integer> contextHubToNanoappUid =
       Multimaps.synchronizedMultimap(HashMultimap.<ContextHubInfo, Integer>create());
-  private final HashMultimap<String, ContextHubClient> attributionTagToClientMap =
+  private static final Map<Long, ContextHubInfo> nanoAppIdToInfo = new ConcurrentHashMap<>();
+  private static final HashMultimap<String, ContextHubClient> attributionTagToClientMap =
       HashMultimap.create();
-  private final Map<ContextHubClient, ContextHubClientCallbackDetails> contextHubClientCallbacks =
-      new HashMap<>();
+  private static final Map<ContextHubClient, ContextHubClientCallbackDetails>
+      contextHubClientCallbacks = new HashMap<>();
 
   static {
     contextHubInfoList.add(new ContextHubInfo());
@@ -70,6 +68,7 @@ public class ShadowContextHubManager {
     NanoAppInstanceInfo instanceInfo =
         createInstanceInfo(info, nanoAppUid, nanoAppId, nanoAppVersion);
     nanoAppUidToInfo.put(nanoAppUid, instanceInfo);
+    nanoAppIdToInfo.put(nanoAppId, info);
   }
 
   /** Creates and returns a {@link NanoAppInstanceInfo}. */
@@ -101,9 +100,10 @@ public class ShadowContextHubManager {
 
   @Implementation(minSdk = VERSION_CODES.P)
   @HiddenApi
-  protected Object /* ContextHubClient */ createClient(
-      Object /* ContextHubInfo */ contextHubInfo,
-      Object /* ContextHubClientCallback */ contextHubClientCallback) {
+  protected @ClassName("android.hardware.location.ContextHubClient") Object createClient(
+      @ClassName("android.hardware.location.ContextHubInfo") Object contextHubInfo,
+      @ClassName("android.hardware.location.ContextHubClientCallback") Object callback) {
+
     ContextHubClient client;
 
     if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
@@ -114,32 +114,34 @@ public class ShadowContextHubManager {
       client = reflector(ContextHubClientReflector.class).newContextHubClient();
     }
 
-    if (contextHubClientCallback != null) {
+    if (callback != null) {
       contextHubClientCallbacks.put(
           client,
           ContextHubClientCallbackDetails.create(
-              (ContextHubClientCallback) contextHubClientCallback, directExecutor()));
+              (ContextHubClientCallback) callback, MoreExecutors.directExecutor()));
     }
     return client;
   }
 
   @Implementation(minSdk = VERSION_CODES.P)
   @HiddenApi
-  protected Object /* ContextHubClient */ createClient(
-      ContextHubInfo contextHubInfo,
-      ContextHubClientCallback contextHubClientCallback,
+  protected @ClassName("android.hardware.location.ContextHubClient") Object createClient(
+      @ClassName("android.hardware.location.ContextHubInfo") Object contextHubInfo,
+      @ClassName("android.hardware.location.ContextHubClientCallback") Object callback,
       Executor executor) {
     ContextHubClient client;
     if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
       client =
-          reflector(ContextHubClientReflector.class).newContextHubClient(contextHubInfo, false);
+          reflector(ContextHubClientReflector.class)
+              .newContextHubClient((ContextHubInfo) contextHubInfo, false);
     } else {
       client = reflector(ContextHubClientReflector.class).newContextHubClient();
     }
 
-    if (contextHubClientCallback != null) {
+    if (callback != null) {
       contextHubClientCallbacks.put(
-          client, ContextHubClientCallbackDetails.create(contextHubClientCallback, executor));
+          client,
+          ContextHubClientCallbackDetails.create((ContextHubClientCallback) callback, executor));
     }
 
     return client;
@@ -147,12 +149,15 @@ public class ShadowContextHubManager {
 
   @Implementation(minSdk = VERSION_CODES.Q)
   @HiddenApi
-  protected Object /* ContextHubClient */ createClient(
-      ContextHubInfo contextHubInfo, PendingIntent pendingIntent, long nanoAppId) {
+  protected @ClassName("android.hardware.location.ContextHubClient") Object createClient(
+      @ClassName("android.hardware.location.ContextHubInfo") Object contextHubInfo,
+      PendingIntent pendingIntent,
+      long nanoAppId) {
     ContextHubClient client;
     if (Build.VERSION.SDK_INT >= VERSION_CODES.Q) {
       client =
-          reflector(ContextHubClientReflector.class).newContextHubClient(contextHubInfo, false);
+          reflector(ContextHubClientReflector.class)
+              .newContextHubClient((ContextHubInfo) contextHubInfo, false);
     } else {
       client = reflector(ContextHubClientReflector.class).newContextHubClient();
     }
@@ -162,11 +167,11 @@ public class ShadowContextHubManager {
 
   @Implementation(minSdk = VERSION_CODES.S)
   @HiddenApi
-  protected Object /* ContextHubClient */ createClient(
-      Object /* Context */ context,
-      Object /* ContextHubInfo */ contextHubInfo,
-      Object /* Executor */ executor,
-      Object /* ContextHubClientCallback */ contextHubClientCallback) {
+  protected @ClassName("android.hardware.location.ContextHubClient") Object createClient(
+      Context context,
+      @ClassName("android.hardware.location.ContextHubInfo") Object contextHubInfo,
+      Executor executor,
+      @ClassName("android.hardware.location.ContextHubClientCallback") Object callback) {
     ContextHubClient client =
         reflector(ContextHubClientReflector.class)
             .newContextHubClient((ContextHubInfo) contextHubInfo, false);
@@ -174,28 +179,46 @@ public class ShadowContextHubManager {
       attributionTagToClientMap.put(((Context) context).getAttributionTag(), client);
     }
 
-    if (contextHubClientCallback != null) {
+    if (callback != null) {
       contextHubClientCallbacks.put(
           client,
-          ContextHubClientCallbackDetails.create(
-              (ContextHubClientCallback) contextHubClientCallback, (Executor) executor));
+          ContextHubClientCallbackDetails.create((ContextHubClientCallback) callback, executor));
     }
     return client;
   }
 
   @Implementation(minSdk = VERSION_CODES.S)
   @HiddenApi
-  protected Object /* ContextHubClient */ createClient(
-      Context context, ContextHubInfo hubInfo, PendingIntent pendingIntent, long nanoAppId) {
+  protected @ClassName("android.hardware.location.ContextHubClient") Object createClient(
+      Context context, ContextHubInfo contextHubInfo, PendingIntent pendingIntent, long nanoAppId) {
     ContextHubClient client =
         Shadow.newInstance(
             ContextHubClient.class,
             new Class<?>[] {ContextHubInfo.class, Boolean.TYPE},
-            new Object[] {hubInfo, false});
+            new Object[] {contextHubInfo, false});
     contextHubClientWithPendingIntentList.add(client);
     return client;
   }
 
+  @Implementation(minSdk = VERSION_CODES.S)
+  @HiddenApi
+  protected @ClassName("android.hardware.location.ContextHubTransaction<java.lang.Void>") Object
+      unloadNanoApp(ContextHubInfo contextHubInfo, long nanoAppId) {
+    nanoAppIdToInfo.remove(nanoAppId);
+    @SuppressWarnings("unchecked")
+    ContextHubTransaction<Void> transaction =
+        ReflectionHelpers.callConstructor(
+            ContextHubTransaction.class,
+            ClassParameter.from(int.class, ContextHubTransaction.TYPE_UNLOAD_NANOAPP));
+
+    // @SuppressWarnings("unchecked")
+    ContextHubTransaction.Response<List<NanoAppState>> response =
+        reflector(ReflectorContextHubTransactionResponse.class)
+            .create(ContextHubTransaction.RESULT_SUCCESS, null);
+    reflector(ReflectorContextHubTransaction.class, transaction).setResponse(response);
+    return transaction;
+  }
+
   @Nullable
   public List<ContextHubClient> getClientsWithAttributionTag(String attributionTag) {
     return ImmutableList.copyOf(attributionTagToClientMap.get(attributionTag));
@@ -305,20 +328,32 @@ public class ShadowContextHubManager {
     }
   }
 
+  /** Returns true if the nanoapp is loaded. */
+  public boolean nanoAppIsLoaded(long nanoAppId) {
+    return nanoAppIdToInfo.containsKey(nanoAppId);
+  }
+
   @Resetter
   public static void clearContextHubClientWithPendingIntentList() {
     contextHubClientWithPendingIntentList.clear();
+    nanoAppUidToInfo.clear();
+    contextHubToNanoappUid.clear();
+    attributionTagToClientMap.clear();
+    contextHubClientCallbacks.clear();
+    nanoAppIdToInfo.clear();
   }
 
   @Implementation(minSdk = VERSION_CODES.P)
   @HiddenApi
-  protected Object queryNanoApps(ContextHubInfo hubInfo) {
+  protected @ClassName(
+      "android.hardware.location.ContextHubTransaction<java.util.List<android.hardware.location.NanoAppState>>")
+  Object queryNanoApps(ContextHubInfo contextHubInfo) {
     @SuppressWarnings("unchecked")
     ContextHubTransaction<List<NanoAppState>> transaction =
         ReflectionHelpers.callConstructor(
             ContextHubTransaction.class,
             ClassParameter.from(int.class, ContextHubTransaction.TYPE_QUERY_NANOAPPS));
-    Collection<Integer> uids = contextHubToNanoappUid.get(hubInfo);
+    Collection<Integer> uids = contextHubToNanoappUid.get(contextHubInfo);
     List<NanoAppState> nanoAppStates = new ArrayList<>();
 
     for (Integer uid : uids) {
@@ -328,13 +363,9 @@ public class ShadowContextHubManager {
             new NanoAppState(info.getAppId(), info.getAppVersion(), true /* enabled */));
       }
     }
-    @SuppressWarnings("unchecked")
     ContextHubTransaction.Response<List<NanoAppState>> response =
-        ReflectionHelpers.newInstance(ContextHubTransaction.Response.class);
-    ReflectorContextHubTransactionResponse reflectedResponse =
-        reflector(ReflectorContextHubTransactionResponse.class, response);
-    reflectedResponse.setResult(ContextHubTransaction.RESULT_SUCCESS);
-    reflectedResponse.setContents(nanoAppStates);
+        reflector(ReflectorContextHubTransactionResponse.class)
+            .create(ContextHubTransaction.RESULT_SUCCESS, nanoAppStates);
     reflector(ReflectorContextHubTransaction.class, transaction).setResponse(response);
     return transaction;
   }
@@ -403,10 +434,8 @@ public class ShadowContextHubManager {
   /** Accessor interface for {@link ContextHubTransaction.Response}'s internals. */
   @ForType(ContextHubTransaction.Response.class)
   private interface ReflectorContextHubTransactionResponse {
-    @Accessor("mResult")
-    void setResult(int result);
-
-    @Accessor("mContents")
-    void setContents(List<NanoAppState> contents);
+    @Constructor
+    ContextHubTransaction.Response<List<NanoAppState>> create(int result, Object contents);
   }
 }
+
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
index f41730af2..b52bec927 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowCrossProfileApps.java
@@ -40,6 +40,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
@@ -48,16 +49,26 @@ import org.robolectric.util.reflector.ForType;
 public class ShadowCrossProfileApps {
 
   @RealObject private CrossProfileApps realObject;
-  private final Set<UserHandle> targetUserProfiles = new LinkedHashSet<>();
-  private final List<StartedMainActivity> startedMainActivities = new ArrayList<>();
-  private final List<StartedActivity> startedActivities =
+
+  private static final Set<UserHandle> targetUserProfiles = new LinkedHashSet<>();
+  private static final List<StartedMainActivity> startedMainActivities = new ArrayList<>();
+  private static final List<StartedActivity> startedActivities =
       Collections.synchronizedList(new ArrayList<>());
 
   // Whether the current application has the interact across profile AppOps.
-  private volatile int canInteractAcrossProfileAppOps = AppOpsManager.MODE_ERRORED;
+  private static volatile int canInteractAcrossProfileAppOps = AppOpsManager.MODE_ERRORED;
 
   // Whether the current application has requested the interact across profile permission.
-  private volatile boolean hasRequestedInteractAcrossProfiles = false;
+  private static volatile boolean hasRequestedInteractAcrossProfiles = false;
+
+  @Resetter
+  public static void reset() {
+    targetUserProfiles.clear();
+    startedMainActivities.clear();
+    startedActivities.clear();
+    canInteractAcrossProfileAppOps = AppOpsManager.MODE_ERRORED;
+    hasRequestedInteractAcrossProfiles = false;
+  }
 
   /**
    * Returns a list of {@link UserHandle}s currently accessible. This list is populated from calls
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
index 34bb3c9a6..355e3664a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDevicePolicyManager.java
@@ -17,6 +17,7 @@ import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.Shadows.shadowOf;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.accounts.Account;
 import android.annotation.NonNull;
@@ -33,6 +34,7 @@ import android.app.admin.DevicePolicyManager.PasswordComplexity;
 import android.app.admin.DevicePolicyManager.UserProvisioningState;
 import android.app.admin.DevicePolicyState;
 import android.app.admin.IDevicePolicyManager;
+import android.app.admin.SystemUpdateInfo;
 import android.app.admin.SystemUpdatePolicy;
 import android.content.ComponentName;
 import android.content.Context;
@@ -64,13 +66,18 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.U;
 
-@Implements(value = DevicePolicyManager.class, looseSignatures = true)
+/** Shadow for {@link DevicePolicyManager}. */
+@Implements(DevicePolicyManager.class)
 @SuppressLint("NewApi")
 public class ShadowDevicePolicyManager {
   /**
@@ -78,83 +85,146 @@ public class ShadowDevicePolicyManager {
    *     https://developer.android.com/reference/android/app/admin/DevicePolicyManager.html#setOrganizationColor(android.content.ComponentName,
    *     int)
    */
-  private static final int DEFAULT_ORGANIZATION_COLOR = 0xFF008080; // teal
-
-  private ComponentName deviceOwner;
-  private ComponentName profileOwner;
-  private List<ComponentName> deviceAdmins = new ArrayList<>();
-  private Map<Integer, String> profileOwnerNamesMap = new HashMap<>();
-  private List<String> permittedAccessibilityServices = new ArrayList<>();
-  private List<String> permittedInputMethods = new ArrayList<>();
-  private Map<String, Bundle> applicationRestrictionsMap = new HashMap<>();
-  private CharSequence organizationName;
-  private int organizationColor;
-  private boolean isAutoTimeEnabled;
-  private boolean isAutoTimeRequired;
-  private boolean isAutoTimeZoneEnabled;
-  private String timeZone;
-  private int keyguardDisabledFeatures;
-  private String lastSetPassword;
-  private int requiredPasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
-
-  private int passwordMinimumLength;
-  private int passwordMinimumLetters = 1;
-  private int passwordMinimumLowerCase;
-  private int passwordMinimumUpperCase;
-  private int passwordMinimumNonLetter;
-  private int passwordMinimumNumeric = 1;
-  private int passwordMinimumSymbols = 1;
-  private int passwordHistoryLength = 0;
-  private long passwordExpiration = 0;
-  private long passwordExpirationTimeout = 0;
-  private int maximumFailedPasswordsForWipe = 0;
-  private long maximumTimeToLock = 0;
-  private boolean cameraDisabled;
-  private boolean isActivePasswordSufficient;
-  private boolean isUniqueDeviceAttestationSupported;
-  @PasswordComplexity private int passwordComplexity;
-
-  private int wipeCalled;
-  private int storageEncryptionStatus;
-  private int permissionPolicy;
-  private boolean storageEncryptionRequested;
-  private final Set<String> wasHiddenPackages = new HashSet<>();
-  private final Set<String> accountTypesWithManagementDisabled = new HashSet<>();
-  private final Set<String> systemAppsEnabled = new HashSet<>();
-  private final Set<String> uninstallBlockedPackages = new HashSet<>();
-  private final Set<String> suspendedPackages = new HashSet<>();
-  private final Set<String> affiliationIds = new HashSet<>();
   private final Map<PackageAndPermission, Boolean> appPermissionGrantedMap = new HashMap<>();
+
   private final Map<PackageAndPermission, Integer> appPermissionGrantStateMap = new HashMap<>();
-  private final Map<String, Set<String>> delegatedScopePackagesMap = new HashMap<>();
   private final Map<ComponentName, byte[]> passwordResetTokens = new HashMap<>();
-  private final Map<ComponentName, Set<Integer>> adminPolicyGrantedMap = new HashMap<>();
-  private final Map<ComponentName, CharSequence> shortSupportMessageMap = new HashMap<>();
-  private final Map<ComponentName, CharSequence> longSupportMessageMap = new HashMap<>();
-  private final Set<ComponentName> componentsWithActivatedTokens = new HashSet<>();
+  private final List<ComponentName> deviceAdmins = new ArrayList<>();
+  private final Map<Integer, String> profileOwnerNamesMap = new HashMap<>();
+  private final Map<String, Bundle> applicationRestrictionsMap = new HashMap<>();
+  private List<String> permittedAccessibilityServices = new ArrayList<>();
+  private List<String> permittedInputMethods = new ArrayList<>();
   private Collection<String> packagesToFailForSetApplicationHidden = Collections.emptySet();
-  private int lockTaskFeatures;
-  private final List<String> lockTaskPackages = new ArrayList<>();
   private Context context;
-  private ApplicationPackageManager applicationPackageManager;
-  private SystemUpdatePolicy policy;
   private List<UserHandle> bindDeviceAdminTargetUsers = ImmutableList.of();
-  private boolean isDeviceProvisioned;
-  private boolean isDeviceProvisioningConfigApplied;
-  private volatile boolean organizationOwnedDeviceWithManagedProfile = false;
-  private int nearbyNotificationStreamingPolicy =
+  private @RealObject DevicePolicyManager realObject;
+
+  private static final int DEFAULT_ORGANIZATION_COLOR = 0xFF008080; // teal
+  private static final Set<String> wasHiddenPackages = new HashSet<>();
+  private static final Set<String> accountTypesWithManagementDisabled = new HashSet<>();
+  private static final Set<String> systemAppsEnabled = new HashSet<>();
+  private static final Set<String> uninstallBlockedPackages = new HashSet<>();
+  private static final Set<String> suspendedPackages = new HashSet<>();
+  private static final Set<String> affiliationIds = new HashSet<>();
+  private static final Map<String, Set<String>> delegatedScopePackagesMap = new HashMap<>();
+  private static final Map<ComponentName, Set<Integer>> adminPolicyGrantedMap = new HashMap<>();
+  private static final Map<ComponentName, CharSequence> shortSupportMessageMap = new HashMap<>();
+  private static final Map<ComponentName, CharSequence> longSupportMessageMap = new HashMap<>();
+  private static final Set<ComponentName> componentsWithActivatedTokens = new HashSet<>();
+  private static final List<String> lockTaskPackages = new ArrayList<>();
+  private static final Map<UserHandle, Account> finalizedWorkProfileProvisioningMap =
+      new HashMap<>();
+  private static final Map<Integer, Integer> userProvisioningStatesMap = new HashMap<>();
+  private static ComponentName deviceOwner;
+  private static ComponentName profileOwner;
+  private static CharSequence organizationName;
+  private static int organizationColor;
+  private static boolean isAutoTimeEnabled;
+  private static boolean isAutoTimeRequired;
+  private static boolean isAutoTimeZoneEnabled;
+  private static String timeZone;
+  private static int keyguardDisabledFeatures;
+  private static String lastSetPassword;
+  private static int requiredPasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
+  private static int passwordMinimumLength;
+  private static int passwordMinimumLetters = 1;
+  private static int passwordMinimumLowerCase;
+  private static int passwordMinimumUpperCase;
+  private static int passwordMinimumNonLetter;
+  private static int passwordMinimumNumeric = 1;
+  private static int passwordMinimumSymbols = 1;
+  private static int passwordHistoryLength = 0;
+  private static long passwordExpiration = 0;
+  private static long passwordExpirationTimeout = 0;
+  private static int maximumFailedPasswordsForWipe = 0;
+  private static long maximumTimeToLock = 0;
+  private static boolean cameraDisabled;
+  private static boolean isActivePasswordSufficient;
+  private static boolean isUniqueDeviceAttestationSupported;
+  @PasswordComplexity private static int passwordComplexity;
+  private static int wipeCalled;
+  private static int storageEncryptionStatus;
+  private static int permissionPolicy;
+  private static boolean storageEncryptionRequested;
+  private static int lockTaskFeatures;
+  private static ApplicationPackageManager applicationPackageManager;
+  private static SystemUpdatePolicy policy;
+  private static boolean isDeviceProvisioned;
+  private static boolean isDeviceProvisioningConfigApplied;
+  private static volatile boolean organizationOwnedDeviceWithManagedProfile = false;
+  private static int nearbyNotificationStreamingPolicy =
       DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
-  private int nearbyAppStreamingPolicy =
+  private static int nearbyAppStreamingPolicy =
       DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
-  private boolean isUsbDataSignalingEnabled = true;
-  @Nullable private String devicePolicyManagementRoleHolderPackage;
-  private final Map<UserHandle, Account> finalizedWorkProfileProvisioningMap = new HashMap<>();
-  private List<UserHandle> policyManagedProfiles = new ArrayList<>();
-  private final Map<Integer, Integer> userProvisioningStatesMap = new HashMap<>();
-  @Nullable private PersistableBundle lastTransferOwnershipBundle;
-
-  private Object /* DevicePolicyState */ devicePolicyState;
-  private @RealObject DevicePolicyManager realObject;
+  private static boolean isUsbDataSignalingEnabled = true;
+  @Nullable private static String devicePolicyManagementRoleHolderPackage;
+  private static List<UserHandle> policyManagedProfiles = new ArrayList<>();
+  @Nullable private static PersistableBundle lastTransferOwnershipBundle;
+  private static Object /* DevicePolicyState */ devicePolicyState;
+  @Nullable private static SystemUpdateInfo systemUpdateInfo;
+
+  @Resetter
+  public static void reset() {
+    deviceOwner = null;
+    profileOwner = null;
+    organizationName = null;
+    organizationColor = DEFAULT_ORGANIZATION_COLOR;
+    isAutoTimeEnabled = false;
+    isAutoTimeRequired = false;
+    isAutoTimeZoneEnabled = false;
+    timeZone = null;
+    keyguardDisabledFeatures = 0;
+    lastSetPassword = null;
+    requiredPasswordQuality = DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
+
+    passwordMinimumLength = 0;
+    passwordMinimumLetters = 1;
+    passwordMinimumLowerCase = 0;
+    passwordMinimumUpperCase = 0;
+    passwordMinimumNonLetter = 0;
+    passwordMinimumNumeric = 1;
+    passwordMinimumSymbols = 1;
+    passwordHistoryLength = 0;
+    passwordExpiration = 0;
+    passwordExpirationTimeout = 0;
+    maximumFailedPasswordsForWipe = 0;
+    maximumTimeToLock = 0;
+    cameraDisabled = false;
+    isActivePasswordSufficient = false;
+    isUniqueDeviceAttestationSupported = false;
+    passwordComplexity = 0;
+
+    wipeCalled = 0;
+    storageEncryptionStatus = DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
+    permissionPolicy = 0;
+    storageEncryptionRequested = false;
+    wasHiddenPackages.clear();
+    accountTypesWithManagementDisabled.clear();
+    systemAppsEnabled.clear();
+    uninstallBlockedPackages.clear();
+    suspendedPackages.clear();
+    affiliationIds.clear();
+    delegatedScopePackagesMap.clear();
+    adminPolicyGrantedMap.clear();
+    shortSupportMessageMap.clear();
+    longSupportMessageMap.clear();
+    componentsWithActivatedTokens.clear();
+    lockTaskFeatures = 0;
+    lockTaskPackages.clear();
+    policy = null;
+    isDeviceProvisioned = false;
+    isDeviceProvisioningConfigApplied = false;
+    organizationOwnedDeviceWithManagedProfile = false;
+    nearbyNotificationStreamingPolicy =
+        DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
+    nearbyAppStreamingPolicy = DevicePolicyManager.NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
+    isUsbDataSignalingEnabled = true;
+    devicePolicyManagementRoleHolderPackage = null;
+    finalizedWorkProfileProvisioningMap.clear();
+    policyManagedProfiles = new ArrayList<>();
+    userProvisioningStatesMap.clear();
+    lastTransferOwnershipBundle = null;
+  }
 
   private static class PackageAndPermission {
 
@@ -1582,7 +1652,7 @@ public class ShadowDevicePolicyManager {
 
   /** Return a stub value set by {@link #setDevicePolicyState(DevicePolicyState policyState)} */
   @Implementation(minSdk = U.SDK_INT)
-  protected Object getDevicePolicyState() {
+  protected @ClassName("android.app.admin.DevicePolicyState") Object getDevicePolicyState() {
     return devicePolicyState;
   }
 
@@ -1593,4 +1663,38 @@ public class ShadowDevicePolicyManager {
   public void setDevicePolicyState(Object policyState) {
     devicePolicyState = policyState;
   }
+
+  /**
+   * Set the {@link SystemUpdateInfo} to be returned by {@link
+   * DevicePolicyManager#getPendingSystemUpdate(ComponentName)}.
+   */
+  public void setPendingSystemUpdate(@Nullable SystemUpdateInfo info) {
+    systemUpdateInfo = info;
+  }
+
+  @Implementation(minSdk = O)
+  protected void notifyPendingSystemUpdate(long updateReceivedTime) {
+    systemUpdateInfo = reflector(SystemUpdateInfoReflector.class).of(updateReceivedTime);
+  }
+
+  @Implementation(minSdk = O)
+  protected void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch) {
+    systemUpdateInfo =
+        reflector(SystemUpdateInfoReflector.class).of(updateReceivedTime, isSecurityPatch);
+  }
+
+  @Implementation(minSdk = O)
+  @Nullable
+  protected SystemUpdateInfo getPendingSystemUpdate(@Nullable ComponentName admin) {
+    return systemUpdateInfo;
+  }
+
+  @ForType(SystemUpdateInfo.class)
+  interface SystemUpdateInfoReflector {
+    @Static
+    SystemUpdateInfo of(long updateReceivedTime);
+
+    @Static
+    SystemUpdateInfo of(long updateReceivedTime, boolean isSecurityPatch);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
index 4cb4b94ca..c42647082 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayEventReceiver.java
@@ -19,17 +19,20 @@ import java.lang.ref.WeakReference;
 import java.lang.reflect.Array;
 import java.time.Duration;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.res.android.NativeObjRegistry;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /**
@@ -45,10 +48,7 @@ import org.robolectric.versioning.AndroidVersions.U;
  * the next frame will only trigger when the clock is advance manually or via the {@link
  * ShadowLooper}.
  */
-@Implements(
-    className = "android.view.DisplayEventReceiver",
-    isInAndroidSdk = false,
-    looseSignatures = true)
+@Implements(className = "android.view.DisplayEventReceiver", isInAndroidSdk = false)
 public class ShadowDisplayEventReceiver {
 
   private static NativeObjRegistry<NativeDisplayEventReceiver> nativeObjRegistry =
@@ -140,6 +140,16 @@ public class ShadowDisplayEventReceiver {
     }
   }
 
+  void resetState() {
+    if (realReceiver.getClass().getName().contains("FrameDisplayEventReceiver")) {
+      FrameDisplayEventReceiverReflector frameReflector =
+          reflector(FrameDisplayEventReceiverReflector.class, realReceiver);
+      frameReflector.setFrame(0);
+      frameReflector.setHavePendingVsync(false);
+      frameReflector.setTimestampNanos(0);
+    }
+  }
+
   /**
    * A simulation of the native code that provides synchronization with the display hardware frames
    * (aka vsync), that attempts to provide relatively accurate behavior, while adjusting for
@@ -164,7 +174,7 @@ public class ShadowDisplayEventReceiver {
     public NativeDisplayEventReceiver(WeakReference<DisplayEventReceiver> receiverRef) {
       this.receiverRef = receiverRef;
       // register a clock listener for the async mode
-      ShadowPausedSystemClock.addListener(clockListener);
+      ShadowPausedSystemClock.addStaticListener(clockListener);
     }
 
     private void onClockAdvanced() {
@@ -206,7 +216,8 @@ public class ShadowDisplayEventReceiver {
   }
 
   @Implementation(minSdk = TIRAMISU)
-  protected Object getLatestVsyncEventData() {
+  protected @ClassName("android.view.DisplayEventReceiver$VsyncEventData") Object
+      getLatestVsyncEventData() {
     return newVsyncEventData();
   }
 
@@ -232,11 +243,28 @@ public class ShadowDisplayEventReceiver {
         return vsyncEventDataReflector.newVsyncEventData(
             timelineArray, /* preferredFrameTimelineIndex= */ 0, /* frameInterval= */ 1);
       } else {
-        return vsyncEventDataReflector.newVsyncEventData(
-            timelineArray,
-            /* preferredFrameTimelineIndex= */ 0,
-            timelineArrayLength,
-            /* frameInterval= */ 1);
+        boolean baklavaConstructor =
+            ReflectionHelpers.hasConstructor(
+                DisplayEventReceiver.VsyncEventData.class,
+                DisplayEventReceiver.VsyncEventData.FrameTimeline[].class,
+                int.class,
+                int.class,
+                long.class,
+                int.class);
+        if (RuntimeEnvironment.getApiLevel() < Baklava.SDK_INT || !baklavaConstructor) {
+          return vsyncEventDataReflector.newVsyncEventData(
+              timelineArray,
+              /* preferredFrameTimelineIndex= */ 0,
+              timelineArrayLength,
+              /* frameInterval= */ 1);
+        } else {
+          return vsyncEventDataReflector.newVsyncEventData(
+              timelineArray,
+              /* preferredFrameTimelineIndex= */ 0,
+              timelineArrayLength,
+              /* frameInterval= */ 1,
+              /* numberQueuedBuffers= */ 0);
+        }
       }
     } catch (ClassNotFoundException e) {
       throw new LinkageError("Unable to construct VsyncEventData", e);
@@ -269,6 +297,18 @@ public class ShadowDisplayEventReceiver {
     long getReceiverPtr();
   }
 
+  @ForType(className = "android.view.Choreographer$FrameDisplayEventReceiver")
+  interface FrameDisplayEventReceiverReflector {
+    @Accessor("mHavePendingVsync")
+    void setHavePendingVsync(boolean val);
+
+    @Accessor("mTimestampNanos")
+    void setTimestampNanos(long val);
+
+    @Accessor("mFrame")
+    void setFrame(int val);
+  }
+
   @ForType(className = "android.view.DisplayEventReceiver$VsyncEventData")
   interface VsyncEventDataReflector {
     @Constructor
@@ -288,6 +328,15 @@ public class ShadowDisplayEventReceiver {
         int preferredFrameTimelineIndex,
         int timelineArrayLength,
         long frameInterval);
+
+    @Constructor
+    Object newVsyncEventData(
+        @WithType("[Landroid.view.DisplayEventReceiver$VsyncEventData$FrameTimeline;")
+            Object frameTimelineArray,
+        int preferredFrameTimelineIndex,
+        int timelineArrayLength,
+        long frameInterval,
+        int numberQueuedBuffers);
   }
 
   @ForType(className = "android.view.DisplayEventReceiver$VsyncEventData$FrameTimeline")
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
index c86ecb274..75b8c3843 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManager.java
@@ -27,6 +27,7 @@ import java.util.List;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.Bootstrap;
 import org.robolectric.android.internal.DisplayConfig;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -44,7 +45,7 @@ import org.robolectric.versioning.AndroidVersions.V;
  * For tests, display properties may be changed and devices may be added or removed
  * programmatically.
  */
-@Implements(value = DisplayManager.class, looseSignatures = true)
+@Implements(value = DisplayManager.class)
 public class ShadowDisplayManager {
 
   @RealObject private DisplayManager realDisplayManager;
@@ -348,14 +349,17 @@ public class ShadowDisplayManager {
 
   @Implementation(minSdk = P)
   @HiddenApi
-  protected void setBrightnessConfiguration(Object config) {
+  protected void setBrightnessConfiguration(
+      @ClassName("android.hardware.display.BrightnessConfiguration") Object config) {
     setBrightnessConfigurationForUser(config, 0, context.getPackageName());
   }
 
   @Implementation(minSdk = P)
   @HiddenApi
   protected void setBrightnessConfigurationForUser(
-      Object config, Object userId, Object packageName) {
+      @ClassName("android.hardware.display.BrightnessConfiguration") Object config,
+      int userId,
+      String packageName) {
     getShadowDisplayManagerGlobal().setBrightnessConfigurationForUser(config, userId, packageName);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
index d73734543..548f57261 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDisplayManagerGlobal.java
@@ -20,6 +20,7 @@ import android.os.RemoteException;
 import android.util.SparseArray;
 import android.view.Display;
 import android.view.DisplayInfo;
+import android.view.Surface;
 import com.google.common.annotations.VisibleForTesting;
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -42,8 +43,9 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link DisplayManagerGlobal}. */
-@Implements(value = DisplayManagerGlobal.class, isInAndroidSdk = false, looseSignatures = true)
+@Implements(value = DisplayManagerGlobal.class, isInAndroidSdk = false)
 public class ShadowDisplayManagerGlobal {
+  private static final String TOPOLOGY_LISTENERS_FIELD_NAME = "mTopologyListeners";
   private static DisplayManagerGlobal instance;
 
   private float saturationLevel = 1f;
@@ -89,6 +91,10 @@ public class ShadowDisplayManagerGlobal {
     displayManagerGlobal.setLock(new Object());
     List<Handler> displayListeners = createDisplayListeners();
     displayManagerGlobal.setDisplayListeners(displayListeners);
+    if (ReflectionHelpers.hasField(DisplayManagerGlobal.class,
+            TOPOLOGY_LISTENERS_FIELD_NAME)) {
+      displayManagerGlobal.setTopologyListeners(new CopyOnWriteArrayList<>());
+    }
     displayManagerGlobal.setDisplayInfoCache(new SparseArray<>());
     return instance;
   }
@@ -147,6 +153,10 @@ public class ShadowDisplayManagerGlobal {
     mDm.removeDisplay(displayId);
   }
 
+  SystemUi getSystemUi(int displayId) {
+    return mDm.getSystemUi(displayId);
+  }
+
   /**
    * A delegating proxy for the IDisplayManager system service.
    *
@@ -156,6 +166,7 @@ public class ShadowDisplayManagerGlobal {
    */
   private static class DisplayManagerProxyDelegate {
     private final TreeMap<Integer, DisplayInfo> displayInfos = new TreeMap<>();
+    private final Map<Integer, SystemUi> systemUis = new HashMap<>();
     private int nextDisplayId = 0;
     private final List<IDisplayManagerCallback> callbacks = new ArrayList<>();
     private final Map<IVirtualDisplayCallback, Integer> virtualDisplayIds = new HashMap<>();
@@ -182,6 +193,10 @@ public class ShadowDisplayManagerGlobal {
       return getDisplayIds();
     }
 
+    public SystemUi getSystemUi(int displayId) {
+      return systemUis.get(displayId);
+    }
+
     // @Override
     public void registerCallback(IDisplayManagerCallback iDisplayManagerCallback)
         throws RemoteException {
@@ -194,9 +209,9 @@ public class ShadowDisplayManagerGlobal {
       registerCallback(iDisplayManagerCallback);
     }
 
-    // for android U
+    // for android R+ (SDK 30+)
     // Use Object here instead of VirtualDisplayConfig to avoid breaking projects that still
-    // compile against SDKs < U
+    // compile against SDKs < R
     public int createVirtualDisplay(
         @ClassName("android.hardware.display.VirtualDisplayConfig")
             Object virtualDisplayConfigObject,
@@ -222,6 +237,36 @@ public class ShadowDisplayManagerGlobal {
       return id;
     }
 
+    // for android Q (SDK 29) and below
+    public int createVirtualDisplay(
+        IVirtualDisplayCallback callbackWrapper,
+        IMediaProjection projectionToken,
+        String packageName,
+        String name,
+        int width,
+        int height,
+        int densityDpi,
+        Surface surface,
+        int flags,
+        String uniqueId) {
+      DisplayInfo displayInfo = new DisplayInfo();
+      displayInfo.flags = flags;
+      displayInfo.type = Display.TYPE_VIRTUAL;
+      displayInfo.name = name;
+      displayInfo.logicalDensityDpi = densityDpi;
+      displayInfo.physicalXDpi = densityDpi;
+      displayInfo.physicalYDpi = densityDpi;
+      displayInfo.ownerPackageName = packageName;
+      displayInfo.appWidth = width;
+      displayInfo.logicalWidth = width;
+      displayInfo.appHeight = height;
+      displayInfo.logicalHeight = height;
+      displayInfo.state = Display.STATE_ON;
+      int id = addDisplay(displayInfo);
+      virtualDisplayIds.put(callbackWrapper, id);
+      return id;
+    }
+
     // for android U
     public void resizeVirtualDisplay(
         IVirtualDisplayCallback token, int width, int height, int densityDpi) {
@@ -243,12 +288,23 @@ public class ShadowDisplayManagerGlobal {
       }
     }
 
+    // for android Q through V
     // @Override
     public void setVirtualDisplayState(IVirtualDisplayCallback token, boolean isOn) {
       Integer id = virtualDisplayIds.get(token);
       DisplayInfo displayInfo = displayInfos.get(id);
-      displayInfo.state = isOn ? Display.STATE_ON : Display.STATE_OFF;
-      changeDisplay(id, displayInfo);
+      int newState = isOn ? Display.STATE_ON : Display.STATE_OFF;
+      if (displayInfo.state != newState) {
+        displayInfo.state = newState;
+        changeDisplay(id, displayInfo);
+      }
+    }
+
+    public void setVirtualDisplaySurface(IVirtualDisplayCallback token, Surface surface) {
+      // in post android V, the setVirtualDisplayState has been removed and the virtual device
+      // state is propagated from system service
+      // TODO: also check power group state if > android V
+      setVirtualDisplayState(token, surface != null);
     }
 
     private synchronized int addDisplay(DisplayInfo displayInfo) {
@@ -257,6 +313,7 @@ public class ShadowDisplayManagerGlobal {
       if (RuntimeEnvironment.getApiLevel() >= Q) {
         displayInfo.displayId = nextId;
       }
+      systemUis.put(nextId, new SystemUi(nextId));
       notifyListeners(nextId, DisplayManagerGlobal.EVENT_DISPLAY_ADDED);
       return nextId;
     }
@@ -276,6 +333,7 @@ public class ShadowDisplayManagerGlobal {
       }
 
       displayInfos.remove(displayId);
+      systemUis.remove(displayId);
       notifyListeners(displayId, DisplayManagerGlobal.EVENT_DISPLAY_REMOVED);
     }
 
@@ -308,14 +366,17 @@ public class ShadowDisplayManagerGlobal {
   @Implementation(minSdk = P)
   @HiddenApi
   protected void setBrightnessConfigurationForUser(
-      Object configObject, Object userId, Object packageName) {
+      @ClassName("android.hardware.display.BrightnessConfiguration") Object configObject,
+      int userId,
+      String packageName) {
     BrightnessConfiguration config = (BrightnessConfiguration) configObject;
     brightnessConfiguration.put((int) userId, config);
   }
 
   @Implementation(minSdk = P)
   @HiddenApi
-  protected Object getBrightnessConfigurationForUser(int userId) {
+  protected @ClassName("android.hardware.display.BrightnessConfiguration") Object
+      getBrightnessConfigurationForUser(int userId) {
     BrightnessConfiguration config = brightnessConfiguration.get(userId);
     if (config != null) {
       return config;
@@ -326,7 +387,8 @@ public class ShadowDisplayManagerGlobal {
 
   @Implementation(minSdk = P)
   @HiddenApi
-  protected Object getDefaultBrightnessConfiguration() {
+  protected @ClassName("android.hardware.display.BrightnessConfiguration") Object
+      getDefaultBrightnessConfiguration() {
     return defaultBrightnessConfiguration;
   }
 
@@ -357,6 +419,9 @@ public class ShadowDisplayManagerGlobal {
     @Accessor("mDisplayListeners")
     void setDisplayListeners(List<Handler> list);
 
+    @Accessor(TOPOLOGY_LISTENERS_FIELD_NAME)
+    void setTopologyListeners(List<Handler> list);
+
     @Accessor("mDisplayInfoCache")
     void setDisplayInfoCache(SparseArray<DisplayInfo> displayInfoCache);
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
index 36830fd23..a412ab079 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDownloadManager.java
@@ -20,6 +20,7 @@ import javax.annotation.Nullable;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.fakes.BaseCursor;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
@@ -27,49 +28,66 @@ import org.robolectric.util.ReflectionHelpers;
 @Implements(DownloadManager.class)
 public class ShadowDownloadManager {
 
-  private long queueCounter = -1; // First request starts at 0 just like in the real DownloadManager
-  private Map<Long, DownloadManager.Request> requestMap = new TreeMap<>();
+  private static long queueCounter =
+      -1; // First request starts at 0 just like in the real DownloadManager
+  private static Map<Long, DownloadManager.Request> requestMap = new TreeMap<>();
 
-  private long completedCounter = -1;
-  private Map<Long, CompletedDownload> completedDownloadsMap = new HashMap<>();
+  private static long completedCounter = -1;
+  private static Map<Long, CompletedDownload> completedDownloadsMap = new HashMap<>();
+
+  @Resetter
+  public static void reset() {
+    synchronized (ShadowDownloadManager.class) {
+      queueCounter = -1;
+      requestMap.clear();
+      completedCounter = -1;
+      completedDownloadsMap.clear();
+    }
+  }
 
   @Implementation
   protected long enqueue(DownloadManager.Request request) {
-    queueCounter++;
-    requestMap.put(queueCounter, request);
-    ShadowRequest shadowRequest = Shadow.extract(request);
-    shadowRequest.setId(queueCounter);
-    return queueCounter;
+    synchronized (ShadowDownloadManager.class) {
+      queueCounter++;
+      requestMap.put(queueCounter, request);
+      ShadowRequest shadowRequest = Shadow.extract(request);
+      shadowRequest.setId(queueCounter);
+      return queueCounter;
+    }
   }
 
   @Implementation
   protected int remove(long... ids) {
-    int removeCount = 0;
-    for (long id : ids) {
-      if (requestMap.remove(id) != null) {
-        removeCount++;
+    synchronized (ShadowDownloadManager.class) {
+      int removeCount = 0;
+      for (long id : ids) {
+        if (requestMap.remove(id) != null) {
+          removeCount++;
+        }
       }
+      return removeCount;
     }
-    return removeCount;
   }
 
   @Implementation
   protected Cursor query(DownloadManager.Query query) {
-    ResultCursor result = new ResultCursor();
-    ShadowQuery shadow = Shadow.extract(query);
-    long[] ids = shadow.getIds();
-
-    if (ids != null) {
-      for (long id : ids) {
-        DownloadManager.Request request = requestMap.get(id);
-        if (request != null) {
-          result.requests.add(request);
+    synchronized (ShadowDownloadManager.class) {
+      ResultCursor result = new ResultCursor();
+      ShadowQuery shadow = Shadow.extract(query);
+      long[] ids = shadow.getIds();
+
+      if (ids != null) {
+        for (long id : ids) {
+          DownloadManager.Request request = requestMap.get(id);
+          if (request != null) {
+            result.requests.add(request);
+          }
         }
+      } else {
+        result.requests.addAll(requestMap.values());
       }
-    } else {
-      result.requests.addAll(requestMap.values());
+      return result;
     }
-    return result;
   }
 
   @Implementation
@@ -104,36 +122,46 @@ public class ShadowDownloadManager {
       boolean showNotification,
       Uri uri,
       Uri referrer) {
-    completedCounter++;
-    completedDownloadsMap.put(
-        completedCounter,
-        new CompletedDownload(
-            title,
-            description,
-            isMediaScannerScannable,
-            mimeType,
-            path,
-            length,
-            showNotification,
-            uri,
-            referrer));
-    return completedCounter;
+    synchronized (ShadowDownloadManager.class) {
+      completedCounter++;
+      completedDownloadsMap.put(
+          completedCounter,
+          new CompletedDownload(
+              title,
+              description,
+              isMediaScannerScannable,
+              mimeType,
+              path,
+              length,
+              showNotification,
+              uri,
+              referrer));
+      return completedCounter;
+    }
   }
 
   public DownloadManager.Request getRequest(long id) {
-    return requestMap.get(id);
+    synchronized (ShadowDownloadManager.class) {
+      return requestMap.get(id);
+    }
   }
 
   public int getRequestCount() {
-    return requestMap.size();
+    synchronized (ShadowDownloadManager.class) {
+      return requestMap.size();
+    }
   }
 
   public CompletedDownload getCompletedDownload(long id) {
-    return completedDownloadsMap.get(id);
+    synchronized (ShadowDownloadManager.class) {
+      return completedDownloadsMap.get(id);
+    }
   }
 
   public int getCompletedDownloadsCount() {
-    return completedDownloadsMap.size();
+    synchronized (ShadowDownloadManager.class) {
+      return completedDownloadsMap.size();
+    }
   }
 
   @Implements(DownloadManager.Request.class)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
index 1176cc71b..cbd681625 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowDropBoxManager.java
@@ -8,11 +8,12 @@ import java.util.SortedMap;
 import java.util.TreeMap;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Fake dropbox manager that starts with no entries. */
 @Implements(value = DropBoxManager.class)
 public class ShadowDropBoxManager {
-  private final SortedMap<Long, Entry> entries = new TreeMap<>();
+  private static final SortedMap<Long, Entry> entries = new TreeMap<>();
 
   public ShadowDropBoxManager() {
     reset();
@@ -56,7 +57,8 @@ public class ShadowDropBoxManager {
   }
 
   /** Clears all entries. */
-  public void reset() {
+  @Resetter
+  public static void reset() {
     entries.clear();
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
index ae0b74f3c..62ccce394 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowEuiccManager.java
@@ -8,13 +8,21 @@ import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 @Implements(value = EuiccManager.class, minSdk = P)
 public class ShadowEuiccManager {
 
-  private final Map<Integer, EuiccManager> cardIdsToEuiccManagers = new HashMap<>();
-  private boolean enabled;
-  private String eid;
+  private static final Map<Integer, EuiccManager> cardIdsToEuiccManagers = new HashMap<>();
+  private static boolean enabled;
+  private static String eid;
+
+  @Resetter
+  public static void reset() {
+    cardIdsToEuiccManagers.clear();
+    enabled = false;
+    eid = null;
+  }
 
   @Implementation(minSdk = Q)
   protected EuiccManager createForCardId(int cardId) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
index 8224cb548..276fbd54b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFileIntegrityManager.java
@@ -5,12 +5,13 @@ import static android.os.Build.VERSION_CODES.R;
 import android.security.FileIntegrityManager;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow for {@link FileIntegrityManager}. */
 @Implements(value = FileIntegrityManager.class, minSdk = R, isInAndroidSdk = false)
 public class ShadowFileIntegrityManager {
 
-  private boolean isApkVeritySupported = true;
+  private static boolean isApkVeritySupported = true;
 
   /** Sets the value of {@link #isApkVeritySupported}. */
   public void setIsApkVeritySupported(boolean isApkVeritySupported) {
@@ -25,4 +26,9 @@ public class ShadowFileIntegrityManager {
   protected boolean isApkVeritySupported() {
     return isApkVeritySupported;
   }
+
+  @Resetter
+  public static void reset() {
+    isApkVeritySupported = true;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
index 9bd665cf6..88f00f0a4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowFingerprintManager.java
@@ -24,6 +24,7 @@ import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
@@ -34,10 +35,18 @@ public class ShadowFingerprintManager {
 
   private static final String TAG = "ShadowFingerprintManager";
 
-  private boolean isHardwareDetected;
-  protected CryptoObject pendingCryptoObject;
-  private AuthenticationCallback pendingCallback;
-  private List<Fingerprint> fingerprints = Collections.emptyList();
+  private static boolean isHardwareDetected;
+  protected static CryptoObject pendingCryptoObject;
+  private static AuthenticationCallback pendingCallback;
+  private static List<Fingerprint> fingerprints = Collections.emptyList();
+
+  @Resetter
+  public static void reset() {
+    isHardwareDetected = false;
+    pendingCryptoObject = null;
+    pendingCallback = null;
+    fingerprints = Collections.emptyList();
+  }
 
   /**
    * Simulates a successful fingerprint authentication. An authentication request must have been
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHardwareRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHardwareRenderer.java
index 7b86dc2f4..bd1034c1f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHardwareRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowHardwareRenderer.java
@@ -7,16 +7,15 @@ import static android.os.Build.VERSION_CODES.S;
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
 import android.graphics.HardwareRenderer;
+import android.graphics.RenderNode;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 
-@Implements(
-    value = HardwareRenderer.class,
-    isInAndroidSdk = false,
-    looseSignatures = true,
-    minSdk = Q)
+/** No-op shadow for {@link HardwareRenderer}. */
+@Implements(value = HardwareRenderer.class, isInAndroidSdk = false, minSdk = Q)
 public class ShadowHardwareRenderer {
 
   private static long nextCreateProxy = 0;
@@ -37,16 +36,17 @@ public class ShadowHardwareRenderer {
     return nCreateProxy(translucent, rootRenderNode);
   }
 
-  // need to use loose signatures here to account for signature changes
-  @Implementation(minSdk = S)
-  protected static long nCreateProxy(Object translucent, Object rootRenderNode) {
-    return nCreateProxy((boolean) translucent, (long) rootRenderNode);
+  // `nCreateProxy` function signature changed in R, have to create two functions with different
+  // function name for pre-R and post-R.
+  @Implementation(minSdk = S, methodName = "nCreateProxy")
+  protected static long nCreateProxyFromS(boolean translucent, long rootRenderNode) {
+    return nCreateProxy(translucent, rootRenderNode);
   }
 
   @Implementation
   protected static Bitmap createHardwareBitmap(
-      /*RenderNode*/ Object node, /*int*/ Object width, /*int*/ Object height) {
-    return createHardwareBitmap((int) width, (int) height);
+      @ClassName("android.graphics.RenderNode") RenderNode node, int width, int height) {
+    return createHardwareBitmap(width, height);
   }
 
   private static Bitmap createHardwareBitmap(int width, int height) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
index a454e68ed..c93b02f63 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageDecoder.java
@@ -3,10 +3,10 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.content.res.AssetManager;
 import android.content.res.AssetManager.AssetInputStream;
-import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.ColorSpace;
@@ -21,12 +21,15 @@ import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import libcore.io.IoUtils;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.res.android.NativeObjRegistry;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
 
 // transliterated from
 // https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/core/jni/android/graphics/ImageDecoder.cpp
@@ -150,14 +153,12 @@ public class ShadowImageDecoder {
         });
   }
 
-  protected static ImageDecoder ImageDecoder_nCreateAsset(long asset_ptr, Source source)
-      throws DecodeException {
+  protected static ImageDecoder ImageDecoder_nCreateAsset(
+      AssetInputStream assetInputStream /*long asset_ptr*/, Source source) throws DecodeException {
     // Asset* asset = reinterpret_cast<Asset*>(assetPtr);
     // SkStream stream = new AssetStreamAdaptor(asset);
     // return jniCreateDecoder(stream, source);
-    Resources resources = ReflectionHelpers.getField(source, "mResources");
-    AssetInputStream assetInputStream =
-        ShadowAssetInputStream.createAssetInputStream(null, asset_ptr, resources.getAssets());
+
     return jniCreateDecoder(
         new ImgStream() {
           @Override
@@ -274,11 +275,6 @@ public class ShadowImageDecoder {
 
   // native method implementations...
 
-  @Implementation(maxSdk = Q)
-  protected static ImageDecoder nCreate(long asset, Source source) throws IOException {
-    return ImageDecoder_nCreateAsset(asset, source);
-  }
-
   @Implementation(maxSdk = Q)
   protected static ImageDecoder nCreate(ByteBuffer buffer, int position, int limit, Source src)
       throws IOException {
@@ -302,10 +298,28 @@ public class ShadowImageDecoder {
     return ImageDecoder_nCreateFd(fd, src);
   }
 
-  @Implementation(minSdk = R)
-  protected static ImageDecoder nCreate(long asset, boolean preferAnimation, Source source)
+  @Implementation(maxSdk = Q)
+  protected static ImageDecoder createFromAsset(AssetInputStream ais, Source source)
       throws IOException {
-    return ImageDecoder_nCreateAsset(asset, source);
+    return createFromAsset(ais, false, source);
+  }
+
+  @Implementation(minSdk = R)
+  protected static ImageDecoder createFromAsset(
+      AssetInputStream ais, boolean preferAnimation, Source source) throws IOException {
+    // copy the real android implementation to retain access to the AssetInputStream
+    ImageDecoder decoder = null;
+    try {
+      decoder = ImageDecoder_nCreateAsset(ais, source);
+    } finally {
+      if (decoder == null) {
+        IoUtils.closeQuietly(ais);
+      } else {
+        reflector(ImageDecoderReflector.class, decoder).setInputStream(ais);
+        reflector(ImageDecoderReflector.class, decoder).setOwnsInputStream(true);
+      }
+    }
+    return decoder;
   }
 
   @Implementation(minSdk = R)
@@ -419,4 +433,13 @@ public class ShadowImageDecoder {
   protected static ColorSpace nGetColorSpace(long nativePtr) {
     return ImageDecoder_nGetColorSpace(nativePtr);
   }
+
+  @ForType(ImageDecoder.class)
+  interface ImageDecoderReflector {
+    @Accessor("mInputStream")
+    void setInputStream(InputStream is);
+
+    @Accessor("mOwnsInputStream")
+    void setOwnsInputStream(boolean value);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageReader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageReader.java
index 9431560eb..4cb92ce93 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageReader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowImageReader.java
@@ -26,7 +26,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for {@link android.media.ImageReader} */
-@Implements(value = ImageReader.class, looseSignatures = true)
+@Implements(value = ImageReader.class)
 public class ShadowImageReader {
   // Using same return codes as ImageReader.
   private static final int ACQUIRE_SUCCESS = 0;
@@ -69,9 +69,9 @@ public class ShadowImageReader {
     return nativeImageSetup(image);
   }
 
-  @Implementation(minSdk = U.SDK_INT)
-  protected int nativeImageSetup(Object /* Image */ image) {
-    return nativeImageSetup((Image) image);
+  @Implementation(minSdk = U.SDK_INT, methodName = "nativeImageSetup")
+  protected int nativeImageSetupFromU(Image image) {
+    return nativeImageSetup(image);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputDevice.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputDevice.java
index ea1efa2df..358794b28 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputDevice.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputDevice.java
@@ -1,47 +1,72 @@
 package org.robolectric.shadows;
 
 import android.view.InputDevice;
-import org.robolectric.annotation.Implementation;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.ReflectorObject;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.U;
 
+/**
+ * @deprecated use {@link InputDeviceBuilder}.
+ */
 @Implements(InputDevice.class)
+@Deprecated
 public class ShadowInputDevice {
-  private String deviceName;
-  private int productId;
-  private int vendorId;
+  @ReflectorObject private InputDeviceReflector inputDeviceReflector;
 
+  /**
+   * @deprecated use {@link InputDeviceBuilder}.
+   */
+  @Deprecated
   public static InputDevice makeInputDeviceNamed(String deviceName) {
-    InputDevice inputDevice = Shadow.newInstanceOf(InputDevice.class);
-    ShadowInputDevice shadowInputDevice = Shadow.extract(inputDevice);
-    shadowInputDevice.setDeviceName(deviceName);
-    return inputDevice;
+    if (RuntimeEnvironment.getApiLevel() >= U.SDK_INT) {
+      InputDevice.Builder builder = new InputDevice.Builder();
+      builder.setName(deviceName);
+      return builder.build();
+    } else {
+      InputDevice inputDevice = Shadow.newInstanceOf(InputDevice.class);
+      ShadowInputDevice shadowInputDevice = Shadow.extract(inputDevice);
+      shadowInputDevice.setDeviceName(deviceName);
+      return inputDevice;
+    }
   }
 
-  @Implementation
-  protected String getName() {
-    return deviceName;
+  /**
+   * @deprecated use {@link InputDeviceBuilder}.
+   */
+  @Deprecated
+  public void setDeviceName(String deviceName) {
+    inputDeviceReflector.setName(deviceName);
   }
 
-  @Implementation
-  protected int getProductId() {
-    return productId;
+  /**
+   * @deprecated use {@link InputDeviceBuilder}.
+   */
+  @Deprecated
+  public void setProductId(int productId) {
+    inputDeviceReflector.setProductId(productId);
   }
 
-  @Implementation
-  protected int getVendorId() {
-    return vendorId;
+  /**
+   * @deprecated use {@link InputDeviceBuilder}.
+   */
+  @Deprecated
+  public void setVendorId(int vendorId) {
+    inputDeviceReflector.setVendorId(vendorId);
   }
 
-  public void setDeviceName(String deviceName) {
-    this.deviceName = deviceName;
-  }
+  @ForType(InputDevice.class)
+  private interface InputDeviceReflector {
+    @Accessor("mName")
+    void setName(String name);
 
-  public void setProductId(int productId) {
-    this.productId = productId;
-  }
+    @Accessor("mProductId")
+    void setProductId(int productId);
 
-  public void setVendorId(int vendorId) {
-    this.vendorId = vendorId;
+    @Accessor("mVendorId")
+    void setVendorId(int vendorId);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
index 30b4ea814..f8018973f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputManager.java
@@ -14,6 +14,7 @@ import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.VerifiedKeyEvent;
 import android.view.VerifiedMotionEvent;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -24,7 +25,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for {@link InputManager} */
-@Implements(value = InputManager.class, looseSignatures = true)
+@Implements(value = InputManager.class)
 public class ShadowInputManager {
 
   @RealObject InputManager realInputManager;
@@ -94,7 +95,8 @@ public class ShadowInputManager {
    * native code.
    */
   @Implementation(minSdk = R)
-  protected Object verifyInputEvent(Object inputEvent) {
+  protected @ClassName("android.view.VerifiedInputEvent") Object verifyInputEvent(
+      InputEvent inputEvent) {
     if (inputEvent instanceof MotionEvent) {
       MotionEvent motionEvent = (MotionEvent) inputEvent;
       return new VerifiedMotionEvent(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
index 093bb2d12..741e98b86 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInputMethodManager.java
@@ -23,17 +23,21 @@ import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import java.util.List;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for InputMethodManager. */
-@Implements(value = InputMethodManager.class, looseSignatures = true)
+@Implements(value = InputMethodManager.class)
 public class ShadowInputMethodManager {
 
   /**
@@ -55,12 +59,13 @@ public class ShadowInputMethodManager {
     void onPrivateCommand(View view, String action, Bundle data);
   }
 
-  private boolean softInputVisible;
-  private Optional<SoftInputVisibilityChangeHandler> visibilityChangeHandler = Optional.absent();
-  private Optional<PrivateCommandListener> privateCommandListener = Optional.absent();
-  private List<InputMethodInfo> inputMethodInfoList = ImmutableList.of();
-  private List<InputMethodInfo> enabledInputMethodInfoList = ImmutableList.of();
-  private Optional<InputMethodSubtype> inputMethodSubtype = Optional.absent();
+  private static boolean softInputVisible;
+  private static Optional<SoftInputVisibilityChangeHandler> visibilityChangeHandler =
+      Optional.absent();
+  private static Optional<PrivateCommandListener> privateCommandListener = Optional.absent();
+  private static List<InputMethodInfo> inputMethodInfoList = ImmutableList.of();
+  private static List<InputMethodInfo> enabledInputMethodInfoList = ImmutableList.of();
+  private static Optional<InputMethodSubtype> inputMethodSubtype = Optional.absent();
 
   @Implementation
   protected boolean showSoftInput(View view, int flags) {
@@ -81,17 +86,31 @@ public class ShadowInputMethodManager {
 
   @Implementation(minSdk = U.SDK_INT)
   protected boolean showSoftInput(
-      Object view, Object statsToken, Object flags, Object resultReceiver, Object reason) {
-    return showSoftInput(
-        (View) view, (Integer) flags, (ResultReceiver) resultReceiver, (Integer) reason);
+      View view,
+      @ClassName("android.view.inputmethod.ImeTracker$Token") Object statsToken,
+      int flags,
+      ResultReceiver resultReceiver,
+      int reason) {
+    return showSoftInput(view, flags, resultReceiver, reason);
   }
 
-  @Implementation(minSdk = S)
+  @Implementation(minSdk = S, maxSdk = V.SDK_INT)
   protected boolean hideSoftInputFromWindow(
       IBinder windowToken, int flags, ResultReceiver resultReceiver, int ignoredReason) {
     return hideSoftInputFromWindow(windowToken, flags, resultReceiver);
   }
 
+  @Implementation(minSdk = Baklava.SDK_INT)
+  @InDevelopment
+  protected boolean hideSoftInputFromWindow(
+      IBinder windowToken,
+      int flags,
+      ResultReceiver resultReceiver,
+      int ignoredReason,
+      @ClassName("android.view.inputmethod.ImeTracker$Token") Object statsToken) {
+    return hideSoftInputFromWindow(windowToken, flags, resultReceiver);
+  }
+
   @Implementation(maxSdk = R)
   protected boolean hideSoftInputFromWindow(IBinder windowToken, int flags) {
     return hideSoftInputFromWindow(windowToken, flags, null);
@@ -270,6 +289,12 @@ public class ShadowInputMethodManager {
     if (apiLevel > P) {
       _reflector.getInstanceMap().clear();
     }
+    softInputVisible = false;
+    visibilityChangeHandler = Optional.absent();
+    privateCommandListener = Optional.absent();
+    inputMethodInfoList = ImmutableList.of();
+    enabledInputMethodInfoList = ImmutableList.of();
+    inputMethodSubtype = Optional.absent();
   }
 
   @ForType(InputMethodManager.class)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsAnimationThread.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsAnimationThread.java
new file mode 100644
index 000000000..231f7ab87
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsAnimationThread.java
@@ -0,0 +1,16 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.R;
+
+import android.view.InsetsAnimationThread;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+
+/** Shadow for {@link InsetsAnimationThread}. */
+@Implements(value = InsetsAnimationThread.class, minSdk = R, isInAndroidSdk = false)
+public class ShadowInsetsAnimationThread {
+  @Resetter
+  public static void reset() {
+    InsetsAnimationThread.release();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsController.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsController.java
deleted file mode 100644
index 0cd93e68e..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsController.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.robolectric.shadows;
-
-import android.annotation.RequiresApi;
-import android.os.Build;
-import android.view.InsetsController;
-import android.view.WindowInsets;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-import org.robolectric.annotation.ReflectorObject;
-import org.robolectric.util.reflector.Direct;
-import org.robolectric.util.reflector.ForType;
-
-/** Intercepts calls to [InsetsController] to monitor system bars functionality (hide/show). */
-@Implements(value = InsetsController.class, minSdk = Build.VERSION_CODES.R, isInAndroidSdk = false)
-@RequiresApi(Build.VERSION_CODES.R)
-public class ShadowInsetsController {
-  @ReflectorObject private InsetsControllerReflector insetsControllerReflector;
-
-  /**
-   * Intercepts calls to [InsetsController.show] to detect requested changes to the system
-   * status/nav bar visibility.
-   */
-  @Implementation
-  protected void show(int types) {
-    if (hasStatusBarType(types)) {
-      ShadowViewRootImpl.setIsStatusBarVisible(true);
-    }
-
-    if (hasNavigationBarType(types)) {
-      ShadowViewRootImpl.setIsNavigationBarVisible(true);
-    }
-
-    insetsControllerReflector.show(types);
-  }
-
-  /**
-   * Intercepts calls to [InsetsController.hide] to detect requested changes to the system
-   * status/nav bar visibility.
-   */
-  @Implementation
-  public void hide(int types) {
-    if (hasStatusBarType(types)) {
-      ShadowViewRootImpl.setIsStatusBarVisible(false);
-    }
-
-    if (hasNavigationBarType(types)) {
-      ShadowViewRootImpl.setIsNavigationBarVisible(false);
-    }
-
-    insetsControllerReflector.hide(types);
-  }
-
-  /** Returns true if the given flags contain the mask for the system status bar. */
-  private boolean hasStatusBarType(int types) {
-    return hasTypeMask(types, WindowInsets.Type.statusBars());
-  }
-
-  /** Returns true if the given flags contain the mask for the system navigation bar. */
-  private boolean hasNavigationBarType(int types) {
-    return hasTypeMask(types, WindowInsets.Type.navigationBars());
-  }
-
-  /** Returns true if the given flags contains the requested type mask. */
-  private boolean hasTypeMask(int types, int typeMask) {
-    return (types & typeMask) == typeMask;
-  }
-
-  /** Reflector for [InsetsController] to use for direct (non-intercepted) calls. */
-  @ForType(InsetsController.class)
-  interface InsetsControllerReflector {
-    @Direct
-    void show(int types);
-
-    @Direct
-    void hide(int types);
-  }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsSource.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsSource.java
new file mode 100644
index 000000000..573e6394c
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsSource.java
@@ -0,0 +1,57 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+
+import android.graphics.Rect;
+import android.view.InsetsSource;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.ReflectorObject;
+import org.robolectric.util.reflector.ForType;
+
+/** Shadow of {@link InsetsSource}. */
+@Implements(value = InsetsSource.class, minSdk = Q, isInAndroidSdk = false)
+public class ShadowInsetsSource {
+  @RealObject private InsetsSource realInsetsSource;
+  @ReflectorObject private InsetsSourceReflector insetsSourceReflector;
+
+  /**
+   * Backwards compatible version of {@link InsetsSource#setVisible(boolean)} which changed in U
+   * from returning {@code void} to {@link InsetsSource}.
+   */
+  @CanIgnoreReturnValue
+  ShadowInsetsSource setVisible(boolean isVisible) {
+    if (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE) {
+      realInsetsSource.setVisible(isVisible);
+    } else {
+      insetsSourceReflector.setVisible(isVisible);
+    }
+    return this;
+  }
+
+  /**
+   * Backwards compatible version of {@link InsetsSource#setFrame(Rect)} which changed in U from
+   * returning {@code void} to {@link InsetsSource}.
+   */
+  @CanIgnoreReturnValue
+  ShadowInsetsSource setFrame(Rect frame) {
+    if (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE) {
+      realInsetsSource.setFrame(frame);
+    } else {
+      insetsSourceReflector.setFrame(frame);
+    }
+    return this;
+  }
+
+  @ForType(InsetsSource.class)
+  interface InsetsSourceReflector {
+    // Prior to U this method returned void
+    void setFrame(Rect frame);
+
+    // Prior to U this method returned void
+    void setVisible(boolean isVisible);
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsState.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsState.java
new file mode 100644
index 000000000..bd343e271
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInsetsState.java
@@ -0,0 +1,83 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.view.InsetsSource;
+import android.view.InsetsState;
+import android.view.WindowInsets;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.ReflectorObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.util.reflector.Static;
+
+/** Shadow of {@link InsetsState}. */
+@Implements(value = InsetsState.class, minSdk = Q, isInAndroidSdk = false)
+public class ShadowInsetsState {
+  // These must align with the indexes declared in InsetsState in SDK up to 33
+  static final int STATUS_BARS = 0;
+  static final int NAVIGATION_BARS = 1;
+
+  @RealObject private InsetsState realInsetsState;
+  @ReflectorObject private InsetsStateReflector insetsStateReflector;
+
+  InsetsSource getOrCreateSource(int id) {
+    return RuntimeEnvironment.getApiLevel() < UPSIDE_DOWN_CAKE
+        ? insetsStateReflector.getSource(id)
+        : realInsetsState.getOrCreateSource(id, getType(id));
+  }
+
+  int getSourceSize() {
+    if (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE) {
+      return realInsetsState.sourceSize();
+    } else if (RuntimeEnvironment.getApiLevel() >= R) {
+      return reflector(InsetsStateReflector.class).getLastType() + 1;
+    } else {
+      return insetsStateReflector.getSourcesCount();
+    }
+  }
+
+  private static int getType(int id) {
+    switch (id) {
+      case STATUS_BARS:
+        return RuntimeEnvironment.getApiLevel() < Q
+            ? reflector(WindowInsetsTypeReflector.class).topBar()
+            : WindowInsets.Type.statusBars();
+      case NAVIGATION_BARS:
+        return RuntimeEnvironment.getApiLevel() < Q
+            ? reflector(WindowInsetsTypeReflector.class).sideBars()
+            : WindowInsets.Type.navigationBars();
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  @ForType(InsetsState.class)
+  interface InsetsStateReflector {
+    InsetsSource getSource(int type);
+
+    @Accessor("ITYPE_IME")
+    @Static
+    int getImeType();
+
+    @Accessor("LAST_TYPE")
+    @Static
+    int getLastType();
+
+    int getSourcesCount();
+  }
+
+  @ForType(WindowInsets.Type.class)
+  interface WindowInsetsTypeReflector {
+    @Static
+    int topBar();
+
+    @Static
+    int sideBars();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
index 623302507..672771ee1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowInstrumentation.java
@@ -772,9 +772,9 @@ public class ShadowInstrumentation {
             Logger.warn(
                 "Configured to call onServiceDisconnected when unbindService is called. This is"
                     + " not accurate Android behavior. Please update your tests and call"
-                    + " ShadowActivity#setUnbindCallsOnServiceDisconnected(false). This will"
-                    + " become default behavior in the future, which may break your tests if you"
-                    + " are expecting this inaccurate behavior.");
+                    + " ShadowApplication#setUnbindServiceCallsOnServiceDisconnected(false). This"
+                    + " will become default behavior in the future, which may break your tests if"
+                    + " you are expecting this inaccurate behavior.");
             serviceConnection.onServiceDisconnected(
                 serviceConnectionDataWrapper.componentNameForBindService);
           }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
index 02c3f5dbf..bc1e88b92 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLauncherApps.java
@@ -40,24 +40,41 @@ import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow of {@link android.content.pm.LauncherApps}. */
 @Implements(value = LauncherApps.class)
 public class ShadowLauncherApps {
-  private List<ShortcutInfo> shortcuts = new ArrayList<>();
-  private final Multimap<UserHandle, String> enabledPackages = HashMultimap.create();
-  private final Multimap<UserHandle, ComponentName> enabledActivities = HashMultimap.create();
-  private final Multimap<UserHandle, LauncherActivityInfo> shortcutActivityList =
+  private static List<ShortcutInfo> shortcuts = new ArrayList<>();
+  private static final Multimap<UserHandle, String> enabledPackages = HashMultimap.create();
+  private static final Multimap<UserHandle, ComponentName> enabledActivities =
       HashMultimap.create();
-  private final Multimap<UserHandle, LauncherActivityInfo> activityList = HashMultimap.create();
-  private final Map<UserHandle, Map<String, ApplicationInfo>> applicationInfoList = new HashMap<>();
-  private final Map<UserHandle, Map<String, Bundle>> suspendedPackageLauncherExtras =
+  private static final Multimap<UserHandle, LauncherActivityInfo> shortcutActivityList =
+      HashMultimap.create();
+  private static final Multimap<UserHandle, LauncherActivityInfo> activityList =
+      HashMultimap.create();
+  private static final Map<UserHandle, Map<String, ApplicationInfo>> applicationInfoList =
+      new HashMap<>();
+  private static final Map<UserHandle, Map<String, Bundle>> suspendedPackageLauncherExtras =
       new HashMap<>();
 
-  private final List<Pair<LauncherApps.Callback, Handler>> callbacks = new ArrayList<>();
-  private boolean hasShortcutHostPermission = false;
+  private static final List<Pair<LauncherApps.Callback, Handler>> callbacks = new ArrayList<>();
+  private static boolean hasShortcutHostPermission = false;
+
+  @Resetter
+  public static void reset() {
+    shortcuts.clear();
+    enabledPackages.clear();
+    enabledActivities.clear();
+    shortcutActivityList.clear();
+    activityList.clear();
+    applicationInfoList.clear();
+    suspendedPackageLauncherExtras.clear();
+    callbacks.clear();
+    hasShortcutHostPermission = false;
+  }
 
   /**
    * Adds a dynamic shortcut to be returned by {@link #getShortcuts(ShortcutQuery, UserHandle)}.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
index 3e48f655a..8d01deb10 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyChoreographer.java
@@ -5,13 +5,13 @@ import android.os.Looper;
 import android.os.SystemClock;
 import android.view.Choreographer;
 import android.view.Choreographer.FrameCallback;
+import java.time.Duration;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.SoftThreadLocal;
-import org.robolectric.util.TimeUtils;
 
 /**
  * The {@link Choreographer} shadow for {@link LooperMode.Mode.PAUSED}.
@@ -27,7 +27,7 @@ import org.robolectric.util.TimeUtils;
     isInAndroidSdk = false)
 public class ShadowLegacyChoreographer extends ShadowChoreographer {
   private long nanoTime = 0;
-  private static long FRAME_INTERVAL = 10 * TimeUtils.NANOS_PER_MS; // 10ms
+  private static long FRAME_INTERVAL = Duration.ofMillis(10).toNanos();
   private static final Thread MAIN_THREAD = Thread.currentThread();
   private static SoftThreadLocal<Choreographer> instance = makeThreadLocal();
   private Handler handler = new Handler(Looper.myLooper());
@@ -181,6 +181,8 @@ public class ShadowLegacyChoreographer extends ShadowChoreographer {
       throw new RuntimeException("You should only call this from the main thread!");
     }
     instance = makeThreadLocal();
-    FRAME_INTERVAL = 10 * TimeUtils.NANOS_PER_MS; // 10ms
+    FRAME_INTERVAL = Duration.ofMillis(10).toNanos();
+    postCallbackDelayMillis = 0;
+    postFrameCallbackDelayMillis = 0;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
index bb9cc1264..a0ccefb0c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLegacyTypeface.java
@@ -11,7 +11,6 @@ import static org.robolectric.Shadows.shadowOf;
 
 import android.annotation.SuppressLint;
 import android.content.res.AssetManager;
-import android.graphics.FontFamily;
 import android.graphics.Typeface;
 import android.util.ArrayMap;
 import java.io.File;
@@ -25,6 +24,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -35,12 +35,13 @@ import org.robolectric.res.Fs;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link Typeface}. */
-@Implements(value = Typeface.class, looseSignatures = true, isInAndroidSdk = false)
+@Implements(value = Typeface.class, isInAndroidSdk = false)
 @SuppressLint("NewApi")
 public class ShadowLegacyTypeface extends ShadowTypeface {
   private static final Map<Long, FontDesc> FONTS = Collections.synchronizedMap(new HashMap<>());
@@ -53,13 +54,12 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
     description = findById(fontId);
   }
 
-  @Implementation(minSdk = U.SDK_INT)
-  @InDevelopment
+  @Implementation(minSdk = U.SDK_INT, maxSdk = V.SDK_INT)
   protected void __constructor__(long fontId, String familyName) {
     description = findById(fontId);
   }
 
-  @Implementation(minSdk = V.SDK_INT)
+  @Implementation(minSdk = Baklava.SDK_INT)
   @InDevelopment
   protected void __constructor__(long fontId, String familyName, Typeface derivedFrom) {
     description = findById(fontId);
@@ -130,10 +130,10 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
 
   @Implementation(minSdk = O)
   protected static Typeface createFromResources(
-      Object /* FamilyResourceEntry */ entry,
-      Object /* AssetManager */ mgr,
-      Object /* String */ path) {
-    return createUnderlyingTypeface((String) path, Typeface.NORMAL);
+      @ClassName("android.content.res.FontResourcesParser$FamilyResourceEntry") Object entry,
+      AssetManager mgr,
+      String path) {
+    return createUnderlyingTypeface(path, Typeface.NORMAL);
   }
 
   @Implementation
@@ -170,29 +170,31 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
 
   @HiddenApi
   @Implementation
-  protected static Typeface createFromFamilies(Object /*FontFamily[]*/ families) {
+  protected static Typeface createFromFamilies(
+      @ClassName("android.graphics.FontFamily[]") Object families) {
     return null;
   }
 
   @HiddenApi
   @Implementation(maxSdk = N_MR1)
-  protected static Typeface createFromFamiliesWithDefault(Object /*FontFamily[]*/ families) {
+  protected static Typeface createFromFamiliesWithDefault(
+      @ClassName("android.graphics.FontFamily[]") Object families) {
     return null;
   }
 
   @Implementation(minSdk = O, maxSdk = O_MR1)
   protected static Typeface createFromFamiliesWithDefault(
-      Object /*FontFamily[]*/ families, Object /* int */ weight, Object /* int */ italic) {
+      @ClassName("android.graphics.FontFamily[]") Object families, int weight, int italic) {
     return createUnderlyingTypeface("fake-font", Typeface.NORMAL);
   }
 
   @Implementation(minSdk = P)
   protected static Typeface createFromFamiliesWithDefault(
-      Object /*FontFamily[]*/ families,
-      Object /* String */ fallbackName,
-      Object /* int */ weight,
-      Object /* int */ italic) {
-    return createUnderlyingTypeface((String) fallbackName, Typeface.NORMAL);
+      @ClassName("android.graphics.FontFamily[]") Object families,
+      String fallbackName,
+      int weight,
+      int italic) {
+    return createUnderlyingTypeface(fallbackName, Typeface.NORMAL);
   }
 
   @Implementation(minSdk = P, maxSdk = P)
@@ -200,7 +202,7 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
       String xmlPath,
       String fontDir,
       ArrayMap<String, Typeface> fontMap,
-      ArrayMap<String, FontFamily[]> fallbackMap) {
+      ArrayMap<String, @ClassName("android.graphics.FontFamily[]") Object> fallbackMap) {
     fontMap.put("sans-serif", createUnderlyingTypeface("sans-serif", 0));
   }
 
@@ -211,7 +213,9 @@ public class ShadowLegacyTypeface extends ShadowTypeface {
   @HiddenApi
   @Implementation(minSdk = Q, maxSdk = R)
   protected static void initSystemDefaultTypefaces(
-      Object systemFontMap, Object fallbacks, Object aliases) {}
+      Map<String, Typeface> systemFontMap,
+      Map<String, /*android.graphics.FontFamily[]*/ ?> fallbacks,
+      @ClassName("android.text.FontConfig$Alias[]") Object aliases) {}
 
   @Resetter
   public static synchronized void reset() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLibcoreOsConstants.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLibcoreOsConstants.java
deleted file mode 100644
index 2c2d07312..000000000
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLibcoreOsConstants.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.robolectric.shadows;
-
-import java.lang.reflect.Field;
-import java.util.regex.Pattern;
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
-/** Implements OsConstants on APIs 20 and below. */
-@Implements(className = "libcore.io.OsConstants", maxSdk = 20, isInAndroidSdk = false)
-public final class ShadowLibcoreOsConstants {
-  private static final Pattern ERRNO_PATTERN = Pattern.compile("E[A-Z0-9]+");
-
-  @Implementation
-  protected static void initConstants() {
-    int errnos = 1;
-    try {
-      for (Field field : Class.forName("libcore.io.OsConstants").getDeclaredFields()) {
-        if (ERRNO_PATTERN.matcher(field.getName()).matches() && field.getType() == int.class) {
-          field.setInt(null, errnos++);
-        }
-
-        // Type of file.
-        if (field.getName().equals(OsConstantsValues.S_IFMT)) {
-          field.setInt(null, OsConstantsValues.S_IFMT_VALUE);
-          continue;
-        }
-        // Directory.
-        if (field.getName().equals(OsConstantsValues.S_IFDIR)) {
-          field.setInt(null, OsConstantsValues.S_IFDIR_VALUE);
-          continue;
-        }
-        // Regular file.
-        if (field.getName().equals(OsConstantsValues.S_IFREG)) {
-          field.setInt(null, OsConstantsValues.S_IFREG_VALUE);
-          continue;
-        }
-        // Symbolic link.
-        if (field.getName().equals(OsConstantsValues.S_IFLNK)) {
-          field.setInt(null, OsConstantsValues.S_IFLNK_VALUE);
-        }
-      }
-    } catch (ReflectiveOperationException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLinux.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLinux.java
index 58405af44..ec1c408c0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLinux.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLinux.java
@@ -14,6 +14,9 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.FileChannel;
 import java.time.Duration;
 import libcore.io.Linux;
 import org.robolectric.annotation.Implementation;
@@ -29,7 +32,7 @@ public class ShadowLinux {
 
   @Implementation
   public StructStat stat(String path) throws ErrnoException {
-    int mode = OsConstantsValues.getMode(path);
+    int mode = ShadowOsConstants.getMode(path);
     long size = 0;
     long modifiedTime = 0;
     if (path != null) {
@@ -95,14 +98,18 @@ public class ShadowLinux {
   @Implementation
   protected int pread(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, long offset)
       throws ErrnoException, InterruptedIOException {
-
-    try (FileInputStream fis = new FileInputStream(fd)) {
-      for (long n = offset; n > 0; ) {
-        n -= fis.skip(n);
-      }
-      return fis.read(bytes, byteOffset, byteCount);
+    // explicitly do not close the opened InputStream here, as java's FileDescriptor will close
+    // and become invalid
+    try {
+      FileInputStream is = new FileInputStream(fd);
+      FileChannel channel = is.getChannel();
+      ByteBuffer buf = ByteBuffer.wrap(bytes, byteOffset, byteCount);
+      return channel.read(buf, offset);
+    } catch (AsynchronousCloseException e) {
+      throw new InterruptedIOException(e.getMessage());
     } catch (IOException e) {
-      return -1;
+      // Most likely EIO
+      throw new ErrnoException("pread", OsConstants.EIO, e);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
index 47843b53c..73569da5b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocaleManager.java
@@ -12,15 +12,23 @@ import java.util.Map;
 import java.util.Set;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow of {@link LocaleManager} */
 @Implements(value = LocaleManager.class, minSdk = VERSION_CODES.TIRAMISU, isInAndroidSdk = false)
 public class ShadowLocaleManager {
 
-  private final Map<String, LocaleList> appLocales = new HashMap<>();
-  private final Set<String> packagesInstalledByCaller = new HashSet<>();
-  private boolean enforceInstallerCheck;
+  private static final Map<String, LocaleList> appLocales = new HashMap<>();
+  private static final Set<String> packagesInstalledByCaller = new HashSet<>();
+  private static boolean enforceInstallerCheck;
+
+  @Resetter
+  public static void reset() {
+    appLocales.clear();
+    packagesInstalledByCaller.clear();
+    enforceInstallerCheck = false;
+  }
 
   /**
    * Returns the stored locales from in-memory map for the given package when {@link
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
index dfad4ac83..0859baed8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowLocationManager.java
@@ -57,6 +57,7 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.function.Consumer;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -70,7 +71,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
  * location on, gps provider enabled, network provider disabled.
  */
 @SuppressWarnings("deprecation")
-@Implements(value = LocationManager.class, looseSignatures = true)
+@Implements(value = LocationManager.class)
 public class ShadowLocationManager {
 
   private static final String TAG = "ShadowLocationManager";
@@ -451,8 +452,8 @@ public class ShadowLocationManager {
 
   @Implementation(minSdk = VERSION_CODES.S)
   @Nullable
-  protected Object getProviderProperties(Object providerStr) {
-    String provider = (String) providerStr;
+  protected @ClassName("android.location.provider.ProviderProperties") Object getProviderProperties(
+      String provider) {
     if (provider == null) {
       throw new IllegalArgumentException();
     }
@@ -957,13 +958,13 @@ public class ShadowLocationManager {
 
   @Implementation(minSdk = VERSION_CODES.O)
   protected boolean registerGnssBatchedLocationCallback(
-      Object periodNanos, Object wakeOnFifoFull, Object callback, Object handler) {
+      long periodNanos,
+      boolean wakeOnFifoFull,
+      @ClassName("android.location.BatchedLocationCallback") Object callback,
+      Handler handler) {
     getOrCreateProviderEntry(GPS_PROVIDER)
         .setLegacyBatchedListener(
-            callback,
-            new HandlerExecutor((Handler) handler),
-            gnssBatchSize,
-            (Boolean) wakeOnFifoFull);
+            callback, new HandlerExecutor(handler), gnssBatchSize, wakeOnFifoFull);
     return true;
   }
 
@@ -976,7 +977,8 @@ public class ShadowLocationManager {
   }
 
   @Implementation(minSdk = VERSION_CODES.O)
-  protected boolean unregisterGnssBatchedLocationCallback(Object callback) {
+  protected boolean unregisterGnssBatchedLocationCallback(
+      @ClassName("android.location.BatchedLocationCallback") Object callback) {
     ProviderEntry e = getProviderEntry(GPS_PROVIDER);
     if (e != null) {
       e.clearLegacyBatchedListener();
@@ -1193,9 +1195,19 @@ public class ShadowLocationManager {
   @Implementation(minSdk = VERSION_CODES.R)
   @RequiresApi(api = VERSION_CODES.R)
   protected boolean registerGnssMeasurementsCallback(
-      Object request, Object executor, Object callback) {
-    return registerGnssMeasurementsCallback(
-        (Executor) executor, (GnssMeasurementsEvent.Callback) callback);
+      @ClassName("android.location.GnssRequest") Object request,
+      Executor executor,
+      @ClassName("android.location.GnssMeasurementsEvent$Callback") Object callback) {
+    return registerGnssMeasurementsCallback(executor, (GnssMeasurementsEvent.Callback) callback);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.S, methodName = "registerGnssMeasurementsCallback")
+  @RequiresApi(api = VERSION_CODES.S)
+  protected boolean registerGnssMeasurementsCallbackFromS(
+      @ClassName("android.location.GnssMeasurementRequest") Object request,
+      Executor executor,
+      @ClassName("android.location.GnssMeasurementsEvent$Callback") Object callback) {
+    return registerGnssMeasurementsCallback(executor, (GnssMeasurementsEvent.Callback) callback);
   }
 
   @Implementation(minSdk = VERSION_CODES.R)
@@ -1254,19 +1266,20 @@ public class ShadowLocationManager {
   }
 
   @Implementation(minSdk = VERSION_CODES.R)
-  protected Object registerAntennaInfoListener(Object executor, Object listener) {
+  protected boolean registerAntennaInfoListener(
+      Executor executor, @ClassName("android.location.GnssAntennaInfo$Listener") Object listener) {
     synchronized (gnssAntennaInfoTransports) {
       Iterables.removeIf(
           gnssAntennaInfoTransports, transport -> transport.getListener() == listener);
       gnssAntennaInfoTransports.add(
-          new GnssAntennaInfoListenerTransport(
-              (Executor) executor, (GnssAntennaInfo.Listener) listener));
+          new GnssAntennaInfoListenerTransport(executor, (GnssAntennaInfo.Listener) listener));
     }
     return true;
   }
 
   @Implementation(minSdk = VERSION_CODES.R)
-  protected void unregisterAntennaInfoListener(Object listener) {
+  protected void unregisterAntennaInfoListener(
+      @ClassName("android.location.GnssAntennaInfo$Listener") Object listener) {
     synchronized (gnssAntennaInfoTransports) {
       Iterables.removeIf(
           gnssAntennaInfoTransports, transport -> transport.getListener() == listener);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
index d3e75330c..2bc1d40f5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaCodec.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.concurrent.TimeUnit.MICROSECONDS;
@@ -17,6 +18,7 @@ import android.media.MediaCodecInfo;
 import android.media.MediaCodecList;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
+import android.os.IBinder;
 import android.view.Surface;
 import com.google.common.annotations.VisibleForTesting;
 import java.nio.Buffer;
@@ -29,6 +31,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingDeque;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -52,7 +55,7 @@ import org.robolectric.versioning.AndroidVersions.U;
  * implementation will present an input buffer, which will be copied to an output buffer once
  * queued, which will be subsequently presented to the callback handler.
  */
-@Implements(value = MediaCodec.class, looseSignatures = true)
+@Implements(value = MediaCodec.class)
 public class ShadowMediaCodec {
   private static final int DEFAULT_BUFFER_SIZE = 512;
   @VisibleForTesting static final int BUFFER_COUNT = 10;
@@ -164,16 +167,26 @@ public class ShadowMediaCodec {
     innerConfigure(keys, values, surface, crypto, flags);
   }
 
-  @Implementation(minSdk = O)
+  @Implementation(minSdk = O, maxSdk = O)
   protected void native_configure(
-      Object keys,
-      Object values,
-      Object surface,
-      Object crypto,
-      Object descramblerBinder,
-      Object flags) {
-    innerConfigure(
-        (String[]) keys, (Object[]) values, (Surface) surface, (MediaCrypto) crypto, (int) flags);
+      String[] keys,
+      Object[] values,
+      Surface surface,
+      MediaCrypto crypto,
+      IBinder descramblerBinder,
+      int flags) {
+    innerConfigure(keys, values, surface, crypto, flags);
+  }
+
+  @Implementation(minSdk = O_MR1)
+  protected void native_configure(
+      String[] keys,
+      Object[] values,
+      Surface surface,
+      MediaCrypto crypto,
+      @ClassName("android.os.IHwBinder") Object descramblerBinder,
+      int flags) {
+    innerConfigure(keys, values, surface, crypto, flags);
   }
 
   private void innerConfigure(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
index cc83a7f63..e63abfd70 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaPlayer.java
@@ -17,6 +17,7 @@ import static org.robolectric.shadows.ShadowMediaPlayer.State.PREPARING;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.STARTED;
 import static org.robolectric.shadows.ShadowMediaPlayer.State.STOPPED;
 import static org.robolectric.shadows.util.DataSource.toDataSource;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.NonNull;
 import android.content.Context;
@@ -49,6 +50,8 @@ import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.util.DataSource;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /**
@@ -407,6 +410,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
   private int audioStreamType;
   private boolean looping;
   private int pendingSeek = -1;
+  private AudioAttributes audioAttributes;
 
   /** Various source variables from setDataSource() */
   private Uri sourceUri;
@@ -538,6 +542,7 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     if (mp != null) {
       ShadowMediaPlayer shadow = Shadow.extract(mp);
       shadow.audioSessionId = audioSessionId;
+      mp.setAudioAttributes(audioAttributes);
     }
     return mp;
   }
@@ -1179,6 +1184,15 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     audioSessionId = sessionId;
   }
 
+  @Implementation
+  protected void setAudioAttributes(AudioAttributes audioAttributes) {
+    if (audioAttributes == null) {
+      throw new IllegalArgumentException("AudioAttributes must not be null");
+    }
+    reflector(MediaPlayerBaseReflector.class, player).setAudioAttributes(audioAttributes);
+    this.audioAttributes = audioAttributes;
+  }
+
   private static final EnumSet<State> nonPlayingStates = EnumSet.of(IDLE, INITIALIZED, STOPPED);
 
   @Implementation
@@ -1401,6 +1415,15 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     return auxEffect;
   }
 
+  /**
+   * Retrieves the currently set {@link AudioAttributes}.
+   *
+   * @return The current {@link AudioAttributes}.
+   */
+  public AudioAttributes getAudioAttributes() {
+    return audioAttributes;
+  }
+
   /**
    * Retrieves the pending seek setting.
    *
@@ -1573,6 +1596,12 @@ public class ShadowMediaPlayer extends ShadowPlayerBase {
     }
   }
 
+  @ForType(MediaPlayer.class)
+  interface MediaPlayerBaseReflector {
+    @Direct
+    void setAudioAttributes(AudioAttributes attributes);
+  }
+
   @Resetter
   public static void resetStaticState() {
     createListener = null;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
index c16bf6fb5..b0efe2f51 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowMediaSessionManager.java
@@ -19,14 +19,15 @@ import java.util.concurrent.CopyOnWriteArraySet;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link MediaSessionManager}. */
 @Implements(value = MediaSessionManager.class)
 public class ShadowMediaSessionManager {
-  private final List<MediaController> controllers = new CopyOnWriteArrayList<>();
-  private final Set<OnActiveSessionsChangedListener> listeners = new CopyOnWriteArraySet<>();
+  private static final List<MediaController> controllers = new CopyOnWriteArrayList<>();
+  private static final Set<OnActiveSessionsChangedListener> listeners = new CopyOnWriteArraySet<>();
   @RealObject MediaSessionManager realMediaSessionManager;
 
   @Implementation(minSdk = S)
@@ -87,6 +88,12 @@ public class ShadowMediaSessionManager {
     }
   }
 
+  @Resetter
+  public static void reset() {
+    controllers.clear();
+    listeners.clear();
+  }
+
   @ForType(MediaSessionManager.class)
   interface MediaSessionManagerReflector {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
index e3a9aaad8..509b57066 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAllocationRegistry.java
@@ -15,8 +15,8 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 import org.robolectric.versioning.AndroidVersions.U;
-import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link NativeAllocationRegistry} that is backed by native code */
 @Implements(
@@ -36,7 +36,7 @@ public class ShadowNativeAllocationRegistry {
    * behavior of actual class.
    */
   @InDevelopment
-  @Implementation(minSdk = V.SDK_INT)
+  @Implementation(minSdk = Baklava.SDK_INT)
   protected void __constructor__(
       ClassLoader classLoader,
       Class clazz,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java
index c09281f0a..d49e8a23f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeApkAssets.java
@@ -4,11 +4,13 @@ import static org.robolectric.shadows.ShadowArscApkAssets9.FRAMEWORK_APK_PATH;
 
 import android.content.res.ApkAssets;
 import android.content.res.loader.AssetsProvider;
-import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.PerfStatsCollector;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.V;
@@ -20,18 +22,44 @@ import org.robolectric.versioning.AndroidVersions.V;
     shadowPicker = ShadowApkAssets.Picker.class,
     isInAndroidSdk = false)
 public class ShadowNativeApkAssets extends ShadowApkAssets {
+
+  // cached native apk assets.
+  // native resources currently cannot use the cross-sandbox ApkAssetsCache cache
+  // because each sandbox currently loads its own copy of the native runtime
+  private static final Map<String, Long> cachedApkAssetsPtrs = new HashMap<>();
+
   @Implementation
-  protected static long nativeLoad(int format, String path, int flags, AssetsProvider asset)
-      throws IOException {
+  protected static long nativeLoad(int format, String path, int flags, AssetsProvider asset) {
+    boolean system = false;
     if (path.equals(FRAMEWORK_APK_PATH)) {
       path = RuntimeEnvironment.getAndroidFrameworkJarPath().toString();
+      system = true;
+    }
+    if (cachedApkAssetsPtrs.containsKey(path)) {
+      return cachedApkAssetsPtrs.get(path);
     }
-    return ReflectionHelpers.callStaticMethod(
-        ApkAssets.class,
-        Shadow.directNativeMethodName(ApkAssets.class.getName(), "nativeLoad"),
-        ClassParameter.from(int.class, format),
-        ClassParameter.from(String.class, path),
-        ClassParameter.from(int.class, flags),
-        ClassParameter.from(AssetsProvider.class, asset));
+    final String adjustedPath = path;
+    return PerfStatsCollector.getInstance()
+        .measure(
+            "load native " + (system ? "framework" : "app") + " resources",
+            () -> {
+              long ptr =
+                  ReflectionHelpers.callStaticMethod(
+                      ApkAssets.class,
+                      Shadow.directNativeMethodName(ApkAssets.class.getName(), "nativeLoad"),
+                      ClassParameter.from(int.class, format),
+                      ClassParameter.from(String.class, adjustedPath),
+                      ClassParameter.from(int.class, flags),
+                      ClassParameter.from(AssetsProvider.class, asset));
+              if (ptr > 0) {
+                cachedApkAssetsPtrs.put(adjustedPath, ptr);
+              }
+              return ptr;
+            });
+  }
+
+  @Implementation
+  protected static void nativeDestroy(long ptr) {
+    // ignoring nativeDestroy in order to cache assets across tests
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetInputStream.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetInputStream.java
new file mode 100644
index 000000000..06d6a6408
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetInputStream.java
@@ -0,0 +1,23 @@
+package org.robolectric.shadows;
+
+import android.content.res.AssetManager.AssetInputStream;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowAssetInputStream.Picker;
+
+@Implements(
+    value = AssetInputStream.class,
+    shadowPicker = Picker.class,
+    callNativeMethodsByDefault = true)
+public class ShadowNativeAssetInputStream extends ShadowAssetInputStream {
+
+  private boolean ninePatch;
+
+  @Override
+  boolean isNinePatch() {
+    return ninePatch;
+  }
+
+  void setNinePatch(boolean b) {
+    this.ninePatch = true;
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java
index 2e9959dcb..d617965b6 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeAssetManager.java
@@ -1,9 +1,27 @@
 package org.robolectric.shadows;
 
+import static org.robolectric.util.reflector.Reflector.reflector;
+
 import android.content.res.AssetManager;
+import android.content.res.AssetManager.AssetInputStream;
+import android.content.res.XmlBlock;
+import android.util.TypedValue;
+import dalvik.system.VMRuntime;
+import java.io.InputStream;
 import java.nio.file.Path;
 import java.util.Collection;
+import java.util.Locale;
+import java.util.Objects;
+import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.ReflectorObject;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.PerfStatsCollector;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @Implements(
@@ -13,6 +31,8 @@ import org.robolectric.versioning.AndroidVersions.V;
     shadowPicker = ShadowAssetManager.Picker.class)
 public class ShadowNativeAssetManager extends ShadowAssetManager {
 
+  @ReflectorObject private AssetManagerReflector assetManagerReflector;
+
   @Override
   Collection<Path> getAllAssetDirs() {
     throw new UnsupportedOperationException();
@@ -22,4 +42,114 @@ public class ShadowNativeAssetManager extends ShadowAssetManager {
   long getNativePtr() {
     throw new UnsupportedOperationException();
   }
+
+  @Implementation
+  protected InputStream open(String fileName, int accessMode) {
+    // intercept real method to handle nine patch for LEGACY graphics mode
+    InputStream is = assetManagerReflector.open(fileName, accessMode);
+    setNinePatch(fileName, is);
+    return is;
+  }
+
+  private static void setNinePatch(String fileName, InputStream is) {
+    if (is instanceof AssetInputStream) {
+      ShadowNativeAssetInputStream snais = Shadow.extract(is);
+      // this is a dubious assumption, but this is the logic with BINARY resources mode:
+      // assume nine patch based on file name
+      if (fileName != null && fileName.toLowerCase(Locale.ENGLISH).endsWith(".9.png")) {
+        snais.setNinePatch(true);
+      }
+    }
+  }
+
+  @Implementation
+  protected InputStream openNonAsset(int cookie, String fileName, int accessMode) {
+    // intercept real method to handle nine patch for LEGACY graphics mode
+    InputStream is = assetManagerReflector.openNonAsset(cookie, fileName, accessMode);
+    setNinePatch(fileName, is);
+    return is;
+  }
+
+  /**
+   * Use a similar implementation as applyStyle$ravenwood as workaround for allocating pinned
+   * (non-movable) array objects.
+   */
+  @Implementation
+  protected void applyStyle(
+      long themePtr,
+      int defStyleAttr,
+      int defStyleRes,
+      XmlBlock.Parser parser,
+      int[] inAttrs,
+      long outValuesAddress,
+      long outIndicesAddress) {
+    Objects.requireNonNull(inAttrs, "inAttrs");
+    PerfStatsCollector.getInstance()
+        .measure(
+            "native applyStyle",
+            () -> {
+              ShadowVMRuntime shadowVmRuntime = Shadow.extract(VMRuntime.getRuntime());
+              int[] outValues = (int[]) shadowVmRuntime.getObjectForAddress(outValuesAddress);
+              int[] outIndices = (int[]) shadowVmRuntime.getObjectForAddress(outIndicesAddress);
+              synchronized (this) {
+                // Need to synchronize on AssetManager because we will be accessing
+                // the native implementation of AssetManager.
+                assetManagerReflector.ensureValidLocked();
+                long xmlParserPtr =
+                    parser != null
+                        ? reflector(XmlBlockParserReflector.class, parser).getParseState()
+                        : 0;
+                ReflectionHelpers.callStaticMethod(
+                    AssetManager.class,
+                    Shadow.directNativeMethodName(
+                        AssetManager.class.getName(), "nativeApplyStyleWithArray"),
+                    ClassParameter.from(long.class, assetManagerReflector.getObject()),
+                    ClassParameter.from(long.class, themePtr),
+                    ClassParameter.from(int.class, defStyleAttr),
+                    ClassParameter.from(int.class, defStyleRes),
+                    ClassParameter.from(long.class, xmlParserPtr),
+                    ClassParameter.from(int[].class, inAttrs),
+                    ClassParameter.from(int[].class, outValues),
+                    ClassParameter.from(int[].class, outIndices));
+              }
+            });
+  }
+
+  @Implementation
+  protected static int nativeGetResourceValue(
+      long ptr, int resid, short density, TypedValue typed_value, boolean resolve_references) {
+    return PerfStatsCollector.getInstance()
+        .measure(
+            "native nativeGetResourceValue",
+            () ->
+                ReflectionHelpers.callStaticMethod(
+                    AssetManager.class,
+                    Shadow.directNativeMethodName(
+                        AssetManager.class.getName(), "nativeGetResourceValue"),
+                    ClassParameter.from(long.class, ptr),
+                    ClassParameter.from(int.class, resid),
+                    ClassParameter.from(short.class, density),
+                    ClassParameter.from(TypedValue.class, typed_value),
+                    ClassParameter.from(boolean.class, resolve_references)));
+  }
+
+  @ForType(AssetManager.class)
+  interface AssetManagerReflector {
+    @Accessor("mObject")
+    long getObject();
+
+    void ensureValidLocked();
+
+    @Direct
+    InputStream open(String fileName, int accessMode);
+
+    @Direct
+    InputStream openNonAsset(int cookie, String fileName, int accessMode);
+  }
+
+  @ForType(XmlBlock.Parser.class)
+  interface XmlBlockParserReflector {
+    @Accessor("mParseState")
+    long getParseState();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
index 4ab416812..53eacaf45 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeBitmap.java
@@ -25,6 +25,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -41,7 +42,6 @@ import org.robolectric.versioning.AndroidVersions.V;
 /** Shadow for {@link Bitmap} that is backed by native code */
 @Implements(
     value = Bitmap.class,
-    looseSignatures = true,
     minSdk = O,
     isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
@@ -121,12 +121,17 @@ public class ShadowNativeBitmap extends ShadowBitmap {
     return BitmapNatives.nativeGetNativeFinalizer();
   }
 
-  @Implementation(maxSdk = U.SDK_INT)
-  protected static Object nativeRecycle(Object nativeBitmap) {
-    BitmapNatives.nativeRecycle((long) nativeBitmap);
+  @Implementation(maxSdk = P, methodName = "nativeRecycle")
+  protected static boolean nativeRecyclePreQ(long nativeBitmap) {
+    BitmapNatives.nativeRecycle(nativeBitmap);
     return true;
   }
 
+  @Implementation(minSdk = Q, maxSdk = U.SDK_INT)
+  protected static void nativeRecycle(long nativeBitmap) {
+    BitmapNatives.nativeRecycle(nativeBitmap);
+  }
+
   @Implementation(minSdk = O, maxSdk = U.SDK_INT)
   protected static void nativeReconfigure(
       long nativeBitmap, int width, int height, int config, boolean isPremultiplied) {
@@ -351,7 +356,8 @@ public class ShadowNativeBitmap extends ShadowBitmap {
    * method must be present in Android U and below to avoid an UnsatisfiedLinkError.
    */
   @Implementation(minSdk = U.SDK_INT)
-  protected static Object nativeExtractGainmap(Object nativePtr) {
+  protected static @ClassName("android.graphics.Gainmap") Object nativeExtractGainmap(
+      long nativePtr) {
     // No-op implementation
     return null;
   }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCanvas.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCanvas.java
index 788199ad1..1ee241e4d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCanvas.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeCanvas.java
@@ -1,6 +1,7 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
@@ -13,6 +14,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.CanvasNatives;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
+import org.robolectric.nativeruntime.HardwareRendererNatives;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for {@link Canvas} that is backed by native code */
@@ -200,6 +202,11 @@ public class ShadowNativeCanvas extends ShadowNativeBaseCanvas {
     return CanvasNatives.nQuickReject(nativeCanvas, left, top, right, bottom);
   }
 
+  @Implementation(minSdk = O, maxSdk = O_MR1)
+  protected static void nSetHighContrastText(long renderer, boolean highContrastText) {
+    HardwareRendererNatives.nSetHighContrastText(highContrastText);
+  }
+
   /**
    * In Android P and below, Canvas.saveUnclippedLayer called {@link
    * ShadowNativeCanvas#nSaveLayer(long, float, float, float, float, long)}.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
index 3b9a67e2b..2ca5fbf7a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeHardwareRenderer.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.S_V2;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 
 import android.content.pm.ActivityInfo;
 import android.graphics.Bitmap;
@@ -22,6 +23,7 @@ import android.media.Image.Plane;
 import android.media.ImageReader;
 import android.view.Surface;
 import java.io.FileDescriptor;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -34,7 +36,6 @@ import org.robolectric.versioning.AndroidVersions.U;
 @Implements(
     value = HardwareRenderer.class,
     minSdk = Q,
-    looseSignatures = true,
     shadowPicker = Picker.class,
     callNativeMethodsByDefault = true)
 public class ShadowNativeHardwareRenderer {
@@ -53,6 +54,11 @@ public class ShadowNativeHardwareRenderer {
     return HardwareRendererNatives.isWebViewOverlaysEnabled();
   }
 
+  @Implementation(minSdk = TIRAMISU, maxSdk = U.SDK_INT)
+  protected static boolean nIsDrawingEnabled() {
+    return true;
+  }
+
   @Implementation(maxSdk = U.SDK_INT)
   protected static void setupShadersDiskCache(String cacheFile, String skiaCacheFile) {
     HardwareRendererNatives.setupShadersDiskCache(cacheFile, skiaCacheFile);
@@ -79,9 +85,9 @@ public class ShadowNativeHardwareRenderer {
     return HardwareRendererNatives.nCreateRootRenderNode();
   }
 
-  @Implementation(minSdk = S, maxSdk = U.SDK_INT)
-  protected static long nCreateProxy(boolean translucent, long rootRenderNode) {
-    return HardwareRendererNatives.nCreateProxy(translucent, rootRenderNode);
+  @Implementation(minSdk = S, maxSdk = U.SDK_INT, methodName = "nCreateProxy")
+  protected static long nCreateProxyPostR(boolean translucent, long rootRenderNode) {
+    return nCreateProxy(translucent, rootRenderNode);
   }
 
   @Implementation(minSdk = R, maxSdk = R)
@@ -91,8 +97,8 @@ public class ShadowNativeHardwareRenderer {
   }
 
   @Implementation(minSdk = Q, maxSdk = Q)
-  protected static Object nCreateProxy(Object translucent, Object rootRenderNode) {
-    return nCreateProxy((boolean) translucent, (long) rootRenderNode);
+  protected static long nCreateProxy(boolean translucent, long rootRenderNode) {
+    return HardwareRendererNatives.nCreateProxy(translucent, rootRenderNode);
   }
 
   @Implementation(maxSdk = U.SDK_INT)
@@ -120,9 +126,9 @@ public class ShadowNativeHardwareRenderer {
     HardwareRendererNatives.nSetSurface(nativeProxy, window, discardBuffer);
   }
 
-  @Implementation(minSdk = S, maxSdk = U.SDK_INT)
+  @Implementation(minSdk = S)
   protected static void nSetSurfaceControl(long nativeProxy, long nativeSurfaceControl) {
-    HardwareRendererNatives.nSetSurfaceControl(nativeProxy, nativeSurfaceControl);
+    // SurfaceControl is not in RNG
   }
 
   @Implementation(maxSdk = U.SDK_INT)
@@ -152,10 +158,15 @@ public class ShadowNativeHardwareRenderer {
     HardwareRendererNatives.nSetOpaque(nativeProxy, opaque);
   }
 
-  @Implementation(minSdk = S, maxSdk = U.SDK_INT)
-  protected static Object nSetColorMode(long nativeProxy, int colorMode) {
+  @Implementation(minSdk = S, maxSdk = TIRAMISU)
+  protected static void nSetColorMode(long nativeProxy, int colorMode) {
+    HardwareRendererNatives.nSetColorMode(nativeProxy, colorMode);
+  }
+
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE, methodName = "nSetColorMode")
+  protected static float nSetColorModePostT(long nativeProxy, int colorMode) {
     HardwareRendererNatives.nSetColorMode(nativeProxy, colorMode);
-    return null;
+    return 0.0f;
   }
 
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
@@ -281,18 +292,20 @@ public class ShadowNativeHardwareRenderer {
   }
 
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
-  protected static void nSetASurfaceTransactionCallback(Object nativeProxy, Object callback) {
-    // Requires looseSignatures because ASurfaceTransactionCallback is S+.
+  protected static void nSetASurfaceTransactionCallback(
+      long nativeProxy,
+      @ClassName("android.graphics.HardwareRenderer$ASurfaceTransactionCallback") Object callback) {
     HardwareRendererNatives.nSetASurfaceTransactionCallback(
-        (long) nativeProxy, (ASurfaceTransactionCallback) callback);
+        nativeProxy, (ASurfaceTransactionCallback) callback);
   }
 
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
   protected static void nSetPrepareSurfaceControlForWebviewCallback(
-      Object nativeProxy, Object callback) {
-    // Need to use loose signatures here as PrepareSurfaceControlForWebviewCallback is S+.
+      long nativeProxy,
+      @ClassName("android.graphics.HardwareRenderer$PrepareSurfaceControlForWebviewCallback")
+          Object callback) {
     HardwareRendererNatives.nSetPrepareSurfaceControlForWebviewCallback(
-        (long) nativeProxy, (PrepareSurfaceControlForWebviewCallback) callback);
+        nativeProxy, (PrepareSurfaceControlForWebviewCallback) callback);
   }
 
   @Implementation(maxSdk = U.SDK_INT)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
index cfdc06eae..0598c047b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReader.java
@@ -30,7 +30,6 @@ import org.robolectric.versioning.AndroidVersions.V;
 @Implements(
     value = ImageReader.class,
     minSdk = P,
-    looseSignatures = true,
     isInAndroidSdk = false,
     shadowPicker = Picker.class,
     callNativeMethodsByDefault = true)
@@ -127,10 +126,10 @@ public class ShadowNativeImageReader {
     return natives.nativeImageSetup(i);
   }
 
-  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
-  protected Object nativeImageSetup(Object i) {
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT, methodName = "nativeImageSetup")
+  protected int nativeImageSetupPostT(Image i) {
     // Note: reverted to Q-S API
-    return natives.nativeImageSetup((Image) i);
+    return natives.nativeImageSetup(i);
   }
 
   /** We use a class initializer to allow the native code to cache some field offsets. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
index e9db53cac..328e2f81d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeImageReaderSurfaceImage.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S;
 
 import android.hardware.HardwareBuffer;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -16,7 +17,6 @@ import org.robolectric.versioning.AndroidVersions.U;
 @Implements(
     className = "android.media.ImageReader$SurfaceImage",
     minSdk = P,
-    looseSignatures = true,
     isInAndroidSdk = false,
     shadowPicker = ShadowNativeImageReaderSurfaceImage.Picker.class,
     callNativeMethodsByDefault = true)
@@ -25,17 +25,17 @@ public class ShadowNativeImageReaderSurfaceImage {
   @RealObject private Object realSurfaceImage;
 
   @Implementation(maxSdk = R)
-  protected synchronized /*SurfacePlane[]*/ Object nativeCreatePlanes(
-      /*int*/ Object numPlanes, /*int*/ Object readerFormat) {
+  protected synchronized @ClassName("android.media.ImageReader$SurfaceImage$SurfacePlane[]") Object
+      nativeCreatePlanes(int numPlanes, int readerFormat) {
     return ImageReaderSurfaceImageNatives.nativeSurfaceImageCreatePlanes(
-        realSurfaceImage, (int) numPlanes, (int) readerFormat, /* readerUsage= */ 0);
+        realSurfaceImage, numPlanes, readerFormat, /* readerUsage= */ 0);
   }
 
   @Implementation(minSdk = S, maxSdk = U.SDK_INT)
-  protected synchronized /*SurfacePlane[]*/ Object nativeCreatePlanes(
-      /*int*/ Object numPlanes, /*int*/ Object readerFormat, /*long*/ Object readerUsage) {
+  protected synchronized @ClassName("android.media.ImageReader$SurfaceImage$SurfacePlane[]") Object
+      nativeCreatePlanes(int numPlanes, int readerFormat, long readerUsage) {
     return ImageReaderSurfaceImageNatives.nativeSurfaceImageCreatePlanes(
-        realSurfaceImage, (int) numPlanes, (int) readerFormat, (long) readerUsage);
+        realSurfaceImage, numPlanes, readerFormat, readerUsage);
   }
 
   @Implementation(maxSdk = U.SDK_INT)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
index 7d2dda662..2ca0ce80f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePaint.java
@@ -23,7 +23,6 @@ import org.robolectric.versioning.AndroidVersions.U;
 @Implements(
     minSdk = O,
     value = Paint.class,
-    looseSignatures = true,
     shadowPicker = Picker.class,
     isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
@@ -523,9 +522,9 @@ public class ShadowNativePaint {
     PaintNatives.nSetTypeface(paintPtr, typeface);
   }
 
-  @Implementation(minSdk = O, maxSdk = O_MR1)
-  protected static Object nSetTypeface(Object paintPtr, Object typeface) {
-    PaintNatives.nSetTypeface((long) paintPtr, (long) typeface);
+  @Implementation(minSdk = O, maxSdk = O_MR1, methodName = "nSetTypeface")
+  protected static long nSetTypefacePrePie(long paintPtr, long typeface) {
+    PaintNatives.nSetTypeface(paintPtr, typeface);
     return paintPtr;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePath.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePath.java
index a5c9d2f8e..1a3468aae 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePath.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativePath.java
@@ -94,6 +94,17 @@ public class ShadowNativePath extends ShadowPath {
     PathNatives.nRQuadTo(nPath, dx1, dy1, dx2, dy2);
   }
 
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static void nConicTo(long nPath, float x1, float y1, float x2, float y2, float weight) {
+    PathNatives.nConicTo(nPath, x1, y1, x2, y2, weight);
+  }
+
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static void nRConicTo(
+      long nPath, float dx1, float dy1, float dx2, float dy2, float weight) {
+    PathNatives.nRConicTo(nPath, dx1, dy1, dx2, dy2, weight);
+  }
+
   @Implementation(minSdk = O, maxSdk = U.SDK_INT)
   protected static void nCubicTo(
       long nPath, float x1, float y1, float x2, float y2, float x3, float y3) {
@@ -245,9 +256,20 @@ public class ShadowNativePath extends ShadowPath {
     return PathNatives.nApproximate(nPath, error);
   }
 
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static boolean nInterpolate(
+      long startPath, long endPath, float t, long interpolatedPath) {
+    return PathNatives.nInterpolate(startPath, endPath, t, interpolatedPath);
+  }
+
   @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
   protected static int nGetGenerationID(long nativePath) {
-    return 0;
+    return PathNatives.nGetGenerationID(nativePath);
+  }
+
+  @Implementation(minSdk = U.SDK_INT, maxSdk = U.SDK_INT)
+  protected static boolean nIsInterpolatable(long startPath, long endPath) {
+    return PathNatives.nIsInterpolatable(startPath, endPath);
   }
 
   @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeAnimatorQ.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeAnimatorQ.java
index f83378285..5821e646c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeAnimatorQ.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeAnimatorQ.java
@@ -3,6 +3,7 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.Q;
 
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -17,7 +18,6 @@ import org.robolectric.shadows.ShadowNativeRenderNodeAnimatorQ.Picker;
     className = "android.view.RenderNodeAnimator",
     minSdk = O,
     maxSdk = Q,
-    looseSignatures = true,
     shadowPicker = Picker.class)
 public class ShadowNativeRenderNodeAnimatorQ {
   @Implementation
@@ -77,8 +77,9 @@ public class ShadowNativeRenderNodeAnimatorQ {
   }
 
   @Implementation
-  protected static void nSetListener(Object animPtr, Object listener) {
-    RenderNodeAnimatorNatives.nSetListener((long) animPtr, listener);
+  protected static void nSetListener(
+      long animPtr, @ClassName("android.view.RenderNodeAnimator") Object listener) {
+    RenderNodeAnimatorNatives.nSetListener(animPtr, listener);
   }
 
   @Implementation
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeOP.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeOP.java
index 0875a98d4..01a9c201e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeOP.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeRenderNodeOP.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.P;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.graphics.Canvas;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -19,7 +20,6 @@ import org.robolectric.util.reflector.ForType;
     className = "android.view.RenderNode",
     minSdk = O,
     maxSdk = P,
-    looseSignatures = true,
     shadowPicker = Picker.class)
 public class ShadowNativeRenderNodeOP {
   @RealObject Object realRenderNode;
@@ -371,7 +371,7 @@ public class ShadowNativeRenderNodeOP {
   // To bridge the two implementations, the end(..) function here uses the API Q+ version so that
   // the RenderNode is marked as valid when isValid() is called.
   @Implementation
-  protected void end(Object canvas) {
+  protected void end(@ClassName("android.view.DisplayListCanvas") Object canvas) {
     long nativeRenderNode =
         reflector(RenderNodeOpReflector.class, realRenderNode).getNativeRenderNode();
     long nativeCanvasWrapper = reflector(CanvasReflector.class, canvas).getNativeCanvasWrapper();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStaticLayout.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStaticLayout.java
index e965bde03..ecb59926f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStaticLayout.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeStaticLayout.java
@@ -10,6 +10,7 @@ import android.text.StaticLayout;
 import android.text.TextPaint;
 import java.nio.ByteBuffer;
 import java.util.Locale;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -30,7 +31,6 @@ import org.robolectric.util.reflector.ForType;
     value = StaticLayout.class,
     minSdk = O,
     maxSdk = P,
-    looseSignatures = true,
     shadowPicker = ShadowNativeStaticLayout.Picker.class)
 public class ShadowNativeStaticLayout {
 
@@ -55,50 +55,46 @@ public class ShadowNativeStaticLayout {
     LineBreakerNatives.nFinishP(nativePtr);
   }
 
-  /**
-   * This has to use looseSignatures due to {@code recycle} param with non-public type {@code
-   * android.text.StaticLayout$LineBreaks}.
-   */
   @Implementation(minSdk = P, maxSdk = P)
   protected static int nComputeLineBreaks(
-      Object nativePtr,
-      Object text,
-      Object measuredTextPtr,
-      Object length,
-      Object firstWidth,
-      Object firstWidthLineCount,
-      Object restWidth,
-      Object variableTabStopsObject,
-      Object defaultTabStop,
-      Object indentsOffset,
-      Object recycle,
-      Object recycleLength,
-      Object recycleBreaks,
-      Object recycleWidths,
-      Object recycleAscents,
-      Object recycleDescents,
-      Object recycleFlags,
-      Object charWidths) {
+      long nativePtr,
+      char[] text,
+      long measuredTextPtr,
+      int length,
+      float firstWidth,
+      int firstWidthLineCount,
+      float restWidth,
+      int[] variableTabStopsObject,
+      int defaultTabStop,
+      int indentsOffset,
+      @ClassName("android.text.StaticLayout$LineBreaks") Object recycle,
+      int recycleLength,
+      int[] recycleBreaks,
+      float[] recycleWidths,
+      float[] recycleAscents,
+      float[] recycleDescents,
+      int[] recycleFlags,
+      float[] charWidths) {
 
     return LineBreakerNatives.nComputeLineBreaksP(
-        (long) nativePtr,
-        (char[]) text,
-        (long) measuredTextPtr,
-        (int) length,
-        (float) firstWidth,
-        (int) firstWidthLineCount,
-        (float) restWidth,
-        intsToFloat((int[]) variableTabStopsObject),
+        nativePtr,
+        text,
+        measuredTextPtr,
+        length,
+        firstWidth,
+        firstWidthLineCount,
+        restWidth,
+        intsToFloat(variableTabStopsObject),
         ((Number) defaultTabStop).floatValue(),
-        (int) indentsOffset,
+        indentsOffset,
         recycle,
-        (int) recycleLength,
-        (int[]) recycleBreaks,
-        (float[]) recycleWidths,
-        (float[]) recycleAscents,
-        (float[]) recycleDescents,
-        (int[]) recycleFlags,
-        (float[]) charWidths);
+        recycleLength,
+        recycleBreaks,
+        recycleWidths,
+        recycleAscents,
+        recycleDescents,
+        recycleFlags,
+        charWidths);
   }
 
   @Implementation(minSdk = O, maxSdk = O_MR1)
@@ -203,24 +199,20 @@ public class ShadowNativeStaticLayout {
     MeasuredTextBuilderNatives.nFreeBuilder(setup.measuredTextBuilderPtr);
   }
 
-  /**
-   * This has to use looseSignatures due to {@code recycle} param with non-public type {@code
-   * android.text.StaticLayout$LineBreaks}.
-   */
   @Implementation(maxSdk = O_MR1)
   protected static int nComputeLineBreaks(
-      Object /*long*/ nativePtr,
-      Object /*LineBreaks*/ recycle,
-      Object /*int[]*/ recycleBreaksObject,
-      Object /*float[]*/ recycleWidthsObject,
-      Object /*int[]*/ recycleFlagsObject,
-      Object /*int*/ recycleLength) {
-
-    int[] recycleBreaks = (int[]) recycleBreaksObject;
-    float[] recycleWidths = (float[]) recycleWidthsObject;
-    int[] recycleFlags = (int[]) recycleFlagsObject;
-
-    NativeStaticLayoutSetup setup = nativeObjectRegistry.getNativeObject((long) nativePtr);
+      long nativePtr,
+      @ClassName("android.text.StaticLayout$LineBreaks") Object recycle,
+      int[] recycleBreaksObject,
+      float[] recycleWidthsObject,
+      int[] recycleFlagsObject,
+      int recycleLength) {
+
+    int[] recycleBreaks = recycleBreaksObject;
+    float[] recycleWidths = recycleWidthsObject;
+    int[] recycleFlags = recycleFlagsObject;
+
+    NativeStaticLayoutSetup setup = nativeObjectRegistry.getNativeObject(nativePtr);
 
     long lineBreakerBuilderPtr =
         LineBreakerNatives.nInit(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
index 5e5759a31..73e32653a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeThreadedRenderer.java
@@ -13,6 +13,7 @@ import android.media.Image.Plane;
 import android.media.ImageReader;
 import android.view.Surface;
 import android.view.ThreadedRenderer;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -22,12 +23,7 @@ import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.WithType;
 
 /** Shadow for {@link ThreadedRenderer} that is backed by native code */
-@Implements(
-    value = ThreadedRenderer.class,
-    minSdk = O,
-    maxSdk = P,
-    shadowPicker = Picker.class,
-    looseSignatures = true)
+@Implements(value = ThreadedRenderer.class, minSdk = O, maxSdk = P, shadowPicker = Picker.class)
 public class ShadowNativeThreadedRenderer {
 
   // ThreadedRenderer specific functions. These do not exist in HardwareRenderer
@@ -190,9 +186,10 @@ public class ShadowNativeThreadedRenderer {
   }
 
   @Implementation(minSdk = P, maxSdk = P)
-  protected static Object createHardwareBitmap(Object renderNode, Object width, Object height) {
+  protected static Bitmap createHardwareBitmap(
+      @ClassName("android.view.RenderNode") Object renderNode, int width, int height) {
     try (ImageReader imageReader =
-        ImageReader.newInstance((int) width, (int) height, PixelFormat.RGBA_8888, 1)) {
+        ImageReader.newInstance(width, height, PixelFormat.RGBA_8888, 1)) {
       Surface surface = imageReader.getSurface();
       Canvas canvas = surface.lockHardwareCanvas();
       reflector(DisplayListCanvasReflector.class, canvas).drawRenderNode(renderNode);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
index 186b56353..eb106444b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNativeTypeface.java
@@ -25,6 +25,7 @@ import java.nio.channels.FileChannel;
 import java.util.List;
 import java.util.Map;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.nativeruntime.DefaultNativeRuntimeLoader;
@@ -38,7 +39,6 @@ import org.robolectric.versioning.AndroidVersions.U;
 /** Shadow for {@link Typeface} that is backed by native code */
 @Implements(
     value = Typeface.class,
-    looseSignatures = true,
     minSdk = O,
     isInAndroidSdk = false,
     callNativeMethodsByDefault = true)
@@ -92,9 +92,10 @@ public class ShadowNativeTypeface extends ShadowTypeface {
 
   @SuppressWarnings("unchecked")
   @Implementation(minSdk = O, maxSdk = O_MR1)
-  protected static Object makeFamilyFromParsed(Object family, Object bufferForPathMap) {
+  protected static @ClassName("android.graphics.FontFamily") Object makeFamilyFromParsed(
+      @ClassName("android.text.FontConfig$Family") Object family,
+      Map<String, ByteBuffer> bufferForPath) {
     FontConfigFamilyReflector reflector = reflector(FontConfigFamilyReflector.class, family);
-    Map<String, ByteBuffer> bufferForPath = (Map<String, ByteBuffer>) bufferForPathMap;
 
     FontFamily fontFamily =
         Shadow.newInstance(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
index a09112060..8908e409f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkCapabilities.java
@@ -4,6 +4,8 @@ import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
 import static android.os.Build.VERSION_CODES.O;
+import static android.os.Build.VERSION_CODES.O_MR1;
+import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.S;
 import static org.robolectric.util.reflector.Reflector.reflector;
@@ -22,7 +24,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Robolectric provides overrides for fetching and updating transport. */
-@Implements(value = NetworkCapabilities.class, looseSignatures = true)
+@Implements(value = NetworkCapabilities.class)
 public class ShadowNetworkCapabilities {
 
   @RealObject protected NetworkCapabilities realNetworkCapabilities;
@@ -95,12 +97,42 @@ public class ShadowNetworkCapabilities {
 
   /** Sets the LinkDownstreamBandwidthKbps of the NetworkCapabilities. */
   @HiddenApi
-  @Implementation
-  public Object setLinkDownstreamBandwidthKbps(Object kbps) {
-    // Loose signatures is necessary because the return type of setLinkDownstreamBandwidthKbps
-    // changed from void to NetworkCapabilities starting from API 28 (Pie)
+  @Implementation(maxSdk = O_MR1, methodName = "setLinkDownstreamBandwidthKbps")
+  protected void setLinkDownstreamBandwidthKbpsPrePie(int kbps) {
+    reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
+        .setLinkDownstreamBandwidthKbps(kbps);
+  }
+
+  /**
+   * Sets the LinkDownstreamBandwidthKbps of the NetworkCapabilities.
+   *
+   * <p>Return type changed to {@code NetworkCapabilities} starting from Pie.
+   */
+  @HiddenApi
+  @Implementation(minSdk = P)
+  public NetworkCapabilities setLinkDownstreamBandwidthKbps(int kbps) {
     return reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
-        .setLinkDownstreamBandwidthKbps((int) kbps);
+        .setLinkDownstreamBandwidthKbps(kbps);
+  }
+
+  /** Sets the LinkUpstreamBandwidthKbps of the NetworkCapabilities. */
+  @HiddenApi
+  @Implementation(maxSdk = O_MR1, methodName = "setLinkUpstreamBandwidthKbps")
+  protected void setLinkUpstreamBandwidthKbpsPrePie(int kbps) {
+    reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
+        .setLinkUpstreamBandwidthKbps(kbps);
+  }
+
+  /**
+   * Sets the LinkUpstreamBandwidthKbps of the NetworkCapabilities.
+   *
+   * <p>Return type changed to {@code NetworkCapabilities} starting from Pie.
+   */
+  @HiddenApi
+  @Implementation(minSdk = P)
+  public NetworkCapabilities setLinkUpstreamBandwidthKbps(int kbps) {
+    return reflector(NetworkCapabilitiesReflector.class, realNetworkCapabilities)
+        .setLinkUpstreamBandwidthKbps(kbps);
   }
 
   /** Clears capabilities. */
@@ -150,5 +182,8 @@ public class ShadowNetworkCapabilities {
 
     @Direct
     NetworkCapabilities setLinkDownstreamBandwidthKbps(int kbps);
+
+    @Direct
+    NetworkCapabilities setLinkUpstreamBandwidthKbps(int kbps);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
index 3389402e3..785af44af 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNetworkScoreManager.java
@@ -3,12 +3,19 @@ package org.robolectric.shadows;
 import android.net.NetworkScoreManager;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Provides testing APIs for {@link NetworkScoreManager}. */
 @Implements(value = NetworkScoreManager.class, isInAndroidSdk = false)
 public class ShadowNetworkScoreManager {
-  private String activeScorerPackage;
-  private boolean isScoringEnabled = true;
+  private static String activeScorerPackage;
+  private static boolean isScoringEnabled = true;
+
+  @Resetter
+  public static void reset() {
+    activeScorerPackage = null;
+    isScoringEnabled = true;
+  }
 
   @Implementation
   public String getActiveScorerPackage() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java
index a2e5229ac..1c527afa1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNfcAdapter.java
@@ -18,6 +18,7 @@ import android.os.Bundle;
 import java.util.Map;
 import javax.annotation.concurrent.GuardedBy;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
@@ -28,9 +29,10 @@ import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow implementation of {@link NfcAdapter}. */
-@Implements(value = NfcAdapter.class, looseSignatures = true)
+@Implements(value = NfcAdapter.class)
 public class ShadowNfcAdapter {
   @RealObject NfcAdapter nfcAdapter;
 
@@ -79,6 +81,46 @@ public class ShadowNfcAdapter {
   @GuardedBy("this")
   private NfcAntennaInfo nfcAntennaInfo;
 
+  @GuardedBy("this")
+  private boolean isObserveModeSupported = false;
+
+  @GuardedBy("this")
+  private boolean isObserverModeEnabled = false;
+
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean setObserveModeEnabled(boolean enabled) {
+    synchronized (this) {
+      if (isObserveModeSupported) {
+        isObserverModeEnabled = enabled;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean isObserveModeEnabled() {
+    synchronized (this) {
+      return isObserverModeEnabled;
+    }
+  }
+
+  @Implementation(minSdk = V.SDK_INT)
+  protected boolean isObserveModeSupported() {
+    synchronized (this) {
+      return isObserveModeSupported;
+    }
+  }
+
+  /**
+   * Sets the value returned by {@link #isObserveModeSupported()}.
+   *
+   * @param supported the value to return from {@link #isObserveModeSupported()}
+   */
+  public synchronized void setObserveModeSupported(boolean supported) {
+    isObserveModeSupported = supported;
+  }
+
   @Implementation
   protected static NfcAdapter getDefaultAdapter(Context context) {
     // The result of `getNfcAdapter` is cached, so need to check `hardwareExists` again here in case
@@ -283,7 +325,7 @@ public class ShadowNfcAdapter {
 
   // TODO: use NfcAntennaInfo when minimum supported compile SDK is >= android U
   @Implementation(minSdk = UPSIDE_DOWN_CAKE)
-  protected Object /* NfcAntennaInfo */ getNfcAntennaInfo() {
+  protected @ClassName("android.nfc.NfcAntennaInfo") Object getNfcAntennaInfo() {
     synchronized (this) {
       return nfcAntennaInfo;
     }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
index a842607cf..8a35a184e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNoopNativeAllocationRegistry.java
@@ -1,28 +1,28 @@
 package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.P;
 import static org.robolectric.shadow.api.Shadow.invokeConstructor;
 
 import libcore.util.NativeAllocationRegistry;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
-import org.robolectric.versioning.AndroidVersions.V;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 
 /** Shadow for {@link NativeAllocationRegistry} that is a no-op. */
-@Implements(
-    value = NativeAllocationRegistry.class,
-    minSdk = N,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+@Implements(value = NativeAllocationRegistry.class, minSdk = N, isInAndroidSdk = false)
 public class ShadowNoopNativeAllocationRegistry {
 
   @RealObject protected NativeAllocationRegistry realNativeAllocationRegistry;
 
-  @Implementation
-  protected Runnable registerNativeAllocation(Object referent, Object allocator) {
+  @Implementation(maxSdk = P)
+  protected Runnable registerNativeAllocation(
+      Object referent,
+      @ClassName("libcore.util.NativeAllocationRegistry$Allocator") Object allocator) {
     return () -> {};
   }
 
@@ -38,7 +38,7 @@ public class ShadowNoopNativeAllocationRegistry {
    * behavior of actual class.
    */
   @InDevelopment
-  @Implementation(minSdk = V.SDK_INT)
+  @Implementation(minSdk = Baklava.SDK_INT)
   protected void __constructor__(
       ClassLoader classLoader,
       Class clazz,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
index c497572a2..13325c0d3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowNotificationManager.java
@@ -12,6 +12,7 @@ import android.annotation.NonNull;
 import android.app.AutomaticZenRule;
 import android.app.Notification;
 import android.app.NotificationChannel;
+import android.app.NotificationChannelGroup;
 import android.app.NotificationManager;
 import android.app.NotificationManager.Policy;
 import android.content.ComponentName;
@@ -32,29 +33,53 @@ import java.util.concurrent.ConcurrentHashMap;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadows for NotificationManager. */
 @SuppressWarnings({"UnusedDeclaration", "AndroidConcurrentHashMap"})
-@Implements(value = NotificationManager.class, looseSignatures = true)
+@Implements(value = NotificationManager.class)
 public class ShadowNotificationManager {
   private static final int MAX_NOTIFICATION_LIMIT = 25;
-  private boolean mAreNotificationsEnabled = true;
-  private boolean isNotificationPolicyAccessGranted = false;
-  private boolean enforceMaxNotificationLimit = false;
-  private final Map<Key, PostedNotification> notifications = new ConcurrentHashMap<>();
-  private final Map<String, Object> notificationChannels = new ConcurrentHashMap<>();
-  private final Map<String, Object> notificationChannelGroups = new ConcurrentHashMap<>();
-  private final Map<String, Object> deletedNotificationChannels = new ConcurrentHashMap<>();
-  private final Map<String, AutomaticZenRule> automaticZenRules = new ConcurrentHashMap<>();
-  private final Map<String, Boolean> listenerAccessGrantedComponents = new ConcurrentHashMap<>();
-  private final Set<String> canNotifyOnBehalfPackages = Sets.newConcurrentHashSet();
-
-  private int currentInteruptionFilter = INTERRUPTION_FILTER_ALL;
-  private Policy notificationPolicy;
-  private Policy consolidatedNotificationPolicy;
-  private String notificationDelegate;
-  private int importance;
+  private static boolean mAreNotificationsEnabled = true;
+  private static boolean isNotificationPolicyAccessGranted = false;
+  private static boolean enforceMaxNotificationLimit = false;
+  private static final Map<Key, PostedNotification> notifications = new ConcurrentHashMap<>();
+  private static final Map<String, NotificationChannel> notificationChannels =
+      new ConcurrentHashMap<>();
+  private static final Map<String, NotificationChannelGroup> notificationChannelGroups =
+      new ConcurrentHashMap<>();
+  private static final Map<String, NotificationChannel> deletedNotificationChannels =
+      new ConcurrentHashMap<>();
+  private static final Map<String, AutomaticZenRule> automaticZenRules = new ConcurrentHashMap<>();
+  private static final Map<String, Boolean> listenerAccessGrantedComponents =
+      new ConcurrentHashMap<>();
+  private static final Set<String> canNotifyOnBehalfPackages = Sets.newConcurrentHashSet();
+
+  private static int currentInterruptionFilter = INTERRUPTION_FILTER_ALL;
+  private static Policy notificationPolicy;
+  private static Policy consolidatedNotificationPolicy;
+  private static String notificationDelegate;
+  private static int importance = NotificationManager.IMPORTANCE_NONE;
+
+  @Resetter
+  public static void reset() {
+    mAreNotificationsEnabled = true;
+    isNotificationPolicyAccessGranted = false;
+    enforceMaxNotificationLimit = false;
+    notifications.clear();
+    notificationChannels.clear();
+    notificationChannelGroups.clear();
+    deletedNotificationChannels.clear();
+    automaticZenRules.clear();
+    listenerAccessGrantedComponents.clear();
+    canNotifyOnBehalfPackages.clear();
+    currentInterruptionFilter = INTERRUPTION_FILTER_ALL;
+    notificationPolicy = null;
+    notificationDelegate = null;
+    consolidatedNotificationPolicy = null;
+    importance = NotificationManager.IMPORTANCE_NONE;
+  }
 
   @Implementation
   protected void notify(int id, Notification notification) {
@@ -130,15 +155,14 @@ public class ShadowNotificationManager {
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected Object /*NotificationChannel*/ getNotificationChannel(String channelId) {
+  protected NotificationChannel getNotificationChannel(String channelId) {
     return notificationChannels.get(channelId);
   }
 
   /** Returns a NotificationChannel that has the given parent and conversation ID. */
   @Implementation(minSdk = R)
   protected NotificationChannel getNotificationChannel(String channelId, String conversationId) {
-    for (Object object : getNotificationChannels()) {
-      NotificationChannel notificationChannel = (NotificationChannel) object;
+    for (NotificationChannel notificationChannel : getNotificationChannels()) {
       if (conversationId.equals(notificationChannel.getConversationId())
           && channelId.equals(notificationChannel.getParentChannelId())) {
         return notificationChannel;
@@ -148,26 +172,25 @@ public class ShadowNotificationManager {
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected void createNotificationChannelGroup(Object /*NotificationChannelGroup*/ group) {
+  protected void createNotificationChannelGroup(NotificationChannelGroup group) {
     String id = ReflectionHelpers.callInstanceMethod(group, "getId");
     notificationChannelGroups.put(id, group);
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected void createNotificationChannelGroups(
-      List<Object /*NotificationChannelGroup*/> groupList) {
-    for (Object group : groupList) {
+  protected void createNotificationChannelGroups(List<NotificationChannelGroup> groupList) {
+    for (NotificationChannelGroup group : groupList) {
       createNotificationChannelGroup(group);
     }
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected List<Object /*NotificationChannelGroup*/> getNotificationChannelGroups() {
+  protected List<NotificationChannelGroup> getNotificationChannelGroups() {
     return ImmutableList.copyOf(notificationChannelGroups.values());
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected void createNotificationChannel(Object /*NotificationChannel*/ channel) {
+  protected void createNotificationChannel(NotificationChannel channel) {
     String id = ReflectionHelpers.callInstanceMethod(channel, "getId");
     // Per documentation, recreating a deleted channel should have the same settings as the old
     // deleted channel. See
@@ -197,21 +220,21 @@ public class ShadowNotificationManager {
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  protected void createNotificationChannels(List<Object /*NotificationChannel*/> channelList) {
-    for (Object channel : channelList) {
+  protected void createNotificationChannels(List<NotificationChannel> channelList) {
+    for (NotificationChannel channel : channelList) {
       createNotificationChannel(channel);
     }
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
-  public List<Object /*NotificationChannel*/> getNotificationChannels() {
+  public List<NotificationChannel> getNotificationChannels() {
     return ImmutableList.copyOf(notificationChannels.values());
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.O)
   protected void deleteNotificationChannel(String channelId) {
     if (getNotificationChannel(channelId) != null) {
-      Object /*NotificationChannel*/ channel = notificationChannels.remove(channelId);
+      NotificationChannel channel = notificationChannels.remove(channelId);
       deletedNotificationChannels.put(channelId, channel);
     }
   }
@@ -227,7 +250,7 @@ public class ShadowNotificationManager {
       // Deleting a channel group also deleted all associated channels. See
       // https://developer.android.com/reference/android/app/NotificationManager.html#deleteNotificationChannelGroup%28java.lang.String%29
       // for more info.
-      for (/* NotificationChannel */ Object channel : getNotificationChannels()) {
+      for (NotificationChannel channel : getNotificationChannels()) {
         String groupId = ReflectionHelpers.callInstanceMethod(channel, "getGroup");
         if (channelGroupId.equals(groupId)) {
           String channelId = ReflectionHelpers.callInstanceMethod(channel, "getId");
@@ -244,7 +267,7 @@ public class ShadowNotificationManager {
    */
   @Implementation(minSdk = M)
   protected int getCurrentInterruptionFilter() {
-    return currentInteruptionFilter;
+    return currentInterruptionFilter;
   }
 
   /**
@@ -254,7 +277,7 @@ public class ShadowNotificationManager {
    */
   @Implementation(minSdk = M)
   protected void setInterruptionFilter(int interruptionFilter) {
-    currentInteruptionFilter = interruptionFilter;
+    currentInterruptionFilter = interruptionFilter;
   }
 
   /**
@@ -480,7 +503,7 @@ public class ShadowNotificationManager {
   }
 
   @Implementation(minSdk = P)
-  public Object /*NotificationChannelGroup*/ getNotificationChannelGroup(String id) {
+  public NotificationChannelGroup getNotificationChannelGroup(String id) {
     return notificationChannelGroups.get(id);
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
index 6c61fdb27..bdc6b2ecf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowOsConstants.java
@@ -1,53 +1,612 @@
 package org.robolectric.shadows;
 
 import android.system.OsConstants;
+import java.io.File;
 import java.lang.reflect.Field;
-import java.util.regex.Pattern;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** */
 @Implements(value = OsConstants.class, minSdk = 21)
 public final class ShadowOsConstants {
-  private static final Pattern ERRNO_PATTERN = Pattern.compile("E[A-Z0-9]+");
-
   @Implementation
   protected static void initConstants() {
-    int errnos = 1;
+
+    // In real android these constants are populated via reflection in native linux-only code.
+    // This shadow performs similar logic here , using the values obtained from
+    // an Android emulator at runtime.
+
+    initConstant("AF_INET", 0x0000002);
+    initConstant("AF_INET6", 0x000000a);
+    initConstant("AF_NETLINK", 0x0000010);
+    initConstant("AF_PACKET", 0x0000011);
+    initConstant("AF_UNIX", 0x0000001);
+    initConstant("AF_UNSPEC", 0x0000000);
+    initConstant("AF_VSOCK", 0x0000028);
+    initConstant("AI_ADDRCONFIG", 0x0000400);
+    initConstant("AI_ALL", 0x0000100);
+    initConstant("AI_CANONNAME", 0x0000002);
+    initConstant("AI_NUMERICHOST", 0x0000004);
+    initConstant("AI_NUMERICSERV", 0x0000008);
+    initConstant("AI_PASSIVE", 0x0000001);
+    initConstant("AI_V4MAPPED", 0x0000800);
+    initConstant("ARPHRD_ETHER", 0x0000001);
+    initConstant("ARPHRD_LOOPBACK", 0x0000304);
+    initConstant("CAP_AUDIT_CONTROL", 0x000001e);
+    initConstant("CAP_AUDIT_WRITE", 0x000001d);
+    initConstant("CAP_BLOCK_SUSPEND", 0x0000024);
+    initConstant("CAP_CHOWN", 0x0000000);
+    initConstant("CAP_DAC_OVERRIDE", 0x0000001);
+    initConstant("CAP_DAC_READ_SEARCH", 0x0000002);
+    initConstant("CAP_FOWNER", 0x0000003);
+    initConstant("CAP_FSETID", 0x0000004);
+    initConstant("CAP_IPC_LOCK", 0x000000e);
+    initConstant("CAP_IPC_OWNER", 0x000000f);
+    initConstant("CAP_KILL", 0x0000005);
+    initConstant("CAP_LAST_CAP", 0x0000028);
+    initConstant("CAP_LEASE", 0x000001c);
+    initConstant("CAP_LINUX_IMMUTABLE", 0x0000009);
+    initConstant("CAP_MAC_ADMIN", 0x0000021);
+    initConstant("CAP_MAC_OVERRIDE", 0x0000020);
+    initConstant("CAP_MKNOD", 0x000001b);
+    initConstant("CAP_NET_ADMIN", 0x000000c);
+    initConstant("CAP_NET_BIND_SERVICE", 0x000000a);
+    initConstant("CAP_NET_BROADCAST", 0x000000b);
+    initConstant("CAP_NET_RAW", 0x000000d);
+    initConstant("CAP_SETFCAP", 0x000001f);
+    initConstant("CAP_SETGID", 0x0000006);
+    initConstant("CAP_SETPCAP", 0x0000008);
+    initConstant("CAP_SETUID", 0x0000007);
+    initConstant("CAP_SYSLOG", 0x0000022);
+    initConstant("CAP_SYS_ADMIN", 0x0000015);
+    initConstant("CAP_SYS_BOOT", 0x0000016);
+    initConstant("CAP_SYS_CHROOT", 0x0000012);
+    initConstant("CAP_SYS_MODULE", 0x0000010);
+    initConstant("CAP_SYS_NICE", 0x0000017);
+    initConstant("CAP_SYS_PACCT", 0x0000014);
+    initConstant("CAP_SYS_PTRACE", 0x0000013);
+    initConstant("CAP_SYS_RAWIO", 0x0000011);
+    initConstant("CAP_SYS_RESOURCE", 0x0000018);
+    initConstant("CAP_SYS_TIME", 0x0000019);
+    initConstant("CAP_SYS_TTY_CONFIG", 0x000001a);
+    initConstant("CAP_WAKE_ALARM", 0x0000023);
+    initConstant("E2BIG", 0x0000007);
+    initConstant("EACCES", 0x000000d);
+    initConstant("EADDRINUSE", 0x0000062);
+    initConstant("EADDRNOTAVAIL", 0x0000063);
+    initConstant("EAFNOSUPPORT", 0x0000061);
+    initConstant("EAGAIN", 0x000000b);
+    initConstant("EAI_AGAIN", 0x0000002);
+    initConstant("EAI_BADFLAGS", 0x0000003);
+    initConstant("EAI_FAIL", 0x0000004);
+    initConstant("EAI_FAMILY", 0x0000005);
+    initConstant("EAI_MEMORY", 0x0000006);
+    initConstant("EAI_NODATA", 0x0000007);
+    initConstant("EAI_NONAME", 0x0000008);
+    initConstant("EAI_OVERFLOW", 0x000000e);
+    initConstant("EAI_SERVICE", 0x0000009);
+    initConstant("EAI_SOCKTYPE", 0x000000a);
+    initConstant("EAI_SYSTEM", 0x000000b);
+    initConstant("EALREADY", 0x0000072);
+    initConstant("EBADF", 0x0000009);
+    initConstant("EBADMSG", 0x000004a);
+    initConstant("EBUSY", 0x0000010);
+    initConstant("ECANCELED", 0x000007d);
+    initConstant("ECHILD", 0x000000a);
+    initConstant("ECONNABORTED", 0x0000067);
+    initConstant("ECONNREFUSED", 0x000006f);
+    initConstant("ECONNRESET", 0x0000068);
+    initConstant("EDEADLK", 0x0000023);
+    initConstant("EDESTADDRREQ", 0x0000059);
+    initConstant("EDOM", 0x0000021);
+    initConstant("EDQUOT", 0x000007a);
+    initConstant("EEXIST", 0x0000011);
+    initConstant("EFAULT", 0x000000e);
+    initConstant("EFBIG", 0x000001b);
+    initConstant("EHOSTUNREACH", 0x0000071);
+    initConstant("EIDRM", 0x000002b);
+    initConstant("EILSEQ", 0x0000054);
+    initConstant("EINPROGRESS", 0x0000073);
+    initConstant("EINTR", 0x0000004);
+    initConstant("EINVAL", 0x0000016);
+    initConstant("EIO", 0x0000005);
+    initConstant("EISCONN", 0x000006a);
+    initConstant("EISDIR", 0x0000015);
+    initConstant("ELOOP", 0x0000028);
+    initConstant("EMFILE", 0x0000018);
+    initConstant("EMLINK", 0x000001f);
+    initConstant("EMSGSIZE", 0x000005a);
+    initConstant("EMULTIHOP", 0x0000048);
+    initConstant("ENAMETOOLONG", 0x0000024);
+    initConstant("ENETDOWN", 0x0000064);
+    initConstant("ENETRESET", 0x0000066);
+    initConstant("ENETUNREACH", 0x0000065);
+    initConstant("ENFILE", 0x0000017);
+    initConstant("ENOBUFS", 0x0000069);
+    initConstant("ENODATA", 0x000003d);
+    initConstant("ENODEV", 0x0000013);
+    initConstant("ENOENT", 0x0000002);
+    initConstant("ENOEXEC", 0x0000008);
+    initConstant("ENOLCK", 0x0000025);
+    initConstant("ENOLINK", 0x0000043);
+    initConstant("ENOMEM", 0x000000c);
+    initConstant("ENOMSG", 0x000002a);
+    initConstant("ENONET", 0x0000040);
+    initConstant("ENOPROTOOPT", 0x000005c);
+    initConstant("ENOSPC", 0x000001c);
+    initConstant("ENOSR", 0x000003f);
+    initConstant("ENOSTR", 0x000003c);
+    initConstant("ENOSYS", 0x0000026);
+    initConstant("ENOTCONN", 0x000006b);
+    initConstant("ENOTDIR", 0x0000014);
+    initConstant("ENOTEMPTY", 0x0000027);
+    initConstant("ENOTSOCK", 0x0000058);
+    initConstant("ENOTSUP", 0x000005f);
+    initConstant("ENOTTY", 0x0000019);
+    initConstant("ENXIO", 0x0000006);
+    initConstant("EOPNOTSUPP", 0x000005f);
+    initConstant("EOVERFLOW", 0x000004b);
+    initConstant("EPERM", 0x0000001);
+    initConstant("EPIPE", 0x0000020);
+    initConstant("EPROTO", 0x0000047);
+    initConstant("EPROTONOSUPPORT", 0x000005d);
+    initConstant("EPROTOTYPE", 0x000005b);
+    initConstant("ERANGE", 0x0000022);
+    initConstant("EROFS", 0x000001e);
+    initConstant("ESPIPE", 0x000001d);
+    initConstant("ESRCH", 0x0000003);
+    initConstant("ESTALE", 0x0000074);
+    initConstant("ETH_P_ALL", 0x0000003);
+    initConstant("ETH_P_ARP", 0x0000806);
+    initConstant("ETH_P_IP", 0x0000800);
+    initConstant("ETH_P_IPV6", 0x00086dd);
+    initConstant("ETIME", 0x000003e);
+    initConstant("ETIMEDOUT", 0x000006e);
+    initConstant("ETXTBSY", 0x000001a);
+    initConstant("EUSERS", 0x0000057);
+    initConstant("EXDEV", 0x0000012);
+    initConstant("EXIT_FAILURE", 0x0000001);
+    initConstant("EXIT_SUCCESS", 0x0000000);
+    initConstant("FD_CLOEXEC", 0x0000001);
+    initConstant("FIONREAD", 0x000541b);
+    initConstant("F_DUPFD", 0x0000000);
+    initConstant("F_DUPFD_CLOEXEC", 0x0000406);
+    initConstant("F_GETFD", 0x0000001);
+    initConstant("F_GETFL", 0x0000003);
+    initConstant("F_GETLK", 0x0000005);
+    initConstant("F_GETLK64", 0x0000005);
+    initConstant("F_GETOWN", 0x0000009);
+    initConstant("F_OK", 0x0000000);
+    initConstant("F_RDLCK", 0x0000000);
+    initConstant("F_SETFD", 0x0000002);
+    initConstant("F_SETFL", 0x0000004);
+    initConstant("F_SETLK", 0x0000006);
+    initConstant("F_SETLK64", 0x0000006);
+    initConstant("F_SETLKW", 0x0000007);
+    initConstant("F_SETLKW64", 0x0000007);
+    initConstant("F_SETOWN", 0x0000008);
+    initConstant("F_UNLCK", 0x0000002);
+    initConstant("F_WRLCK", 0x0000001);
+    initConstant("ICMP6_ECHO_REPLY", 0x0000081);
+    initConstant("ICMP6_ECHO_REQUEST", 0x0000080);
+    initConstant("ICMP_ECHO", 0x0000008);
+    initConstant("ICMP_ECHOREPLY", 0x0000000);
+    initConstant("IFA_F_DADFAILED", 0x0000008);
+    initConstant("IFA_F_DEPRECATED", 0x0000020);
+    initConstant("IFA_F_HOMEADDRESS", 0x0000010);
+    initConstant("IFA_F_MANAGETEMPADDR", 0x0000100);
+    initConstant("IFA_F_NODAD", 0x0000002);
+    initConstant("IFA_F_NOPREFIXROUTE", 0x0000200);
+    initConstant("IFA_F_OPTIMISTIC", 0x0000004);
+    initConstant("IFA_F_PERMANENT", 0x0000080);
+    initConstant("IFA_F_SECONDARY", 0x0000001);
+    initConstant("IFA_F_TEMPORARY", 0x0000001);
+    initConstant("IFA_F_TENTATIVE", 0x0000040);
+    initConstant("IFF_ALLMULTI", 0x0000200);
+    initConstant("IFF_AUTOMEDIA", 0x0004000);
+    initConstant("IFF_BROADCAST", 0x0000002);
+    initConstant("IFF_DEBUG", 0x0000004);
+    initConstant("IFF_DYNAMIC", 0x0008000);
+    initConstant("IFF_LOOPBACK", 0x0000008);
+    initConstant("IFF_MASTER", 0x0000400);
+    initConstant("IFF_MULTICAST", 0x0001000);
+    initConstant("IFF_NOARP", 0x0000080);
+    initConstant("IFF_NOTRAILERS", 0x0000020);
+    initConstant("IFF_POINTOPOINT", 0x0000010);
+    initConstant("IFF_PORTSEL", 0x0002000);
+    initConstant("IFF_PROMISC", 0x0000100);
+    initConstant("IFF_RUNNING", 0x0000040);
+    initConstant("IFF_SLAVE", 0x0000800);
+    initConstant("IFF_UP", 0x0000001);
+    initConstant("IPPROTO_ESP", 0x0000032);
+    initConstant("IPPROTO_ICMP", 0x0000001);
+    initConstant("IPPROTO_ICMPV6", 0x000003a);
+    initConstant("IPPROTO_IP", 0x0000000);
+    initConstant("IPPROTO_IPV6", 0x0000029);
+    initConstant("IPPROTO_RAW", 0x00000ff);
+    initConstant("IPPROTO_TCP", 0x0000006);
+    initConstant("IPPROTO_UDP", 0x0000011);
+    initConstant("IPV6_CHECKSUM", 0x0000007);
+    initConstant("IPV6_MULTICAST_HOPS", 0x0000012);
+    initConstant("IPV6_MULTICAST_IF", 0x0000011);
+    initConstant("IPV6_MULTICAST_LOOP", 0x0000013);
+    initConstant("IPV6_PKTINFO", 0x0000032);
+    initConstant("IPV6_RECVDSTOPTS", 0x000003a);
+    initConstant("IPV6_RECVHOPLIMIT", 0x0000033);
+    initConstant("IPV6_RECVHOPOPTS", 0x0000035);
+    initConstant("IPV6_RECVPKTINFO", 0x0000031);
+    initConstant("IPV6_RECVRTHDR", 0x0000038);
+    initConstant("IPV6_RECVTCLASS", 0x0000042);
+    initConstant("IPV6_TCLASS", 0x0000043);
+    initConstant("IPV6_UNICAST_HOPS", 0x0000010);
+    initConstant("IPV6_V6ONLY", 0x000001a);
+    initConstant("IP_MULTICAST_ALL", 0x0000031);
+    initConstant("IP_MULTICAST_IF", 0x0000020);
+    initConstant("IP_MULTICAST_LOOP", 0x0000022);
+    initConstant("IP_MULTICAST_TTL", 0x0000021);
+    initConstant("IP_RECVTOS", 0x000000d);
+    initConstant("IP_TOS", 0x0000001);
+    initConstant("IP_TTL", 0x0000002);
+    initConstant("MAP_ANONYMOUS", 0x0000020);
+    initConstant("MAP_FIXED", 0x0000010);
+    initConstant("MAP_POPULATE", 0x0008000);
+    initConstant("MAP_PRIVATE", 0x0000002);
+    initConstant("MAP_SHARED", 0x0000001);
+    initConstant("MCAST_BLOCK_SOURCE", 0x000002b);
+    initConstant("MCAST_JOIN_GROUP", 0x000002a);
+    initConstant("MCAST_JOIN_SOURCE_GROUP", 0x000002e);
+    initConstant("MCAST_LEAVE_GROUP", 0x000002d);
+    initConstant("MCAST_LEAVE_SOURCE_GROUP", 0x000002f);
+    initConstant("MCAST_UNBLOCK_SOURCE", 0x000002c);
+    initConstant("MCL_CURRENT", 0x0000001);
+    initConstant("MCL_FUTURE", 0x0000002);
+    initConstant("MFD_CLOEXEC", 0x0000001);
+    initConstant("MSG_CTRUNC", 0x0000008);
+    initConstant("MSG_DONTROUTE", 0x0000004);
+    initConstant("MSG_EOR", 0x0000080);
+    initConstant("MSG_OOB", 0x0000001);
+    initConstant("MSG_PEEK", 0x0000002);
+    initConstant("MSG_TRUNC", 0x0000020);
+    initConstant("MSG_WAITALL", 0x0000100);
+    initConstant("MS_ASYNC", 0x0000001);
+    initConstant("MS_INVALIDATE", 0x0000002);
+    initConstant("MS_SYNC", 0x0000004);
+    initConstant("NETLINK_INET_DIAG", 0x0000004);
+    initConstant("NETLINK_NETFILTER", 0x000000c);
+    initConstant("NETLINK_ROUTE", 0x0000000);
+    initConstant("NETLINK_XFRM", 0x0000006);
+    initConstant("NI_DGRAM", 0x0000010);
+    initConstant("NI_NAMEREQD", 0x0000004);
+    initConstant("NI_NOFQDN", 0x0000001);
+    initConstant("NI_NUMERICHOST", 0x0000002);
+    initConstant("NI_NUMERICSERV", 0x0000008);
+    initConstant("O_ACCMODE", 0x0000003);
+    initConstant("O_APPEND", 0x0000400);
+    initConstant("O_CLOEXEC", 0x0080000);
+    initConstant("O_CREAT", 0x0000040);
+    initConstant("O_DIRECT", 0x0004000);
+    initConstant("O_DSYNC", 0x0001000);
+    initConstant("O_EXCL", 0x0000080);
+    initConstant("O_NOCTTY", 0x0000100);
+    initConstant("O_NOFOLLOW", 0x0020000);
+    initConstant("O_NONBLOCK", 0x0000800);
+    initConstant("O_RDONLY", 0x0000000);
+    initConstant("O_RDWR", 0x0000002);
+    initConstant("O_SYNC", 0x0101000);
+    initConstant("O_TRUNC", 0x0000200);
+    initConstant("O_WRONLY", 0x0000001);
+    initConstant("PACKET_IGNORE_OUTGOING", 0x0000017);
+    initConstant("POLLERR", 0x0000008);
+    initConstant("POLLHUP", 0x0000010);
+    initConstant("POLLIN", 0x0000001);
+    initConstant("POLLNVAL", 0x0000020);
+    initConstant("POLLOUT", 0x0000004);
+    initConstant("POLLPRI", 0x0000002);
+    initConstant("POLLRDBAND", 0x0000080);
+    initConstant("POLLRDNORM", 0x0000040);
+    initConstant("POLLWRBAND", 0x0000200);
+    initConstant("POLLWRNORM", 0x0000100);
+    initConstant("PROT_EXEC", 0x0000004);
+    initConstant("PROT_NONE", 0x0000000);
+    initConstant("PROT_READ", 0x0000001);
+    initConstant("PROT_WRITE", 0x0000002);
+    initConstant("PR_CAP_AMBIENT", 0x000002f);
+    initConstant("PR_CAP_AMBIENT_RAISE", 0x0000002);
+    initConstant("PR_GET_DUMPABLE", 0x0000003);
+    initConstant("PR_SET_DUMPABLE", 0x0000004);
+    initConstant("PR_SET_NO_NEW_PRIVS", 0x0000026);
+    initConstant("RLIMIT_NOFILE", 0x0000007);
+    initConstant("RLIMIT_RTPRIO", 0x000000e);
+    initConstant("RTMGRP_IPV4_IFADDR", 0x0000010);
+    initConstant("RTMGRP_IPV4_MROUTE", 0x0000020);
+    initConstant("RTMGRP_IPV4_ROUTE", 0x0000040);
+    initConstant("RTMGRP_IPV4_RULE", 0x0000080);
+    initConstant("RTMGRP_IPV6_IFADDR", 0x0000100);
+    initConstant("RTMGRP_IPV6_IFINFO", 0x0000800);
+    initConstant("RTMGRP_IPV6_MROUTE", 0x0000200);
+    initConstant("RTMGRP_IPV6_PREFIX", 0x0020000);
+    initConstant("RTMGRP_IPV6_ROUTE", 0x0000400);
+    initConstant("RTMGRP_LINK", 0x0000001);
+    initConstant("RTMGRP_NEIGH", 0x0000004);
+    initConstant("RTMGRP_NOTIFY", 0x0000002);
+    initConstant("RTMGRP_TC", 0x0000008);
+    initConstant("RT_SCOPE_HOST", 0x00000fe);
+    initConstant("RT_SCOPE_LINK", 0x00000fd);
+    initConstant("RT_SCOPE_NOWHERE", 0x00000ff);
+    initConstant("RT_SCOPE_SITE", 0x00000c8);
+    initConstant("RT_SCOPE_UNIVERSE", 0x0000000);
+    initConstant("R_OK", 0x0000004);
+    initConstant("SEEK_CUR", 0x0000001);
+    initConstant("SEEK_END", 0x0000002);
+    initConstant("SEEK_SET", 0x0000000);
+    initConstant("SHUT_RD", 0x0000000);
+    initConstant("SHUT_RDWR", 0x0000002);
+    initConstant("SHUT_WR", 0x0000001);
+    initConstant("SIGABRT", 0x0000006);
+    initConstant("SIGALRM", 0x000000e);
+    initConstant("SIGBUS", 0x0000007);
+    initConstant("SIGCHLD", 0x0000011);
+    initConstant("SIGCONT", 0x0000012);
+    initConstant("SIGFPE", 0x0000008);
+    initConstant("SIGHUP", 0x0000001);
+    initConstant("SIGILL", 0x0000004);
+    initConstant("SIGINT", 0x0000002);
+    initConstant("SIGIO", 0x000001d);
+    initConstant("SIGKILL", 0x0000009);
+    initConstant("SIGPIPE", 0x000000d);
+    initConstant("SIGPROF", 0x000001b);
+    initConstant("SIGPWR", 0x000001e);
+    initConstant("SIGQUIT", 0x0000003);
+    initConstant("SIGRTMAX", 0x0000040);
+    initConstant("SIGRTMIN", 0x0000029);
+    initConstant("SIGSEGV", 0x000000b);
+    initConstant("SIGSTKFLT", 0x0000010);
+    initConstant("SIGSTOP", 0x0000013);
+    initConstant("SIGSYS", 0x000001f);
+    initConstant("SIGTERM", 0x000000f);
+    initConstant("SIGTRAP", 0x0000005);
+    initConstant("SIGTSTP", 0x0000014);
+    initConstant("SIGTTIN", 0x0000015);
+    initConstant("SIGTTOU", 0x0000016);
+    initConstant("SIGURG", 0x0000017);
+    initConstant("SIGUSR1", 0x000000a);
+    initConstant("SIGUSR2", 0x000000c);
+    initConstant("SIGVTALRM", 0x000001a);
+    initConstant("SIGWINCH", 0x000001c);
+    initConstant("SIGXCPU", 0x0000018);
+    initConstant("SIGXFSZ", 0x0000019);
+    initConstant("SIOCGIFADDR", 0x0008915);
+    initConstant("SIOCGIFBRDADDR", 0x0008919);
+    initConstant("SIOCGIFDSTADDR", 0x0008917);
+    initConstant("SIOCGIFNETMASK", 0x000891b);
+    initConstant("SOCK_CLOEXEC", 0x0080000);
+    initConstant("SOCK_DGRAM", 0x0000002);
+    initConstant("SOCK_NONBLOCK", 0x0000800);
+    initConstant("SOCK_RAW", 0x0000003);
+    initConstant("SOCK_SEQPACKET", 0x0000005);
+    initConstant("SOCK_STREAM", 0x0000001);
+    initConstant("SOL_PACKET", 0x0000107);
+    initConstant("SOL_SOCKET", 0x0000001);
+    initConstant("SOL_UDP", 0x0000011);
+    initConstant("SO_BINDTODEVICE", 0x0000019);
+    initConstant("SO_BROADCAST", 0x0000006);
+    initConstant("SO_DEBUG", 0x0000001);
+    initConstant("SO_DOMAIN", 0x0000027);
+    initConstant("SO_DONTROUTE", 0x0000005);
+    initConstant("SO_ERROR", 0x0000004);
+    initConstant("SO_KEEPALIVE", 0x0000009);
+    initConstant("SO_LINGER", 0x000000d);
+    initConstant("SO_OOBINLINE", 0x000000a);
+    initConstant("SO_PASSCRED", 0x0000010);
+    initConstant("SO_PEERCRED", 0x0000011);
+    initConstant("SO_PROTOCOL", 0x0000026);
+    initConstant("SO_RCVBUF", 0x0000008);
+    initConstant("SO_RCVLOWAT", 0x0000012);
+    initConstant("SO_RCVTIMEO", 0x0000014);
+    initConstant("SO_REUSEADDR", 0x0000002);
+    initConstant("SO_SNDBUF", 0x0000007);
+    initConstant("SO_SNDLOWAT", 0x0000013);
+    initConstant("SO_SNDTIMEO", 0x0000015);
+    initConstant("SO_TYPE", 0x0000003);
+    initConstant("SPLICE_F_MORE", 0x0000004);
+    initConstant("SPLICE_F_MOVE", 0x0000001);
+    initConstant("SPLICE_F_NONBLOCK", 0x0000002);
+    initConstant("STDERR_FILENO", 0x0000002);
+    initConstant("STDIN_FILENO", 0x0000000);
+    initConstant("STDOUT_FILENO", 0x0000001);
+    initConstant("ST_MANDLOCK", 0x0000040);
+    initConstant("ST_NOATIME", 0x0000400);
+    initConstant("ST_NODEV", 0x0000004);
+    initConstant("ST_NODIRATIME", 0x0000800);
+    initConstant("ST_NOEXEC", 0x0000008);
+    initConstant("ST_NOSUID", 0x0000002);
+    initConstant("ST_RDONLY", 0x0000001);
+    initConstant("ST_RELATIME", 0x0001000);
+    initConstant("ST_SYNCHRONOUS", 0x0000010);
+    initConstant("S_IFBLK", 0x0006000);
+    initConstant("S_IFCHR", 0x0002000);
+    initConstant("S_IFDIR", 0x0004000);
+    initConstant("S_IFIFO", 0x0001000);
+    initConstant("S_IFLNK", 0x000a000);
+    initConstant("S_IFMT", 0x000f000);
+    initConstant("S_IFREG", 0x0008000);
+    initConstant("S_IFSOCK", 0x000c000);
+    initConstant("S_IRGRP", 0x0000020);
+    initConstant("S_IROTH", 0x0000004);
+    initConstant("S_IRUSR", 0x0000100);
+    initConstant("S_IRWXG", 0x0000038);
+    initConstant("S_IRWXO", 0x0000007);
+    initConstant("S_IRWXU", 0x00001c0);
+    initConstant("S_ISGID", 0x0000400);
+    initConstant("S_ISUID", 0x0000800);
+    initConstant("S_ISVTX", 0x0000200);
+    initConstant("S_IWGRP", 0x0000010);
+    initConstant("S_IWOTH", 0x0000002);
+    initConstant("S_IWUSR", 0x0000080);
+    initConstant("S_IXGRP", 0x0000008);
+    initConstant("S_IXOTH", 0x0000001);
+    initConstant("S_IXUSR", 0x0000040);
+    initConstant("TCP_NODELAY", 0x0000001);
+    initConstant("TCP_USER_TIMEOUT", 0x0000012);
+    initConstant("TIOCOUTQ", 0x0005411);
+    initConstant("UDP_ENCAP", 0x0000064);
+    initConstant("UDP_ENCAP_ESPINUDP", 0x0000002);
+    initConstant("UDP_ENCAP_ESPINUDP_NON_IKE", 0x0000001);
+    initConstant("UDP_GRO", 0x0000068);
+    initConstant("UDP_SEGMENT", 0x0000067);
+    initConstant("UNIX_PATH_MAX", 0x000006c);
+    initConstant("VMADDR_CID_ANY", 0xffffffff);
+    initConstant("VMADDR_CID_HOST", 0x0000002);
+    initConstant("VMADDR_CID_LOCAL", 0x0000001);
+    initConstant("VMADDR_PORT_ANY", 0xffffffff);
+    initConstant("WCONTINUED", 0x0000008);
+    initConstant("WEXITED", 0x0000004);
+    initConstant("WNOHANG", 0x0000001);
+    initConstant("WNOWAIT", 0x1000000);
+    initConstant("WSTOPPED", 0x0000002);
+    initConstant("WUNTRACED", 0x0000002);
+    initConstant("W_OK", 0x0000002);
+    initConstant("XATTR_CREATE", 0x0000001);
+    initConstant("XATTR_REPLACE", 0x0000002);
+    initConstant("X_OK", 0x0000001);
+    initConstant("_LINUX_CAPABILITY_VERSION_3", 0x20080522);
+    initConstant("_SC_2_CHAR_TERM", 0x0000010);
+    initConstant("_SC_2_C_BIND", 0x000000d);
+    initConstant("_SC_2_C_DEV", 0x000000e);
+    initConstant("_SC_2_C_VERSION", 0x000000f);
+    initConstant("_SC_2_FORT_DEV", 0x0000011);
+    initConstant("_SC_2_FORT_RUN", 0x0000012);
+    initConstant("_SC_2_LOCALEDEF", 0x0000013);
+    initConstant("_SC_2_SW_DEV", 0x0000014);
+    initConstant("_SC_2_UPE", 0x0000015);
+    initConstant("_SC_2_VERSION", 0x0000016);
+    initConstant("_SC_AIO_LISTIO_MAX", 0x000002e);
+    initConstant("_SC_AIO_MAX", 0x000002f);
+    initConstant("_SC_AIO_PRIO_DELTA_MAX", 0x0000030);
+    initConstant("_SC_ARG_MAX", 0x0000000);
+    initConstant("_SC_ASYNCHRONOUS_IO", 0x0000039);
+    initConstant("_SC_ATEXIT_MAX", 0x0000025);
+    initConstant("_SC_AVPHYS_PAGES", 0x0000063);
+    initConstant("_SC_BC_BASE_MAX", 0x0000001);
+    initConstant("_SC_BC_DIM_MAX", 0x0000002);
+    initConstant("_SC_BC_SCALE_MAX", 0x0000003);
+    initConstant("_SC_BC_STRING_MAX", 0x0000004);
+    initConstant("_SC_CHILD_MAX", 0x0000005);
+    initConstant("_SC_CLK_TCK", 0x0000006);
+    initConstant("_SC_COLL_WEIGHTS_MAX", 0x0000007);
+    initConstant("_SC_DELAYTIMER_MAX", 0x0000031);
+    initConstant("_SC_EXPR_NEST_MAX", 0x0000008);
+    initConstant("_SC_FSYNC", 0x000003a);
+    initConstant("_SC_GETGR_R_SIZE_MAX", 0x0000047);
+    initConstant("_SC_GETPW_R_SIZE_MAX", 0x0000048);
+    initConstant("_SC_IOV_MAX", 0x0000026);
+    initConstant("_SC_JOB_CONTROL", 0x0000017);
+    initConstant("_SC_LINE_MAX", 0x0000009);
+    initConstant("_SC_LOGIN_NAME_MAX", 0x0000049);
+    initConstant("_SC_MAPPED_FILES", 0x000003b);
+    initConstant("_SC_MEMLOCK", 0x000003c);
+    initConstant("_SC_MEMLOCK_RANGE", 0x000003d);
+    initConstant("_SC_MEMORY_PROTECTION", 0x000003e);
+    initConstant("_SC_MESSAGE_PASSING", 0x000003f);
+    initConstant("_SC_MQ_OPEN_MAX", 0x0000032);
+    initConstant("_SC_MQ_PRIO_MAX", 0x0000033);
+    initConstant("_SC_NGROUPS_MAX", 0x000000a);
+    initConstant("_SC_NPROCESSORS_CONF", 0x0000060);
+    initConstant("_SC_NPROCESSORS_ONLN", 0x0000061);
+    initConstant("_SC_OPEN_MAX", 0x000000b);
+    initConstant("_SC_PAGESIZE", 0x0000027);
+    initConstant("_SC_PAGE_SIZE", 0x0000028);
+    initConstant("_SC_PASS_MAX", 0x000000c);
+    initConstant("_SC_PHYS_PAGES", 0x0000062);
+    initConstant("_SC_PRIORITIZED_IO", 0x0000040);
+    initConstant("_SC_PRIORITY_SCHEDULING", 0x0000041);
+    initConstant("_SC_REALTIME_SIGNALS", 0x0000042);
+    initConstant("_SC_RE_DUP_MAX", 0x000001a);
+    initConstant("_SC_RTSIG_MAX", 0x0000034);
+    initConstant("_SC_SAVED_IDS", 0x0000018);
+    initConstant("_SC_SEMAPHORES", 0x0000043);
+    initConstant("_SC_SEM_NSEMS_MAX", 0x0000035);
+    initConstant("_SC_SEM_VALUE_MAX", 0x0000036);
+    initConstant("_SC_SHARED_MEMORY_OBJECTS", 0x0000044);
+    initConstant("_SC_SIGQUEUE_MAX", 0x0000037);
+    initConstant("_SC_STREAM_MAX", 0x000001b);
+    initConstant("_SC_SYNCHRONIZED_IO", 0x0000045);
+    initConstant("_SC_THREADS", 0x000004f);
+    initConstant("_SC_THREAD_ATTR_STACKADDR", 0x0000050);
+    initConstant("_SC_THREAD_ATTR_STACKSIZE", 0x0000051);
+    initConstant("_SC_THREAD_DESTRUCTOR_ITERATIONS", 0x000004a);
+    initConstant("_SC_THREAD_KEYS_MAX", 0x000004b);
+    initConstant("_SC_THREAD_PRIORITY_SCHEDULING", 0x0000052);
+    initConstant("_SC_THREAD_PRIO_INHERIT", 0x0000053);
+    initConstant("_SC_THREAD_PRIO_PROTECT", 0x0000054);
+    initConstant("_SC_THREAD_SAFE_FUNCTIONS", 0x0000055);
+    initConstant("_SC_THREAD_STACK_MIN", 0x000004c);
+    initConstant("_SC_THREAD_THREADS_MAX", 0x000004d);
+    initConstant("_SC_TIMERS", 0x0000046);
+    initConstant("_SC_TIMER_MAX", 0x0000038);
+    initConstant("_SC_TTY_NAME_MAX", 0x000004e);
+    initConstant("_SC_TZNAME_MAX", 0x000001c);
+    initConstant("_SC_VERSION", 0x0000019);
+    initConstant("_SC_XBS5_ILP32_OFF32", 0x000002a);
+    initConstant("_SC_XBS5_ILP32_OFFBIG", 0x000002b);
+    initConstant("_SC_XBS5_LP64_OFF64", 0x000002c);
+    initConstant("_SC_XBS5_LPBIG_OFFBIG", 0x000002d);
+    initConstant("_SC_XOPEN_CRYPT", 0x000001d);
+    initConstant("_SC_XOPEN_ENH_I18N", 0x000001e);
+    initConstant("_SC_XOPEN_LEGACY", 0x0000024);
+    initConstant("_SC_XOPEN_REALTIME", 0x0000022);
+    initConstant("_SC_XOPEN_REALTIME_THREADS", 0x0000023);
+    initConstant("_SC_XOPEN_SHM", 0x000001f);
+    initConstant("_SC_XOPEN_UNIX", 0x0000029);
+    initConstant("_SC_XOPEN_VERSION", 0x0000020);
+    initConstant("_SC_XOPEN_XCU_VERSION", 0x0000021);
+  }
+
+  private static void initConstant(String fieldName, int value) {
     try {
-      for (Field field : OsConstants.class.getDeclaredFields()) {
-        final String fieldName = field.getName();
-
-        if (ERRNO_PATTERN.matcher(fieldName).matches() && field.getType() == int.class) {
-          field.setInt(null, errnos++);
-        }
-        // Type of file.
-        if (fieldName.equals(OsConstantsValues.S_IFMT)) {
-          field.setInt(null, OsConstantsValues.S_IFMT_VALUE);
-          continue;
-        }
-        // Directory.
-        if (fieldName.equals(OsConstantsValues.S_IFDIR)) {
-          field.setInt(null, OsConstantsValues.S_IFDIR_VALUE);
-          continue;
-        }
-        // Regular file.
-        if (fieldName.equals(OsConstantsValues.S_IFREG)) {
-          field.setInt(null, OsConstantsValues.S_IFREG_VALUE);
-          continue;
-        }
-        // Symbolic link.
-        if (fieldName.equals(OsConstantsValues.S_IFLNK)) {
-          field.setInt(null, OsConstantsValues.S_IFLNK_VALUE);
-        }
-
-        // File open modes.
-        if (OsConstantsValues.OPEN_MODE_VALUES.containsKey(fieldName)) {
-          field.setInt(null, OsConstantsValues.OPEN_MODE_VALUES.get(fieldName));
-        }
-      }
+      Field field = OsConstants.class.getField(fieldName);
+      field.setInt(field, value);
     } catch (ReflectiveOperationException e) {
-      throw new RuntimeException(e);
+      // ignore, this can occur when running on an older SDK that doesn't have a
+      // constant from a newer SDK
+    }
+  }
+
+  /** Returns the st_mode for the path. */
+  public static int getMode(String path) {
+    if (path == null) {
+      return 0;
+    }
+    int mode = 0;
+
+    File file = new File(path);
+    if (file.isDirectory()) {
+      mode |= OsConstants.S_IFDIR;
+    } else if (file.isFile()) {
+      mode |= OsConstants.S_IFREG;
+    } else if (!canonicalize(path).equals(path)) {
+      mode |= OsConstants.S_IFLNK;
+    }
+
+    // the Java File API doesn't have concepts for user vs group vs other permissions
+    // so just assume world permissions
+    if (file.canExecute()) {
+      mode |= OsConstants.S_IXUSR | OsConstants.S_IXGRP | OsConstants.S_IXOTH;
+    }
+    if (file.canRead()) {
+      mode |= OsConstants.S_IRUSR | OsConstants.S_IRGRP | OsConstants.S_IROTH;
+    }
+    if (file.canWrite()) {
+      mode |= OsConstants.S_IWUSR | OsConstants.S_IWGRP | OsConstants.S_IWOTH;
+    }
+    return mode;
+  }
+
+  private static String canonicalize(String path) {
+    try {
+      return new File(path).getCanonicalPath();
+    } catch (Throwable t) {
+      throw new RuntimeException(t);
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
index 042638bd7..0cdc986df 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageBackwardCompatibility.java
@@ -3,7 +3,6 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 
-import com.android.server.pm.parsing.library.PackageSharedLibraryUpdater;
 import java.util.List;
 import java.util.function.Supplier;
 import org.robolectric.annotation.Implementation;
@@ -25,9 +24,7 @@ public class ShadowPackageBackwardCompatibility {
    */
   @Implementation(minSdk = P)
   protected static boolean addOptionalUpdater(
-      List<PackageSharedLibraryUpdater> packageUpdaters,
-      String className,
-      Supplier<PackageSharedLibraryUpdater> defaultUpdater) {
+      List<Object> packageUpdaters, String className, Supplier<Object> defaultUpdater) {
     return false;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
index cb33a025d..b01305bff 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPackageManager.java
@@ -29,6 +29,7 @@ import static android.content.pm.PackageManager.SIGNATURE_SECOND_NOT_SIGNED;
 import static android.content.pm.PackageManager.VERIFICATION_ALLOW;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static com.google.common.collect.ImmutableList.toImmutableList;
 import static java.util.Arrays.asList;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
@@ -80,6 +81,7 @@ import android.util.Pair;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multimap;
 import com.google.errorprone.annotations.InlineMe;
@@ -1355,13 +1357,9 @@ public class ShadowPackageManager {
   protected List<ResolveInfo> queryOverriddenIntents(Intent intent, int flags) {
     List<ResolveInfo> overrides = resolveInfoForIntent.get(intent);
     if (overrides == null) {
-      return Collections.emptyList();
+      return ImmutableList.of();
     }
-    List<ResolveInfo> result = new ArrayList<>(overrides.size());
-    for (ResolveInfo resolveInfo : overrides) {
-      result.add(ShadowResolveInfo.newResolveInfo(resolveInfo));
-    }
-    return result;
+    return overrides.stream().map(ShadowResolveInfo::newResolveInfo).collect(toImmutableList());
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
index a23985865..73deac68a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPaint.java
@@ -15,8 +15,10 @@ import android.graphics.ColorFilter;
 import android.graphics.Paint;
 import android.graphics.Paint.FontMetricsInt;
 import android.graphics.PathEffect;
+import android.graphics.RectF;
 import android.graphics.Shader;
 import android.graphics.Typeface;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
@@ -29,7 +31,7 @@ import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
 @SuppressWarnings({"UnusedDeclaration"})
-@Implements(value = Paint.class, looseSignatures = true)
+@Implements(value = Paint.class)
 public class ShadowPaint {
 
   private int color;
@@ -505,8 +507,11 @@ public class ShadowPaint {
   }
 
   @Implementation(minSdk = N, maxSdk = N_MR1)
-  protected int nGetFontMetricsInt(Object nativePaint, Object nativeTypeface, Object fmi) {
-    return nGetFontMetricsInt((long) nativePaint, (FontMetricsInt) fmi);
+  protected int nGetFontMetricsInt(
+      long nativePaint,
+      long nativeTypeface,
+      @ClassName("android.graphics.Paint$FontMetricsInt") Object fmi) {
+    return nGetFontMetricsInt(nativePaint, (FontMetricsInt) fmi);
   }
 
   @Implementation(maxSdk = M)
@@ -549,29 +554,29 @@ public class ShadowPaint {
   @Implementation(minSdk = V.SDK_INT)
   @InDevelopment
   protected static float nGetRunCharacterAdvance(
-      Object /* long */ paintPtr,
-      Object /* char[] */ text,
-      Object /* int */ start,
-      Object /* int */ end,
-      Object /* int */ contextStart,
-      Object /* int */ contextEnd,
-      Object /* boolean */ isRtl,
-      Object /* int */ offset,
-      Object /* float[] */ advances,
-      Object /* int */ advancesIndex,
-      Object /* RectF */ drawingBounds,
-      Object /* RunInfo */ runInfo) {
+      long paintPtr,
+      char[] text,
+      int start,
+      int end,
+      int contextStart,
+      int contextEnd,
+      boolean isRtl,
+      int offset,
+      float[] advances,
+      int advancesIndex,
+      RectF drawingBounds,
+      @ClassName("android.graphics.Paint$RunInfo") Object runInfo) {
     return nGetRunCharacterAdvance(
-        (long) paintPtr,
-        (char[]) text,
-        (int) start,
-        (int) end,
-        (int) contextStart,
-        (int) contextEnd,
-        (boolean) isRtl,
-        (int) offset,
-        (float[]) advances,
-        (int) advancesIndex);
+        paintPtr,
+        text,
+        start,
+        end,
+        contextStart,
+        contextEnd,
+        isRtl,
+        offset,
+        advances,
+        advancesIndex);
   }
 
   @Implementation(minSdk = N, maxSdk = O_MR1)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
index 53d9570c0..f606249a5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowParcel.java
@@ -5,7 +5,6 @@ import static android.os.Build.VERSION_CODES.O_MR1;
 import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
-import static android.os.Build.VERSION_CODES.S;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 
 import android.os.BadParcelableException;
@@ -48,7 +47,7 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
  * IllegalArgumentException} or {@link IllegalStateException} for error-prone behavior normal {@link
  * Parcel} tolerates.
  */
-@Implements(value = Parcel.class, looseSignatures = true)
+@Implements(value = Parcel.class)
 public class ShadowParcel {
   protected static final String TAG = "Parcel";
 
@@ -338,24 +337,32 @@ public class ShadowParcel {
     nativeWriteByteArray(nativePtr, b, offset, len);
   }
 
-  @Implementation(maxSdk = R)
-  protected static void nativeWriteInt(long nativePtr, int val) {
+  @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
+  @Implementation
+  protected static int nativeWriteInt(long nativePtr, int val) {
     NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).writeInt(val);
+    return 0; /* OK */
   }
 
-  @Implementation(maxSdk = R)
-  protected static void nativeWriteLong(long nativePtr, long val) {
+  @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
+  @Implementation
+  protected static int nativeWriteLong(long nativePtr, long val) {
     NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).writeLong(val);
+    return 0; /* OK */
   }
 
-  @Implementation(maxSdk = R)
-  protected static void nativeWriteFloat(long nativePtr, float val) {
+  @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
+  @Implementation
+  protected static int nativeWriteFloat(long nativePtr, float val) {
     NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).writeFloat(val);
+    return 0; /* OK */
   }
 
-  @Implementation(maxSdk = R)
-  protected static void nativeWriteDouble(long nativePtr, double val) {
+  @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
+  @Implementation
+  protected static int nativeWriteDouble(long nativePtr, double val) {
     NATIVE_BYTE_BUFFER_REGISTRY.getNativeObject(nativePtr).writeDouble(val);
+    return 0; /* OK */
   }
 
   @Implementation(maxSdk = Q)
@@ -1125,7 +1132,8 @@ public class ShadowParcel {
     return randomAccessFile.getFD();
   }
 
-  @Implementation(minSdk = M, maxSdk = R)
+  @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
+  @Implementation(minSdk = M)
   protected static long nativeWriteFileDescriptor(long nativePtr, FileDescriptor val) {
     // The Java version of FileDescriptor stored the fd in a field called "fd", and the Android
     // version changed the field name to "descriptor". But it looks like Robolectric uses the
@@ -1162,37 +1170,6 @@ public class ShadowParcel {
     return nativeReadString(nativePtr);
   }
 
-  // need to use looseSignatures for the S methods because method signatures differ only by return
-  // type
-  @Implementation(minSdk = S)
-  protected static int nativeWriteInt(Object nativePtr, Object val) {
-    nativeWriteInt((long) nativePtr, (int) val);
-    return 0; /* OK */
-  }
-
-  @Implementation(minSdk = S)
-  protected static int nativeWriteLong(Object nativePtr, Object val) {
-    nativeWriteLong((long) nativePtr, (long) val);
-    return 0; /* OK */
-  }
-
-  @Implementation(minSdk = S)
-  protected static int nativeWriteFloat(Object nativePtr, Object val) {
-    nativeWriteFloat((long) nativePtr, (float) val);
-    return 0; /* OK */
-  }
-
-  @Implementation(minSdk = S)
-  protected static int nativeWriteDouble(Object nativePtr, Object val) {
-    nativeWriteDouble((long) nativePtr, (double) val);
-    return 0; /* OK */
-  }
-
-  @Implementation(minSdk = S)
-  protected static void nativeWriteFileDescriptor(Object nativePtr, Object val) {
-    nativeWriteFileDescriptor((long) nativePtr, (FileDescriptor) val);
-  }
-
   @Resetter
   public static void reset() {
     pairedCreators.clear();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java
index 73d0a75dd..28ccc105f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPathIterator.java
@@ -3,7 +3,9 @@ package org.robolectric.shadows;
 import android.graphics.PathIterator;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.InDevelopment;
 import org.robolectric.versioning.AndroidVersions.U;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link PathIterator} in LEGACY graphics. */
 @Implements(
@@ -21,4 +23,11 @@ public class ShadowPathIterator {
   protected static int nNext(long nativeIterator, long pointsAddress) {
     return PathIterator.VERB_DONE;
   }
+
+  /** Also shadow the upcoming indevelopment nNextHost */
+  @InDevelopment
+  @Implementation(minSdk = V.SDK_INT)
+  protected static int nNextHost(long nativeIterator, float[] points) {
+    return PathIterator.VERB_DONE;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
index 1de1f93d0..6797cd512 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedAsyncTask.java
@@ -3,7 +3,7 @@ package org.robolectric.shadows;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.AsyncTask;
-import androidx.test.annotation.Beta;
+import com.google.common.annotations.Beta;
 import java.util.concurrent.Executor;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -52,7 +52,7 @@ public class ShadowPausedAsyncTask<Params, Progress, Result> extends ShadowAsync
   /**
    * Globally override the executor used for all AsyncTask#execute* calls.
    *
-   * <p>This can be useful if you want to use a more determinstic executor for tests, like {@link
+   * <p>This can be useful if you want to use a more deterministic executor for tests, like {@link
    * org.robolectric.android.util.concurrent.PausedExecutorService} or {@link
    * org.robolectric.android.util.concurrent.InlineExecutorService}.
    *
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
index efeed94bd..5fa5bc3e3 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedChoreographer.java
@@ -2,20 +2,28 @@ package org.robolectric.shadows;
 
 import static org.robolectric.util.reflector.Reflector.reflector;
 
+import android.graphics.FrameInfo;
+import android.os.Build.VERSION_CODES;
 import android.os.Looper;
 import android.view.Choreographer;
 import android.view.DisplayEventReceiver;
 import com.android.internal.annotations.VisibleForTesting;
+import java.util.Arrays;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
+import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowDisplayEventReceiver.DisplayEventReceiverReflector;
+import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.NMR1;
 import org.robolectric.versioning.AndroidVersions.O;
+import org.robolectric.versioning.AndroidVersions.Q;
+import org.robolectric.versioning.AndroidVersions.S;
 import org.robolectric.versioning.AndroidVersions.T;
 import org.robolectric.versioning.AndroidVersions.U;
 
@@ -33,51 +41,82 @@ import org.robolectric.versioning.AndroidVersions.U;
     isInAndroidSdk = false)
 public class ShadowPausedChoreographer extends ShadowChoreographer {
 
-  // keep track of all Loopers with active Choreographer so they can be selectively reset
-  private static final Set<Looper> choreographedLoopers = new CopyOnWriteArraySet<>();
+  // keep track of all active Choreographers so they can be selectively reset
+  private static final Set<Choreographer> activeChoreographers = new CopyOnWriteArraySet<>();
 
   @RealObject private Choreographer realChoreographer;
 
   @Implementation(maxSdk = NMR1.SDK_INT)
   protected void __constructor__(Looper looper) {
     reflector(ChoreographerReflector.class, realChoreographer).__constructor__(looper);
-    choreographedLoopers.add(looper);
+    activeChoreographers.add(realChoreographer);
   }
 
   @Implementation(minSdk = O.SDK_INT, maxSdk = T.SDK_INT)
   protected void __constructor__(Looper looper, int vsyncSource) {
     reflector(ChoreographerReflector.class, realChoreographer).__constructor__(looper, vsyncSource);
-    choreographedLoopers.add(looper);
+    activeChoreographers.add(realChoreographer);
   }
 
   @Implementation(minSdk = U.SDK_INT)
   protected void __constructor__(Looper looper, int vsyncSource, long layerHandle) {
     reflector(ChoreographerReflector.class, realChoreographer)
         .__constructor__(looper, vsyncSource, layerHandle);
-    choreographedLoopers.add(looper);
+    activeChoreographers.add(realChoreographer);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.N)
+  protected void dispose() {
+    activeChoreographers.remove(realChoreographer);
   }
 
   /**
-   * Resets the choreographer ThreadLocal instance for the given Looper
+   * Resets the Choreographer state
    *
-   * @param looper an active looper whose queue has already been reset
+   * <p>Called from ShadowPausedLooper reset to ensure this occurs before Loopers are reset.
    */
-  static void reset(Looper looper) {
-    if (choreographedLoopers.remove(looper)) {
+  static void resetChoreographers() {
+    for (Choreographer choreographer : activeChoreographers) {
+      Looper looper = reflector(ChoreographerReflector.class, choreographer).getLooper();
+      ShadowPausedChoreographer shadowChoreographer = Shadow.extract(choreographer);
       if (looper.getThread() == Thread.currentThread()) {
-        reflector(ChoreographerReflector.class).getThreadInstance().remove();
+        shadowChoreographer.resetState();
       } else if (looper.getThread().isAlive()) {
         ShadowPausedLooper shadowLooper = Shadow.extract(looper);
-        shadowLooper.postSyncQuiet(
-            () -> reflector(ChoreographerReflector.class).getThreadInstance().remove());
+        shadowLooper.postSyncQuiet(shadowChoreographer::resetState);
       }
     }
   }
 
-  // safeguard that clears the list of choreographed Loopers. Intended to clean up references
-  // to Loopers that are no longer running
-  static void clearLoopers() {
-    choreographedLoopers.clear();
+  private void resetState() {
+    ChoreographerReflector choreographerReflector =
+        reflector(ChoreographerReflector.class, realChoreographer);
+    choreographerReflector.setLastFrameTimeNanos(Long.MIN_VALUE);
+    if (RuntimeEnvironment.getApiLevel() >= S.SDK_INT) {
+      choreographerReflector.setLastFrameIntervalNanos(0);
+    }
+    choreographerReflector.setFrameScheduled(false);
+    Object[] /* CallbackQueue */ callbackQueues = choreographerReflector.getCallbackQueues();
+    for (Object callbackQueue : callbackQueues) {
+      reflector(CallbackQueueReflector.class, callbackQueue).setHead(null);
+    }
+    choreographerReflector.setCallbackPool(null);
+    choreographerReflector.setCallbacksRunning(false);
+    if (RuntimeEnvironment.getApiLevel() >= U.SDK_INT) {
+      ReflectionHelpers.callInstanceMethod(
+          choreographerReflector.getFrameData(),
+          "update",
+          ClassParameter.from(long.class, 0),
+          ClassParameter.from(int.class, 0));
+    }
+
+    if (RuntimeEnvironment.getApiLevel() >= Q.SDK_INT) {
+      Arrays.fill(((FrameInfo) choreographerReflector.getFrameInfo()).frameInfo, 0);
+    }
+    DisplayEventReceiver receiver =
+        reflector(ChoreographerReflector.class, realObject).getReceiver();
+    ShadowDisplayEventReceiver shadowReceiver = Shadow.extract(receiver);
+    shadowReceiver.resetState();
   }
 
   /**
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
index c836b0739..4eeada1bb 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedLooper.java
@@ -303,11 +303,11 @@ public final class ShadowPausedLooper extends ShadowLooper {
     }
 
     createMainThreadAndLooperIfNotAlive();
+    ShadowPausedChoreographer.resetChoreographers();
     for (Looper looper : getLoopers()) {
       ShadowPausedLooper shadowPausedLooper = Shadow.extract(looper);
       shadowPausedLooper.resetLooperToInitialState();
     }
-    ShadowPausedChoreographer.clearLoopers();
   }
 
   private static final Object instrumentationTestMainThreadLock = new Object();
@@ -392,7 +392,6 @@ public final class ShadowPausedLooper extends ShadowLooper {
           && !(realLooper == Looper.getMainLooper() && looperMode != Mode.INSTRUMENTATION_TEST)) {
         unPause();
       }
-      ShadowPausedChoreographer.reset(realLooper);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
index b5810a9f2..1390d0acc 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPausedMessageQueue.java
@@ -4,8 +4,6 @@ import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static com.google.common.base.Preconditions.checkState;
 import static org.robolectric.RuntimeEnvironment.getApiLevel;
-import static org.robolectric.shadow.api.Shadow.invokeConstructor;
-import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.os.Looper;
@@ -25,7 +23,6 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.res.android.NativeObjRegistry;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowMessage.MessageReflector;
-import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.Scheduler;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
@@ -38,7 +35,7 @@ import org.robolectric.versioning.AndroidVersions.V;
  * <p>This class should not be referenced directly. Use {@link ShadowMessageQueue} instead.
  */
 @SuppressWarnings("SynchronizeOnNonFinalField")
-@Implements(value = MessageQueue.class, isInAndroidSdk = false, looseSignatures = true)
+@Implements(value = MessageQueue.class, isInAndroidSdk = false)
 public class ShadowPausedMessageQueue extends ShadowMessageQueue {
 
   @RealObject private MessageQueue realQueue;
@@ -54,7 +51,7 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
   // versions
   @Implementation
   protected void __constructor__(boolean quitAllowed) {
-    invokeConstructor(MessageQueue.class, realQueue, from(boolean.class, quitAllowed));
+    reflector(MessageQueueReflector.class, realQueue).__constructor__(quitAllowed);
     long ptr = nativeQueueRegistry.register(this);
     reflector(MessageQueueReflector.class, realQueue).setPtr(ptr);
     clockListener =
@@ -76,12 +73,9 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     ShadowPausedSystemClock.removeListener(q.clockListener);
   }
 
-  // use the generic Object parameter types here, to avoid conflicts with the non-static
-  // nativePollOnce
-  @Implementation(maxSdk = LOLLIPOP_MR1)
-  protected static void nativePollOnce(Object ptr, Object timeoutMillis) {
-    long ptrLong = (long) ptr;
-    nativeQueueRegistry.getNativeObject(ptrLong).nativePollOnce(ptrLong, (int) timeoutMillis);
+  @Implementation(maxSdk = LOLLIPOP_MR1, methodName = "nativePollOnce")
+  protected static void nativePollOncePreM(long ptr, int timeoutMillis) {
+    nativeQueueRegistry.getNativeObject(ptr).nativePollOnce(ptr, timeoutMillis);
   }
 
   @Implementation(minSdk = M)
@@ -126,13 +120,13 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     // mark the queue as blocked and wait on a new message.
     synchronized (realQueue) {
       if (isIdle()) {
-        ReflectionHelpers.setField(realQueue, "mBlocked", true);
+        reflector(MessageQueueReflector.class, realQueue).setBlocked(true);
         try {
           realQueue.wait(timeout);
         } catch (InterruptedException ignored) {
           // Fall through and unblock with no messages.
         } finally {
-          ReflectionHelpers.setField(realQueue, "mBlocked", false);
+          reflector(MessageQueueReflector.class, realQueue).setBlocked(false);
         }
       }
     }
@@ -326,7 +320,7 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
           }
         }
         if (msg.isAsynchronous() && getApiLevel() >= V.SDK_INT) {
-          queueReflector.setAsyncMessageCount(queueReflector.getAsyncMessageCount() - 1);
+            queueReflector.setAsyncMessageCount(queueReflector.getAsyncMessageCount() - 1);
         }
       }
       return msg;
@@ -440,6 +434,9 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
   /** Accessor interface for {@link MessageQueue}'s internals. */
   @ForType(MessageQueue.class)
   private interface MessageQueueReflector {
+    @Direct
+    void __constructor__(boolean quitAllowed);
+
     @Direct
     boolean enqueueMessage(Message msg, long when);
 
@@ -472,7 +469,6 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
     @Accessor("mQuitting")
     boolean getQuitting();
 
-    // start for android V
     @Accessor("mLast")
     void setLast(Message msg);
 
@@ -481,6 +477,8 @@ public class ShadowPausedMessageQueue extends ShadowMessageQueue {
 
     @Accessor("mAsyncMessageCount")
     void setAsyncMessageCount(int asyncMessageCount);
-    // end android V
+
+    @Accessor("mBlocked")
+    void setBlocked(boolean blocked);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
index 7da58626c..73bcfa052 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPendingIntent.java
@@ -249,7 +249,7 @@ public class ShadowPendingIntent {
             (Activity) null,
             intentToSend,
             requestCode,
-            (Bundle) null);
+            options);
       }
     } else if (isBroadcast()) {
       for (Intent intentToSend : intentsToSend) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
index 5767d88fe..cff38ebb1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindow.java
@@ -17,8 +17,7 @@ import org.robolectric.util.reflector.ForType;
 @Implements(
     className = "com.android.internal.policy.PhoneWindow",
     isInAndroidSdk = false,
-    minSdk = M,
-    looseSignatures = true)
+    minSdk = M)
 public class ShadowPhoneWindow extends ShadowWindow {
   protected @RealObject Window realWindow;
   protected boolean decorFitsSystemWindows = true;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
index 6d658e064..5ebebd33d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPhoneWindowFor22.java
@@ -8,11 +8,10 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.reflector.ForType;
 
-/** Shadow for the API 16-22 PhoneWindow.li */
+/** Shadow for the API 16-22 PhoneWindow. */
 @Implements(
     className = "com.android.internal.policy.impl.PhoneWindow",
     maxSdk = LOLLIPOP_MR1,
-    looseSignatures = true,
     isInAndroidSdk = false)
 public class ShadowPhoneWindowFor22 extends ShadowPhoneWindow {
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
index 9f3c381b8..ee6befb04 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPixelCopy.java
@@ -20,7 +20,9 @@ import android.view.View;
 import android.view.ViewRootImpl;
 import android.view.Window;
 import android.view.WindowManagerGlobal;
+import java.util.concurrent.Executor;
 import java.util.function.Consumer;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
@@ -39,7 +41,7 @@ import org.robolectric.versioning.AndroidVersions.U;
  * <p>If listenerThread is backed by a paused looper, make sure to call ShadowLooper.idle() to
  * ensure the screenshot finishes.
  */
-@Implements(value = PixelCopy.class, minSdk = O, looseSignatures = true)
+@Implements(value = PixelCopy.class, minSdk = O)
 public class ShadowPixelCopy {
 
   @Implementation
@@ -114,9 +116,9 @@ public class ShadowPixelCopy {
 
   @Implementation(minSdk = U.SDK_INT)
   protected static void request(
-      /* PixelCopy.Request */ Object requestObject, /* Executor */
-      Object callbackExecutor, /* Consumer<Result> */
-      Object listener) {
+      @ClassName("android.view.PixelCopy$Request") Object requestObject,
+      Executor callbackExecutor,
+      Consumer</*android.view.PixelCopy$Result*/ ?> listener) {
     PixelCopy.Request request = (PixelCopy.Request) requestObject;
     RequestReflector requestReflector = reflector(RequestReflector.class, request);
     OnPixelCopyFinishedListener legacyListener =
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
index ccf0c941d..890a6b7ec 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPosix.java
@@ -6,6 +6,7 @@ import android.system.StructStat;
 import java.io.File;
 import java.io.FileDescriptor;
 import java.time.Duration;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
@@ -13,8 +14,7 @@ import org.robolectric.annotation.Implements;
 @Implements(
     className = "libcore.io.Posix",
     maxSdk = Build.VERSION_CODES.N_MR1,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+    isInAndroidSdk = false)
 public class ShadowPosix {
   @Implementation
   public void mkdir(String path, int mode) throws ErrnoException {
@@ -24,8 +24,9 @@ public class ShadowPosix {
   @Implementation
   // actually preventing a 'static' mismatch
   @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
-  public static Object stat(String path) throws ErrnoException {
-    int mode = OsConstantsValues.getMode(path);
+  public static @ClassName("android.system.StructStat") Object stat(String path)
+      throws ErrnoException {
+    int mode = ShadowOsConstants.getMode(path);
     long size = 0;
     long modifiedTime = 0;
     if (path != null) {
@@ -54,14 +55,16 @@ public class ShadowPosix {
   @Implementation
   // actually preventing a 'static' mismatch
   @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
-  protected static Object lstat(String path) throws ErrnoException {
+  protected static @ClassName("android.system.StructStat") Object lstat(String path)
+      throws ErrnoException {
     return stat(path);
   }
 
   @Implementation
   // actually preventing a 'static' mismatch
   @SuppressWarnings("robolectric.ShadowReturnTypeMismatch")
-  protected static Object fstat(FileDescriptor fd) throws ErrnoException {
+  protected static @ClassName("android.system.StructStat") Object fstat(FileDescriptor fd)
+      throws ErrnoException {
     return stat(null);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
index ee0fd122d..bb3f0e575 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowPowerManager.java
@@ -2,7 +2,6 @@ package org.robolectric.shadows;
 
 import static android.content.Intent.ACTION_SCREEN_OFF;
 import static android.content.Intent.ACTION_SCREEN_ON;
-import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.O;
@@ -42,6 +41,7 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -49,49 +49,50 @@ import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow of PowerManager */
-@Implements(value = PowerManager.class, looseSignatures = true)
+@Implements(value = PowerManager.class)
 public class ShadowPowerManager {
 
   @RealObject private PowerManager realPowerManager;
 
-  private boolean isInteractive = true;
-  private boolean isPowerSaveMode = false;
-  private boolean isDeviceIdleMode = false;
-  private boolean isLightDeviceIdleMode = false;
-  @Nullable private Duration batteryDischargePrediction = null;
-  private boolean isBatteryDischargePredictionPersonalized = false;
+  private static boolean isInteractive = true;
+  private static boolean isPowerSaveMode = false;
+  private static boolean isDeviceIdleMode = false;
+  private static boolean isLightDeviceIdleMode = false;
+  @Nullable private static Duration batteryDischargePrediction = null;
+  private static boolean isBatteryDischargePredictionPersonalized = false;
 
   @PowerManager.LocationPowerSaveMode
-  private int locationMode = PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
+  private static int locationMode = PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
 
-  private final List<String> rebootReasons = new ArrayList<>();
-  private final Map<String, Boolean> ignoringBatteryOptimizations = new HashMap<>();
+  private static final List<String> rebootReasons = new ArrayList<>();
+  private static final Map<String, Boolean> ignoringBatteryOptimizations = new HashMap<>();
 
-  private int thermalStatus = 0;
+  private static int thermalStatus = 0;
   // Intentionally use Object instead of PowerManager.OnThermalStatusChangedListener to avoid
   // ClassLoader exceptions on earlier SDKs that don't have this class.
-  private final Set<Object> thermalListeners = new HashSet<>();
+  private static final Set<Object> thermalListeners = new HashSet<>();
 
-  private final Set<String> ambientDisplaySuppressionTokens =
+  private static final Set<String> ambientDisplaySuppressionTokens =
       Collections.synchronizedSet(new HashSet<>());
-  private volatile boolean isAmbientDisplayAvailable = true;
-  private volatile boolean isRebootingUserspaceSupported = false;
-  private volatile boolean adaptivePowerSaveEnabled = false;
+  private static volatile boolean isAmbientDisplayAvailable = true;
+  private static volatile boolean isRebootingUserspaceSupported = false;
+  private static volatile boolean adaptivePowerSaveEnabled = false;
 
   private static PowerManager.WakeLock latestWakeLock;
 
-  private boolean lowPowerStandbyEnabled = false;
-  private boolean lowPowerStandbySupported = false;
-  private boolean exemptFromLowPowerStandby = false;
-  private final Set<String> allowedFeatures = new HashSet<String>();
+  private static boolean lowPowerStandbyEnabled = false;
+  private static boolean lowPowerStandbySupported = false;
+  private static boolean exemptFromLowPowerStandby = false;
+  private static final Set<String> allowedFeatures = new HashSet<String>();
 
   @Implementation
   protected PowerManager.WakeLock newWakeLock(int flags, String tag) {
-    PowerManager.WakeLock wl = Shadow.newInstanceOf(PowerManager.WakeLock.class);
-    ((ShadowWakeLock) Shadow.extract(wl)).setTag(tag);
+    PowerManager.WakeLock wl =
+        reflector(PowerManagerReflector.class, realPowerManager).newWakeLock(flags, tag);
     latestWakeLock = wl;
     return wl;
   }
@@ -161,6 +162,7 @@ public class ShadowPowerManager {
   /** Sets the value returned by {@link #isDeviceIdleMode()}. */
   public void setIsDeviceIdleMode(boolean isDeviceIdleMode) {
     this.isDeviceIdleMode = isDeviceIdleMode;
+    getContext().sendBroadcast(new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
   }
 
   /**
@@ -218,7 +220,8 @@ public class ShadowPowerManager {
 
   /** This function adds a listener for thermal status change. */
   @Implementation(minSdk = Q)
-  protected void addThermalStatusListener(Object listener) {
+  protected void addThermalStatusListener(
+      @ClassName("android.os.PowerManager$OnThermalStatusChangedListener") Object listener) {
     checkState(
         listener instanceof PowerManager.OnThermalStatusChangedListener,
         "Listener must implement PowerManager.OnThermalStatusChangedListener");
@@ -232,7 +235,8 @@ public class ShadowPowerManager {
 
   /** This function removes a listener for thermal status change. */
   @Implementation(minSdk = Q)
-  protected void removeThermalStatusListener(Object listener) {
+  protected void removeThermalStatusListener(
+      @ClassName("android.os.PowerManager$OnThermalStatusChangedListener") Object listener) {
     checkState(
         listener instanceof PowerManager.OnThermalStatusChangedListener,
         "Listener must implement PowerManager.OnThermalStatusChangedListener");
@@ -257,6 +261,26 @@ public class ShadowPowerManager {
   /** Discards the most recent {@code PowerManager.WakeLock}s */
   @Resetter
   public static void reset() {
+    isInteractive = true;
+    isPowerSaveMode = false;
+    isDeviceIdleMode = false;
+    isLightDeviceIdleMode = false;
+    batteryDischargePrediction = null;
+    isBatteryDischargePredictionPersonalized = false;
+    locationMode = PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
+    rebootReasons.clear();
+    ignoringBatteryOptimizations.clear();
+    thermalStatus = 0;
+    thermalListeners.clear();
+    ambientDisplaySuppressionTokens.clear();
+    isAmbientDisplayAvailable = true;
+    isRebootingUserspaceSupported = false;
+    adaptivePowerSaveEnabled = false;
+    latestWakeLock = null;
+    lowPowerStandbyEnabled = false;
+    lowPowerStandbySupported = false;
+    exemptFromLowPowerStandby = false;
+    allowedFeatures.clear();
     clearWakeLocks();
   }
 
@@ -438,10 +462,11 @@ public class ShadowPowerManager {
 
   @Implements(PowerManager.WakeLock.class)
   public static class ShadowWakeLock {
+    @RealObject private PowerManager.WakeLock realWakeLock;
+
     private boolean refCounted = true;
     private WorkSource workSource = null;
     private int timesHeld = 0;
-    private String tag = null;
     private List<Optional<Long>> timeoutTimestampList = new ArrayList<>();
 
     private void acquireInternal(Optional<Long> timeoutOptional) {
@@ -546,18 +571,18 @@ public class ShadowPowerManager {
     @HiddenApi
     @Implementation(minSdk = O)
     public String getTag() {
-      return tag;
+      return reflector(WakeLockReflector.class, realWakeLock).getTag();
     }
 
-    /** Sets the tag. */
-    @Implementation(minSdk = LOLLIPOP_MR1)
-    protected void setTag(String tag) {
-      this.tag = tag;
+    @ForType(PowerManager.WakeLock.class)
+    private interface WakeLockReflector {
+      @Accessor("mTag")
+      String getTag();
     }
   }
 
   private Context getContext() {
-    return reflector(ReflectorPowerManager.class, realPowerManager).getContext();
+    return reflector(PowerManagerReflector.class, realPowerManager).getContext();
   }
 
   @Implementation(minSdk = TIRAMISU)
@@ -607,12 +632,12 @@ public class ShadowPowerManager {
   }
 
   @Implementation(minSdk = UPSIDE_DOWN_CAKE)
-  protected Object /* LowPowerStandbyPortsLock */ newLowPowerStandbyPortsLock(
-      List<LowPowerStandbyPortDescription> ports) {
+  protected @ClassName("android.os.PowerManager$LowPowerStandbyPortsLock") Object
+      newLowPowerStandbyPortsLock(List<LowPowerStandbyPortDescription> ports) {
     PowerManager.LowPowerStandbyPortsLock lock =
         Shadow.newInstanceOf(PowerManager.LowPowerStandbyPortsLock.class);
     ((ShadowLowPowerStandbyPortsLock) Shadow.extract(lock)).setPorts(ports);
-    return (Object) lock;
+    return lock;
   }
 
   /** Shadow of {@link LowPowerStandbyPortsLock} to allow testing state. */
@@ -655,9 +680,12 @@ public class ShadowPowerManager {
 
   /** Reflector interface for {@link PowerManager}'s internals. */
   @ForType(PowerManager.class)
-  private interface ReflectorPowerManager {
+  private interface PowerManagerReflector {
 
     @Accessor("mContext")
     Context getContext();
+
+    @Direct
+    WakeLock newWakeLock(int flags, String tag);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
index 4a6ec4b06..e6c988a1d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowQueuedWork.java
@@ -25,7 +25,7 @@ public class ShadowQueuedWork {
       resetStateApi26();
     } else {
       QueuedWork.waitToFinish();
-      reflector(_QueuedWork_.class).setSingleThreadExecutor(null);
+      reflector(QueuedWorkReflector.class).setSingleThreadExecutor(null);
     }
   }
 
@@ -34,16 +34,15 @@ public class ShadowQueuedWork {
     if (queuedWorkHandler != null) {
       queuedWorkHandler.removeCallbacksAndMessages(null);
     }
-    _QueuedWork_ _queuedWorkStatic_ = reflector(_QueuedWork_.class);
-    _queuedWorkStatic_.getFinishers().clear();
-    _queuedWorkStatic_.getWork().clear();
-    _queuedWorkStatic_.setNumWaits(0);
-    _queuedWorkStatic_.setHandler(null);
+    QueuedWorkReflector queuedWorkReflector = reflector(QueuedWorkReflector.class);
+    queuedWorkReflector.getFinishers().clear();
+    queuedWorkReflector.getWork().clear();
+    queuedWorkReflector.setNumWaits(0);
   }
 
   /** Accessor interface for {@link QueuedWork}'s internals. */
   @ForType(QueuedWork.class)
-  interface _QueuedWork_ {
+  interface QueuedWorkReflector {
 
     @Static
     @Accessor("sFinishers")
@@ -65,5 +64,8 @@ public class ShadowQueuedWork {
     @Static
     @Accessor("sHandler")
     void setHandler(Handler handler);
+
+    @Static
+    void add(Runnable runnable);
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
index cb52b9a2c..d4c6f28ce 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRestrictionsManager.java
@@ -4,11 +4,17 @@ import android.content.RestrictionsManager;
 import android.os.Bundle;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow of {@link android.content.RestrictionsManager}. */
 @Implements(value = RestrictionsManager.class)
 public class ShadowRestrictionsManager {
-  private Bundle applicationRestrictions;
+  private static Bundle applicationRestrictions;
+
+  @Resetter
+  public static void reset() {
+    applicationRestrictions = null;
+  }
 
   /**
    * Sets the application restrictions as returned by {@link
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRollbackManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRollbackManager.java
index 0b30f3752..38e4e932a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRollbackManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRollbackManager.java
@@ -7,6 +7,7 @@ import java.util.ArrayList;
 import java.util.List;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** A Shadow for android.content.rollback.RollbackManager added in Android Q. */
 @Implements(
@@ -15,8 +16,8 @@ import org.robolectric.annotation.Implements;
     isInAndroidSdk = false)
 public final class ShadowRollbackManager {
 
-  private final List<RollbackInfo> availableRollbacks = new ArrayList<>();
-  private final List<RollbackInfo> recentlyCommittedRollbacks = new ArrayList<>();
+  private static final List<RollbackInfo> availableRollbacks = new ArrayList<>();
+  private static final List<RollbackInfo> recentlyCommittedRollbacks = new ArrayList<>();
 
   public void addAvailableRollbacks(RollbackInfo rollbackInfo) {
     availableRollbacks.add(rollbackInfo);
@@ -35,4 +36,10 @@ public final class ShadowRollbackManager {
   protected List<RollbackInfo> getRecentlyCommittedRollbacks() {
     return recentlyCommittedRollbacks;
   }
+
+  @Resetter
+  public static void reset() {
+    availableRollbacks.clear();
+    recentlyCommittedRollbacks.clear();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
index 21c5042e1..c95034043 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowRotationWatcherFor22.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
 
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
@@ -9,12 +10,12 @@ import org.robolectric.annotation.Implements;
 @Implements(
     className = "com.android.internal.policy.impl.PhoneWindow$RotationWatcher",
     isInAndroidSdk = false,
-    maxSdk = LOLLIPOP_MR1,
-    looseSignatures = true)
+    maxSdk = LOLLIPOP_MR1)
 public class ShadowRotationWatcherFor22 {
 
   @Implementation
-  protected void addWindow(Object phoneWindow) {
+  protected void addWindow(
+      @ClassName("com.android.internal.policy.impl.PhoneWindow") Object phoneWindow) {
     // ignore
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
index 4840614cd..4fb33ba34 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSafetyCenterManager.java
@@ -14,6 +14,7 @@ import java.util.Map;
 import java.util.Set;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow for {@link SafetyCenterManager}. */
 @Implements(
@@ -22,22 +23,22 @@ import org.robolectric.annotation.Implements;
     isInAndroidSdk = false)
 public class ShadowSafetyCenterManager {
 
-  private final Object lock = new Object();
+  private static final Object lock = new Object();
 
   @GuardedBy("lock")
-  private final Map<String, SafetySourceData> dataById = new HashMap<>();
+  private static final Map<String, SafetySourceData> dataById = new HashMap<>();
 
   @GuardedBy("lock")
-  private final Map<String, SafetyEvent> eventsById = new HashMap<>();
+  private static final Map<String, SafetyEvent> eventsById = new HashMap<>();
 
   @GuardedBy("lock")
-  private final Map<String, SafetySourceErrorDetails> errorsById = new HashMap<>();
+  private static final Map<String, SafetySourceErrorDetails> errorsById = new HashMap<>();
 
   @GuardedBy("lock")
-  private final Set<String> throwForId = new HashSet<>();
+  private static final Set<String> throwForId = new HashSet<>();
 
   @GuardedBy("lock")
-  private boolean enabled = false;
+  private static boolean enabled = false;
 
   @Implementation
   protected boolean isSafetyCenterEnabled() {
@@ -85,7 +86,7 @@ public class ShadowSafetyCenterManager {
   }
 
   @GuardedBy("lock")
-  private void maybeThrowForId(String safetySourceId) {
+  private static void maybeThrowForId(String safetySourceId) {
     if (throwForId.contains(safetySourceId)) {
       throw new IllegalArgumentException(String.format("%s is invalid", safetySourceId));
     }
@@ -97,7 +98,7 @@ public class ShadowSafetyCenterManager {
    */
   public void setSafetyCenterEnabled(boolean enabled) {
     synchronized (lock) {
-      this.enabled = enabled;
+      ShadowSafetyCenterManager.enabled = enabled;
     }
   }
 
@@ -129,4 +130,15 @@ public class ShadowSafetyCenterManager {
       return errorsById.get(safetySourceId);
     }
   }
+
+  @Resetter
+  public static void reset() {
+    synchronized (lock) {
+      dataById.clear();
+      eventsById.clear();
+      errorsById.clear();
+      throwForId.clear();
+      enabled = false;
+    }
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
index 1a4cc863d..ddd7bbbcd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSensorManager.java
@@ -20,23 +20,34 @@ import com.google.common.collect.Multimaps;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Collectors;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 
-@Implements(value = SensorManager.class, looseSignatures = true)
+/** Shadow for {@link SensorManager}. */
+@Implements(value = SensorManager.class)
 public class ShadowSensorManager {
-  public boolean forceListenersToFail = false;
-  private final Multimap<Integer, Sensor> sensorMap =
+  private static AtomicBoolean forceListenersToFail = new AtomicBoolean();
+  private static final Multimap<Integer, Sensor> sensorMap =
       Multimaps.synchronizedMultimap(HashMultimap.create());
-  private final Multimap<SensorEventListener, Sensor> listeners =
+  private static final Multimap<SensorEventListener, Sensor> listeners =
       Multimaps.synchronizedMultimap(HashMultimap.create());
 
   @RealObject private SensorManager realObject;
 
+  @Resetter
+  public static void reset() {
+    sensorMap.clear();
+    listeners.clear();
+    forceListenersToFail.set(false);
+  }
+
   /**
    * Provide a Sensor for the indicated sensor type.
    *
@@ -110,9 +121,13 @@ public class ShadowSensorManager {
     return registerListener(listener, sensor, rate);
   }
 
+  public void setForceListenersToFail(boolean forceListenersToFail) {
+    this.forceListenersToFail.set(forceListenersToFail);
+  }
+
   @Implementation
   protected boolean registerListener(SensorEventListener listener, Sensor sensor, int rate) {
-    if (forceListenersToFail) {
+    if (this.forceListenersToFail.get()) {
       return false;
     }
     listeners.put(listener, sensor);
@@ -243,7 +258,8 @@ public class ShadowSensorManager {
   }
 
   @Implementation(minSdk = O)
-  protected Object createDirectChannel(MemoryFile mem) {
+  protected @ClassName("android.hardware.SensorDirectChannel") Object createDirectChannel(
+      MemoryFile mem) {
     return ReflectionHelpers.callConstructor(
         SensorDirectChannel.class,
         ClassParameter.from(SensorManager.class, realObject),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
index f9fe035f7..eeb9b1414 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowServiceManager.java
@@ -43,9 +43,11 @@ import android.content.pm.ICrossProfileApps;
 import android.content.pm.ILauncherApps;
 import android.content.pm.IShortcutService;
 import android.content.rollback.IRollbackManager;
+import android.credentials.ICredentialManager;
 import android.hardware.ISensorPrivacyManager;
 import android.hardware.biometrics.IAuthService;
 import android.hardware.biometrics.IBiometricService;
+import android.hardware.display.IColorDisplayManager;
 import android.hardware.fingerprint.IFingerprintService;
 import android.hardware.input.IInputManager;
 import android.hardware.location.IContextHubService;
@@ -112,6 +114,7 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow for {@link ServiceManager}. */
 @SuppressWarnings("NewApi")
@@ -125,14 +128,22 @@ public class ShadowServiceManager {
   @GuardedBy("ShadowServiceManager.class")
   private static final Set<String> unavailableServices = new HashSet<>();
 
-  /** Represents the type of implementation to generate for the Binder interface */
-  private enum BinderProxyType {
+  /** Represents the type of implementation to use for the Binder interface */
+  private enum BinderType {
     /* use ReflectionHelpers.createNullProxy */
-    NULL,
+    NULL_PROXY,
     /* use ReflectionHelpers.createDeepProxy */
-    DEEP,
+    DEEP_PROXY,
     /* use ReflectionHelpers.createDelegatingProxy */
-    DELEGATING
+    DELEGATING_PROXY,
+
+    /**
+     * Use a real concrete implementation of the binder interface. One technique is to use the aidl
+     * compiler generated 'Default' implementation of the binder interface, and use shadows to fill
+     * in the missing functionality and adjust to differences across the supported Android platform
+     * versions
+     */
+    CONCRETE
   }
 
   /**
@@ -143,20 +154,20 @@ public class ShadowServiceManager {
 
     private final Class<? extends IInterface> clazz;
     private final String className;
-    private final BinderProxyType proxyType;
+    private final BinderType binderType;
     private Binder cachedBinder;
     private final Object delegate;
 
     BinderService(
         Class<? extends IInterface> clazz,
         String className,
-        BinderProxyType proxyType,
+        BinderType binderType,
         @Nullable Object delegate) {
       this.clazz = clazz;
       this.className = className;
-      this.proxyType = proxyType;
+      this.binderType = binderType;
       this.delegate = delegate;
-      if (proxyType == BinderProxyType.DELEGATING) {
+      if (binderType == BinderType.DELEGATING_PROXY || binderType == BinderType.CONCRETE) {
         checkNotNull(delegate);
       }
     }
@@ -165,22 +176,23 @@ public class ShadowServiceManager {
     IBinder getBinder() {
       if (cachedBinder == null) {
         cachedBinder = new Binder();
-
-        cachedBinder.attachInterface(createProxy(), className);
+        cachedBinder.attachInterface(createBinderImplementation(), className);
       }
       return cachedBinder;
     }
 
-    private IInterface createProxy() {
-      switch (proxyType) {
-        case NULL:
+    private IInterface createBinderImplementation() {
+      switch (binderType) {
+        case NULL_PROXY:
           return ReflectionHelpers.createNullProxy(clazz);
-        case DEEP:
+        case DEEP_PROXY:
           return ReflectionHelpers.createDeepProxy(clazz);
-        case DELEGATING:
+        case DELEGATING_PROXY:
           return ReflectionHelpers.createDelegatingProxy(clazz, delegate);
+        case CONCRETE:
+          return (IInterface) delegate;
       }
-      throw new IllegalStateException("unrecognized proxy type " + proxyType);
+      throw new IllegalStateException("unrecognized binder type " + binderType);
     }
   }
 
@@ -212,13 +224,13 @@ public class ShadowServiceManager {
     addBinderService(binderServices, Context.WALLPAPER_SERVICE, IWallpaperManager.class);
     addBinderService(binderServices, Context.BLUETOOTH_SERVICE, IBluetooth.class);
     addBinderService(binderServices, Context.WINDOW_SERVICE, IWindowManager.class);
-    addBinderService(binderServices, Context.NFC_SERVICE, INfcAdapter.class, BinderProxyType.DEEP);
+    addBinderService(binderServices, Context.NFC_SERVICE, INfcAdapter.class, BinderType.DEEP_PROXY);
     addBinderService(binderServices, Context.USER_SERVICE, IUserManager.class);
     addBinderService(
         binderServices,
         BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE,
         IBluetoothManager.class,
-        BinderProxyType.DELEGATING,
+        BinderType.DELEGATING_PROXY,
         IBluetoothManagerDelegates.createDelegate());
 
     addBinderService(binderServices, Context.APP_OPS_SERVICE, IAppOpsService.class);
@@ -231,17 +243,20 @@ public class ShadowServiceManager {
     addBinderService(binderServices, Context.USAGE_STATS_SERVICE, IUsageStatsManager.class);
     addBinderService(binderServices, Context.MEDIA_ROUTER_SERVICE, IMediaRouterService.class);
     addBinderService(
-        binderServices, Context.MEDIA_SESSION_SERVICE, ISessionManager.class, BinderProxyType.DEEP);
+        binderServices,
+        Context.MEDIA_SESSION_SERVICE,
+        ISessionManager.class,
+        BinderType.DEEP_PROXY);
     addBinderService(
         binderServices,
         Context.VOICE_INTERACTION_MANAGER_SERVICE,
         IVoiceInteractionManagerService.class,
-        BinderProxyType.DEEP);
+        BinderType.DEEP_PROXY);
     addBinderService(
         binderServices,
         Context.LAUNCHER_APPS_SERVICE,
         ILauncherApps.class,
-        BinderProxyType.DELEGATING,
+        BinderType.DELEGATING_PROXY,
         new LauncherAppsDelegate());
 
     if (RuntimeEnvironment.getApiLevel() >= M) {
@@ -254,7 +269,7 @@ public class ShadowServiceManager {
           binderServices,
           Context.WIFI_SCANNING_SERVICE,
           IWifiScanner.class,
-          BinderProxyType.DELEGATING,
+          BinderType.DELEGATING_PROXY,
           new WifiScannerDelegate());
     }
     if (RuntimeEnvironment.getApiLevel() >= N_MR1) {
@@ -283,6 +298,7 @@ public class ShadowServiceManager {
       addBinderService(binderServices, Context.ROLLBACK_SERVICE, IRollbackManager.class);
       addBinderService(binderServices, Context.THERMAL_SERVICE, IThermalService.class);
       addBinderService(binderServices, Context.BUGREPORT_SERVICE, IDumpstate.class);
+      addBinderService(binderServices, Context.COLOR_DISPLAY_SERVICE, IColorDisplayManager.class);
     }
     if (RuntimeEnvironment.getApiLevel() >= R) {
       addBinderService(binderServices, Context.APP_INTEGRITY_SERVICE, IAppIntegrityManager.class);
@@ -317,9 +333,29 @@ public class ShadowServiceManager {
     }
     if (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE) {
       addBinderService(binderServices, Context.VIRTUAL_DEVICE_SERVICE, IVirtualDeviceManager.class);
+      addBinderService(binderServices, Context.CREDENTIAL_SERVICE, ICredentialManager.class);
       addBinderService(
           binderServices, Context.WEARABLE_SENSING_SERVICE, IWearableSensingManager.class);
     }
+    if (RuntimeEnvironment.getApiLevel() >= V.SDK_INT) {
+      // TODO: replace strings with references once compiling against V
+      addBinderService(
+          binderServices,
+          "sensitive_content_protection_service" /* Context.SENSITIVE_CONTENT_PROTECTION_SERVICE */,
+          "android.view.ISensitiveContentProtectionManager"
+          /*ISensitiveContentProtectionManager.class*/ );
+
+      addBinderService(
+          binderServices,
+          "grammatical_inflection" /* Context.GRAMMATICAL_INFLECTION_SERVICE */,
+          "android.app.IGrammaticalInflectionManager" /* IGrammaticalInflectionManager.class */);
+
+      addBinderServiceIfClassExists(
+          binderServices,
+          "protolog_configuration" /* Context.PROTOLOG_CONFIGURATION_SERVICE, */,
+          "com.android.internal.protolog.ProtoLogConfigurationService"
+          /* new ProtoLogConfigurationServiceImpl.class */ );
+    }
 
     return binderServices;
   }
@@ -327,14 +363,14 @@ public class ShadowServiceManager {
   protected static void addBinderService(
       Map<String, BinderService> binderServices, String name, Class<? extends IInterface> clazz) {
     addBinderService(
-        binderServices, name, clazz, clazz.getCanonicalName(), BinderProxyType.NULL, null);
+        binderServices, name, clazz, clazz.getCanonicalName(), BinderType.NULL_PROXY, null);
   }
 
   private static void addBinderService(
       Map<String, BinderService> binderServices,
       String name,
       Class<? extends IInterface> clazz,
-      BinderProxyType proxyType) {
+      BinderType proxyType) {
     addBinderService(binderServices, name, clazz, clazz.getCanonicalName(), proxyType, null);
   }
 
@@ -346,14 +382,14 @@ public class ShadowServiceManager {
     } catch (ClassNotFoundException e) {
       throw new RuntimeException(e);
     }
-    addBinderService(binderServices, name, clazz, className, BinderProxyType.NULL, null);
+    addBinderService(binderServices, name, clazz, className, BinderType.NULL_PROXY, null);
   }
 
   private static void addBinderService(
       Map<String, BinderService> binderServices,
       String name,
       Class<? extends IInterface> clazz,
-      BinderProxyType proxyType,
+      BinderType proxyType,
       @Nullable Object delegate) {
     addBinderService(binderServices, name, clazz, clazz.getCanonicalName(), proxyType, delegate);
   }
@@ -363,11 +399,28 @@ public class ShadowServiceManager {
       String name,
       Class<? extends IInterface> clazz,
       String className,
-      BinderProxyType proxyType,
+      BinderType proxyType,
       @Nullable Object delegate) {
     binderServices.put(name, new BinderService(clazz, className, proxyType, delegate));
   }
 
+  public static void addBinderService(
+      String name, Class<? extends IInterface> clazz, IInterface service) {
+    binderServices.put(
+        name, new BinderService(clazz, clazz.getCanonicalName(), BinderType.CONCRETE, service));
+  }
+
+  private static void addBinderServiceIfClassExists(
+      Map<String, BinderService> binderServices, String name, String className) {
+    Class<? extends IInterface> clazz;
+    try {
+      clazz = Class.forName(className).asSubclass(IInterface.class);
+      addBinderService(binderServices, name, clazz, className, BinderType.NULL_PROXY, null);
+    } catch (ClassNotFoundException e) {
+      return;
+    }
+  }
+
   /**
    * Returns the {@link IBinder} associated with the given system service. If the given service is
    * set to unavailable in {@link #setServiceAvailability}, {@code null} will be returned.
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
index c2fa93bae..69256cd41 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowShortcutManager.java
@@ -26,6 +26,7 @@ import java.util.Set;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** */
 @Implements(value = ShortcutManager.class, minSdk = Build.VERSION_CODES.N_MR1)
@@ -33,16 +34,28 @@ public class ShadowShortcutManager {
 
   private static final int MAX_ICON_DIMENSION = 128;
 
-  private final Map<String, ShortcutInfo> dynamicShortcuts = new HashMap<>();
-  private final Map<String, ShortcutInfo> activePinnedShortcuts = new HashMap<>();
-  private final Map<String, ShortcutInfo> disabledPinnedShortcuts = new HashMap<>();
+  private static final Map<String, ShortcutInfo> dynamicShortcuts = new HashMap<>();
+  private static final Map<String, ShortcutInfo> activePinnedShortcuts = new HashMap<>();
+  private static final Map<String, ShortcutInfo> disabledPinnedShortcuts = new HashMap<>();
 
-  private List<ShortcutInfo> manifestShortcuts = ImmutableList.of();
+  private static List<ShortcutInfo> manifestShortcuts = ImmutableList.of();
 
-  private boolean isRequestPinShortcutSupported = true;
-  private int maxShortcutCountPerActivity = 16;
-  private int maxIconHeight = MAX_ICON_DIMENSION;
-  private int maxIconWidth = MAX_ICON_DIMENSION;
+  private static boolean isRequestPinShortcutSupported = true;
+  private static int maxShortcutCountPerActivity = 16;
+  private static int maxIconHeight = MAX_ICON_DIMENSION;
+  private static int maxIconWidth = MAX_ICON_DIMENSION;
+
+  @Resetter
+  public static void reset() {
+    dynamicShortcuts.clear();
+    activePinnedShortcuts.clear();
+    disabledPinnedShortcuts.clear();
+    manifestShortcuts = ImmutableList.of();
+    isRequestPinShortcutSupported = true;
+    maxShortcutCountPerActivity = 16;
+    maxIconHeight = MAX_ICON_DIMENSION;
+    maxIconWidth = MAX_ICON_DIMENSION;
+  }
 
   @Implementation
   protected boolean addDynamicShortcuts(List<ShortcutInfo> shortcutInfoList) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
index 8f8ef2517..f44e09852 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSliceManager.java
@@ -27,7 +27,7 @@ public class ShadowSliceManager {
 
   private static final Map<Integer, Collection<Uri>> packageUidsToPermissionGrantedSliceUris =
       new HashMap<>();
-  private final Map<Uri, Set<SliceSpec>> pinnedUriMap = new HashMap<>();
+  private static final Map<Uri, Set<SliceSpec>> pinnedUriMap = new HashMap<>();
   private Context context;
 
   @Implementation
@@ -107,5 +107,6 @@ public class ShadowSliceManager {
   @Resetter
   public static synchronized void reset() {
     packageUidsToPermissionGrantedSliceUris.clear();
+    pinnedUriMap.clear();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
index b7375e557..534727b32 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizer.java
@@ -22,6 +22,7 @@ import android.speech.SpeechRecognizer;
 import com.google.common.base.Preconditions;
 import java.util.Queue;
 import java.util.concurrent.Executor;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.InDevelopment;
@@ -35,7 +36,7 @@ import org.robolectric.util.reflector.Static;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Robolectric shadow for SpeechRecognizer. */
-@Implements(value = SpeechRecognizer.class, looseSignatures = true)
+@Implements(value = SpeechRecognizer.class)
 public class ShadowSpeechRecognizer {
 
   @SuppressWarnings("NonFinalStaticField")
@@ -187,11 +188,9 @@ public class ShadowSpeechRecognizer {
   @RequiresApi(api = VERSION_CODES.TIRAMISU)
   @Implementation(minSdk = VERSION_CODES.TIRAMISU, maxSdk = U.SDK_INT)
   protected void checkRecognitionSupport(
-      @NonNull /*Intent*/ Object recognizerIntent,
-      @NonNull /*Executor*/ Object executor,
-      @NonNull /*RecognitionSupportCallback*/ Object supportListener) {
-    Preconditions.checkArgument(recognizerIntent instanceof Intent);
-    Preconditions.checkArgument(executor instanceof Executor);
+      @NonNull Intent recognizerIntent,
+      @NonNull Executor executor,
+      @NonNull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
     Preconditions.checkArgument(supportListener instanceof RecognitionSupportCallback);
 
     ShadowSpeechRecognizerState shadowState = getState();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java
new file mode 100644
index 000000000..51cf7ccca
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerImpl.java
@@ -0,0 +1,119 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.annotation.NonNull;
+import android.annotation.RequiresApi;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build.VERSION_CODES;
+import android.os.Handler;
+import android.os.Message;
+import android.speech.IRecognitionService;
+import android.speech.RecognitionListener;
+import android.speech.SpeechRecognizer;
+import java.util.Queue;
+import java.util.concurrent.Executor;
+import org.robolectric.annotation.ClassName;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.Direct;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
+
+/**
+ * Robolectric shadow for SpeechRecognizerImpl.
+ *
+ * <p>Prior to Android V, SpeechRecognizer contained all functionality within one class. The {@link
+ * ShadowSpeechRecognizer} shadow would work correctly to shadow both static and instance functions
+ * of the class. With Android V, the instance of {@link SpeechRecognizer} returned from {@link
+ * SpeechRecognizer#createSpeechRecognizer(Context)} is an instance of {@link
+ * android.speech.SpeechRecognizerProxy} which delegates all calls to {@link
+ * android.speech.SpeechRecognizerImpl}. We need this shadow in order to intercept function calls
+ * correctly and to ensure that the functionality of {@link ShadowSpeechRecognizer} still works in
+ * tests prior to Android V and on Android V+.
+ *
+ * <p>Customizations for this implementation:
+ *
+ * <ul>
+ *   <li>Intercept of all needed functions in SpeechRecognizerImpl
+ *   <li>Direct access to functions/variables in SpeechRecognizerImpl via {@link
+ *       #getDirectAccessors()}
+ *   <li>Parent shadow class' state is used for state (no custom state)
+ * </ul>
+ */
+@Implements(
+    className = ShadowSpeechRecognizerImpl.CLASS_NAME,
+    isInAndroidSdk = false,
+    minSdk = V.SDK_INT)
+public class ShadowSpeechRecognizerImpl extends ShadowSpeechRecognizer {
+  protected static final String CLASS_NAME = "android.speech.SpeechRecognizerImpl";
+
+  @RealObject SpeechRecognizer realSpeechRecognizer;
+
+  @Override
+  protected ShadowSpeechRecognizerDirectAccessors getDirectAccessors() {
+    return reflector(SpeechRecognizerImplReflector.class, realSpeechRecognizer);
+  }
+
+  /** Provides access to the shadow's state for other shadows in the same package. */
+  ShadowSpeechRecognizerState internalGetState() {
+    return super.getState();
+  }
+
+  @Implementation
+  @Override
+  protected void destroy() {
+    super.destroy();
+  }
+
+  @Implementation
+  @Override
+  protected void startListening(Intent recognizerIntent) {
+    super.startListening(recognizerIntent);
+  }
+
+  @Implementation
+  @Override
+  protected void handleChangeListener(RecognitionListener listener) {
+    super.handleChangeListener(listener);
+  }
+
+  @RequiresApi(api = VERSION_CODES.TIRAMISU)
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  @Override
+  protected void checkRecognitionSupport(
+      @NonNull Intent recognizerIntent,
+      @NonNull Executor executor,
+      @NonNull @ClassName("android.speech.RecognitionSupportCallback") Object supportListener) {
+    super.checkRecognitionSupport(recognizerIntent, executor, supportListener);
+  }
+
+  @Implementation(minSdk = VERSION_CODES.TIRAMISU)
+  @Override
+  protected void triggerModelDownload(Intent recognizerIntent) {
+    super.triggerModelDownload(recognizerIntent);
+  }
+
+  /** Reflector interface for {@link android.speech.SpeechRecognizerImpl}'s internals. */
+  @ForType(className = CLASS_NAME)
+  interface SpeechRecognizerImplReflector extends ShadowSpeechRecognizerDirectAccessors {
+    @Direct
+    @Override
+    void destroy();
+
+    @Accessor("mService")
+    @Override
+    void setService(IRecognitionService service);
+
+    @Accessor("mPendingTasks")
+    @Override
+    Queue<Message> getPendingTasks();
+
+    @Accessor("mHandler")
+    @Override
+    Handler getHandler();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerProxy.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerProxy.java
new file mode 100644
index 000000000..c4bfc9731
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSpeechRecognizerProxy.java
@@ -0,0 +1,66 @@
+package org.robolectric.shadows;
+
+import static org.robolectric.util.reflector.Reflector.reflector;
+
+import android.content.Context;
+import android.speech.SpeechRecognizer;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.RealObject;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
+
+/**
+ * Robolectric shadow for SpeechRecognizerProxy.
+ *
+ * <p>Prior to Android V, SpeechRecognizer contained all functionality within one class. The {@link
+ * ShadowSpeechRecognizer} shadow would work correctly to shadow both static and instance functions
+ * of the class. With Android V, the instance of {@link SpeechRecognizer} returned from {@link
+ * SpeechRecognizer#createSpeechRecognizer(Context)} is an instance of {@link
+ * android.speech.SpeechRecognizerProxy} which delegates all calls to {@link
+ * android.speech.SpeechRecognizerImpl}.
+ *
+ * <p>This shadow (for the proxy subclass) works in coordination with {@link
+ * ShadowSpeechRecognizerImpl} to ensure that the functionality of {@link ShadowSpeechRecognizer}
+ * still works in tests prior to Android V and on Android V+.
+ *
+ * <p>Customizations for this implementation:
+ *
+ * <ul>
+ *   <li>Does not intercept any public API since all calls will be placed to {@link
+ *       android.speech.SpeechRecognizerImpl}
+ *   <li>Instead of returning its own state, returns the state of the delegate
+ *       (ShadowSpeechRecognizerImpl)
+ *   <li>No change in direct accessor since it is not required
+ * </ul>
+ */
+@Implements(
+    className = ShadowSpeechRecognizerProxy.CLASS_NAME,
+    isInAndroidSdk = false,
+    minSdk = V.SDK_INT)
+public class ShadowSpeechRecognizerProxy extends ShadowSpeechRecognizer {
+  protected static final String CLASS_NAME = "android.speech.SpeechRecognizerProxy";
+
+  @RealObject SpeechRecognizer realSpeechRecognizer;
+
+  /**
+   * The proxy and its shadow do not store their own state and this shadow does not intercept any of
+   * the relevant functions on its shadowed class. Rather, the delegate within the proxy has the
+   * correct state and intercepts such calls.
+   */
+  @Override
+  protected ShadowSpeechRecognizerState getState() {
+    SpeechRecognizer delegate =
+        reflector(SpeechRecognizerProxyReflector.class, realSpeechRecognizer).getDelegate();
+    ShadowSpeechRecognizerImpl delegateShadow = Shadow.extract(delegate);
+    return delegateShadow.internalGetState();
+  }
+
+  /** Reflector interface for {@link SpeechRecognizerProxy}'s internals. */
+  @ForType(className = CLASS_NAME)
+  interface SpeechRecognizerProxyReflector {
+    @Accessor("mDelegate")
+    SpeechRecognizer getDelegate();
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
index 61a595d76..da27f752c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatsManager.java
@@ -9,31 +9,49 @@ import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
 
-/** Shadow for {@link ShadowStatsManager} */
+/** Shadow for {@link StatsManager}. */
 @Implements(value = StatsManager.class, isInAndroidSdk = false, minSdk = P)
 public class ShadowStatsManager {
 
-  private static final Map<Long, byte[]> dataMap = new HashMap<>();
+  private static final Map<Long, byte[]> reportDataMap = new HashMap<>();
+
+  @SuppressWarnings("NonFinalStaticField")
   private static byte[] statsMetadata = new byte[] {};
 
+  private static final Map<Long, byte[]> configDataMap = new HashMap<>();
+
   @Resetter
   public static void reset() {
-    dataMap.clear();
+    reportDataMap.clear();
     statsMetadata = new byte[] {};
+    configDataMap.clear();
   }
 
+  /** Adds metrics data that the shadow should return from {@link StatsManager#getReports()}. */
   public static void addReportData(long configKey, byte[] data) {
-    dataMap.put(configKey, data);
+    reportDataMap.put(configKey, data);
   }
 
+  /**
+   * Sets the statsd metadata that the shadow should return from {@link
+   * StatsManager#getStatsMetadata()}.
+   */
   public static void setStatsMetadata(byte[] metadata) {
     statsMetadata = metadata;
   }
 
+  /**
+   * Retrieves the statsd configurations stored in the shadow as a result of {@link
+   * StatsManager#addConfig()} and {@link StatsManager#removeConfig()}.
+   */
+  public static byte[] getConfigData(long configKey) {
+    return configDataMap.getOrDefault(configKey, new byte[] {});
+  }
+
   @Implementation
   protected byte[] getReports(long configKey) {
-    byte[] data = dataMap.getOrDefault(configKey, new byte[] {});
-    dataMap.remove(configKey);
+    byte[] data = reportDataMap.getOrDefault(configKey, new byte[] {});
+    reportDataMap.remove(configKey);
     return data;
   }
 
@@ -41,4 +59,14 @@ public class ShadowStatsManager {
   protected byte[] getStatsMetadata() {
     return statsMetadata;
   }
+
+  @Implementation
+  protected void addConfig(long configKey, byte[] config) {
+    configDataMap.put(configKey, config);
+  }
+
+  @Implementation
+  protected void removeConfig(long configKey) {
+    configDataMap.remove(configKey);
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatusBarManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatusBarManager.java
index 5fb1b89ba..5de8d170c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatusBarManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStatusBarManager.java
@@ -9,6 +9,7 @@ import android.app.StatusBarManager;
 import com.android.internal.annotations.VisibleForTesting;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
@@ -29,10 +30,10 @@ public class ShadowStatusBarManager {
   public static final int DISABLE2_ROTATE_SUGGESTIONS = 1 << 4;
   public static final int DISABLE2_NONE = 0x00000000;
 
-  private int disabled = StatusBarManager.DISABLE_NONE;
-  private int disabled2 = StatusBarManager.DISABLE2_NONE;
+  private static int disabled = StatusBarManager.DISABLE_NONE;
+  private static int disabled2 = StatusBarManager.DISABLE2_NONE;
 
-  private int navBarMode = StatusBarManager.NAV_BAR_MODE_DEFAULT;
+  private static int navBarMode = StatusBarManager.NAV_BAR_MODE_DEFAULT;
 
   @Implementation
   protected void disable(int what) {
@@ -80,6 +81,13 @@ public class ShadowStatusBarManager {
     return navBarMode;
   }
 
+  @Resetter
+  public static void reset() {
+    disabled = StatusBarManager.DISABLE_NONE;
+    disabled2 = StatusBarManager.DISABLE2_NONE;
+    navBarMode = StatusBarManager.NAV_BAR_MODE_DEFAULT;
+  }
+
   @ForType(StatusBarManager.class)
   interface StatusBarManagerReflector {
     @Static
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
index e86fb5401..e1033ca97 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowStorageManager.java
@@ -113,5 +113,6 @@ public class ShadowStorageManager {
   @Resetter
   public static void reset() {
     storageVolumeList.clear();
+    isFileEncryptionSupported = true;
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
index 047e50ca9..d9adb94cd 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSubscriptionManager.java
@@ -8,6 +8,7 @@ import static android.os.Build.VERSION_CODES.P;
 import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.TIRAMISU;
+import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
 
 import android.os.Build.VERSION;
 import android.telephony.SubscriptionInfo;
@@ -31,8 +32,8 @@ import org.robolectric.util.ReflectionHelpers;
 @Implements(value = SubscriptionManager.class, minSdk = LOLLIPOP_MR1)
 public class ShadowSubscriptionManager {
 
-  private boolean readPhoneStatePermission = true;
-  private boolean readPhoneNumbersPermission = true;
+  private static boolean readPhoneStatePermission = true;
+  private static boolean readPhoneNumbersPermission = true;
   public static final int INVALID_PHONE_INDEX =
       ReflectionHelpers.getStaticField(SubscriptionManager.class, "INVALID_PHONE_INDEX");
 
@@ -42,7 +43,7 @@ public class ShadowSubscriptionManager {
   private static int defaultSmsSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
   private static int defaultVoiceSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
 
-  private final Map<Integer, String> phoneNumberMap = new HashMap<>();
+  private static final Map<Integer, String> phoneNumberMap = new HashMap<>();
 
   /** Returns value set with {@link #setActiveDataSubscriptionId(int)}. */
   @Implementation(minSdk = R)
@@ -128,19 +129,19 @@ public class ShadowSubscriptionManager {
 
   /**
    * Cache of {@link SubscriptionInfo} used by {@link #getActiveSubscriptionInfoList}. Managed by
-   * {@link #setActiveSubscriptionInfoList}.
+   * {@link #setActiveSubscriptionInfoList}. May be {@code null}.
    */
-  private List<SubscriptionInfo> subscriptionList = new ArrayList<>();
+  private static List<SubscriptionInfo> subscriptionList = new ArrayList<>();
 
   /**
    * Cache of {@link SubscriptionInfo} used by {@link #getAccessibleSubscriptionInfoList}. Managed
-   * by {@link #setAccessibleSubscriptionInfos}.
+   * by {@link #setAccessibleSubscriptionInfos}. May be {@code null}.
    */
   private List<SubscriptionInfo> accessibleSubscriptionList = new ArrayList<>();
 
   /**
    * Cache of {@link SubscriptionInfo} used by {@link #getAvailableSubscriptionInfoList}. Managed by
-   * {@link #setAvailableSubscriptionInfos}.
+   * {@link #setAvailableSubscriptionInfos}. May be {@code null}.
    */
   private List<SubscriptionInfo> availableSubscriptionList = new ArrayList<>();
 
@@ -466,6 +467,47 @@ public class ShadowSubscriptionManager {
     return INVALID_PHONE_INDEX;
   }
 
+  /**
+   * Older form of {@link #getSubscriptionId} that was designed prior to mainstream multi-SIM
+   * support, so its {@code int[]} return type ended up being an unused vestige from that older
+   * design.
+   */
+  @Implementation(minSdk = LOLLIPOP_MR1)
+  @HiddenApi
+  protected static int[] getSubId(int slotIndex) {
+    int subId = getSubscriptionId(slotIndex);
+    return subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID ? null : new int[] {subId};
+  }
+
+  /**
+   * Older form of {@link #getSubscriptionId} that was designed prior to mainstream multi-SIM
+   * support, so its {@code int[]} return type ended up being an unused vestige from that older
+   * design.
+   */
+  @Implementation(minSdk = Q)
+  protected int[] getSubscriptionIds(int slotIndex) {
+    return getSubId(slotIndex);
+  }
+
+  /**
+   * Derives the subscription ID corresponding to an "active" {@link SubscriptionInfo} for the given
+   * SIM slot index.
+   */
+  @Implementation(minSdk = UPSIDE_DOWN_CAKE)
+  protected static int getSubscriptionId(int slotIndex) {
+    // Intentionally not re-calling getActiveSubscriptionInfoForSimSlotIndex since this API does not
+    // require any permissions (and this is static).
+    if (subscriptionList == null) {
+      return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+    }
+    for (SubscriptionInfo info : subscriptionList) {
+      if (info.getSimSlotIndex() == slotIndex) {
+        return info.getSubscriptionId();
+      }
+    }
+    return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+  }
+
   /**
    * When set to false methods requiring {@link android.Manifest.permission.READ_PHONE_STATE}
    * permission will throw a {@link SecurityException}. By default it's set to true for backwards
@@ -533,7 +575,11 @@ public class ShadowSubscriptionManager {
     defaultSmsSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
     defaultVoiceSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
     defaultSubscriptionId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+    subscriptionList = new ArrayList<>();
     phoneIds.clear();
+    phoneNumberMap.clear();
+    readPhoneStatePermission = true;
+    readPhoneNumbersPermission = true;
   }
 
   /** Builder class to create instance of {@link SubscriptionInfo}. */
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
index ef83be975..6c70c41ea 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSurface.java
@@ -25,7 +25,7 @@ import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 
 /** Shadow for {@link android.view.Surface} */
-@Implements(value = Surface.class, looseSignatures = true)
+@Implements(value = Surface.class)
 public class ShadowSurface {
   private static final AtomicInteger nativeObject = new AtomicInteger();
 
@@ -58,6 +58,11 @@ public class ShadowSurface {
     surfaceReflector.finalize();
   }
 
+  @Implementation
+  protected void checkNotReleasedLocked() {
+    checkNotReleased();
+  }
+
   @Implementation
   protected boolean isValid() {
     return valid.get();
@@ -121,12 +126,12 @@ public class ShadowSurface {
   }
 
   @Implementation
-  protected static Object nativeCreateFromSurfaceTexture(Object surfaceTexture) {
+  protected static long nativeCreateFromSurfaceTexture(SurfaceTexture surfaceTexture) {
     return nativeObject.incrementAndGet();
   }
 
   @Implementation
-  protected static Object nativeCreateFromSurfaceControl(Object surfaceControlNativeObject) {
+  protected static long nativeCreateFromSurfaceControl(long surfaceControlNativeObject) {
     return nativeObject.incrementAndGet();
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
index 90c33c9b4..eff905283 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemClock.java
@@ -9,6 +9,7 @@ import android.os.SystemClock;
 import java.time.DateTimeException;
 import java.time.Duration;
 import java.util.concurrent.TimeUnit;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.LooperMode;
@@ -21,10 +22,7 @@ import org.robolectric.annotation.LooperMode.Mode;
  * LooperMode}. See {@link ShadowLegacySystemClock} and {@link ShadowPausedSystemClock} for more
  * details.
  */
-@Implements(
-    value = SystemClock.class,
-    shadowPicker = ShadowSystemClock.Picker.class,
-    looseSignatures = true)
+@Implements(value = SystemClock.class, shadowPicker = ShadowSystemClock.Picker.class)
 public abstract class ShadowSystemClock {
   protected static boolean networkTimeAvailable = true;
   private static boolean gnssTimeAvailable = true;
@@ -98,7 +96,7 @@ public abstract class ShadowSystemClock {
   }
 
   @Implementation(minSdk = Q)
-  protected static Object currentGnssTimeClock() {
+  protected static @ClassName("java.time.Clock") Object currentGnssTimeClock() {
     if (gnssTimeAvailable) {
       return new SimpleClock(UTC) {
         @Override
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemHealthManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemHealthManager.java
index 4eff63dfb..fcb92a95e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemHealthManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemHealthManager.java
@@ -8,6 +8,7 @@ import android.os.health.SystemHealthManager;
 import java.util.HashMap;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow for {@link android.os.health.SystemHealthManager} */
 @Implements(value = SystemHealthManager.class, minSdk = N)
@@ -16,7 +17,12 @@ public class ShadowSystemHealthManager {
   private static final HealthStats DEFAULT_HEALTH_STATS =
       HealthStatsBuilder.newBuilder().setDataType("default_health_stats").build();
 
-  private final HashMap<Integer, HealthStats> uidToHealthStats = new HashMap<>();
+  private static final HashMap<Integer, HealthStats> uidToHealthStats = new HashMap<>();
+
+  @Resetter
+  public static void reset() {
+    uidToHealthStats.clear();
+  }
 
   @Implementation
   protected HealthStats takeMyUidSnapshot() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
index 2f150456a..92564631f 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemServiceRegistry.java
@@ -6,6 +6,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.content.Context;
 import android.os.Build;
 import java.util.Map;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
@@ -15,7 +16,6 @@ import org.robolectric.util.reflector.ForType;
 @Implements(
     className = "android.app.SystemServiceRegistry",
     isInAndroidSdk = false,
-    looseSignatures = true,
     minSdk = Build.VERSION_CODES.M)
 public class ShadowSystemServiceRegistry {
 
@@ -124,7 +124,8 @@ public class ShadowSystemServiceRegistry {
   }
 
   @Implementation(minSdk = O)
-  protected static void onServiceNotFound(/* ServiceNotFoundException */ Object e0) {
+  protected static void onServiceNotFound(
+      @ClassName("android.os.ServiceManager$ServiceNotFoundException") Object e0) {
     // otherwise the full stacktrace might be swallowed...
     Exception e = (Exception) e0;
     e.printStackTrace();
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
index f663c6bc9..6fa7fbe9c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowSystemVibrator.java
@@ -17,12 +17,13 @@ import com.google.common.base.Preconditions;
 import java.util.List;
 import java.util.Optional;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow for {@link SystemVibrator}. */
-@Implements(value = SystemVibrator.class, isInAndroidSdk = false, looseSignatures = true)
+@Implements(value = SystemVibrator.class, isInAndroidSdk = false)
 public class ShadowSystemVibrator extends ShadowVibrator {
 
   private final Handler handler = new Handler(Looper.getMainLooper());
@@ -110,12 +111,13 @@ public class ShadowSystemVibrator extends ShadowVibrator {
 
   @Implementation(minSdk = S)
   protected void vibrate(
-      Object uid, Object opPkg, Object effect, Object reason, Object attributes) {
-    Preconditions.checkArgument(uid instanceof Integer);
-    Preconditions.checkArgument(opPkg == null || opPkg instanceof String);
+      int uid,
+      String opPkg,
+      @ClassName("android.os.VibrationEffect") Object effect,
+      String reason,
+      @ClassName("android.os.VibrationAttributes") Object attributes) {
     // The SystemVibrator#vibrate needs effect NonNull.
     Preconditions.checkArgument(effect instanceof VibrationEffect);
-    Preconditions.checkArgument(reason == null || reason instanceof String);
     // The SystemVibrator#vibrate needs attributes NonNull.
     Preconditions.checkArgument(attributes instanceof android.os.VibrationAttributes);
     if (effect instanceof VibrationEffect.Composed) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
index de690464f..bfe1fbb44 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelecomManager.java
@@ -44,6 +44,7 @@ import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 
 @Implements(value = TelecomManager.class)
@@ -76,28 +77,57 @@ public class ShadowTelecomManager {
 
   @RealObject private TelecomManager realObject;
 
-  private final LinkedHashMap<PhoneAccountHandle, PhoneAccount> accounts = new LinkedHashMap<>();
-  private final LinkedHashMap<PhoneAccountHandle, String> voicemailNumbers = new LinkedHashMap<>();
-  private final LinkedHashMap<PhoneAccountHandle, String> line1Numbers = new LinkedHashMap<>();
-
-  private final List<IncomingCallRecord> incomingCalls = new ArrayList<>();
-  private final List<OutgoingCallRecord> outgoingCalls = new ArrayList<>();
-  private final List<UnknownCallRecord> unknownCalls = new ArrayList<>();
-  private final Map<String, PhoneAccountHandle> defaultOutgoingPhoneAccounts = new ArrayMap<>();
-  private Intent manageBlockNumbersIntent;
-  private CallRequestMode callRequestMode = CallRequestMode.MANUAL;
-  private PhoneAccountHandle simCallManager;
-  private String defaultDialerPackageName;
-  private String systemDefaultDialerPackageName;
-  private boolean isInCall;
-  private boolean isInEmergencyCall;
-  private boolean ttySupported;
-  private PhoneAccountHandle userSelectedOutgoingPhoneAccount;
-  private boolean readPhoneStatePermission = true;
-  private boolean callPhonePermission = true;
-  private boolean handleMmiValue = false;
-  private ConnectionService connectionService;
-  private boolean isOutgoingCallPermitted = false;
+  private static final LinkedHashMap<PhoneAccountHandle, PhoneAccount> accounts =
+      new LinkedHashMap<>();
+  private static final LinkedHashMap<PhoneAccountHandle, String> voicemailNumbers =
+      new LinkedHashMap<>();
+  private static final LinkedHashMap<PhoneAccountHandle, String> line1Numbers =
+      new LinkedHashMap<>();
+
+  private static final List<IncomingCallRecord> incomingCalls = new ArrayList<>();
+  private static final List<OutgoingCallRecord> outgoingCalls = new ArrayList<>();
+  private static final List<UnknownCallRecord> unknownCalls = new ArrayList<>();
+  private static final Map<String, PhoneAccountHandle> defaultOutgoingPhoneAccounts =
+      new ArrayMap<>();
+  private static Intent manageBlockNumbersIntent;
+  private static CallRequestMode callRequestMode = CallRequestMode.MANUAL;
+  private static PhoneAccountHandle simCallManager;
+  private static String defaultDialerPackageName;
+  private static String systemDefaultDialerPackageName;
+  private static boolean isInCall;
+  private static boolean isInEmergencyCall;
+  private static boolean ttySupported;
+  private static PhoneAccountHandle userSelectedOutgoingPhoneAccount;
+  private static boolean readPhoneStatePermission = true;
+  private static boolean callPhonePermission = true;
+  private static boolean handleMmiValue = false;
+  private static ConnectionService connectionService;
+  private static boolean isOutgoingCallPermitted = false;
+
+  @Resetter
+  public static void reset() {
+    accounts.clear();
+    voicemailNumbers.clear();
+    line1Numbers.clear();
+    incomingCalls.clear();
+    outgoingCalls.clear();
+    unknownCalls.clear();
+    defaultOutgoingPhoneAccounts.clear();
+    manageBlockNumbersIntent = null;
+    callRequestMode = CallRequestMode.MANUAL;
+    simCallManager = null;
+    defaultDialerPackageName = null;
+    systemDefaultDialerPackageName = null;
+    isInCall = false;
+    isInEmergencyCall = false;
+    ttySupported = false;
+    userSelectedOutgoingPhoneAccount = null;
+    readPhoneStatePermission = true;
+    callPhonePermission = true;
+    handleMmiValue = false;
+    connectionService = null;
+    isOutgoingCallPermitted = false;
+  }
 
   public CallRequestMode getCallRequestMode() {
     return callRequestMode;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
index 02aa751c3..3b298f71c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTelephonyManager.java
@@ -70,6 +70,7 @@ import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -80,7 +81,8 @@ import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.versioning.AndroidVersions.U;
 import org.robolectric.versioning.AndroidVersions.V;
 
-@Implements(value = TelephonyManager.class, looseSignatures = true)
+/** Shadow for {@link TelephonyManager}. */
+@Implements(value = TelephonyManager.class)
 public class ShadowTelephonyManager {
 
   @RealObject protected TelephonyManager realTelephonyManager;
@@ -250,12 +252,13 @@ public class ShadowTelephonyManager {
   @Implementation(minSdk = S)
   @HiddenApi
   public void bootstrapAuthenticationRequest(
-      Object appType,
-      Object nafId,
-      Object securityProtocol,
-      Object forceBootStrapping,
-      Object e,
-      Object callback) {
+      int appType,
+      Uri nafId,
+      @ClassName("android.telephony.gba.UaSecurityProtocolIdentifier") Object securityProtocol,
+      boolean forceBootStrapping,
+      Executor e,
+      @ClassName("android.telephony.TelephonyManager$BootstrapAuthenticationCallback")
+          Object callback) {
     this.callback = callback;
   }
 
@@ -265,7 +268,7 @@ public class ShadowTelephonyManager {
 
   @Implementation(minSdk = S)
   @HiddenApi
-  public /*PhoneCapability*/ Object getPhoneCapability() {
+  public @ClassName("android.telephony.PhoneCapability") Object getPhoneCapability() {
     return phoneCapability;
   }
 
@@ -306,8 +309,7 @@ public class ShadowTelephonyManager {
 
   @Implementation(minSdk = S)
   public void registerTelephonyCallback(
-      /*Executor*/ Object executor, /*TelephonyCallback*/ Object callback) {
-    Preconditions.checkArgument(executor instanceof Executor);
+      Executor executor, @ClassName("android.telephony.TelephonyCallback") Object callback) {
     Preconditions.checkArgument(callback instanceof TelephonyCallback);
     lastTelephonyCallback = callback;
     initTelephonyCallback(callback);
@@ -316,15 +318,15 @@ public class ShadowTelephonyManager {
 
   @Implementation(minSdk = TIRAMISU)
   protected void registerTelephonyCallback(
-      /*int*/ Object includeLocationData, /*Executor*/
-      Object executor, /*TelephonyCallback*/
-      Object callback) {
-    Preconditions.checkArgument(includeLocationData instanceof Integer);
+      int includeLocationData,
+      Executor executor,
+      @ClassName("android.telephony.TelephonyCallback") Object callback) {
     registerTelephonyCallback(executor, callback);
   }
 
   @Implementation(minSdk = S)
-  public void unregisterTelephonyCallback(/*TelephonyCallback*/ Object callback) {
+  public void unregisterTelephonyCallback(
+      @ClassName("android.telephony.TelephonyCallback") Object callback) {
     telephonyCallbackRegistrations.remove(callback);
   }
 
@@ -634,7 +636,7 @@ public class ShadowTelephonyManager {
   /** Returns the UICC slots information set by {@link #setUiccSlotsInfo}. */
   @Implementation(minSdk = P)
   @HiddenApi
-  protected /*UiccSlotInfo[]*/ Object getUiccSlotsInfo() {
+  protected @ClassName("android.telephony.UiccSlotInfo[]") Object getUiccSlotsInfo() {
     return uiccSlotInfos;
   }
 
@@ -646,8 +648,8 @@ public class ShadowTelephonyManager {
   /** Returns the UICC cards information set by {@link #setUiccCardsInfo}. */
   @Implementation(minSdk = Q)
   @HiddenApi
-  protected /*List<UiccCardInfo>*/ Object getUiccCardsInfo() {
-    return uiccCardsInfo;
+  protected List</*android.telephony.UiccCardInfo*/ ?> getUiccCardsInfo() {
+    return (List<?>) uiccCardsInfo;
   }
 
   /** Clears {@code slotIndex} to state mapping and resets to default state. */
@@ -804,8 +806,9 @@ public class ShadowTelephonyManager {
    * TelephonyManager#NETWORK_TYPE_UNKNOWN} if it was never called.
    */
   @Implementation(minSdk = Q)
-  protected void requestCellInfoUpdate(Object cellInfoExecutor, Object cellInfoCallback) {
-    Executor executor = (Executor) cellInfoExecutor;
+  protected void requestCellInfoUpdate(
+      Executor executor,
+      @ClassName("android.telephony.TelephonyManager$CellInfoCallback") Object cellInfoCallback) {
     List<CellInfo> callbackCellInfos = ShadowTelephonyManager.callbackCellInfos;
     if (callbackCellInfos == null) {
       // ignore
@@ -1687,8 +1690,9 @@ public class ShadowTelephonyManager {
    * Implementation for {@link TelephonyManager#getCarrierRestrictionRules} that is set for tests by
    * {@link TelephonyManager#setCarrierRestrictionRules}.
    */
-  @Implementation(minSdk = Build.VERSION_CODES.Q)
-  protected /*CarrierRestrictionRules*/ Object getCarrierRestrictionRules() {
+  @Implementation(minSdk = Q)
+  protected @ClassName("android.telephony.CarrierRestrictionRules") Object
+      getCarrierRestrictionRules() {
     return carrierRestrictionRules;
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextClassifierService.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextClassifierService.java
new file mode 100644
index 000000000..464b414dd
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextClassifierService.java
@@ -0,0 +1,39 @@
+package org.robolectric.shadows;
+
+import android.annotation.SystemApi;
+import android.content.Context;
+import android.os.Build;
+import android.service.textclassifier.TextClassifierService;
+import android.view.textclassifier.TextClassifier;
+import java.util.concurrent.atomic.AtomicReference;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
+
+/** Shadow for {@link TextClassifierService} */
+@SystemApi
+@Implements(
+    value = TextClassifierService.class,
+    minSdk = Build.VERSION_CODES.Q,
+    isInAndroidSdk = false)
+public class ShadowTextClassifierService {
+  private static final AtomicReference<TextClassifier> defaultTextClassifier =
+      new AtomicReference<>(TextClassifier.NO_OP);
+
+  @Resetter
+  public static void reset() {
+    defaultTextClassifier.set(TextClassifier.NO_OP);
+  }
+
+  @Implementation
+  protected static TextClassifier getDefaultTextClassifierImplementation(Context context) {
+    return defaultTextClassifier.get();
+  }
+
+  /** Sets the default text classifier implementation for the test. */
+  public static void setDefaultTextClassifierImplementation(TextClassifier textClassifier) {
+    defaultTextClassifier.set(textClassifier);
+  }
+
+  private ShadowTextClassifierService() {}
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
index 0328e81b6..54cd10b0a 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTextToSpeech.java
@@ -232,8 +232,8 @@ public class ShadowTextToSpeech {
         && utteranceProgressListener != null
         && !Boolean.getBoolean("robolectric.enableShadowTtsSynthesisToFileCallbackSuppression")) {
       switch (synthesizeToFileResult) {
-          // Right now this only supports success an error though there are other possible
-          // situations.
+        // Right now this only supports success an error though there are other possible
+        // situations.
         case TextToSpeech.SUCCESS:
           utteranceProgressListener.onStart(utteranceId);
           utteranceProgressListener.onDone(utteranceId);
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowThreadedRenderer.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowThreadedRenderer.java
index 7675c9996..e1a2a45db 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowThreadedRenderer.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowThreadedRenderer.java
@@ -5,6 +5,7 @@ import static android.os.Build.VERSION_CODES.P;
 
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.shadow.api.Shadow;
@@ -12,15 +13,14 @@ import org.robolectric.shadow.api.Shadow;
 @Implements(
     className = "android.view.ThreadedRenderer",
     isInAndroidSdk = false,
-    looseSignatures = true,
     minSdk = O,
     maxSdk = P)
 public class ShadowThreadedRenderer {
 
   @Implementation
   protected static Bitmap createHardwareBitmap(
-      /*RenderNode*/ Object node, /*int*/ Object width, /*int*/ Object height) {
-    return createHardwareBitmap((int) width, (int) height);
+      @ClassName("android.view.RenderNode") Object node, int width, int height) {
+    return createHardwareBitmap(width, height);
   }
 
   private static Bitmap createHardwareBitmap(int width, int height) {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
index e1a5edc64..9ccf875e2 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeManager.java
@@ -15,6 +15,7 @@ import java.util.concurrent.Executor;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.versioning.AndroidVersions.U;
@@ -26,9 +27,9 @@ public class ShadowTimeManager {
   public static final String CONFIGURE_GEO_DETECTION_CAPABILITY =
       "configure_geo_detection_capability";
 
-  private TimeZoneCapabilities timeZoneCapabilities = getTimeZoneCapabilities();
+  private static TimeZoneCapabilities timeZoneCapabilities = getTimeZoneCapabilities();
 
-  private TimeZoneConfiguration timeZoneConfiguration;
+  private static TimeZoneConfiguration timeZoneConfiguration;
 
   /**
    * Capabilites are predefined and not controlled by user, so they can't be changed via TimeManager
@@ -115,7 +116,7 @@ public class ShadowTimeManager {
   @Implementation
   protected void suggestExternalTime(ExternalTimeSuggestion timeSuggestion) {}
 
-  private TimeZoneCapabilities getTimeZoneCapabilities() {
+  private static TimeZoneCapabilities getTimeZoneCapabilities() {
     TimeZoneCapabilities.Builder timeZoneCapabilitiesBuilder =
         new TimeZoneCapabilities.Builder(UserHandle.CURRENT)
             .setConfigureAutoDetectionEnabledCapability(Capabilities.CAPABILITY_POSSESSED)
@@ -139,4 +140,10 @@ public class ShadowTimeManager {
       return timeZoneCapabilitiesBuilder.build();
     }
   }
+
+  @Resetter
+  public static void reset() {
+    timeZoneCapabilities = getTimeZoneCapabilities();
+    timeZoneConfiguration = null;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinder.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinder.java
index 926ae6e8d..c2ab43294 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinder.java
@@ -8,6 +8,7 @@ import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
@@ -18,14 +19,13 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
     className = "libcore.util.TimeZoneFinder",
     minSdk = O,
     maxSdk = P,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+    isInAndroidSdk = false)
 public class ShadowTimeZoneFinder {
 
   private static final String TZLOOKUP_PATH = "/usr/share/zoneinfo/tzlookup.xml";
 
   @Implementation
-  protected static Object getInstance() {
+  protected static @ClassName("libcore.util.TimeZoneFinder") Object getInstance() {
     try {
       return ReflectionHelpers.callStaticMethod(
           Class.forName("libcore.util.TimeZoneFinder"),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderQ.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderQ.java
index 97134bd42..e401905a0 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderQ.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderQ.java
@@ -4,6 +4,7 @@ import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static org.robolectric.shadows.ShadowTimeZoneFinder.readTzlookup;
 
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.util.ReflectionHelpers;
@@ -14,12 +15,11 @@ import org.robolectric.util.ReflectionHelpers.ClassParameter;
     className = "libcore.timezone.TimeZoneFinder",
     minSdk = Q,
     maxSdk = R,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+    isInAndroidSdk = false)
 public class ShadowTimeZoneFinderQ {
 
   @Implementation
-  protected static Object getInstance() {
+  protected static @ClassName("libcore.timezone.TimeZoneFinder") Object getInstance() {
     try {
       return ReflectionHelpers.callStaticMethod(
           Class.forName("libcore.timezone.TimeZoneFinder"),
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderS.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderS.java
index f28a12edf..493f95830 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderS.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTimeZoneFinderS.java
@@ -8,21 +8,18 @@ import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 
 /** Shadow for TimeZoneFinder on S or above. */
-@Implements(
-    value = TimeZoneFinder.class,
-    minSdk = S,
-    isInAndroidSdk = false,
-    looseSignatures = true)
+@Implements(value = TimeZoneFinder.class, minSdk = S, isInAndroidSdk = false)
 public class ShadowTimeZoneFinderS {
 
   private static final String TZLOOKUP_PATH = "/usr/share/zoneinfo/tzlookup.xml";
 
   @Implementation
-  protected static Object getInstance() {
+  protected static @ClassName("com.android.i18n.timezone.TimeZoneFinder") Object getInstance() {
     return TimeZoneFinder.createInstanceForTests(readTzlookup());
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTranslationManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTranslationManager.java
index 9cd316944..79a6c9ca5 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTranslationManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowTranslationManager.java
@@ -9,6 +9,7 @@ import com.google.common.collect.Table;
 import java.util.Set;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow for {@link TranslationManager}. */
 @Implements(
@@ -17,7 +18,7 @@ import org.robolectric.annotation.Implements;
     isInAndroidSdk = false // turn off shadowOf generation
     )
 public class ShadowTranslationManager {
-  private final Table<Integer, Integer, ImmutableSet<TranslationCapability>>
+  private static final Table<Integer, Integer, ImmutableSet<TranslationCapability>>
       onDeviceTranslationCapabilities = HashBasedTable.create();
 
   @Implementation
@@ -34,4 +35,9 @@ public class ShadowTranslationManager {
     onDeviceTranslationCapabilities.put(
         sourceFormat, targetFormat, ImmutableSet.copyOf(capabilities));
   }
+
+  @Resetter
+  public static void reset() {
+    onDeviceTranslationCapabilities.clear();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
index 932b052f0..61f70c98b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUiAutomation.java
@@ -137,7 +137,8 @@ public class ShadowUiAutomation {
                   Canvas windowCanvas = new Canvas(window);
                   rootView.draw(windowCanvas);
                 }
-                screenshotCanvas.drawBitmap(window, root.params.x, root.params.y, paint);
+                screenshotCanvas.drawBitmap(
+                    window, root.locationOnScreen.x, root.locationOnScreen.y, paint);
               }
               return screenshot;
             });
@@ -181,14 +182,14 @@ public class ShadowUiAutomation {
     for (int i = 0; i < touchableRoots.size(); i++) {
       Root root = touchableRoots.get(i);
       if (i == touchableRoots.size() - 1 || root.isTouchModal() || root.isTouchInside(event)) {
-        event.offsetLocation(-root.params.x, -root.params.y);
+        event.offsetLocation(-root.locationOnScreen.x, -root.locationOnScreen.y);
         root.getRootView().dispatchTouchEvent(event);
-        event.offsetLocation(root.params.x, root.params.y);
+        event.offsetLocation(root.locationOnScreen.x, root.locationOnScreen.y);
         break;
       } else if (event.getActionMasked() == MotionEvent.ACTION_DOWN && root.watchTouchOutside()) {
         MotionEvent outsideEvent = MotionEvent.obtain(event);
         outsideEvent.setAction(MotionEvent.ACTION_OUTSIDE);
-        outsideEvent.offsetLocation(-root.params.x, -root.params.y);
+        outsideEvent.offsetLocation(-root.locationOnScreen.x, -root.locationOnScreen.y);
         root.getRootView().dispatchTouchEvent(outsideEvent);
         outsideEvent.recycle();
       }
@@ -283,11 +284,16 @@ public class ShadowUiAutomation {
     final ViewRootImpl impl;
     final WindowManager.LayoutParams params;
     final int index;
+    final Point locationOnScreen;
 
     Root(ViewRootImpl impl, WindowManager.LayoutParams params, int index) {
       this.impl = impl;
       this.params = params;
       this.index = index;
+
+      int[] coords = new int[2];
+      getRootView().getLocationOnScreen(coords);
+      locationOnScreen = new Point(coords[0], coords[1]);
     }
 
     int getIndex() {
@@ -304,10 +310,10 @@ public class ShadowUiAutomation {
 
     boolean isTouchInside(MotionEvent event) {
       int index = event.getActionIndex();
-      return event.getX(index) >= params.x
-          && event.getX(index) <= params.x + impl.getView().getWidth()
-          && event.getY(index) >= params.y
-          && event.getY(index) <= params.y + impl.getView().getHeight();
+      return event.getX(index) >= locationOnScreen.x
+          && event.getX(index) <= locationOnScreen.x + impl.getView().getWidth()
+          && event.getY(index) >= locationOnScreen.y
+          && event.getY(index) <= locationOnScreen.y + impl.getView().getHeight();
     }
 
     boolean isTouchModal() {
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
index 5400f9d07..fe27ea78b 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsageStatsManager.java
@@ -2,6 +2,7 @@ package org.robolectric.shadows;
 
 import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -19,15 +20,18 @@ import android.content.Intent;
 import android.content.res.Configuration;
 import android.os.Build;
 import android.os.Parcel;
+import android.os.PersistableBundle;
 import android.util.ArraySet;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.Range;
 import com.google.common.collect.SetMultimap;
+import com.google.common.primitives.Ints;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -39,13 +43,17 @@ import java.util.Map;
 import java.util.NavigableMap;
 import java.util.concurrent.TimeUnit;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.util.reflector.Accessor;
+import org.robolectric.util.reflector.ForType;
+import org.robolectric.versioning.AndroidVersions.V;
 
 /** Shadow of {@link UsageStatsManager}. */
-@Implements(value = UsageStatsManager.class, looseSignatures = true)
+@Implements(value = UsageStatsManager.class)
 public class ShadowUsageStatsManager {
   private static @StandbyBuckets int currentAppStandbyBucket =
       UsageStatsManager.STANDBY_BUCKET_ACTIVE;
@@ -61,14 +69,14 @@ public class ShadowUsageStatsManager {
    * Keys {@link UsageStats} objects by intervalType (e.g. {@link
    * UsageStatsManager#INTERVAL_WEEKLY}).
    */
-  private SetMultimap<Integer, UsageStats> usageStatsByIntervalType =
+  private static SetMultimap<Integer, UsageStats> usageStatsByIntervalType =
       Multimaps.synchronizedSetMultimap(HashMultimap.create());
 
   private static final Map<String, Integer> appStandbyBuckets = Maps.newConcurrentMap();
 
   /** Used with T APIs for {@link BroadcastResponseStats}. */
-  private final Map<String, Map<Long, Object /*BroadcastResponseStats */>> appBroadcastStats =
-      Maps.newConcurrentMap();
+  private static final Map<String, Map<Long, Object /*BroadcastResponseStats */>>
+      appBroadcastStats = Maps.newConcurrentMap();
 
   /**
    * App usage observer registered via {@link UsageStatsManager#registerAppUsageObserver(int,
@@ -235,6 +243,22 @@ public class ShadowUsageStatsManager {
     return createUsageEvents(results);
   }
 
+  @Implementation(minSdk = V.SDK_INT)
+  protected UsageEvents queryEvents(@ClassName("android.app.usage.UsageEventsQuery") Object query) {
+    UsageEventsQueryReflector queryReflector = reflector(UsageEventsQueryReflector.class, query);
+    long beginTime = queryReflector.getBeginTimeMillis();
+    long endTime = queryReflector.getEndTimeMillis();
+    int[] eventTypes = queryReflector.getEventTypes();
+    ImmutableSet<Integer> eventTypesSet = ImmutableSet.copyOf(Ints.asList(eventTypes));
+    List<Event> results = new ArrayList<>();
+    for (Event event : Iterables.concat(eventsByTimeStamp.subMap(beginTime, endTime).values())) {
+      if (eventTypesSet.contains(event.getEventType())) {
+        results.add(event);
+      }
+    }
+    return createUsageEvents(results);
+  }
+
   private static UsageEvents createUsageEvents(List<Event> results) {
     ArraySet<String> names = new ArraySet<>();
     for (Event result : results) {
@@ -586,21 +610,16 @@ public class ShadowUsageStatsManager {
     currentUsageSource = usageSource;
   }
 
-  /**
-   * Requires loose signatures because return value is a list of {@link BroadcastResponseStats},
-   * which is a hidden class introduced in Android T.
-   */
   @SuppressWarnings("unchecked")
   @Implementation(minSdk = TIRAMISU)
-  protected Object /* List<BroadcastResponseStats> */ queryBroadcastResponseStats(
-      @Nullable Object packageName, Object id) {
+  protected List</*android.app.usage.BroadcastResponseStats*/ ?> queryBroadcastResponseStats(
+      @Nullable String packageName, long id) {
     List<BroadcastResponseStats> result = new ArrayList<>();
     for (Map.Entry<String, Map<Long, Object /*BroadcastResponseStats*/>> entry :
         appBroadcastStats.entrySet()) {
       if (packageName == null || entry.getKey().equals(packageName)) {
         result.addAll(
-            (List<BroadcastResponseStats>)
-                queryBroadcastResponseStatsForId(entry.getValue(), (long) id));
+            (List<BroadcastResponseStats>) queryBroadcastResponseStatsForId(entry.getValue(), id));
       }
     }
     return result;
@@ -652,6 +671,9 @@ public class ShadowUsageStatsManager {
     appUsageObserversById.clear();
     usageSessionObserversById.clear();
     appUsageLimitObserversById.clear();
+
+    usageStatsByIntervalType.clear();
+    appBroadcastStats.clear();
   }
 
   /**
@@ -783,5 +805,30 @@ public class ShadowUsageStatsManager {
       event.mBucketAndReason |= bucket << 16;
       return this;
     }
+
+    @TargetApi(V.SDK_INT)
+    public EventBuilder setExtras(PersistableBundle extras) {
+      EventReflector eventReflector = reflector(EventReflector.class, event);
+      eventReflector.setExtras(extras);
+      return this;
+    }
+  }
+
+  // TODO: remove reflection calls once Android V is fully supported.
+  @ForType(className = "android.app.usage.UsageEventsQuery")
+  interface UsageEventsQueryReflector {
+    int[] getEventTypes();
+
+    long getBeginTimeMillis();
+
+    long getEndTimeMillis();
+  }
+
+  @ForType(Event.class)
+  interface EventReflector {
+    @Accessor("mExtras")
+    void setExtras(PersistableBundle extras);
+
+    PersistableBundle getExtras();
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
index 6e7ab5840..6d224217d 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUsbManager.java
@@ -3,6 +3,8 @@ package org.robolectric.shadows;
 import static android.os.Build.VERSION_CODES.M;
 import static android.os.Build.VERSION_CODES.N;
 import static android.os.Build.VERSION_CODES.N_MR1;
+import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
 import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.ReflectionHelpers.callConstructor;
 import static org.robolectric.util.ReflectionHelpers.getStaticField;
@@ -16,7 +18,6 @@ import android.hardware.usb.UsbDeviceConnection;
 import android.hardware.usb.UsbManager;
 import android.hardware.usb.UsbPort;
 import android.hardware.usb.UsbPortStatus;
-import android.os.Build;
 import android.os.ParcelFileDescriptor;
 import com.google.common.base.Preconditions;
 import java.io.File;
@@ -25,14 +26,16 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.reflector.ForType;
 
 /** Robolectric implementation of {@link android.hardware.usb.UsbManager}. */
-@Implements(value = UsbManager.class, looseSignatures = true)
+@Implements(value = UsbManager.class)
 public class ShadowUsbManager {
 
   @RealObject private UsbManager realUsbManager;
@@ -40,28 +43,39 @@ public class ShadowUsbManager {
   /**
    * A mapping from the package names to a list of USB devices for which permissions are granted.
    */
-  private final HashMap<String, List<UsbDevice>> grantedDevicePermissions = new HashMap<>();
+  private static final HashMap<String, List<UsbDevice>> grantedDevicePermissions = new HashMap<>();
 
   /**
    * A mapping from the package names to a list of USB accessories for which permissions are
    * granted.
    */
-  private final HashMap<String, List<UsbAccessory>> grantedAccessoryPermissions = new HashMap<>();
+  private static final HashMap<String, List<UsbAccessory>> grantedAccessoryPermissions =
+      new HashMap<>();
 
   /**
    * A mapping from the USB device names to the USB device instances.
    *
    * @see UsbManager#getDeviceList()
    */
-  private final HashMap<String, UsbDevice> usbDevices = new HashMap<>();
+  private static final HashMap<String, UsbDevice> usbDevices = new HashMap<>();
 
   /** A mapping from USB port ID to the port object. */
-  private final HashMap<String, UsbPort> usbPorts = new HashMap<>();
+  private static final HashMap<String, UsbPort> usbPorts = new HashMap<>();
 
   /** A mapping from USB port to the status of that port. */
-  private final HashMap<UsbPort, UsbPortStatus> usbPortStatuses = new HashMap<>();
+  private static final HashMap<UsbPort, UsbPortStatus> usbPortStatuses = new HashMap<>();
 
-  private UsbAccessory attachedUsbAccessory = null;
+  private static UsbAccessory attachedUsbAccessory = null;
+
+  @Resetter
+  public static void reset() {
+    grantedDevicePermissions.clear();
+    grantedAccessoryPermissions.clear();
+    usbDevices.clear();
+    usbPorts.clear();
+    usbPortStatuses.clear();
+    attachedUsbAccessory = null;
+  }
 
   /** Returns true if the caller has permission to access the device. */
   @Implementation
@@ -185,16 +199,18 @@ public class ShadowUsbManager {
     revokePermission(usbDevice, RuntimeEnvironment.getApplication().getPackageName());
   }
 
-  @Implementation(minSdk = M)
+  @Implementation(minSdk = M, maxSdk = P)
   @HiddenApi
-  protected /* UsbPort[] */ Object getPorts() {
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
-      return new ArrayList<>(usbPortStatuses.keySet());
-    }
-
+  protected @ClassName("android.hardware.usb.UsbPort[]") Object getPorts() {
     return usbPortStatuses.keySet().toArray(new UsbPort[usbPortStatuses.size()]);
   }
 
+  @Implementation(minSdk = Q, methodName = "getPorts")
+  @HiddenApi
+  protected List</*android.hardware.usb.UsbPort*/ ?> getPortsFromQ() {
+    return new ArrayList<>(usbPortStatuses.keySet());
+  }
+
   /** Remove all added ports from UsbManager. */
   public void clearPorts() {
     usbPorts.clear();
@@ -203,7 +219,7 @@ public class ShadowUsbManager {
 
   /** Adds a USB port with given ID to UsbManager. */
   public void addPort(String portId) {
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
+    if (RuntimeEnvironment.getApiLevel() >= Q) {
       addPort(
           portId,
           UsbPortStatus.MODE_DUAL,
@@ -230,14 +246,14 @@ public class ShadowUsbManager {
   }
 
   /** Adds a USB port with given ID and {@link UsbPortStatus} parameters to UsbManager for Q+. */
-  @TargetApi(Build.VERSION_CODES.Q)
+  @TargetApi(Q)
   public void addPort(
       String portId,
       int statusCurrentMode,
       int statusCurrentPowerRole,
       int statusCurrentDataRole,
       int statusSupportedRoleCombinations) {
-    Preconditions.checkState(RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q);
+    Preconditions.checkState(RuntimeEnvironment.getApiLevel() >= Q);
     UsbPort usbPort = (UsbPort) createUsbPort(realUsbManager, portId, statusCurrentMode);
     usbPorts.put(portId, usbPort);
     usbPortStatuses.put(
@@ -261,22 +277,23 @@ public class ShadowUsbManager {
 
   @Implementation(minSdk = M)
   @HiddenApi
-  protected /* UsbPortStatus */ Object getPortStatus(/* UsbPort */ Object port) {
+  protected @ClassName("android.hardware.usb.UsbPortStatus") Object getPortStatus(
+      @ClassName("android.hardware.usb.UsbPort") Object port) {
     return usbPortStatuses.get(port);
   }
 
   @Implementation(minSdk = M)
   @HiddenApi
   protected void setPortRoles(
-      /* UsbPort */ Object port, /* int */ Object powerRole, /* int */ Object dataRole) {
+      @ClassName("android.hardware.usb.UsbPort") Object port, int powerRole, int dataRole) {
     UsbPortStatus status = usbPortStatuses.get(port);
     usbPortStatuses.put(
         (UsbPort) port,
         (UsbPortStatus)
             createUsbPortStatus(
                 status.getCurrentMode(),
-                (int) powerRole,
-                (int) dataRole,
+                powerRole,
+                dataRole,
                 status.getSupportedRoleCombinations()));
     RuntimeEnvironment.getApplication()
         .sendBroadcast(new Intent(UsbManager.ACTION_USB_PORT_CHANGED));
@@ -309,7 +326,7 @@ public class ShadowUsbManager {
    */
   private static Object createUsbPortStatus(
       int currentMode, int currentPowerRole, int currentDataRole, int supportedRoleCombinations) {
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
+    if (RuntimeEnvironment.getApiLevel() >= Q) {
       return new UsbPortStatus(
           currentMode, currentPowerRole, currentDataRole, supportedRoleCombinations, 0, 0);
     }
@@ -327,7 +344,7 @@ public class ShadowUsbManager {
    * <p>Returns Object to avoid referencing the API M+ UsbPort when running on older platforms.
    */
   private static Object createUsbPort(UsbManager usbManager, String id, int supportedModes) {
-    if (RuntimeEnvironment.getApiLevel() >= Build.VERSION_CODES.Q) {
+    if (RuntimeEnvironment.getApiLevel() >= Q) {
       return new UsbPort(usbManager, id, supportedModes, 0, false, false);
     }
     return callConstructor(
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
index e9f712e1d..e0d2a84f4 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUserManager.java
@@ -13,8 +13,6 @@ import static android.os.UserManager.RESTRICTION_SOURCE_SYSTEM;
 import static android.os.UserManager.USER_TYPE_FULL_GUEST;
 import static android.os.UserManager.USER_TYPE_FULL_RESTRICTED;
 import static android.os.UserManager.USER_TYPE_FULL_SECONDARY;
-import static org.robolectric.shadow.api.Shadow.invokeConstructor;
-import static org.robolectric.util.ReflectionHelpers.ClassParameter.from;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.Manifest.permission;
@@ -51,6 +49,7 @@ import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
@@ -77,40 +76,52 @@ public class ShadowUserManager {
   public static final int FLAG_SYSTEM = UserInfo.FLAG_SYSTEM;
   public static final int FLAG_MAIN = UserInfo.FLAG_MAIN;
 
-  private static int maxSupportedUsers = DEFAULT_MAX_SUPPORTED_USERS;
-  private static boolean isMultiUserSupported = false;
-  private static boolean isHeadlessSystemUserMode = false;
-
   private final Object lock = new Object();
 
   @RealObject private UserManager realObject;
-  private UserManagerState userManagerState;
-  private Boolean managedProfile;
-  private Boolean cloneProfile;
-  private boolean userUnlocked = true;
-  private boolean isSystemUser = true;
-  private volatile boolean isForegroundUser = true;
-
-  /**
-   * Holds whether or not a managed profile can be unlocked. If a profile is not in this map, it is
-   * assume it can be unlocked.
-   */
-  private String seedAccountName;
-
-  private String seedAccountType;
-  private PersistableBundle seedAccountOptions;
+  private static UserManagerState userManagerState = new UserManagerState();
 
   private Context context;
-  private boolean enforcePermissions;
-  private int userSwitchability = UserManager.SWITCHABILITY_STATUS_OK;
 
-  private final Set<Account> userAccounts = new HashSet<>();
+  private Context getContext() {
+    return context;
+  }
+
+  /**
+   * Shadowing this is currently required because the real UserManager constructor stores the result
+   * of context.getApplicationContext(), which may be null due to a separate Robolectric bug.
+   */
+  @Implementation
+  protected void __constructor__(Context context, IUserManager service) {
+    Shadow.invokeConstructor(
+        UserManager.class,
+        realObject,
+        ClassParameter.from(Context.class, context),
+        ClassParameter.from(IUserManager.class, service));
+    this.context = context;
+  }
 
   /**
    * Global UserManager state. Shared across {@link UserManager}s created in different {@link
    * Context}s.
    */
   static class UserManagerState {
+    private int maxSupportedUsers = DEFAULT_MAX_SUPPORTED_USERS;
+    private boolean isMultiUserSupported = false;
+    private boolean isHeadlessSystemUserMode = false;
+    private Boolean managedProfile;
+    private Boolean cloneProfile;
+    private boolean userUnlocked = true;
+    private boolean isSystemUser = true;
+    private volatile boolean isForegroundUser = true;
+
+    private String seedAccountName;
+    private String seedAccountType;
+    private PersistableBundle seedAccountOptions;
+    private boolean enforcePermissions;
+    private int userSwitchability = UserManager.SWITCHABILITY_STATUS_OK;
+    private final Set<Account> userAccounts = new HashSet<>();
+
     private final Map<Integer, Integer> userPidMap = new HashMap<>();
 
     /** Holds the serial numbers for all users and profiles, indexed by UserHandle.id */
@@ -123,14 +134,20 @@ public class ShadowUserManager {
     private final Map<Integer, UserInfo> userInfoMap = new HashMap<>();
 
     /**
-     * Each user holds a list of UserHandles of assocated profiles and user itself. User is indexed
+     * Each user holds a list of UserHandles of associated profiles and user itself. User is indexed
      * by UserHandle.id. See UserManager.getProfiles(userId).
      */
     private final Map<Integer, List<UserHandle>> userProfilesListMap = new HashMap<>();
 
     private final Map<Integer, Bundle> userRestrictions = new HashMap<>();
     private final Map<String, Bundle> applicationRestrictions = new HashMap<>();
+
+    /**
+     * Holds whether or not a managed profile can be unlocked. If a profile is not in this map, it
+     * is assume it can be unlocked.
+     */
     private final Map<Integer, Boolean> profileIsLocked = new HashMap<>();
+
     private final Map<Integer, Bitmap> userIcon = new HashMap<>();
 
     private int nextUserId = DEFAULT_SECONDARY_USER_ID;
@@ -153,18 +170,6 @@ public class ShadowUserManager {
     }
   }
 
-  @Implementation
-  protected void __constructor__(Context context, IUserManager service) {
-    this.context = context;
-    invokeConstructor(
-        UserManager.class,
-        realObject,
-        from(Context.class, context),
-        from(IUserManager.class, service));
-
-    userManagerState = ShadowApplication.getInstance().getUserManagerState();
-  }
-
   /**
    * Compared to real Android, there is no check that the package name matches the application
    * package name and the method returns instantly.
@@ -243,18 +248,18 @@ public class ShadowUserManager {
   @Implementation(minSdk = R)
   protected List<UserHandle> getAllProfiles() {
     ArrayList<UserHandle> userHandles = new ArrayList<>();
-    if (userManagerState.userProfilesListMap.containsKey(context.getUserId())) {
-      userHandles.addAll(userManagerState.userProfilesListMap.get(context.getUserId()));
+    if (userManagerState.userProfilesListMap.containsKey(getContext().getUserId())) {
+      userHandles.addAll(userManagerState.userProfilesListMap.get(getContext().getUserId()));
       return userHandles;
     }
 
-    userHandles.add(UserHandle.of(context.getUserId()));
+    userHandles.add(UserHandle.of(getContext().getUserId()));
     return userHandles;
   }
 
   @Implementation
   protected UserInfo getProfileParent(int userId) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException("Requires MANAGE_USERS permission");
     }
     UserInfo profile = getUserInfo(userId);
@@ -273,10 +278,12 @@ public class ShadowUserManager {
   protected UserHandle createProfile(String name, String userType, Set<String> disallowedPackages) {
     int flags = getDefaultUserTypeFlags(userType);
     flags |= FLAG_PROFILE; // assume createProfile used with a profile userType
-    if (enforcePermissions && !hasManageUsersPermission() && !hasCreateUsersPermission()) {
+    if (userManagerState.enforcePermissions
+        && !hasManageUsersPermission()
+        && !hasCreateUsersPermission()) {
       throw new SecurityException(
           "You either need MANAGE_USERS or CREATE_USERS "
-              + "permission to create an user with flags: "
+              + "permission to create a user with flags: "
               + flags);
     }
 
@@ -285,7 +292,7 @@ public class ShadowUserManager {
     }
 
     int profileId = userManagerState.nextUserId++;
-    addProfile(context.getUserId(), profileId, name, flags);
+    addProfile(getContext().getUserId(), profileId, name, flags);
     userManagerState.userInfoMap.get(profileId).userType = userType;
     return UserHandle.of(profileId);
   }
@@ -342,12 +349,12 @@ public class ShadowUserManager {
 
   /** Setter for {@link UserManager#isUserUnlocked()} */
   public void setUserUnlocked(boolean userUnlocked) {
-    this.userUnlocked = userUnlocked;
+    userManagerState.userUnlocked = userUnlocked;
   }
 
   @Implementation(minSdk = N)
   protected boolean isUserUnlocked() {
-    return userUnlocked;
+    return userManagerState.userUnlocked;
   }
 
   /**
@@ -372,18 +379,18 @@ public class ShadowUserManager {
    */
   @Implementation
   protected boolean isManagedProfile() {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException(
           "You need MANAGE_USERS permission to: check if specified user a "
               + "managed profile outside your profile group");
     }
 
-    if (managedProfile != null) {
-      return managedProfile;
+    if (userManagerState.managedProfile != null) {
+      return userManagerState.managedProfile;
     }
 
     if (RuntimeEnvironment.getApiLevel() >= R) {
-      return isManagedProfile(context.getUserId());
+      return isManagedProfile(getContext().getUserId());
     }
 
     return false;
@@ -401,7 +408,7 @@ public class ShadowUserManager {
    */
   @Implementation(minSdk = N)
   protected boolean isManagedProfile(int userHandle) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException(
           "You need MANAGE_USERS permission to: check if specified user a "
               + "managed profile outside your profile group");
@@ -411,12 +418,12 @@ public class ShadowUserManager {
   }
 
   public void enforcePermissionChecks(boolean enforcePermissions) {
-    this.enforcePermissions = enforcePermissions;
+    userManagerState.enforcePermissions = enforcePermissions;
   }
 
   /** Setter for {@link UserManager#isManagedProfile()}. */
   public void setManagedProfile(boolean managedProfile) {
-    this.managedProfile = managedProfile;
+    userManagerState.managedProfile = managedProfile;
   }
 
   /**
@@ -430,46 +437,46 @@ public class ShadowUserManager {
    */
   @Implementation(minSdk = S)
   protected boolean isCloneProfile() {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException("You need MANAGE_USERS permission to: check isCloneProfile");
     }
 
-    if (cloneProfile != null) {
-      return cloneProfile;
+    if (userManagerState.cloneProfile != null) {
+      return userManagerState.cloneProfile;
     }
 
-    UserInfo info = getUserInfo(context.getUserId());
+    UserInfo info = getUserInfo(getContext().getUserId());
     return info != null && info.isCloneProfile();
   }
 
   /** Setter for {@link UserManager#isCloneProfile()}. */
   public void setCloneProfile(boolean cloneProfile) {
-    this.cloneProfile = cloneProfile;
+    userManagerState.cloneProfile = cloneProfile;
   }
 
   @Implementation(minSdk = R)
   protected boolean isProfile() {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException(
           "You need INTERACT_ACROSS_USERS or MANAGE_USERS permission to: check isProfile");
     }
 
-    return getUserInfo(context.getUserId()).isProfile();
+    return getUserInfo(getContext().getUserId()).isProfile();
   }
 
   @Implementation(minSdk = R)
   protected boolean isUserOfType(String userType) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException("You need MANAGE_USERS permission to: check user type");
     }
 
-    UserInfo info = getUserInfo(context.getUserId());
+    UserInfo info = getUserInfo(getContext().getUserId());
     return info != null && info.userType != null && info.userType.equals(userType);
   }
 
   @Implementation(minSdk = R)
   protected boolean isSameProfileGroup(UserHandle user, UserHandle otherUser) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException(
           "You need MANAGE_USERS permission to: check if in the same profile group");
     }
@@ -555,8 +562,8 @@ public class ShadowUserManager {
 
   /**
    * {@link #addUser} uses UserHandle for serialNumber. setSerialNumberForUser() allows assigning an
-   * arbitary serialNumber. Some test use serialNumber!=0 as secondary user check, so it's necessary
-   * to "fake" the serialNumber to a non-zero value.
+   * arbitrary serialNumber. Some test use serialNumber!=0 as secondary user check, so it's
+   * necessary to "fake" the serialNumber to a non-zero value.
    */
   public void setSerialNumberForUser(UserHandle userHandle, long serialNumber) {
     userManagerState.userSerialNumbers.put(userHandle.getIdentifier(), serialNumber);
@@ -596,7 +603,7 @@ public class ShadowUserManager {
   @Implementation(minSdk = Q)
   protected String getUserName() {
     if (RuntimeEnvironment.getApiLevel() >= R) {
-      return getUserName(context.getUserId());
+      return getUserName(getContext().getUserId());
     }
 
     return getUserName(UserHandle.myUserId());
@@ -604,16 +611,16 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = R)
   protected void setUserName(String name) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException("You need MANAGE_USERS permission to: rename users");
     }
-    UserInfo user = getUserInfo(context.getUserId());
+    UserInfo user = getUserInfo(getContext().getUserId());
     user.name = name;
   }
 
   @Implementation(minSdk = Q)
   protected Bitmap getUserIcon() {
-    if (enforcePermissions
+    if (userManagerState.enforcePermissions
         && !hasManageUsersPermission()
         && !hasGetAccountsPrivilegedPermission()) {
       throw new SecurityException(
@@ -622,7 +629,7 @@ public class ShadowUserManager {
 
     int userId = UserHandle.myUserId();
     if (RuntimeEnvironment.getApiLevel() >= R) {
-      userId = context.getUserId();
+      userId = getContext().getUserId();
     }
 
     return userManagerState.userIcon.get(userId);
@@ -630,13 +637,13 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = Q)
   protected void setUserIcon(Bitmap icon) {
-    if (enforcePermissions && !hasManageUsersPermission()) {
+    if (userManagerState.enforcePermissions && !hasManageUsersPermission()) {
       throw new SecurityException("You need MANAGE_USERS permission to: update users");
     }
 
     int userId = UserHandle.myUserId();
     if (RuntimeEnvironment.getApiLevel() >= R) {
-      userId = context.getUserId();
+      userId = getContext().getUserId();
     }
 
     userManagerState.userIcon.put(userId, icon);
@@ -666,43 +673,43 @@ public class ShadowUserManager {
   @HiddenApi
   @Implementation
   protected static int getMaxSupportedUsers() {
-    return maxSupportedUsers;
+    return userManagerState.maxSupportedUsers;
   }
 
   public void setMaxSupportedUsers(int maxSupportedUsers) {
-    ShadowUserManager.maxSupportedUsers = maxSupportedUsers;
+    userManagerState.maxSupportedUsers = maxSupportedUsers;
   }
 
   private boolean hasManageUsersPermission() {
-    return context
+    return getContext()
             .getPackageManager()
-            .checkPermission(permission.MANAGE_USERS, context.getPackageName())
+            .checkPermission(permission.MANAGE_USERS, getContext().getPackageName())
         == PackageManager.PERMISSION_GRANTED;
   }
 
   private boolean hasCreateUsersPermission() {
-    return context
+    return getContext()
             .getPackageManager()
-            .checkPermission(permission.CREATE_USERS, context.getPackageName())
+            .checkPermission(permission.CREATE_USERS, getContext().getPackageName())
         == PackageManager.PERMISSION_GRANTED;
   }
 
   private boolean hasModifyQuietModePermission() {
-    return context
+    return getContext()
             .getPackageManager()
-            .checkPermission(permission.MODIFY_QUIET_MODE, context.getPackageName())
+            .checkPermission(permission.MODIFY_QUIET_MODE, getContext().getPackageName())
         == PackageManager.PERMISSION_GRANTED;
   }
 
   private boolean hasGetAccountsPrivilegedPermission() {
-    return context
+    return getContext()
             .getPackageManager()
-            .checkPermission(permission.GET_ACCOUNTS_PRIVILEGED, context.getPackageName())
+            .checkPermission(permission.GET_ACCOUNTS_PRIVILEGED, getContext().getPackageName())
         == PackageManager.PERMISSION_GRANTED;
   }
 
   private void checkPermissions() {
-    // TODO Ensure permisions
+    // TODO Ensure permissions
     //              throw new SecurityException("You need INTERACT_ACROSS_USERS or MANAGE_USERS
     // permission "
     //                + "to: check " + name);throw new SecurityException();
@@ -738,7 +745,7 @@ public class ShadowUserManager {
    */
   @Implementation(minSdk = M)
   protected boolean isSystemUser() {
-    if (isSystemUser == false) {
+    if (userManagerState.isSystemUser == false) {
       return false;
     } else {
       return reflector(UserManagerReflector.class, realObject).isSystemUser();
@@ -754,7 +761,7 @@ public class ShadowUserManager {
    */
   @Deprecated
   public void setIsSystemUser(boolean isSystemUser) {
-    this.isSystemUser = isSystemUser;
+    userManagerState.isSystemUser = isSystemUser;
   }
 
   /**
@@ -951,7 +958,9 @@ public class ShadowUserManager {
    */
   @Implementation(minSdk = Q)
   protected boolean requestQuietModeEnabled(boolean enableQuietMode, UserHandle userHandle) {
-    if (enforcePermissions && !hasManageUsersPermission() && !hasModifyQuietModePermission()) {
+    if (userManagerState.enforcePermissions
+        && !hasManageUsersPermission()
+        && !hasModifyQuietModePermission()) {
       throw new SecurityException("Requires MANAGE_USERS or MODIFY_QUIET_MODE permission");
     }
     Preconditions.checkArgument(isManagedProfileWithoutPermission(userHandle));
@@ -986,7 +995,7 @@ public class ShadowUserManager {
     intent.putExtra(Intent.EXTRA_USER, profileHandle);
     intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_REGISTERED_ONLY);
     // Send the broadcast to the context-registered receivers.
-    context.sendBroadcast(intent);
+    getContext().sendBroadcast(intent);
   }
 
   /**
@@ -1037,39 +1046,39 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = Build.VERSION_CODES.N)
   protected String getSeedAccountName() {
-    return seedAccountName;
+    return userManagerState.seedAccountName;
   }
 
   /** Setter for {@link UserManager#getSeedAccountName()} */
   public void setSeedAccountName(String seedAccountName) {
-    this.seedAccountName = seedAccountName;
+    userManagerState.seedAccountName = seedAccountName;
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.N)
   protected String getSeedAccountType() {
-    return seedAccountType;
+    return userManagerState.seedAccountType;
   }
 
   /** Setter for {@link UserManager#getSeedAccountType()} */
   public void setSeedAccountType(String seedAccountType) {
-    this.seedAccountType = seedAccountType;
+    userManagerState.seedAccountType = seedAccountType;
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.N)
   protected PersistableBundle getSeedAccountOptions() {
-    return seedAccountOptions;
+    return userManagerState.seedAccountOptions;
   }
 
   /** Setter for {@link UserManager#getSeedAccountOptions()} */
   public void setSeedAccountOptions(PersistableBundle seedAccountOptions) {
-    this.seedAccountOptions = seedAccountOptions;
+    userManagerState.seedAccountOptions = seedAccountOptions;
   }
 
   @Implementation(minSdk = Build.VERSION_CODES.N)
   protected void clearSeedAccountData() {
-    seedAccountName = null;
-    seedAccountType = null;
-    seedAccountOptions = null;
+    userManagerState.seedAccountName = null;
+    userManagerState.seedAccountType = null;
+    userManagerState.seedAccountOptions = null;
   }
 
   @Implementation
@@ -1109,7 +1118,7 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = N)
   protected static boolean supportsMultipleUsers() {
-    return isMultiUserSupported;
+    return userManagerState.isMultiUserSupported;
   }
 
   /**
@@ -1117,7 +1126,7 @@ public class ShadowUserManager {
    * UserManager#supportsMultipleUser}.
    */
   public void setSupportsMultipleUsers(boolean isMultiUserSupported) {
-    ShadowUserManager.isMultiUserSupported = isMultiUserSupported;
+    userManagerState.isMultiUserSupported = isMultiUserSupported;
   }
 
   /**
@@ -1132,7 +1141,7 @@ public class ShadowUserManager {
 
     ShadowProcess.setUid(userManagerState.userPidMap.get(userId));
 
-    Application application = (Application) context.getApplicationContext();
+    Application application = (Application) getContext().getApplicationContext();
     ShadowContextImpl shadowContext = Shadow.extract(application.getBaseContext());
     shadowContext.setUserId(userId);
 
@@ -1186,12 +1195,12 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = Q)
   protected int getUserSwitchability() {
-    return userSwitchability;
+    return userManagerState.userSwitchability;
   }
 
   /** Sets the user switchability for all users. */
   public void setUserSwitchability(int switchability) {
-    this.userSwitchability = switchability;
+    userManagerState.userSwitchability = switchability;
   }
 
   @Implementation(minSdk = R)
@@ -1223,12 +1232,12 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = S)
   protected static boolean isHeadlessSystemUserMode() {
-    return isHeadlessSystemUserMode;
+    return userManagerState.isHeadlessSystemUserMode;
   }
 
   /** Updates headless system user mode. */
   public static void setHeadlessSystemUserMode(boolean isEnabled) {
-    ShadowUserManager.isHeadlessSystemUserMode = isEnabled;
+    userManagerState.isHeadlessSystemUserMode = isEnabled;
   }
 
   @Implementation(minSdk = TIRAMISU)
@@ -1244,9 +1253,7 @@ public class ShadowUserManager {
 
   @Resetter
   public static void reset() {
-    maxSupportedUsers = DEFAULT_MAX_SUPPORTED_USERS;
-    isMultiUserSupported = false;
-    isHeadlessSystemUserMode = false;
+    userManagerState = new UserManagerState();
   }
 
   @ForType(UserManager.class)
@@ -1264,27 +1271,27 @@ public class ShadowUserManager {
 
   @Implementation(minSdk = TIRAMISU)
   protected boolean someUserHasAccount(String accountName, String accountType) {
-    return userAccounts.contains(new Account(accountName, accountType));
+    return userManagerState.userAccounts.contains(new Account(accountName, accountType));
   }
 
   /** Setter for {@link UserManager#someUserHasAccount(String, String)}. */
   public void setSomeUserHasAccount(String accountName, String accountType) {
-    userAccounts.add(new Account(accountName, accountType));
+    userManagerState.userAccounts.add(new Account(accountName, accountType));
   }
 
   /** Removes user account set via {@link #setSomeUserHasAccount(String, String)}. */
   public void removeSomeUserHasAccount(String accountName, String accountType) {
-    userAccounts.remove(new Account(accountName, accountType));
+    userManagerState.userAccounts.remove(new Account(accountName, accountType));
   }
 
   /** Sets whether or not the current user is the foreground user. */
   public void setUserForeground(boolean foreground) {
-    isForegroundUser = foreground;
+    userManagerState.isForegroundUser = foreground;
   }
 
   @Implementation(minSdk = S)
   protected boolean isUserForeground() {
-    return isForegroundUser;
+    return userManagerState.isForegroundUser;
   }
 
   @Implementation(minSdk = O)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
index b941ce52e..c3138e82e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowUwbManager.java
@@ -16,42 +16,24 @@ import java.util.List;
 import java.util.concurrent.Executor;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.shadow.api.Shadow;
 
 /** Adds Robolectric support for UWB ranging. */
 @Implements(value = UwbManager.class, minSdk = VERSION_CODES.S, isInAndroidSdk = false)
 public class ShadowUwbManager {
 
-  private AdapterStateCallback callback;
+  private static AdapterStateCallback callback;
 
-  private int adapterState = AdapterStateCallback.STATE_ENABLED_INACTIVE;
+  private static int adapterState = AdapterStateCallback.STATE_ENABLED_INACTIVE;
 
-  private int stateChangedReason = AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_POLICY;
+  private static int stateChangedReason = AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_POLICY;
 
-  private PersistableBundle specificationInfo = new PersistableBundle();
+  private static PersistableBundle specificationInfo = new PersistableBundle();
 
-  private List<PersistableBundle> chipInfos = new ArrayList<>();
+  private static List<PersistableBundle> chipInfos = new ArrayList<>();
 
-  private ShadowRangingSession.Adapter adapter =
-      new ShadowRangingSession.Adapter() {
-        @Override
-        public void onOpen(
-            RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
-
-        @Override
-        public void onStart(
-            RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
-
-        @Override
-        public void onReconfigure(
-            RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
-
-        @Override
-        public void onStop(RangingSession session, RangingSession.Callback callback) {}
-
-        @Override
-        public void onClose(RangingSession session, RangingSession.Callback callback) {}
-      };
+  private static ShadowRangingSession.Adapter adapter = createDefaultAdapter();
 
   @Implementation
   protected void registerAdapterStateCallback(Executor executor, AdapterStateCallback callback) {
@@ -182,4 +164,39 @@ public class ShadowUwbManager {
   public void setChipInfos(List<PersistableBundle> chipInfos) {
     this.chipInfos = new ArrayList<>(chipInfos);
   }
+
+  @Resetter
+  public static void reset() {
+    callback = null;
+    adapterState = AdapterStateCallback.STATE_ENABLED_INACTIVE;
+    stateChangedReason = AdapterStateCallback.STATE_CHANGED_REASON_SYSTEM_POLICY;
+    specificationInfo = new PersistableBundle();
+    if (chipInfos != null) {
+      chipInfos.clear();
+    }
+    adapter = createDefaultAdapter();
+  }
+
+  /** Creates a default {@link ShadowRangingSession.Adapter} instance. */
+  private static ShadowRangingSession.Adapter createDefaultAdapter() {
+    return new ShadowRangingSession.Adapter() {
+      @Override
+      public void onOpen(
+          RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
+
+      @Override
+      public void onStart(
+          RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
+
+      @Override
+      public void onReconfigure(
+          RangingSession session, RangingSession.Callback callback, PersistableBundle params) {}
+
+      @Override
+      public void onStop(RangingSession session, RangingSession.Callback callback) {}
+
+      @Override
+      public void onClose(RangingSession session, RangingSession.Callback callback) {}
+    };
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVcnManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVcnManager.java
index dcacd0c7e..3a3f728bf 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVcnManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVcnManager.java
@@ -14,15 +14,16 @@ import java.util.Set;
 import java.util.concurrent.Executor;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** A Shadow for android.net.vcn.VcnManager added in Android S. */
 @Implements(value = VcnManager.class, minSdk = VERSION_CODES.S, isInAndroidSdk = false)
 public class ShadowVcnManager {
 
-  private final Map<VcnStatusCallback, VcnStatusCallbackInfo> callbacks = new HashMap<>();
-  private final Map<ParcelUuid, VcnConfig> configs = new HashMap<>();
+  private static final Map<VcnStatusCallback, VcnStatusCallbackInfo> callbacks = new HashMap<>();
+  private static final Map<ParcelUuid, VcnConfig> configs = new HashMap<>();
 
-  private int currentVcnStatus = VcnManager.VCN_STATUS_CODE_NOT_CONFIGURED;
+  private static int currentVcnStatus = VcnManager.VCN_STATUS_CODE_NOT_CONFIGURED;
 
   @Implementation
   protected void registerVcnStatusCallback(
@@ -95,6 +96,13 @@ public class ShadowVcnManager {
     return callbacks.get(callback).subGroup;
   }
 
+  @Resetter
+  public static void reset() {
+    callbacks.clear();
+    configs.clear();
+    currentVcnStatus = VcnManager.VCN_STATUS_CODE_NOT_CONFIGURED;
+  }
+
   private static final class VcnStatusCallbackInfo {
     private final Executor executor;
     private final ParcelUuid subGroup;
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
index 60ee635a3..daaec1977 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowView.java
@@ -14,7 +14,6 @@ import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.Point;
 import android.graphics.Rect;
-import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.os.Looper;
@@ -27,15 +26,14 @@ import android.view.IWindowFocusObserver;
 import android.view.IWindowId;
 import android.view.MotionEvent;
 import android.view.View;
-import android.view.ViewGroup.LayoutParams;
 import android.view.ViewParent;
 import android.view.WindowId;
-import android.view.WindowManager;
 import android.view.animation.Animation;
 import android.view.animation.Transformation;
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableList;
 import java.io.PrintStream;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -53,7 +51,6 @@ import org.robolectric.annotation.Resetter;
 import org.robolectric.config.ConfigurationRegistry;
 import org.robolectric.shadow.api.Shadow;
 import org.robolectric.shadows.ShadowViewRootImpl.ViewRootImplReflector;
-import org.robolectric.util.TimeUtils;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
@@ -631,33 +628,6 @@ public class ShadowView {
     }
   }
 
-  @Implementation
-  protected void getLocationOnScreen(int[] outLocation) {
-    reflector(_View_.class, realView).getLocationOnScreen(outLocation);
-    int[] windowLocation = getWindowLocation();
-    outLocation[0] += windowLocation[0];
-    outLocation[1] += windowLocation[1];
-  }
-
-  @Implementation(minSdk = O)
-  protected void mapRectFromViewToScreenCoords(RectF rect, boolean clipToParent) {
-    reflector(_View_.class, realView).mapRectFromViewToScreenCoords(rect, clipToParent);
-    int[] windowLocation = getWindowLocation();
-    rect.offset(windowLocation[0], windowLocation[1]);
-  }
-
-  // TODO(paulsowden): Should configure the correct frame on the ViewRootImpl instead and remove
-  //  this.
-  private int[] getWindowLocation() {
-    int[] location = new int[2];
-    LayoutParams rootParams = realView.getRootView().getLayoutParams();
-    if (rootParams instanceof WindowManager.LayoutParams) {
-      location[0] = ((WindowManager.LayoutParams) rootParams).x;
-      location[1] = ((WindowManager.LayoutParams) rootParams).y;
-    }
-    return location;
-  }
-
   @Implementation
   protected int getLayerType() {
     return this.layerType;
@@ -767,7 +737,7 @@ public class ShadowView {
         startTime = animation.getStartTime();
         elapsedTime +=
             ShadowLooper.looperMode().equals(LooperMode.Mode.LEGACY)
-                ? ShadowChoreographer.getFrameInterval() / TimeUtils.NANOS_PER_MS
+                ? Duration.ofNanos(ShadowChoreographer.getFrameInterval()).toMillis()
                 : ShadowChoreographer.getFrameDelay().toMillis();
         Choreographer.getInstance().postCallback(Choreographer.CALLBACK_ANIMATION, this, null);
       } else if (animationRunner == this) {
@@ -891,12 +861,6 @@ public class ShadowView {
 
     void onScrollChanged(int l, int t, int oldl, int oldt);
 
-    @Direct
-    void getLocationOnScreen(int[] outLocation);
-
-    @Direct
-    void mapRectFromViewToScreenCoords(RectF rect, boolean clipToParent);
-
     @Direct
     int getSourceLayoutResId();
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
index fe582460b..142a73f9e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowViewRootImpl.java
@@ -1,313 +1,59 @@
 package org.robolectric.shadows;
 
-import static android.os.Build.VERSION_CODES.Q;
 import static android.os.Build.VERSION_CODES.R;
 import static android.os.Build.VERSION_CODES.S_V2;
-import static org.robolectric.annotation.TextLayoutMode.Mode.REALISTIC;
+import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
-import android.content.res.Configuration;
 import android.graphics.Rect;
-import android.os.Build;
-import android.os.Build.VERSION_CODES;
-import android.os.RemoteException;
-import android.util.MergedConfiguration;
 import android.view.Display;
 import android.view.HandlerActionQueue;
-import android.view.InsetsState;
+import android.view.IWindow;
 import android.view.Surface;
 import android.view.SurfaceControl;
 import android.view.View;
 import android.view.ViewRootImpl;
 import android.view.WindowInsets;
 import android.view.WindowManager;
-import android.window.ClientWindowFrames;
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Optional;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.RealObject;
 import org.robolectric.annotation.Resetter;
-import org.robolectric.annotation.TextLayoutMode;
-import org.robolectric.config.ConfigurationRegistry;
-import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
-import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Direct;
 import org.robolectric.util.reflector.ForType;
 import org.robolectric.util.reflector.Static;
-import org.robolectric.util.reflector.WithType;
 
 @Implements(value = ViewRootImpl.class, isInAndroidSdk = false)
 public class ShadowViewRootImpl {
 
-  private static final int RELAYOUT_RES_IN_TOUCH_MODE = 0x1;
-
-  @RealObject protected ViewRootImpl realObject;
-
-  /**
-   * The visibility of the system status bar.
-   *
-   * <p>The value will be read in the intercepted {@link #getWindowInsets(boolean)} method providing
-   * the current state via the returned {@link WindowInsets} instance if it has been set..
-   *
-   * <p>NOTE: This state does not reflect the current state of system UI visibility flags or the
-   * current window insets. Rather it tracks the latest known state provided via {@link
-   * #setIsStatusBarVisible(boolean)}.
-   */
-  private static Optional<Boolean> isStatusBarVisible = Optional.empty();
-
-  /**
-   * The visibility of the system navigation bar.
-   *
-   * <p>The value will be read in the intercepted {@link #getWindowInsets(boolean)} method providing
-   * the current state via the returned {@link WindowInsets} instance if it has been set.
-   *
-   * <p>NOTE: This state does not reflect the current state of system UI visibility flags or the
-   * current window insets. Rather it tracks the latest known state provided via {@link
-   * #setIsNavigationBarVisible(boolean)}.
-   */
-  private static Optional<Boolean> isNavigationBarVisible = Optional.empty();
-
-  /** Allows other shadows to set the state of {@link #isStatusBarVisible}. */
-  protected static void setIsStatusBarVisible(boolean isStatusBarVisible) {
-    ShadowViewRootImpl.isStatusBarVisible = Optional.of(isStatusBarVisible);
-  }
-
-  /** Clears the last known state of {@link #isStatusBarVisible}. */
-  protected static void clearIsStatusBarVisible() {
-    ShadowViewRootImpl.isStatusBarVisible = Optional.empty();
-  }
-
-  /** Allows other shadows to set the state of {@link #isNavigationBarVisible}. */
-  protected static void setIsNavigationBarVisible(boolean isNavigationBarVisible) {
-    ShadowViewRootImpl.isNavigationBarVisible = Optional.of(isNavigationBarVisible);
+  static {
+    if (RuntimeEnvironment.getApiLevel() == R) {
+      ReflectionHelpers.setStaticField(ViewRootImpl.class, "sNewInsetsMode", 2);
+    }
   }
 
-  /** Clears the last known state of {@link #isNavigationBarVisible}. */
-  protected static void clearIsNavigationBarVisible() {
-    ShadowViewRootImpl.isNavigationBarVisible = Optional.empty();
-  }
+  @RealObject protected ViewRootImpl realObject;
 
   @Implementation
   public void playSoundEffect(int effectId) {}
 
-  @Implementation
-  protected int relayoutWindow(
-      WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending)
-      throws RemoteException {
-    // TODO(christianw): probably should return WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED?
-    int result = 0;
-    if (ShadowWindowManagerGlobal.getInTouchMode() && RuntimeEnvironment.getApiLevel() <= S_V2) {
-      result |= RELAYOUT_RES_IN_TOUCH_MODE;
-    }
-    if (RuntimeEnvironment.getApiLevel() >= Q) {
-      // Simulate initializing the SurfaceControl member object, which happens during this method.
-      SurfaceControl surfaceControl =
-          reflector(ViewRootImplReflector.class, realObject).getSurfaceControl();
-      ShadowSurfaceControl shadowSurfaceControl = Shadow.extract(surfaceControl);
-      shadowSurfaceControl.initializeNativeObject();
-    }
-    return result;
-  }
-
+  // TODO: Deprecate and remove this method, resize should get dispatched automatically to all
+  //  windows added in the window session when a display changes its size.
   public void callDispatchResized() {
-    Optional<Class<?>> activityWindowInfoClass =
-        ReflectionHelpers.attemptLoadClass(
-            this.getClass().getClassLoader(), "android.window.ActivityWindowInfo");
-    if (RuntimeEnvironment.getApiLevel() > VERSION_CODES.UPSIDE_DOWN_CAKE
-        && activityWindowInfoClass.isPresent()) {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-
-      ClientWindowFrames frames = new ClientWindowFrames();
-      // set the final field
-      ReflectionHelpers.setField(frames, "frame", frame);
-      final ClassParameter<?>[] parameters =
-          new ClassParameter<?>[] {
-            ClassParameter.from(ClientWindowFrames.class, frames),
-            ClassParameter.from(boolean.class, true), /* reportDraw */
-            ClassParameter.from(
-                MergedConfiguration.class, new MergedConfiguration()), /* mergedConfiguration */
-            ClassParameter.from(InsetsState.class, new InsetsState()), /* insetsState */
-            ClassParameter.from(boolean.class, false), /* forceLayout */
-            ClassParameter.from(boolean.class, false), /* alwaysConsumeSystemBars */
-            ClassParameter.from(int.class, 0), /* displayId */
-            ClassParameter.from(int.class, 0), /* syncSeqId */
-            ClassParameter.from(boolean.class, false), /* dragResizing */
-            ClassParameter.from(
-                activityWindowInfoClass.get(),
-                ReflectionHelpers.newInstance(
-                    activityWindowInfoClass.get())) /* activityWindowInfo */
-          };
-      try {
-        ReflectionHelpers.callInstanceMethod(
-            ViewRootImpl.class, realObject, "dispatchResized", parameters);
-      } catch (RuntimeException ex) {
-        ReflectionHelpers.callInstanceMethod(
-            ViewRootImpl.class,
-            realObject,
-            "dispatchResized",
-            Arrays.copyOfRange(parameters, 0, parameters.length - 1));
-      }
-    } else if (RuntimeEnvironment.getApiLevel() > VERSION_CODES.TIRAMISU) {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-
-      ClientWindowFrames frames = new ClientWindowFrames();
-      // set the final field
-      ReflectionHelpers.setField(frames, "frame", frame);
-
-      ReflectionHelpers.callInstanceMethod(
-          ViewRootImpl.class,
-          realObject,
-          "dispatchResized",
-          ClassParameter.from(ClientWindowFrames.class, frames),
-          ClassParameter.from(boolean.class, true), /* reportDraw */
-          ClassParameter.from(
-              MergedConfiguration.class, new MergedConfiguration()), /* mergedConfiguration */
-          ClassParameter.from(InsetsState.class, new InsetsState()), /* insetsState */
-          ClassParameter.from(boolean.class, false), /* forceLayout */
-          ClassParameter.from(boolean.class, false), /* alwaysConsumeSystemBars */
-          ClassParameter.from(int.class, 0), /* displayId */
-          ClassParameter.from(int.class, 0), /* syncSeqId */
-          ClassParameter.from(boolean.class, false) /* dragResizing */);
-    } else if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.S_V2) {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-
-      ClientWindowFrames frames = new ClientWindowFrames();
-      // set the final field
-      ReflectionHelpers.setField(frames, "frame", frame);
-
-      ReflectionHelpers.callInstanceMethod(
-          ViewRootImpl.class,
-          realObject,
-          "dispatchResized",
-          ClassParameter.from(ClientWindowFrames.class, frames),
-          ClassParameter.from(boolean.class, true), /* reportDraw */
-          ClassParameter.from(
-              MergedConfiguration.class, new MergedConfiguration()), /* mergedConfiguration */
-          ClassParameter.from(InsetsState.class, new InsetsState()), /* insetsState */
-          ClassParameter.from(boolean.class, false), /* forceLayout */
-          ClassParameter.from(boolean.class, false), /* alwaysConsumeSystemBars */
-          ClassParameter.from(int.class, 0), /* displayId */
-          ClassParameter.from(int.class, 0), /* syncSeqId */
-          ClassParameter.from(int.class, 0) /* resizeMode */);
-    } else if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.R) {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-
-      ClientWindowFrames frames = new ClientWindowFrames();
-      // set the final field
-      ReflectionHelpers.setField(frames, "frame", frame);
-
-      ReflectionHelpers.callInstanceMethod(
-          ViewRootImpl.class,
-          realObject,
-          "dispatchResized",
-          ClassParameter.from(ClientWindowFrames.class, frames),
-          ClassParameter.from(boolean.class, true), /* reportDraw */
-          ClassParameter.from(
-              MergedConfiguration.class, new MergedConfiguration()), /* mergedConfiguration */
-          ClassParameter.from(boolean.class, false), /* forceLayout */
-          ClassParameter.from(boolean.class, false), /* alwaysConsumeSystemBars */
-          ClassParameter.from(int.class, 0) /* displayId */);
-    } else if (RuntimeEnvironment.getApiLevel() > Build.VERSION_CODES.Q) {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-
-      Rect emptyRect = new Rect(0, 0, 0, 0);
-      ReflectionHelpers.callInstanceMethod(
-          ViewRootImpl.class,
-          realObject,
-          "dispatchResized",
-          ClassParameter.from(Rect.class, frame),
-          ClassParameter.from(Rect.class, emptyRect),
-          ClassParameter.from(Rect.class, emptyRect),
-          ClassParameter.from(Rect.class, emptyRect),
-          ClassParameter.from(boolean.class, true),
-          ClassParameter.from(MergedConfiguration.class, new MergedConfiguration()),
-          ClassParameter.from(Rect.class, frame),
-          ClassParameter.from(boolean.class, false),
-          ClassParameter.from(boolean.class, false),
-          ClassParameter.from(int.class, 0),
-          ClassParameter.from(
-              android.view.DisplayCutout.ParcelableWrapper.class,
-              new android.view.DisplayCutout.ParcelableWrapper()));
-    } else {
-      Display display = getDisplay();
-      Rect frame = new Rect();
-      display.getRectSize(frame);
-      reflector(ViewRootImplReflector.class, realObject).dispatchResized(frame);
-    }
+    ShadowWindowManagerGlobal.notifyResize(
+        reflector(ViewRootImplReflector.class, realObject).getWindow());
   }
 
   protected Display getDisplay() {
     return reflector(ViewRootImplReflector.class, realObject).getDisplay();
   }
 
-  @Implementation
-  protected void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
-    reflector(ViewRootImplReflector.class, realObject).setView(view, attrs, panelParentView);
-    if (ConfigurationRegistry.get(TextLayoutMode.Mode.class) == REALISTIC) {
-      Rect winFrame = new Rect();
-      getDisplay().getRectSize(winFrame);
-      reflector(ViewRootImplReflector.class, realObject).setWinFrame(winFrame);
-    }
-  }
-
-  @Implementation(minSdk = R)
-  protected void setView(
-      View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) {
-    reflector(ViewRootImplReflector.class, realObject)
-        .setView(view, attrs, panelParentView, userId);
-    if (ConfigurationRegistry.get(TextLayoutMode.Mode.class) == REALISTIC) {
-      Rect winFrame = new Rect();
-      getDisplay().getRectSize(winFrame);
-      reflector(ViewRootImplReflector.class, realObject).setWinFrame(winFrame);
-    }
-  }
-
-  /**
-   * On Android R+ {@link WindowInsets} supports checking visibility of specific inset types.
-   *
-   * <p>For those SDK levels, override the real {@link WindowInsets} with the tracked system bar
-   * visibility status ({@link #isStatusBarVisible}/{@link #isNavigationBarVisible}), if set.
-   *
-   * <p>NOTE: We use state tracking in place of a longer term solution of implementing the insets
-   * calculations and broadcast (via listeners) for now. Once we have insets calculations working we
-   * should remove this mechanism.
-   */
-  @Implementation(minSdk = R)
-  protected WindowInsets getWindowInsets(boolean forceConstruct) {
-    WindowInsets realInsets =
-        reflector(ViewRootImplReflector.class, realObject).getWindowInsets(forceConstruct);
-
-    WindowInsets.Builder overridenInsetsBuilder = new WindowInsets.Builder(realInsets);
-
-    if (isStatusBarVisible.isPresent()) {
-      overridenInsetsBuilder =
-          overridenInsetsBuilder.setVisible(
-              WindowInsets.Type.statusBars(), isStatusBarVisible.get());
-    }
-
-    if (isNavigationBarVisible.isPresent()) {
-      overridenInsetsBuilder =
-          overridenInsetsBuilder.setVisible(
-              WindowInsets.Type.navigationBars(), isNavigationBarVisible.get());
-    }
-
-    return overridenInsetsBuilder.build();
-  }
+  @Implementation(minSdk = TIRAMISU)
+  protected void updateBlastSurfaceIfNeeded() {}
 
   @Resetter
   public static void reset() {
@@ -316,9 +62,6 @@ public class ShadowViewRootImpl {
     viewRootImplStatic.setFirstDrawHandlers(new ArrayList<>());
     viewRootImplStatic.setFirstDrawComplete(false);
     viewRootImplStatic.setConfigCallbacks(new ArrayList<>());
-
-    clearIsStatusBarVisible();
-    clearIsNavigationBarVisible();
   }
 
   public void callWindowFocusChanged(boolean hasFocus) {
@@ -337,6 +80,8 @@ public class ShadowViewRootImpl {
   /** Reflector interface for {@link ViewRootImpl}'s internals. */
   @ForType(ViewRootImpl.class)
   protected interface ViewRootImplReflector {
+    @Accessor("mWindow")
+    IWindow getWindow();
 
     @Direct
     void setView(View view, WindowManager.LayoutParams attrs, View panelParentView);
@@ -379,116 +124,6 @@ public class ShadowViewRootImpl {
     @Accessor("mWindowAttributes")
     WindowManager.LayoutParams getWindowAttributes();
 
-    // <= LOLLIPOP_MR1
-    void dispatchResized(
-        Rect frame,
-        Rect overscanInsets,
-        Rect contentInsets,
-        Rect visibleInsets,
-        Rect stableInsets,
-        boolean reportDraw,
-        Configuration newConfig);
-
-    // <= M
-    void dispatchResized(
-        Rect frame,
-        Rect overscanInsets,
-        Rect contentInsets,
-        Rect visibleInsets,
-        Rect stableInsets,
-        Rect outsets,
-        boolean reportDraw,
-        Configuration newConfig);
-
-    // <= N_MR1
-    void dispatchResized(
-        Rect frame,
-        Rect overscanInsets,
-        Rect contentInsets,
-        Rect visibleInsets,
-        Rect stableInsets,
-        Rect outsets,
-        boolean reportDraw,
-        Configuration newConfig,
-        Rect backDropFrame,
-        boolean forceLayout,
-        boolean alwaysConsumeNavBar);
-
-    // <= O_MR1
-    void dispatchResized(
-        Rect frame,
-        Rect overscanInsets,
-        Rect contentInsets,
-        Rect visibleInsets,
-        Rect stableInsets,
-        Rect outsets,
-        boolean reportDraw,
-        @WithType("android.util.MergedConfiguration") Object mergedConfiguration,
-        Rect backDropFrame,
-        boolean forceLayout,
-        boolean alwaysConsumeNavBar,
-        int displayId);
-
-    // >= P
-    void dispatchResized(
-        Rect frame,
-        Rect overscanInsets,
-        Rect contentInsets,
-        Rect visibleInsets,
-        Rect stableInsets,
-        Rect outsets,
-        boolean reportDraw,
-        @WithType("android.util.MergedConfiguration") Object mergedConfiguration,
-        Rect backDropFrame,
-        boolean forceLayout,
-        boolean alwaysConsumeNavBar,
-        int displayId,
-        @WithType("android.view.DisplayCutout$ParcelableWrapper") Object displayCutout);
-
-    default void dispatchResized(Rect frame) {
-      Rect emptyRect = new Rect(0, 0, 0, 0);
-
-      int apiLevel = RuntimeEnvironment.getApiLevel();
-      if (apiLevel <= Build.VERSION_CODES.LOLLIPOP_MR1) {
-        dispatchResized(frame, emptyRect, emptyRect, emptyRect, emptyRect, true, null);
-      } else if (apiLevel <= Build.VERSION_CODES.M) {
-        dispatchResized(frame, emptyRect, emptyRect, emptyRect, emptyRect, emptyRect, true, null);
-      } else if (apiLevel <= Build.VERSION_CODES.N_MR1) {
-        dispatchResized(
-            frame, emptyRect, emptyRect, emptyRect, emptyRect, emptyRect, true, null, frame, false,
-            false);
-      } else if (apiLevel <= Build.VERSION_CODES.O_MR1) {
-        dispatchResized(
-            frame,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            true,
-            new MergedConfiguration(),
-            frame,
-            false,
-            false,
-            0);
-      } else { // apiLevel >= Build.VERSION_CODES.P
-        dispatchResized(
-            frame,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            emptyRect,
-            true,
-            new MergedConfiguration(),
-            frame,
-            false,
-            false,
-            0,
-            new android.view.DisplayCutout.ParcelableWrapper());
-      }
-    }
-
     // SDK <= S_V2
     void windowFocusChanged(boolean hasFocus, boolean inTouchMode);
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
index 4eda4c4d3..4afdd4183 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVirtualDeviceManager.java
@@ -51,9 +51,9 @@ import org.robolectric.versioning.AndroidVersions.V;
 @Implements(value = VirtualDeviceManager.class, minSdk = U.SDK_INT, isInAndroidSdk = false)
 public class ShadowVirtualDeviceManager {
 
-  private final List<VirtualDeviceManager.VirtualDevice> mVirtualDevices = new ArrayList<>();
+  private static final List<VirtualDeviceManager.VirtualDevice> mVirtualDevices = new ArrayList<>();
   private Context context;
-  private IVirtualDeviceManager service;
+  private static IVirtualDeviceManager service;
 
   @Implementation
   protected void __constructor__(IVirtualDeviceManager service, Context context) {
@@ -323,6 +323,8 @@ public class ShadowVirtualDeviceManager {
     @Resetter
     public static void reset() {
       nextDeviceId.set(1);
+      mVirtualDevices.clear();
+      service = null;
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
index 17d150775..611a50f5c 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowVpnManager.java
@@ -9,13 +9,14 @@ import java.util.UUID;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow for {@link VpnManager}. */
 @Implements(value = VpnManager.class, minSdk = VERSION_CODES.R, isInAndroidSdk = false)
 public class ShadowVpnManager {
 
-  private VpnProfileState vpnProfileState;
-  private Intent provisionVpnProfileIntent;
+  private static VpnProfileState vpnProfileState;
+  private static Intent provisionVpnProfileIntent;
 
   @Implementation
   protected void deleteProvisionedVpnProfile() {
@@ -64,4 +65,10 @@ public class ShadowVpnManager {
       vpnProfileState = new VpnProfileState(VpnProfileState.STATE_DISCONNECTED, null, false, false);
     }
   }
+
+  @Resetter
+  public static void reset() {
+    vpnProfileState = null;
+    provisionVpnProfileIntent = null;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
index 1b59b3d5d..ab76f02ff 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWallpaperManager.java
@@ -34,24 +34,25 @@ import javax.annotation.Nullable;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.Logger;
 import org.xmlpull.v1.XmlPullParserException;
 
 @Implements(WallpaperManager.class)
 public class ShadowWallpaperManager {
   private static final String TAG = "ShadowWallpaperManager";
-  private Bitmap lockScreenImage = null;
-  private Bitmap homeScreenImage = null;
-  private boolean isWallpaperAllowed = true;
-  private boolean isWallpaperSupported = true;
-  private WallpaperInfo wallpaperInfo = null;
-  private final List<WallpaperCommandRecord> wallpaperCommandRecords = new ArrayList<>();
-  private AtomicInteger wallpaperId = new AtomicInteger(0);
-  private int lockScreenId;
-  private int homeScreenId;
-
-  private float wallpaperDimAmount = 0.0f;
-  private final ArrayList<Float> allWallpaperDimAmounts = new ArrayList<>();
+  private static Bitmap lockScreenImage = null;
+  private static Bitmap homeScreenImage = null;
+  private static boolean isWallpaperAllowed = true;
+  private static boolean isWallpaperSupported = true;
+  private static WallpaperInfo wallpaperInfo = null;
+  private static final List<WallpaperCommandRecord> wallpaperCommandRecords = new ArrayList<>();
+  private static AtomicInteger wallpaperId = new AtomicInteger(0);
+  private static int lockScreenId;
+  private static int homeScreenId;
+
+  private static float wallpaperDimAmount = 0.0f;
+  private static final ArrayList<Float> allWallpaperDimAmounts = new ArrayList<>();
 
   @Implementation
   protected void sendWallpaperCommand(
@@ -321,4 +322,19 @@ public class ShadowWallpaperManager {
       this.extras = extras;
     }
   }
+
+  @Resetter
+  public static void reset() {
+    lockScreenImage = null;
+    homeScreenImage = null;
+    isWallpaperAllowed = true;
+    isWallpaperSupported = true;
+    wallpaperInfo = null;
+    wallpaperCommandRecords.clear();
+    wallpaperId.set(0);
+    lockScreenId = 0;
+    homeScreenId = 0;
+    wallpaperDimAmount = 0.0f;
+    allWallpaperDimAmounts.clear();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
index 275855a21..279a88cbe 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWearableSensingManager.java
@@ -12,6 +12,7 @@ import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.versioning.AndroidVersions.U;
 
 /** Shadow for VirtualDeviceManager. */
@@ -22,11 +23,12 @@ import org.robolectric.versioning.AndroidVersions.U;
     isInAndroidSdk = false)
 public class ShadowWearableSensingManager {
 
-  private @StatusCode Integer provideDataStreamResult = WearableSensingManager.STATUS_SUCCESS;
-  private @StatusCode Integer provideDataResult = WearableSensingManager.STATUS_SUCCESS;
-  private final ArrayList<PersistableBundle> dataBundleList = new ArrayList<>();
-  private final ArrayList<SharedMemory> sharedMemoryList = new ArrayList<>();
-  private ParcelFileDescriptor lastParcelFileDescriptor;
+  private static @StatusCode Integer provideDataStreamResult =
+      WearableSensingManager.STATUS_SUCCESS;
+  private static @StatusCode Integer provideDataResult = WearableSensingManager.STATUS_SUCCESS;
+  private static final ArrayList<PersistableBundle> dataBundleList = new ArrayList<>();
+  private static final ArrayList<SharedMemory> sharedMemoryList = new ArrayList<>();
+  private static ParcelFileDescriptor lastParcelFileDescriptor;
 
   @Implementation
   protected void provideDataStream(
@@ -75,4 +77,13 @@ public class ShadowWearableSensingManager {
   public List<SharedMemory> getAllSharedMemories() {
     return new ArrayList<>(sharedMemoryList);
   }
+
+  @Resetter
+  public static void reset() {
+    provideDataStreamResult = WearableSensingManager.STATUS_SUCCESS;
+    provideDataResult = WearableSensingManager.STATUS_SUCCESS;
+    dataBundleList.clear();
+    sharedMemoryList.clear();
+    lastParcelFileDescriptor = null;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
index 6a814cc21..366e598f1 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiAwareManager.java
@@ -15,15 +15,16 @@ import android.os.Handler;
 import android.os.Looper;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 
 /** Shadow Implementation of {@link android.net.wifi.aware.WifiAwareManager} */
 @Implements(value = WifiAwareManager.class, minSdk = O)
 public class ShadowWifiAwareManager {
-  private boolean available = true;
-  private WifiAwareSession session;
-  private boolean sessionDetached = true;
-  private PublishDiscoverySession discoverySessionToPublish;
-  private SubscribeDiscoverySession discoverySessionToSubscribe;
+  private static boolean available = true;
+  private static WifiAwareSession session;
+  private static boolean sessionDetached = true;
+  private static PublishDiscoverySession discoverySessionToPublish;
+  private static SubscribeDiscoverySession discoverySessionToSubscribe;
 
   @Implementation
   protected boolean isAvailable() {
@@ -109,4 +110,13 @@ public class ShadowWifiAwareManager {
   public void setDiscoverySessionToSubscribe(SubscribeDiscoverySession subscribeDiscoverySession) {
     this.discoverySessionToSubscribe = subscribeDiscoverySession;
   }
+
+  @Resetter
+  public static void reset() {
+    available = true;
+    session = null;
+    sessionDetached = true;
+    discoverySessionToPublish = null;
+    discoverySessionToSubscribe = null;
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
index 5fb44efc9..1061fee1e 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiManager.java
@@ -48,6 +48,7 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.HiddenApi;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
@@ -56,7 +57,7 @@ import org.robolectric.shadow.api.Shadow;
 import org.robolectric.util.ReflectionHelpers;
 
 /** Shadow for {@link android.net.wifi.WifiManager}. */
-@Implements(value = WifiManager.class, looseSignatures = true)
+@Implements(value = WifiManager.class)
 @SuppressWarnings("AndroidConcurrentHashMap")
 public class ShadowWifiManager {
   private static final int LOCAL_HOST = 2130706433;
@@ -600,19 +601,17 @@ public class ShadowWifiManager {
 
   @Implementation(minSdk = Q)
   @HiddenApi
-  protected void addOnWifiUsabilityStatsListener(Object executorObject, Object listenerObject) {
-    Executor executor = (Executor) executorObject;
-    WifiManager.OnWifiUsabilityStatsListener listener =
-        (WifiManager.OnWifiUsabilityStatsListener) listenerObject;
-    wifiUsabilityStatsListeners.put(listener, executor);
+  protected void addOnWifiUsabilityStatsListener(
+      Executor executor,
+      @ClassName("android.net.wifi.WifiManager$OnWifiUsabilityStatsListener") Object listener) {
+    wifiUsabilityStatsListeners.put((WifiManager.OnWifiUsabilityStatsListener) listener, executor);
   }
 
   @Implementation(minSdk = Q)
   @HiddenApi
-  protected void removeOnWifiUsabilityStatsListener(Object listenerObject) {
-    WifiManager.OnWifiUsabilityStatsListener listener =
-        (WifiManager.OnWifiUsabilityStatsListener) listenerObject;
-    wifiUsabilityStatsListeners.remove(listener);
+  protected void removeOnWifiUsabilityStatsListener(
+      @ClassName("android.net.wifi.WifiManager$OnWifiUsabilityStatsListener") Object listener) {
+    wifiUsabilityStatsListeners.remove((WifiManager.OnWifiUsabilityStatsListener) listener);
   }
 
   @Implementation(minSdk = Q)
@@ -629,9 +628,11 @@ public class ShadowWifiManager {
    */
   @Implementation(minSdk = R)
   @HiddenApi
-  protected boolean setWifiConnectedNetworkScorer(Object executorObject, Object scorerObject) {
+  protected boolean setWifiConnectedNetworkScorer(
+      Executor executor,
+      @ClassName("android.net.wifi.WifiManager$WifiConnectedNetworkScorer") Object scorer) {
     if (networkScorer == null) {
-      networkScorer = scorerObject;
+      networkScorer = scorer;
       return true;
     } else {
       return false;
@@ -867,23 +868,21 @@ public class ShadowWifiManager {
     }
   }
 
-  // Object needs to be used here since PnoScanResultsCallback is hidden. The looseSignatures spec
-  // requires that all args are of type Object.
   @Implementation(minSdk = TIRAMISU)
-  @HiddenApi
   protected void setExternalPnoScanRequest(
-      Object ssids, Object frequencies, Object executor, Object callback) {
+      List</*android.net.wifi.WifiSsid*/ ?> ssids,
+      int[] frequencies,
+      Executor executor,
+      @ClassName("android.net.wifi.WifiManager$PnoScanResultsCallback") Object callback) {
     synchronized (pnoRequestLock) {
       if (callback == null) {
         throw new IllegalArgumentException("callback cannot be null");
       }
 
       List<WifiSsid> pnoSsids = (List<WifiSsid>) ssids;
-      int[] pnoFrequencies = (int[]) frequencies;
-      Executor pnoExecutor = (Executor) executor;
       InternalPnoScanResultsCallback pnoCallback = new InternalPnoScanResultsCallback(callback);
 
-      if (pnoExecutor == null) {
+      if (executor == null) {
         throw new IllegalArgumentException("executor cannot be null");
       }
       if (pnoSsids == null || pnoSsids.isEmpty()) {
@@ -894,14 +893,14 @@ public class ShadowWifiManager {
       if (pnoSsids.size() > 2) {
         throw new IllegalArgumentException("Ssid list can't be greater than 2");
       }
-      if (pnoFrequencies != null && pnoFrequencies.length > 10) {
+      if (frequencies != null && frequencies.length > 10) {
         throw new IllegalArgumentException("Length of frequencies must be smaller than 10");
       }
       int uid = Binder.getCallingUid();
       String packageName = getContext().getPackageName();
 
       if (outstandingPnoScanRequest != null) {
-        pnoExecutor.execute(
+        executor.execute(
             () ->
                 pnoCallback.onRegisterFailed(
                     uid == outstandingPnoScanRequest.uid
@@ -911,8 +910,8 @@ public class ShadowWifiManager {
       }
 
       outstandingPnoScanRequest =
-          new PnoScanRequest(pnoSsids, pnoFrequencies, pnoExecutor, pnoCallback, packageName, uid);
-      pnoExecutor.execute(pnoCallback::onRegisterSuccess);
+          new PnoScanRequest(pnoSsids, frequencies, executor, pnoCallback, packageName, uid);
+      executor.execute(pnoCallback::onRegisterSuccess);
     }
   }
 
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
index a8b2c05cc..0fc38a726 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWifiP2pManager.java
@@ -12,6 +12,7 @@ import java.util.HashMap;
 import java.util.Map;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
+import org.robolectric.annotation.Resetter;
 import org.robolectric.util.ReflectionHelpers;
 
 @Implements(WifiP2pManager.class)
@@ -19,12 +20,12 @@ public class ShadowWifiP2pManager {
 
   private static final int NO_FAILURE = -1;
 
-  private int listeningChannel;
-  private int operatingChannel;
-  private WifiP2pManager.GroupInfoListener groupInfoListener;
-  private Handler handler;
-  private int nextActionFailure = NO_FAILURE;
-  private Map<Channel, WifiP2pGroup> p2pGroupmap = new HashMap<>();
+  private static int listeningChannel;
+  private static int operatingChannel;
+  private static WifiP2pManager.GroupInfoListener groupInfoListener;
+  private static Handler handler;
+  private static int nextActionFailure = NO_FAILURE;
+  private static final Map<Channel, WifiP2pGroup> p2pGroupmap = new HashMap<>();
 
   public int getListeningChannel() {
     return listeningChannel;
@@ -105,4 +106,14 @@ public class ShadowWifiP2pManager {
   public void setGroupInfo(Channel channel, WifiP2pGroup wifiP2pGroup) {
     p2pGroupmap.put(channel, wifiP2pGroup);
   }
+
+  @Resetter
+  public static void reset() {
+    listeningChannel = 0;
+    operatingChannel = 0;
+    groupInfoListener = null;
+    handler = null;
+    nextActionFailure = NO_FAILURE;
+    p2pGroupmap.clear();
+  }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
index b749a962a..384ece475 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerGlobal.java
@@ -1,12 +1,31 @@
 package org.robolectric.shadows;
 
+import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
+import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.N_MR1;
+import static android.os.Build.VERSION_CODES.O;
 import static android.os.Build.VERSION_CODES.P;
+import static android.os.Build.VERSION_CODES.Q;
+import static android.os.Build.VERSION_CODES.R;
+import static android.os.Build.VERSION_CODES.S;
+import static android.os.Build.VERSION_CODES.S_V2;
+import static android.os.Build.VERSION_CODES.TIRAMISU;
 import static android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE;
+import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;
+import static android.view.WindowInsets.Type.navigationBars;
+import static android.view.WindowInsets.Type.statusBars;
+import static android.view.WindowInsets.Type.systemBars;
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static java.lang.Math.max;
 import static java.lang.Math.round;
+import static java.util.Arrays.stream;
 import static org.robolectric.shadows.ShadowView.useRealGraphics;
+import static org.robolectric.shadows.SystemUi.systemUiForDisplay;
+import static org.robolectric.util.ReflectionHelpers.callConstructor;
+import static org.robolectric.util.ReflectionHelpers.callInstanceMethod;
 import static org.robolectric.util.reflector.Reflector.reflector;
 
 import android.annotation.FloatRange;
@@ -14,31 +33,60 @@ import android.annotation.Nullable;
 import android.app.Instrumentation;
 import android.content.ClipData;
 import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Insets;
+import android.graphics.Point;
 import android.graphics.Rect;
+import android.hardware.display.DisplayManagerGlobal;
 import android.os.Binder;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.util.Log;
+import android.util.MergedConfiguration;
+import android.view.DisplayCutout;
+import android.view.DisplayInfo;
+import android.view.Gravity;
+import android.view.IWindow;
 import android.view.IWindowManager;
 import android.view.IWindowSession;
+import android.view.InsetsSource;
+import android.view.InsetsSourceControl;
+import android.view.InsetsState;
 import android.view.MotionEvent;
 import android.view.RemoteAnimationTarget;
+import android.view.SurfaceControl;
 import android.view.View;
 import android.view.ViewConfiguration;
+import android.view.WindowManager;
+import android.view.WindowManager.LayoutParams;
 import android.view.WindowManagerGlobal;
+import android.view.WindowRelayoutResult;
+import android.window.ActivityWindowInfo;
 import android.window.BackEvent;
 import android.window.BackMotionEvent;
+import android.window.ClientWindowFrames;
 import android.window.OnBackInvokedCallbackInfo;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Closeable;
+import java.lang.reflect.Array;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map.Entry;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.ClassName;
 import org.robolectric.annotation.Implementation;
 import org.robolectric.annotation.Implements;
 import org.robolectric.annotation.Resetter;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowInsetsState.InsetsStateReflector;
 import org.robolectric.util.ReflectionHelpers;
+import org.robolectric.util.ReflectionHelpers.ClassParameter;
 import org.robolectric.util.reflector.Accessor;
 import org.robolectric.util.reflector.Constructor;
 import org.robolectric.util.reflector.ForType;
@@ -46,7 +94,7 @@ import org.robolectric.util.reflector.Static;
 
 /** Shadow for {@link WindowManagerGlobal}. */
 @SuppressWarnings("unused") // Unused params are implementations of Android SDK methods.
-@Implements(value = WindowManagerGlobal.class, isInAndroidSdk = false, looseSignatures = true)
+@Implements(value = WindowManagerGlobal.class, isInAndroidSdk = false)
 public class ShadowWindowManagerGlobal {
   private static WindowSessionDelegate windowSessionDelegate = new WindowSessionDelegate();
   private static IWindowSession windowSession;
@@ -70,6 +118,10 @@ public class ShadowWindowManagerGlobal {
     windowSessionDelegate.setInTouchMode(inTouchMode);
   }
 
+  static void notifyResize(IWindow window) {
+    windowSessionDelegate.sendResize(window);
+  }
+
   /**
    * Returns the last {@link ClipData} passed to a drag initiated from a call to {@link
    * View#startDrag} or {@link View#startDragAndDrop}, or null if there isn't one.
@@ -294,7 +346,12 @@ public class ShadowWindowManagerGlobal {
                       case "add": // SDK 16
                       case "addToDisplay": // SDK 17-29
                       case "addToDisplayAsUser": // SDK 30+
-                        return windowSessionDelegate.getAddFlags();
+                        return windowSessionDelegate.addToDisplay(args);
+                      case "remove":
+                        windowSessionDelegate.remove(args);
+                        return null;
+                      case "relayout":
+                        return windowSessionDelegate.relayout(args);
                       case "getInTouchMode":
                         return windowSessionDelegate.getInTouchMode();
                       case "performDrag":
@@ -311,6 +368,11 @@ public class ShadowWindowManagerGlobal {
                       case "reportSystemGestureExclusionChanged":
                         windowSessionDelegate.systemGestureExclusionRects = (List<Rect>) args[1];
                         return null;
+                      case "insetsModified":
+                      case "updateRequestedVisibilities":
+                      case "updateRequestedVisibleTypes":
+                        windowSessionDelegate.updateInsets(args);
+                        return null;
                       default:
                         return ReflectionHelpers.defaultValueForType(
                             method.getReturnType().getName());
@@ -326,7 +388,8 @@ public class ShadowWindowManagerGlobal {
   }
 
   @Implementation
-  public static Object getWindowManagerService() throws RemoteException {
+  public static @ClassName("android.view.IWindowManager") Object getWindowManagerService()
+      throws RemoteException {
     IWindowManager service =
         reflector(WindowManagerGlobalReflector.class).getWindowManagerService();
     if (service == null) {
@@ -355,9 +418,12 @@ public class ShadowWindowManagerGlobal {
   }
 
   private static class WindowSessionDelegate {
+    private final LinkedHashMap<IWindow, WindowInfo> windows = new LinkedHashMap<>();
+
     // From WindowManagerGlobal (was WindowManagerImpl in JB).
     static final int ADD_FLAG_IN_TOUCH_MODE = 0x1;
     static final int ADD_FLAG_APP_VISIBLE = 0x2;
+    static final int RELAYOUT_RES_IN_TOUCH_MODE = 0x1;
 
     // TODO: Default to touch mode always.
     private boolean inTouchMode = useRealGraphics();
@@ -366,7 +432,36 @@ public class ShadowWindowManagerGlobal {
     @Nullable private List<Rect> systemGestureExclusionRects;
     @Nullable private PredictiveBackGesture currentPredictiveBackGesture;
 
-    protected int getAddFlags() {
+    protected int addToDisplay(Object[] args) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      WindowInfo windowInfo = windows.computeIfAbsent((IWindow) args[0], id -> new WindowInfo());
+      int displayId = (int) args[sdk <= R ? 4 : 3];
+      // TODO: This is to allow window insets to be keyed per display, i.e. a window has requested
+      //  insets visibility changed before it was added to a display, does android actually allow
+      //  per display window inset visibilities?
+      if (sdk >= R) {
+        applyInsets(displayId, windowInfo.requestedVisibleTypes);
+      }
+      windowInfo.displayId = displayId;
+
+      // Create some insets source controls otherwise the insets controller will not apply changes.
+      if (sdk >= R && sdk < UPSIDE_DOWN_CAKE) {
+        populateInsetSourceControls(windowInfo, findFirst(InsetsSourceControl[].class, args));
+        windowInfo.hasInsetsControl = true;
+        transferWindowInsetsControlTo(windowInfo);
+      }
+      Rect[] rects = findAll(Rect.class, args);
+      int rectIdx = 0;
+      configureWindowFrames(
+          windowInfo,
+          /* inAttrs= */ (WindowManager.LayoutParams) args[sdk <= R ? 2 : 1],
+          /* requestedSize= */ null,
+          /* outFrame= */ sdk >= P && rects.length > rectIdx ? rects[rectIdx++] : null,
+          /* outContentInsets= */ sdk <= R ? rects[rectIdx++] : null,
+          /* outVisibleInsets= */ null,
+          /* outStableInsets= */ sdk >= LOLLIPOP_MR1 && sdk <= R ? rects[rectIdx] : null,
+          /* outInsetsState= */ sdk >= Q ? findFirst(InsetsState.class, args) : null);
+
       int res = 0;
       // Temporarily enable this based on a system property to allow for test migration. This will
       // eventually be updated to default and true and eventually removed, Robolectric's previous
@@ -376,12 +471,123 @@ public class ShadowWindowManagerGlobal {
           || "true".equals(System.getProperty("robolectric.areWindowsMarkedVisible", "false"))) {
         res |= ADD_FLAG_APP_VISIBLE;
       }
-      if (getInTouchMode()) {
-        res |= ADD_FLAG_IN_TOUCH_MODE;
-      }
+      res |= inTouchMode ? ADD_FLAG_IN_TOUCH_MODE : 0;
       return res;
     }
 
+    protected void remove(Object[] args) {
+      IWindow window = (IWindow) args[0];
+      windows.remove(window);
+      // TODO: This transfers control to the last window, should there be another heuristic here?
+      // TODO: Streams.findLast is not available in Android Guava yet.
+      transferWindowInsetsControlTo(windows.values().stream().reduce((a, b) -> b).orElse(null));
+    }
+
+    protected int relayout(Object[] args) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      WindowRelayoutResult windowLayoutResult =
+          sdk >= VANILLA_ICE_CREAM ? findFirst(WindowRelayoutResult.class, args) : null;
+
+      // Simulate initializing the SurfaceControl member object, which happens during this method.
+      if (sdk >= Q) {
+        SurfaceControl surfaceControl =
+            sdk >= VANILLA_ICE_CREAM
+                ? windowLayoutResult.surfaceControl
+                : findFirst(SurfaceControl.class, args);
+        Shadow.<ShadowSurfaceControl>extract(surfaceControl).initializeNativeObject();
+      }
+
+      IWindow window = (IWindow) args[0];
+      WindowInfo windowInfo = windows.get(window);
+      // In legacy looper mode relayout can be called out of order with add so just ignore it.
+      // TODO: In paused looper mode the material SnackbarManager static instance leaks state
+      //  between tests and triggers relayout on window roots that are cleared, for now just ignore
+      //  them here, but ideally this library would not leak state between tests.
+      if (windowInfo != null) {
+        if (sdk >= R && sdk < UPSIDE_DOWN_CAKE) {
+          InsetsSourceControl[] controls = findFirst(InsetsSourceControl[].class, args);
+          if (windowInfo.hasInsetsControl) {
+            populateInsetSourceControls(windowInfo, controls);
+          } else {
+            Arrays.setAll(controls, i -> null);
+          }
+        }
+        Rect[] rects = findAll(Rect.class, args);
+        int requestedSizeIdx = sdk < S ? 3 : 2;
+        configureWindowFrames(
+            checkNotNull(windowInfo),
+            /* inAttrs= */ (WindowManager.LayoutParams) args[sdk <= R ? 2 : 1],
+            /* requestedSize= */ new Point(
+                (int) args[requestedSizeIdx], (int) args[requestedSizeIdx + 1]),
+            /* outFrame= */ rects.length > 0
+                ? rects[0]
+                : (windowLayoutResult != null
+                        ? windowLayoutResult.frames
+                        : findFirst(ClientWindowFrames.class, args))
+                    .frame,
+            /* outContentInsets= */ sdk <= R ? rects[2] : null,
+            /* outVisibleInsets= */ sdk <= R ? rects[3] : null,
+            /* outStableInsets= */ sdk <= R ? rects[4] : null,
+            /* outInsetsState= */ sdk >= Q
+                ? (windowLayoutResult != null
+                    ? windowLayoutResult.insetsState
+                    : findFirst(InsetsState.class, args))
+                : null);
+      }
+
+      return inTouchMode ? RELAYOUT_RES_IN_TOUCH_MODE : 0;
+    }
+
+    private void configureWindowFrames(
+        WindowInfo windowInfo,
+        @Nullable WindowManager.LayoutParams inAttrs,
+        Point requestedSize,
+        Rect outFrame,
+        Rect outContentInsets,
+        Rect outVisibleInsets,
+        Rect outStableInsets,
+        InsetsState outInsetsState) {
+      SystemUi systemUi = systemUiForDisplay(windowInfo.displayId);
+      DisplayInfo displayInfo =
+          DisplayManagerGlobal.getInstance().getDisplayInfo(windowInfo.displayId);
+      WindowManager.LayoutParams attrs = windowInfo.attrs;
+      if (inAttrs != null) {
+        attrs.copyFrom(inAttrs);
+      }
+      windowInfo.displayFrame.set(0, 0, displayInfo.logicalWidth, displayInfo.logicalHeight);
+      Rect contentFrame = new Rect(windowInfo.displayFrame);
+      systemUi.adjustFrameForInsets(attrs, contentFrame);
+      // TODO: Remove this and respect the requested size as real Android does. For back compat
+      //  reasons temporarily ignore requested size.
+      boolean useRequestedSize = Boolean.getBoolean("robolectric.windowManager.useRequestedSize");
+      int width =
+          useRequestedSize && requestedSize != null && attrs.width != LayoutParams.MATCH_PARENT
+              ? requestedSize.x
+              : (attrs.width > 0 ? attrs.width : contentFrame.width());
+      int height =
+          useRequestedSize && requestedSize != null && attrs.height != LayoutParams.MATCH_PARENT
+              ? requestedSize.y
+              : (attrs.height > 0 ? attrs.height : contentFrame.height());
+      // TODO: Take account of parent frame for child windows.
+      Gravity.apply(
+          attrs.gravity,
+          width,
+          height,
+          contentFrame,
+          (int) (attrs.x + attrs.horizontalMargin * contentFrame.width()),
+          (int) (attrs.y + attrs.verticalMargin * contentFrame.height()),
+          windowInfo.frame);
+      if (!useRequestedSize) {
+        // If we are not respecting the requested size, for backwards compatibility allow the window
+        // to offset to the requested position ignoring the gravity and display bounds.
+        windowInfo.frame.offsetTo(attrs.x, attrs.y);
+      } else {
+        Gravity.applyDisplay(attrs.gravity, contentFrame, windowInfo.frame);
+      }
+      systemUiForDisplay(windowInfo.displayId).putInsets(windowInfo);
+      windowInfo.put(outFrame, outContentInsets, outVisibleInsets, outStableInsets, outInsetsState);
+    }
+
     public boolean getInTouchMode() {
       return inTouchMode;
     }
@@ -405,6 +611,264 @@ public class ShadowWindowManagerGlobal {
       }
       throw new AssertionError("Missing ClipData param");
     }
+
+    public void updateInsets(Object[] args) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      checkState(sdk >= R);
+      IWindow window = (IWindow) args[0];
+      WindowInfo windowInfo = windows.computeIfAbsent(window, id -> new WindowInfo());
+      if (sdk <= S) {
+        InsetsState state = (InsetsState) args[1];
+        InsetsSource statusBar = state.peekSource(ShadowInsetsState.STATUS_BARS);
+        InsetsSource navBar = state.peekSource(ShadowInsetsState.NAVIGATION_BARS);
+        windowInfo.requestedVisibleTypes =
+            (statusBar == null || statusBar.isVisible() ? statusBars() : 0)
+                | (navBar == null || navBar.isVisible() ? navigationBars() : 0);
+      } else if (sdk <= TIRAMISU) {
+        InsetsVisibilitiesReflector visibilities =
+            reflector(InsetsVisibilitiesReflector.class, args[1]);
+        boolean statusBar = visibilities.getVisibility(ShadowInsetsState.STATUS_BARS);
+        boolean navBar = visibilities.getVisibility(ShadowInsetsState.NAVIGATION_BARS);
+        windowInfo.requestedVisibleTypes =
+            (statusBar ? statusBars() : 0) | (navBar ? navigationBars() : 0);
+      } else {
+        windowInfo.requestedVisibleTypes = (int) args[1];
+      }
+      if (windowInfo.displayId != -1) {
+        applyInsets(windowInfo.displayId, windowInfo.requestedVisibleTypes);
+      }
+    }
+
+    void applyInsets(int displayId, int requestedVisibleTypes) {
+      checkState(displayId != -1);
+      SystemUi systemUi = systemUiForDisplay(displayId);
+      boolean statusBarVisible = (requestedVisibleTypes & statusBars()) != 0;
+      if (systemUi.getStatusBar().isVisible() != statusBarVisible) {
+        systemUi.getStatusBar().setVisible(statusBarVisible);
+        notifyInsetsChanges(systemUi, systemUi.getStatusBar().getId());
+      }
+      boolean navBarVisible = (requestedVisibleTypes & navigationBars()) != 0;
+      if (systemUi.getNavigationBar().isVisible() != navBarVisible) {
+        systemUi.getNavigationBar().setVisible(navBarVisible);
+        notifyInsetsChanges(systemUi, systemUi.getNavigationBar().getId());
+      }
+    }
+
+    void notifyInsetsChanges(SystemUi systemUi, @Nullable Integer type) {
+      for (Entry<IWindow, WindowInfo> windowEntry : windows.entrySet()) {
+        if (windowEntry.getValue().displayId == systemUi.getDisplayId()) {
+          systemUi.putInsets(windowEntry.getValue());
+          sendInsetsControlChanged(windowEntry.getKey(), type, false);
+          // TODO: only send resize if the window resized.
+          sendResize(windowEntry.getKey());
+        }
+      }
+    }
+
+    void sendInsetsControlChanged(
+        IWindow window, @Nullable Integer type, boolean hasControlsChanged) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      WindowInfo windowInfo = checkNotNull(windows.get(window));
+      InsetsState insetsState = new InsetsState(windowInfo.insetsState);
+      // On R if we don't remove the sources that aren't changing we'll infinite loop when toggling
+      // visibility of multiple bars.
+      if (sdk == R && type != null) {
+        for (int i = 0; i < Shadow.<ShadowInsetsState>extract(insetsState).getSourceSize(); i++) {
+          if (i != type) {
+            insetsState.removeSource(i);
+          }
+        }
+      }
+      if ((sdk == R && !hasControlsChanged) || sdk >= S && sdk <= S_V2) {
+        ClassParameterBuilder params = new ClassParameterBuilder();
+        params.add(InsetsState.class, windowInfo.insetsState);
+        /* willMove */ params.addIf(sdk >= S, boolean.class, false);
+        /* willResize */ params.addIf(sdk >= S, boolean.class, false);
+        callInstanceMethod(window, "insetsChanged", params.build());
+      } else {
+        ClassParameterBuilder params = new ClassParameterBuilder();
+        params.add(InsetsState.class, windowInfo.insetsState);
+        // TODO: We should give control to the active window.
+        if (sdk >= VANILLA_ICE_CREAM) {
+          params.add(InsetsSourceControl.Array.class, new InsetsSourceControl.Array());
+        } else {
+          params.add(
+              InsetsSourceControl[].class,
+              windowInfo.hasInsetsControl ? populateInsetSourceControls(windowInfo, null) : null);
+        }
+        callInstanceMethod(window, "insetsControlChanged", params.build());
+      }
+    }
+
+    void sendResize(IWindow window) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      WindowInfo windowInfo = checkNotNull(windows.get(window));
+      configureWindowFrames(
+          windowInfo,
+          windowInfo.attrs,
+          /* requestedSize= */ null,
+          /* outFrame= */ null,
+          /* outContentInsets= */ null,
+          /* outVisibleInsets= */ null,
+          /* outStableInsets= */ null,
+          /* outInsetsState= */ null);
+      Configuration configuration =
+          RuntimeEnvironment.getApplication().getResources().getConfiguration();
+      ClassParameterBuilder args = new ClassParameterBuilder();
+
+      // The resized method has changed pretty much every other release, this is a canonicalize-d
+      // set of all the parameters it has ever taken.
+      if (sdk >= S) {
+        /* frames */ args.add(ClientWindowFrames.class, windowInfo.frames);
+      } else {
+        /* frame */ args.add(Rect.class, windowInfo.frame);
+        /* overscanInsets */ args.addIf(sdk <= Q, Rect.class, new Rect());
+        /* contentInsets */ args.add(Rect.class, windowInfo.contentInsets);
+        /* visibleInsets */ args.add(Rect.class, windowInfo.visibleInsets);
+        /* stableInsets */ args.add(Rect.class, windowInfo.stableInsets);
+        /* outsets */ args.addIf(sdk >= M && sdk <= Q, Rect.class, new Rect());
+      }
+      /* reportDraw */ args.add(boolean.class, false);
+      if (sdk <= N_MR1) {
+        /* newConfig */ args.add(Configuration.class, configuration);
+      } else {
+        /* newMergedConfiguration */ args.add(
+            MergedConfiguration.class, new MergedConfiguration(configuration));
+      }
+      /* backDropFrame */ args.addIf(sdk >= N && sdk <= R, Rect.class, new Rect());
+      if (sdk >= TIRAMISU) {
+        /* insetsState */ args.add(InsetsState.class, windowInfo.insetsState);
+      }
+      /* forceLayout */ args.addIf(sdk >= N, boolean.class, false);
+      /* alwaysConsumeNavBar */ args.addIf(sdk >= N, boolean.class, false);
+      /* displayId */ args.addIf(sdk >= O, int.class, windowInfo.displayId);
+      if (sdk >= P && sdk <= R) {
+        /* displayCutout */ args.add(
+            DisplayCutout.ParcelableWrapper.class, new DisplayCutout.ParcelableWrapper());
+      }
+      /* syncSeqId */ args.addIf(sdk >= TIRAMISU, int.class, 0);
+      /* resizeMode */ args.addIf(sdk == TIRAMISU, int.class, 0);
+      /* dragResizing */ args.addIf(sdk >= UPSIDE_DOWN_CAKE, boolean.class, false);
+      if (sdk > UPSIDE_DOWN_CAKE) {
+        /* activityWindowInfo */ args.add(ActivityWindowInfo.class, null);
+      }
+      callInstanceMethod(window, "resized", args.build());
+    }
+
+    private void transferWindowInsetsControlTo(WindowInfo windowInfo) {
+      // If we don't transfer the controls on R then windows conflict when their insets mismatch,
+      // resulting in infinite loops, and if no window has control then insets are not updated.
+      // TODO: This is almost certainly not the correct logic for determining which window has
+      //  control.
+      if (RuntimeEnvironment.getApiLevel() != R) {
+        return;
+      }
+      for (Entry<IWindow, WindowInfo> entry : windows.entrySet()) {
+        boolean hasControl = entry.getValue() == windowInfo;
+        if (entry.getValue().hasInsetsControl != hasControl) {
+          entry.getValue().hasInsetsControl = hasControl;
+          sendInsetsControlChanged(entry.getKey(), null, true);
+        }
+      }
+    }
+
+    @CanIgnoreReturnValue
+    private InsetsSourceControl[] populateInsetSourceControls(
+        WindowInfo windowInfo, InsetsSourceControl[] controls) {
+      int sdk = RuntimeEnvironment.getApiLevel();
+      // Skip bars after IME as they have the same public types as navigation/status bars and
+      // their visibility combines.
+      int lastControl = reflector(InsetsStateReflector.class).getImeType();
+      if (controls == null) {
+        controls = new InsetsSourceControl[lastControl + 1];
+      }
+      for (int i = 0; i <= lastControl; i++) {
+        ClassParameterBuilder params = new ClassParameterBuilder();
+        /* type */ params.add(int.class, i);
+        /* leash */ params.add(SurfaceControl.class, null);
+        /* surfacePosition */ params.add(Point.class, new Point());
+        /* insetsHint */ params.addIf(sdk >= S, Insets.class, Insets.of(0, 0, 0, 0));
+        controls[i] = callConstructor(InsetsSourceControl.class, params.build());
+        // Populate the same insets as we did controls, otherwise the insets controller can
+        // infinite loop as it sees the insets being added and removed every time.
+        Shadow.<ShadowInsetsState>extract(windowInfo.insetsState).getOrCreateSource(i);
+      }
+      return controls;
+    }
+  }
+
+  static final class WindowInfo {
+    final Rect displayFrame = new Rect();
+    final ClientWindowFrames frames;
+    final Rect frame;
+    final InsetsState insetsState =
+        RuntimeEnvironment.getApiLevel() >= Q ? new InsetsState() : null;
+    final Rect contentInsets = new Rect();
+    final Rect visibleInsets = new Rect();
+    final Rect stableInsets = new Rect();
+    final WindowManager.LayoutParams attrs = new WindowManager.LayoutParams();
+    int displayId = -1;
+    int requestedVisibleTypes = RuntimeEnvironment.getApiLevel() >= R ? systemBars() : 0;
+    boolean hasInsetsControl;
+
+    WindowInfo() {
+      if (RuntimeEnvironment.getApiLevel() >= S) {
+        frames = new ClientWindowFrames();
+        frame = frames.frame;
+      } else {
+        frames = null;
+        frame = new Rect();
+      }
+    }
+
+    void put(
+        Rect outFrame,
+        Rect outContentInsets,
+        Rect outVisibleInsets,
+        Rect outStableInsets,
+        InsetsState outInsetsState) {
+      if (outFrame != null) {
+        outFrame.set(frame);
+      }
+      if (outContentInsets != null) {
+        outContentInsets.set(contentInsets);
+      }
+      if (outVisibleInsets != null) {
+        outVisibleInsets.set(visibleInsets);
+      }
+      if (outStableInsets != null) {
+        outStableInsets.set(stableInsets);
+      }
+      if (outInsetsState != null) {
+        outInsetsState.set(insetsState, /* copySources= */ true);
+      }
+    }
+  }
+
+  private static <T> T findFirst(Class<T> type, Object[] args) {
+    return type.cast(stream(args).filter(type::isInstance).findFirst().get());
+  }
+
+  private static <T> T[] findAll(Class<T> type, Object[] args) {
+    return stream(args).filter(type::isInstance).toArray(len -> (T[]) Array.newInstance(type, len));
+  }
+
+  private static final class ClassParameterBuilder {
+    private final List<ClassParameter<?>> parameters = new ArrayList<>();
+
+    <T> void add(Class<T> type, T parameter) {
+      parameters.add(ClassParameter.from(type, parameter));
+    }
+
+    <T> void addIf(boolean shouldAdd, Class<T> type, T parameter) {
+      if (shouldAdd) {
+        add(type, parameter);
+      }
+    }
+
+    ClassParameter<?>[] build() {
+      return parameters.toArray(new ClassParameter<?>[0]);
+    }
   }
 
   @ForType(BackMotionEvent.class)
@@ -429,6 +893,21 @@ public class ShadowWindowManagerGlobal {
         boolean triggerBack,
         int swipeEdge,
         RemoteAnimationTarget departingAnimationTarget);
+
+    @Constructor
+    BackMotionEvent newBackMotionEventPostV(
+        float touchX,
+        float touchY,
+        long frameTime,
+        float progress,
+        boolean triggerBack,
+        int swipeEdge,
+        RemoteAnimationTarget departingAnimationTarget);
+  }
+
+  @ForType(className = "android.view.InsetsVisibilities")
+  interface InsetsVisibilitiesReflector {
+    boolean getVisibility(int type);
   }
 
   private static class BackMotionEvents {
@@ -436,37 +915,52 @@ public class ShadowWindowManagerGlobal {
 
     static BackMotionEvent newBackMotionEvent(
         @BackEvent.SwipeEdge int edge, float touchX, float touchY, float progress) {
-      if (RuntimeEnvironment.getApiLevel() >= UPSIDE_DOWN_CAKE) {
-        try {
-          return reflector(BackMotionEventReflector.class)
-              .newBackMotionEventV(
-                  touchX,
-                  touchY,
-                  progress,
-                  0f, // velocity x
-                  0f, // velocity y
-                  Boolean.FALSE, // trigger back
-                  edge, // swipe edge
-                  null);
-        } catch (Throwable t) {
-          if (NoSuchMethodException.class.isInstance(t) || AssertionError.class.isInstance(t)) {
-            // fall through, assuming (perhaps falsely?) this exception is thrown by reflector(),
-            // and not the method reflected in to.
-          } else {
-            if (RuntimeException.class.isInstance(t)) {
-              throw (RuntimeException) t;
-            } else {
-              throw new RuntimeException(t);
-            }
-          }
+      if (RuntimeEnvironment.getApiLevel() < VANILLA_ICE_CREAM) {
+        return reflector(BackMotionEventReflector.class)
+            .newBackMotionEvent(
+                touchX, touchY, progress, 0f, // velocity x
+                0f, // velocity y
+                edge, // swipe edge
+                null);
+      }
+      // normally we would consistently determine which constructor to call based on API level,
+      // but that is tricky for in development SDKS. So just determine
+      // what constructor to call based on the constructors we find reflectively
+      java.lang.reflect.Constructor<?> theConstructor = findPublicConstructor();
+      if (theConstructor.getParameterTypes()[2].equals(float.class)) {
+        return reflector(BackMotionEventReflector.class)
+            .newBackMotionEventV(
+                touchX,
+                touchY,
+                progress,
+                0f, // velocity x
+                0f, // velocity y
+                Boolean.FALSE, // trigger back
+                edge, // swipe edge
+                null);
+      } else if (theConstructor.getParameterTypes()[2].equals(long.class)) {
+        return reflector(BackMotionEventReflector.class)
+            .newBackMotionEventPostV(
+                touchX,
+                touchY,
+                SystemClock.uptimeMillis(), /* frameTime */
+                progress,
+                Boolean.FALSE, // trigger back
+                edge, // swipe edge
+                null);
+      } else {
+            throw new IllegalStateException("Could not find a BackMotionEvent constructor to call");
+      }
+    }
+
+    private static java.lang.reflect.Constructor<?> findPublicConstructor() {
+      for (java.lang.reflect.Constructor<?> constructor :
+          BackMotionEvent.class.getDeclaredConstructors()) {
+        if (constructor.getParameterCount() > 0 && Modifier.isPublic(constructor.getModifiers())) {
+          return constructor;
         }
       }
-      return reflector(BackMotionEventReflector.class)
-          .newBackMotionEvent(
-              touchX, touchY, progress, 0f, // velocity x
-              0f, // velocity y
-              edge, // swipe edge
-              null);
+      throw new IllegalStateException("Could not find a BackMotionEvent constructor");
     }
   }
 }
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
index bf54a5c14..562095409 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/ShadowWindowManagerImpl.java
@@ -10,6 +10,7 @@ import static org.robolectric.util.reflector.Reflector.reflector;
 import android.content.Context;
 import android.graphics.Insets;
 import android.graphics.Rect;
+import android.util.SparseIntArray;
 import android.view.Display;
 import android.view.DisplayCutout;
 import android.view.InsetsState;
@@ -82,13 +83,13 @@ public class ShadowWindowManagerImpl extends ShadowWindowManager {
           insetsState,
           "calculateInsets",
           ClassParameter.from(Rect.class, bounds),
-          null,
+          ClassParameter.from(InsetsState.class, null),
           ClassParameter.from(Boolean.TYPE, isScreenRound),
           ClassParameter.from(Boolean.TYPE, alwaysConsumeSystemBars),
-          ClassParameter.from(DisplayCutout.ParcelableWrapper.class, displayCutout.get()),
+          ClassParameter.from(DisplayCutout.class, displayCutout.get()),
           ClassParameter.from(int.class, SOFT_INPUT_ADJUST_NOTHING),
           ClassParameter.from(int.class, SYSTEM_UI_FLAG_VISIBLE),
-          null);
+          ClassParameter.from(SparseIntArray.class, null));
     } else {
       return new WindowInsets.Builder()
           .setAlwaysConsumeSystemBars(alwaysConsumeSystemBars)
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/SystemUi.java b/shadows/framework/src/main/java/org/robolectric/shadows/SystemUi.java
new file mode 100644
index 000000000..49711b383
--- /dev/null
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/SystemUi.java
@@ -0,0 +1,534 @@
+package org.robolectric.shadows;
+
+import static android.os.Build.VERSION_CODES.R;
+import static java.lang.Math.max;
+import static java.lang.Math.round;
+
+import android.graphics.Rect;
+import android.hardware.display.DisplayManagerGlobal;
+import android.util.DisplayMetrics;
+import android.view.Display;
+import android.view.DisplayInfo;
+import android.view.InsetsState;
+import android.view.Surface;
+import android.view.View;
+import android.view.WindowInsets;
+import android.view.WindowManager;
+import com.google.common.collect.ImmutableList;
+import java.util.ArrayList;
+import java.util.List;
+import javax.annotation.Nonnull;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.shadow.api.Shadow;
+import org.robolectric.shadows.ShadowWindowManagerGlobal.WindowInfo;
+import org.robolectric.shadows.SystemUi.SystemBar.Side;
+
+/**
+ * State holder for the Android system UI.
+ *
+ * <p>The system UI is configured per display and the system UI can be retrieved for the default
+ * display using {@link #systemUiForDefaultDisplay()} or for a display identified by its ID using
+ * {@link #systemUiForDisplay(int)}.
+ *
+ * <p>For backwards compatibility with previous Robolectric versions by default the system UIs are
+ * configured with no status bar or navigation insets, to apply a "standard" phone setup configure a
+ * status bar and navigation bar behavior e.g. in your test setup:
+ *
+ * <pre>{@code
+ * systemUiForDefaultDisplay()
+ *     .setBehavior(SystemUi.STANDARD_STATUS_BAR, SystemUi.GESTURAL_NAVIGATION);
+ * }</pre>
+ *
+ * <p>{@link SystemUi} includes the most common Android system UI behaviors including:
+ *
+ * <ul>
+ *   <li>{@link #NO_STATUS_BAR} - The default, no status bar insets reserved.
+ *   <li>{@link #STANDARD_STATUS_BAR} - A standard status bar that grows if a top cutout is present.
+ *   <li>{@link #GESTURAL_NAVIGATION} - Standard gestural navigation with bottom inset and gestural
+ *       areas on the bottom and sides of the screen.
+ *   <li>{@link #THREE_BUTTON_NAVIGATION} - Standard three button navigation bar that aligns to the
+ *       bottom of the screen, and on smaller screens moves to the sides when rotated.
+ *   <li>{@link #GESTURAL_NAVIGATION} - Standard two button navigation bar with similar alignment to
+ *       the three button bar but also reserves a gestural area at the bottom of the screen.
+ * </ul>
+ *
+ * <p>It's recommended to use the predefined behaviors which attempt to align with real Android
+ * behavior, but if necessary custom system bar and navigation bar behaviors can be defined by
+ * implementing the {@link StatusBarBehavior} and {@link NavigationBarBehavior} interfaces
+ * respectively.
+ */
+// TODO: Make public when we're happy with the implementation/api/behavior
+final class SystemUi {
+  /** Default status bar behavior which renders a 0 height status bar. */
+  public static final StatusBarBehavior NO_STATUS_BAR = new NoStatusBarBehavior();
+
+  /** Standard Android status bar behavior which behaves similarly to real Android. */
+  public static final StatusBarBehavior STANDARD_STATUS_BAR = new StandardStatusBarBehavior();
+
+  /** Default navigation bar behavior which renders a 0 height navigation bar. */
+  public static final NavigationBarBehavior NO_NAVIGATION_BAR = new NoNavigationBarBehavior();
+
+  /** Standard Android gestural navigation bar behavior. */
+  public static final NavigationBarBehavior GESTURAL_NAVIGATION =
+      new GesturalNavigationBarBehavior();
+
+  /** Standard Android three button navigation bar behavior. */
+  public static final NavigationBarBehavior THREE_BUTTON_NAVIGATION =
+      new ButtonNavigationBarBehavior();
+
+  private final int displayId;
+  private final StatusBar statusBar;
+  private final NavigationBar navigationBar;
+  private final ImmutableList<SystemBar> systemsBars;
+
+  interface OnChangeListener {
+    void onChange();
+  }
+
+  private final List<OnChangeListener> listeners = new ArrayList<>();
+
+  /** Returns the {@link SystemUi} for the default display. */
+  public static SystemUi systemUiForDefaultDisplay() {
+    return systemUiForDisplay(Display.DEFAULT_DISPLAY);
+  }
+
+  /** Returns the {@link SystemUi} for the given display. */
+  public static SystemUi systemUiForDisplay(int displayId) {
+    return Shadow.<ShadowDisplayManagerGlobal>extract(DisplayManagerGlobal.getInstance())
+        .getSystemUi(displayId);
+  }
+
+  SystemUi(int displayId) {
+    this.displayId = displayId;
+    statusBar = new StatusBar(displayId);
+    navigationBar = new NavigationBar(displayId);
+    systemsBars = ImmutableList.of(statusBar, navigationBar);
+  }
+
+  int getDisplayId() {
+    return displayId;
+  }
+
+  void addListener(OnChangeListener listener) {
+    listeners.add(listener);
+  }
+
+  public StatusBar getStatusBar() {
+    return statusBar;
+  }
+
+  /** Returns the status bar behavior. The default status bar behavior is {@link #NO_STATUS_BAR}. */
+  public StatusBarBehavior getStatusBarBehavior() {
+    return statusBar.getBehavior();
+  }
+
+  /**
+   * Sets the status bar behavior.
+   *
+   * <p>The default behavior is {@link #NO_STATUS_BAR}, use {@link #STANDARD_STATUS_BAR} for a
+   * standard Android status bar behavior.
+   */
+  public void setStatusBarBehavior(StatusBarBehavior statusBarBehavior) {
+    statusBar.setBehavior(statusBarBehavior);
+  }
+
+  public NavigationBar getNavigationBar() {
+    return navigationBar;
+  }
+
+  /**
+   * Returns the navigation bar behavior. The default navigation bar behavior is {@link
+   * #NO_NAVIGATION_BAR}.
+   */
+  public NavigationBarBehavior getNavigationBarBehavior() {
+    return navigationBar.getBehavior();
+  }
+
+  /**
+   * Sets the navigation bar behavior.
+   *
+   * <p>The default behavior is {@link #NO_NAVIGATION_BAR}, use {@link #GESTURAL_NAVIGATION} or
+   * {@link #THREE_BUTTON_NAVIGATION} for a standard on screen Android navigation bar behavior.
+   */
+  public void setNavigationBarBehavior(NavigationBarBehavior statusBarBehavior) {
+    navigationBar.setBehavior(statusBarBehavior);
+  }
+
+  public void setBehavior(
+      StatusBarBehavior statusBarBehavior, NavigationBarBehavior navigationBarBehavior) {
+    setStatusBarBehavior(statusBarBehavior);
+    setNavigationBarBehavior(navigationBarBehavior);
+  }
+
+  @SuppressWarnings("deprecation") // Back compat support for system ui visibility
+  void adjustFrameForInsets(WindowManager.LayoutParams attrs, Rect outFrame) {
+    boolean hideStatusBar;
+    boolean hideNavigationBar;
+    if (RuntimeEnvironment.getApiLevel() >= R) {
+      hideStatusBar = (attrs.getFitInsetsTypes() & WindowInsets.Type.statusBars()) != 0;
+      hideNavigationBar = (attrs.getFitInsetsTypes() & WindowInsets.Type.navigationBars()) != 0;
+    } else {
+      int systemUiVisibility = attrs.systemUiVisibility | attrs.subtreeSystemUiVisibility;
+      hideStatusBar =
+          (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) == 0
+              && (attrs.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN) == 0
+              && (attrs.flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0;
+      hideNavigationBar =
+          (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) == 0
+              && (attrs.flags & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0;
+    }
+    if (hideStatusBar) {
+      statusBar.insetFrame(outFrame);
+    }
+    if (hideNavigationBar) {
+      navigationBar.insetFrame(outFrame);
+    }
+  }
+
+  void putInsets(WindowInfo windowInfo) {
+    putInsets(windowInfo, windowInfo.contentInsets, /* includeNotVisible= */ false);
+    putInsets(windowInfo, windowInfo.visibleInsets, /* includeNotVisible= */ false);
+    putInsets(windowInfo, windowInfo.stableInsets, /* includeNotVisible= */ true);
+    if (windowInfo.insetsState != null) {
+      putInsetsState(windowInfo, windowInfo.insetsState);
+    }
+  }
+
+  private void putInsets(WindowInfo info, Rect outInsets, boolean includeNotVisible) {
+    outInsets.set(0, 0, 0, 0);
+    for (SystemBar bar : systemsBars) {
+      if (includeNotVisible || bar.isVisible()) {
+        bar.putInsets(info.displayFrame, info.frame, outInsets);
+      }
+    }
+  }
+
+  private void putInsetsState(WindowInfo info, InsetsState outInsetsState) {
+    outInsetsState.setDisplayFrame(info.frame);
+    ShadowInsetsState outShadowInsetsState = Shadow.extract(outInsetsState);
+    for (SystemBar bar : systemsBars) {
+      Shadow.<ShadowInsetsSource>extract(outShadowInsetsState.getOrCreateSource(bar.getId()))
+          .setFrame(bar.inFrame(info.displayFrame, info.frame))
+          .setVisible(bar.isVisible());
+    }
+  }
+
+  private static int dpToPx(int px, int displayId) {
+    return dpToPx(px, DisplayManagerGlobal.getInstance().getDisplayInfo(displayId));
+  }
+
+  private static int dpToPx(int px, DisplayInfo displayInfo) {
+    float density = displayInfo.logicalDensityDpi / (float) DisplayMetrics.DENSITY_DEFAULT;
+    return round(density * px);
+  }
+
+  /**
+   * Base interface for behavior for a system bar such as status bar or navigation bar. See the
+   * specific interfaces {@link StatusBarBehavior} and {@link NavigationBarBehavior}.
+   */
+  public interface SystemBarBehavior {
+    /**
+     * Returns which side of the screen this system bar should be attached to when rendered on the
+     * given display ID. The implementation may look up the size of the display to determine the
+     * side.
+     */
+    Side calculateSide(int displayId);
+
+    /**
+     * Returns the size of the this system bar when rendered on the given display ID. This is either
+     * the height or the width based on the return value from {@link #calculateSide(int)}. The
+     * implementation may look up the size of the display to determine the side.
+     */
+    int calculateSize(int displayId);
+  }
+
+  /**
+   * Interface for status bar behavior. See {@link #STANDARD_STATUS_BAR} and {@link #NO_STATUS_BAR}
+   * for default implementations. Custom status bar behavior can be provided by implementing this
+   * interface and calling {@link SystemUi#setStatusBarBehavior(StatusBarBehavior)}.
+   */
+  public interface StatusBarBehavior extends SystemBarBehavior {}
+
+  /**
+   * Interface for navigation bar behavior. See {@link #GESTURAL_NAVIGATION}, {@link
+   * #THREE_BUTTON_NAVIGATION}, and {@link #NO_NAVIGATION_BAR} for default implementations. Custom
+   * status bar behavior can be provided by implementing this interface and calling {@link
+   * SystemUi#setNavigationBarBehavior(NavigationBarBehavior)}.
+   */
+  public interface NavigationBarBehavior extends SystemBarBehavior {}
+
+  /** Base class for a system bar. See {@link StatusBar} and {@link NavigationBar}. */
+  public abstract static class SystemBar {
+    /** Side of the screen a system bar is attached to. */
+    public enum Side {
+      LEFT,
+      TOP,
+      RIGHT,
+      BOTTOM
+    }
+
+    SystemBar() {}
+
+    abstract int getId();
+
+    /** Returns which side of the screen this bar is attached to. */
+    public abstract Side getSide();
+
+    /**
+     * Returns the size of this status bar. Depending on which side of the screen the bar is
+     * attached to this is either the height (for top and bottom) or width (for left or right).
+     */
+    public abstract int getSize();
+
+    /**
+     * Returns true if this status bar is currently visible. Note that this is still tracked even if
+     * the status bar has 0 size.
+     */
+    public abstract boolean isVisible();
+
+    void insetFrame(Rect outFrame) {
+      switch (getSide()) {
+        case LEFT:
+          outFrame.left += getSize();
+          break;
+        case TOP:
+          outFrame.top += getSize();
+          break;
+        case RIGHT:
+          outFrame.right -= getSize();
+          break;
+        case BOTTOM:
+          outFrame.bottom -= getSize();
+          break;
+      }
+    }
+
+    Rect inFrame(Rect displayFrame, Rect frame) {
+      switch (getSide()) {
+        case LEFT:
+          return new Rect(0, 0, max(0, getSize() - frame.left), frame.bottom);
+        case TOP:
+          return new Rect(0, 0, frame.right, max(0, getSize() - frame.top));
+        case RIGHT:
+          int rightSize = max(0, getSize() - (displayFrame.right - frame.right));
+          return new Rect(frame.right - rightSize, 0, frame.right, frame.bottom);
+        case BOTTOM:
+          int bottomSize = max(0, getSize() - (displayFrame.bottom - frame.bottom));
+          return new Rect(0, frame.bottom - bottomSize, frame.right, frame.bottom);
+      }
+      throw new IllegalStateException();
+    }
+
+    void putInsets(Rect displayFrame, Rect frame, Rect insets) {
+      switch (getSide()) {
+        case LEFT:
+          insets.left = max(insets.left, getSize() - frame.left);
+          break;
+        case TOP:
+          insets.top = max(insets.top, getSize() - frame.top);
+          break;
+        case RIGHT:
+          insets.right = max(insets.right, getSize() - (displayFrame.right - frame.right));
+          break;
+        case BOTTOM:
+          insets.bottom = max(insets.bottom, getSize() - (displayFrame.bottom - frame.bottom));
+          break;
+      }
+    }
+  }
+
+  /** Represents the system status bar. */
+  public static final class StatusBar extends SystemBar {
+    private final int displayId;
+    private StatusBarBehavior behavior = NO_STATUS_BAR;
+    private boolean isVisible = true;
+
+    StatusBar(int displayId) {
+      this.displayId = displayId;
+    }
+
+    @Override
+    int getId() {
+      return ShadowInsetsState.STATUS_BARS;
+    }
+
+    StatusBarBehavior getBehavior() {
+      return behavior;
+    }
+
+    void setBehavior(StatusBarBehavior behavior) {
+      this.behavior = behavior;
+    }
+
+    @Override
+    public boolean isVisible() {
+      return isVisible;
+    }
+
+    boolean setVisible(boolean isVisible) {
+      boolean didChange = this.isVisible != isVisible;
+      this.isVisible = isVisible;
+      return didChange;
+    }
+
+    @Override
+    public Side getSide() {
+      return behavior.calculateSide(displayId);
+    }
+
+    @Override
+    public int getSize() {
+      return behavior.calculateSize(displayId);
+    }
+
+    @Nonnull
+    @Override
+    public String toString() {
+      return "StatusBar{isVisible=" + isVisible + "}";
+    }
+  }
+
+  static final class NoStatusBarBehavior implements StatusBarBehavior {
+    @Override
+    public Side calculateSide(int displayId) {
+      return Side.TOP;
+    }
+
+    @Override
+    public int calculateSize(int displayId) {
+      return 0;
+    }
+  }
+
+  static final class StandardStatusBarBehavior implements StatusBarBehavior {
+    private static final int HEIGHT_DP = 24;
+
+    @Override
+    public Side calculateSide(int displayId) {
+      return Side.TOP;
+    }
+
+    @Override
+    public int calculateSize(int displayId) {
+      return dpToPx(HEIGHT_DP, displayId);
+    }
+  }
+
+  /** Represents the system navigation bar. */
+  public static final class NavigationBar extends SystemBar {
+    private final int displayId;
+    private NavigationBarBehavior behavior = NO_NAVIGATION_BAR;
+    private boolean isVisible = true;
+
+    NavigationBar(int displayId) {
+      this.displayId = displayId;
+    }
+
+    @Override
+    int getId() {
+      return ShadowInsetsState.NAVIGATION_BARS;
+    }
+
+    NavigationBarBehavior getBehavior() {
+      return behavior;
+    }
+
+    void setBehavior(NavigationBarBehavior behavior) {
+      this.behavior = behavior;
+    }
+
+    @Override
+    public boolean isVisible() {
+      return isVisible;
+    }
+
+    boolean setVisible(boolean isVisible) {
+      boolean didChange = this.isVisible != isVisible;
+      this.isVisible = isVisible;
+      return didChange;
+    }
+
+    @Override
+    public Side getSide() {
+      return behavior.calculateSide(displayId);
+    }
+
+    @Override
+    public int getSize() {
+      return behavior.calculateSize(displayId);
+    }
+
+    @Nonnull
+    @Override
+    public String toString() {
+      return "NavigationBar{isVisible=" + isVisible + "}";
+    }
+  }
+
+  private static class NoNavigationBarBehavior implements NavigationBarBehavior {
+    @Override
+    public Side calculateSide(int displayId) {
+      return Side.BOTTOM;
+    }
+
+    @Override
+    public int calculateSize(int displayId) {
+      return 0;
+    }
+  }
+
+  private static class GesturalNavigationBarBehavior implements NavigationBarBehavior {
+    private static final int HEIGHT_DP = 24;
+
+    @Override
+    public Side calculateSide(int displayId) {
+      return Side.BOTTOM;
+    }
+
+    @Override
+    public int calculateSize(int displayId) {
+      return dpToPx(HEIGHT_DP, displayId);
+    }
+  }
+
+  private static class ButtonNavigationBarBehavior implements NavigationBarBehavior {
+    private static final int BOTTOM_HEIGHT_DP = 48;
+    private static final int SIDE_HEIGHT_DP = 42;
+    private static final int LARGE_SCREEN_DP = 600;
+    private static final int LARGE_SCREEN_HEIGHT_DP = 56;
+
+    @Override
+    public Side calculateSide(int displayId) {
+      return calculateSide(DisplayManagerGlobal.getInstance().getDisplayInfo(displayId));
+    }
+
+    private Side calculateSide(DisplayInfo info) {
+      if (isLargeScreen(info)) {
+        return Side.BOTTOM;
+      } else {
+        switch (info.rotation) {
+          case Surface.ROTATION_90:
+            return Side.LEFT;
+          case Surface.ROTATION_180:
+            return Side.RIGHT;
+          default:
+            return Side.BOTTOM;
+        }
+      }
+    }
+
+    @Override
+    public int calculateSize(int displayId) {
+      DisplayInfo displayInfo = DisplayManagerGlobal.getInstance().getDisplayInfo(displayId);
+      int sizeDp =
+          isLargeScreen(displayInfo)
+              ? LARGE_SCREEN_HEIGHT_DP
+              : (calculateSide(displayInfo) == Side.BOTTOM ? BOTTOM_HEIGHT_DP : SIDE_HEIGHT_DP);
+      return dpToPx(sizeDp, displayInfo);
+    }
+
+    private boolean isLargeScreen(DisplayInfo info) {
+      return max(info.logicalWidth, info.logicalHeight) >= dpToPx(LARGE_SCREEN_DP, info);
+    }
+  }
+}
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java b/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
index 37b3f8d65..0df6d0f87 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/WifiUsabilityStatsEntryBuilder.java
@@ -1,5 +1,6 @@
 package org.robolectric.shadows;
 
+
 import android.net.wifi.WifiUsabilityStatsEntry;
 import android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
 import android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
@@ -9,6 +10,7 @@ import android.util.SparseArray;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.util.ReflectionHelpers;
 import org.robolectric.util.ReflectionHelpers.ClassParameter;
+import org.robolectric.versioning.AndroidVersions.Baklava;
 
 /** Builder for {@link WifiUsabilityStatsEntry}. */
 public class WifiUsabilityStatsEntryBuilder {
@@ -76,6 +78,65 @@ public class WifiUsabilityStatsEntryBuilder {
           ClassParameter.from(int.class, cellularSignalStrengthDbm),
           ClassParameter.from(int.class, cellularSignalStrengthDb),
           ClassParameter.from(boolean.class, isSameRegisteredCell));
+    } else if (RuntimeEnvironment.getApiLevel() >= Baklava.SDK_INT) {
+      return ReflectionHelpers.callConstructor(
+          WifiUsabilityStatsEntry.class,
+          ClassParameter.from(long.class, timeStampMillis),
+          ClassParameter.from(int.class, rssi),
+          ClassParameter.from(int.class, linkSpeedMbps),
+          ClassParameter.from(long.class, totalTxSuccess),
+          ClassParameter.from(long.class, totalTxRetries),
+          ClassParameter.from(long.class, totalTxBad),
+          ClassParameter.from(long.class, totalRxSuccess),
+          ClassParameter.from(long.class, totalRadioOnTimeMillis),
+          ClassParameter.from(long.class, totalRadioTxTimeMillis),
+          ClassParameter.from(long.class, totalRadioRxTimeMillis),
+          ClassParameter.from(long.class, totalScanTimeMillis),
+          ClassParameter.from(long.class, totalNanScanTimeMillis),
+          ClassParameter.from(long.class, totalBackgroundScanTimeMillis),
+          ClassParameter.from(long.class, totalRoamScanTimeMillis),
+          ClassParameter.from(long.class, totalPnoScanTimeMillis),
+          ClassParameter.from(long.class, totalHotspot2ScanTimeMillis),
+          ClassParameter.from(long.class, totalCcaBusyFreqTimeMillis),
+          ClassParameter.from(long.class, totalRadioOnFreqTimeMillis),
+          ClassParameter.from(long.class, totalBeaconRx),
+          ClassParameter.from(int.class, probeStatusSinceLastUpdate),
+          ClassParameter.from(int.class, probeElapsedTimeSinceLastUpdateMillis),
+          ClassParameter.from(int.class, probeMcsRateSinceLastUpdate),
+          ClassParameter.from(int.class, rxLinkSpeedMbps),
+          ClassParameter.from(int.class, timeSliceDutyCycleInPercent),
+          ClassParameter.from(ContentionTimeStats[].class, new ContentionTimeStats[] {}),
+          ClassParameter.from(RateStats[].class, new RateStats[] {}),
+          ClassParameter.from(RadioStats[].class, new RadioStats[] {}),
+          ClassParameter.from(int.class, CHANNEL_UTILIZATION_RATIO),
+          ClassParameter.from(boolean.class, isThroughputSufficient),
+          ClassParameter.from(boolean.class, isWifiScoringEnabled),
+          ClassParameter.from(boolean.class, isCellularDataAvailable),
+          ClassParameter.from(int.class, cellularDataNetworkType),
+          ClassParameter.from(int.class, cellularSignalStrengthDbm),
+          ClassParameter.from(int.class, cellularSignalStrengthDb),
+          ClassParameter.from(boolean.class, isSameRegisteredCell),
+          ClassParameter.from(SparseArray.class, new SparseArray<>()),
+          /* new in post V */
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(long.class, 0),
+          ClassParameter.from(long.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(boolean.class, false),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(boolean.class, false),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0),
+          ClassParameter.from(int.class, 0)
+          /* end new in post V */
+          );
     } else if (RuntimeEnvironment.getApiLevel() > VERSION_CODES.TIRAMISU) {
       return ReflectionHelpers.callConstructor(
           WifiUsabilityStatsEntry.class,
diff --git a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
index bcc680bd8..9c25209e8 100644
--- a/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
+++ b/shadows/framework/src/main/java/org/robolectric/shadows/_Activity_.java
@@ -163,6 +163,7 @@ public interface _Activity_ {
       CharSequence activityTitle,
       @WithType("android.app.Activity$NonConfigurationInstances")
           Object lastNonConfigurationInstances) {
+    Configuration config = new Configuration(application.getResources().getConfiguration());
     int apiLevel = RuntimeEnvironment.getApiLevel();
     if (apiLevel == Build.VERSION_CODES.LOLLIPOP) {
       attach(
@@ -178,7 +179,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           null);
     } else if (apiLevel <= Build.VERSION_CODES.M) {
       attach(
@@ -194,7 +195,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           "referrer",
           null);
     } else if (apiLevel <= Build.VERSION_CODES.N_MR1) {
@@ -211,7 +212,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           "referrer",
           null,
           null);
@@ -229,7 +230,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           "referrer",
           null,
           null,
@@ -248,7 +249,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           "referrer",
           null,
           null,
@@ -268,7 +269,7 @@ public interface _Activity_ {
           null,
           null,
           lastNonConfigurationInstances,
-          application.getResources().getConfiguration(),
+          config,
           "referrer",
           null,
           null,
diff --git a/shadows/httpclient/build.gradle b/shadows/httpclient/build.gradle
deleted file mode 100644
index f58bdb5cc..000000000
--- a/shadows/httpclient/build.gradle
+++ /dev/null
@@ -1,42 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.shadows)
-}
-
-shadows {
-    packageName "org.robolectric.shadows.httpclient"
-    sdkCheckMode "OFF"
-}
-
-configurations {
-    earlyRuntime
-}
-
-dependencies {
-    api project(":annotations")
-    api project(":shadowapi")
-    api project(":utils")
-
-    // We should keep httpclient version for low level API compatibility.
-    earlyRuntime libs.apache.http.core
-    api libs.apache.http.client
-    compileOnly(AndroidSdk.LOLLIPOP_MR1.coordinates)
-
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-    testImplementation "androidx.test.ext:junit:$axtJunitVersion@aar"
-
-    testCompileOnly(AndroidSdk.LOLLIPOP_MR1.coordinates)
-    testRuntimeOnly AndroidSdk.S.coordinates
-}
-
-// httpcore needs to come before android-all on runtime classpath; the gradle IntelliJ plugin
-//   needs the compileClasspath order patched too (bug?)
-sourceSets.main.compileClasspath = configurations.earlyRuntime + sourceSets.main.compileClasspath
-sourceSets.main.runtimeClasspath = configurations.earlyRuntime + sourceSets.main.runtimeClasspath
-
-sourceSets.test.compileClasspath = configurations.earlyRuntime + sourceSets.test.compileClasspath
-sourceSets.test.runtimeClasspath = configurations.earlyRuntime + sourceSets.test.runtimeClasspath
diff --git a/shadows/httpclient/build.gradle.kts b/shadows/httpclient/build.gradle.kts
new file mode 100644
index 000000000..35a4c8be7
--- /dev/null
+++ b/shadows/httpclient/build.gradle.kts
@@ -0,0 +1,47 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.shadows)
+}
+
+shadows {
+  packageName = "org.robolectric.shadows.httpclient"
+  sdkCheckMode = "OFF"
+}
+
+val earlyRuntime = configurations.create("earlyRuntime")
+val axtJunitVersion: String by rootProject.extra
+
+dependencies {
+  api(project(":annotations"))
+  api(project(":shadowapi"))
+  api(project(":utils"))
+
+  // We should keep httpclient version for low level API compatibility.
+  earlyRuntime(libs.apache.http.core)
+  api(libs.apache.http.client)
+  compileOnly(AndroidSdk.LOLLIPOP_MR1.coordinates)
+
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+  testImplementation("androidx.test.ext:junit:$axtJunitVersion@aar")
+
+  testCompileOnly(AndroidSdk.LOLLIPOP_MR1.coordinates)
+  testRuntimeOnly(AndroidSdk.S.coordinates)
+}
+
+// httpcore needs to come before android-all on runtime classpath; the gradle IntelliJ plugin
+//   needs the compileClasspath order patched too (bug?)
+val mainSourceSet = sourceSets.getByName("main")
+
+mainSourceSet.compileClasspath = earlyRuntime + mainSourceSet.compileClasspath
+
+mainSourceSet.runtimeClasspath = earlyRuntime + mainSourceSet.runtimeClasspath
+
+val testSourceSet = sourceSets.getByName("test")
+
+testSourceSet.compileClasspath = earlyRuntime + testSourceSet.compileClasspath
+
+testSourceSet.runtimeClasspath = earlyRuntime + testSourceSet.runtimeClasspath
diff --git a/shadows/multidex/build.gradle b/shadows/multidex/build.gradle
deleted file mode 100644
index 9cd79281f..000000000
--- a/shadows/multidex/build.gradle
+++ /dev/null
@@ -1,19 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.shadows)
-}
-
-shadows {
-    packageName "org.robolectric.shadows.multidex"
-    sdkCheckMode "OFF"
-}
-
-dependencies {
-    compileOnly project(":shadows:framework")
-    api project(":annotations")
-
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testImplementation project(":robolectric")
-}
diff --git a/shadows/multidex/build.gradle.kts b/shadows/multidex/build.gradle.kts
new file mode 100644
index 000000000..d3b9137ec
--- /dev/null
+++ b/shadows/multidex/build.gradle.kts
@@ -0,0 +1,19 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.shadows)
+}
+
+shadows {
+  packageName = "org.robolectric.shadows.multidex"
+  sdkCheckMode = "OFF"
+}
+
+dependencies {
+  compileOnly(project(":shadows:framework"))
+  api(project(":annotations"))
+
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testImplementation(project(":robolectric"))
+}
diff --git a/shadows/playservices/build.gradle b/shadows/playservices/build.gradle
deleted file mode 100644
index 4455c96ff..000000000
--- a/shadows/playservices/build.gradle
+++ /dev/null
@@ -1,31 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.shadows)
-}
-
-shadows {
-    packageName "org.robolectric.shadows.gms"
-    sdkCheckMode "OFF"
-}
-
-dependencies {
-    compileOnly project(":shadows:framework")
-    api project(":annotations")
-    api libs.guava
-
-    compileOnly libs.bundles.play.services.for.shadows
-
-    compileOnly AndroidSdk.MAX_SDK.coordinates
-
-    testCompileOnly AndroidSdk.MAX_SDK.coordinates
-    testCompileOnly libs.bundles.play.services.for.shadows
-
-    testImplementation project(":robolectric")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.mockito
-    testRuntimeOnly libs.bundles.play.services.for.shadows
-
-    testRuntimeOnly AndroidSdk.MAX_SDK.coordinates
-}
diff --git a/shadows/playservices/build.gradle.kts b/shadows/playservices/build.gradle.kts
new file mode 100644
index 000000000..a8b355192
--- /dev/null
+++ b/shadows/playservices/build.gradle.kts
@@ -0,0 +1,29 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.shadows)
+}
+
+shadows {
+  packageName = "org.robolectric.shadows.gms"
+  sdkCheckMode = "OFF"
+}
+
+dependencies {
+  compileOnly(project(":shadows:framework"))
+  api(project(":annotations"))
+  api(libs.guava)
+
+  compileOnly(libs.bundles.play.services.`for`.shadows)
+  compileOnly(AndroidSdk.MAX_SDK.coordinates)
+
+  testCompileOnly(AndroidSdk.MAX_SDK.coordinates)
+  testCompileOnly(libs.bundles.play.services.`for`.shadows)
+
+  testImplementation(project(":robolectric"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.mockito)
+  testRuntimeOnly(libs.bundles.play.services.`for`.shadows)
+  testRuntimeOnly(AndroidSdk.MAX_SDK.coordinates)
+}
diff --git a/testapp/build.gradle b/testapp/build.gradle
deleted file mode 100644
index 1911aad9a..000000000
--- a/testapp/build.gradle
+++ /dev/null
@@ -1,22 +0,0 @@
-plugins {
-    alias(libs.plugins.android.library)
-}
-
-android {
-    compileSdk 34
-    namespace 'org.robolectric.testapp'
-
-    defaultConfig {
-        minSdk 21
-        targetSdk 34
-        versionCode 1
-        versionName "1.0"
-
-        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-        vectorDrawables.useSupportLibrary = true
-    }
-
-    lintOptions {
-        abortOnError false
-    }
-}
diff --git a/testapp/build.gradle.kts b/testapp/build.gradle.kts
new file mode 100644
index 000000000..5daff99e8
--- /dev/null
+++ b/testapp/build.gradle.kts
@@ -0,0 +1,18 @@
+plugins { alias(libs.plugins.android.library) }
+
+android {
+  compileSdk = 34
+  namespace = "org.robolectric.testapp"
+
+  defaultConfig {
+    minSdk = 21
+
+    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+    vectorDrawables.useSupportLibrary = true
+  }
+
+  lint {
+    abortOnError = false
+    targetSdk = 34
+  }
+}
diff --git a/utils/build.gradle b/utils/build.gradle
deleted file mode 100644
index a655f9058..000000000
--- a/utils/build.gradle
+++ /dev/null
@@ -1,41 +0,0 @@
-import org.jetbrains.kotlin.gradle.dsl.JvmTarget
-
-plugins {
-    alias(libs.plugins.detekt)
-    alias(libs.plugins.kotlin.jvm)
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-    alias(libs.plugins.robolectric.spotless)
-}
-
-tasks.withType(GenerateModuleMetadata).configureEach {
-    // We don't want to release gradle module metadata now to avoid
-    // potential compatibility problems.
-    enabled = false
-}
-
-compileKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-compileTestKotlin {
-    compilerOptions.jvmTarget = JvmTarget.JVM_1_8
-}
-
-dependencies {
-    api project(":annotations")
-    api project(":pluginapi")
-    api libs.javax.inject
-    api libs.javax.annotation.api
-
-    compileOnly libs.findbugs.jsr305
-
-    testCompileOnly libs.auto.service.annotations
-    testAnnotationProcessor libs.auto.service
-    testAnnotationProcessor libs.error.prone.core
-    implementation libs.error.prone.annotations
-
-    testImplementation libs.junit4
-    testImplementation libs.truth
-    testImplementation libs.kotlin.stdlib
-}
diff --git a/utils/build.gradle.kts b/utils/build.gradle.kts
new file mode 100644
index 000000000..dab0ccc5c
--- /dev/null
+++ b/utils/build.gradle.kts
@@ -0,0 +1,37 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+
+plugins {
+  alias(libs.plugins.detekt)
+  alias(libs.plugins.kotlin.jvm)
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+  alias(libs.plugins.robolectric.spotless)
+}
+
+tasks.withType<GenerateModuleMetadata>().configureEach {
+  // We don't want to release Gradle module metadata now to avoid
+  // potential compatibility problems.
+  enabled = false
+}
+
+tasks.compileKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+tasks.compileTestKotlin.configure { compilerOptions.jvmTarget = JvmTarget.JVM_1_8 }
+
+dependencies {
+  api(project(":annotations"))
+  api(project(":pluginapi"))
+  api(libs.javax.inject)
+  api(libs.javax.annotation.api)
+
+  compileOnly(libs.findbugs.jsr305)
+
+  testCompileOnly(libs.auto.service.annotations)
+  testAnnotationProcessor(libs.auto.service)
+  testAnnotationProcessor(libs.error.prone.core)
+  implementation(libs.error.prone.annotations)
+
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+  testImplementation(libs.kotlin.stdlib)
+}
diff --git a/utils/reflector/build.gradle b/utils/reflector/build.gradle
deleted file mode 100644
index 5616aa6c4..000000000
--- a/utils/reflector/build.gradle
+++ /dev/null
@@ -1,15 +0,0 @@
-plugins {
-    alias(libs.plugins.robolectric.deployed.java.module)
-    alias(libs.plugins.robolectric.java.module)
-}
-
-dependencies {
-    api libs.asm
-    api libs.asm.commons
-    api libs.asm.util
-    api project(":utils")
-
-    testImplementation project(":shadowapi")
-    testImplementation libs.junit4
-    testImplementation libs.truth
-}
diff --git a/utils/reflector/build.gradle.kts b/utils/reflector/build.gradle.kts
new file mode 100644
index 000000000..2278f0b78
--- /dev/null
+++ b/utils/reflector/build.gradle.kts
@@ -0,0 +1,15 @@
+plugins {
+  alias(libs.plugins.robolectric.deployed.java.module)
+  alias(libs.plugins.robolectric.java.module)
+}
+
+dependencies {
+  api(libs.asm)
+  api(libs.asm.commons)
+  api(libs.asm.util)
+  api(project(":utils"))
+
+  testImplementation(project(":shadowapi"))
+  testImplementation(libs.junit4)
+  testImplementation(libs.truth)
+}
diff --git a/utils/src/main/java/org/robolectric/util/OsUtil.java b/utils/src/main/java/org/robolectric/util/OsUtil.java
new file mode 100644
index 000000000..4376fea94
--- /dev/null
+++ b/utils/src/main/java/org/robolectric/util/OsUtil.java
@@ -0,0 +1,27 @@
+package org.robolectric.util;
+
+import static com.google.common.base.StandardSystemProperty.OS_NAME;
+
+import java.util.Locale;
+
+/** OS-related utilities. */
+public class OsUtil {
+
+  private OsUtil() {}
+
+  public static boolean isMac() {
+    return osName().contains("mac");
+  }
+
+  public static boolean isWindows() {
+    return osName().contains("win");
+  }
+
+  public static boolean isLinux() {
+    return osName().contains("linux");
+  }
+
+  private static String osName() {
+    return OS_NAME.value().toLowerCase(Locale.ROOT);
+  }
+}
diff --git a/utils/src/main/java/org/robolectric/util/SimpleFuture.java b/utils/src/main/java/org/robolectric/util/SimpleFuture.java
deleted file mode 100644
index e27bf3692..000000000
--- a/utils/src/main/java/org/robolectric/util/SimpleFuture.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.robolectric.util;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A Future represents the result of an asynchronous computation.
- *
- * @param <T> The result type returned by this Future's get method.
- * @deprecated This class can introduce deadlocks, since its lock is held while invoking run().
- */
-@Deprecated
-public class SimpleFuture<T> {
-  private T result;
-  private boolean hasRun;
-  private boolean cancelled;
-  private final Callable<T> callable;
-
-  public SimpleFuture(Callable<T> callable) {
-    this.callable = callable;
-  }
-
-  public boolean isCancelled() {
-    return cancelled;
-  }
-
-  public boolean cancel(boolean mayInterruptIfRunning) {
-    if (!hasRun) {
-      cancelled = true;
-      done();
-    }
-
-    return cancelled;
-  }
-
-  public synchronized T get() throws InterruptedException {
-    if (cancelled) {
-      throw new CancellationException();
-    } else {
-      while (!hasRun) this.wait();
-      return result;
-    }
-  }
-
-  public synchronized T get(long timeout, TimeUnit unit) throws InterruptedException {
-    if (cancelled) {
-      throw new CancellationException();
-    } else {
-      while (!hasRun) this.wait(unit.toMillis(timeout));
-      return result;
-    }
-  }
-
-  public synchronized void run() {
-    try {
-      if (!cancelled) {
-        result = callable.call();
-        hasRun = true;
-        done();
-      }
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-
-    this.notify();
-  }
-
-  protected void done() {}
-}
diff --git a/utils/src/main/java/org/robolectric/util/TempDirectory.java b/utils/src/main/java/org/robolectric/util/TempDirectory.java
index cffcbcb59..7564ec2c1 100644
--- a/utils/src/main/java/org/robolectric/util/TempDirectory.java
+++ b/utils/src/main/java/org/robolectric/util/TempDirectory.java
@@ -15,7 +15,6 @@ import java.nio.file.SimpleFileVisitor;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.Locale;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -45,7 +44,7 @@ public class TempDirectory {
       Collections.synchronizedSet(new HashSet<>());
 
   static {
-    if (isWindows()) {
+    if (OsUtil.isWindows()) {
       TempDirectory.findObsoleteWindowsTempDirectoriesInBackground();
     }
   }
@@ -86,7 +85,7 @@ public class TempDirectory {
         deletionExecutorService.execute(undeletedDirectory::destroy);
       }
     }
-    if (isWindows()) {
+    if (OsUtil.isWindows()) {
       synchronized (obsoleteTempDirectoriesToDelete) {
         for (Path obsoletePath : obsoleteTempDirectoriesToDelete) {
           deletionExecutorService.execute(() -> destroyObsoleteTempDirectory(obsoletePath));
@@ -141,7 +140,7 @@ public class TempDirectory {
       clearDirectory(basePath);
       Files.delete(basePath);
     } catch (IOException e) {
-      if (isWindows()) {
+      if (OsUtil.isWindows()) {
         // Windows is much more protective of files that have been opened in native code. For
         // instance, unlike in Mac and Linux, it's not possible to delete nativeruntime files
         // (dlls, fonts, icu data) in the same process where they were opened. Because of
@@ -162,7 +161,8 @@ public class TempDirectory {
           public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
               throws IOException {
             // Avoid deleting the obsolete temp directory marker
-            if (!(isWindows() && file.getFileName().toString().equals(OBSOLETE_MARKER_FILE_NAME))) {
+            if (!(OsUtil.isWindows()
+                && file.getFileName().toString().equals(OBSOLETE_MARKER_FILE_NAME))) {
               Files.delete(file);
             }
             return FileVisitResult.CONTINUE;
@@ -178,10 +178,6 @@ public class TempDirectory {
         });
   }
 
-  private static boolean isWindows() {
-    return System.getProperty("os.name").toLowerCase(Locale.US).contains("win");
-  }
-
   private static void findObsoleteWindowsTempDirectoriesInBackground() {
     Thread thread = new Thread(TempDirectory::collectObsoleteWindowsTempDirectories);
     thread.setDaemon(true);
diff --git a/utils/src/main/java/org/robolectric/util/TimeUtils.java b/utils/src/main/java/org/robolectric/util/TimeUtils.java
deleted file mode 100644
index ad182bac8..000000000
--- a/utils/src/main/java/org/robolectric/util/TimeUtils.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package org.robolectric.util;
-
-/** Utility methods for dealing with time. */
-public class TimeUtils {
-  public static final long NANOS_PER_MS = 1000000;
-}
diff --git a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
index 22549e009..f3ed5f14f 100644
--- a/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
+++ b/utils/src/main/java/org/robolectric/util/inject/PluginFinder.java
@@ -76,17 +76,17 @@ class PluginFinder {
   }
 
   private <T> Iterable<Class<? extends T>> filter(Iterable<Class<? extends T>> classes) {
-    Set<Class<?>> superceded = new HashSet<>();
+    Set<Class<?>> superseded = new HashSet<>();
     for (Class<? extends T> clazz : classes) {
-      Supercedes supercedes = clazz.getAnnotation(Supercedes.class);
-      if (supercedes != null) {
-        superceded.add(supercedes.value());
+      Supersedes supersedes = clazz.getAnnotation(Supersedes.class);
+      if (supersedes != null) {
+        superseded.add(supersedes.value());
       }
     }
-    if (superceded.isEmpty()) {
+    if (superseded.isEmpty()) {
       return classes;
     } else {
-      return () -> new Filterator<>(classes.iterator(), o -> !superceded.contains(o));
+      return () -> new Filterator<>(classes.iterator(), o -> !superseded.contains(o));
     }
   }
 
diff --git a/utils/src/main/java/org/robolectric/util/inject/Supercedes.java b/utils/src/main/java/org/robolectric/util/inject/Supersedes.java
similarity index 93%
rename from utils/src/main/java/org/robolectric/util/inject/Supercedes.java
rename to utils/src/main/java/org/robolectric/util/inject/Supersedes.java
index d57e58e3f..67efb67fb 100644
--- a/utils/src/main/java/org/robolectric/util/inject/Supercedes.java
+++ b/utils/src/main/java/org/robolectric/util/inject/Supersedes.java
@@ -10,7 +10,7 @@ import java.lang.annotation.Target;
 @Documented
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
-public @interface Supercedes {
+public @interface Supersedes {
 
   /** The type that is superceded by the annotated type. */
   Class<?> value();
diff --git a/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt b/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
index a1da07d95..4336c95fa 100644
--- a/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
+++ b/utils/src/test/java/org/robolectric/util/inject/PluginFinderTest.kt
@@ -70,11 +70,11 @@ class PluginFinderTest {
 
   @Test
   @Throws(Exception::class)
-  fun findPlugins_whenAnnotatedSupercedes_shouldExcludeSuperceded() {
+  fun findPlugins_whenAnnotatedSupersedes_shouldExcludeSuperseded() {
     pluginClasses.addAll(
       listOf(
         ImplMinus1::class.java,
-        ImplZeroXSupercedesA::class.java,
+        ImplZeroXSupersedesA::class.java,
         ImplZeroA::class.java,
         ImplOne::class.java,
         ImplZeroB::class.java,
@@ -85,7 +85,7 @@ class PluginFinderTest {
       .containsExactly(
         ImplOne::class.java,
         ImplZeroB::class.java,
-        ImplZeroXSupercedesA::class.java,
+        ImplZeroXSupersedesA::class.java,
         ImplMinus1::class.java,
       )
       .inOrder()
@@ -100,7 +100,7 @@ class PluginFinderTest {
 
   @Priority(1) private class ImplOne : Iface
 
-  @Supercedes(ImplZeroA::class) private class ImplZeroXSupercedesA : Iface
+  @Supersedes(ImplZeroA::class) private class ImplZeroXSupersedesA : Iface
 
   private interface Iface
 }
```

