```diff
diff --git a/Android.bp b/Android.bp
index f93f6a0d7..c66fd0cfe 100644
--- a/Android.bp
+++ b/Android.bp
@@ -2,6 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+package {
+    default_team: "trendy_team_desktop_hwsec",
+}
+
+team {
+    name: "trendy_team_desktop_hwsec",
+
+    // go/trendy/manage/engineers/5198716937273344
+    trendy_team_id: "5198716937273344",
+}
+
 cc_defaults {
     name: "gsctool_defaults",
     // cflags used are identical to those of extra/usb_updater/Makefile
@@ -40,7 +51,7 @@ cc_binary {
     defaults: ["gsctool_defaults"],
     srcs: [
         "extra/usb_updater/*.c",
-        "util/usb_if.c"
+        "util/usb_if.c",
     ],
     local_include_dirs: [
         "extra/usb_updater",
diff --git a/PRESUBMIT.cfg b/PRESUBMIT.cfg
index bd92c7ec6..aa66e94f9 100644
--- a/PRESUBMIT.cfg
+++ b/PRESUBMIT.cfg
@@ -1,3 +1,6 @@
+[Hook Scripts]
+usb_updater presubmit=./extra/usb_updater/presubmit_hook.sh ${PRESUBMIT_COMMIT} ${PRESUBMIT_FILES}
+
 [Hook Overrides]
 checkpatch_check: true
 signoff_check: false
diff --git a/boot_param/.gitignore b/boot_param/.gitignore
new file mode 100644
index 000000000..145467410
--- /dev/null
+++ b/boot_param/.gitignore
@@ -0,0 +1,4 @@
+*.o
+*.d
+test_boot_param
+test*.cbor
\ No newline at end of file
diff --git a/boot_param/Makefile b/boot_param/Makefile
new file mode 100644
index 000000000..84ca2003a
--- /dev/null
+++ b/boot_param/Makefile
@@ -0,0 +1,51 @@
+# Copyright 2024 The ChromiumOS Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+CC ?= gcc
+PROGRAM := test_boot_param
+LIBS    := -lcrypto
+CFLAGS  += -std=gnu99 \
+	-g \
+	-Wall \
+	-Werror \
+	-Wpointer-arith \
+	-Wcast-align \
+	-Wundef \
+	-Wsign-compare \
+	-Wredundant-decls \
+	-Wmissing-declarations
+RESULT_FILES := test_boot_param.cbor test_dice_chain.cbor
+PCR0_OPTION := normal
+PROGRAM_OPTIONS := $(RESULT_FILES) $(PCR0_OPTION)
+
+ifneq ($(DEBUG),)
+CFLAGS += -O0
+else
+CFLAGS += -O3
+endif
+
+ifneq ($(DICE_DEBUG),)
+CFLAGS += -DDICE_DEBUG
+endif
+
+all: test
+
+test: $(PROGRAM)
+	./$(PROGRAM) $(PROGRAM_OPTIONS)
+
+SOURCES := test.c boot_param.c boot_param_platform_host.c
+OBJS := $(patsubst %.c,%.o,$(SOURCES))
+DEPS := $(patsubst %.c,%.d,$(SOURCES))
+
+$(PROGRAM): $(OBJS) Makefile
+	$(CC) $(CFLAGS) $(OBJS) $(LDFLAGS) $(LIBS) -o $@
+
+%.o: %.c Makefile
+	$(CC) $(CFLAGS) $(CPPFLAGS) -c -MMD -MF $(basename $@).d -o $@ $<
+
+.PHONY: clean
+clean:
+	rm -rf $(PROGRAM) *~ *.o *.d $(RESULT_FILES)
+
+-include $(DEPS)
diff --git a/boot_param/boot_param.c b/boot_param/boot_param.c
new file mode 100644
index 000000000..adc92b1d9
--- /dev/null
+++ b/boot_param/boot_param.c
@@ -0,0 +1,939 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "cbor_boot_param.h"
+#include "cdi.h"
+#include "boot_param.h"
+#include "boot_param_platform.h"
+
+/* Common structure to build Sig_structure or DICE Handover structure
+ */
+
+/* Combined headers before cert payload (CWT claims) in DICE handover
+ */
+struct combined_hdr_s {
+	struct dice_cert_chain_hdr_s cert_chain;
+	struct cdi_cert_hdr_s cert;
+};
+
+union header_options_s {
+	uint8_t sig_struct[sizeof(struct combined_hdr_s)];
+	struct combined_hdr_s dice_handover;
+};
+
+/* We need the following to be able to fill CDIs in dice_handover_s::hdr
+ * before we temporarily use dice_handover_s::options.sig_struct to calc
+ * signature.
+ */
+_Static_assert(
+	sizeof(struct combined_hdr_s) >= sizeof(struct cdi_sig_struct_hdr_s)
+);
+
+struct dice_handover_s {
+	struct dice_handover_hdr_s hdr;
+	union header_options_s options;
+	struct cwt_claims_bstr_s payload;
+	struct cbor_bstr64_s signature;
+};
+_Static_assert(
+	sizeof(struct dice_handover_s) - sizeof(struct dice_handover_hdr_s) ==
+	DICE_CHAIN_SIZE
+);
+
+/* BootParam = {
+ *   1  : uint,               ; structure version (0)
+ *   2  : GSCBootParam,
+ *   3  : AndroidDiceHandover,
+ * }
+ */
+#define BOOT_PARAM_VERSION 0
+struct boot_param_s {
+	/* Map header: 3 entries */
+	uint8_t map_hdr;
+	/* 1. Version: uint(1, 0bytes) => uint(BOOT_PARAM_VERSION, 0bytes) */
+	uint8_t version_label;
+	uint8_t version;
+	/* 2. GSCBootParam: uint(2, 0bytes) => GSCBootParam */
+	uint8_t gsc_boot_param_label;
+	struct gsc_boot_param_s gsc_boot_param;
+	/* 3. AndroidDiceHandover: uint(3, 0bytes) => AndroidDiceHandover */
+	uint8_t dice_handover_label;
+	struct dice_handover_s dice_handover;
+};
+_Static_assert(sizeof(struct boot_param_s) == BOOT_PARAM_SIZE);
+
+/* Context to pass between functions that build the DICE handover structure
+ */
+struct dice_ctx_s {
+	struct boot_param_s output;
+	struct dice_config_s cfg;
+};
+
+/* PCR0 values for various modes - see go/pcr0-tpm2 */
+static const uint8_t kPcr0NormalMode[DIGEST_BYTES] = {
+	0x89, 0xEA, 0xF3, 0x51, 0x34, 0xB4, 0xB3, 0xC6,
+	0x49, 0xF4, 0x4C, 0x0C, 0x76, 0x5B, 0x96, 0xAE,
+	0xAB, 0x8B, 0xB3, 0x4E, 0xE8, 0x3C, 0xC7, 0xA6,
+	0x83, 0xC4, 0xE5, 0x3D, 0x15, 0x81, 0xC8, 0xC7
+};
+static const uint8_t kPcr0RecoveryNormalMode[DIGEST_BYTES] = {
+	0x9F, 0x9E, 0xA8, 0x66, 0xD3, 0xF3, 0x4F, 0xE3,
+	0xA3, 0x11, 0x2A, 0xE9, 0xCB, 0x1F, 0xBA, 0xBC,
+	0x6F, 0xFE, 0x8C, 0xD2, 0x61, 0xD4, 0x24, 0x93,
+	0xBC, 0x68, 0x42, 0xA9, 0xE4, 0xF9, 0x3B, 0x3D
+};
+
+/* Const salts - see go/gsc-dice */
+static const uint8_t kIdSalt[64] = {
+	0xDB, 0xDB, 0xAE, 0xBC, 0x80, 0x20, 0xDA, 0x9F,
+	0xF0, 0xDD, 0x5A, 0x24, 0xC8, 0x3A, 0xA5, 0xA5,
+	0x42, 0x86, 0xDF, 0xC2, 0x63, 0x03, 0x1E, 0x32,
+	0x9B, 0x4D, 0xA1, 0x48, 0x43, 0x06, 0x59, 0xFE,
+	0x62, 0xCD, 0xB5, 0xB7, 0xE1, 0xE0, 0x0F, 0xC6,
+	0x80, 0x30, 0x67, 0x11, 0xEB, 0x44, 0x4A, 0xF7,
+	0x72, 0x09, 0x35, 0x94, 0x96, 0xFC, 0xFF, 0x1D,
+	0xB9, 0x52, 0x0B, 0xA5, 0x1C, 0x7B, 0x29, 0xEA
+};
+static const uint8_t kAsymSalt[64] = {
+	0x63, 0xB6, 0xA0, 0x4D, 0x2C, 0x07, 0x7F, 0xC1,
+	0x0F, 0x63, 0x9F, 0x21, 0xDA, 0x79, 0x38, 0x44,
+	0x35, 0x6C, 0xC2, 0xB0, 0xB4, 0x41, 0xB3, 0xA7,
+	0x71, 0x24, 0x03, 0x5C, 0x03, 0xF8, 0xE1, 0xBE,
+	0x60, 0x35, 0xD3, 0x1F, 0x28, 0x28, 0x21, 0xA7,
+	0x45, 0x0A, 0x02, 0x22, 0x2A, 0xB1, 0xB3, 0xCF,
+	0xF1, 0x67, 0x9B, 0x05, 0xAB, 0x1C, 0xA5, 0xD1,
+	0xAF, 0xFB, 0x78, 0x9C, 0xCD, 0x2B, 0x0B, 0x3B
+};
+static const uint8_t kSigHdr[2] = CBOR_BSTR64_HDR;
+
+static const struct cwt_claims_bstr_s kCwtClaimsTemplate = {
+	CWT_CLAIMS_BSTR_HDR,
+	{
+		/* Map header: 10 entries */
+		CBOR_HDR1(CBOR_MAJOR_MAP, 10),
+		/* 1. ISS: uint(1, 0bytes) => tstr(hex(UDS_ID)) */
+		CWT_LABEL_ISS,
+		CBOR_TSTR40_EMPTY, /* CALC - calc from UDS */
+		/* 2. SUB: uint(2, 0bytes) =>
+		 *    tstr(hex(CDI_ID))
+		 */
+		CWT_LABEL_SUB,
+		CBOR_TSTR40_EMPTY, /* CALC - calc from CDI */
+		/* 3. Code Hash: nint(-4670545, 4bytes) =>
+		 *    bstr(32bytes)
+		 */
+		CWT_LABEL_CODE_HASH,
+		CBOR_BSTR32_EMPTY, /* VARIABLE */
+		/* 4. Cfg Hash: nint(-4670547, 4bytes) =>
+		 *    bstr(32bytes)
+		 */
+		CWT_LABEL_CFG_HASH,
+		CBOR_BSTR32_EMPTY, /* CALC - calc from CfgDescr */
+		/* 5. Cfg Descr: nint(-4670548, 4bytes) =>
+		 *    bstr(struct cfg_descr_s)
+		 */
+		CWT_LABEL_CFG_DESCR,
+		/* struct cfg_descr_bstr_s */
+		{
+			CFG_DESCR_BSTR_HDR,
+			/* struct cfg_descr_s */
+			{
+				/* Map header: 6 entries */
+				CBOR_HDR1(CBOR_MAJOR_MAP, 6),
+				/* 1. Comp name: nint(-70002, 4bytes) =>
+				 * tstr("CrOS AP FW")
+				 */
+				CFG_DESCR_LABEL_COMP_NAME,
+				CFG_DESCR_COMP_NAME,
+				/* 2. Resettable: nint(-70004, 4bytes) => null
+				 */
+				CFG_DESCR_LABEL_RESETTABLE,
+				CBOR_NULL,
+				/* 3. Sec ver: nint(-70005, 4bytes) =>
+				 *    uint(Security ver, 4bytes)
+				 */
+				CFG_DESCR_LABEL_SEC_VER,
+				CBOR_UINT32_ZERO, /* VARIABLE */
+				/* 4. APROV status:
+				 *    nint(-71000, 4bytes) =>
+				 *    uint(APROV status, 4bytes)
+				 */
+				CFG_DESCR_LABEL_APROV_STATUS,
+				CBOR_UINT32_ZERO, /* VARIABLE */
+				/* 5. Vboot status: */
+				/* nint(-71000, 4bytes) => */
+				/* bstr(PCR0, 32bytes) */
+				CFG_DESCR_LABEL_VBOOT_STATUS,
+				CBOR_BSTR32_EMPTY, /* VARIABLE */
+				/* 6. AP FW version: */
+				/* nint(-71002, 4bytes) => */
+				/* bstr(PCR10, 32bytes) */
+				CFG_DESCR_LABEL_AP_FW_VERSION,
+				CBOR_BSTR32_EMPTY, /* VARIABLE */
+			},
+		},
+		/* 6. Auth Hash: nint(-4670549, 4bytes) => bstr(32bytes) */
+		CWT_LABEL_AUTH_HASH,
+		CBOR_BSTR32_EMPTY, /* always zero */
+		/* 7. Mode: nint(-4670551, 4bytes) => bstr(1byte) */
+		CWT_LABEL_MODE,
+		CBOR_BSTR1_EMPTY, /* VARIABLE */
+		/* 8. Subject PK: nint(-4670552, 4bytes) => bstr(COSE_Key) */
+		CWT_LABEL_SUBJECT_PK,
+		/* struct cose_key_ecdsa_bstr_s */
+		{
+			COSE_KEY_ECDSA_BSTR_HDR,
+			/* struct cose_key_ecdsa_s */
+			{
+				/* Map header: 6 entries */
+				CBOR_HDR1(CBOR_MAJOR_MAP, 6),
+				/* 1. Key type: uint(1, 0bytes) =>
+				 * uint(2, 0bytes)
+				 */
+				COSE_KEY_LABEL_KTY,
+				CBOR_UINT0(2), /* EC2 */
+				/* 2. Algorithm: uint(3, 0bytes) =>
+				 *    nint(-1, 0bytes)
+				 */
+				COSE_KEY_LABEL_ALG,
+				CBOR_NINT0(-7), /* ECDSA w/SHA-256 */
+				/* 3. Key ops: uint(4, 0bytes) =>
+				 *    array(1) { uint(2, 0bytes) }
+				 */
+				COSE_KEY_LABEL_KEY_OPS,
+				CBOR_HDR1(CBOR_MAJOR_ARR, 1),
+				CBOR_UINT0(2),
+				/* 4. Curve: nint(-1, 0bytes) => uint(1, 0bytes)
+				 */
+				COSE_KEY_LABEL_CRV,
+				CBOR_UINT0(1), /* P-256 */
+				/* 5. X: nint(-2, 0bytes) =>
+				 *    bstr(X, 32bytes)
+				 */
+				COSE_KEY_LABEL_X,
+				CBOR_BSTR32_EMPTY, /* VARIABLE */
+				/* 6. X: nint(-3, 0bytes) =>
+				 *    bstr(Y, 32bytes)
+				 */
+				COSE_KEY_LABEL_Y,
+				CBOR_BSTR32_EMPTY, /* VARIABLE */
+			},
+		},
+		/* 9. Key Usage: nint(-4670553, 4bytes) => bstr(1byte) */
+		CWT_LABEL_KEY_USAGE,
+		{
+			CBOR_HDR1(CBOR_MAJOR_BSTR, 1),
+			0x20, /* keyCertSign */
+		},
+		/* 10. Profile name: nint(-4670554, 4bytes) => */
+		/* tstr("android.16") */
+		CWT_LABEL_PROFILE_NAME,
+		CWT_PROFILE_NAME,
+	},
+};
+
+static const struct dice_handover_hdr_s kDiceHandoverHdrTemplate = {
+	/* Map header: 3 elements */
+	CBOR_HDR1(CBOR_MAJOR_MAP, 3),
+	/* 1. CDI_Attest: uint(1, 0bytes) => bstr(32bytes) */
+	DICE_HANDOVER_LABEL_CDI_ATTEST,
+	CBOR_BSTR32_EMPTY, /* CALC - CDI_attest */
+	/* 2. CDI_Seal: uint(2, 0bytes) => bstr(32bytes) */
+	DICE_HANDOVER_LABEL_CDI_SEAL,
+	CBOR_BSTR32_EMPTY, /* CALC - CDI_seal */
+	/* 3. DICE chain: uint(3, 0bytes) => DICE cert chain */
+	DICE_HANDOVER_LABEL_DICE_CHAIN
+	/* DICE cert chain is not included */
+};
+
+static const struct cdi_sig_struct_hdr_s kSigStructFixedHdr = {
+	/* Array header: 4 elements */
+	CBOR_HDR1(CBOR_MAJOR_ARR, 4),
+	/* 1. Context: tstr("Signature1") */
+	CDI_SIG_STRUCT_CONTEXT,
+	/* 2. Body protected: bstr(COSE param) */
+	COSE_PARAM_BSTR,
+	/* 3. External AAD: Bstr(0 bytes) */
+	CBOR_HDR1(CBOR_MAJOR_BSTR, 0),
+	/* 4. Payload - not fixed, contained in cdi_sig_struct_t */
+};
+
+static const struct combined_hdr_s kCombinedHdrTemplate = {
+	/* struct dice_cert_chain_hdr_s cert_chain */
+	{
+		/* Array header: 2 elements */
+		CBOR_HDR1(CBOR_MAJOR_ARR, 2),
+		/* 1. UDS pub key: COSE_Key
+		 * struct cose_key_ecdsa_s
+		 */
+		{
+			/* Map header: 6 entries */
+			CBOR_HDR1(CBOR_MAJOR_MAP, 6),
+			/* 1. Key type: uint(1, 0bytes) => uint(2, 0bytes) */
+			COSE_KEY_LABEL_KTY,
+			CBOR_UINT0(2), /* EC2 */
+			/* 2. Algorithm: uint(3, 0bytes) => nint(-1, 0bytes) */
+			COSE_KEY_LABEL_ALG,
+			CBOR_NINT0(-7), /* ECDSA w/ SHA-256 */
+			/* 3. Key ops: uint(4, 0bytes) =>
+			 *    array(1) { uint(2, 0bytes) }
+			 */
+			COSE_KEY_LABEL_KEY_OPS,
+			CBOR_HDR1(CBOR_MAJOR_ARR, 1),
+			CBOR_UINT0(2),
+			/* 4. Curve: nint(-1, 0bytes) => uint(1, 0bytes) */
+			COSE_KEY_LABEL_CRV,
+			CBOR_UINT0(1), /* P-256 */
+			/* 5. X: nint(-2, 0bytes) => bstr(X, 32bytes) */
+			COSE_KEY_LABEL_X,
+			CBOR_BSTR32_EMPTY, /* VARIABLE */
+			/* 6. X: nint(-3, 0bytes) => bstr(Y, 32bytes) */
+			COSE_KEY_LABEL_Y,
+			CBOR_BSTR32_EMPTY, /* VARIABLE */
+		},
+		/* 2. CDI DICE cert: - not included, */
+		/* consists of hdr=cdi_cert_hdr_s, payload=cwt_claims_bstr_s, */
+		/* sig=cbor_bstr64_s */
+	},
+	/* struct cdi_cert_hdr_s cert */
+	{
+		/* Array header: 4 elements */
+		CBOR_HDR1(CBOR_MAJOR_ARR, 4),
+		/* 1. Protected: bstr(COSE param) */
+		COSE_PARAM_BSTR,
+		/* 2. Unprotected: empty map */
+		CBOR_HDR1(CBOR_MAJOR_MAP, 0),
+		/* 3. Payload: bstr(CWT claims) - not fixed, contained in */
+		/* cdi_cert_t */
+		/* 4. Signature: bstr(64 bytes) - not fixed, contained in */
+		/* cdi_cert_t */
+	}
+};
+
+static const struct slice_ref_s kCdiAttestLabel = {
+	10 /* strlen("CDI_Attest") */,
+	(const uint8_t *)"CDI_Attest"
+};
+static const struct slice_ref_s kCdiSealLabel = {
+	8 /* strlen("CDI_Seal") */,
+	(const uint8_t *)"CDI_Seal"
+};
+static const struct slice_ref_s kIdSaltSlice = {
+	64,
+	(const uint8_t *)kIdSalt
+};
+static const struct slice_ref_s kAsymSaltSlice = {
+	64,
+	(const uint8_t *)kAsymSalt
+};
+static const struct slice_ref_s kIdLabel = {
+	2, /* streln("ID") */
+	(const uint8_t *)"ID"
+};
+static const struct slice_ref_s kKeyPairLabel = {
+	8, /* strelen("Key Pair") */
+	(const uint8_t *)"Key Pair"
+};
+
+/* Calculates CDI from {UDS, inputs_digest, label}
+ */
+static inline bool calc_cdi_from_digest(
+	/* [IN] UDS */
+	const uint8_t uds[DIGEST_BYTES],
+	/* [IN] digest of inputs */
+	const uint8_t inputs_digest[DIGEST_BYTES],
+	/* [IN] label */
+	const struct slice_ref_s label,
+	/* [OUT] CDI */
+	uint8_t cdi[DIGEST_BYTES]
+)
+{
+	const struct slice_ref_s uds_slice = digest_as_slice(uds);
+	const struct slice_ref_s inputs_digest_slice =
+		digest_as_slice(inputs_digest);
+	const struct slice_mut_s cdi_slice = digest_as_slice_mut(cdi);
+
+	return __platform_hkdf_sha256(uds_slice, inputs_digest_slice, label,
+				      cdi_slice);
+}
+
+/* Calculates CDI from {UDS, inputs, label}
+ */
+static bool calc_cdi(
+	/* [IN] UDS */
+	const uint8_t uds[DIGEST_BYTES],
+	/* [IN] inputs */
+	const struct slice_ref_s inputs,
+	/* [IN] label */
+	const struct slice_ref_s label,
+	/* [OUT] CDI */
+	uint8_t cdi[DIGEST_BYTES]
+)
+{
+	uint8_t inputs_digest[DIGEST_BYTES];
+
+	if (!__platform_sha256(inputs, inputs_digest)) {
+		__platform_log_str("Failed to hash inputs");
+		return false;
+	}
+	return calc_cdi_from_digest(uds, inputs_digest, label, cdi);
+}
+
+/* Fills inputs for sealing CDI.
+ * Assumes that ctx->cfg and CfgDescr in ctx->output are already filled.
+ */
+static inline void fill_inputs_seal(
+	/* [IN] dice context */
+	const struct dice_ctx_s *ctx,
+	/* [OUT] inputs */
+	struct cdi_seal_inputs_s *inputs
+)
+{
+	__platform_memset(inputs->auth_data_digest, 0, DIGEST_BYTES);
+	__platform_memcpy(inputs->hidden_digest, ctx->cfg.hidden_digest,
+			  DIGEST_BYTES);
+	inputs->mode = ctx->output.dice_handover.payload.data.mode.value;
+}
+
+/* Fills inputs for attestation CDI
+ * Assumes that ctx->cfg and CfgDescr in ctx->output are already filled.
+ */
+static inline void fill_inputs_attest(
+	/* [IN] dice context */
+	const struct dice_ctx_s *ctx,
+	/* [OUT] inputs */
+	struct cdi_attest_inputs_s *inputs
+)
+{
+	const struct cwt_claims_s *cwt_claims =
+		&ctx->output.dice_handover.payload.data;
+
+	__platform_memcpy(inputs->code_digest,
+			  cwt_claims->code_hash.value,
+			  DIGEST_BYTES);
+	__platform_memcpy(inputs->cfg_desr_digest,
+			  cwt_claims->cfg_hash.value,
+			  DIGEST_BYTES);
+	fill_inputs_seal(ctx, &inputs->seal_inputs);
+}
+
+/* Calculates attestation CDI.
+ * Assumes that ctx->cfg and CfgDescr in ctx->output are already filled.
+ */
+static inline bool calc_cdi_attest(
+	/* [IN] dice context */
+	const struct dice_ctx_s *ctx,
+	/* [OUT] CDI */
+	uint8_t cdi[DIGEST_BYTES]
+)
+{
+	struct cdi_attest_inputs_s inputs;
+	const struct slice_ref_s inputs_slice = {
+		sizeof(inputs), (uint8_t *)&inputs
+	};
+
+	fill_inputs_attest(ctx, &inputs);
+	return calc_cdi(ctx->cfg.uds, inputs_slice, kCdiAttestLabel, cdi);
+}
+
+/* Calculates sealing CDI.
+ * Assumes that ctx->cfg and CfgDescr in ctx->output are already filled.
+ */
+static inline bool calc_cdi_seal(
+	/* [IN] dice context */
+	const struct dice_ctx_s *ctx,
+	/* [OUT] CDI */
+	uint8_t cdi[DIGEST_BYTES]
+)
+{
+	struct cdi_seal_inputs_s inputs;
+	const struct slice_ref_s inputs_slice = {
+		sizeof(inputs), (uint8_t *)&inputs
+	};
+
+	fill_inputs_seal(ctx, &inputs);
+	return calc_cdi(ctx->cfg.uds, inputs_slice, kCdiSealLabel, cdi);
+}
+
+/* Calculates boot mode from the data in ctx->cfg
+ * On DT/OT with ti50:
+ * - Normal if
+ * - APROV succeeded or not configured from factory (for legacy devices).
+ * Note: AllowUnverifiedRo counts as a failure AND
+ * - Coreboot reported 'normal' boot mode
+ * - Recovery if
+ * - APROV succeeded or not configured from factory (for legacy devices).
+ * Note: AllowUnverifiedRo counts as a failure AND
+ * - Coreboot reported 'recovery-normal' boot mode
+ * - Debug - in all other cases
+ *
+ * On H1 with Cr50:
+ * - Normal if Coreboot reported 'normal' boot mode
+ * - Recovery if Coreboot reported 'recovery-normal' boot mode
+ * - Debug - in all other cases
+ */
+static inline uint8_t calc_mode(
+	/* [IN] dice context */
+	const struct dice_ctx_s *ctx
+)
+{
+	if (__platform_aprov_status_allows_normal(ctx->cfg.aprov_status)) {
+		if (__platform_memcmp(ctx->cfg.pcr0, kPcr0NormalMode,
+				      DIGEST_BYTES) == 0) {
+			return BOOT_MODE_NORMAL;
+		}
+		if (__platform_memcmp(ctx->cfg.pcr0, kPcr0RecoveryNormalMode,
+				      DIGEST_BYTES) == 0) {
+			return BOOT_MODE_RECOVERY;
+		}
+	}
+	return BOOT_MODE_DEBUG;
+}
+
+/* Generates CDI cert signature for the initialized builder with pre-filled
+ * CWT claims.
+ */
+static inline bool fill_cdi_cert_signature(
+	/* [IN/OUT] dice context */
+	struct dice_ctx_s *ctx,
+	/* [IN] key handle to sign */
+	const void *key
+)
+{
+	uint8_t *sig_struct = ((uint8_t *)&ctx->output.dice_handover.payload) -
+			      sizeof(struct cdi_sig_struct_hdr_s);
+	const struct slice_ref_s data_to_sign = {
+		CDI_SIG_STRUCT_LEN, sig_struct
+	};
+	struct cbor_bstr64_s *sig_bstr64 =
+		&ctx->output.dice_handover.signature;
+
+	__platform_memcpy(sig_struct, &kSigStructFixedHdr,
+			  sizeof(struct cdi_sig_struct_hdr_s));
+	__platform_memcpy(sig_bstr64->cbor_hdr, kSigHdr, 2);
+	return __platform_ecdsa_p256_sign(key, data_to_sign,
+					  sig_bstr64->value);
+}
+
+/* Generates key from UDS or CDI_Attest value.
+ */
+static bool generate_key(
+	/* [IN] CDI_attest or UDS */
+	const uint8_t input[DIGEST_BYTES],
+	/* [OUT] key handle */
+	const void **key
+)
+{
+	uint8_t drbg_seed[DIGEST_BYTES];
+	const struct slice_ref_s input_slice = digest_as_slice(input);
+	const struct slice_mut_s drbg_seed_slice =
+		digest_as_slice_mut(drbg_seed);
+
+	if (!__platform_hkdf_sha256(input_slice, kAsymSaltSlice,
+				    kKeyPairLabel, drbg_seed_slice)) {
+		__platform_log_str("ASYM_KDF failed");
+		return false;
+	}
+	return __platform_ecdsa_p256_keygen_hmac_drbg(drbg_seed, key);
+}
+
+/* Generates {UDS, CDI}_ID from {UDS, CDI} public key.
+ */
+static bool generate_id_from_pub_key(
+	/* [IN] public key */
+	const struct ecdsa_public_s *pub_key,
+	/* [OUT] generated id */
+	uint8_t dice_id[DICE_ID_BYTES]
+)
+{
+	const struct slice_ref_s pub_key_slice = {
+		sizeof(struct ecdsa_public_s), (const uint8_t *)pub_key
+	};
+	const struct slice_mut_s dice_id_slice = {
+		DICE_ID_BYTES, (uint8_t *)dice_id
+	};
+
+	return __platform_hkdf_sha256(pub_key_slice, kIdSaltSlice, kIdLabel,
+				      dice_id_slice);
+}
+
+/* Returns hexdump character for the half-byte.
+ */
+static inline uint8_t hexdump_halfbyte(uint8_t half_byte)
+{
+	if (half_byte < 10)
+		return '0' + half_byte;
+	else
+		return 'a' + half_byte - 10;
+}
+
+/* Fills hexdump of the byte (lowercase).
+ */
+static inline void hexdump_byte(
+	/* [IN] byte to hexdump */
+	uint8_t byte,
+	/* [OUT] str (always 2 bytes) with hexdump */
+	uint8_t *str
+)
+{
+	str[0] = hexdump_halfbyte((byte & 0xF0) >> 4);
+	str[1] = hexdump_halfbyte(byte & 0x0F);
+}
+
+/* Fills {CDI, UDS} ID string from ID bytes.
+ */
+static void fill_dice_id_string(
+	/* [IN] IDS_ID or CDI_ID */
+	const uint8_t dice_id[DICE_ID_BYTES],
+	/* [OUT] hexdump of this ID */
+	uint8_t dice_id_str[DICE_ID_HEX_BYTES]
+)
+{
+	size_t idx;
+
+	for (idx = 0; idx < DICE_ID_BYTES; idx++, dice_id_str += 2)
+		hexdump_byte(dice_id[idx], dice_id_str);
+}
+
+/* Fills COSE_Key structure from pubkey.
+ * Assumes that all fields in COSE_Key except for X, y are already filled
+ * from template.
+ */
+static inline void fill_cose_pubkey(
+	/* [IN] pub key */
+	const struct ecdsa_public_s *pub_key,
+	/* [IN/OUT] COSE key structure */
+	struct cose_key_ecdsa_s *cose_key
+)
+{
+	__platform_memcpy(cose_key->x.value, pub_key->x, ECDSA_POINT_BYTES);
+	__platform_memcpy(cose_key->y.value, pub_key->y, ECDSA_POINT_BYTES);
+}
+
+/* Fills CDI_attest pubkey, CDI_ID in the CDI certificate using generated
+ * CDI_attest key.
+ */
+static inline bool fill_cdi_details_with_key(
+	/* [IN/OUT] dice context */
+	struct dice_ctx_s *ctx,
+	/* [IN] CDI_attest key handle */
+	const void *cdi_key
+)
+{
+	struct ecdsa_public_s cdi_pub_key;
+	uint8_t cdi_id[DICE_ID_BYTES];
+	struct cwt_claims_s *cwt_claims =
+		&ctx->output.dice_handover.payload.data;
+
+	if (!__platform_ecdsa_p256_get_pub_key(cdi_key, &cdi_pub_key)) {
+		__platform_log_str("Failed to get CDI pubkey");
+		return false;
+	}
+	fill_cose_pubkey(&cdi_pub_key, &cwt_claims->subject_pk.data);
+	if (!generate_id_from_pub_key(&cdi_pub_key, cdi_id)) {
+		__platform_log_str("Failed to generate CDI_ID");
+		return false;
+	}
+	/* SUB = hex(CDI_ID) */
+	fill_dice_id_string(cdi_id, cwt_claims->sub.value);
+
+	return true;
+}
+
+/* Fills CDI_attest pubkey, CDI_ID in the CDI certificate.
+ * Assumes that ctx->cfg and CfgDescr in ctx->output are already filled.
+ */
+static inline bool fill_cdi_details(
+	/* [IN/OUT] dice context */
+	struct dice_ctx_s *ctx
+)
+{
+	const void *cdi_key;
+	bool result;
+	struct dice_handover_hdr_s *hdr = &ctx->output.dice_handover.hdr;
+
+	__platform_memcpy(hdr, &kDiceHandoverHdrTemplate,
+			  sizeof(struct dice_handover_hdr_s));
+	if (!calc_cdi_attest(ctx, hdr->cdi_attest.value)) {
+		__platform_log_str("Failed to calc CDI_attest");
+		return false;
+	}
+	if (!calc_cdi_seal(ctx, hdr->cdi_seal.value)) {
+		__platform_log_str("Failed to calc CDI_seal");
+		return false;
+	}
+	if (!generate_key(hdr->cdi_attest.value, &cdi_key)) {
+		__platform_log_str("Failed to generate CDI key");
+		return false;
+	}
+	result = fill_cdi_details_with_key(ctx, cdi_key);
+	__platform_ecdsa_p256_free(cdi_key);
+
+	return result;
+}
+
+/* Fills UDS_ID, signature into the certificate using generated UDS key.
+ * Assumes that all other fields of CDI certificate are filled already.
+ */
+static inline bool fill_uds_details_with_key(
+	/* [IN/OUT] dice context */
+	struct dice_ctx_s *ctx,
+	/* [IN] UDS key handle */
+	const void *uds_key
+)
+{
+	struct ecdsa_public_s uds_pub_key;
+	uint8_t uds_id[DICE_ID_BYTES];
+	struct cwt_claims_s *cwt_claims =
+		&ctx->output.dice_handover.payload.data;
+	struct combined_hdr_s *combined_hdr =
+		&ctx->output.dice_handover.options.dice_handover;
+
+	if (!__platform_ecdsa_p256_get_pub_key(uds_key, &uds_pub_key)) {
+		__platform_log_str("Failed to get UDS pubkey");
+		return false;
+	}
+	if (!generate_id_from_pub_key(&uds_pub_key, uds_id)) {
+		__platform_log_str("Failed to generate UDS_ID");
+		return false;
+	}
+	/* ISS = hex(UDS_ID) */
+	fill_dice_id_string(uds_id, cwt_claims->iss.value);
+	if (!fill_cdi_cert_signature(ctx, uds_key)) {
+		__platform_log_str("Failed to sign CDI cert");
+		return false;
+	}
+
+	/* We can do the rest only after we generated the signature because */
+	/* signature generation uses ctx->output.hdr temporarily to build */
+	/* Sig_struct for signing. */
+	__platform_memcpy(combined_hdr,
+			  &kCombinedHdrTemplate,
+			  sizeof(struct combined_hdr_s));
+	fill_cose_pubkey(
+		&uds_pub_key,
+		&combined_hdr->cert_chain.uds_pub_key);
+
+	return true;
+}
+
+/* Fills UDS_ID, signature into the certificate. */
+/* Assumes that all other fields of CDI certificate were filled already. */
+static inline bool fill_uds_details(
+	struct dice_ctx_s *ctx /* [IN/OUT] dice context */
+)
+{
+	const void *uds_key;
+	bool result;
+
+	if (!generate_key(ctx->cfg.uds, &uds_key)) {
+		__platform_log_str("Failed to generate UDS key");
+		return false;
+	}
+	result = fill_uds_details_with_key(ctx, uds_key);
+	__platform_ecdsa_p256_free(uds_key);
+
+	return result;
+}
+
+/* Fills value in struct cbor_uint32_s */
+/* Assumes that `cbor_var->cbor_hdr` is already pre-set */
+static inline void set_cbor_u32(
+	uint32_t value, /* [IN] value to set */
+	struct cbor_uint32_s *cbor_var /* [OUT] CBOR UINT32 variable to fill */
+)
+{
+	cbor_var->value[0] = (uint8_t)(((value) & 0xFF000000) >> 24);
+	cbor_var->value[1] = (uint8_t)(((value) & 0x00FF0000) >> 16);
+	cbor_var->value[2] = (uint8_t)(((value) & 0x0000FF00) >> 8);
+	cbor_var->value[3] = (uint8_t)((value) & 0x000000FF);
+}
+
+/* Fills CfgDescr, CfgDescr digest and boot mode in CDI certificate */
+static inline bool fill_config_details(
+	struct dice_ctx_s *ctx /* [IN/OUT] dice context */
+)
+{
+	struct cwt_claims_bstr_s *payload = &ctx->output.dice_handover.payload;
+	struct cwt_claims_s *cwt_claims = &payload->data;
+	struct cfg_descr_s *cfg_descr = &payload->data.cfg_descr.data;
+	const struct slice_ref_s cfg_descr_slice = { sizeof(struct cfg_descr_s),
+					(uint8_t *)cfg_descr };
+
+	/* Copy fixed data from the template */
+	__platform_memcpy(payload, &kCwtClaimsTemplate,
+			  sizeof(struct cwt_claims_bstr_s));
+
+	/* Fill Cfg Descriptor variables based on ctx->cfg */
+	set_cbor_u32(ctx->cfg.aprov_status, &cfg_descr->aprov_status);
+	set_cbor_u32(ctx->cfg.sec_ver, &cfg_descr->sec_ver);
+	__platform_memcpy(cfg_descr->vboot_status.value, ctx->cfg.pcr0,
+			  DIGEST_BYTES);
+	__platform_memcpy(cfg_descr->ap_fw_version.value, ctx->cfg.pcr10,
+			  DIGEST_BYTES);
+
+	/* Calculate Cfg Descriptor digest */
+	if (!__platform_sha256(cfg_descr_slice, cwt_claims->cfg_hash.value)) {
+		__platform_log_str("Failed to calc CfgDescr digest");
+		return false;
+	}
+
+	/* Calculate boot mode */
+	cwt_claims->mode.value = calc_mode(ctx);
+
+	return true;
+}
+
+/* Fills DICE handover structure in struct dice_ctx_s. */
+/* Assumes ctx.cfg is already filled */
+static inline bool generate_dice_handover(
+	struct dice_ctx_s *ctx /* [IN/OUT] dice context */
+)
+{
+	/* 1. Fill device configuration details in CDI certificate: CfgDescr and
+	 * its digest, boot mode.
+	 * 2. Fill CDI details in CDI certificate (CDI pubkey, CDI_ID) and DICE
+	 * handover (CDIs) Relies on config details to be filled already
+	 * 3. Fill UDS details in CDI certificate (UDS_ID, signature by UDS key)
+	 * and DICE chain (UDS pubkey) Relies on the rest of CDI certificate to
+	 * be filled already.
+	 */
+
+	return fill_config_details(ctx) &&
+		fill_cdi_details(ctx) &&
+		fill_uds_details(ctx);
+}
+
+/* Fills GSCBootParam. */
+static inline bool fill_gsc_boot_param(
+	struct gsc_boot_param_s *gsc_boot_param /* [IN/OUT] GSCBootParam */
+)
+{
+	/* GSCBootParam: Map header: 3 entries */
+	gsc_boot_param->map_hdr = CBOR_HDR1(CBOR_MAJOR_MAP, 3);
+
+	/* GSCBootParam entry 1: EarlyEntropy:
+	 * uint(1, 0bytes) => bstr(entropy, 64bytes)
+	 */
+	gsc_boot_param->early_entropy_label = CBOR_UINT0(1);
+	gsc_boot_param->early_entropy.cbor_hdr[0] =
+		CBOR_HDR1(CBOR_MAJOR_BSTR, CBOR_BYTES1);
+	gsc_boot_param->early_entropy.cbor_hdr[1] = EARLY_ENTROPY_BYTES;
+
+	/* GSCBootParam entry 2: SessionKeySeed:
+	 * uint(2, 0bytes) => bstr(entropy, 32bytes)
+	 */
+	gsc_boot_param->session_key_seed_label = CBOR_UINT0(2);
+	gsc_boot_param->session_key_seed.cbor_hdr[0] =
+		CBOR_HDR1(CBOR_MAJOR_BSTR, CBOR_BYTES1);
+	gsc_boot_param->session_key_seed.cbor_hdr[1] = KEY_SEED_BYTES;
+
+	/* GSCBootParam entry 3: AuthTokenKeySeed:
+	 * uint(3, 0bytes) => bstr(entropy, 32bytes)
+	 */
+	gsc_boot_param->auth_token_key_seed_label = CBOR_UINT0(3);
+	gsc_boot_param->auth_token_key_seed.cbor_hdr[0] =
+		CBOR_HDR1(CBOR_MAJOR_BSTR, CBOR_BYTES1);
+	gsc_boot_param->auth_token_key_seed.cbor_hdr[1] = KEY_SEED_BYTES;
+
+	if (!__platform_get_gsc_boot_param(
+			gsc_boot_param->early_entropy.value,
+			gsc_boot_param->session_key_seed.value,
+			gsc_boot_param->auth_token_key_seed.value)) {
+		__platform_log_str("Failed to get GSC boot param");
+		return false;
+	}
+	return true;
+}
+
+/* Fills GSCBootParam and BootParam header in struct dice_ctx_s. */
+/* Doesn't touch DICE handover structure */
+static inline bool fill_boot_param(
+	struct dice_ctx_s *ctx /* [IN/OUT] dice context */
+)
+{
+	/* BootParam: Map header: 3 entries */
+	ctx->output.map_hdr = CBOR_HDR1(CBOR_MAJOR_MAP, 3);
+
+	/* BootParam entry 1: Version:
+	 * uint(1, 0bytes) => uint(BOOT_PARAM_VERSION, 0bytes)
+	 */
+	ctx->output.version_label = CBOR_UINT0(1);
+	ctx->output.version = CBOR_UINT0(0);
+
+	/* BootParam entry 2: GSCBootParam:
+	 * uint(2, 0bytes) => GSCBootParam (filled in fill_gsc_boot_param)
+	 */
+	ctx->output.gsc_boot_param_label = CBOR_UINT0(2);
+
+	/* BootParam entry 3: AndroidDiceHandover:
+	 * uint(3, 0bytes) => AndroidDiceHandover (not touched in this func)
+	 */
+	ctx->output.dice_handover_label = CBOR_UINT0(3);
+
+	return fill_gsc_boot_param(&ctx->output.gsc_boot_param);
+}
+
+/* Get (part of) BootParam structure: [offset .. offset + size). */
+size_t get_boot_param_bytes(
+	/* [OUT] destination buffer to fill */
+	uint8_t *dest,
+	/* [IN] starting offset in the BootParam struct */
+	size_t offset,
+	/* [IN] size of the BootParam struct to copy */
+	size_t size
+)
+{
+	struct dice_ctx_s ctx;
+	uint8_t *src = (uint8_t *)&ctx.output;
+
+	if (size == 0 || offset >= BOOT_PARAM_SIZE)
+		return 0;
+	if (size > BOOT_PARAM_SIZE - offset)
+		size = BOOT_PARAM_SIZE - offset;
+
+	if (!__platform_get_dice_config(&ctx.cfg)) {
+		__platform_log_str("Failed to get DICE config");
+		return 0;
+	}
+	if (!generate_dice_handover(&ctx))
+		return 0;
+
+	if (!fill_boot_param(&ctx))
+		return 0;
+
+	__platform_memcpy(dest, src + offset, size);
+	return size;
+}
+
+/* Get (part of) DiceChain structure: [offset .. offset + size) */
+size_t get_dice_chain_bytes(
+	/* [OUT] destination buffer to fill */
+	uint8_t *dest,
+	/* [IN] starting offset in the DiceChain struct */
+	size_t offset,
+	/* [IN] size of the data to copy */
+	size_t size
+)
+{
+	struct dice_ctx_s ctx;
+	uint8_t *src = (uint8_t *)&ctx.output.dice_handover.options;
+
+	if (size == 0 || offset >= DICE_CHAIN_SIZE)
+		return 0;
+	if (size > DICE_CHAIN_SIZE - offset)
+		size = DICE_CHAIN_SIZE - offset;
+
+	if (!__platform_get_dice_config(&ctx.cfg)) {
+		__platform_log_str("Failed to get DICE config");
+		return 0;
+	}
+	if (!generate_dice_handover(&ctx))
+		return 0;
+
+	__platform_memcpy(dest, src + offset, size);
+	return size;
+}
diff --git a/boot_param/boot_param.h b/boot_param/boot_param.h
new file mode 100644
index 000000000..a92f0d1b3
--- /dev/null
+++ b/boot_param/boot_param.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_H
+#define __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_H
+
+#include "boot_param_types.h"
+#include "boot_param_platform.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Size of BootParam structure in bytes */
+#define BOOT_PARAM_SIZE 820
+
+/* Get (part of) BootParam structure: [offset .. offset + size) */
+size_t get_boot_param_bytes(
+	/* [OUT] destination buffer to fill */
+	uint8_t *dest,
+	/* [IN] starting offset in the BootParam struct */
+	size_t offset,
+	/* [IN] size of the data to copy */
+	size_t size
+);
+
+/* Size of DiceChain structure in bytes */
+#define DICE_CHAIN_SIZE 605
+
+/* Get (part of) DiceChain structure: [offset .. offset + size) */
+size_t get_dice_chain_bytes(
+	/* [OUT] destination buffer to fill */
+	uint8_t *dest,
+	/* [IN] starting offset in the DiceChain struct */
+	size_t offset,
+	/* [IN] size of the data to copy */
+	size_t size
+);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_H */
diff --git a/boot_param/boot_param_platform.h b/boot_param/boot_param_platform.h
new file mode 100644
index 000000000..5ba4951b6
--- /dev/null
+++ b/boot_param/boot_param_platform.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_PLATFORM_H
+#define __GSC_UTILS_BOOT_PARAM_PLATFORM_H
+
+#include "boot_param_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Perform HKDF-SHA256(ikm, salt, info) */
+bool __platform_hkdf_sha256(
+	/* [IN] input key material */
+	const struct slice_ref_s ikm,
+	/* [IN] salt */
+	const struct slice_ref_s salt,
+	/* [IN] info */
+	const struct slice_ref_s info,
+	/* [IN/OUT] .size sets length for hkdf,
+	 * .data is where the digest will be placed
+	 */
+	const struct slice_mut_s result
+);
+
+/* Calculate SH256 for the provided buffer */
+bool __platform_sha256(
+	/* [IN] data to hash */
+	const struct slice_ref_s data,
+	/* [OUT] resulting digest */
+	uint8_t digest[DIGEST_BYTES]
+);
+
+/* Get DICE config */
+bool __platform_get_dice_config(
+	/* [OUT] DICE config */
+	struct dice_config_s *cfg
+);
+
+/* Get GSC boot parameters */
+bool __platform_get_gsc_boot_param(
+	/* [OUT] early entropy */
+	uint8_t early_entropy[EARLY_ENTROPY_BYTES],
+	/* [OUT] SessionKeySeed */
+	uint8_t session_key_seed[KEY_SEED_BYTES],
+	/* [OUT] AuthTokenKeySeed */
+	uint8_t auth_token_key_seed[KEY_SEED_BYTES]
+);
+
+/* Generate ECDSA P-256 key using HMAC-DRBG initialized by the seed */
+bool __platform_ecdsa_p256_keygen_hmac_drbg(
+	/* [IN] key seed */
+	const uint8_t seed[DIGEST_BYTES],
+	/* [OUT] ECDSA key handle */
+	const void **key
+);
+
+/* Generate ECDSA P-256 signature: 64 bytes (R | S) */
+bool __platform_ecdsa_p256_sign(
+	/* [IN] ECDSA key handle */
+	const void *key,
+	/* [IN] data to sign */
+	const struct slice_ref_s data,
+	/* [OUT] resulting signature */
+	uint8_t signature[ECDSA_SIG_BYTES]
+);
+
+/* Get ECDSA public key X, Y */
+bool __platform_ecdsa_p256_get_pub_key(
+	/* [IN] ECDSA key handle */
+	const void *key,
+	/* [OUT] public key structure */
+	struct ecdsa_public_s *pub_key
+);
+
+/* Free ECDSA key handle */
+void __platform_ecdsa_p256_free(
+	/* [IN] ECDSA key handle */
+	const void *key
+);
+
+/* Check if APROV status allows making 'normal' boot mode decision */
+bool __platform_aprov_status_allows_normal(
+	/* [IN] APROV status */
+	uint32_t aprov_status
+);
+
+/* Print error string to log */
+void __platform_log_str(
+	/* [IN] string to print */
+	const char *str
+);
+
+/* memcpy */
+void __platform_memcpy(void *dest, const void *src, size_t size);
+
+/* memset */
+void __platform_memset(void *dest, uint8_t fill, size_t size);
+
+/* memcmp */
+int __platform_memcmp(const void *str1, const void *str2, size_t size);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_PLATFORM_H */
diff --git a/boot_param/boot_param_platform_host.c b/boot_param/boot_param_platform_host.c
new file mode 100644
index 000000000..978a22db5
--- /dev/null
+++ b/boot_param/boot_param_platform_host.c
@@ -0,0 +1,381 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "boot_param_platform.h"
+
+#include <openssl/core_names.h>
+#include <openssl/err.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#include <openssl/kdf.h>
+#include <openssl/params.h>
+#include <openssl/sha.h>
+
+#include <stdio.h>
+#include <string.h>
+
+static void print_openssl_error(const char *func_name, const char *prefix_err)
+{
+	unsigned long err = ERR_get_error();
+	char *err_str = ERR_error_string(err, NULL);
+
+	printf("%s: %s\n", func_name, prefix_err);
+	if (err_str)
+		__platform_log_str(err_str);
+}
+
+/* Perform HKDF-SHA256(ikm, salt, info) */
+bool __platform_hkdf_sha256(
+	/* [IN] input key material */
+	const struct slice_ref_s ikm,
+	/* [IN] salt */
+	const struct slice_ref_s salt,
+	/* [IN] info */
+	const struct slice_ref_s info,
+	/* [IN/OUT] .size sets length for hkdf,
+	 * .data is where the digest will be placed
+	 */
+	const struct slice_mut_s result
+)
+{
+	EVP_KDF *kdf;
+	EVP_KDF_CTX *kctx;
+	OSSL_PARAM params[5], *p = params;
+	int res;
+
+	kdf = EVP_KDF_fetch(NULL, "HKDF", NULL);
+	if (kdf == NULL) {
+		print_openssl_error(__func__, "Can't find HKDF");
+		return false;
+	}
+	kctx = EVP_KDF_CTX_new(kdf);
+	EVP_KDF_free(kdf);
+	if (kctx == NULL) {
+		print_openssl_error(__func__, "Can't create HKDF context");
+		return false;
+	}
+
+	*p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+						SN_sha256, strlen(SN_sha256));
+	*p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+						 (void *)ikm.data, ikm.size);
+	*p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+						 (void *)info.data, info.size);
+	*p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+						 (void *)salt.data, salt.size);
+	*p = OSSL_PARAM_construct_end();
+
+	res = EVP_KDF_derive(kctx, result.data, result.size, params);
+	if (res <= 0)
+		print_openssl_error(__func__, "Can't perform HKDF");
+
+	EVP_KDF_CTX_free(kctx);
+	return (res > 0);
+}
+
+/* Calculate SH256 for the provided buffer */
+bool __platform_sha256(
+	/* [IN] data to hash */
+	const struct slice_ref_s data,
+	/* [OUT] resulting digest */
+	uint8_t digest[DIGEST_BYTES]
+)
+{
+	return SHA256(data.data, data.size, digest) == digest;
+}
+
+struct dice_config_s g_dice_config = {
+	.aprov_status = 0x20,
+	.sec_ver = 1,
+	.uds = {
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	},
+	.hidden_digest = {
+		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+		0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+		0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+	},
+	.code_digest = {
+		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+		0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+		0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+	},
+	.pcr0 = {
+		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+		0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+		0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+	},
+	.pcr10 = {
+		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+		0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+		0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+	},
+};
+
+/* Get DICE config */
+bool __platform_get_dice_config(
+	/* [OUT] DICE config */
+	struct dice_config_s *cfg
+)
+{
+	memcpy(cfg, &g_dice_config, sizeof(struct dice_config_s));
+	return true;
+}
+
+uint8_t g_early_entropy[EARLY_ENTROPY_BYTES] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+};
+
+uint8_t g_session_key_seed[KEY_SEED_BYTES] = {
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+};
+
+uint8_t g_auth_token_key_seed[KEY_SEED_BYTES] = {
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+};
+
+/* Get GSC boot parameters */
+bool __platform_get_gsc_boot_param(
+	/* [OUT] early entropy */
+	uint8_t early_entropy[EARLY_ENTROPY_BYTES],
+	/* [OUT] SessionKeySeed */
+	uint8_t session_key_seed[KEY_SEED_BYTES],
+	/* [OUT] AuthTokenKeySeed */
+	uint8_t auth_token_key_seed[KEY_SEED_BYTES]
+)
+{
+	memcpy(early_entropy, g_early_entropy, EARLY_ENTROPY_BYTES);
+	memcpy(session_key_seed, g_session_key_seed, KEY_SEED_BYTES);
+	memcpy(auth_token_key_seed, g_auth_token_key_seed, KEY_SEED_BYTES);
+	return true;
+}
+
+/* Generate ECDSA P-256 key using HMAC-DRBG initialized by the seed */
+bool __platform_ecdsa_p256_keygen_hmac_drbg(
+	/* [IN] key seed */
+	const uint8_t seed[DIGEST_BYTES],
+	/* [OUT] ECDSA key handle */
+	const void **key
+)
+{
+	/* NOTE: for testing we don't do the actual KDF based on HMAC_DRBG.
+	 * We could use EVP_KDF-HMAC-DRBG or EVP_RAND-HMAC-DRBG, but there's
+	 * no easy way to generate EC key from a seed we'd get from DRBG.
+	 * Instead, we just generate a random EC key ignoring the seed.
+	 */
+	*key = EVP_EC_gen("P-256");
+
+	if (*key == NULL) {
+		print_openssl_error(__func__, "Can't generate EC");
+		return false;
+	}
+	return true;
+}
+
+/* Generate ECDSA P-256 signature: 64 bytes (R | S) */
+bool __platform_ecdsa_p256_sign(
+	/* [IN] ECDSA key handle */
+	const void *key,
+	/* [IN] data to sign */
+	const struct slice_ref_s data,
+	/* [OUT] resulting signature */
+	uint8_t signature[ECDSA_SIG_BYTES]
+)
+{
+	const BIGNUM *r;
+	const BIGNUM *s;
+	EVP_PKEY_CTX *ctx;
+	EVP_SIGNATURE *alg;
+	uint8_t digest[DIGEST_BYTES];
+	uint8_t output[128];
+	int res;
+	size_t siglen;
+	ECDSA_SIG *sig_obj;
+	const uint8_t *sig_ptr = output;
+
+	if (!__platform_sha256(data, digest)) {
+		printf("%s: SHA failed\n", __func__);
+		return false;
+	}
+
+	ctx = EVP_PKEY_CTX_new((EVP_PKEY *)key, NULL /* no engine */);
+	if (ctx == NULL) {
+		print_openssl_error(__func__, "Can't create context");
+		return false;
+	}
+	if (EVP_PKEY_sign_init(ctx) <= 0) {
+		print_openssl_error(__func__, "Can't init sign");
+		EVP_PKEY_CTX_free(ctx);
+		return false;
+	}
+
+	alg = EVP_SIGNATURE_fetch(NULL, "ECDSA", NULL);
+	if (alg == NULL) {
+		print_openssl_error(__func__, "Can't fetch signature alg");
+		EVP_PKEY_CTX_free(ctx);
+		return false;
+	}
+
+	res = EVP_PKEY_sign(ctx, NULL, &siglen, digest, DIGEST_BYTES);
+	if (res <= 0)
+		print_openssl_error(__func__, "Can't detect signature size");
+
+	if (siglen <= sizeof(output)) {
+		res = EVP_PKEY_sign(ctx, output, &siglen, digest, DIGEST_BYTES);
+		if (res <= 0)
+			print_openssl_error(__func__, "Can't sign");
+	} else {
+		printf("%s: unexpected sigsize %zu > %zu\n",
+		       __func__, siglen, sizeof(output));
+		res = 0;
+	}
+
+	EVP_PKEY_CTX_free(ctx);
+	EVP_SIGNATURE_free(alg);
+
+	if (res <= 0)
+		return false;
+
+	sig_obj = d2i_ECDSA_SIG(NULL, &sig_ptr, siglen);
+	if (sig_obj == NULL) {
+		print_openssl_error(__func__, "Can't convert signature");
+		return false;
+	}
+
+	r = ECDSA_SIG_get0_r(sig_obj);
+	s = ECDSA_SIG_get0_s(sig_obj);
+
+	if (BN_num_bytes(r) > ECDSA_POINT_BYTES) {
+		printf("%s: unexpected r size %d > %u\n",
+		       __func__, BN_num_bytes(r), ECDSA_POINT_BYTES);
+		ECDSA_SIG_free(sig_obj);
+		return false;
+	}
+	if (BN_num_bytes(s) > ECDSA_POINT_BYTES) {
+		printf("%s: unexpected s size %d > %u\n",
+		       __func__, BN_num_bytes(s), ECDSA_POINT_BYTES);
+		ECDSA_SIG_free(sig_obj);
+		return false;
+	}
+	memset(signature, 0, ECDSA_SIG_BYTES);
+	BN_bn2bin(r, signature + (ECDSA_POINT_BYTES - BN_num_bytes(r)));
+	BN_bn2bin(s, signature + (ECDSA_SIG_BYTES - BN_num_bytes(s)));
+
+	ECDSA_SIG_free(sig_obj);
+	return true;
+}
+
+/* Get ECDSA public key X, Y */
+bool __platform_ecdsa_p256_get_pub_key(
+	/* [IN] ECDSA key handle */
+	const void *key,
+	/* [OUT] public key structure */
+	struct ecdsa_public_s *pub_key
+)
+{
+	BIGNUM *x = NULL;
+	BIGNUM *y = NULL;
+	bool res = true;
+
+	if (!EVP_PKEY_get_bn_param(key, OSSL_PKEY_PARAM_EC_PUB_X, &x)) {
+		print_openssl_error(__func__, "Can't get X");
+		res = false;
+	}
+
+	if (!EVP_PKEY_get_bn_param(key, OSSL_PKEY_PARAM_EC_PUB_Y, &y)) {
+		print_openssl_error(__func__, "Can't get Y");
+		res = false;
+	}
+
+	if (res && (BN_num_bytes(x) > ECDSA_POINT_BYTES)) {
+		printf("%s: unexpected X size %d > %u\n",
+		       __func__, BN_num_bytes(x), ECDSA_POINT_BYTES);
+		res = false;
+	}
+	if (res && (BN_num_bytes(y) > ECDSA_POINT_BYTES)) {
+		printf("%s: unexpected Y size %d > %u\n",
+		       __func__, BN_num_bytes(y), ECDSA_POINT_BYTES);
+		res = false;
+	}
+
+	if (res) {
+		memset(pub_key->x, 0, ECDSA_POINT_BYTES);
+		BN_bn2bin(x,
+			pub_key->x + (ECDSA_POINT_BYTES - BN_num_bytes(x)));
+		memset(pub_key->y, 0, ECDSA_POINT_BYTES);
+		BN_bn2bin(y,
+			pub_key->y + (ECDSA_POINT_BYTES - BN_num_bytes(y)));
+	}
+
+	BN_free(x);
+	BN_free(y);
+	return res;
+}
+
+/* Free ECDSA key handle */
+void __platform_ecdsa_p256_free(
+	/* [IN] ECDSA key handle */
+	const void *key
+)
+{
+	EVP_PKEY_free((EVP_PKEY *)key);
+}
+
+/* Check if APROV status allows making 'normal' boot mode decision */
+bool __platform_aprov_status_allows_normal(
+	/* [IN] APROV status */
+	uint32_t aprov_status
+)
+{
+	return true;
+}
+
+/* Print error string to log */
+void __platform_log_str(
+	/* [IN] string to print */
+	const char *str
+)
+{
+	puts(str);
+}
+
+/* memcpy */
+void __platform_memcpy(void *dest, const void *src, size_t size)
+{
+	memcpy(dest, src, size);
+}
+
+/* memset */
+void __platform_memset(void *dest, uint8_t fill, size_t size)
+{
+	memset(dest, fill, size);
+}
+
+/* memcmp */
+int __platform_memcmp(const void *str1, const void *str2, size_t size)
+{
+	return memcmp(str1, str2, size);
+}
diff --git a/boot_param/boot_param_platform_host.h b/boot_param/boot_param_platform_host.h
new file mode 100644
index 000000000..43c7627e1
--- /dev/null
+++ b/boot_param/boot_param_platform_host.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_PLATFORM_HOST_H
+#define __GSC_UTILS_BOOT_PARAM_PLATFORM_HOST_H
+
+#include "boot_param_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct dice_config_s g_dice_config;
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_PLATFORM_HOST_H */
diff --git a/boot_param/boot_param_types.h b/boot_param/boot_param_types.h
new file mode 100644
index 000000000..a055195c0
--- /dev/null
+++ b/boot_param/boot_param_types.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_TYPES_H
+#define __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_TYPES_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DIGEST_BYTES	  32
+#define ECDSA_POINT_BYTES 32
+#define ECDSA_SIG_BYTES	  (2 * ECDSA_POINT_BYTES) /* 32 byte R + 32 byte S */
+
+/* Sizes of GGSCBootParam fields */
+#define EARLY_ENTROPY_BYTES     64
+#define KEY_SEED_BYTES          32
+
+
+/* UDS_ID and CDI_ID sizes */
+#define DICE_ID_BYTES	  20
+#define DICE_ID_HEX_BYTES (DICE_ID_BYTES * 2)
+
+struct slice_mut_s {
+	size_t size;
+	uint8_t *data;
+};
+struct slice_ref_s {
+	const size_t size;
+	const uint8_t *data;
+};
+
+#define digest_as_slice(digest) \
+	{ DIGEST_BYTES, digest }
+
+#define digest_as_slice_mut(digest) \
+	{ DIGEST_BYTES, digest }
+
+struct ecdsa_public_s {
+	uint8_t x[ECDSA_POINT_BYTES];
+	uint8_t y[ECDSA_POINT_BYTES];
+};
+
+struct dice_config_s {
+	/* APROV status */
+	uint32_t aprov_status;
+	/* GSCVD version (or 0 where not available) */
+	uint32_t sec_ver;
+	/* UDS */
+	uint8_t uds[DIGEST_BYTES];
+	/* derived from owner seed, changes on owner clear */
+	uint8_t hidden_digest[DIGEST_BYTES];
+	/* GSCVD digest (or 0..0 where not available) */
+	uint8_t code_digest[DIGEST_BYTES];
+	/* PCR0 value */
+	uint8_t pcr0[DIGEST_BYTES];
+	/* PCR10 value */
+	uint8_t pcr10[DIGEST_BYTES];
+};
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_BOOT_PARAM_TYPES_H */
diff --git a/boot_param/cbor_basic.h b/boot_param/cbor_basic.h
new file mode 100644
index 000000000..85fb83a0d
--- /dev/null
+++ b/boot_param/cbor_basic.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_CBOR_BASIC_H
+#define __GSC_UTILS_BOOT_PARAM_CBOR_BASIC_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CBOR_MAJOR_UINT         ((uint8_t)(0 << 5))
+#define CBOR_MAJOR_NINT         ((uint8_t)(1 << 5))
+#define CBOR_MAJOR_BSTR         ((uint8_t)(2 << 5))
+#define CBOR_MAJOR_TSTR         ((uint8_t)(3 << 5))
+#define CBOR_MAJOR_ARR          ((uint8_t)(4 << 5))
+#define CBOR_MAJOR_MAP          ((uint8_t)(5 << 5))
+#define CBOR_MAJOR_TAG          ((uint8_t)(6 << 5))
+#define CBOR_MAJOR_SIMPLE       ((uint8_t)(7 << 5))
+
+#define CBOR_HDR1(major, value) ((uint8_t)(major) | (uint8_t)((value) & 0x1f))
+
+#define CBOR_FALSE CBOR_HDR1(CBOR_MAJOR_SIMPLE, 20)
+#define CBOR_TRUE  CBOR_HDR1(CBOR_MAJOR_SIMPLE, 21)
+#define CBOR_NULL  CBOR_HDR1(CBOR_MAJOR_SIMPLE, 22)
+
+#define CBOR_BYTES1 24
+#define CBOR_BYTES2 25
+#define CBOR_BYTES4 26
+#define CBOR_BYTES8 27
+
+/* NINTs in [-24..-1] range ("0 bytes") */
+#define CBOR_NINT0_LEN	  1
+#define CBOR_NINT0(label) CBOR_HDR1(CBOR_MAJOR_NINT, -(label) - 1)
+
+/* UINTs in [0..23] range ("0 bytes") */
+#define CBOR_UINT0_LEN	  1
+#define CBOR_UINT0(label) CBOR_HDR1(CBOR_MAJOR_UINT, (label))
+
+/* Building block for 32 bit (4 bytes) integer representations */
+#define CBOR_INT32_LEN (1 + 4)
+#define CBOR_INT32(major, value)                         \
+	{                                                \
+		CBOR_HDR1(major, CBOR_BYTES4),           \
+		(uint8_t)(((value) & 0xFF000000) >> 24), \
+		(uint8_t)(((value) & 0x00FF0000) >> 16), \
+		(uint8_t)(((value) & 0x0000FF00) >> 8),  \
+		(uint8_t)((value) & 0x000000FF)          \
+	}
+
+/* 32 bit (4 bytes) negative integers */
+#define CBOR_NINT32_LEN	   CBOR_INT32_LEN
+#define CBOR_NINT32(value) CBOR_INT32(CBOR_MAJOR_NINT, (-(value) - 1))
+
+/* 32 bit (4 bytes) positive integers */
+#define CBOR_UINT32_LEN	   CBOR_INT32_LEN
+#define CBOR_UINT32(value) CBOR_INT32(CBOR_MAJOR_UINT, value)
+
+/* BSTR with 1 byte size */
+#define CBOR_BSTR_HDR8(size)                              \
+	{ CBOR_HDR1(CBOR_MAJOR_BSTR, CBOR_BYTES1), size }
+
+/* TSTR with 1 byte size */
+#define CBOR_TSTR_HDR8(size)                              \
+	{ CBOR_HDR1(CBOR_MAJOR_TSTR, CBOR_BYTES1), size }
+
+/* BSTR with 2 byte size */
+#define CBOR_BSTR_HDR16(size)                            \
+	{                                                \
+		CBOR_HDR1(CBOR_MAJOR_BSTR, CBOR_BYTES2), \
+		(uint8_t)(((size) & 0xFF00) >> 8),       \
+		(uint8_t)((size) & 0x00FF)               \
+	}
+
+/* BSTR of length 1 */
+struct cbor_bstr1_s {
+	uint8_t cbor_hdr;
+	uint8_t value;
+};
+#define CBOR_BSTR1_HDR CBOR_HDR1(CBOR_MAJOR_BSTR, 1)
+#define CBOR_BSTR1_EMPTY { CBOR_BSTR1_HDR, 0 }
+
+/* BSTR of length 32: UDS, CDI, digest, key seeds */
+struct cbor_bstr32_s {
+	uint8_t cbor_hdr[2];
+	uint8_t value[32];
+};
+#define CBOR_BSTR32_HDR CBOR_BSTR_HDR8(32)
+#define CBOR_BSTR32_EMPTY                       \
+	{                                       \
+		CBOR_BSTR32_HDR,                \
+		{                               \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0  \
+		}                               \
+	}
+
+/* TSTR of length 2*20 = 40: UDS_ID, CDI_ID as hex */
+struct cbor_tstr40_s {
+	uint8_t cbor_hdr[2];
+	uint8_t value[40];
+};
+#define CBOR_TSTR40_HDR CBOR_TSTR_HDR8(40)
+#define CBOR_TSTR40_EMPTY                       \
+	{                                       \
+		CBOR_TSTR40_HDR,                \
+		{                               \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0  \
+		}                               \
+	}
+
+/* BSTR of length 64: signature, entropy */
+struct cbor_bstr64_s {
+	uint8_t cbor_hdr[2];
+	uint8_t value[64];
+};
+#define CBOR_BSTR64_HDR CBOR_BSTR_HDR8(64)
+#define CBOR_BSTR64_EMPTY                       \
+	{                                       \
+		CBOR_BSTR64_HDR,                \
+		{                               \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0, \
+			0, 0, 0, 0, 0, 0, 0, 0  \
+		}                               \
+	}
+
+/* UINT32 */
+struct cbor_uint32_s {
+	uint8_t cbor_hdr;
+	uint8_t value[4];
+};
+#define CBOR_UINT32_HDR CBOR_HDR1(CBOR_MAJOR_UINT, CBOR_BYTES4)
+#define CBOR_UINT32_ZERO           \
+	{                          \
+		CBOR_UINT32_HDR,   \
+		{                  \
+			0, 0, 0, 0 \
+		}                  \
+	}
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __CGSC_UTILS_BOOT_PARAM_CBOR_BASIC_H */
diff --git a/boot_param/cbor_boot_param.h b/boot_param/cbor_boot_param.h
new file mode 100644
index 000000000..e1408f122
--- /dev/null
+++ b/boot_param/cbor_boot_param.h
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_CBOR_BOOT_PARAM_H
+#define __GSC_UTILS_BOOT_PARAM_CBOR_BOOT_PARAM_H
+
+#include "cbor_basic.h"
+#include "boot_param_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Boot mode decisions.
+ * Boot mode == "Not configured" is not allowed
+ */
+#define BOOT_MODE_NORMAL   1
+#define BOOT_MODE_DEBUG	   2
+#define BOOT_MODE_RECOVERY 3
+
+/* Configuration descriptor - see go/gsc-dice
+ */
+#define CFG_DESCR_LABEL_COMP_NAME     CBOR_NINT32(-70002)
+#define CFG_DESCR_LABEL_RESETTABLE    CBOR_NINT32(-70004)
+#define CFG_DESCR_LABEL_SEC_VER	      CBOR_NINT32(-70005)
+#define CFG_DESCR_LABEL_APROV_STATUS  CBOR_NINT32(-71000)
+#define CFG_DESCR_LABEL_VBOOT_STATUS  CBOR_NINT32(-71001)
+#define CFG_DESCR_LABEL_AP_FW_VERSION CBOR_NINT32(-71002)
+
+#define CFG_DESCR_COMP_NAME_VALUE_LEN 10 /* "CrOS AP FW" */
+#define CFG_DESCR_COMP_NAME_LEN	      (1 + CFG_DESCR_COMP_NAME_VALUE_LEN)
+#define CFG_DESCR_COMP_NAME                                                \
+	{                                                                  \
+		CBOR_HDR1(CBOR_MAJOR_TSTR, CFG_DESCR_COMP_NAME_VALUE_LEN), \
+			'C', 'r', 'O', 'S', ' ', 'A', 'P', ' ', 'F', 'W'   \
+	}
+
+struct cfg_descr_s {
+	/* Map header: 6 entries */
+	uint8_t map_hdr;
+	/* 1. Comp name: nint(-70002, 4bytes) => tstr("CrOS AP FW") */
+	uint8_t comp_name_label[CBOR_NINT32_LEN];
+	uint8_t comp_name[CFG_DESCR_COMP_NAME_LEN];
+	/* 2. Resettable: nint(-70004, 4bytes) => null */
+	uint8_t resettable_label[CBOR_NINT32_LEN];
+	uint8_t resettable;
+	/* 3. Sec ver: nint(-70005, 4bytes) => uint(Security ver, 4bytes) */
+	uint8_t sec_ver_label[CBOR_NINT32_LEN];
+	struct cbor_uint32_s sec_ver;
+	/* 4. APROV status: nint(-71000, 4bytes) => uint(APROV_sts, 4bytes) */
+	uint8_t aprov_status_label[CBOR_NINT32_LEN];
+	struct cbor_uint32_s aprov_status;
+	/* 5. Vboot status: nint(-71001, 4bytes) => bstr(PCR0, 32bytes) */
+	uint8_t vboot_status_label[CBOR_NINT32_LEN];
+	struct cbor_bstr32_s vboot_status;
+	/* 6. AP FW version: nint(-71002, 4bytes) => bstr(PCR10, 32bytes) */
+	uint8_t ap_fw_version_label[CBOR_NINT32_LEN];
+	struct cbor_bstr32_s ap_fw_version;
+};
+
+#define CFG_DESCR_LEN sizeof(struct cfg_descr_s)
+struct cfg_descr_bstr_s {
+	uint8_t bstr_hdr[2]; /* bstr(sizeof(struct cfg_descr_s), 1byte) */
+	struct cfg_descr_s data;
+};
+#define CFG_DESCR_BSTR_HDR CBOR_BSTR_HDR8(CFG_DESCR_LEN)
+
+/* COSE keys - see go/gsc-dice
+ */
+#define COSE_KEY_LABEL_KTY     CBOR_UINT0(1)
+#define COSE_KEY_LABEL_ALG     CBOR_UINT0(3)
+#define COSE_KEY_LABEL_KEY_OPS CBOR_UINT0(4)
+#define COSE_KEY_LABEL_CRV     CBOR_NINT0(-1)
+#define COSE_KEY_LABEL_X       CBOR_NINT0(-2)
+#define COSE_KEY_LABEL_Y       CBOR_NINT0(-3)
+
+/* Configuration descriptor per go/gsc-dice
+ */
+struct cose_key_ecdsa_s {
+	/* Map header: 6 entries */
+	uint8_t map_hdr;
+	/* 1. Key type: uint(1, 0bytes) => uint(2, 0bytes) */
+	uint8_t kty_label;
+	uint8_t kty;
+	/* 2. Algorithm: uint(3, 0bytes) => nint(-1, 0bytes) */
+	uint8_t alg_label;
+	uint8_t alg;
+	/* 3. Key ops: uint(4, 0bytes) => array(1) { uint(2, 0bytes) } */
+	uint8_t key_ops_label;
+	uint8_t key_ops_array_hdr;
+	uint8_t key_ops;
+	/* 4. Curve: nint(-1, 0bytes) => uint(1, 0bytes) */
+	uint8_t crv_label;
+	uint8_t crv;
+	/* 5. X: nint(-2, 0bytes) => bstr(X, 32bytes) */
+	uint8_t x_label;
+	struct cbor_bstr32_s x;
+	/* 6. X: nint(-3, 0bytes) => bstr(Y, 32bytes) */
+	uint8_t y_label;
+	struct cbor_bstr32_s y;
+};
+
+#define COSE_KEY_ECDSA_LEN sizeof(struct cose_key_ecdsa_s)
+struct cose_key_ecdsa_bstr_s {
+	uint8_t bstr_hdr[2]; /* bstr(sizeof(struct cose_key_ecdsa_s), 1byte) */
+	struct cose_key_ecdsa_s data;
+};
+#define COSE_KEY_ECDSA_BSTR_HDR CBOR_BSTR_HDR8(COSE_KEY_ECDSA_LEN)
+
+/* CWT claims - see go/gsc-dice
+ * Size of TSTR containing an {UDS,CDI}_ID: (24 =< DICE_ID_HEX_LEN < 255)
+ * => 1 byte size encoding
+ */
+#define DICE_ID_TSTR_LEN (2 + DICE_ID_HEX_BYTES)
+
+#define CWT_LABEL_ISS	       CBOR_UINT0(1)
+#define CWT_LABEL_SUB	       CBOR_UINT0(2)
+#define CWT_LABEL_CODE_HASH    CBOR_NINT32(-4670545)
+#define CWT_LABEL_CFG_HASH     CBOR_NINT32(-4670547)
+#define CWT_LABEL_CFG_DESCR    CBOR_NINT32(-4670548)
+#define CWT_LABEL_AUTH_HASH    CBOR_NINT32(-4670549)
+#define CWT_LABEL_MODE	       CBOR_NINT32(-4670551)
+#define CWT_LABEL_SUBJECT_PK   CBOR_NINT32(-4670552)
+#define CWT_LABEL_KEY_USAGE    CBOR_NINT32(-4670553)
+#define CWT_LABEL_PROFILE_NAME CBOR_NINT32(-4670554)
+
+#define CWT_PROFILE_NAME_VALUE_LEN 10 /* "android.16" */
+#define CWT_PROFILE_NAME_LEN	   (1 + CWT_PROFILE_NAME_VALUE_LEN)
+#define CWT_PROFILE_NAME                                                 \
+	{                                                                \
+		CBOR_HDR1(CBOR_MAJOR_TSTR, CWT_PROFILE_NAME_VALUE_LEN),  \
+			'a', 'n', 'd', 'r', 'o', 'i', 'd', '.', '1', '6' \
+	}
+
+struct cwt_claims_s {
+	/* Map header: 10 entries */
+	uint8_t map_hdr;
+	/* 1. ISS: uint(1, 0bytes) => tstr(hex(UDS_ID)) */
+	uint8_t iss_label;
+	struct cbor_tstr40_s iss;
+	/* 2. SUB: uint(2, 0bytes) => tstr(hex(CDI_ID)) */
+	uint8_t sub_label;
+	struct cbor_tstr40_s sub;
+	/* 3. Code Hash: nint(-4670545, 4bytes) => bstr(32bytes) */
+	uint8_t code_hash_label[CBOR_NINT32_LEN];
+	struct cbor_bstr32_s code_hash;
+	/* 4. Cfg Hash: nint(-4670547, 4bytes) => bstr(32bytes) */
+	uint8_t cfg_hash_label[CBOR_NINT32_LEN];
+	struct cbor_bstr32_s cfg_hash;
+	/* 5. Cfg Descr: nint(-4670548, 4bytes) => bstr(struct cfg_descr_s) */
+	uint8_t cfg_descr_label[CBOR_NINT32_LEN];
+	struct cfg_descr_bstr_s cfg_descr;
+	/* 6. Auth Hash: nint(-4670549, 4bytes) => bstr(32bytes) */
+	uint8_t auth_hash_label[CBOR_NINT32_LEN];
+	struct cbor_bstr32_s auth_hash;
+	/* 7. Mode: nint(-4670551, 4bytes) => bstr(1byte) */
+	uint8_t mode_label[CBOR_NINT32_LEN];
+	struct cbor_bstr1_s mode;
+	/* 8. Subject PK: nint(-4670552, 4bytes) => bstr(COSE_Key) */
+	uint8_t subject_pk_label[CBOR_NINT32_LEN];
+	struct cose_key_ecdsa_bstr_s subject_pk;
+	/* 9. Key Usage: nint(-4670553, 4bytes) => bstr(1byte) */
+	uint8_t key_usage_label[CBOR_NINT32_LEN];
+	struct cbor_bstr1_s key_usage;
+	/* 10. Profile name: nint(-4670554, 4bytes) => tstr("android.16") */
+	uint8_t profile_name_label[CBOR_NINT32_LEN];
+	uint8_t profile_name[CWT_PROFILE_NAME_LEN];
+};
+
+#define CWT_CLAIMS_LEN sizeof(struct cwt_claims_s)
+struct cwt_claims_bstr_s {
+	uint8_t bstr_hdr[3]; /* bstr(sizeof(struct cose_key_ecdsa_s), 2bytes) */
+	struct cwt_claims_s data;
+};
+#define CWT_CLAIMS_BSTR_HDR CBOR_BSTR_HDR16(CWT_CLAIMS_LEN)
+
+/* Protected COSE header parameters - see go/gsc-dice
+ */
+#define COSE_PARAM_LABEL_ALG CBOR_UINT0(1)
+struct cose_param_bstr_s {
+	/* BSTR of size 3 - see the rest of the struct */
+	uint8_t bstr_hdr;
+	/* Map header: 1 element */
+	uint8_t map_hdr;
+	/* 1. Alg: uint(1, 0bytes) => nint(-7, 0bytes) */
+	uint8_t alg_label;
+	uint8_t alg;
+};
+
+#define COSE_PARAM_BSTR                                                       \
+	{                                                                     \
+		/* BSTR of size 3 - see the rest of the struct */             \
+		CBOR_HDR1(CBOR_MAJOR_BSTR, 3),                                \
+		/* Map header: 1 elem */                                      \
+		CBOR_HDR1(CBOR_MAJOR_MAP, 1),                                 \
+		/* 1. Alg: uint(1) => nint(-7) */                             \
+		COSE_PARAM_LABEL_ALG,                                         \
+		CBOR_NINT0(-7) /* ECDSA w/ SHA-256 */                         \
+	}
+
+/* Sig structure for CDI certificate - see go/gsc-dice
+ */
+#define CDI_SIG_STRUCT_CONTEXT_VALUE_LEN 10 /* "Signature1" */
+#define CDI_SIG_STRUCT_CONTEXT_LEN	 (1 + CDI_SIG_STRUCT_CONTEXT_VALUE_LEN)
+#define CDI_SIG_STRUCT_CONTEXT                                                \
+	{                                                                     \
+		CBOR_HDR1(CBOR_MAJOR_TSTR, CDI_SIG_STRUCT_CONTEXT_VALUE_LEN), \
+			'S', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', '1'      \
+	}
+
+struct cdi_sig_struct_hdr_s {
+	/* Array header: 4 elements */
+	uint8_t array_hdr;
+	/* 1. Context: tstr("Signature1") */
+	uint8_t context[CDI_SIG_STRUCT_CONTEXT_LEN];
+	/* 2. Body protected: bstr(COSE param) */
+	struct cose_param_bstr_s body_protected;
+	/* 3. External AAD: bstr(0 bytes) */
+	uint8_t external_aad;
+	/* 4. Payload - not fixed, contained in cdi_sig_struct_t */
+};
+
+#define CDI_SIG_STRUCT_LEN \
+	(sizeof(struct cdi_sig_struct_hdr_s) + sizeof(struct cwt_claims_bstr_s))
+
+/* CDI certificate = COSE_Sign1 structure - see go/gsc-dice
+ */
+
+/* Header of the certificate that includes protected & unprotected
+ * parameters, but not payload (CWT claims) and signature.
+ * This header is actually fixed (no variable fields).
+ * We need it to be able to prepend either it or Sig_structure header to
+ * payload: the former to return as a part of AndroidDiceHandover,
+ * the latter to calculate certificate signature.
+ */
+struct cdi_cert_hdr_s {
+	/* Array header: 4 elements */
+	uint8_t array_hdr;
+	/* 1. Protected: bstr(COSE param) */
+	struct cose_param_bstr_s protected;
+	/* 2. Unprotected: empty map */
+	uint8_t unprotected;
+	/* 3. Payload: bstr(CWT claims) - not fixed, struct cwt_claims_bstr_s */
+	/* 4. Signature: bstr(64 bytes) - not fixed, struct cbor_bstr64_s */
+};
+
+#define CDI_CERT_LEN                        \
+	(sizeof(struct cdi_cert_hdr_s) +    \
+	 sizeof(struct cwt_claims_bstr_s) + \
+	 sizeof(struct cbor_bstr64_s))
+
+/* DICE cert chain. In our case, CBOR array consisting of exactly 2 entries
+ * DiceCertChain = [
+ * COSE_Key,       ; UDS pub key
+ * COSE_Sign1,     ; CDI DICE cert
+ * ]
+ */
+
+/* Header of DICE cert chain that includes UDS pubkey, but not CDI DICE cert.
+ * This header contains variable fields (UDS key).
+ * We need it to be able to prepend either it + cert header or Sig_structure
+ * header to CWT claims: the former to return as a part of
+ * AndroidDiceHandover, the latter to calculate certificate signature.
+ */
+struct dice_cert_chain_hdr_s {
+	/* Array header: 2 elements */
+	uint8_t array_hdr;
+	/* 1. UDS pub key: COSE_Key */
+	struct cose_key_ecdsa_s uds_pub_key;
+	/* 2. CDI DICE cert: - not included,
+	 * consists of hdr=cdi_cert_hdr_s, payload=cwt_claims_bstr_s,
+	 * sig=cbor_bstr64_s
+	 */
+};
+
+/* Dice Handover struct. In our case, CBOR map with exactly 3 entries:
+ * AndroidDiceHandover = {
+ * 1 : bstr .size 32,     ; CDI_Attest
+ * 2 : bstr .size 32,     ; CDI_Seal
+ * 3 : DiceCertChain,     ; DICE chain - see above
+ * }
+ */
+
+#define DICE_HANDOVER_LABEL_CDI_ATTEST CBOR_UINT0(1)
+#define DICE_HANDOVER_LABEL_CDI_SEAL   CBOR_UINT0(2)
+#define DICE_HANDOVER_LABEL_DICE_CHAIN CBOR_UINT0(3)
+
+/* Header of the DICE handover structure that contains the CDIs, but not the
+ * DICE chain. This header contains variable fields (CDIs). We need it to be
+ * able to prepend either it + DICE chain header + cert header or
+ * Sig_structure header to CWT claims: the former to return as a part of
+ * AndroidDiceHandover, the latter to calculate certificate signature.
+ */
+struct dice_handover_hdr_s {
+	/* Map header: 3 elements */
+	uint8_t map_hdr;
+	/* 1. CDI_Attest: uint(1, 0bytes) => bstr(32bytes) */
+	uint8_t cdi_attest_label;
+	struct cbor_bstr32_s cdi_attest;
+	/* 2. CDI_Seal: uint(2, 0bytes) => bstr(32bytes) */
+	uint8_t cdi_seal_label;
+	struct cbor_bstr32_s cdi_seal;
+	/* 3. DICE chain: uint(3, 0bytes) => DICE cert chain */
+	uint8_t dice_chain_label;
+	/* DICE cert chain is not included */
+};
+
+/* GSC Boot Parameters for TEE.
+ * GSCBootParam = {
+ *   1  : bstr .size 64,     ; EarlyEntropy
+ *   2  : bstr .size 32,     ; SessionKeySeed
+ *   3  : bstr .size 32,     ; AuthTokenKeySeed
+ * }
+ */
+struct gsc_boot_param_s {
+	/* Map header: 3 entries */
+	uint8_t map_hdr;
+	/* 1. EarlyEntropy: uint(1, 0bytes) => bstr(entropy, 64bytes) */
+	uint8_t early_entropy_label;
+	struct cbor_bstr64_s early_entropy;
+	/* 2. SessionKeySeed: uint(2, 0bytes) => bstr(entropy, 32bytes) */
+	uint8_t session_key_seed_label;
+	struct cbor_bstr32_s session_key_seed;
+	/* 3. AuthTokenKeySeed: uint(3, 0bytes) => bstr(entropy, 32bytes) */
+	uint8_t auth_token_key_seed_label;
+	struct cbor_bstr32_s auth_token_key_seed;
+};
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_CBOR_BOOT_PARAM_H */
diff --git a/boot_param/cdi.h b/boot_param/cdi.h
new file mode 100644
index 000000000..92b62311f
--- /dev/null
+++ b/boot_param/cdi.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef __GSC_UTILS_BOOT_PARAM_CDI_H
+#define __GSC_UTILS_BOOT_PARAM_CDI_H
+
+#include "boot_param_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct cdi_seal_inputs_s {
+	uint8_t auth_data_digest[DIGEST_BYTES];
+	uint8_t mode;
+	uint8_t hidden_digest[DIGEST_BYTES];
+};
+
+struct cdi_attest_inputs_s {
+	uint8_t code_digest[DIGEST_BYTES];
+	uint8_t cfg_desr_digest[DIGEST_BYTES];
+	struct cdi_seal_inputs_s seal_inputs;
+};
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __GSC_UTILS_BOOT_PARAM_CDI_H */
diff --git a/boot_param/test.c b/boot_param/test.c
new file mode 100644
index 000000000..f9e02a279
--- /dev/null
+++ b/boot_param/test.c
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2024 The ChromiumOS Authors
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "boot_param.h"
+#include "boot_param_platform.h"
+#include "boot_param_platform_host.h"
+
+#define DUMPVAR(name) hexdump(#name, name, sizeof(name))
+
+static void hexdump(const char *pfx, const uint8_t *buf, size_t size)
+{
+	size_t i;
+
+	printf("%s:\n  ", pfx);
+	for (i = 0; i < size; i++) {
+		if (i > 0 && i % 16 == 0)
+			printf("\n  ");
+		printf("%02x ", buf[i]);
+	}
+	printf("\n");
+}
+
+#undef TEST_PLATFORM
+
+#ifdef TEST_PLATFORM
+
+static void test_hkdf(void)
+{
+	uint8_t derived[DIGEST_BYTES];
+	const struct slice_ref_s ikm = {
+		3, (const uint8_t *)"key"
+	};
+	const struct slice_ref_s salt = {
+		4, (const uint8_t *)"salt"
+	};
+	const struct slice_ref_s info = {
+		5, (const uint8_t *)"label"
+	};
+	const struct slice_mut_s result = {DIGEST_BYTES, derived };
+
+	if (__platform_hkdf_sha256(ikm, salt, info, result)) {
+		__platform_log_str("HKDF: success");
+		DUMPVAR(derived);
+	} else {
+		__platform_log_str("HKDF: failed");
+	}
+}
+
+static void test_sha(void)
+{
+	uint8_t digest[DIGEST_BYTES];
+	const struct slice_ref_s input = {
+		4, (const uint8_t *)"test"
+	};
+
+	if (__platform_sha256(input, digest)) {
+		__platform_log_str("SHA256: success");
+		DUMPVAR(digest);
+	} else {
+		__platform_log_str("SHA256: failed");
+	}
+}
+
+static void test_ecdsa(void)
+{
+	uint8_t seed[DIGEST_BYTES] = { 0 };
+	const void *key;
+	const struct slice_ref_s input = {
+		4, (const uint8_t *)"test"
+	};
+	uint8_t signature[ECDSA_SIG_BYTES];
+	struct ecdsa_public_s pub_key;
+
+	if (!__platform_ecdsa_p256_keygen_hmac_drbg(seed, &key)) {
+		__platform_log_str("ECDSA: keygen failed");
+		return;
+	}
+
+	if (!__platform_ecdsa_p256_sign(key, input, signature)) {
+		__platform_log_str("ECDSA: sign failed");
+		__platform_ecdsa_p256_free(key);
+		return;
+	}
+
+	if (!__platform_ecdsa_p256_get_pub_key(key, &pub_key)) {
+		__platform_log_str("ECDSA: get pubkey failed");
+		__platform_ecdsa_p256_free(key);
+		return;
+	}
+
+	__platform_ecdsa_p256_free(key);
+	__platform_log_str("ECDSA: success");
+	DUMPVAR(signature);
+	DUMPVAR(pub_key.x);
+	DUMPVAR(pub_key.y);
+}
+#endif /* TEST_PLATFORM */
+
+static bool save_to_file(
+	const char *filename,
+	uint8_t *buf,
+	size_t size
+)
+{
+	FILE *f;
+	size_t written;
+
+	f = fopen(filename, "wb");
+	if (f == NULL) {
+		printf("Failed to open file \"%s\"\n", filename);
+		return false;
+	}
+	written = fwrite(buf, 1, size, f);
+	fclose(f);
+	return written == size;
+}
+
+static bool test_boot_param(
+	const char *filename_handover,
+	const char *filename_chain
+)
+{
+	uint8_t boot_param[BOOT_PARAM_SIZE];
+	uint8_t dice_chain[DICE_CHAIN_SIZE];
+
+	if (get_boot_param_bytes(boot_param, 0, BOOT_PARAM_SIZE) !=
+				 BOOT_PARAM_SIZE) {
+		printf("get_boot_param_bytes failed");
+		return false;
+	}
+	DUMPVAR(boot_param);
+
+	if (get_dice_chain_bytes(dice_chain, 0, DICE_CHAIN_SIZE) !=
+				 DICE_CHAIN_SIZE) {
+		printf("get_dice_chain_bytes failed");
+		return false;
+	}
+	DUMPVAR(dice_chain);
+
+	return
+		save_to_file(filename_handover,
+			     boot_param,
+			     BOOT_PARAM_SIZE) &&
+		save_to_file(filename_chain,
+			     dice_chain,
+			     DICE_CHAIN_SIZE);
+}
+
+/* PCR0 values for various modes - see go/pcr0-tpm2 */
+static const uint8_t kPcr0NormalMode[DIGEST_BYTES] = {
+	0x89, 0xEA, 0xF3, 0x51, 0x34, 0xB4, 0xB3, 0xC6,
+	0x49, 0xF4, 0x4C, 0x0C, 0x76, 0x5B, 0x96, 0xAE,
+	0xAB, 0x8B, 0xB3, 0x4E, 0xE8, 0x3C, 0xC7, 0xA6,
+	0x83, 0xC4, 0xE5, 0x3D, 0x15, 0x81, 0xC8, 0xC7
+};
+static const uint8_t kPcr0RecoveryNormalMode[DIGEST_BYTES] = {
+	0x9F, 0x9E, 0xA8, 0x66, 0xD3, 0xF3, 0x4F, 0xE3,
+	0xA3, 0x11, 0x2A, 0xE9, 0xCB, 0x1F, 0xBA, 0xBC,
+	0x6F, 0xFE, 0x8C, 0xD2, 0x61, 0xD4, 0x24, 0x93,
+	0xBC, 0x68, 0x42, 0xA9, 0xE4, 0xF9, 0x3B, 0x3D
+};
+static const uint8_t kPcr0DebugMode[DIGEST_BYTES] = {
+	0x23, 0xE1, 0x4D, 0xD9, 0xBB, 0x51, 0xA5, 0x0E,
+	0x16, 0x91, 0x1F, 0x7E, 0x11, 0xDF, 0x1E, 0x1A,
+	0xAF, 0x0B, 0x17, 0x13, 0x4D, 0xC7, 0x39, 0xC5,
+	0x65, 0x36, 0x07, 0xA1, 0xEC, 0x8D, 0xD3, 0x7A
+};
+static const uint8_t kPcr0Zeroes[DIGEST_BYTES] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static void set_pcr0(const char *param)
+{
+	const uint8_t *pcr0 = kPcr0DebugMode;
+
+	switch (param[0]) {
+	case '0':
+		pcr0 = kPcr0Zeroes;
+		break;
+	case 'n':
+		pcr0 = kPcr0NormalMode;
+		break;
+	case 'r':
+		pcr0 = kPcr0RecoveryNormalMode;
+		break;
+	}
+
+	memcpy(g_dice_config.pcr0, pcr0, DIGEST_BYTES);
+}
+
+int main(int argc, char *argv[])
+{
+#ifdef TEST_PLATFORM
+	printf("BOOT_PARAM_SIZE = %zu\n", BOOT_PARAM_SIZE);
+	printf("DICE_CHAIN_SIZE = %zu\n", DICE_CHAIN_SIZE);
+	test_hkdf();
+	test_sha();
+	test_ecdsa();
+#endif /* TEST_PLATFORM */
+
+	if (argc != 1 + 3) {
+		printf("Syntax: %s <boot_param> <dice_chain> <bootmode>\n"
+		       "  where\n"
+		       "    <boot_param> - filename for writing the "
+		       "BootParam structure\n"
+		       "    <dice_chain> - filename for writing the "
+		       "dice chain structure\n"
+		       "    <bootmode> - sets PCR0 value: when starts with\n"
+		       "        0 = all zeroes\n"
+		       "        n = normal mode\n"
+		       "        r = recovery mode\n"
+		       "        <anything else> = debug mode\n"
+		       "",
+		       argv[0]);
+		return 2;
+	}
+	set_pcr0(argv[3]);
+	return test_boot_param(argv[1], argv[2]) ? 0 : 1;
+}
diff --git a/docs/ti50_firmware_releases.md b/docs/ti50_firmware_releases.md
index dd50d59f0..55e7af8ae 100644
--- a/docs/ti50_firmware_releases.md
+++ b/docs/ti50_firmware_releases.md
@@ -8,7 +8,9 @@ This document captures major feature differences between Ti50 firmware releases
 
 ChromeOS Version    | PrePVT version | Prod Version
 ------------------- | -------------- | ------------
-[ToT][ToT ebuild]   | 0.24.112       | 0.23.112
+[ToT][ToT ebuild]   | 0.24.120       | 0.23.112
+[M130][130 release] | 0.24.112       | 0.23.112
+[M129][129 release] | 0.24.112       | 0.23.112
 [M128][128 release] | 0.24.101       | 0.23.101
 [M127][127 release] | 0.24.101       | 0.23.101
 [M126][126 release] | 0.24.90        | 0.23.90
@@ -1807,6 +1809,31 @@ Build:   ti50_common_tot:v0.0.1414-fd2d8291
     [b/329439532](https://b.corp.google.com/issues/329439532)
 *   Print AP RO verification latch state
 
+### 0.24.120 Released on 2024-09-26 in M131
+
+Release
+[CL](https://chromium-review.googlesource.com/c/chromiumos/overlays/chromiumos-overlay/+/5891857)
+
+Builder
+[firmware-ti50-prepvt-15974.B-branch/14](https://ci.chromium.org/ui/p/chromeos/builders/firmware/firmware-ti50-prepvt-15974.B-branch/14/overview)
+
+Artifacts:
+[15974.14.0](https://pantheon.corp.google.com/storage/browser/chromeos-releases/firmware-ti50-prepvt-15974.B-branch/R129-15974.14.0-1-8736609614553322753/ti50.tar.bz2/)
+
+**Features**
+
+*   MISC SPI host improvements
+    [b/319124176](https://b.corp.google.com/issues/319124176)
+*   Add misc debug prints for I2C and PMU
+
+```
+Build:   ti50_common_prepvt-15974.B:v0.0.92-7f6c1fcb
+         libtock-rs:v0.0.925-1213708
+         tock:v0.0.9676-524942299
+         ms-tpm-20-ref:v0.0.320-cc605af
+         chrome-bot@chromeos-ci-firmware-us-central2-d-x32-1-csf8 2024-09-13 08:58:43
+```
+
 <!-- Links -->
 
 [105 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R105-14989.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
@@ -1833,4 +1860,6 @@ Build:   ti50_common_tot:v0.0.1414-fd2d8291
 [126 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R126-15886.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
 [127 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R127-15917.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
 [128 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R128-15964.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
+[129 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R129-16002.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
+[130 release]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/release-R130-16033.B/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
 [ToT ebuild]: https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/refs/heads/main/chromeos-base/chromeos-ti50/chromeos-ti50-0.0.1.ebuild
diff --git a/extra/usb_updater/gsctool.c b/extra/usb_updater/gsctool.c
index 1e41ba336..e8284c22b 100644
--- a/extra/usb_updater/gsctool.c
+++ b/extra/usb_updater/gsctool.c
@@ -632,7 +632,7 @@ static bool is_ti50_device(void)
 static FILE *tpm_output;
 static int ts_write(const void *out, size_t len)
 {
-	const char *cmd_head = "PATH=\"${PATH}:/usr/sbin\" "
+	const char *cmd_head = "PATH=\"${PATH}:/usr/sbin:/vendor/bin/hw\" "
 			       "${TRUNKS_SEND_BIN:-trunks_send} --raw ";
 	size_t head_size = strlen(cmd_head);
 	char full_command[head_size + 2 * len + 1];
@@ -3244,19 +3244,6 @@ static int process_get_apro_hash(struct transfer_descriptor *td)
 	return 0;
 }
 
-static int process_start_apro_verify(struct transfer_descriptor *td)
-{
-	int rv = 0;
-
-	rv = send_vendor_command(td, VENDOR_CC_AP_RO_VALIDATE, NULL, 0, NULL,
-				 NULL);
-	if (rv != VENDOR_RC_SUCCESS) {
-		fprintf(stderr, "Error %d starting RO verify\n", rv);
-		return update_error;
-	}
-	return 0;
-}
-
 static int process_get_apro_boot_status(struct transfer_descriptor *td)
 {
 	size_t response_size;
@@ -4242,6 +4229,27 @@ static int process_reboot_gsc(struct transfer_descriptor *td, size_t timeout_ms)
 	return 0;
 }
 
+static int process_start_apro_verify(struct transfer_descriptor *td)
+{
+	int rv = 0;
+
+	/*
+	 * For Ti50, we need to restart GSC to perform AP RO verification again.
+	 */
+	if (is_ti50_device())
+		return process_reboot_gsc(td, 1000);
+
+	/* If H1 chip, then send vendor command to start AP RO verification */
+	rv = send_vendor_command(td, VENDOR_CC_AP_RO_VALIDATE, NULL, 0, NULL,
+				 NULL);
+	if (rv != VENDOR_RC_SUCCESS) {
+		fprintf(stderr, "Error %d starting RO verify\n", rv);
+		return update_error;
+	}
+
+	return 0;
+}
+
 /*
  * Search the passed in zero terminated array of options_map structures for
  * option 'option'.
@@ -4740,10 +4748,27 @@ static struct get_chip_id_response get_chip_id_info(
  */
 static enum gsc_device determine_gsc_type(struct transfer_descriptor *td)
 {
+	int epoch;
 	int major;
-	/* First try the newer TPMV command */
-	const struct get_chip_id_response chip_id = get_chip_id_info(td);
+	struct get_chip_id_response chip_id;
 
+	/*
+	 * Get the firmware version first. See if this is a specific GSC version
+	 * where the Ti50 FW does not response with an error code if the host
+	 * tries an unknown TPMV command over USB. This prevents a USB timeout
+	 * and shutting down of USB subsystem within gsctool (b/368631328).
+	 */
+	get_version(td, false);
+	epoch = targ.shv[1].epoch;
+	major = targ.shv[1].major;
+	if ((epoch == 0 || epoch == 1) && (major >= 21 && major <= 26))
+		return GSC_DEVICE_DT;
+	/*
+	 * Try the newer TPMV command. If the command isn't supported,
+	 * then the GSC should respond with an error. If that happens we will
+	 * fall back to the GSC version as the indicator.
+	 */
+	chip_id = get_chip_id_info(td);
 	switch (chip_id.tpm_vid_pid) {
 	case 0x50666666:
 		return GSC_DEVICE_NT;
@@ -4761,7 +4786,6 @@ static enum gsc_device determine_gsc_type(struct transfer_descriptor *td)
 	 * If TPMV command doesn't exist or VID_PID is unrecognized then,
 	 * use the firmware version to determine type.
 	 */
-	get_version(td, false);
 	major = targ.shv[1].major;
 	if (major >= 30 && major < 40)
 		return GSC_DEVICE_NT;
diff --git a/extra/usb_updater/presubmit_hook.sh b/extra/usb_updater/presubmit_hook.sh
new file mode 100755
index 000000000..00091cae7
--- /dev/null
+++ b/extra/usb_updater/presubmit_hook.sh
@@ -0,0 +1,19 @@
+#!/bin/bash
+# Copyright 2024 The ChromiumOS Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+commit=$1
+shift
+files=$*
+
+if [[ ${files} == *"usb_updater"* ]]; then
+  if ! git log -n 1 "${commit}" | \
+     grep -q "gscdevboard.GSCFactoryUpdate"; then
+    echo 'Run and add "TEST=BED=DT make tast' \
+         'TAST_EXPR=gscdevboard.GSCFactoryUpdate.ti50_0_21_1"' \
+         'to commit msg for gsctool changes. See go/gsc-bed to set custom.mk' \
+         'up in a way to work with BED= for local test set up.'
+    exit 1
+  fi
+fi
diff --git a/tpm_generated/Android.bp b/tpm_generated/Android.bp
new file mode 100644
index 000000000..1a475b18f
--- /dev/null
+++ b/tpm_generated/Android.bp
@@ -0,0 +1,35 @@
+// Copyright 2024 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// A library for generating TPM commands and parsing TPM responses. Derived from
+// the Chromium OS trunks daemon's TPM code.
+
+cc_library {
+    name: "libtpmgenerated",
+    host_supported: true,
+    shared_libs: [
+        "libbase",
+        "libcrypto",
+    ],
+    srcs: [
+        "hex.cc",
+        "secure_hash.cc",
+        "tpm_generated.cc",
+    ],
+}
+
+cc_test_host {
+    name: "libtpmgenerated_test",
+    srcs: [
+        "mock_authorization_delegate.cc",
+        "mock_command_transceiver.cc",
+        "tpm_generated_test.cc",
+    ],
+    shared_libs: [
+        "libtpmgenerated",
+    ],
+    static_libs: [
+        "libgmock",
+    ],
+}
diff --git a/tpm_generated/authorization_delegate.h b/tpm_generated/authorization_delegate.h
new file mode 100644
index 000000000..d6fa30d65
--- /dev/null
+++ b/tpm_generated/authorization_delegate.h
@@ -0,0 +1,57 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_AUTHORIZATION_DELEGATE_H_
+#define TRUNKS_AUTHORIZATION_DELEGATE_H_
+
+#include <string>
+
+namespace trunks {
+
+inline constexpr uint8_t kContinueSession = 1;
+
+// AuthorizationDelegate is an interface passed to TPM commands. The delegate
+// takes care of providing the authorization data for commands and verifying
+// authorization data for responses. It also handles parameter encryption for
+// commands and parameter decryption for responses.
+class AuthorizationDelegate {
+ public:
+  AuthorizationDelegate() {}
+  AuthorizationDelegate(const AuthorizationDelegate&) = delete;
+  AuthorizationDelegate& operator=(const AuthorizationDelegate&) = delete;
+
+  virtual ~AuthorizationDelegate() {}
+
+  // Provides authorization data for a command which has a cpHash value of
+  // |command_hash|. The availability of encryption for the command is indicated
+  // by |is_*_parameter_encryption_possible|. On success, |authorization| is
+  // populated with the exact octets for the Authorization Area of the command.
+  // Returns true on success.
+  virtual bool GetCommandAuthorization(
+      const std::string& command_hash,
+      bool is_command_parameter_encryption_possible,
+      bool is_response_parameter_encryption_possible,
+      std::string* authorization) = 0;
+
+  // Checks authorization data for a response which has a rpHash value of
+  // |response_hash|. The exact octets from the Authorization Area of the
+  // response are given in |authorization|. Returns true iff the authorization
+  // is valid.
+  virtual bool CheckResponseAuthorization(const std::string& response_hash,
+                                          const std::string& authorization) = 0;
+
+  // Encrypts |parameter| if encryption is enabled. Returns true on success.
+  virtual bool EncryptCommandParameter(std::string* parameter) = 0;
+
+  // Decrypts |parameter| if encryption is enabled. Returns true on success.
+  virtual bool DecryptResponseParameter(std::string* parameter) = 0;
+
+  // Returns the current TPM-generated nonce that is associated with the
+  // authorization session. Returns true on success.
+  virtual bool GetTpmNonce(std::string* nonce) = 0;
+};
+
+}  // namespace trunks
+
+#endif  // TRUNKS_AUTHORIZATION_DELEGATE_H_
diff --git a/tpm_generated/callback.h b/tpm_generated/callback.h
new file mode 100644
index 000000000..d3a20ac43
--- /dev/null
+++ b/tpm_generated/callback.h
@@ -0,0 +1,50 @@
+// Copyright 2024 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TPM_GENERATED_CALLBACK_H_
+#define TPM_GENERATED_CALLBACK_H_
+
+// tpm_generated was designed to use libchrome, but we can't use libchrome in
+// AOSP. This implements just enough of libchrome's callback functionality to
+// make tpm_generated work.
+
+#include <functional>
+
+namespace trunks {
+
+template <typename Signature>
+class OnceCallback;
+
+template <typename R, typename... Args>
+class OnceCallback<R(Args...)> {
+ public:
+  OnceCallback(std::function<R(Args...)> function) : inner_(function) {}
+
+  R Run(Args... args) && { return inner_(args...); }
+
+ private:
+  std::function<R(Args...)> inner_;
+};
+
+template <typename R, typename Arg1, typename... Remaining>
+OnceCallback<R(Remaining...)> BindOnce(R (*callback)(Arg1, Remaining...),
+                                       Arg1 arg1) {
+  return OnceCallback<R(Remaining...)>(
+      [callback, arg1](Remaining... remaining) {
+        return callback(arg1, remaining...);
+      });
+}
+
+template <typename R, typename Arg1, typename Arg2, typename... Remaining>
+OnceCallback<R(Remaining...)> BindOnce(R (*callback)(Arg1, Arg2, Remaining...),
+                                       Arg1 arg1, Arg2 arg2) {
+  return OnceCallback<R(Remaining...)>(
+      [callback, arg1, arg2](Remaining... remaining) {
+        return callback(arg1, arg2, remaining...);
+      });
+}
+
+}  // namespace trunks
+
+#endif  // TPM_GENERATED_CALLBACK_H_
diff --git a/tpm_generated/command_transceiver.h b/tpm_generated/command_transceiver.h
new file mode 100644
index 000000000..2ce89c4c1
--- /dev/null
+++ b/tpm_generated/command_transceiver.h
@@ -0,0 +1,58 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_COMMAND_TRANSCEIVER_H_
+#define TRUNKS_COMMAND_TRANSCEIVER_H_
+
+#include <string>
+#include <utility>
+
+#include "callback.h"
+
+namespace trunks {
+
+// CommandTransceiver is an interface that sends commands to a TPM device and
+// receives responses. It can operate synchronously or asynchronously.
+class CommandTransceiver {
+ public:
+  typedef trunks::OnceCallback<void(const std::string& response)>
+      ResponseCallback;
+
+  virtual ~CommandTransceiver() {}
+
+  // Sends a TPM |command| asynchronously. When a |response| is received,
+  // |callback| will be called with the |response| data from the TPM. If a
+  // transmission error occurs |callback| will be called with a well-formed
+  // error |response|.
+  virtual void SendCommand(const std::string& command,
+                           ResponseCallback callback) = 0;
+
+  // Sends a TPM |command| synchronously (i.e. waits for a response) and returns
+  // the response. If a transmission error occurs the response will be populated
+  // with a well-formed error response.
+  virtual std::string SendCommandAndWait(const std::string& command) = 0;
+
+  // Similar to the SendCommand, but we add an extra sender information.
+  // By default, it will fallback to the normal implementation.
+  virtual void SendCommandWithSender(const std::string& command,
+                                     uint64_t sender,
+                                     ResponseCallback callback) {
+    return SendCommand(command, std::move(callback));
+  }
+
+  // Similar to the SendCommandAndWait, but we add an extra sender information.
+  // By default, it will fallback to the normal implementation.
+  virtual std::string SendCommandWithSenderAndWait(const std::string& command,
+                                                   uint64_t sender) {
+    return SendCommandAndWait(command);
+  }
+
+  // Initializes the actual interface, replaced by the derived classes, where
+  // needed.
+  virtual bool Init() { return true; }
+};
+
+}  // namespace trunks
+
+#endif  // TRUNKS_COMMAND_TRANSCEIVER_H_
diff --git a/tpm_generated/error_codes.h b/tpm_generated/error_codes.h
new file mode 100644
index 000000000..cd3e10044
--- /dev/null
+++ b/tpm_generated/error_codes.h
@@ -0,0 +1,88 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_ERROR_CODES_H_
+#define TRUNKS_ERROR_CODES_H_
+
+#include <string>
+
+#include "tpm_generated.h"  // For TPM_RC.
+#include "trunks_export.h"
+
+namespace trunks {
+
+// Use the TPM_RC type but with different layer bits (12 - 15). Choose the layer
+// value arbitrarily. Currently TSS2 uses 9 for TCTI and 8 for SAPI.
+// TCTI and SAPI error codes taken from
+// http://www.trustedcomputinggroup.org/resources/
+// tss_system_level_api_and_tpm_command_transmission_interface_specification
+const TPM_RC kTrunksErrorBase = (7 << 12);
+const TPM_RC kTctiErrorBase = (8 << 12);
+const TPM_RC kSapiErrorBase = (9 << 12);
+const TPM_RC kResourceManagerTpmErrorBase = (11 << 12);
+const TPM_RC kResourceManagerErrorBase = (12 << 12);
+
+// Note that the trunks error layer is shared with the unified error code in
+// TPMError and related classes, see libhwsec/error/tpm_error.h for more info.
+// From the perspective of trunks, trunks can only use kTrunksErrorBase + 0 up
+// to kTrunksErrorBase + 1023. The other 3072 error code is reserved for use by
+// the TPMError and related classes.
+const TPM_RC TRUNKS_RC_AUTHORIZATION_FAILED = kTrunksErrorBase + 1;
+const TPM_RC TRUNKS_RC_ENCRYPTION_FAILED = kTrunksErrorBase + 2;
+const TPM_RC TRUNKS_RC_READ_ERROR = kTrunksErrorBase + 3;
+const TPM_RC TRUNKS_RC_WRITE_ERROR = kTrunksErrorBase + 4;
+const TPM_RC TRUNKS_RC_IPC_ERROR = kTrunksErrorBase + 5;
+const TPM_RC TRUNKS_RC_SESSION_SETUP_ERROR = kTrunksErrorBase + 6;
+const TPM_RC TRUNKS_RC_INVALID_TPM_CONFIGURATION = kTrunksErrorBase + 7;
+const TPM_RC TRUNKS_RC_PARSE_ERROR = kTrunksErrorBase + 8;
+
+const TPM_RC TCTI_RC_TRY_AGAIN = kTctiErrorBase + 1;
+const TPM_RC TCTI_RC_GENERAL_FAILURE = kTctiErrorBase + 2;
+const TPM_RC TCTI_RC_BAD_CONTEXT = kTctiErrorBase + 3;
+const TPM_RC TCTI_RC_WRONG_ABI_VERSION = kTctiErrorBase + 4;
+const TPM_RC TCTI_RC_NOT_IMPLEMENTED = kTctiErrorBase + 5;
+const TPM_RC TCTI_RC_BAD_PARAMETER = kTctiErrorBase + 6;
+const TPM_RC TCTI_RC_INSUFFICIENT_BUFFER = kTctiErrorBase + 7;
+const TPM_RC TCTI_RC_NO_CONNECTION = kTctiErrorBase + 8;
+const TPM_RC TCTI_RC_DRIVER_NOT_FOUND = kTctiErrorBase + 9;
+const TPM_RC TCTI_RC_DRIVERINFO_NOT_FOUND = kTctiErrorBase + 10;
+const TPM_RC TCTI_RC_NO_RESPONSE = kTctiErrorBase + 11;
+const TPM_RC TCTI_RC_BAD_VALUE = kTctiErrorBase + 12;
+
+const TPM_RC SAPI_RC_INVALID_SESSIONS = kSapiErrorBase + 1;
+const TPM_RC SAPI_RC_ABI_MISMATCH = kSapiErrorBase + 2;
+const TPM_RC SAPI_RC_INSUFFICIENT_BUFFER = kSapiErrorBase + 3;
+const TPM_RC SAPI_RC_BAD_PARAMETER = kSapiErrorBase + 4;
+const TPM_RC SAPI_RC_BAD_SEQUENCE = kSapiErrorBase + 5;
+const TPM_RC SAPI_RC_NO_DECRYPT_PARAM = kSapiErrorBase + 6;
+const TPM_RC SAPI_RC_NO_ENCRYPT_PARAM = kSapiErrorBase + 7;
+const TPM_RC SAPI_RC_NO_RESPONSE_RECEIVED = kSapiErrorBase + 8;
+const TPM_RC SAPI_RC_BAD_SIZE = kSapiErrorBase + 9;
+const TPM_RC SAPI_RC_CORRUPTED_DATA = kSapiErrorBase + 10;
+const TPM_RC SAPI_RC_INSUFFICIENT_CONTEXT = kSapiErrorBase + 11;
+const TPM_RC SAPI_RC_INSUFFICIENT_RESPONSE = kSapiErrorBase + 12;
+const TPM_RC SAPI_RC_INCOMPATIBLE_TCTI = kSapiErrorBase + 13;
+const TPM_RC SAPI_RC_MALFORMED_RESPONSE = kSapiErrorBase + 14;
+const TPM_RC SAPI_RC_BAD_TCTI_STRUCTURE = kSapiErrorBase + 15;
+const TPM_RC SAPI_RC_NO_CONNECTION = kSapiErrorBase + 16;
+
+// Returns a description of |error|.
+TRUNKS_EXPORT std::string GetErrorString(TPM_RC error);
+
+// Strips the P and N bits from a 'format one' error. If the given error code
+// is not a format one error, it is returned as is. The error that is returned
+// can be compared to TPM_RC_* constant values. See TPM 2.0 Part 2 Section 6.6
+// for details on format one errors.
+TRUNKS_EXPORT TPM_RC GetFormatOneError(TPM_RC error);
+
+// Creates a well-formed response with the given |error_code|.
+TRUNKS_EXPORT std::string CreateErrorResponse(TPM_RC error_code);
+
+// Retrieves response code, |rc|, from the response string, |response|.
+// Return TPM_RC_SUCCESS iff success.
+TRUNKS_EXPORT TPM_RC GetResponseCode(const std::string& response, TPM_RC& rc);
+
+}  // namespace trunks
+
+#endif  // TRUNKS_ERROR_CODES_H_
diff --git a/tpm_generated/hex.cc b/tpm_generated/hex.cc
new file mode 100644
index 000000000..34cb9e2aa
--- /dev/null
+++ b/tpm_generated/hex.cc
@@ -0,0 +1,21 @@
+// Copyright 2024 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "hex.h"
+
+namespace trunks {
+
+std::string HexEncode(const char* data, std::size_t len) {
+  static constexpr char kHexChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
+                                       '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+  std::string ret;
+  ret.reserve(len * 2);
+  for (int i = 0; i < len; i++) {
+    ret.push_back(kHexChars[data[i] >> 4]);
+    ret.push_back(kHexChars[data[i] & 0xf]);
+  }
+  return ret;
+}
+
+}  // namespace trunks
diff --git a/tpm_generated/hex.h b/tpm_generated/hex.h
new file mode 100644
index 000000000..7f1d19444
--- /dev/null
+++ b/tpm_generated/hex.h
@@ -0,0 +1,16 @@
+// Copyright 2024 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TPM_GENERATED_HEX_H_
+#define TPM_GENERATED_HEX_H_
+
+#include <string>
+
+namespace trunks {
+
+std::string HexEncode(const char* data, std::size_t len);
+
+}  // namespace trunks
+
+#endif  // TPM_GENERATED_HEX_H_
diff --git a/tpm_generated/mock_authorization_delegate.cc b/tpm_generated/mock_authorization_delegate.cc
new file mode 100644
index 000000000..20c1c21e5
--- /dev/null
+++ b/tpm_generated/mock_authorization_delegate.cc
@@ -0,0 +1,12 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "mock_authorization_delegate.h"
+
+namespace trunks {
+
+MockAuthorizationDelegate::MockAuthorizationDelegate() {}
+MockAuthorizationDelegate::~MockAuthorizationDelegate() {}
+
+}  // namespace trunks
diff --git a/tpm_generated/mock_authorization_delegate.h b/tpm_generated/mock_authorization_delegate.h
new file mode 100644
index 000000000..19fe16c2b
--- /dev/null
+++ b/tpm_generated/mock_authorization_delegate.h
@@ -0,0 +1,36 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_MOCK_AUTHORIZATION_DELEGATE_H_
+#define TRUNKS_MOCK_AUTHORIZATION_DELEGATE_H_
+
+#include <string>
+
+#include <gmock/gmock.h>
+
+#include "authorization_delegate.h"
+
+namespace trunks {
+
+class MockAuthorizationDelegate : public AuthorizationDelegate {
+ public:
+  MockAuthorizationDelegate();
+  MockAuthorizationDelegate(const MockAuthorizationDelegate&) = delete;
+  MockAuthorizationDelegate& operator=(const MockAuthorizationDelegate&) =
+      delete;
+
+  ~MockAuthorizationDelegate() override;
+
+  MOCK_METHOD4(GetCommandAuthorization,
+               bool(const std::string&, bool, bool, std::string*));
+  MOCK_METHOD2(CheckResponseAuthorization,
+               bool(const std::string&, const std::string&));
+  MOCK_METHOD1(EncryptCommandParameter, bool(std::string*));
+  MOCK_METHOD1(DecryptResponseParameter, bool(std::string*));
+  MOCK_METHOD1(GetTpmNonce, bool(std::string*));
+};
+
+}  // namespace trunks
+
+#endif  // TRUNKS_MOCK_AUTHORIZATION_DELEGATE_H_
diff --git a/tpm_generated/mock_command_transceiver.cc b/tpm_generated/mock_command_transceiver.cc
new file mode 100644
index 000000000..58f867171
--- /dev/null
+++ b/tpm_generated/mock_command_transceiver.cc
@@ -0,0 +1,12 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "mock_command_transceiver.h"
+
+namespace trunks {
+
+MockCommandTransceiver::MockCommandTransceiver() {}
+MockCommandTransceiver::~MockCommandTransceiver() {}
+
+}  // namespace trunks
diff --git a/tpm_generated/mock_command_transceiver.h b/tpm_generated/mock_command_transceiver.h
new file mode 100644
index 000000000..c69cacc2a
--- /dev/null
+++ b/tpm_generated/mock_command_transceiver.h
@@ -0,0 +1,30 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_MOCK_COMMAND_TRANSCEIVER_H_
+#define TRUNKS_MOCK_COMMAND_TRANSCEIVER_H_
+
+#include <string>
+
+#include <gmock/gmock.h>
+
+#include "command_transceiver.h"
+
+namespace trunks {
+
+class MockCommandTransceiver : public CommandTransceiver {
+ public:
+  MockCommandTransceiver();
+  MockCommandTransceiver(const MockCommandTransceiver&) = delete;
+  MockCommandTransceiver& operator=(const MockCommandTransceiver&) = delete;
+
+  ~MockCommandTransceiver() override;
+
+  MOCK_METHOD2(SendCommand, void(const std::string&, ResponseCallback));
+  MOCK_METHOD1(SendCommandAndWait, std::string(const std::string&));
+};
+
+}  // namespace trunks
+
+#endif  // TRUNKS_MOCK_COMMAND_TRANSCEIVER_H_
diff --git a/tpm_generated/secure_hash.cc b/tpm_generated/secure_hash.cc
new file mode 100644
index 000000000..d27beffd1
--- /dev/null
+++ b/tpm_generated/secure_hash.cc
@@ -0,0 +1,66 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "secure_hash.h"
+
+#if defined(OPENSSL_IS_BORINGSSL)
+#include <openssl/mem.h>
+#else
+#include <openssl/crypto.h>
+#endif
+#include <openssl/sha.h>
+#include <stddef.h>
+
+#include <android-base/logging.h>
+
+namespace crypto {
+
+namespace {
+
+class SecureHashSHA256 : public SecureHash {
+ public:
+  SecureHashSHA256() {
+    SHA256_Init(&ctx_);
+  }
+
+  SecureHashSHA256(const SecureHashSHA256& other) : SecureHash() {
+    memcpy(&ctx_, &other.ctx_, sizeof(ctx_));
+  }
+
+  ~SecureHashSHA256() override {
+    OPENSSL_cleanse(&ctx_, sizeof(ctx_));
+  }
+
+  void Update(const void* input, size_t len) override {
+    SHA256_Update(&ctx_, static_cast<const unsigned char*>(input), len);
+  }
+
+  void Finish(void* output, size_t len) override {
+    CHECK(len >= SHA256_DIGEST_LENGTH);
+    SHA256_Final(static_cast<uint8_t*>(output), &ctx_);
+  }
+
+  SecureHash* Clone() const override {
+    return new SecureHashSHA256(*this);
+  }
+
+  size_t GetHashLength() const override { return SHA256_DIGEST_LENGTH; }
+
+ private:
+  SHA256_CTX ctx_;
+};
+
+}  // namespace
+
+SecureHash* SecureHash::Create(Algorithm algorithm) {
+  switch (algorithm) {
+    case SHA256:
+      return new SecureHashSHA256();
+    default:
+      LOG(ERROR) << "SecureHash not implemented for algorithm " << algorithm;
+      return NULL;
+  }
+}
+
+}  // namespace crypto
diff --git a/tpm_generated/secure_hash.h b/tpm_generated/secure_hash.h
new file mode 100644
index 000000000..17eb9c860
--- /dev/null
+++ b/tpm_generated/secure_hash.h
@@ -0,0 +1,42 @@
+// Copyright 2012 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CRYPTO_SECURE_HASH_H_
+#define CRYPTO_SECURE_HASH_H_
+
+#include <stddef.h>
+
+namespace crypto {
+
+// A wrapper to calculate secure hashes incrementally, allowing to
+// be used when the full input is not known in advance.
+class SecureHash {
+ public:
+  enum Algorithm {
+    SHA256,
+  };
+
+  SecureHash(const SecureHash&) = delete;
+  SecureHash& operator=(const SecureHash&) = delete;
+
+  virtual ~SecureHash() {}
+
+  static SecureHash* Create(Algorithm type);
+
+  virtual void Update(const void* input, size_t len) = 0;
+  virtual void Finish(void* output, size_t len) = 0;
+  virtual size_t GetHashLength() const = 0;
+
+  // Create a clone of this SecureHash. The returned clone and this both
+  // represent the same hash state. But from this point on, calling
+  // Update()/Finish() on either doesn't affect the state of the other.
+  virtual SecureHash* Clone() const = 0;
+
+ protected:
+  SecureHash() {}
+};
+
+}  // namespace crypto
+
+#endif  // CRYPTO_SECURE_HASH_H_
diff --git a/tpm_generated/tpm_generated.cc b/tpm_generated/tpm_generated.cc
new file mode 100644
index 000000000..b4ff3e122
--- /dev/null
+++ b/tpm_generated/tpm_generated.cc
@@ -0,0 +1,33740 @@
+// Copyright 2015 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// THIS CODE IS GENERATED - DO NOT MODIFY!
+
+#include "tpm_generated.h"
+
+#include <iterator>
+#include <memory>
+#include <string>
+
+#include <android-base/endian.h>
+#include <android-base/logging.h>
+#include <secure_hash.h>
+
+#include "authorization_delegate.h"
+#include "callback.h"
+#include "command_transceiver.h"
+#include "error_codes.h"
+
+// Redirect VLOG invocations written for libchrome to android-base's LOG macro.
+#define VLOG(x) LOG(INFO)
+
+namespace trunks {
+
+size_t GetNumberOfRequestHandles(TPM_CC command_code) {
+  switch (command_code) {
+    case TPM_CC_Startup:
+      return 0;
+    case TPM_CC_Shutdown:
+      return 0;
+    case TPM_CC_SelfTest:
+      return 0;
+    case TPM_CC_IncrementalSelfTest:
+      return 0;
+    case TPM_CC_GetTestResult:
+      return 0;
+    case TPM_CC_StartAuthSession:
+      return 2;
+    case TPM_CC_PolicyRestart:
+      return 1;
+    case TPM_CC_Create:
+      return 1;
+    case TPM_CC_Load:
+      return 1;
+    case TPM_CC_LoadExternal:
+      return 0;
+    case TPM_CC_ReadPublic:
+      return 1;
+    case TPM_CC_ActivateCredential:
+      return 2;
+    case TPM_CC_MakeCredential:
+      return 1;
+    case TPM_CC_Unseal:
+      return 1;
+    case TPM_CC_ObjectChangeAuth:
+      return 2;
+    case TPM_CC_Duplicate:
+      return 2;
+    case TPM_CC_Rewrap:
+      return 2;
+    case TPM_CC_Import:
+      return 1;
+    case TPM_CC_RSA_Encrypt:
+      return 1;
+    case TPM_CC_RSA_Decrypt:
+      return 1;
+    case TPM_CC_ECDH_KeyGen:
+      return 1;
+    case TPM_CC_ECDH_ZGen:
+      return 1;
+    case TPM_CC_ECC_Parameters:
+      return 0;
+    case TPM_CC_ZGen_2Phase:
+      return 1;
+    case TPM_CC_EncryptDecrypt:
+      return 1;
+    case TPM_CC_Hash:
+      return 0;
+    case TPM_CC_HMAC:
+      return 1;
+    case TPM_CC_GetRandom:
+      return 0;
+    case TPM_CC_StirRandom:
+      return 0;
+    case TPM_CC_HMAC_Start:
+      return 1;
+    case TPM_CC_HashSequenceStart:
+      return 0;
+    case TPM_CC_SequenceUpdate:
+      return 1;
+    case TPM_CC_SequenceComplete:
+      return 1;
+    case TPM_CC_EventSequenceComplete:
+      return 2;
+    case TPM_CC_Certify:
+      return 2;
+    case TPM_CC_CertifyCreation:
+      return 2;
+    case TPM_CC_Quote:
+      return 1;
+    case TPM_CC_GetSessionAuditDigest:
+      return 3;
+    case TPM_CC_GetCommandAuditDigest:
+      return 2;
+    case TPM_CC_GetTime:
+      return 2;
+    case TPM_CC_Commit:
+      return 1;
+    case TPM_CC_EC_Ephemeral:
+      return 0;
+    case TPM_CC_VerifySignature:
+      return 1;
+    case TPM_CC_Sign:
+      return 1;
+    case TPM_CC_SetCommandCodeAuditStatus:
+      return 1;
+    case TPM_CC_PCR_Extend:
+      return 1;
+    case TPM_CC_PCR_Event:
+      return 1;
+    case TPM_CC_PCR_Read:
+      return 0;
+    case TPM_CC_PCR_Allocate:
+      return 1;
+    case TPM_CC_PCR_SetAuthPolicy:
+      return 2;
+    case TPM_CC_PCR_SetAuthValue:
+      return 1;
+    case TPM_CC_PCR_Reset:
+      return 1;
+    case TPM_CC_PolicySigned:
+      return 2;
+    case TPM_CC_PolicySecret:
+      return 2;
+    case TPM_CC_PolicyTicket:
+      return 1;
+    case TPM_CC_PolicyOR:
+      return 1;
+    case TPM_CC_PolicyPCR:
+      return 1;
+    case TPM_CC_PolicyLocality:
+      return 1;
+    case TPM_CC_PolicyNV:
+      return 3;
+    case TPM_CC_PolicyCounterTimer:
+      return 1;
+    case TPM_CC_PolicyCommandCode:
+      return 1;
+    case TPM_CC_PolicyPhysicalPresence:
+      return 1;
+    case TPM_CC_PolicyCpHash:
+      return 1;
+    case TPM_CC_PolicyNameHash:
+      return 1;
+    case TPM_CC_PolicyDuplicationSelect:
+      return 1;
+    case TPM_CC_PolicyAuthorize:
+      return 1;
+    case TPM_CC_PolicyAuthValue:
+      return 1;
+    case TPM_CC_PolicyPassword:
+      return 1;
+    case TPM_CC_PolicyGetDigest:
+      return 1;
+    case TPM_CC_PolicyNvWritten:
+      return 1;
+    case TPM_CC_CreatePrimary:
+      return 1;
+    case TPM_CC_HierarchyControl:
+      return 1;
+    case TPM_CC_SetPrimaryPolicy:
+      return 1;
+    case TPM_CC_ChangePPS:
+      return 1;
+    case TPM_CC_ChangeEPS:
+      return 1;
+    case TPM_CC_Clear:
+      return 1;
+    case TPM_CC_ClearControl:
+      return 1;
+    case TPM_CC_HierarchyChangeAuth:
+      return 1;
+    case TPM_CC_DictionaryAttackLockReset:
+      return 1;
+    case TPM_CC_DictionaryAttackParameters:
+      return 1;
+    case TPM_CC_PP_Commands:
+      return 1;
+    case TPM_CC_SetAlgorithmSet:
+      return 1;
+    case TPM_CC_FieldUpgradeStart:
+      return 2;
+    case TPM_CC_FieldUpgradeData:
+      return 0;
+    case TPM_CC_FirmwareRead:
+      return 0;
+    case TPM_CC_ContextSave:
+      return 1;
+    case TPM_CC_ContextLoad:
+      return 0;
+    case TPM_CC_FlushContext:
+      return 0;
+    case TPM_CC_EvictControl:
+      return 2;
+    case TPM_CC_ReadClock:
+      return 0;
+    case TPM_CC_ClockSet:
+      return 1;
+    case TPM_CC_ClockRateAdjust:
+      return 1;
+    case TPM_CC_GetCapability:
+      return 0;
+    case TPM_CC_TestParms:
+      return 0;
+    case TPM_CC_NV_DefineSpace:
+      return 1;
+    case TPM_CC_NV_UndefineSpace:
+      return 2;
+    case TPM_CC_NV_UndefineSpaceSpecial:
+      return 2;
+    case TPM_CC_NV_ReadPublic:
+      return 1;
+    case TPM_CC_NV_Write:
+      return 2;
+    case TPM_CC_NV_Increment:
+      return 2;
+    case TPM_CC_NV_Extend:
+      return 2;
+    case TPM_CC_NV_SetBits:
+      return 2;
+    case TPM_CC_NV_WriteLock:
+      return 2;
+    case TPM_CC_NV_GlobalWriteLock:
+      return 1;
+    case TPM_CC_NV_Read:
+      return 2;
+    case TPM_CC_NV_ReadLock:
+      return 2;
+    case TPM_CC_NV_ChangeAuth:
+      return 1;
+    case TPM_CC_NV_Certify:
+      return 3;
+    case TPM_CCE_PolicyFidoSigned:
+      return 2;
+    default:
+      LOG(WARNING) << "Unknown command code: " << command_code;
+  }
+  return 0;
+}
+
+size_t GetNumberOfResponseHandles(TPM_CC command_code) {
+  switch (command_code) {
+    case TPM_CC_Startup:
+      return 0;
+    case TPM_CC_Shutdown:
+      return 0;
+    case TPM_CC_SelfTest:
+      return 0;
+    case TPM_CC_IncrementalSelfTest:
+      return 0;
+    case TPM_CC_GetTestResult:
+      return 0;
+    case TPM_CC_StartAuthSession:
+      return 1;
+    case TPM_CC_PolicyRestart:
+      return 0;
+    case TPM_CC_Create:
+      return 0;
+    case TPM_CC_Load:
+      return 1;
+    case TPM_CC_LoadExternal:
+      return 1;
+    case TPM_CC_ReadPublic:
+      return 0;
+    case TPM_CC_ActivateCredential:
+      return 0;
+    case TPM_CC_MakeCredential:
+      return 0;
+    case TPM_CC_Unseal:
+      return 0;
+    case TPM_CC_ObjectChangeAuth:
+      return 0;
+    case TPM_CC_Duplicate:
+      return 0;
+    case TPM_CC_Rewrap:
+      return 0;
+    case TPM_CC_Import:
+      return 0;
+    case TPM_CC_RSA_Encrypt:
+      return 0;
+    case TPM_CC_RSA_Decrypt:
+      return 0;
+    case TPM_CC_ECDH_KeyGen:
+      return 0;
+    case TPM_CC_ECDH_ZGen:
+      return 0;
+    case TPM_CC_ECC_Parameters:
+      return 0;
+    case TPM_CC_ZGen_2Phase:
+      return 0;
+    case TPM_CC_EncryptDecrypt:
+      return 0;
+    case TPM_CC_Hash:
+      return 0;
+    case TPM_CC_HMAC:
+      return 0;
+    case TPM_CC_GetRandom:
+      return 0;
+    case TPM_CC_StirRandom:
+      return 0;
+    case TPM_CC_HMAC_Start:
+      return 1;
+    case TPM_CC_HashSequenceStart:
+      return 1;
+    case TPM_CC_SequenceUpdate:
+      return 0;
+    case TPM_CC_SequenceComplete:
+      return 0;
+    case TPM_CC_EventSequenceComplete:
+      return 0;
+    case TPM_CC_Certify:
+      return 0;
+    case TPM_CC_CertifyCreation:
+      return 0;
+    case TPM_CC_Quote:
+      return 0;
+    case TPM_CC_GetSessionAuditDigest:
+      return 0;
+    case TPM_CC_GetCommandAuditDigest:
+      return 0;
+    case TPM_CC_GetTime:
+      return 0;
+    case TPM_CC_Commit:
+      return 0;
+    case TPM_CC_EC_Ephemeral:
+      return 0;
+    case TPM_CC_VerifySignature:
+      return 0;
+    case TPM_CC_Sign:
+      return 0;
+    case TPM_CC_SetCommandCodeAuditStatus:
+      return 0;
+    case TPM_CC_PCR_Extend:
+      return 0;
+    case TPM_CC_PCR_Event:
+      return 0;
+    case TPM_CC_PCR_Read:
+      return 0;
+    case TPM_CC_PCR_Allocate:
+      return 0;
+    case TPM_CC_PCR_SetAuthPolicy:
+      return 0;
+    case TPM_CC_PCR_SetAuthValue:
+      return 0;
+    case TPM_CC_PCR_Reset:
+      return 0;
+    case TPM_CC_PolicySigned:
+      return 0;
+    case TPM_CC_PolicySecret:
+      return 0;
+    case TPM_CC_PolicyTicket:
+      return 0;
+    case TPM_CC_PolicyOR:
+      return 0;
+    case TPM_CC_PolicyPCR:
+      return 0;
+    case TPM_CC_PolicyLocality:
+      return 0;
+    case TPM_CC_PolicyNV:
+      return 0;
+    case TPM_CC_PolicyCounterTimer:
+      return 0;
+    case TPM_CC_PolicyCommandCode:
+      return 0;
+    case TPM_CC_PolicyPhysicalPresence:
+      return 0;
+    case TPM_CC_PolicyCpHash:
+      return 0;
+    case TPM_CC_PolicyNameHash:
+      return 0;
+    case TPM_CC_PolicyDuplicationSelect:
+      return 0;
+    case TPM_CC_PolicyAuthorize:
+      return 0;
+    case TPM_CC_PolicyAuthValue:
+      return 0;
+    case TPM_CC_PolicyPassword:
+      return 0;
+    case TPM_CC_PolicyGetDigest:
+      return 0;
+    case TPM_CC_PolicyNvWritten:
+      return 0;
+    case TPM_CC_CreatePrimary:
+      return 1;
+    case TPM_CC_HierarchyControl:
+      return 0;
+    case TPM_CC_SetPrimaryPolicy:
+      return 0;
+    case TPM_CC_ChangePPS:
+      return 0;
+    case TPM_CC_ChangeEPS:
+      return 0;
+    case TPM_CC_Clear:
+      return 0;
+    case TPM_CC_ClearControl:
+      return 0;
+    case TPM_CC_HierarchyChangeAuth:
+      return 0;
+    case TPM_CC_DictionaryAttackLockReset:
+      return 0;
+    case TPM_CC_DictionaryAttackParameters:
+      return 0;
+    case TPM_CC_PP_Commands:
+      return 0;
+    case TPM_CC_SetAlgorithmSet:
+      return 0;
+    case TPM_CC_FieldUpgradeStart:
+      return 0;
+    case TPM_CC_FieldUpgradeData:
+      return 0;
+    case TPM_CC_FirmwareRead:
+      return 0;
+    case TPM_CC_ContextSave:
+      return 0;
+    case TPM_CC_ContextLoad:
+      return 1;
+    case TPM_CC_FlushContext:
+      return 0;
+    case TPM_CC_EvictControl:
+      return 0;
+    case TPM_CC_ReadClock:
+      return 0;
+    case TPM_CC_ClockSet:
+      return 0;
+    case TPM_CC_ClockRateAdjust:
+      return 0;
+    case TPM_CC_GetCapability:
+      return 0;
+    case TPM_CC_TestParms:
+      return 0;
+    case TPM_CC_NV_DefineSpace:
+      return 0;
+    case TPM_CC_NV_UndefineSpace:
+      return 0;
+    case TPM_CC_NV_UndefineSpaceSpecial:
+      return 0;
+    case TPM_CC_NV_ReadPublic:
+      return 0;
+    case TPM_CC_NV_Write:
+      return 0;
+    case TPM_CC_NV_Increment:
+      return 0;
+    case TPM_CC_NV_Extend:
+      return 0;
+    case TPM_CC_NV_SetBits:
+      return 0;
+    case TPM_CC_NV_WriteLock:
+      return 0;
+    case TPM_CC_NV_GlobalWriteLock:
+      return 0;
+    case TPM_CC_NV_Read:
+      return 0;
+    case TPM_CC_NV_ReadLock:
+      return 0;
+    case TPM_CC_NV_ChangeAuth:
+      return 0;
+    case TPM_CC_NV_Certify:
+      return 0;
+    case TPM_CCE_PolicyFidoSigned:
+      return 0;
+    default:
+      LOG(WARNING) << "Unknown command code: " << command_code;
+  }
+  return 0;
+}
+
+TPM_RC Serialize_uint8_t(const uint8_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  uint8_t value_net = value;
+  switch (sizeof(uint8_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(uint8_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_uint8_t(std::string* buffer,
+                     uint8_t* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(uint8_t))
+    return TPM_RC_INSUFFICIENT;
+  uint8_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(uint8_t));
+  switch (sizeof(uint8_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(uint8_t)));
+  }
+  buffer->erase(0, sizeof(uint8_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_int8_t(const int8_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  int8_t value_net = value;
+  switch (sizeof(int8_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(int8_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_int8_t(std::string* buffer,
+                    int8_t* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(int8_t))
+    return TPM_RC_INSUFFICIENT;
+  int8_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(int8_t));
+  switch (sizeof(int8_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(int8_t)));
+  }
+  buffer->erase(0, sizeof(int8_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_int(const int& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  int value_net = value;
+  switch (sizeof(int)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(int));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_int(std::string* buffer, int* value, std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(int))
+    return TPM_RC_INSUFFICIENT;
+  int value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(int));
+  switch (sizeof(int)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(int)));
+  }
+  buffer->erase(0, sizeof(int));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_uint16_t(const uint16_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  uint16_t value_net = value;
+  switch (sizeof(uint16_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(uint16_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_uint16_t(std::string* buffer,
+                      uint16_t* value,
+                      std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(uint16_t))
+    return TPM_RC_INSUFFICIENT;
+  uint16_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(uint16_t));
+  switch (sizeof(uint16_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(uint16_t)));
+  }
+  buffer->erase(0, sizeof(uint16_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_int16_t(const int16_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  int16_t value_net = value;
+  switch (sizeof(int16_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(int16_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_int16_t(std::string* buffer,
+                     int16_t* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(int16_t))
+    return TPM_RC_INSUFFICIENT;
+  int16_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(int16_t));
+  switch (sizeof(int16_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(int16_t)));
+  }
+  buffer->erase(0, sizeof(int16_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_uint32_t(const uint32_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  uint32_t value_net = value;
+  switch (sizeof(uint32_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(uint32_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_uint32_t(std::string* buffer,
+                      uint32_t* value,
+                      std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(uint32_t))
+    return TPM_RC_INSUFFICIENT;
+  uint32_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(uint32_t));
+  switch (sizeof(uint32_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(uint32_t)));
+  }
+  buffer->erase(0, sizeof(uint32_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_int32_t(const int32_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  int32_t value_net = value;
+  switch (sizeof(int32_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(int32_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_int32_t(std::string* buffer,
+                     int32_t* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(int32_t))
+    return TPM_RC_INSUFFICIENT;
+  int32_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(int32_t));
+  switch (sizeof(int32_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(int32_t)));
+  }
+  buffer->erase(0, sizeof(int32_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_uint64_t(const uint64_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  uint64_t value_net = value;
+  switch (sizeof(uint64_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(uint64_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_uint64_t(std::string* buffer,
+                      uint64_t* value,
+                      std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(uint64_t))
+    return TPM_RC_INSUFFICIENT;
+  uint64_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(uint64_t));
+  switch (sizeof(uint64_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(uint64_t)));
+  }
+  buffer->erase(0, sizeof(uint64_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_int64_t(const int64_t& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  int64_t value_net = value;
+  switch (sizeof(int64_t)) {
+    case 2:
+      value_net = htons(value);
+      break;
+    case 4:
+      value_net = htonl(value);
+      break;
+    case 8:
+      value_net = htonq(value);
+      break;
+    default:
+      break;
+  }
+  const char* value_bytes = reinterpret_cast<const char*>(&value_net);
+  buffer->append(value_bytes, sizeof(int64_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Parse_int64_t(std::string* buffer,
+                     int64_t* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  if (buffer->size() < sizeof(int64_t))
+    return TPM_RC_INSUFFICIENT;
+  int64_t value_net = 0;
+  memcpy(&value_net, buffer->data(), sizeof(int64_t));
+  switch (sizeof(int64_t)) {
+    case 2:
+      *value = ntohs(value_net);
+      break;
+    case 4:
+      *value = ntohl(value_net);
+      break;
+    case 8:
+      *value = ntohq(value_net);
+      break;
+    default:
+      *value = value_net;
+  }
+  if (value_bytes) {
+    value_bytes->append(buffer->substr(0, sizeof(int64_t)));
+  }
+  buffer->erase(0, sizeof(int64_t));
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Serialize_UINT8(const UINT8& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_uint8_t(value, buffer);
+}
+
+TPM_RC Parse_UINT8(std::string* buffer,
+                   UINT8* value,
+                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_uint8_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_BYTE(const BYTE& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_uint8_t(value, buffer);
+}
+
+TPM_RC Parse_BYTE(std::string* buffer, BYTE* value, std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_uint8_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_INT8(const INT8& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_int8_t(value, buffer);
+}
+
+TPM_RC Parse_INT8(std::string* buffer, INT8* value, std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_int8_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_BOOL(const BOOL& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_int(value, buffer);
+}
+
+TPM_RC Parse_BOOL(std::string* buffer, BOOL* value, std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_int(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_UINT16(const UINT16& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_uint16_t(value, buffer);
+}
+
+TPM_RC Parse_UINT16(std::string* buffer,
+                    UINT16* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_uint16_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_INT16(const INT16& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_int16_t(value, buffer);
+}
+
+TPM_RC Parse_INT16(std::string* buffer,
+                   INT16* value,
+                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_int16_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_UINT32(const UINT32& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_uint32_t(value, buffer);
+}
+
+TPM_RC Parse_UINT32(std::string* buffer,
+                    UINT32* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_uint32_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_INT32(const INT32& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_int32_t(value, buffer);
+}
+
+TPM_RC Parse_INT32(std::string* buffer,
+                   INT32* value,
+                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_int32_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_UINT64(const UINT64& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_uint64_t(value, buffer);
+}
+
+TPM_RC Parse_UINT64(std::string* buffer,
+                    UINT64* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_uint64_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_INT64(const INT64& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_int64_t(value, buffer);
+}
+
+TPM_RC Parse_INT64(std::string* buffer,
+                   INT64* value,
+                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_int64_t(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_ALGORITHM_ID(const TPM_ALGORITHM_ID& value,
+                                  std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_ALGORITHM_ID(std::string* buffer,
+                              TPM_ALGORITHM_ID* value,
+                              std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_MODIFIER_INDICATOR(const TPM_MODIFIER_INDICATOR& value,
+                                        std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_MODIFIER_INDICATOR(std::string* buffer,
+                                    TPM_MODIFIER_INDICATOR* value,
+                                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_AUTHORIZATION_SIZE(const TPM_AUTHORIZATION_SIZE& value,
+                                        std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_AUTHORIZATION_SIZE(std::string* buffer,
+                                    TPM_AUTHORIZATION_SIZE* value,
+                                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_PARAMETER_SIZE(const TPM_PARAMETER_SIZE& value,
+                                    std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_PARAMETER_SIZE(std::string* buffer,
+                                TPM_PARAMETER_SIZE* value,
+                                std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_KEY_SIZE(const TPM_KEY_SIZE& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_KEY_SIZE(std::string* buffer,
+                          TPM_KEY_SIZE* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_KEY_BITS(const TPM_KEY_BITS& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_KEY_BITS(std::string* buffer,
+                          TPM_KEY_BITS* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_HANDLE(const TPM_HANDLE& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_HANDLE(std::string* buffer,
+                        TPM_HANDLE* value,
+                        std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM2B_DIGEST(const TPM2B_DIGEST& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_DIGEST(std::string* buffer,
+                          TPM2B_DIGEST* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_DIGEST Make_TPM2B_DIGEST(const std::string& bytes) {
+  TPM2B_DIGEST tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_DIGEST));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_DIGEST(const TPM2B_DIGEST& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_NONCE(const TPM2B_NONCE& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM2B_DIGEST(value, buffer);
+}
+
+TPM_RC Parse_TPM2B_NONCE(std::string* buffer,
+                         TPM2B_NONCE* value,
+                         std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM2B_DIGEST(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM2B_AUTH(const TPM2B_AUTH& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM2B_DIGEST(value, buffer);
+}
+
+TPM_RC Parse_TPM2B_AUTH(std::string* buffer,
+                        TPM2B_AUTH* value,
+                        std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM2B_DIGEST(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM2B_OPERAND(const TPM2B_OPERAND& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM2B_DIGEST(value, buffer);
+}
+
+TPM_RC Parse_TPM2B_OPERAND(std::string* buffer,
+                           TPM2B_OPERAND* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM2B_DIGEST(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_ALG_ID(const TPM_ALG_ID& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_ALG_ID(std::string* buffer,
+                        TPM_ALG_ID* value,
+                        std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_HASH(const TPMI_ALG_HASH& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_HASH(std::string* buffer,
+                           TPMI_ALG_HASH* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_SIGHASH(const TPMS_SCHEME_SIGHASH& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_SIGHASH(std::string* buffer,
+                                 TPMS_SCHEME_SIGHASH* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_HMAC(const TPMS_SCHEME_HMAC& value,
+                                  std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_HMAC(std::string* buffer,
+                              TPMS_SCHEME_HMAC* value,
+                              std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_RSASSA(const TPMS_SCHEME_RSASSA& value,
+                                    std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_RSASSA(std::string* buffer,
+                                TPMS_SCHEME_RSASSA* value,
+                                std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_RSAPSS(const TPMS_SCHEME_RSAPSS& value,
+                                    std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_RSAPSS(std::string* buffer,
+                                TPMS_SCHEME_RSAPSS* value,
+                                std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_ECDSA(const TPMS_SCHEME_ECDSA& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_ECDSA(std::string* buffer,
+                               TPMS_SCHEME_ECDSA* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_SM2(const TPMS_SCHEME_SM2& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_SM2(std::string* buffer,
+                             TPMS_SCHEME_SM2* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_SCHEME_ECSCHNORR(const TPMS_SCHEME_ECSCHNORR& value,
+                                       std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPMS_SCHEME_SIGHASH(value, buffer);
+}
+
+TPM_RC Parse_TPMS_SCHEME_ECSCHNORR(std::string* buffer,
+                                   TPMS_SCHEME_ECSCHNORR* value,
+                                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPMS_SCHEME_SIGHASH(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_YES_NO(const TPMI_YES_NO& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_BYTE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_YES_NO(std::string* buffer,
+                         TPMI_YES_NO* value,
+                         std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_BYTE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_DH_OBJECT(const TPMI_DH_OBJECT& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_DH_OBJECT(std::string* buffer,
+                            TPMI_DH_OBJECT* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_DH_PERSISTENT(const TPMI_DH_PERSISTENT& value,
+                                    std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_DH_PERSISTENT(std::string* buffer,
+                                TPMI_DH_PERSISTENT* value,
+                                std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_DH_ENTITY(const TPMI_DH_ENTITY& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_DH_ENTITY(std::string* buffer,
+                            TPMI_DH_ENTITY* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_DH_PCR(const TPMI_DH_PCR& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_DH_PCR(std::string* buffer,
+                         TPMI_DH_PCR* value,
+                         std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_SH_AUTH_SESSION(const TPMI_SH_AUTH_SESSION& value,
+                                      std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_SH_AUTH_SESSION(std::string* buffer,
+                                  TPMI_SH_AUTH_SESSION* value,
+                                  std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_SH_HMAC(const TPMI_SH_HMAC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_SH_HMAC(std::string* buffer,
+                          TPMI_SH_HMAC* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_SH_POLICY(const TPMI_SH_POLICY& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_SH_POLICY(std::string* buffer,
+                            TPMI_SH_POLICY* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_DH_CONTEXT(const TPMI_DH_CONTEXT& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_DH_CONTEXT(std::string* buffer,
+                             TPMI_DH_CONTEXT* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_HIERARCHY(const TPMI_RH_HIERARCHY& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_HIERARCHY(std::string* buffer,
+                               TPMI_RH_HIERARCHY* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_ENABLES(const TPMI_RH_ENABLES& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_ENABLES(std::string* buffer,
+                             TPMI_RH_ENABLES* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_HIERARCHY_AUTH(const TPMI_RH_HIERARCHY_AUTH& value,
+                                        std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_HIERARCHY_AUTH(std::string* buffer,
+                                    TPMI_RH_HIERARCHY_AUTH* value,
+                                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_PLATFORM(const TPMI_RH_PLATFORM& value,
+                                  std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_PLATFORM(std::string* buffer,
+                              TPMI_RH_PLATFORM* value,
+                              std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_OWNER(const TPMI_RH_OWNER& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_OWNER(std::string* buffer,
+                           TPMI_RH_OWNER* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_ENDORSEMENT(const TPMI_RH_ENDORSEMENT& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_ENDORSEMENT(std::string* buffer,
+                                 TPMI_RH_ENDORSEMENT* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_PROVISION(const TPMI_RH_PROVISION& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_PROVISION(std::string* buffer,
+                               TPMI_RH_PROVISION* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_CLEAR(const TPMI_RH_CLEAR& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_CLEAR(std::string* buffer,
+                           TPMI_RH_CLEAR* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_NV_AUTH(const TPMI_RH_NV_AUTH& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_NV_AUTH(std::string* buffer,
+                             TPMI_RH_NV_AUTH* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_LOCKOUT(const TPMI_RH_LOCKOUT& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_LOCKOUT(std::string* buffer,
+                             TPMI_RH_LOCKOUT* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RH_NV_INDEX(const TPMI_RH_NV_INDEX& value,
+                                  std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RH_NV_INDEX(std::string* buffer,
+                              TPMI_RH_NV_INDEX* value,
+                              std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_ASYM(const TPMI_ALG_ASYM& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_ASYM(std::string* buffer,
+                           TPMI_ALG_ASYM* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_SYM(const TPMI_ALG_SYM& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_SYM(std::string* buffer,
+                          TPMI_ALG_SYM* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_SYM_OBJECT(const TPMI_ALG_SYM_OBJECT& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_SYM_OBJECT(std::string* buffer,
+                                 TPMI_ALG_SYM_OBJECT* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_SYM_MODE(const TPMI_ALG_SYM_MODE& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_SYM_MODE(std::string* buffer,
+                               TPMI_ALG_SYM_MODE* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_KDF(const TPMI_ALG_KDF& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_KDF(std::string* buffer,
+                          TPMI_ALG_KDF* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_SIG_SCHEME(const TPMI_ALG_SIG_SCHEME& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_SIG_SCHEME(std::string* buffer,
+                                 TPMI_ALG_SIG_SCHEME* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ECC_KEY_EXCHANGE(const TPMI_ECC_KEY_EXCHANGE& value,
+                                       std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ECC_KEY_EXCHANGE(std::string* buffer,
+                                   TPMI_ECC_KEY_EXCHANGE* value,
+                                   std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_ST(const TPM_ST& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_ST(std::string* buffer,
+                    TPM_ST* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ST_COMMAND_TAG(const TPMI_ST_COMMAND_TAG& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ST(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ST_COMMAND_TAG(std::string* buffer,
+                                 TPMI_ST_COMMAND_TAG* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ST(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ST_ATTEST(const TPMI_ST_ATTEST& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ST(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ST_ATTEST(std::string* buffer,
+                            TPMI_ST_ATTEST* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ST(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_AES_KEY_BITS(const TPMI_AES_KEY_BITS& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_KEY_BITS(value, buffer);
+}
+
+TPM_RC Parse_TPMI_AES_KEY_BITS(std::string* buffer,
+                               TPMI_AES_KEY_BITS* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_KEY_BITS(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_SM4_KEY_BITS(const TPMI_SM4_KEY_BITS& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_KEY_BITS(value, buffer);
+}
+
+TPM_RC Parse_TPMI_SM4_KEY_BITS(std::string* buffer,
+                               TPMI_SM4_KEY_BITS* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_KEY_BITS(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_KEYEDHASH_SCHEME(
+    const TPMI_ALG_KEYEDHASH_SCHEME& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_KEYEDHASH_SCHEME(std::string* buffer,
+                                       TPMI_ALG_KEYEDHASH_SCHEME* value,
+                                       std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_ASYM_SCHEME(const TPMI_ALG_ASYM_SCHEME& value,
+                                      std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_ASYM_SCHEME(std::string* buffer,
+                                  TPMI_ALG_ASYM_SCHEME* value,
+                                  std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_RSA_SCHEME(const TPMI_ALG_RSA_SCHEME& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_RSA_SCHEME(std::string* buffer,
+                                 TPMI_ALG_RSA_SCHEME* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_RSA_DECRYPT(const TPMI_ALG_RSA_DECRYPT& value,
+                                      std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_RSA_DECRYPT(std::string* buffer,
+                                  TPMI_ALG_RSA_DECRYPT* value,
+                                  std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_RSA_KEY_BITS(const TPMI_RSA_KEY_BITS& value,
+                                   std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_KEY_BITS(value, buffer);
+}
+
+TPM_RC Parse_TPMI_RSA_KEY_BITS(std::string* buffer,
+                               TPMI_RSA_KEY_BITS* value,
+                               std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_KEY_BITS(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_ECC_SCHEME(const TPMI_ALG_ECC_SCHEME& value,
+                                     std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_ECC_SCHEME(std::string* buffer,
+                                 TPMI_ALG_ECC_SCHEME* value,
+                                 std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_ECC_CURVE(const TPM_ECC_CURVE& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_ECC_CURVE(std::string* buffer,
+                           TPM_ECC_CURVE* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ECC_CURVE(const TPMI_ECC_CURVE& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ECC_CURVE(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ECC_CURVE(std::string* buffer,
+                            TPMI_ECC_CURVE* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ECC_CURVE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMI_ALG_PUBLIC(const TPMI_ALG_PUBLIC& value,
+                                 std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_ALG_ID(value, buffer);
+}
+
+TPM_RC Parse_TPMI_ALG_PUBLIC(std::string* buffer,
+                             TPMI_ALG_PUBLIC* value,
+                             std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_ALG_ID(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_ALGORITHM(const TPMA_ALGORITHM& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_ALGORITHM(std::string* buffer,
+                            TPMA_ALGORITHM* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_OBJECT(const TPMA_OBJECT& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_OBJECT(std::string* buffer,
+                         TPMA_OBJECT* value,
+                         std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_SESSION(const TPMA_SESSION& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT8(value, buffer);
+}
+
+TPM_RC Parse_TPMA_SESSION(std::string* buffer,
+                          TPMA_SESSION* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT8(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_LOCALITY(const TPMA_LOCALITY& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT8(value, buffer);
+}
+
+TPM_RC Parse_TPMA_LOCALITY(std::string* buffer,
+                           TPMA_LOCALITY* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT8(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_PERMANENT(const TPMA_PERMANENT& value,
+                                std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_PERMANENT(std::string* buffer,
+                            TPMA_PERMANENT* value,
+                            std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_STARTUP_CLEAR(const TPMA_STARTUP_CLEAR& value,
+                                    std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_STARTUP_CLEAR(std::string* buffer,
+                                TPMA_STARTUP_CLEAR* value,
+                                std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_MEMORY(const TPMA_MEMORY& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_MEMORY(std::string* buffer,
+                         TPMA_MEMORY* value,
+                         std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_CC(const TPM_CC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_CC(std::string* buffer,
+                    TPM_CC* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_CC(const TPMA_CC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_CC(value, buffer);
+}
+
+TPM_RC Parse_TPMA_CC(std::string* buffer,
+                     TPMA_CC* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_CC(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_NV_INDEX(const TPM_NV_INDEX& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_NV_INDEX(std::string* buffer,
+                          TPM_NV_INDEX* value,
+                          std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMA_NV(const TPMA_NV& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPMA_NV(std::string* buffer,
+                     TPMA_NV* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_SPEC(const TPM_SPEC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_SPEC(std::string* buffer,
+                      TPM_SPEC* value,
+                      std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_GENERATED(const TPM_GENERATED& value,
+                               std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_GENERATED(std::string* buffer,
+                           TPM_GENERATED* value,
+                           std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_RC(const TPM_RC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_RC(std::string* buffer,
+                    TPM_RC* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_CLOCK_ADJUST(const TPM_CLOCK_ADJUST& value,
+                                  std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_INT8(value, buffer);
+}
+
+TPM_RC Parse_TPM_CLOCK_ADJUST(std::string* buffer,
+                              TPM_CLOCK_ADJUST* value,
+                              std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_INT8(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_EO(const TPM_EO& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_EO(std::string* buffer,
+                    TPM_EO* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_SU(const TPM_SU& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT16(value, buffer);
+}
+
+TPM_RC Parse_TPM_SU(std::string* buffer,
+                    TPM_SU* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT16(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_SE(const TPM_SE& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT8(value, buffer);
+}
+
+TPM_RC Parse_TPM_SE(std::string* buffer,
+                    TPM_SE* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT8(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_CAP(const TPM_CAP& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_CAP(std::string* buffer,
+                     TPM_CAP* value,
+                     std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_PT(const TPM_PT& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_PT(std::string* buffer,
+                    TPM_PT* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_PT_PCR(const TPM_PT_PCR& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_PT_PCR(std::string* buffer,
+                        TPM_PT_PCR* value,
+                        std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_PS(const TPM_PS& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_PS(std::string* buffer,
+                    TPM_PS* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_HT(const TPM_HT& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT8(value, buffer);
+}
+
+TPM_RC Parse_TPM_HT(std::string* buffer,
+                    TPM_HT* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT8(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_RH(const TPM_RH& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_UINT32(value, buffer);
+}
+
+TPM_RC Parse_TPM_RH(std::string* buffer,
+                    TPM_RH* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_UINT32(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPM_HC(const TPM_HC& value, std::string* buffer) {
+  VLOG(3) << __func__;
+  return Serialize_TPM_HANDLE(value, buffer);
+}
+
+TPM_RC Parse_TPM_HC(std::string* buffer,
+                    TPM_HC* value,
+                    std::string* value_bytes) {
+  VLOG(3) << __func__;
+  return Parse_TPM_HANDLE(buffer, value, value_bytes);
+}
+
+TPM_RC Serialize_TPMS_ALGORITHM_DESCRIPTION(
+    const TPMS_ALGORITHM_DESCRIPTION& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ALG_ID(value.alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_ALGORITHM(value.attributes, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ALGORITHM_DESCRIPTION(std::string* buffer,
+                                        TPMS_ALGORITHM_DESCRIPTION* value,
+                                        std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ALG_ID(buffer, &value->alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_ALGORITHM(buffer, &value->attributes, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_HA(const TPMU_HA& value,
+                         TPMI_ALG_HASH selector,
+                         std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_SHA384) {
+    if (std::size(value.sha384) < SHA384_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA384_DIGEST_SIZE; ++i) {
+      result = Serialize_BYTE(value.sha384[i], buffer);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SHA1) {
+    if (std::size(value.sha1) < SHA1_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA1_DIGEST_SIZE; ++i) {
+      result = Serialize_BYTE(value.sha1[i], buffer);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SM3_256) {
+    if (std::size(value.sm3_256) < SM3_256_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SM3_256_DIGEST_SIZE; ++i) {
+      result = Serialize_BYTE(value.sm3_256[i], buffer);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SHA256) {
+    if (std::size(value.sha256) < SHA256_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA256_DIGEST_SIZE; ++i) {
+      result = Serialize_BYTE(value.sha256[i], buffer);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SHA512) {
+    if (std::size(value.sha512) < SHA512_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA512_DIGEST_SIZE; ++i) {
+      result = Serialize_BYTE(value.sha512[i], buffer);
+      if (result) {
+        return result;
+      }
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_HA(std::string* buffer,
+                     TPMI_ALG_HASH selector,
+                     TPMU_HA* value,
+                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_SHA384) {
+    if (std::size(value->sha384) < SHA384_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA384_DIGEST_SIZE; ++i) {
+      result = Parse_BYTE(buffer, &value->sha384[i], value_bytes);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SHA1) {
+    if (std::size(value->sha1) < SHA1_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA1_DIGEST_SIZE; ++i) {
+      result = Parse_BYTE(buffer, &value->sha1[i], value_bytes);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SM3_256) {
+    if (std::size(value->sm3_256) < SM3_256_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SM3_256_DIGEST_SIZE; ++i) {
+      result = Parse_BYTE(buffer, &value->sm3_256[i], value_bytes);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SHA256) {
+    if (std::size(value->sha256) < SHA256_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA256_DIGEST_SIZE; ++i) {
+      result = Parse_BYTE(buffer, &value->sha256[i], value_bytes);
+      if (result) {
+        return result;
+      }
+    }
+  }
+
+  if (selector == TPM_ALG_SHA512) {
+    if (std::size(value->sha512) < SHA512_DIGEST_SIZE) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    for (uint32_t i = 0; i < SHA512_DIGEST_SIZE; ++i) {
+      result = Parse_BYTE(buffer, &value->sha512[i], value_bytes);
+      if (result) {
+        return result;
+      }
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_HA(const TPMT_HA& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_HA(value.digest, value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_HA(std::string* buffer,
+                     TPMT_HA* value,
+                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_HA(buffer, value->hash_alg, &value->digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_DATA(const TPM2B_DATA& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_DATA(std::string* buffer,
+                        TPM2B_DATA* value,
+                        std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_DATA Make_TPM2B_DATA(const std::string& bytes) {
+  TPM2B_DATA tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_DATA));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_DATA(const TPM2B_DATA& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_EVENT(const TPM2B_EVENT& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_EVENT(std::string* buffer,
+                         TPM2B_EVENT* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_EVENT Make_TPM2B_EVENT(const std::string& bytes) {
+  TPM2B_EVENT tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_EVENT));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_EVENT(const TPM2B_EVENT& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_MAX_BUFFER(const TPM2B_MAX_BUFFER& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_MAX_BUFFER(std::string* buffer,
+                              TPM2B_MAX_BUFFER* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_MAX_BUFFER Make_TPM2B_MAX_BUFFER(const std::string& bytes) {
+  TPM2B_MAX_BUFFER tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_MAX_BUFFER));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_MAX_BUFFER(const TPM2B_MAX_BUFFER& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_MAX_NV_BUFFER(const TPM2B_MAX_NV_BUFFER& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_MAX_NV_BUFFER(std::string* buffer,
+                                 TPM2B_MAX_NV_BUFFER* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_MAX_NV_BUFFER Make_TPM2B_MAX_NV_BUFFER(const std::string& bytes) {
+  TPM2B_MAX_NV_BUFFER tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_MAX_NV_BUFFER));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_MAX_NV_BUFFER(const TPM2B_MAX_NV_BUFFER& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_TIMEOUT(const TPM2B_TIMEOUT& value,
+                               std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_TIMEOUT(std::string* buffer,
+                           TPM2B_TIMEOUT* value,
+                           std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_TIMEOUT Make_TPM2B_TIMEOUT(const std::string& bytes) {
+  TPM2B_TIMEOUT tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_TIMEOUT));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_TIMEOUT(const TPM2B_TIMEOUT& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_IV(const TPM2B_IV& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_IV(std::string* buffer,
+                      TPM2B_IV* value,
+                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_IV Make_TPM2B_IV(const std::string& bytes) {
+  TPM2B_IV tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_IV));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_IV(const TPM2B_IV& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_NAME(const TPM2B_NAME& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.name) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.name[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_NAME(std::string* buffer,
+                        TPM2B_NAME* value,
+                        std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->name) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->name[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_NAME Make_TPM2B_NAME(const std::string& bytes) {
+  TPM2B_NAME tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.name));
+  memset(&tpm2b, 0, sizeof(TPM2B_NAME));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.name, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_NAME(const TPM2B_NAME& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.name));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.name);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_PCR_SELECT(const TPMS_PCR_SELECT& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT8(value.sizeof_select, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.pcr_select) < value.sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.sizeof_select; ++i) {
+    result = Serialize_BYTE(value.pcr_select[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_PCR_SELECT(std::string* buffer,
+                             TPMS_PCR_SELECT* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT8(buffer, &value->sizeof_select, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->pcr_select) < value->sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->sizeof_select; ++i) {
+    result = Parse_BYTE(buffer, &value->pcr_select[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_PCR_SELECTION(const TPMS_PCR_SELECTION& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT8(value.sizeof_select, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.pcr_select) < value.sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.sizeof_select; ++i) {
+    result = Serialize_BYTE(value.pcr_select[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_PCR_SELECTION(std::string* buffer,
+                                TPMS_PCR_SELECTION* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT8(buffer, &value->sizeof_select, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->pcr_select) < value->sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->sizeof_select; ++i) {
+    result = Parse_BYTE(buffer, &value->pcr_select[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_TK_CREATION(const TPMT_TK_CREATION& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ST(value.tag, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RH_HIERARCHY(value.hierarchy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_TK_CREATION(std::string* buffer,
+                              TPMT_TK_CREATION* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ST(buffer, &value->tag, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RH_HIERARCHY(buffer, &value->hierarchy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_TK_VERIFIED(const TPMT_TK_VERIFIED& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ST(value.tag, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RH_HIERARCHY(value.hierarchy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_TK_VERIFIED(std::string* buffer,
+                              TPMT_TK_VERIFIED* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ST(buffer, &value->tag, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RH_HIERARCHY(buffer, &value->hierarchy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_TK_AUTH(const TPMT_TK_AUTH& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ST(value.tag, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RH_HIERARCHY(value.hierarchy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_TK_AUTH(std::string* buffer,
+                          TPMT_TK_AUTH* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ST(buffer, &value->tag, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RH_HIERARCHY(buffer, &value->hierarchy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_TK_HASHCHECK(const TPMT_TK_HASHCHECK& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ST(value.tag, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RH_HIERARCHY(value.hierarchy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_TK_HASHCHECK(std::string* buffer,
+                               TPMT_TK_HASHCHECK* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ST(buffer, &value->tag, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RH_HIERARCHY(buffer, &value->hierarchy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_ALG_PROPERTY(const TPMS_ALG_PROPERTY& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ALG_ID(value.alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_ALGORITHM(value.alg_properties, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ALG_PROPERTY(std::string* buffer,
+                               TPMS_ALG_PROPERTY* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ALG_ID(buffer, &value->alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_ALGORITHM(buffer, &value->alg_properties, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_TAGGED_PROPERTY(const TPMS_TAGGED_PROPERTY& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_PT(value.property, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT32(value.value, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_TAGGED_PROPERTY(std::string* buffer,
+                                  TPMS_TAGGED_PROPERTY* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_PT(buffer, &value->property, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT32(buffer, &value->value, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_TAGGED_PCR_SELECT(const TPMS_TAGGED_PCR_SELECT& value,
+                                        std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_PT(value.tag, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT8(value.sizeof_select, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.pcr_select) < value.sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.sizeof_select; ++i) {
+    result = Serialize_BYTE(value.pcr_select[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_TAGGED_PCR_SELECT(std::string* buffer,
+                                    TPMS_TAGGED_PCR_SELECT* value,
+                                    std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_PT(buffer, &value->tag, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT8(buffer, &value->sizeof_select, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->pcr_select) < value->sizeof_select) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->sizeof_select; ++i) {
+    result = Parse_BYTE(buffer, &value->pcr_select[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_CC(const TPML_CC& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.command_codes) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPM_CC(value.command_codes[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_CC(std::string* buffer,
+                     TPML_CC* value,
+                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->command_codes) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPM_CC(buffer, &value->command_codes[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_CCA(const TPML_CCA& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.command_attributes) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMA_CC(value.command_attributes[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_CCA(std::string* buffer,
+                      TPML_CCA* value,
+                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->command_attributes) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPMA_CC(buffer, &value->command_attributes[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_ALG(const TPML_ALG& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.algorithms) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPM_ALG_ID(value.algorithms[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_ALG(std::string* buffer,
+                      TPML_ALG* value,
+                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->algorithms) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPM_ALG_ID(buffer, &value->algorithms[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_HANDLE(const TPML_HANDLE& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.handle) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPM_HANDLE(value.handle[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_HANDLE(std::string* buffer,
+                         TPML_HANDLE* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->handle) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPM_HANDLE(buffer, &value->handle[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_DIGEST(const TPML_DIGEST& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.digests) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPM2B_DIGEST(value.digests[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_DIGEST(std::string* buffer,
+                         TPML_DIGEST* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->digests) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPM2B_DIGEST(buffer, &value->digests[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_DIGEST_VALUES(const TPML_DIGEST_VALUES& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.digests) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMT_HA(value.digests[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_DIGEST_VALUES(std::string* buffer,
+                                TPML_DIGEST_VALUES* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->digests) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPMT_HA(buffer, &value->digests[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_DIGEST_VALUES(const TPM2B_DIGEST_VALUES& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_DIGEST_VALUES(std::string* buffer,
+                                 TPM2B_DIGEST_VALUES* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_DIGEST_VALUES Make_TPM2B_DIGEST_VALUES(const std::string& bytes) {
+  TPM2B_DIGEST_VALUES tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_DIGEST_VALUES));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_DIGEST_VALUES(const TPM2B_DIGEST_VALUES& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPML_PCR_SELECTION(const TPML_PCR_SELECTION& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.pcr_selections) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMS_PCR_SELECTION(value.pcr_selections[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_PCR_SELECTION(std::string* buffer,
+                                TPML_PCR_SELECTION* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->pcr_selections) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPMS_PCR_SELECTION(buffer, &value->pcr_selections[i],
+                                      value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_ALG_PROPERTY(const TPML_ALG_PROPERTY& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.alg_properties) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMS_ALG_PROPERTY(value.alg_properties[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_ALG_PROPERTY(std::string* buffer,
+                               TPML_ALG_PROPERTY* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->alg_properties) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result =
+        Parse_TPMS_ALG_PROPERTY(buffer, &value->alg_properties[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_TAGGED_TPM_PROPERTY(const TPML_TAGGED_TPM_PROPERTY& value,
+                                          std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.tpm_property) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMS_TAGGED_PROPERTY(value.tpm_property[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_TAGGED_TPM_PROPERTY(std::string* buffer,
+                                      TPML_TAGGED_TPM_PROPERTY* value,
+                                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->tpm_property) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPMS_TAGGED_PROPERTY(buffer, &value->tpm_property[i],
+                                        value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_TAGGED_PCR_PROPERTY(const TPML_TAGGED_PCR_PROPERTY& value,
+                                          std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.pcr_property) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPMS_TAGGED_PCR_SELECT(value.pcr_property[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_TAGGED_PCR_PROPERTY(std::string* buffer,
+                                      TPML_TAGGED_PCR_PROPERTY* value,
+                                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->pcr_property) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPMS_TAGGED_PCR_SELECT(buffer, &value->pcr_property[i],
+                                          value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPML_ECC_CURVE(const TPML_ECC_CURVE& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT32(value.count, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.ecc_curves) < value.count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.count; ++i) {
+    result = Serialize_TPM_ECC_CURVE(value.ecc_curves[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPML_ECC_CURVE(std::string* buffer,
+                            TPML_ECC_CURVE* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT32(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->ecc_curves) < value->count) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->count; ++i) {
+    result = Parse_TPM_ECC_CURVE(buffer, &value->ecc_curves[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_CAPABILITIES(const TPMU_CAPABILITIES& value,
+                                   TPM_CAP selector,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_CAP_PCRS) {
+    result = Serialize_TPML_PCR_SELECTION(value.assigned_pcr, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_TPM_PROPERTIES) {
+    result = Serialize_TPML_TAGGED_TPM_PROPERTY(value.tpm_properties, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_PP_COMMANDS) {
+    result = Serialize_TPML_CC(value.pp_commands, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_AUDIT_COMMANDS) {
+    result = Serialize_TPML_CC(value.audit_commands, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_COMMANDS) {
+    result = Serialize_TPML_CCA(value.command, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_ECC_CURVES) {
+    result = Serialize_TPML_ECC_CURVE(value.ecc_curves, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_PCR_PROPERTIES) {
+    result = Serialize_TPML_TAGGED_PCR_PROPERTY(value.pcr_properties, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_HANDLES) {
+    result = Serialize_TPML_HANDLE(value.handles, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_ALGS) {
+    result = Serialize_TPML_ALG_PROPERTY(value.algorithms, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_CAPABILITIES(std::string* buffer,
+                               TPM_CAP selector,
+                               TPMU_CAPABILITIES* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_CAP_PCRS) {
+    result =
+        Parse_TPML_PCR_SELECTION(buffer, &value->assigned_pcr, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_TPM_PROPERTIES) {
+    result = Parse_TPML_TAGGED_TPM_PROPERTY(buffer, &value->tpm_properties,
+                                            value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_PP_COMMANDS) {
+    result = Parse_TPML_CC(buffer, &value->pp_commands, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_AUDIT_COMMANDS) {
+    result = Parse_TPML_CC(buffer, &value->audit_commands, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_COMMANDS) {
+    result = Parse_TPML_CCA(buffer, &value->command, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_ECC_CURVES) {
+    result = Parse_TPML_ECC_CURVE(buffer, &value->ecc_curves, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_PCR_PROPERTIES) {
+    result = Parse_TPML_TAGGED_PCR_PROPERTY(buffer, &value->pcr_properties,
+                                            value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_HANDLES) {
+    result = Parse_TPML_HANDLE(buffer, &value->handles, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_CAP_ALGS) {
+    result = Parse_TPML_ALG_PROPERTY(buffer, &value->algorithms, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_CAPABILITY_DATA(const TPMS_CAPABILITY_DATA& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_CAP(value.capability, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_CAPABILITIES(value.data, value.capability, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CAPABILITY_DATA(std::string* buffer,
+                                  TPMS_CAPABILITY_DATA* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_CAP(buffer, &value->capability, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_CAPABILITIES(buffer, value->capability, &value->data,
+                                   value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_CLOCK_INFO(const TPMS_CLOCK_INFO& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT64(value.clock, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT32(value.reset_count, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT32(value.restart_count, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_YES_NO(value.safe, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CLOCK_INFO(std::string* buffer,
+                             TPMS_CLOCK_INFO* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT64(buffer, &value->clock, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT32(buffer, &value->reset_count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT32(buffer, &value->restart_count, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_YES_NO(buffer, &value->safe, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_TIME_INFO(const TPMS_TIME_INFO& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT64(value.time, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMS_CLOCK_INFO(value.clock_info, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_TIME_INFO(std::string* buffer,
+                            TPMS_TIME_INFO* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT64(buffer, &value->time, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMS_CLOCK_INFO(buffer, &value->clock_info, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_TIME_ATTEST_INFO(const TPMS_TIME_ATTEST_INFO& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMS_TIME_INFO(value.time, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT64(value.firmware_version, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_TIME_ATTEST_INFO(std::string* buffer,
+                                   TPMS_TIME_ATTEST_INFO* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMS_TIME_INFO(buffer, &value->time, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT64(buffer, &value->firmware_version, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_CERTIFY_INFO(const TPMS_CERTIFY_INFO& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_NAME(value.name, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_NAME(value.qualified_name, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CERTIFY_INFO(std::string* buffer,
+                               TPMS_CERTIFY_INFO* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_NAME(buffer, &value->name, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_NAME(buffer, &value->qualified_name, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_QUOTE_INFO(const TPMS_QUOTE_INFO& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPML_PCR_SELECTION(value.pcr_select, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.pcr_digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_QUOTE_INFO(std::string* buffer,
+                             TPMS_QUOTE_INFO* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPML_PCR_SELECTION(buffer, &value->pcr_select, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->pcr_digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_COMMAND_AUDIT_INFO(const TPMS_COMMAND_AUDIT_INFO& value,
+                                         std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT64(value.audit_counter, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM_ALG_ID(value.digest_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.audit_digest, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.command_digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_COMMAND_AUDIT_INFO(std::string* buffer,
+                                     TPMS_COMMAND_AUDIT_INFO* value,
+                                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT64(buffer, &value->audit_counter, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM_ALG_ID(buffer, &value->digest_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->audit_digest, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->command_digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SESSION_AUDIT_INFO(const TPMS_SESSION_AUDIT_INFO& value,
+                                         std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_YES_NO(value.exclusive_session, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.session_digest, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SESSION_AUDIT_INFO(std::string* buffer,
+                                     TPMS_SESSION_AUDIT_INFO* value,
+                                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_YES_NO(buffer, &value->exclusive_session, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->session_digest, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_CREATION_INFO(const TPMS_CREATION_INFO& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_NAME(value.object_name, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.creation_hash, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CREATION_INFO(std::string* buffer,
+                                TPMS_CREATION_INFO* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_NAME(buffer, &value->object_name, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->creation_hash, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_NV_CERTIFY_INFO(const TPMS_NV_CERTIFY_INFO& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_NAME(value.index_name, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT16(value.offset, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_MAX_NV_BUFFER(value.nv_contents, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_NV_CERTIFY_INFO(std::string* buffer,
+                                  TPMS_NV_CERTIFY_INFO* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_NAME(buffer, &value->index_name, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT16(buffer, &value->offset, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_MAX_NV_BUFFER(buffer, &value->nv_contents, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_ATTEST(const TPMU_ATTEST& value,
+                             TPMI_ST_ATTEST selector,
+                             std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ST_ATTEST_SESSION_AUDIT) {
+    result = Serialize_TPMS_SESSION_AUDIT_INFO(value.session_audit, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_QUOTE) {
+    result = Serialize_TPMS_QUOTE_INFO(value.quote, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_COMMAND_AUDIT) {
+    result = Serialize_TPMS_COMMAND_AUDIT_INFO(value.command_audit, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_CERTIFY) {
+    result = Serialize_TPMS_CERTIFY_INFO(value.certify, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_NV) {
+    result = Serialize_TPMS_NV_CERTIFY_INFO(value.nv, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_TIME) {
+    result = Serialize_TPMS_TIME_ATTEST_INFO(value.time, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_CREATION) {
+    result = Serialize_TPMS_CREATION_INFO(value.creation, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_ATTEST(std::string* buffer,
+                         TPMI_ST_ATTEST selector,
+                         TPMU_ATTEST* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ST_ATTEST_SESSION_AUDIT) {
+    result = Parse_TPMS_SESSION_AUDIT_INFO(buffer, &value->session_audit,
+                                           value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_QUOTE) {
+    result = Parse_TPMS_QUOTE_INFO(buffer, &value->quote, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_COMMAND_AUDIT) {
+    result = Parse_TPMS_COMMAND_AUDIT_INFO(buffer, &value->command_audit,
+                                           value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_CERTIFY) {
+    result = Parse_TPMS_CERTIFY_INFO(buffer, &value->certify, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_NV) {
+    result = Parse_TPMS_NV_CERTIFY_INFO(buffer, &value->nv, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_TIME) {
+    result = Parse_TPMS_TIME_ATTEST_INFO(buffer, &value->time, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ST_ATTEST_CREATION) {
+    result = Parse_TPMS_CREATION_INFO(buffer, &value->creation, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_ATTEST(const TPMS_ATTEST& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_GENERATED(value.magic, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_ST_ATTEST(value.type, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_NAME(value.qualified_signer, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DATA(value.extra_data, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMS_CLOCK_INFO(value.clock_info, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT64(value.firmware_version, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_ATTEST(value.attested, value.type, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ATTEST(std::string* buffer,
+                         TPMS_ATTEST* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_GENERATED(buffer, &value->magic, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_ST_ATTEST(buffer, &value->type, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_NAME(buffer, &value->qualified_signer, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DATA(buffer, &value->extra_data, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMS_CLOCK_INFO(buffer, &value->clock_info, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT64(buffer, &value->firmware_version, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result =
+      Parse_TPMU_ATTEST(buffer, value->type, &value->attested, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_ATTEST(const TPM2B_ATTEST& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.attestation_data) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.attestation_data[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_ATTEST(std::string* buffer,
+                          TPM2B_ATTEST* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->attestation_data) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->attestation_data[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_ATTEST Make_TPM2B_ATTEST(const std::string& bytes) {
+  TPM2B_ATTEST tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.attestation_data));
+  memset(&tpm2b, 0, sizeof(TPM2B_ATTEST));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.attestation_data, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_ATTEST(const TPM2B_ATTEST& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.attestation_data));
+  const char* char_buffer =
+      reinterpret_cast<const char*>(tpm2b.attestation_data);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_AUTH_COMMAND(const TPMS_AUTH_COMMAND& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_SH_AUTH_SESSION(value.session_handle, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_NONCE(value.nonce, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_SESSION(value.session_attributes, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_AUTH(value.hmac, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_AUTH_COMMAND(std::string* buffer,
+                               TPMS_AUTH_COMMAND* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result =
+      Parse_TPMI_SH_AUTH_SESSION(buffer, &value->session_handle, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_NONCE(buffer, &value->nonce, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_SESSION(buffer, &value->session_attributes, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_AUTH(buffer, &value->hmac, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_AUTH_RESPONSE(const TPMS_AUTH_RESPONSE& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_NONCE(value.nonce, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_SESSION(value.session_attributes, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_AUTH(value.hmac, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_AUTH_RESPONSE(std::string* buffer,
+                                TPMS_AUTH_RESPONSE* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_NONCE(buffer, &value->nonce, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_SESSION(buffer, &value->session_attributes, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_AUTH(buffer, &value->hmac, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SYM_KEY_BITS(const TPMU_SYM_KEY_BITS& value,
+                                   TPMI_ALG_SYM selector,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SM4) {
+    result = Serialize_TPMI_SM4_KEY_BITS(value.sm4, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_AES) {
+    result = Serialize_TPMI_AES_KEY_BITS(value.aes, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    result = Serialize_TPMI_ALG_HASH(value.xor_, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SYM_KEY_BITS(std::string* buffer,
+                               TPMI_ALG_SYM selector,
+                               TPMU_SYM_KEY_BITS* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SM4) {
+    result = Parse_TPMI_SM4_KEY_BITS(buffer, &value->sm4, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_AES) {
+    result = Parse_TPMI_AES_KEY_BITS(buffer, &value->aes, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    result = Parse_TPMI_ALG_HASH(buffer, &value->xor_, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SYM_MODE(const TPMU_SYM_MODE& value,
+                               TPMI_ALG_SYM selector,
+                               std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SM4) {
+    result = Serialize_TPMI_ALG_SYM_MODE(value.sm4, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_AES) {
+    result = Serialize_TPMI_ALG_SYM_MODE(value.aes, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SYM_MODE(std::string* buffer,
+                           TPMI_ALG_SYM selector,
+                           TPMU_SYM_MODE* value,
+                           std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_SM4) {
+    result = Parse_TPMI_ALG_SYM_MODE(buffer, &value->sm4, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_AES) {
+    result = Parse_TPMI_ALG_SYM_MODE(buffer, &value->aes, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SYM_DETAILS(const TPMU_SYM_DETAILS& value,
+                                  TPMI_ALG_SYM selector,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+  return result;
+}
+
+TPM_RC Parse_TPMU_SYM_DETAILS(std::string* buffer,
+                              TPMI_ALG_SYM selector,
+                              TPMU_SYM_DETAILS* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+  return result;
+}
+
+TPM_RC Serialize_TPMT_SYM_DEF(const TPMT_SYM_DEF& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_SYM(value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_KEY_BITS(value.key_bits, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_MODE(value.mode, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_DETAILS(value.details, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_SYM_DEF(std::string* buffer,
+                          TPMT_SYM_DEF* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_SYM(buffer, &value->algorithm, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SYM_KEY_BITS(buffer, value->algorithm, &value->key_bits,
+                                   value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result =
+      Parse_TPMU_SYM_MODE(buffer, value->algorithm, &value->mode, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SYM_DETAILS(buffer, value->algorithm, &value->details,
+                                  value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_SYM_DEF_OBJECT(const TPMT_SYM_DEF_OBJECT& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_SYM_OBJECT(value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_KEY_BITS(value.key_bits, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_MODE(value.mode, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SYM_DETAILS(value.details, value.algorithm, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_SYM_DEF_OBJECT(std::string* buffer,
+                                 TPMT_SYM_DEF_OBJECT* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_SYM_OBJECT(buffer, &value->algorithm, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SYM_KEY_BITS(buffer, value->algorithm, &value->key_bits,
+                                   value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result =
+      Parse_TPMU_SYM_MODE(buffer, value->algorithm, &value->mode, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SYM_DETAILS(buffer, value->algorithm, &value->details,
+                                  value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_SYM_KEY(const TPM2B_SYM_KEY& value,
+                               std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_SYM_KEY(std::string* buffer,
+                           TPM2B_SYM_KEY* value,
+                           std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_SYM_KEY Make_TPM2B_SYM_KEY(const std::string& bytes) {
+  TPM2B_SYM_KEY tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_SYM_KEY));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_SYM_KEY(const TPM2B_SYM_KEY& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_SYMCIPHER_PARMS(const TPMS_SYMCIPHER_PARMS& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMT_SYM_DEF_OBJECT(value.sym, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SYMCIPHER_PARMS(std::string* buffer,
+                                  TPMS_SYMCIPHER_PARMS* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMT_SYM_DEF_OBJECT(buffer, &value->sym, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_SENSITIVE_DATA(const TPM2B_SENSITIVE_DATA& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_SENSITIVE_DATA(std::string* buffer,
+                                  TPM2B_SENSITIVE_DATA* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_SENSITIVE_DATA Make_TPM2B_SENSITIVE_DATA(const std::string& bytes) {
+  TPM2B_SENSITIVE_DATA tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_SENSITIVE_DATA));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_SENSITIVE_DATA(const TPM2B_SENSITIVE_DATA& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_AUTH(value.user_auth, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_SENSITIVE_DATA(value.data, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SENSITIVE_CREATE(std::string* buffer,
+                                   TPMS_SENSITIVE_CREATE* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_AUTH(buffer, &value->user_auth, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_SENSITIVE_DATA(buffer, &value->data, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_SENSITIVE_CREATE(const TPM2B_SENSITIVE_CREATE& value,
+                                        std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMS_SENSITIVE_CREATE)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMS_SENSITIVE_CREATE(value.sensitive, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_SENSITIVE_CREATE(std::string* buffer,
+                                    TPM2B_SENSITIVE_CREATE* value,
+                                    std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMS_SENSITIVE_CREATE);
+    result =
+        Parse_TPMS_SENSITIVE_CREATE(buffer, &value->sensitive, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_SENSITIVE_CREATE Make_TPM2B_SENSITIVE_CREATE(
+    const TPMS_SENSITIVE_CREATE& inner) {
+  TPM2B_SENSITIVE_CREATE tpm2b;
+  tpm2b.size = sizeof(TPMS_SENSITIVE_CREATE);
+  tpm2b.sensitive = inner;
+  return tpm2b;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_XOR(const TPMS_SCHEME_XOR& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_ALG_KDF(value.kdf, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_XOR(std::string* buffer,
+                             TPMS_SCHEME_XOR* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_ALG_KDF(buffer, &value->kdf, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SCHEME_KEYEDHASH(const TPMU_SCHEME_KEYEDHASH& value,
+                                       TPMI_ALG_KEYEDHASH_SCHEME selector,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Serialize_TPMS_SCHEME_HMAC(value.hmac, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    result = Serialize_TPMS_SCHEME_XOR(value.xor_, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SCHEME_KEYEDHASH(std::string* buffer,
+                                   TPMI_ALG_KEYEDHASH_SCHEME selector,
+                                   TPMU_SCHEME_KEYEDHASH* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Parse_TPMS_SCHEME_HMAC(buffer, &value->hmac, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_XOR) {
+    result = Parse_TPMS_SCHEME_XOR(buffer, &value->xor_, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_KEYEDHASH_SCHEME(const TPMT_KEYEDHASH_SCHEME& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_KEYEDHASH_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SCHEME_KEYEDHASH(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_KEYEDHASH_SCHEME(std::string* buffer,
+                                   TPMT_KEYEDHASH_SCHEME* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_KEYEDHASH_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SCHEME_KEYEDHASH(buffer, value->scheme, &value->details,
+                                       value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_ECDAA(const TPMS_SCHEME_ECDAA& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT16(value.count, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_ECDAA(std::string* buffer,
+                               TPMS_SCHEME_ECDAA* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT16(buffer, &value->count, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SIG_SCHEME(const TPMU_SIG_SCHEME& value,
+                                 TPMI_ALG_SIG_SCHEME selector,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Serialize_TPMS_SCHEME_HMAC(value.hmac, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result = Serialize_TPMS_SCHEME_ECSCHNORR(value.ec_schnorr, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Serialize_TPMS_SCHEME_RSAPSS(value.rsapss, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Serialize_TPMS_SCHEME_ECDAA(value.ecdaa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Serialize_TPMS_SCHEME_RSASSA(value.rsassa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Serialize_TPMS_SCHEME_SM2(value.sm2, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Serialize_TPMS_SCHEME_ECDSA(value.ecdsa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SIG_SCHEME(std::string* buffer,
+                             TPMI_ALG_SIG_SCHEME selector,
+                             TPMU_SIG_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Parse_TPMS_SCHEME_HMAC(buffer, &value->hmac, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result =
+        Parse_TPMS_SCHEME_ECSCHNORR(buffer, &value->ec_schnorr, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Parse_TPMS_SCHEME_RSAPSS(buffer, &value->rsapss, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Parse_TPMS_SCHEME_ECDAA(buffer, &value->ecdaa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Parse_TPMS_SCHEME_RSASSA(buffer, &value->rsassa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Parse_TPMS_SCHEME_SM2(buffer, &value->sm2, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Parse_TPMS_SCHEME_ECDSA(buffer, &value->ecdsa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_SIG_SCHEME(const TPMT_SIG_SCHEME& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_SIG_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SIG_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_SIG_SCHEME(std::string* buffer,
+                             TPMT_SIG_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_SIG_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SIG_SCHEME(buffer, value->scheme, &value->details,
+                                 value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_OAEP(const TPMS_SCHEME_OAEP& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_OAEP(std::string* buffer,
+                              TPMS_SCHEME_OAEP* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_ECDH(const TPMS_SCHEME_ECDH& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_ECDH(std::string* buffer,
+                              TPMS_SCHEME_ECDH* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_MGF1(const TPMS_SCHEME_MGF1& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_MGF1(std::string* buffer,
+                              TPMS_SCHEME_MGF1* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_KDF1_SP800_56a(
+    const TPMS_SCHEME_KDF1_SP800_56a& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_KDF1_SP800_56a(std::string* buffer,
+                                        TPMS_SCHEME_KDF1_SP800_56a* value,
+                                        std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_KDF2(const TPMS_SCHEME_KDF2& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_KDF2(std::string* buffer,
+                              TPMS_SCHEME_KDF2* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SCHEME_KDF1_SP800_108(
+    const TPMS_SCHEME_KDF1_SP800_108& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SCHEME_KDF1_SP800_108(std::string* buffer,
+                                        TPMS_SCHEME_KDF1_SP800_108* value,
+                                        std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_KDF_SCHEME(const TPMU_KDF_SCHEME& value,
+                                 TPMI_ALG_KDF selector,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KDF1_SP800_56a) {
+    result = Serialize_TPMS_SCHEME_KDF1_SP800_56a(value.kdf1_sp800_56a, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_MGF1) {
+    result = Serialize_TPMS_SCHEME_MGF1(value.mgf1, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_KDF1_SP800_108) {
+    result = Serialize_TPMS_SCHEME_KDF1_SP800_108(value.kdf1_sp800_108, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_KDF2) {
+    result = Serialize_TPMS_SCHEME_KDF2(value.kdf2, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_KDF_SCHEME(std::string* buffer,
+                             TPMI_ALG_KDF selector,
+                             TPMU_KDF_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KDF1_SP800_56a) {
+    result = Parse_TPMS_SCHEME_KDF1_SP800_56a(buffer, &value->kdf1_sp800_56a,
+                                              value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_MGF1) {
+    result = Parse_TPMS_SCHEME_MGF1(buffer, &value->mgf1, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_KDF1_SP800_108) {
+    result = Parse_TPMS_SCHEME_KDF1_SP800_108(buffer, &value->kdf1_sp800_108,
+                                              value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_KDF2) {
+    result = Parse_TPMS_SCHEME_KDF2(buffer, &value->kdf2, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_KDF_SCHEME(const TPMT_KDF_SCHEME& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_KDF(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_KDF_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_KDF_SCHEME(std::string* buffer,
+                             TPMT_KDF_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_KDF(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_KDF_SCHEME(buffer, value->scheme, &value->details,
+                                 value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_ASYM_SCHEME(const TPMU_ASYM_SCHEME& value,
+                                  TPMI_ALG_ASYM_SCHEME selector,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_RSAES) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result = Serialize_TPMS_SCHEME_ECSCHNORR(value.ec_schnorr, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_ECDH) {
+    result = Serialize_TPMS_SCHEME_ECDH(value.ecdh, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_OAEP) {
+    result = Serialize_TPMS_SCHEME_OAEP(value.oaep, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Serialize_TPMS_SCHEME_RSAPSS(value.rsapss, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Serialize_TPMS_SCHEME_ECDAA(value.ecdaa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Serialize_TPMS_SCHEME_RSASSA(value.rsassa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Serialize_TPMS_SCHEME_SM2(value.sm2, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Serialize_TPMS_SCHEME_ECDSA(value.ecdsa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_ASYM_SCHEME(std::string* buffer,
+                              TPMI_ALG_ASYM_SCHEME selector,
+                              TPMU_ASYM_SCHEME* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_RSAES) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result =
+        Parse_TPMS_SCHEME_ECSCHNORR(buffer, &value->ec_schnorr, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+
+  if (selector == TPM_ALG_ECDH) {
+    result = Parse_TPMS_SCHEME_ECDH(buffer, &value->ecdh, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_OAEP) {
+    result = Parse_TPMS_SCHEME_OAEP(buffer, &value->oaep, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Parse_TPMS_SCHEME_RSAPSS(buffer, &value->rsapss, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Parse_TPMS_SCHEME_ECDAA(buffer, &value->ecdaa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Parse_TPMS_SCHEME_RSASSA(buffer, &value->rsassa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Parse_TPMS_SCHEME_SM2(buffer, &value->sm2, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Parse_TPMS_SCHEME_ECDSA(buffer, &value->ecdsa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_ASYM_SCHEME(const TPMT_ASYM_SCHEME& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_ASYM_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_ASYM_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_ASYM_SCHEME(std::string* buffer,
+                              TPMT_ASYM_SCHEME* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_ASYM_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_ASYM_SCHEME(buffer, value->scheme, &value->details,
+                                  value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_RSA_SCHEME(const TPMT_RSA_SCHEME& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_RSA_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_ASYM_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_RSA_SCHEME(std::string* buffer,
+                             TPMT_RSA_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_RSA_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_ASYM_SCHEME(buffer, value->scheme, &value->details,
+                                  value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_RSA_DECRYPT(const TPMT_RSA_DECRYPT& value,
+                                  std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_RSA_DECRYPT(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_ASYM_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_RSA_DECRYPT(std::string* buffer,
+                              TPMT_RSA_DECRYPT* value,
+                              std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_RSA_DECRYPT(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_ASYM_SCHEME(buffer, value->scheme, &value->details,
+                                  value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_PUBLIC_KEY_RSA(const TPM2B_PUBLIC_KEY_RSA& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_PUBLIC_KEY_RSA(std::string* buffer,
+                                  TPM2B_PUBLIC_KEY_RSA* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_PUBLIC_KEY_RSA Make_TPM2B_PUBLIC_KEY_RSA(const std::string& bytes) {
+  TPM2B_PUBLIC_KEY_RSA tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_PUBLIC_KEY_RSA));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_PUBLIC_KEY_RSA(const TPM2B_PUBLIC_KEY_RSA& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_PRIVATE_KEY_RSA(const TPM2B_PRIVATE_KEY_RSA& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_PRIVATE_KEY_RSA(std::string* buffer,
+                                   TPM2B_PRIVATE_KEY_RSA* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_PRIVATE_KEY_RSA Make_TPM2B_PRIVATE_KEY_RSA(const std::string& bytes) {
+  TPM2B_PRIVATE_KEY_RSA tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_PRIVATE_KEY_RSA));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_PRIVATE_KEY_RSA(
+    const TPM2B_PRIVATE_KEY_RSA& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_ECC_PARAMETER(const TPM2B_ECC_PARAMETER& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_ECC_PARAMETER(std::string* buffer,
+                                 TPM2B_ECC_PARAMETER* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_ECC_PARAMETER Make_TPM2B_ECC_PARAMETER(const std::string& bytes) {
+  TPM2B_ECC_PARAMETER tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_ECC_PARAMETER));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_ECC_PARAMETER(const TPM2B_ECC_PARAMETER& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_ECC_POINT(const TPMS_ECC_POINT& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.x, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.y, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ECC_POINT(std::string* buffer,
+                            TPMS_ECC_POINT* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->x, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->y, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_ECC_POINT(const TPM2B_ECC_POINT& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMS_ECC_POINT)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMS_ECC_POINT(value.point, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_ECC_POINT(std::string* buffer,
+                             TPM2B_ECC_POINT* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMS_ECC_POINT);
+    result = Parse_TPMS_ECC_POINT(buffer, &value->point, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_ECC_POINT Make_TPM2B_ECC_POINT(const TPMS_ECC_POINT& inner) {
+  TPM2B_ECC_POINT tpm2b;
+  tpm2b.size = sizeof(TPMS_ECC_POINT);
+  tpm2b.point = inner;
+  return tpm2b;
+}
+
+TPM_RC Serialize_TPMT_ECC_SCHEME(const TPMT_ECC_SCHEME& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_ECC_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SIG_SCHEME(value.details, value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_ECC_SCHEME(std::string* buffer,
+                             TPMT_ECC_SCHEME* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_ECC_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SIG_SCHEME(buffer, value->scheme, &value->details,
+                                 value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_ALGORITHM_DETAIL_ECC(
+    const TPMS_ALGORITHM_DETAIL_ECC& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM_ECC_CURVE(value.curve_id, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT16(value.key_size, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_KDF_SCHEME(value.kdf, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_ECC_SCHEME(value.sign, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.p, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.a, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.b, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.g_x, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.g_y, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.n, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.h, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ALGORITHM_DETAIL_ECC(std::string* buffer,
+                                       TPMS_ALGORITHM_DETAIL_ECC* value,
+                                       std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM_ECC_CURVE(buffer, &value->curve_id, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT16(buffer, &value->key_size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_KDF_SCHEME(buffer, &value->kdf, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_ECC_SCHEME(buffer, &value->sign, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->p, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->a, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->b, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->g_x, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->g_y, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->n, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->h, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SIGNATURE_RSASSA(const TPMS_SIGNATURE_RSASSA& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_PUBLIC_KEY_RSA(value.sig, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SIGNATURE_RSASSA(std::string* buffer,
+                                   TPMS_SIGNATURE_RSASSA* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_PUBLIC_KEY_RSA(buffer, &value->sig, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SIGNATURE_RSAPSS(const TPMS_SIGNATURE_RSAPSS& value,
+                                       std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_PUBLIC_KEY_RSA(value.sig, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SIGNATURE_RSAPSS(std::string* buffer,
+                                   TPMS_SIGNATURE_RSAPSS* value,
+                                   std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_PUBLIC_KEY_RSA(buffer, &value->sig, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_SIGNATURE_ECDSA(const TPMS_SIGNATURE_ECDSA& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_HASH(value.hash, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.signature_r, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_ECC_PARAMETER(value.signature_s, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_SIGNATURE_ECDSA(std::string* buffer,
+                                  TPMS_SIGNATURE_ECDSA* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->hash, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->signature_r, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->signature_s, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_SIGNATURE(const TPMU_SIGNATURE& value,
+                                TPMI_ALG_SIG_SCHEME selector,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Serialize_TPMT_HA(value.hmac, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result = Serialize_TPMS_SIGNATURE_ECDSA(value.ecschnorr, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Serialize_TPMS_SIGNATURE_RSAPSS(value.rsapss, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Serialize_TPMS_SIGNATURE_ECDSA(value.ecdaa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Serialize_TPMS_SIGNATURE_RSASSA(value.rsassa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Serialize_TPMS_SIGNATURE_ECDSA(value.sm2, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Serialize_TPMS_SIGNATURE_ECDSA(value.ecdsa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SIGNATURE(std::string* buffer,
+                            TPMI_ALG_SIG_SCHEME selector,
+                            TPMU_SIGNATURE* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_HMAC) {
+    result = Parse_TPMT_HA(buffer, &value->hmac, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECSCHNORR) {
+    result = Parse_TPMS_SIGNATURE_ECDSA(buffer, &value->ecschnorr, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSAPSS) {
+    result = Parse_TPMS_SIGNATURE_RSAPSS(buffer, &value->rsapss, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDAA) {
+    result = Parse_TPMS_SIGNATURE_ECDSA(buffer, &value->ecdaa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSASSA) {
+    result = Parse_TPMS_SIGNATURE_RSASSA(buffer, &value->rsassa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SM2) {
+    result = Parse_TPMS_SIGNATURE_ECDSA(buffer, &value->sm2, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECDSA) {
+    result = Parse_TPMS_SIGNATURE_ECDSA(buffer, &value->ecdsa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_NULL) {
+    // Do nothing.
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_SIGNATURE(const TPMT_SIGNATURE& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_SIG_SCHEME(value.sig_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SIGNATURE(value.signature, value.sig_alg, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_SIGNATURE(std::string* buffer,
+                            TPMT_SIGNATURE* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_SIG_SCHEME(buffer, &value->sig_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SIGNATURE(buffer, value->sig_alg, &value->signature,
+                                value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_ENCRYPTED_SECRET(const TPM2B_ENCRYPTED_SECRET& value,
+                                        std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.secret) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.secret[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_ENCRYPTED_SECRET(std::string* buffer,
+                                    TPM2B_ENCRYPTED_SECRET* value,
+                                    std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->secret) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->secret[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_ENCRYPTED_SECRET Make_TPM2B_ENCRYPTED_SECRET(const std::string& bytes) {
+  TPM2B_ENCRYPTED_SECRET tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.secret));
+  memset(&tpm2b, 0, sizeof(TPM2B_ENCRYPTED_SECRET));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.secret, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_ENCRYPTED_SECRET(
+    const TPM2B_ENCRYPTED_SECRET& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.secret));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.secret);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_KEYEDHASH_PARMS(const TPMS_KEYEDHASH_PARMS& value,
+                                      std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMT_KEYEDHASH_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_KEYEDHASH_PARMS(std::string* buffer,
+                                  TPMS_KEYEDHASH_PARMS* value,
+                                  std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMT_KEYEDHASH_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_ASYM_PARMS(const TPMS_ASYM_PARMS& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMT_SYM_DEF_OBJECT(value.symmetric, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_ASYM_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ASYM_PARMS(std::string* buffer,
+                             TPMS_ASYM_PARMS* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMT_SYM_DEF_OBJECT(buffer, &value->symmetric, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_ASYM_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_RSA_PARMS(const TPMS_RSA_PARMS& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMT_SYM_DEF_OBJECT(value.symmetric, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_RSA_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RSA_KEY_BITS(value.key_bits, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT32(value.exponent, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_RSA_PARMS(std::string* buffer,
+                            TPMS_RSA_PARMS* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMT_SYM_DEF_OBJECT(buffer, &value->symmetric, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_RSA_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RSA_KEY_BITS(buffer, &value->key_bits, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT32(buffer, &value->exponent, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_ECC_PARMS(const TPMS_ECC_PARMS& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMT_SYM_DEF_OBJECT(value.symmetric, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_ECC_SCHEME(value.scheme, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_ECC_CURVE(value.curve_id, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMT_KDF_SCHEME(value.kdf, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_ECC_PARMS(std::string* buffer,
+                            TPMS_ECC_PARMS* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMT_SYM_DEF_OBJECT(buffer, &value->symmetric, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_ECC_SCHEME(buffer, &value->scheme, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_ECC_CURVE(buffer, &value->curve_id, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMT_KDF_SCHEME(buffer, &value->kdf, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_PUBLIC_PARMS(const TPMU_PUBLIC_PARMS& value,
+                                   TPMI_ALG_PUBLIC selector,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Serialize_TPMS_KEYEDHASH_PARMS(value.keyed_hash_detail, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Serialize_TPMS_RSA_PARMS(value.rsa_detail, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result = Serialize_TPMS_SYMCIPHER_PARMS(value.sym_detail, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Serialize_TPMS_ECC_PARMS(value.ecc_detail, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_PUBLIC_PARMS(std::string* buffer,
+                               TPMI_ALG_PUBLIC selector,
+                               TPMU_PUBLIC_PARMS* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Parse_TPMS_KEYEDHASH_PARMS(buffer, &value->keyed_hash_detail,
+                                        value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Parse_TPMS_RSA_PARMS(buffer, &value->rsa_detail, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result =
+        Parse_TPMS_SYMCIPHER_PARMS(buffer, &value->sym_detail, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Parse_TPMS_ECC_PARMS(buffer, &value->ecc_detail, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_PUBLIC_PARMS(const TPMT_PUBLIC_PARMS& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_PUBLIC(value.type, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_PUBLIC_PARMS(value.parameters, value.type, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_PUBLIC_PARMS(std::string* buffer,
+                               TPMT_PUBLIC_PARMS* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_PUBLIC(buffer, &value->type, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_PUBLIC_PARMS(buffer, value->type, &value->parameters,
+                                   value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMU_PUBLIC_ID(const TPMU_PUBLIC_ID& value,
+                                TPMI_ALG_PUBLIC selector,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Serialize_TPM2B_DIGEST(value.keyed_hash, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Serialize_TPM2B_PUBLIC_KEY_RSA(value.rsa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result = Serialize_TPM2B_DIGEST(value.sym, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Serialize_TPMS_ECC_POINT(value.ecc, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_PUBLIC_ID(std::string* buffer,
+                            TPMI_ALG_PUBLIC selector,
+                            TPMU_PUBLIC_ID* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Parse_TPM2B_DIGEST(buffer, &value->keyed_hash, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Parse_TPM2B_PUBLIC_KEY_RSA(buffer, &value->rsa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result = Parse_TPM2B_DIGEST(buffer, &value->sym, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Parse_TPMS_ECC_POINT(buffer, &value->ecc, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_PUBLIC(const TPMT_PUBLIC& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_PUBLIC(value.type, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_ALG_HASH(value.name_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_OBJECT(value.object_attributes, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.auth_policy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_PUBLIC_PARMS(value.parameters, value.type, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_PUBLIC_ID(value.unique, value.type, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_PUBLIC(std::string* buffer,
+                         TPMT_PUBLIC* value,
+                         std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_PUBLIC(buffer, &value->type, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->name_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_OBJECT(buffer, &value->object_attributes, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->auth_policy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_PUBLIC_PARMS(buffer, value->type, &value->parameters,
+                                   value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result =
+      Parse_TPMU_PUBLIC_ID(buffer, value->type, &value->unique, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_PUBLIC(const TPM2B_PUBLIC& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMT_PUBLIC)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMT_PUBLIC(value.public_area, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_PUBLIC(std::string* buffer,
+                          TPM2B_PUBLIC* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMT_PUBLIC);
+    result = Parse_TPMT_PUBLIC(buffer, &value->public_area, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_PUBLIC Make_TPM2B_PUBLIC(const TPMT_PUBLIC& inner) {
+  TPM2B_PUBLIC tpm2b;
+  tpm2b.size = sizeof(TPMT_PUBLIC);
+  tpm2b.public_area = inner;
+  return tpm2b;
+}
+
+TPM_RC Serialize_TPM2B_PRIVATE_VENDOR_SPECIFIC(
+    const TPM2B_PRIVATE_VENDOR_SPECIFIC& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_PRIVATE_VENDOR_SPECIFIC(std::string* buffer,
+                                           TPM2B_PRIVATE_VENDOR_SPECIFIC* value,
+                                           std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_PRIVATE_VENDOR_SPECIFIC Make_TPM2B_PRIVATE_VENDOR_SPECIFIC(
+    const std::string& bytes) {
+  TPM2B_PRIVATE_VENDOR_SPECIFIC tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_PRIVATE_VENDOR_SPECIFIC));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_PRIVATE_VENDOR_SPECIFIC(
+    const TPM2B_PRIVATE_VENDOR_SPECIFIC& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMU_SENSITIVE_COMPOSITE(const TPMU_SENSITIVE_COMPOSITE& value,
+                                          TPMI_ALG_PUBLIC selector,
+                                          std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Serialize_TPM2B_SENSITIVE_DATA(value.bits, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Serialize_TPM2B_PRIVATE_KEY_RSA(value.rsa, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result = Serialize_TPM2B_SYM_KEY(value.sym, buffer);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Serialize_TPM2B_ECC_PARAMETER(value.ecc, buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMU_SENSITIVE_COMPOSITE(std::string* buffer,
+                                      TPMI_ALG_PUBLIC selector,
+                                      TPMU_SENSITIVE_COMPOSITE* value,
+                                      std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  if (selector == TPM_ALG_KEYEDHASH) {
+    result = Parse_TPM2B_SENSITIVE_DATA(buffer, &value->bits, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_RSA) {
+    result = Parse_TPM2B_PRIVATE_KEY_RSA(buffer, &value->rsa, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_SYMCIPHER) {
+    result = Parse_TPM2B_SYM_KEY(buffer, &value->sym, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+
+  if (selector == TPM_ALG_ECC) {
+    result = Parse_TPM2B_ECC_PARAMETER(buffer, &value->ecc, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMT_SENSITIVE(const TPMT_SENSITIVE& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_ALG_PUBLIC(value.sensitive_type, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_AUTH(value.auth_value, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.seed_value, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMU_SENSITIVE_COMPOSITE(value.sensitive,
+                                              value.sensitive_type, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMT_SENSITIVE(std::string* buffer,
+                            TPMT_SENSITIVE* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_ALG_PUBLIC(buffer, &value->sensitive_type, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_AUTH(buffer, &value->auth_value, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->seed_value, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMU_SENSITIVE_COMPOSITE(buffer, value->sensitive_type,
+                                          &value->sensitive, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_SENSITIVE(const TPM2B_SENSITIVE& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMT_SENSITIVE)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMT_SENSITIVE(value.sensitive_area, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_SENSITIVE(std::string* buffer,
+                             TPM2B_SENSITIVE* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMT_SENSITIVE);
+    result = Parse_TPMT_SENSITIVE(buffer, &value->sensitive_area, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_SENSITIVE Make_TPM2B_SENSITIVE(const TPMT_SENSITIVE& inner) {
+  TPM2B_SENSITIVE tpm2b;
+  tpm2b.size = sizeof(TPMT_SENSITIVE);
+  tpm2b.sensitive_area = inner;
+  return tpm2b;
+}
+
+TPM_RC Serialize_TPM2B_PRIVATE(const TPM2B_PRIVATE& value,
+                               std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_PRIVATE(std::string* buffer,
+                           TPM2B_PRIVATE* value,
+                           std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_PRIVATE Make_TPM2B_PRIVATE(const std::string& bytes) {
+  TPM2B_PRIVATE tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_PRIVATE));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_PRIVATE(const TPM2B_PRIVATE& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPM2B_ID_OBJECT(const TPM2B_ID_OBJECT& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.credential) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.credential[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_ID_OBJECT(std::string* buffer,
+                             TPM2B_ID_OBJECT* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->credential) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->credential[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_ID_OBJECT Make_TPM2B_ID_OBJECT(const std::string& bytes) {
+  TPM2B_ID_OBJECT tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.credential));
+  memset(&tpm2b, 0, sizeof(TPM2B_ID_OBJECT));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.credential, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_ID_OBJECT(const TPM2B_ID_OBJECT& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.credential));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.credential);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_NV_PUBLIC(const TPMS_NV_PUBLIC& value,
+                                std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPMI_RH_NV_INDEX(value.nv_index, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_ALG_HASH(value.name_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_NV(value.attributes, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.auth_policy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_UINT16(value.data_size, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_NV_PUBLIC(std::string* buffer,
+                            TPMS_NV_PUBLIC* value,
+                            std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPMI_RH_NV_INDEX(buffer, &value->nv_index, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_ALG_HASH(buffer, &value->name_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_NV(buffer, &value->attributes, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->auth_policy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_UINT16(buffer, &value->data_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_NV_PUBLIC(const TPM2B_NV_PUBLIC& value,
+                                 std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMS_NV_PUBLIC)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMS_NV_PUBLIC(value.nv_public, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_NV_PUBLIC(std::string* buffer,
+                             TPM2B_NV_PUBLIC* value,
+                             std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMS_NV_PUBLIC);
+    result = Parse_TPMS_NV_PUBLIC(buffer, &value->nv_public, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_NV_PUBLIC Make_TPM2B_NV_PUBLIC(const TPMS_NV_PUBLIC& inner) {
+  TPM2B_NV_PUBLIC tpm2b;
+  tpm2b.size = sizeof(TPMS_NV_PUBLIC);
+  tpm2b.nv_public = inner;
+  return tpm2b;
+}
+
+TPM_RC Serialize_TPM2B_CONTEXT_SENSITIVE(const TPM2B_CONTEXT_SENSITIVE& value,
+                                         std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_CONTEXT_SENSITIVE(std::string* buffer,
+                                     TPM2B_CONTEXT_SENSITIVE* value,
+                                     std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_CONTEXT_SENSITIVE Make_TPM2B_CONTEXT_SENSITIVE(const std::string& bytes) {
+  TPM2B_CONTEXT_SENSITIVE tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_CONTEXT_SENSITIVE));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_CONTEXT_SENSITIVE(
+    const TPM2B_CONTEXT_SENSITIVE& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_CONTEXT_DATA(const TPMS_CONTEXT_DATA& value,
+                                   std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPM2B_DIGEST(value.integrity, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_CONTEXT_SENSITIVE(value.encrypted, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CONTEXT_DATA(std::string* buffer,
+                               TPMS_CONTEXT_DATA* value,
+                               std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->integrity, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result =
+      Parse_TPM2B_CONTEXT_SENSITIVE(buffer, &value->encrypted, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_CONTEXT_DATA(const TPM2B_CONTEXT_DATA& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT16(value.size, buffer);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value.buffer) < value.size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value.size; ++i) {
+    result = Serialize_BYTE(value.buffer[i], buffer);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM_RC Parse_TPM2B_CONTEXT_DATA(std::string* buffer,
+                                TPM2B_CONTEXT_DATA* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT16(buffer, &value->size, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  if (std::size(value->buffer) < value->size) {
+    return TPM_RC_INSUFFICIENT;
+  }
+  for (uint32_t i = 0; i < value->size; ++i) {
+    result = Parse_BYTE(buffer, &value->buffer[i], value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_CONTEXT_DATA Make_TPM2B_CONTEXT_DATA(const std::string& bytes) {
+  TPM2B_CONTEXT_DATA tpm2b;
+  CHECK(bytes.size() <= sizeof(tpm2b.buffer));
+  memset(&tpm2b, 0, sizeof(TPM2B_CONTEXT_DATA));
+  tpm2b.size = bytes.size();
+  memcpy(tpm2b.buffer, bytes.data(), bytes.size());
+  return tpm2b;
+}
+
+std::string StringFrom_TPM2B_CONTEXT_DATA(const TPM2B_CONTEXT_DATA& tpm2b) {
+  CHECK(tpm2b.size <= std::size(tpm2b.buffer));
+  const char* char_buffer = reinterpret_cast<const char*>(tpm2b.buffer);
+  return std::string(char_buffer, tpm2b.size);
+}
+
+TPM_RC Serialize_TPMS_CONTEXT(const TPMS_CONTEXT& value, std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_UINT64(value.sequence, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_DH_CONTEXT(value.saved_handle, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMI_RH_HIERARCHY(value.hierarchy, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_CONTEXT_DATA(value.context_blob, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CONTEXT(std::string* buffer,
+                          TPMS_CONTEXT* value,
+                          std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_UINT64(buffer, &value->sequence, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_DH_CONTEXT(buffer, &value->saved_handle, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMI_RH_HIERARCHY(buffer, &value->hierarchy, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_CONTEXT_DATA(buffer, &value->context_blob, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPMS_CREATION_DATA(const TPMS_CREATION_DATA& value,
+                                    std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Serialize_TPML_PCR_SELECTION(value.pcr_select, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DIGEST(value.pcr_digest, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPMA_LOCALITY(value.locality, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM_ALG_ID(value.parent_name_alg, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_NAME(value.parent_name, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_NAME(value.parent_qualified_name, buffer);
+  if (result) {
+    return result;
+  }
+
+  result = Serialize_TPM2B_DATA(value.outside_info, buffer);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Parse_TPMS_CREATION_DATA(std::string* buffer,
+                                TPMS_CREATION_DATA* value,
+                                std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  result = Parse_TPML_PCR_SELECTION(buffer, &value->pcr_select, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DIGEST(buffer, &value->pcr_digest, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPMA_LOCALITY(buffer, &value->locality, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM_ALG_ID(buffer, &value->parent_name_alg, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_NAME(buffer, &value->parent_name, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_NAME(buffer, &value->parent_qualified_name, value_bytes);
+  if (result) {
+    return result;
+  }
+
+  result = Parse_TPM2B_DATA(buffer, &value->outside_info, value_bytes);
+  if (result) {
+    return result;
+  }
+  return result;
+}
+
+TPM_RC Serialize_TPM2B_CREATION_DATA(const TPM2B_CREATION_DATA& value,
+                                     std::string* buffer) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  std::string field_bytes;
+  if (value.size) {
+    if (value.size != sizeof(TPMS_CREATION_DATA)) {
+      return TPM_RC_SIZE;
+    }
+    result = Serialize_TPMS_CREATION_DATA(value.creation_data, &field_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  std::string size_bytes;
+  result = Serialize_UINT16(field_bytes.size(), &size_bytes);
+  if (result) {
+    return result;
+  }
+  buffer->append(size_bytes + field_bytes);
+  return result;
+}
+
+TPM_RC Parse_TPM2B_CREATION_DATA(std::string* buffer,
+                                 TPM2B_CREATION_DATA* value,
+                                 std::string* value_bytes) {
+  TPM_RC result = TPM_RC_SUCCESS;
+  VLOG(3) << __func__;
+
+  UINT16 parsed_size = 0;
+  result = Parse_UINT16(buffer, &parsed_size, value_bytes);
+  if (result) {
+    return result;
+  }
+  if (!parsed_size) {
+    value->size = 0;
+  } else {
+    value->size = sizeof(TPMS_CREATION_DATA);
+    result =
+        Parse_TPMS_CREATION_DATA(buffer, &value->creation_data, value_bytes);
+    if (result) {
+      return result;
+    }
+  }
+  return result;
+}
+
+TPM2B_CREATION_DATA Make_TPM2B_CREATION_DATA(const TPMS_CREATION_DATA& inner) {
+  TPM2B_CREATION_DATA tpm2b;
+  tpm2b.size = sizeof(TPMS_CREATION_DATA);
+  tpm2b.creation_data = inner;
+  return tpm2b;
+}
+
+TPM_RC Tpm::SerializeCommand_Startup(
+    const TPM_SU& startup_type,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Startup;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string startup_type_bytes;
+  rc = Serialize_TPM_SU(startup_type, &startup_type_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(startup_type_bytes.data(), startup_type_bytes.size());
+  parameter_section_bytes += startup_type_bytes;
+  command_size += startup_type_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Startup(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Startup;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void StartupErrorCallback(Tpm::StartupResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void StartupResponseParser(Tpm::StartupResponse callback,
+                           AuthorizationDelegate* authorization_delegate,
+                           const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_Startup(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StartupErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::Startup(const TPM_SU& startup_type,
+                  AuthorizationDelegate* authorization_delegate,
+                  StartupResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Startup(startup_type, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StartupErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      StartupResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::StartupSync(const TPM_SU& startup_type,
+                        AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Startup(startup_type, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Startup(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Shutdown(
+    const TPM_SU& shutdown_type,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Shutdown;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string shutdown_type_bytes;
+  rc = Serialize_TPM_SU(shutdown_type, &shutdown_type_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(shutdown_type_bytes.data(), shutdown_type_bytes.size());
+  parameter_section_bytes += shutdown_type_bytes;
+  command_size += shutdown_type_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Shutdown(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Shutdown;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ShutdownErrorCallback(Tpm::ShutdownResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ShutdownResponseParser(Tpm::ShutdownResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_Shutdown(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ShutdownErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::Shutdown(const TPM_SU& shutdown_type,
+                   AuthorizationDelegate* authorization_delegate,
+                   ShutdownResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Shutdown(shutdown_type, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ShutdownErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ShutdownResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ShutdownSync(const TPM_SU& shutdown_type,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Shutdown(shutdown_type, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Shutdown(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SelfTest(
+    const TPMI_YES_NO& full_test,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SelfTest;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string full_test_bytes;
+  rc = Serialize_TPMI_YES_NO(full_test, &full_test_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(full_test_bytes.data(), full_test_bytes.size());
+  parameter_section_bytes += full_test_bytes;
+  command_size += full_test_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SelfTest(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SelfTest;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SelfTestErrorCallback(Tpm::SelfTestResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void SelfTestResponseParser(Tpm::SelfTestResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_SelfTest(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SelfTestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::SelfTest(const TPMI_YES_NO& full_test,
+                   AuthorizationDelegate* authorization_delegate,
+                   SelfTestResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_SelfTest(full_test, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SelfTestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      SelfTestResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SelfTestSync(const TPMI_YES_NO& full_test,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_SelfTest(full_test, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_SelfTest(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_IncrementalSelfTest(
+    const TPML_ALG& to_test,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_IncrementalSelfTest;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string to_test_bytes;
+  rc = Serialize_TPML_ALG(to_test, &to_test_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(to_test_bytes.data(), to_test_bytes.size());
+  parameter_section_bytes += to_test_bytes;
+  command_size += to_test_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_IncrementalSelfTest(
+    const std::string& response,
+    TPML_ALG* to_do_list,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_IncrementalSelfTest;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string to_do_list_bytes;
+  rc = Parse_TPML_ALG(&buffer, to_do_list, &to_do_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void IncrementalSelfTestErrorCallback(Tpm::IncrementalSelfTestResponse callback,
+                                      TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPML_ALG());
+}
+
+void IncrementalSelfTestResponseParser(
+    Tpm::IncrementalSelfTestResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPML_ALG to_do_list;
+  TPM_RC rc = Tpm::ParseResponse_IncrementalSelfTest(response, &to_do_list,
+                                                     authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(IncrementalSelfTestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, to_do_list);
+}
+
+void Tpm::IncrementalSelfTest(const TPML_ALG& to_test,
+                              AuthorizationDelegate* authorization_delegate,
+                              IncrementalSelfTestResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_IncrementalSelfTest(to_test, &command,
+                                                   authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(IncrementalSelfTestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(IncrementalSelfTestResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::IncrementalSelfTestSync(
+    const TPML_ALG& to_test,
+    TPML_ALG* to_do_list,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_IncrementalSelfTest(to_test, &command,
+                                                   authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_IncrementalSelfTest(response, to_do_list,
+                                         authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetTestResult(
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetTestResult;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetTestResult(
+    const std::string& response,
+    TPM2B_MAX_BUFFER* out_data,
+    TPM_RC* test_result,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetTestResult;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_data_bytes;
+  rc = Parse_TPM2B_MAX_BUFFER(&buffer, out_data, &out_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string test_result_bytes;
+  rc = Parse_TPM_RC(&buffer, test_result, &test_result_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetTestResultErrorCallback(Tpm::GetTestResultResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_MAX_BUFFER(), TPM_RC());
+}
+
+void GetTestResultResponseParser(Tpm::GetTestResultResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_MAX_BUFFER out_data;
+  TPM_RC test_result;
+  TPM_RC rc = Tpm::ParseResponse_GetTestResult(
+      response, &out_data, &test_result, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetTestResultErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_data, test_result);
+}
+
+void Tpm::GetTestResult(AuthorizationDelegate* authorization_delegate,
+                        GetTestResultResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetTestResult(&command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetTestResultErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      GetTestResultResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetTestResultSync(TPM2B_MAX_BUFFER* out_data,
+                              TPM_RC* test_result,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetTestResult(&command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetTestResult(response, out_data, test_result,
+                                   authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_StartAuthSession(
+    const TPMI_DH_OBJECT& tpm_key,
+    const std::string& tpm_key_name,
+    const TPMI_DH_ENTITY& bind,
+    const std::string& bind_name,
+    const TPM2B_NONCE& nonce_caller,
+    const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+    const TPM_SE& session_type,
+    const TPMT_SYM_DEF& symmetric,
+    const TPMI_ALG_HASH& auth_hash,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_StartAuthSession;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string tpm_key_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(tpm_key, &tpm_key_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string bind_bytes;
+  rc = Serialize_TPMI_DH_ENTITY(bind, &bind_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nonce_caller_bytes;
+  rc = Serialize_TPM2B_NONCE(nonce_caller, &nonce_caller_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string encrypted_salt_bytes;
+  rc = Serialize_TPM2B_ENCRYPTED_SECRET(encrypted_salt, &encrypted_salt_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string session_type_bytes;
+  rc = Serialize_TPM_SE(session_type, &session_type_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string symmetric_bytes;
+  rc = Serialize_TPMT_SYM_DEF(symmetric, &symmetric_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_hash_bytes;
+  rc = Serialize_TPMI_ALG_HASH(auth_hash, &auth_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = nonce_caller_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    nonce_caller_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(tpm_key_name.data(), tpm_key_name.size());
+  handle_section_bytes += tpm_key_bytes;
+  command_size += tpm_key_bytes.size();
+  hash->Update(bind_name.data(), bind_name.size());
+  handle_section_bytes += bind_bytes;
+  command_size += bind_bytes.size();
+  hash->Update(nonce_caller_bytes.data(), nonce_caller_bytes.size());
+  parameter_section_bytes += nonce_caller_bytes;
+  command_size += nonce_caller_bytes.size();
+  hash->Update(encrypted_salt_bytes.data(), encrypted_salt_bytes.size());
+  parameter_section_bytes += encrypted_salt_bytes;
+  command_size += encrypted_salt_bytes.size();
+  hash->Update(session_type_bytes.data(), session_type_bytes.size());
+  parameter_section_bytes += session_type_bytes;
+  command_size += session_type_bytes.size();
+  hash->Update(symmetric_bytes.data(), symmetric_bytes.size());
+  parameter_section_bytes += symmetric_bytes;
+  command_size += symmetric_bytes.size();
+  hash->Update(auth_hash_bytes.data(), auth_hash_bytes.size());
+  parameter_section_bytes += auth_hash_bytes;
+  command_size += auth_hash_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_StartAuthSession(
+    const std::string& response,
+    TPMI_SH_AUTH_SESSION* session_handle,
+    TPM2B_NONCE* nonce_tpm,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string session_handle_bytes;
+  rc = Parse_TPMI_SH_AUTH_SESSION(&buffer, session_handle,
+                                  &session_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_StartAuthSession;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string nonce_tpm_bytes;
+  rc = Parse_TPM2B_NONCE(&buffer, nonce_tpm, &nonce_tpm_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void StartAuthSessionErrorCallback(Tpm::StartAuthSessionResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_SH_AUTH_SESSION(), TPM2B_NONCE());
+}
+
+void StartAuthSessionResponseParser(
+    Tpm::StartAuthSessionResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_SH_AUTH_SESSION session_handle;
+  TPM2B_NONCE nonce_tpm;
+  TPM_RC rc = Tpm::ParseResponse_StartAuthSession(
+      response, &session_handle, &nonce_tpm, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StartAuthSessionErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, session_handle, nonce_tpm);
+}
+
+void Tpm::StartAuthSession(const TPMI_DH_OBJECT& tpm_key,
+                           const std::string& tpm_key_name,
+                           const TPMI_DH_ENTITY& bind,
+                           const std::string& bind_name,
+                           const TPM2B_NONCE& nonce_caller,
+                           const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+                           const TPM_SE& session_type,
+                           const TPMT_SYM_DEF& symmetric,
+                           const TPMI_ALG_HASH& auth_hash,
+                           AuthorizationDelegate* authorization_delegate,
+                           StartAuthSessionResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_StartAuthSession(
+      tpm_key, tpm_key_name, bind, bind_name, nonce_caller, encrypted_salt,
+      session_type, symmetric, auth_hash, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StartAuthSessionErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(StartAuthSessionResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::StartAuthSessionSync(
+    const TPMI_DH_OBJECT& tpm_key,
+    const std::string& tpm_key_name,
+    const TPMI_DH_ENTITY& bind,
+    const std::string& bind_name,
+    const TPM2B_NONCE& nonce_caller,
+    const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+    const TPM_SE& session_type,
+    const TPMT_SYM_DEF& symmetric,
+    const TPMI_ALG_HASH& auth_hash,
+    TPMI_SH_AUTH_SESSION* session_handle,
+    TPM2B_NONCE* nonce_tpm,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_StartAuthSession(
+      tpm_key, tpm_key_name, bind, bind_name, nonce_caller, encrypted_salt,
+      session_type, symmetric, auth_hash, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_StartAuthSession(response, session_handle, nonce_tpm,
+                                      authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyRestart(
+    const TPMI_SH_POLICY& session_handle,
+    const std::string& session_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyRestart;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string session_handle_bytes;
+  rc = Serialize_TPMI_SH_POLICY(session_handle, &session_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(session_handle_name.data(), session_handle_name.size());
+  handle_section_bytes += session_handle_bytes;
+  command_size += session_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyRestart(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyRestart;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyRestartErrorCallback(Tpm::PolicyRestartResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyRestartResponseParser(Tpm::PolicyRestartResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyRestart(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyRestartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyRestart(const TPMI_SH_POLICY& session_handle,
+                        const std::string& session_handle_name,
+                        AuthorizationDelegate* authorization_delegate,
+                        PolicyRestartResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyRestart(
+      session_handle, session_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyRestartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyRestartResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyRestartSync(const TPMI_SH_POLICY& session_handle,
+                              const std::string& session_handle_name,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyRestart(
+      session_handle, session_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyRestart(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Create(
+    const TPMI_DH_OBJECT& parent_handle,
+    const std::string& parent_handle_name,
+    const TPM2B_SENSITIVE_CREATE& in_sensitive,
+    const TPM2B_PUBLIC& in_public,
+    const TPM2B_DATA& outside_info,
+    const TPML_PCR_SELECTION& creation_pcr,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Create;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string parent_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(parent_handle, &parent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_sensitive_bytes;
+  rc = Serialize_TPM2B_SENSITIVE_CREATE(in_sensitive, &in_sensitive_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_public_bytes;
+  rc = Serialize_TPM2B_PUBLIC(in_public, &in_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string outside_info_bytes;
+  rc = Serialize_TPM2B_DATA(outside_info, &outside_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_pcr_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(creation_pcr, &creation_pcr_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_sensitive_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_sensitive_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(parent_handle_name.data(), parent_handle_name.size());
+  handle_section_bytes += parent_handle_bytes;
+  command_size += parent_handle_bytes.size();
+  hash->Update(in_sensitive_bytes.data(), in_sensitive_bytes.size());
+  parameter_section_bytes += in_sensitive_bytes;
+  command_size += in_sensitive_bytes.size();
+  hash->Update(in_public_bytes.data(), in_public_bytes.size());
+  parameter_section_bytes += in_public_bytes;
+  command_size += in_public_bytes.size();
+  hash->Update(outside_info_bytes.data(), outside_info_bytes.size());
+  parameter_section_bytes += outside_info_bytes;
+  command_size += outside_info_bytes.size();
+  hash->Update(creation_pcr_bytes.data(), creation_pcr_bytes.size());
+  parameter_section_bytes += creation_pcr_bytes;
+  command_size += creation_pcr_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Create(
+    const std::string& response,
+    TPM2B_PRIVATE* out_private,
+    TPM2B_PUBLIC* out_public,
+    TPM2B_CREATION_DATA* creation_data,
+    TPM2B_DIGEST* creation_hash,
+    TPMT_TK_CREATION* creation_ticket,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Create;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_private_bytes;
+  rc = Parse_TPM2B_PRIVATE(&buffer, out_private, &out_private_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string out_public_bytes;
+  rc = Parse_TPM2B_PUBLIC(&buffer, out_public, &out_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_data_bytes;
+  rc = Parse_TPM2B_CREATION_DATA(&buffer, creation_data, &creation_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_hash_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, creation_hash, &creation_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_ticket_bytes;
+  rc = Parse_TPMT_TK_CREATION(&buffer, creation_ticket, &creation_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void CreateErrorCallback(Tpm::CreateResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PRIVATE(), TPM2B_PUBLIC(),
+                          TPM2B_CREATION_DATA(), TPM2B_DIGEST(),
+                          TPMT_TK_CREATION());
+}
+
+void CreateResponseParser(Tpm::CreateResponse callback,
+                          AuthorizationDelegate* authorization_delegate,
+                          const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PRIVATE out_private;
+  TPM2B_PUBLIC out_public;
+  TPM2B_CREATION_DATA creation_data;
+  TPM2B_DIGEST creation_hash;
+  TPMT_TK_CREATION creation_ticket;
+  TPM_RC rc = Tpm::ParseResponse_Create(
+      response, &out_private, &out_public, &creation_data, &creation_hash,
+      &creation_ticket, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CreateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_private, out_public, creation_data,
+                          creation_hash, creation_ticket);
+}
+
+void Tpm::Create(const TPMI_DH_OBJECT& parent_handle,
+                 const std::string& parent_handle_name,
+                 const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                 const TPM2B_PUBLIC& in_public,
+                 const TPM2B_DATA& outside_info,
+                 const TPML_PCR_SELECTION& creation_pcr,
+                 AuthorizationDelegate* authorization_delegate,
+                 CreateResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Create(
+      parent_handle, parent_handle_name, in_sensitive, in_public, outside_info,
+      creation_pcr, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CreateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      CreateResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::CreateSync(const TPMI_DH_OBJECT& parent_handle,
+                       const std::string& parent_handle_name,
+                       const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                       const TPM2B_PUBLIC& in_public,
+                       const TPM2B_DATA& outside_info,
+                       const TPML_PCR_SELECTION& creation_pcr,
+                       TPM2B_PRIVATE* out_private,
+                       TPM2B_PUBLIC* out_public,
+                       TPM2B_CREATION_DATA* creation_data,
+                       TPM2B_DIGEST* creation_hash,
+                       TPMT_TK_CREATION* creation_ticket,
+                       AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Create(
+      parent_handle, parent_handle_name, in_sensitive, in_public, outside_info,
+      creation_pcr, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Create(response, out_private, out_public, creation_data,
+                            creation_hash, creation_ticket,
+                            authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Load(
+    const TPMI_DH_OBJECT& parent_handle,
+    const std::string& parent_handle_name,
+    const TPM2B_PRIVATE& in_private,
+    const TPM2B_PUBLIC& in_public,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Load;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string parent_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(parent_handle, &parent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_private_bytes;
+  rc = Serialize_TPM2B_PRIVATE(in_private, &in_private_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_public_bytes;
+  rc = Serialize_TPM2B_PUBLIC(in_public, &in_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_private_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_private_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(parent_handle_name.data(), parent_handle_name.size());
+  handle_section_bytes += parent_handle_bytes;
+  command_size += parent_handle_bytes.size();
+  hash->Update(in_private_bytes.data(), in_private_bytes.size());
+  parameter_section_bytes += in_private_bytes;
+  command_size += in_private_bytes.size();
+  hash->Update(in_public_bytes.data(), in_public_bytes.size());
+  parameter_section_bytes += in_public_bytes;
+  command_size += in_public_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Load(const std::string& response,
+                               TPM_HANDLE* object_handle,
+                               TPM2B_NAME* name,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string object_handle_bytes;
+  rc = Parse_TPM_HANDLE(&buffer, object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_Load;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, name, &name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void LoadErrorCallback(Tpm::LoadResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM_HANDLE(), TPM2B_NAME());
+}
+
+void LoadResponseParser(Tpm::LoadResponse callback,
+                        AuthorizationDelegate* authorization_delegate,
+                        const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_HANDLE object_handle;
+  TPM2B_NAME name;
+  TPM_RC rc = Tpm::ParseResponse_Load(response, &object_handle, &name,
+                                      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(LoadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, object_handle, name);
+}
+
+void Tpm::Load(const TPMI_DH_OBJECT& parent_handle,
+               const std::string& parent_handle_name,
+               const TPM2B_PRIVATE& in_private,
+               const TPM2B_PUBLIC& in_public,
+               AuthorizationDelegate* authorization_delegate,
+               LoadResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Load(parent_handle, parent_handle_name, in_private,
+                            in_public, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(LoadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      LoadResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::LoadSync(const TPMI_DH_OBJECT& parent_handle,
+                     const std::string& parent_handle_name,
+                     const TPM2B_PRIVATE& in_private,
+                     const TPM2B_PUBLIC& in_public,
+                     TPM_HANDLE* object_handle,
+                     TPM2B_NAME* name,
+                     AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Load(parent_handle, parent_handle_name, in_private,
+                            in_public, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc =
+      ParseResponse_Load(response, object_handle, name, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_LoadExternal(
+    const TPM2B_SENSITIVE& in_private,
+    const TPM2B_PUBLIC& in_public,
+    const TPMI_RH_HIERARCHY& hierarchy,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_LoadExternal;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_private_bytes;
+  rc = Serialize_TPM2B_SENSITIVE(in_private, &in_private_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_public_bytes;
+  rc = Serialize_TPM2B_PUBLIC(in_public, &in_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hierarchy_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(hierarchy, &hierarchy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_private_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_private_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(in_private_bytes.data(), in_private_bytes.size());
+  parameter_section_bytes += in_private_bytes;
+  command_size += in_private_bytes.size();
+  hash->Update(in_public_bytes.data(), in_public_bytes.size());
+  parameter_section_bytes += in_public_bytes;
+  command_size += in_public_bytes.size();
+  hash->Update(hierarchy_bytes.data(), hierarchy_bytes.size());
+  parameter_section_bytes += hierarchy_bytes;
+  command_size += hierarchy_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_LoadExternal(
+    const std::string& response,
+    TPM_HANDLE* object_handle,
+    TPM2B_NAME* name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string object_handle_bytes;
+  rc = Parse_TPM_HANDLE(&buffer, object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_LoadExternal;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, name, &name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void LoadExternalErrorCallback(Tpm::LoadExternalResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM_HANDLE(), TPM2B_NAME());
+}
+
+void LoadExternalResponseParser(Tpm::LoadExternalResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_HANDLE object_handle;
+  TPM2B_NAME name;
+  TPM_RC rc = Tpm::ParseResponse_LoadExternal(response, &object_handle, &name,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(LoadExternalErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, object_handle, name);
+}
+
+void Tpm::LoadExternal(const TPM2B_SENSITIVE& in_private,
+                       const TPM2B_PUBLIC& in_public,
+                       const TPMI_RH_HIERARCHY& hierarchy,
+                       AuthorizationDelegate* authorization_delegate,
+                       LoadExternalResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_LoadExternal(in_private, in_public, hierarchy,
+                                            &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(LoadExternalErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      LoadExternalResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::LoadExternalSync(const TPM2B_SENSITIVE& in_private,
+                             const TPM2B_PUBLIC& in_public,
+                             const TPMI_RH_HIERARCHY& hierarchy,
+                             TPM_HANDLE* object_handle,
+                             TPM2B_NAME* name,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_LoadExternal(in_private, in_public, hierarchy,
+                                            &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_LoadExternal(response, object_handle, name,
+                                  authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ReadPublic(
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ReadPublic;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ReadPublic(
+    const std::string& response,
+    TPM2B_PUBLIC* out_public,
+    TPM2B_NAME* name,
+    TPM2B_NAME* qualified_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ReadPublic;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_public_bytes;
+  rc = Parse_TPM2B_PUBLIC(&buffer, out_public, &out_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, name, &name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualified_name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, qualified_name, &qualified_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ReadPublicErrorCallback(Tpm::ReadPublicResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PUBLIC(), TPM2B_NAME(),
+                          TPM2B_NAME());
+}
+
+void ReadPublicResponseParser(Tpm::ReadPublicResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PUBLIC out_public;
+  TPM2B_NAME name;
+  TPM2B_NAME qualified_name;
+  TPM_RC rc = Tpm::ParseResponse_ReadPublic(
+      response, &out_public, &name, &qualified_name, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ReadPublicErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_public, name, qualified_name);
+}
+
+void Tpm::ReadPublic(const TPMI_DH_OBJECT& object_handle,
+                     const std::string& object_handle_name,
+                     AuthorizationDelegate* authorization_delegate,
+                     ReadPublicResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ReadPublic(object_handle, object_handle_name,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ReadPublicErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ReadPublicResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ReadPublicSync(const TPMI_DH_OBJECT& object_handle,
+                           const std::string& object_handle_name,
+                           TPM2B_PUBLIC* out_public,
+                           TPM2B_NAME* name,
+                           TPM2B_NAME* qualified_name,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ReadPublic(object_handle, object_handle_name,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ReadPublic(response, out_public, name, qualified_name,
+                                authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ActivateCredential(
+    const TPMI_DH_OBJECT& activate_handle,
+    const std::string& activate_handle_name,
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_ID_OBJECT& credential_blob,
+    const TPM2B_ENCRYPTED_SECRET& secret,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ActivateCredential;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string activate_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(activate_handle, &activate_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string credential_blob_bytes;
+  rc = Serialize_TPM2B_ID_OBJECT(credential_blob, &credential_blob_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string secret_bytes;
+  rc = Serialize_TPM2B_ENCRYPTED_SECRET(secret, &secret_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = credential_blob_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    credential_blob_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(activate_handle_name.data(), activate_handle_name.size());
+  handle_section_bytes += activate_handle_bytes;
+  command_size += activate_handle_bytes.size();
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(credential_blob_bytes.data(), credential_blob_bytes.size());
+  parameter_section_bytes += credential_blob_bytes;
+  command_size += credential_blob_bytes.size();
+  hash->Update(secret_bytes.data(), secret_bytes.size());
+  parameter_section_bytes += secret_bytes;
+  command_size += secret_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ActivateCredential(
+    const std::string& response,
+    TPM2B_DIGEST* cert_info,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ActivateCredential;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string cert_info_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, cert_info, &cert_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ActivateCredentialErrorCallback(Tpm::ActivateCredentialResponse callback,
+                                     TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST());
+}
+
+void ActivateCredentialResponseParser(
+    Tpm::ActivateCredentialResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST cert_info;
+  TPM_RC rc = Tpm::ParseResponse_ActivateCredential(response, &cert_info,
+                                                    authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ActivateCredentialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, cert_info);
+}
+
+void Tpm::ActivateCredential(const TPMI_DH_OBJECT& activate_handle,
+                             const std::string& activate_handle_name,
+                             const TPMI_DH_OBJECT& key_handle,
+                             const std::string& key_handle_name,
+                             const TPM2B_ID_OBJECT& credential_blob,
+                             const TPM2B_ENCRYPTED_SECRET& secret,
+                             AuthorizationDelegate* authorization_delegate,
+                             ActivateCredentialResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ActivateCredential(
+      activate_handle, activate_handle_name, key_handle, key_handle_name,
+      credential_blob, secret, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ActivateCredentialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(ActivateCredentialResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ActivateCredentialSync(
+    const TPMI_DH_OBJECT& activate_handle,
+    const std::string& activate_handle_name,
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_ID_OBJECT& credential_blob,
+    const TPM2B_ENCRYPTED_SECRET& secret,
+    TPM2B_DIGEST* cert_info,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ActivateCredential(
+      activate_handle, activate_handle_name, key_handle, key_handle_name,
+      credential_blob, secret, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ActivateCredential(response, cert_info,
+                                        authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_MakeCredential(
+    const TPMI_DH_OBJECT& handle,
+    const std::string& handle_name,
+    const TPM2B_DIGEST& credential,
+    const TPM2B_NAME& object_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_MakeCredential;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(handle, &handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string credential_bytes;
+  rc = Serialize_TPM2B_DIGEST(credential, &credential_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_name_bytes;
+  rc = Serialize_TPM2B_NAME(object_name, &object_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = credential_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    credential_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(handle_name.data(), handle_name.size());
+  handle_section_bytes += handle_bytes;
+  command_size += handle_bytes.size();
+  hash->Update(credential_bytes.data(), credential_bytes.size());
+  parameter_section_bytes += credential_bytes;
+  command_size += credential_bytes.size();
+  hash->Update(object_name_bytes.data(), object_name_bytes.size());
+  parameter_section_bytes += object_name_bytes;
+  command_size += object_name_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_MakeCredential(
+    const std::string& response,
+    TPM2B_ID_OBJECT* credential_blob,
+    TPM2B_ENCRYPTED_SECRET* secret,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_MakeCredential;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string credential_blob_bytes;
+  rc = Parse_TPM2B_ID_OBJECT(&buffer, credential_blob, &credential_blob_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string secret_bytes;
+  rc = Parse_TPM2B_ENCRYPTED_SECRET(&buffer, secret, &secret_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void MakeCredentialErrorCallback(Tpm::MakeCredentialResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ID_OBJECT(),
+                          TPM2B_ENCRYPTED_SECRET());
+}
+
+void MakeCredentialResponseParser(Tpm::MakeCredentialResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ID_OBJECT credential_blob;
+  TPM2B_ENCRYPTED_SECRET secret;
+  TPM_RC rc = Tpm::ParseResponse_MakeCredential(
+      response, &credential_blob, &secret, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(MakeCredentialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, credential_blob, secret);
+}
+
+void Tpm::MakeCredential(const TPMI_DH_OBJECT& handle,
+                         const std::string& handle_name,
+                         const TPM2B_DIGEST& credential,
+                         const TPM2B_NAME& object_name,
+                         AuthorizationDelegate* authorization_delegate,
+                         MakeCredentialResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_MakeCredential(handle, handle_name, credential,
+                                              object_name, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(MakeCredentialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(MakeCredentialResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::MakeCredentialSync(const TPMI_DH_OBJECT& handle,
+                               const std::string& handle_name,
+                               const TPM2B_DIGEST& credential,
+                               const TPM2B_NAME& object_name,
+                               TPM2B_ID_OBJECT* credential_blob,
+                               TPM2B_ENCRYPTED_SECRET* secret,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_MakeCredential(handle, handle_name, credential,
+                                              object_name, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_MakeCredential(response, credential_blob, secret,
+                                    authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Unseal(
+    const TPMI_DH_OBJECT& item_handle,
+    const std::string& item_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Unseal;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string item_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(item_handle, &item_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(item_handle_name.data(), item_handle_name.size());
+  handle_section_bytes += item_handle_bytes;
+  command_size += item_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Unseal(
+    const std::string& response,
+    TPM2B_SENSITIVE_DATA* out_data,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Unseal;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_data_bytes;
+  rc = Parse_TPM2B_SENSITIVE_DATA(&buffer, out_data, &out_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void UnsealErrorCallback(Tpm::UnsealResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_SENSITIVE_DATA());
+}
+
+void UnsealResponseParser(Tpm::UnsealResponse callback,
+                          AuthorizationDelegate* authorization_delegate,
+                          const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_SENSITIVE_DATA out_data;
+  TPM_RC rc =
+      Tpm::ParseResponse_Unseal(response, &out_data, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(UnsealErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_data);
+}
+
+void Tpm::Unseal(const TPMI_DH_OBJECT& item_handle,
+                 const std::string& item_handle_name,
+                 AuthorizationDelegate* authorization_delegate,
+                 UnsealResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Unseal(item_handle, item_handle_name, &command,
+                                      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(UnsealErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      UnsealResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::UnsealSync(const TPMI_DH_OBJECT& item_handle,
+                       const std::string& item_handle_name,
+                       TPM2B_SENSITIVE_DATA* out_data,
+                       AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Unseal(item_handle, item_handle_name, &command,
+                                      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Unseal(response, out_data, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ObjectChangeAuth(
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPMI_DH_OBJECT& parent_handle,
+    const std::string& parent_handle_name,
+    const TPM2B_AUTH& new_auth,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ObjectChangeAuth;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string parent_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(parent_handle, &parent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_auth_bytes;
+  rc = Serialize_TPM2B_AUTH(new_auth, &new_auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = new_auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    new_auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  hash->Update(parent_handle_name.data(), parent_handle_name.size());
+  handle_section_bytes += parent_handle_bytes;
+  command_size += parent_handle_bytes.size();
+  hash->Update(new_auth_bytes.data(), new_auth_bytes.size());
+  parameter_section_bytes += new_auth_bytes;
+  command_size += new_auth_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ObjectChangeAuth(
+    const std::string& response,
+    TPM2B_PRIVATE* out_private,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ObjectChangeAuth;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_private_bytes;
+  rc = Parse_TPM2B_PRIVATE(&buffer, out_private, &out_private_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ObjectChangeAuthErrorCallback(Tpm::ObjectChangeAuthResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PRIVATE());
+}
+
+void ObjectChangeAuthResponseParser(
+    Tpm::ObjectChangeAuthResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PRIVATE out_private;
+  TPM_RC rc = Tpm::ParseResponse_ObjectChangeAuth(response, &out_private,
+                                                  authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ObjectChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_private);
+}
+
+void Tpm::ObjectChangeAuth(const TPMI_DH_OBJECT& object_handle,
+                           const std::string& object_handle_name,
+                           const TPMI_DH_OBJECT& parent_handle,
+                           const std::string& parent_handle_name,
+                           const TPM2B_AUTH& new_auth,
+                           AuthorizationDelegate* authorization_delegate,
+                           ObjectChangeAuthResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ObjectChangeAuth(
+      object_handle, object_handle_name, parent_handle, parent_handle_name,
+      new_auth, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ObjectChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(ObjectChangeAuthResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ObjectChangeAuthSync(
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPMI_DH_OBJECT& parent_handle,
+    const std::string& parent_handle_name,
+    const TPM2B_AUTH& new_auth,
+    TPM2B_PRIVATE* out_private,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ObjectChangeAuth(
+      object_handle, object_handle_name, parent_handle, parent_handle_name,
+      new_auth, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ObjectChangeAuth(response, out_private,
+                                      authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Duplicate(
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPMI_DH_OBJECT& new_parent_handle,
+    const std::string& new_parent_handle_name,
+    const TPM2B_DATA& encryption_key_in,
+    const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Duplicate;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_parent_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(new_parent_handle, &new_parent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string encryption_key_in_bytes;
+  rc = Serialize_TPM2B_DATA(encryption_key_in, &encryption_key_in_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string symmetric_alg_bytes;
+  rc = Serialize_TPMT_SYM_DEF_OBJECT(symmetric_alg, &symmetric_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = encryption_key_in_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    encryption_key_in_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  hash->Update(new_parent_handle_name.data(), new_parent_handle_name.size());
+  handle_section_bytes += new_parent_handle_bytes;
+  command_size += new_parent_handle_bytes.size();
+  hash->Update(encryption_key_in_bytes.data(), encryption_key_in_bytes.size());
+  parameter_section_bytes += encryption_key_in_bytes;
+  command_size += encryption_key_in_bytes.size();
+  hash->Update(symmetric_alg_bytes.data(), symmetric_alg_bytes.size());
+  parameter_section_bytes += symmetric_alg_bytes;
+  command_size += symmetric_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Duplicate(
+    const std::string& response,
+    TPM2B_DATA* encryption_key_out,
+    TPM2B_PRIVATE* duplicate,
+    TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Duplicate;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string encryption_key_out_bytes;
+  rc = Parse_TPM2B_DATA(&buffer, encryption_key_out, &encryption_key_out_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string duplicate_bytes;
+  rc = Parse_TPM2B_PRIVATE(&buffer, duplicate, &duplicate_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string out_sym_seed_bytes;
+  rc = Parse_TPM2B_ENCRYPTED_SECRET(&buffer, out_sym_seed, &out_sym_seed_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void DuplicateErrorCallback(Tpm::DuplicateResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DATA(), TPM2B_PRIVATE(),
+                          TPM2B_ENCRYPTED_SECRET());
+}
+
+void DuplicateResponseParser(Tpm::DuplicateResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DATA encryption_key_out;
+  TPM2B_PRIVATE duplicate;
+  TPM2B_ENCRYPTED_SECRET out_sym_seed;
+  TPM_RC rc =
+      Tpm::ParseResponse_Duplicate(response, &encryption_key_out, &duplicate,
+                                   &out_sym_seed, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(DuplicateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, encryption_key_out, duplicate, out_sym_seed);
+}
+
+void Tpm::Duplicate(const TPMI_DH_OBJECT& object_handle,
+                    const std::string& object_handle_name,
+                    const TPMI_DH_OBJECT& new_parent_handle,
+                    const std::string& new_parent_handle_name,
+                    const TPM2B_DATA& encryption_key_in,
+                    const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                    AuthorizationDelegate* authorization_delegate,
+                    DuplicateResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Duplicate(
+      object_handle, object_handle_name, new_parent_handle,
+      new_parent_handle_name, encryption_key_in, symmetric_alg, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(DuplicateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      DuplicateResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::DuplicateSync(const TPMI_DH_OBJECT& object_handle,
+                          const std::string& object_handle_name,
+                          const TPMI_DH_OBJECT& new_parent_handle,
+                          const std::string& new_parent_handle_name,
+                          const TPM2B_DATA& encryption_key_in,
+                          const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                          TPM2B_DATA* encryption_key_out,
+                          TPM2B_PRIVATE* duplicate,
+                          TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Duplicate(
+      object_handle, object_handle_name, new_parent_handle,
+      new_parent_handle_name, encryption_key_in, symmetric_alg, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Duplicate(response, encryption_key_out, duplicate,
+                               out_sym_seed, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Rewrap(
+    const TPMI_DH_OBJECT& old_parent,
+    const std::string& old_parent_name,
+    const TPMI_DH_OBJECT& new_parent,
+    const std::string& new_parent_name,
+    const TPM2B_PRIVATE& in_duplicate,
+    const TPM2B_NAME& name,
+    const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Rewrap;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string old_parent_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(old_parent, &old_parent_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_parent_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(new_parent, &new_parent_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_duplicate_bytes;
+  rc = Serialize_TPM2B_PRIVATE(in_duplicate, &in_duplicate_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string name_bytes;
+  rc = Serialize_TPM2B_NAME(name, &name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_sym_seed_bytes;
+  rc = Serialize_TPM2B_ENCRYPTED_SECRET(in_sym_seed, &in_sym_seed_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_duplicate_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_duplicate_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(old_parent_name.data(), old_parent_name.size());
+  handle_section_bytes += old_parent_bytes;
+  command_size += old_parent_bytes.size();
+  hash->Update(new_parent_name.data(), new_parent_name.size());
+  handle_section_bytes += new_parent_bytes;
+  command_size += new_parent_bytes.size();
+  hash->Update(in_duplicate_bytes.data(), in_duplicate_bytes.size());
+  parameter_section_bytes += in_duplicate_bytes;
+  command_size += in_duplicate_bytes.size();
+  hash->Update(name_bytes.data(), name_bytes.size());
+  parameter_section_bytes += name_bytes;
+  command_size += name_bytes.size();
+  hash->Update(in_sym_seed_bytes.data(), in_sym_seed_bytes.size());
+  parameter_section_bytes += in_sym_seed_bytes;
+  command_size += in_sym_seed_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Rewrap(
+    const std::string& response,
+    TPM2B_PRIVATE* out_duplicate,
+    TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Rewrap;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_duplicate_bytes;
+  rc = Parse_TPM2B_PRIVATE(&buffer, out_duplicate, &out_duplicate_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string out_sym_seed_bytes;
+  rc = Parse_TPM2B_ENCRYPTED_SECRET(&buffer, out_sym_seed, &out_sym_seed_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void RewrapErrorCallback(Tpm::RewrapResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PRIVATE(),
+                          TPM2B_ENCRYPTED_SECRET());
+}
+
+void RewrapResponseParser(Tpm::RewrapResponse callback,
+                          AuthorizationDelegate* authorization_delegate,
+                          const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PRIVATE out_duplicate;
+  TPM2B_ENCRYPTED_SECRET out_sym_seed;
+  TPM_RC rc = Tpm::ParseResponse_Rewrap(response, &out_duplicate, &out_sym_seed,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RewrapErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_duplicate, out_sym_seed);
+}
+
+void Tpm::Rewrap(const TPMI_DH_OBJECT& old_parent,
+                 const std::string& old_parent_name,
+                 const TPMI_DH_OBJECT& new_parent,
+                 const std::string& new_parent_name,
+                 const TPM2B_PRIVATE& in_duplicate,
+                 const TPM2B_NAME& name,
+                 const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                 AuthorizationDelegate* authorization_delegate,
+                 RewrapResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Rewrap(
+      old_parent, old_parent_name, new_parent, new_parent_name, in_duplicate,
+      name, in_sym_seed, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RewrapErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      RewrapResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::RewrapSync(const TPMI_DH_OBJECT& old_parent,
+                       const std::string& old_parent_name,
+                       const TPMI_DH_OBJECT& new_parent,
+                       const std::string& new_parent_name,
+                       const TPM2B_PRIVATE& in_duplicate,
+                       const TPM2B_NAME& name,
+                       const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                       TPM2B_PRIVATE* out_duplicate,
+                       TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+                       AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Rewrap(
+      old_parent, old_parent_name, new_parent, new_parent_name, in_duplicate,
+      name, in_sym_seed, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Rewrap(response, out_duplicate, out_sym_seed,
+                            authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Import(
+    const TPMI_DH_OBJECT& parent_handle,
+    const std::string& parent_handle_name,
+    const TPM2B_DATA& encryption_key,
+    const TPM2B_PUBLIC& object_public,
+    const TPM2B_PRIVATE& duplicate,
+    const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+    const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Import;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string parent_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(parent_handle, &parent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string encryption_key_bytes;
+  rc = Serialize_TPM2B_DATA(encryption_key, &encryption_key_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_public_bytes;
+  rc = Serialize_TPM2B_PUBLIC(object_public, &object_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string duplicate_bytes;
+  rc = Serialize_TPM2B_PRIVATE(duplicate, &duplicate_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_sym_seed_bytes;
+  rc = Serialize_TPM2B_ENCRYPTED_SECRET(in_sym_seed, &in_sym_seed_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string symmetric_alg_bytes;
+  rc = Serialize_TPMT_SYM_DEF_OBJECT(symmetric_alg, &symmetric_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = encryption_key_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    encryption_key_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(parent_handle_name.data(), parent_handle_name.size());
+  handle_section_bytes += parent_handle_bytes;
+  command_size += parent_handle_bytes.size();
+  hash->Update(encryption_key_bytes.data(), encryption_key_bytes.size());
+  parameter_section_bytes += encryption_key_bytes;
+  command_size += encryption_key_bytes.size();
+  hash->Update(object_public_bytes.data(), object_public_bytes.size());
+  parameter_section_bytes += object_public_bytes;
+  command_size += object_public_bytes.size();
+  hash->Update(duplicate_bytes.data(), duplicate_bytes.size());
+  parameter_section_bytes += duplicate_bytes;
+  command_size += duplicate_bytes.size();
+  hash->Update(in_sym_seed_bytes.data(), in_sym_seed_bytes.size());
+  parameter_section_bytes += in_sym_seed_bytes;
+  command_size += in_sym_seed_bytes.size();
+  hash->Update(symmetric_alg_bytes.data(), symmetric_alg_bytes.size());
+  parameter_section_bytes += symmetric_alg_bytes;
+  command_size += symmetric_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Import(
+    const std::string& response,
+    TPM2B_PRIVATE* out_private,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Import;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_private_bytes;
+  rc = Parse_TPM2B_PRIVATE(&buffer, out_private, &out_private_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ImportErrorCallback(Tpm::ImportResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PRIVATE());
+}
+
+void ImportResponseParser(Tpm::ImportResponse callback,
+                          AuthorizationDelegate* authorization_delegate,
+                          const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PRIVATE out_private;
+  TPM_RC rc =
+      Tpm::ParseResponse_Import(response, &out_private, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ImportErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_private);
+}
+
+void Tpm::Import(const TPMI_DH_OBJECT& parent_handle,
+                 const std::string& parent_handle_name,
+                 const TPM2B_DATA& encryption_key,
+                 const TPM2B_PUBLIC& object_public,
+                 const TPM2B_PRIVATE& duplicate,
+                 const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                 const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                 AuthorizationDelegate* authorization_delegate,
+                 ImportResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Import(
+      parent_handle, parent_handle_name, encryption_key, object_public,
+      duplicate, in_sym_seed, symmetric_alg, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ImportErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ImportResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ImportSync(const TPMI_DH_OBJECT& parent_handle,
+                       const std::string& parent_handle_name,
+                       const TPM2B_DATA& encryption_key,
+                       const TPM2B_PUBLIC& object_public,
+                       const TPM2B_PRIVATE& duplicate,
+                       const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                       const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                       TPM2B_PRIVATE* out_private,
+                       AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Import(
+      parent_handle, parent_handle_name, encryption_key, object_public,
+      duplicate, in_sym_seed, symmetric_alg, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Import(response, out_private, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_RSA_Encrypt(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_PUBLIC_KEY_RSA& message,
+    const TPMT_RSA_DECRYPT& in_scheme,
+    const TPM2B_DATA& label,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_RSA_Encrypt;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string message_bytes;
+  rc = Serialize_TPM2B_PUBLIC_KEY_RSA(message, &message_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_RSA_DECRYPT(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string label_bytes;
+  rc = Serialize_TPM2B_DATA(label, &label_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = message_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    message_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(message_bytes.data(), message_bytes.size());
+  parameter_section_bytes += message_bytes;
+  command_size += message_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(label_bytes.data(), label_bytes.size());
+  parameter_section_bytes += label_bytes;
+  command_size += label_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_RSA_Encrypt(
+    const std::string& response,
+    TPM2B_PUBLIC_KEY_RSA* out_data,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_RSA_Encrypt;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_data_bytes;
+  rc = Parse_TPM2B_PUBLIC_KEY_RSA(&buffer, out_data, &out_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void RSA_EncryptErrorCallback(Tpm::RSA_EncryptResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PUBLIC_KEY_RSA());
+}
+
+void RSA_EncryptResponseParser(Tpm::RSA_EncryptResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PUBLIC_KEY_RSA out_data;
+  TPM_RC rc = Tpm::ParseResponse_RSA_Encrypt(response, &out_data,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RSA_EncryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_data);
+}
+
+void Tpm::RSA_Encrypt(const TPMI_DH_OBJECT& key_handle,
+                      const std::string& key_handle_name,
+                      const TPM2B_PUBLIC_KEY_RSA& message,
+                      const TPMT_RSA_DECRYPT& in_scheme,
+                      const TPM2B_DATA& label,
+                      AuthorizationDelegate* authorization_delegate,
+                      RSA_EncryptResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_RSA_Encrypt(key_handle, key_handle_name, message,
+                                           in_scheme, label, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RSA_EncryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      RSA_EncryptResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::RSA_EncryptSync(const TPMI_DH_OBJECT& key_handle,
+                            const std::string& key_handle_name,
+                            const TPM2B_PUBLIC_KEY_RSA& message,
+                            const TPMT_RSA_DECRYPT& in_scheme,
+                            const TPM2B_DATA& label,
+                            TPM2B_PUBLIC_KEY_RSA* out_data,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_RSA_Encrypt(key_handle, key_handle_name, message,
+                                           in_scheme, label, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_RSA_Encrypt(response, out_data, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_RSA_Decrypt(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+    const TPMT_RSA_DECRYPT& in_scheme,
+    const TPM2B_DATA& label,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_RSA_Decrypt;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string cipher_text_bytes;
+  rc = Serialize_TPM2B_PUBLIC_KEY_RSA(cipher_text, &cipher_text_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_RSA_DECRYPT(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string label_bytes;
+  rc = Serialize_TPM2B_DATA(label, &label_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = cipher_text_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    cipher_text_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(cipher_text_bytes.data(), cipher_text_bytes.size());
+  parameter_section_bytes += cipher_text_bytes;
+  command_size += cipher_text_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(label_bytes.data(), label_bytes.size());
+  parameter_section_bytes += label_bytes;
+  command_size += label_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_RSA_Decrypt(
+    const std::string& response,
+    TPM2B_PUBLIC_KEY_RSA* message,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_RSA_Decrypt;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string message_bytes;
+  rc = Parse_TPM2B_PUBLIC_KEY_RSA(&buffer, message, &message_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void RSA_DecryptErrorCallback(Tpm::RSA_DecryptResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_PUBLIC_KEY_RSA());
+}
+
+void RSA_DecryptResponseParser(Tpm::RSA_DecryptResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_PUBLIC_KEY_RSA message;
+  TPM_RC rc = Tpm::ParseResponse_RSA_Decrypt(response, &message,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RSA_DecryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, message);
+}
+
+void Tpm::RSA_Decrypt(const TPMI_DH_OBJECT& key_handle,
+                      const std::string& key_handle_name,
+                      const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+                      const TPMT_RSA_DECRYPT& in_scheme,
+                      const TPM2B_DATA& label,
+                      AuthorizationDelegate* authorization_delegate,
+                      RSA_DecryptResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_RSA_Decrypt(key_handle, key_handle_name,
+                                           cipher_text, in_scheme, label,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(RSA_DecryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      RSA_DecryptResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::RSA_DecryptSync(const TPMI_DH_OBJECT& key_handle,
+                            const std::string& key_handle_name,
+                            const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+                            const TPMT_RSA_DECRYPT& in_scheme,
+                            const TPM2B_DATA& label,
+                            TPM2B_PUBLIC_KEY_RSA* message,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_RSA_Decrypt(key_handle, key_handle_name,
+                                           cipher_text, in_scheme, label,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_RSA_Decrypt(response, message, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ECDH_KeyGen(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ECDH_KeyGen;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ECDH_KeyGen(
+    const std::string& response,
+    TPM2B_ECC_POINT* z_point,
+    TPM2B_ECC_POINT* pub_point,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ECDH_KeyGen;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string z_point_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, z_point, &z_point_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pub_point_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, pub_point, &pub_point_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ECDH_KeyGenErrorCallback(Tpm::ECDH_KeyGenResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ECC_POINT(), TPM2B_ECC_POINT());
+}
+
+void ECDH_KeyGenResponseParser(Tpm::ECDH_KeyGenResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ECC_POINT z_point;
+  TPM2B_ECC_POINT pub_point;
+  TPM_RC rc = Tpm::ParseResponse_ECDH_KeyGen(response, &z_point, &pub_point,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECDH_KeyGenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, z_point, pub_point);
+}
+
+void Tpm::ECDH_KeyGen(const TPMI_DH_OBJECT& key_handle,
+                      const std::string& key_handle_name,
+                      AuthorizationDelegate* authorization_delegate,
+                      ECDH_KeyGenResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECDH_KeyGen(key_handle, key_handle_name,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECDH_KeyGenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ECDH_KeyGenResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ECDH_KeyGenSync(const TPMI_DH_OBJECT& key_handle,
+                            const std::string& key_handle_name,
+                            TPM2B_ECC_POINT* z_point,
+                            TPM2B_ECC_POINT* pub_point,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECDH_KeyGen(key_handle, key_handle_name,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ECDH_KeyGen(response, z_point, pub_point,
+                                 authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ECDH_ZGen(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_ECC_POINT& in_point,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ECDH_ZGen;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_point_bytes;
+  rc = Serialize_TPM2B_ECC_POINT(in_point, &in_point_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_point_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_point_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(in_point_bytes.data(), in_point_bytes.size());
+  parameter_section_bytes += in_point_bytes;
+  command_size += in_point_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ECDH_ZGen(
+    const std::string& response,
+    TPM2B_ECC_POINT* out_point,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ECDH_ZGen;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_point_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, out_point, &out_point_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ECDH_ZGenErrorCallback(Tpm::ECDH_ZGenResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ECC_POINT());
+}
+
+void ECDH_ZGenResponseParser(Tpm::ECDH_ZGenResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ECC_POINT out_point;
+  TPM_RC rc = Tpm::ParseResponse_ECDH_ZGen(response, &out_point,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECDH_ZGenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_point);
+}
+
+void Tpm::ECDH_ZGen(const TPMI_DH_OBJECT& key_handle,
+                    const std::string& key_handle_name,
+                    const TPM2B_ECC_POINT& in_point,
+                    AuthorizationDelegate* authorization_delegate,
+                    ECDH_ZGenResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECDH_ZGen(key_handle, key_handle_name, in_point,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECDH_ZGenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ECDH_ZGenResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ECDH_ZGenSync(const TPMI_DH_OBJECT& key_handle,
+                          const std::string& key_handle_name,
+                          const TPM2B_ECC_POINT& in_point,
+                          TPM2B_ECC_POINT* out_point,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECDH_ZGen(key_handle, key_handle_name, in_point,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ECDH_ZGen(response, out_point, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ECC_Parameters(
+    const TPMI_ECC_CURVE& curve_id,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ECC_Parameters;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string curve_id_bytes;
+  rc = Serialize_TPMI_ECC_CURVE(curve_id, &curve_id_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(curve_id_bytes.data(), curve_id_bytes.size());
+  parameter_section_bytes += curve_id_bytes;
+  command_size += curve_id_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ECC_Parameters(
+    const std::string& response,
+    TPMS_ALGORITHM_DETAIL_ECC* parameters,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ECC_Parameters;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string parameters_bytes;
+  rc = Parse_TPMS_ALGORITHM_DETAIL_ECC(&buffer, parameters, &parameters_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ECC_ParametersErrorCallback(Tpm::ECC_ParametersResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMS_ALGORITHM_DETAIL_ECC());
+}
+
+void ECC_ParametersResponseParser(Tpm::ECC_ParametersResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPMS_ALGORITHM_DETAIL_ECC parameters;
+  TPM_RC rc = Tpm::ParseResponse_ECC_Parameters(response, &parameters,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECC_ParametersErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, parameters);
+}
+
+void Tpm::ECC_Parameters(const TPMI_ECC_CURVE& curve_id,
+                         AuthorizationDelegate* authorization_delegate,
+                         ECC_ParametersResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECC_Parameters(curve_id, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ECC_ParametersErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(ECC_ParametersResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ECC_ParametersSync(const TPMI_ECC_CURVE& curve_id,
+                               TPMS_ALGORITHM_DETAIL_ECC* parameters,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ECC_Parameters(curve_id, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ECC_Parameters(response, parameters,
+                                    authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ZGen_2Phase(
+    const TPMI_DH_OBJECT& key_a,
+    const std::string& key_a_name,
+    const TPM2B_ECC_POINT& in_qs_b,
+    const TPM2B_ECC_POINT& in_qe_b,
+    const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+    const UINT16& counter,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ZGen_2Phase;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_a_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_a, &key_a_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_qs_b_bytes;
+  rc = Serialize_TPM2B_ECC_POINT(in_qs_b, &in_qs_b_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_qe_b_bytes;
+  rc = Serialize_TPM2B_ECC_POINT(in_qe_b, &in_qe_b_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMI_ECC_KEY_EXCHANGE(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string counter_bytes;
+  rc = Serialize_UINT16(counter, &counter_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_qs_b_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_qs_b_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_a_name.data(), key_a_name.size());
+  handle_section_bytes += key_a_bytes;
+  command_size += key_a_bytes.size();
+  hash->Update(in_qs_b_bytes.data(), in_qs_b_bytes.size());
+  parameter_section_bytes += in_qs_b_bytes;
+  command_size += in_qs_b_bytes.size();
+  hash->Update(in_qe_b_bytes.data(), in_qe_b_bytes.size());
+  parameter_section_bytes += in_qe_b_bytes;
+  command_size += in_qe_b_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(counter_bytes.data(), counter_bytes.size());
+  parameter_section_bytes += counter_bytes;
+  command_size += counter_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ZGen_2Phase(
+    const std::string& response,
+    TPM2B_ECC_POINT* out_z1,
+    TPM2B_ECC_POINT* out_z2,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ZGen_2Phase;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_z1_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, out_z1, &out_z1_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string out_z2_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, out_z2, &out_z2_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ZGen_2PhaseErrorCallback(Tpm::ZGen_2PhaseResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ECC_POINT(), TPM2B_ECC_POINT());
+}
+
+void ZGen_2PhaseResponseParser(Tpm::ZGen_2PhaseResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ECC_POINT out_z1;
+  TPM2B_ECC_POINT out_z2;
+  TPM_RC rc = Tpm::ParseResponse_ZGen_2Phase(response, &out_z1, &out_z2,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ZGen_2PhaseErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_z1, out_z2);
+}
+
+void Tpm::ZGen_2Phase(const TPMI_DH_OBJECT& key_a,
+                      const std::string& key_a_name,
+                      const TPM2B_ECC_POINT& in_qs_b,
+                      const TPM2B_ECC_POINT& in_qe_b,
+                      const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+                      const UINT16& counter,
+                      AuthorizationDelegate* authorization_delegate,
+                      ZGen_2PhaseResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ZGen_2Phase(key_a, key_a_name, in_qs_b, in_qe_b,
+                                           in_scheme, counter, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ZGen_2PhaseErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ZGen_2PhaseResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ZGen_2PhaseSync(const TPMI_DH_OBJECT& key_a,
+                            const std::string& key_a_name,
+                            const TPM2B_ECC_POINT& in_qs_b,
+                            const TPM2B_ECC_POINT& in_qe_b,
+                            const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+                            const UINT16& counter,
+                            TPM2B_ECC_POINT* out_z1,
+                            TPM2B_ECC_POINT* out_z2,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ZGen_2Phase(key_a, key_a_name, in_qs_b, in_qe_b,
+                                           in_scheme, counter, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ZGen_2Phase(response, out_z1, out_z2,
+                                 authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_EncryptDecrypt(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPMI_YES_NO& decrypt,
+    const TPMI_ALG_SYM_MODE& mode,
+    const TPM2B_IV& iv_in,
+    const TPM2B_MAX_BUFFER& in_data,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_EncryptDecrypt;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string decrypt_bytes;
+  rc = Serialize_TPMI_YES_NO(decrypt, &decrypt_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string mode_bytes;
+  rc = Serialize_TPMI_ALG_SYM_MODE(mode, &mode_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string iv_in_bytes;
+  rc = Serialize_TPM2B_IV(iv_in, &iv_in_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_data_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(in_data, &in_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(decrypt_bytes.data(), decrypt_bytes.size());
+  parameter_section_bytes += decrypt_bytes;
+  command_size += decrypt_bytes.size();
+  hash->Update(mode_bytes.data(), mode_bytes.size());
+  parameter_section_bytes += mode_bytes;
+  command_size += mode_bytes.size();
+  hash->Update(iv_in_bytes.data(), iv_in_bytes.size());
+  parameter_section_bytes += iv_in_bytes;
+  command_size += iv_in_bytes.size();
+  hash->Update(in_data_bytes.data(), in_data_bytes.size());
+  parameter_section_bytes += in_data_bytes;
+  command_size += in_data_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_EncryptDecrypt(
+    const std::string& response,
+    TPM2B_MAX_BUFFER* out_data,
+    TPM2B_IV* iv_out,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_EncryptDecrypt;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_data_bytes;
+  rc = Parse_TPM2B_MAX_BUFFER(&buffer, out_data, &out_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string iv_out_bytes;
+  rc = Parse_TPM2B_IV(&buffer, iv_out, &iv_out_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void EncryptDecryptErrorCallback(Tpm::EncryptDecryptResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_MAX_BUFFER(), TPM2B_IV());
+}
+
+void EncryptDecryptResponseParser(Tpm::EncryptDecryptResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_MAX_BUFFER out_data;
+  TPM2B_IV iv_out;
+  TPM_RC rc = Tpm::ParseResponse_EncryptDecrypt(response, &out_data, &iv_out,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EncryptDecryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_data, iv_out);
+}
+
+void Tpm::EncryptDecrypt(const TPMI_DH_OBJECT& key_handle,
+                         const std::string& key_handle_name,
+                         const TPMI_YES_NO& decrypt,
+                         const TPMI_ALG_SYM_MODE& mode,
+                         const TPM2B_IV& iv_in,
+                         const TPM2B_MAX_BUFFER& in_data,
+                         AuthorizationDelegate* authorization_delegate,
+                         EncryptDecryptResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EncryptDecrypt(key_handle, key_handle_name,
+                                              decrypt, mode, iv_in, in_data,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EncryptDecryptErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(EncryptDecryptResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::EncryptDecryptSync(const TPMI_DH_OBJECT& key_handle,
+                               const std::string& key_handle_name,
+                               const TPMI_YES_NO& decrypt,
+                               const TPMI_ALG_SYM_MODE& mode,
+                               const TPM2B_IV& iv_in,
+                               const TPM2B_MAX_BUFFER& in_data,
+                               TPM2B_MAX_BUFFER* out_data,
+                               TPM2B_IV* iv_out,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EncryptDecrypt(key_handle, key_handle_name,
+                                              decrypt, mode, iv_in, in_data,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_EncryptDecrypt(response, out_data, iv_out,
+                                    authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Hash(
+    const TPM2B_MAX_BUFFER& data,
+    const TPMI_ALG_HASH& hash_alg,
+    const TPMI_RH_HIERARCHY& hierarchy,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Hash;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string data_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(data, &data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hash_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(hash_alg, &hash_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hierarchy_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(hierarchy, &hierarchy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(data_bytes.data(), data_bytes.size());
+  parameter_section_bytes += data_bytes;
+  command_size += data_bytes.size();
+  hash->Update(hash_alg_bytes.data(), hash_alg_bytes.size());
+  parameter_section_bytes += hash_alg_bytes;
+  command_size += hash_alg_bytes.size();
+  hash->Update(hierarchy_bytes.data(), hierarchy_bytes.size());
+  parameter_section_bytes += hierarchy_bytes;
+  command_size += hierarchy_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Hash(const std::string& response,
+                               TPM2B_DIGEST* out_hash,
+                               TPMT_TK_HASHCHECK* validation,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Hash;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_hash_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, out_hash, &out_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string validation_bytes;
+  rc = Parse_TPMT_TK_HASHCHECK(&buffer, validation, &validation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HashErrorCallback(Tpm::HashResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST(), TPMT_TK_HASHCHECK());
+}
+
+void HashResponseParser(Tpm::HashResponse callback,
+                        AuthorizationDelegate* authorization_delegate,
+                        const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST out_hash;
+  TPMT_TK_HASHCHECK validation;
+  TPM_RC rc = Tpm::ParseResponse_Hash(response, &out_hash, &validation,
+                                      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_hash, validation);
+}
+
+void Tpm::Hash(const TPM2B_MAX_BUFFER& data,
+               const TPMI_ALG_HASH& hash_alg,
+               const TPMI_RH_HIERARCHY& hierarchy,
+               AuthorizationDelegate* authorization_delegate,
+               HashResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Hash(data, hash_alg, hierarchy, &command,
+                                    authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      HashResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HashSync(const TPM2B_MAX_BUFFER& data,
+                     const TPMI_ALG_HASH& hash_alg,
+                     const TPMI_RH_HIERARCHY& hierarchy,
+                     TPM2B_DIGEST* out_hash,
+                     TPMT_TK_HASHCHECK* validation,
+                     AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Hash(data, hash_alg, hierarchy, &command,
+                                    authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Hash(response, out_hash, validation,
+                          authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_HMAC(
+    const TPMI_DH_OBJECT& handle,
+    const std::string& handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    const TPMI_ALG_HASH& hash_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_HMAC;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(handle, &handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string buffer_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(buffer, &buffer_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hash_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(hash_alg, &hash_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = buffer_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(handle_name.data(), handle_name.size());
+  handle_section_bytes += handle_bytes;
+  command_size += handle_bytes.size();
+  hash->Update(buffer_bytes.data(), buffer_bytes.size());
+  parameter_section_bytes += buffer_bytes;
+  command_size += buffer_bytes.size();
+  hash->Update(hash_alg_bytes.data(), hash_alg_bytes.size());
+  parameter_section_bytes += hash_alg_bytes;
+  command_size += hash_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_HMAC(const std::string& response,
+                               TPM2B_DIGEST* out_hmac,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_HMAC;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_hmac_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, out_hmac, &out_hmac_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HMACErrorCallback(Tpm::HMACResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST());
+}
+
+void HMACResponseParser(Tpm::HMACResponse callback,
+                        AuthorizationDelegate* authorization_delegate,
+                        const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST out_hmac;
+  TPM_RC rc =
+      Tpm::ParseResponse_HMAC(response, &out_hmac, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HMACErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, out_hmac);
+}
+
+void Tpm::HMAC(const TPMI_DH_OBJECT& handle,
+               const std::string& handle_name,
+               const TPM2B_MAX_BUFFER& buffer,
+               const TPMI_ALG_HASH& hash_alg,
+               AuthorizationDelegate* authorization_delegate,
+               HMACResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HMAC(handle, handle_name, buffer, hash_alg,
+                                    &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HMACErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      HMACResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HMACSync(const TPMI_DH_OBJECT& handle,
+                     const std::string& handle_name,
+                     const TPM2B_MAX_BUFFER& buffer,
+                     const TPMI_ALG_HASH& hash_alg,
+                     TPM2B_DIGEST* out_hmac,
+                     AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HMAC(handle, handle_name, buffer, hash_alg,
+                                    &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_HMAC(response, out_hmac, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetRandom(
+    const UINT16& bytes_requested,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetRandom;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string bytes_requested_bytes;
+  rc = Serialize_UINT16(bytes_requested, &bytes_requested_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(bytes_requested_bytes.data(), bytes_requested_bytes.size());
+  parameter_section_bytes += bytes_requested_bytes;
+  command_size += bytes_requested_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetRandom(
+    const std::string& response,
+    TPM2B_DIGEST* random_bytes,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetRandom;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string random_bytes_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, random_bytes, &random_bytes_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetRandomErrorCallback(Tpm::GetRandomResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST());
+}
+
+void GetRandomResponseParser(Tpm::GetRandomResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST random_bytes;
+  TPM_RC rc = Tpm::ParseResponse_GetRandom(response, &random_bytes,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetRandomErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, random_bytes);
+}
+
+void Tpm::GetRandom(const UINT16& bytes_requested,
+                    AuthorizationDelegate* authorization_delegate,
+                    GetRandomResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetRandom(bytes_requested, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetRandomErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      GetRandomResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetRandomSync(const UINT16& bytes_requested,
+                          TPM2B_DIGEST* random_bytes,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetRandom(bytes_requested, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetRandom(response, random_bytes, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_StirRandom(
+    const TPM2B_SENSITIVE_DATA& in_data,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_StirRandom;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_data_bytes;
+  rc = Serialize_TPM2B_SENSITIVE_DATA(in_data, &in_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(in_data_bytes.data(), in_data_bytes.size());
+  parameter_section_bytes += in_data_bytes;
+  command_size += in_data_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_StirRandom(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_StirRandom;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void StirRandomErrorCallback(Tpm::StirRandomResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void StirRandomResponseParser(Tpm::StirRandomResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_StirRandom(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StirRandomErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::StirRandom(const TPM2B_SENSITIVE_DATA& in_data,
+                     AuthorizationDelegate* authorization_delegate,
+                     StirRandomResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_StirRandom(in_data, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(StirRandomErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      StirRandomResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::StirRandomSync(const TPM2B_SENSITIVE_DATA& in_data,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_StirRandom(in_data, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_StirRandom(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_HMAC_Start(
+    const TPMI_DH_OBJECT& handle,
+    const std::string& handle_name,
+    const TPM2B_AUTH& auth,
+    const TPMI_ALG_HASH& hash_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_HMAC_Start;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(handle, &handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPM2B_AUTH(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hash_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(hash_alg, &hash_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(handle_name.data(), handle_name.size());
+  handle_section_bytes += handle_bytes;
+  command_size += handle_bytes.size();
+  hash->Update(auth_bytes.data(), auth_bytes.size());
+  parameter_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(hash_alg_bytes.data(), hash_alg_bytes.size());
+  parameter_section_bytes += hash_alg_bytes;
+  command_size += hash_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_HMAC_Start(
+    const std::string& response,
+    TPMI_DH_OBJECT* sequence_handle,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string sequence_handle_bytes;
+  rc = Parse_TPMI_DH_OBJECT(&buffer, sequence_handle, &sequence_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_HMAC_Start;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HMAC_StartErrorCallback(Tpm::HMAC_StartResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_DH_OBJECT());
+}
+
+void HMAC_StartResponseParser(Tpm::HMAC_StartResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_DH_OBJECT sequence_handle;
+  TPM_RC rc = Tpm::ParseResponse_HMAC_Start(response, &sequence_handle,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HMAC_StartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, sequence_handle);
+}
+
+void Tpm::HMAC_Start(const TPMI_DH_OBJECT& handle,
+                     const std::string& handle_name,
+                     const TPM2B_AUTH& auth,
+                     const TPMI_ALG_HASH& hash_alg,
+                     AuthorizationDelegate* authorization_delegate,
+                     HMAC_StartResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HMAC_Start(handle, handle_name, auth, hash_alg,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HMAC_StartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      HMAC_StartResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HMAC_StartSync(const TPMI_DH_OBJECT& handle,
+                           const std::string& handle_name,
+                           const TPM2B_AUTH& auth,
+                           const TPMI_ALG_HASH& hash_alg,
+                           TPMI_DH_OBJECT* sequence_handle,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HMAC_Start(handle, handle_name, auth, hash_alg,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_HMAC_Start(response, sequence_handle,
+                                authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_HashSequenceStart(
+    const TPM2B_AUTH& auth,
+    const TPMI_ALG_HASH& hash_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_HashSequenceStart;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPM2B_AUTH(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hash_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(hash_alg, &hash_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_bytes.data(), auth_bytes.size());
+  parameter_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(hash_alg_bytes.data(), hash_alg_bytes.size());
+  parameter_section_bytes += hash_alg_bytes;
+  command_size += hash_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_HashSequenceStart(
+    const std::string& response,
+    TPMI_DH_OBJECT* sequence_handle,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string sequence_handle_bytes;
+  rc = Parse_TPMI_DH_OBJECT(&buffer, sequence_handle, &sequence_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_HashSequenceStart;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HashSequenceStartErrorCallback(Tpm::HashSequenceStartResponse callback,
+                                    TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_DH_OBJECT());
+}
+
+void HashSequenceStartResponseParser(
+    Tpm::HashSequenceStartResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_DH_OBJECT sequence_handle;
+  TPM_RC rc = Tpm::ParseResponse_HashSequenceStart(response, &sequence_handle,
+                                                   authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HashSequenceStartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, sequence_handle);
+}
+
+void Tpm::HashSequenceStart(const TPM2B_AUTH& auth,
+                            const TPMI_ALG_HASH& hash_alg,
+                            AuthorizationDelegate* authorization_delegate,
+                            HashSequenceStartResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HashSequenceStart(auth, hash_alg, &command,
+                                                 authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HashSequenceStartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(HashSequenceStartResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HashSequenceStartSync(
+    const TPM2B_AUTH& auth,
+    const TPMI_ALG_HASH& hash_alg,
+    TPMI_DH_OBJECT* sequence_handle,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HashSequenceStart(auth, hash_alg, &command,
+                                                 authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_HashSequenceStart(response, sequence_handle,
+                                       authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SequenceUpdate(
+    const TPMI_DH_OBJECT& sequence_handle,
+    const std::string& sequence_handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SequenceUpdate;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sequence_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sequence_handle, &sequence_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string buffer_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(buffer, &buffer_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = buffer_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sequence_handle_name.data(), sequence_handle_name.size());
+  handle_section_bytes += sequence_handle_bytes;
+  command_size += sequence_handle_bytes.size();
+  hash->Update(buffer_bytes.data(), buffer_bytes.size());
+  parameter_section_bytes += buffer_bytes;
+  command_size += buffer_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SequenceUpdate(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SequenceUpdate;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SequenceUpdateErrorCallback(Tpm::SequenceUpdateResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void SequenceUpdateResponseParser(Tpm::SequenceUpdateResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_SequenceUpdate(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SequenceUpdateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::SequenceUpdate(const TPMI_DH_OBJECT& sequence_handle,
+                         const std::string& sequence_handle_name,
+                         const TPM2B_MAX_BUFFER& buffer,
+                         AuthorizationDelegate* authorization_delegate,
+                         SequenceUpdateResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_SequenceUpdate(sequence_handle, sequence_handle_name,
+                                      buffer, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SequenceUpdateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(SequenceUpdateResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SequenceUpdateSync(const TPMI_DH_OBJECT& sequence_handle,
+                               const std::string& sequence_handle_name,
+                               const TPM2B_MAX_BUFFER& buffer,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_SequenceUpdate(sequence_handle, sequence_handle_name,
+                                      buffer, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_SequenceUpdate(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SequenceComplete(
+    const TPMI_DH_OBJECT& sequence_handle,
+    const std::string& sequence_handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    const TPMI_RH_HIERARCHY& hierarchy,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SequenceComplete;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sequence_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sequence_handle, &sequence_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string buffer_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(buffer, &buffer_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hierarchy_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(hierarchy, &hierarchy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = buffer_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sequence_handle_name.data(), sequence_handle_name.size());
+  handle_section_bytes += sequence_handle_bytes;
+  command_size += sequence_handle_bytes.size();
+  hash->Update(buffer_bytes.data(), buffer_bytes.size());
+  parameter_section_bytes += buffer_bytes;
+  command_size += buffer_bytes.size();
+  hash->Update(hierarchy_bytes.data(), hierarchy_bytes.size());
+  parameter_section_bytes += hierarchy_bytes;
+  command_size += hierarchy_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SequenceComplete(
+    const std::string& response,
+    TPM2B_DIGEST* result,
+    TPMT_TK_HASHCHECK* validation,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SequenceComplete;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string result_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, result, &result_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string validation_bytes;
+  rc = Parse_TPMT_TK_HASHCHECK(&buffer, validation, &validation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SequenceCompleteErrorCallback(Tpm::SequenceCompleteResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST(), TPMT_TK_HASHCHECK());
+}
+
+void SequenceCompleteResponseParser(
+    Tpm::SequenceCompleteResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST result;
+  TPMT_TK_HASHCHECK validation;
+  TPM_RC rc = Tpm::ParseResponse_SequenceComplete(
+      response, &result, &validation, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SequenceCompleteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, result, validation);
+}
+
+void Tpm::SequenceComplete(const TPMI_DH_OBJECT& sequence_handle,
+                           const std::string& sequence_handle_name,
+                           const TPM2B_MAX_BUFFER& buffer,
+                           const TPMI_RH_HIERARCHY& hierarchy,
+                           AuthorizationDelegate* authorization_delegate,
+                           SequenceCompleteResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SequenceComplete(
+      sequence_handle, sequence_handle_name, buffer, hierarchy, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SequenceCompleteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(SequenceCompleteResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SequenceCompleteSync(
+    const TPMI_DH_OBJECT& sequence_handle,
+    const std::string& sequence_handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    const TPMI_RH_HIERARCHY& hierarchy,
+    TPM2B_DIGEST* result,
+    TPMT_TK_HASHCHECK* validation,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SequenceComplete(
+      sequence_handle, sequence_handle_name, buffer, hierarchy, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_SequenceComplete(response, result, validation,
+                                      authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_EventSequenceComplete(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPMI_DH_OBJECT& sequence_handle,
+    const std::string& sequence_handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_EventSequenceComplete;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_handle_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_handle, &pcr_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sequence_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sequence_handle, &sequence_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string buffer_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(buffer, &buffer_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = buffer_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_handle_name.data(), pcr_handle_name.size());
+  handle_section_bytes += pcr_handle_bytes;
+  command_size += pcr_handle_bytes.size();
+  hash->Update(sequence_handle_name.data(), sequence_handle_name.size());
+  handle_section_bytes += sequence_handle_bytes;
+  command_size += sequence_handle_bytes.size();
+  hash->Update(buffer_bytes.data(), buffer_bytes.size());
+  parameter_section_bytes += buffer_bytes;
+  command_size += buffer_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_EventSequenceComplete(
+    const std::string& response,
+    TPML_DIGEST_VALUES* results,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_EventSequenceComplete;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string results_bytes;
+  rc = Parse_TPML_DIGEST_VALUES(&buffer, results, &results_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void EventSequenceCompleteErrorCallback(
+    Tpm::EventSequenceCompleteResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPML_DIGEST_VALUES());
+}
+
+void EventSequenceCompleteResponseParser(
+    Tpm::EventSequenceCompleteResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPML_DIGEST_VALUES results;
+  TPM_RC rc = Tpm::ParseResponse_EventSequenceComplete(response, &results,
+                                                       authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EventSequenceCompleteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, results);
+}
+
+void Tpm::EventSequenceComplete(const TPMI_DH_PCR& pcr_handle,
+                                const std::string& pcr_handle_name,
+                                const TPMI_DH_OBJECT& sequence_handle,
+                                const std::string& sequence_handle_name,
+                                const TPM2B_MAX_BUFFER& buffer,
+                                AuthorizationDelegate* authorization_delegate,
+                                EventSequenceCompleteResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EventSequenceComplete(
+      pcr_handle, pcr_handle_name, sequence_handle, sequence_handle_name,
+      buffer, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EventSequenceCompleteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(EventSequenceCompleteResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::EventSequenceCompleteSync(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPMI_DH_OBJECT& sequence_handle,
+    const std::string& sequence_handle_name,
+    const TPM2B_MAX_BUFFER& buffer,
+    TPML_DIGEST_VALUES* results,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EventSequenceComplete(
+      pcr_handle, pcr_handle_name, sequence_handle, sequence_handle_name,
+      buffer, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_EventSequenceComplete(response, results,
+                                           authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Certify(
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Certify;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Certify(
+    const std::string& response,
+    TPM2B_ATTEST* certify_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Certify;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string certify_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, certify_info, &certify_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void CertifyErrorCallback(Tpm::CertifyResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void CertifyResponseParser(Tpm::CertifyResponse callback,
+                           AuthorizationDelegate* authorization_delegate,
+                           const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST certify_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_Certify(response, &certify_info, &signature,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CertifyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, certify_info, signature);
+}
+
+void Tpm::Certify(const TPMI_DH_OBJECT& object_handle,
+                  const std::string& object_handle_name,
+                  const TPMI_DH_OBJECT& sign_handle,
+                  const std::string& sign_handle_name,
+                  const TPM2B_DATA& qualifying_data,
+                  const TPMT_SIG_SCHEME& in_scheme,
+                  AuthorizationDelegate* authorization_delegate,
+                  CertifyResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Certify(
+      object_handle, object_handle_name, sign_handle, sign_handle_name,
+      qualifying_data, in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CertifyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      CertifyResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::CertifySync(const TPMI_DH_OBJECT& object_handle,
+                        const std::string& object_handle_name,
+                        const TPMI_DH_OBJECT& sign_handle,
+                        const std::string& sign_handle_name,
+                        const TPM2B_DATA& qualifying_data,
+                        const TPMT_SIG_SCHEME& in_scheme,
+                        TPM2B_ATTEST* certify_info,
+                        TPMT_SIGNATURE* signature,
+                        AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Certify(
+      object_handle, object_handle_name, sign_handle, sign_handle_name,
+      qualifying_data, in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Certify(response, certify_info, signature,
+                             authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_CertifyCreation(
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPM2B_DIGEST& creation_hash,
+    const TPMT_SIG_SCHEME& in_scheme,
+    const TPMT_TK_CREATION& creation_ticket,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_CertifyCreation;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_hash_bytes;
+  rc = Serialize_TPM2B_DIGEST(creation_hash, &creation_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_ticket_bytes;
+  rc = Serialize_TPMT_TK_CREATION(creation_ticket, &creation_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(creation_hash_bytes.data(), creation_hash_bytes.size());
+  parameter_section_bytes += creation_hash_bytes;
+  command_size += creation_hash_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(creation_ticket_bytes.data(), creation_ticket_bytes.size());
+  parameter_section_bytes += creation_ticket_bytes;
+  command_size += creation_ticket_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_CertifyCreation(
+    const std::string& response,
+    TPM2B_ATTEST* certify_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_CertifyCreation;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string certify_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, certify_info, &certify_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void CertifyCreationErrorCallback(Tpm::CertifyCreationResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void CertifyCreationResponseParser(
+    Tpm::CertifyCreationResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST certify_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_CertifyCreation(
+      response, &certify_info, &signature, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CertifyCreationErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, certify_info, signature);
+}
+
+void Tpm::CertifyCreation(const TPMI_DH_OBJECT& sign_handle,
+                          const std::string& sign_handle_name,
+                          const TPMI_DH_OBJECT& object_handle,
+                          const std::string& object_handle_name,
+                          const TPM2B_DATA& qualifying_data,
+                          const TPM2B_DIGEST& creation_hash,
+                          const TPMT_SIG_SCHEME& in_scheme,
+                          const TPMT_TK_CREATION& creation_ticket,
+                          AuthorizationDelegate* authorization_delegate,
+                          CertifyCreationResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_CertifyCreation(
+      sign_handle, sign_handle_name, object_handle, object_handle_name,
+      qualifying_data, creation_hash, in_scheme, creation_ticket, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CertifyCreationErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(CertifyCreationResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::CertifyCreationSync(const TPMI_DH_OBJECT& sign_handle,
+                                const std::string& sign_handle_name,
+                                const TPMI_DH_OBJECT& object_handle,
+                                const std::string& object_handle_name,
+                                const TPM2B_DATA& qualifying_data,
+                                const TPM2B_DIGEST& creation_hash,
+                                const TPMT_SIG_SCHEME& in_scheme,
+                                const TPMT_TK_CREATION& creation_ticket,
+                                TPM2B_ATTEST* certify_info,
+                                TPMT_SIGNATURE* signature,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_CertifyCreation(
+      sign_handle, sign_handle_name, object_handle, object_handle_name,
+      qualifying_data, creation_hash, in_scheme, creation_ticket, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_CertifyCreation(response, certify_info, signature,
+                                     authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Quote(
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    const TPML_PCR_SELECTION& pcrselect,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Quote;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcrselect_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(pcrselect, &pcrselect_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(pcrselect_bytes.data(), pcrselect_bytes.size());
+  parameter_section_bytes += pcrselect_bytes;
+  command_size += pcrselect_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Quote(const std::string& response,
+                                TPM2B_ATTEST* quoted,
+                                TPMT_SIGNATURE* signature,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Quote;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string quoted_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, quoted, &quoted_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void QuoteErrorCallback(Tpm::QuoteResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void QuoteResponseParser(Tpm::QuoteResponse callback,
+                         AuthorizationDelegate* authorization_delegate,
+                         const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST quoted;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_Quote(response, &quoted, &signature,
+                                       authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(QuoteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, quoted, signature);
+}
+
+void Tpm::Quote(const TPMI_DH_OBJECT& sign_handle,
+                const std::string& sign_handle_name,
+                const TPM2B_DATA& qualifying_data,
+                const TPMT_SIG_SCHEME& in_scheme,
+                const TPML_PCR_SELECTION& pcrselect,
+                AuthorizationDelegate* authorization_delegate,
+                QuoteResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Quote(sign_handle, sign_handle_name,
+                                     qualifying_data, in_scheme, pcrselect,
+                                     &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(QuoteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      QuoteResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::QuoteSync(const TPMI_DH_OBJECT& sign_handle,
+                      const std::string& sign_handle_name,
+                      const TPM2B_DATA& qualifying_data,
+                      const TPMT_SIG_SCHEME& in_scheme,
+                      const TPML_PCR_SELECTION& pcrselect,
+                      TPM2B_ATTEST* quoted,
+                      TPMT_SIGNATURE* signature,
+                      AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Quote(sign_handle, sign_handle_name,
+                                     qualifying_data, in_scheme, pcrselect,
+                                     &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Quote(response, quoted, signature, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetSessionAuditDigest(
+    const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+    const std::string& privacy_admin_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPMI_SH_HMAC& session_handle,
+    const std::string& session_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetSessionAuditDigest;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string privacy_admin_handle_bytes;
+  rc = Serialize_TPMI_RH_ENDORSEMENT(privacy_admin_handle,
+                                     &privacy_admin_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string session_handle_bytes;
+  rc = Serialize_TPMI_SH_HMAC(session_handle, &session_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(privacy_admin_handle_name.data(),
+               privacy_admin_handle_name.size());
+  handle_section_bytes += privacy_admin_handle_bytes;
+  command_size += privacy_admin_handle_bytes.size();
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(session_handle_name.data(), session_handle_name.size());
+  handle_section_bytes += session_handle_bytes;
+  command_size += session_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetSessionAuditDigest(
+    const std::string& response,
+    TPM2B_ATTEST* audit_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetSessionAuditDigest;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string audit_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, audit_info, &audit_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetSessionAuditDigestErrorCallback(
+    Tpm::GetSessionAuditDigestResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void GetSessionAuditDigestResponseParser(
+    Tpm::GetSessionAuditDigestResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST audit_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_GetSessionAuditDigest(
+      response, &audit_info, &signature, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetSessionAuditDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, audit_info, signature);
+}
+
+void Tpm::GetSessionAuditDigest(const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+                                const std::string& privacy_admin_handle_name,
+                                const TPMI_DH_OBJECT& sign_handle,
+                                const std::string& sign_handle_name,
+                                const TPMI_SH_HMAC& session_handle,
+                                const std::string& session_handle_name,
+                                const TPM2B_DATA& qualifying_data,
+                                const TPMT_SIG_SCHEME& in_scheme,
+                                AuthorizationDelegate* authorization_delegate,
+                                GetSessionAuditDigestResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetSessionAuditDigest(
+      privacy_admin_handle, privacy_admin_handle_name, sign_handle,
+      sign_handle_name, session_handle, session_handle_name, qualifying_data,
+      in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetSessionAuditDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(GetSessionAuditDigestResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetSessionAuditDigestSync(
+    const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+    const std::string& privacy_admin_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPMI_SH_HMAC& session_handle,
+    const std::string& session_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    TPM2B_ATTEST* audit_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetSessionAuditDigest(
+      privacy_admin_handle, privacy_admin_handle_name, sign_handle,
+      sign_handle_name, session_handle, session_handle_name, qualifying_data,
+      in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetSessionAuditDigest(response, audit_info, signature,
+                                           authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetCommandAuditDigest(
+    const TPMI_RH_ENDORSEMENT& privacy_handle,
+    const std::string& privacy_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetCommandAuditDigest;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string privacy_handle_bytes;
+  rc = Serialize_TPMI_RH_ENDORSEMENT(privacy_handle, &privacy_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(privacy_handle_name.data(), privacy_handle_name.size());
+  handle_section_bytes += privacy_handle_bytes;
+  command_size += privacy_handle_bytes.size();
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetCommandAuditDigest(
+    const std::string& response,
+    TPM2B_ATTEST* audit_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetCommandAuditDigest;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string audit_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, audit_info, &audit_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetCommandAuditDigestErrorCallback(
+    Tpm::GetCommandAuditDigestResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void GetCommandAuditDigestResponseParser(
+    Tpm::GetCommandAuditDigestResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST audit_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_GetCommandAuditDigest(
+      response, &audit_info, &signature, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetCommandAuditDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, audit_info, signature);
+}
+
+void Tpm::GetCommandAuditDigest(const TPMI_RH_ENDORSEMENT& privacy_handle,
+                                const std::string& privacy_handle_name,
+                                const TPMI_DH_OBJECT& sign_handle,
+                                const std::string& sign_handle_name,
+                                const TPM2B_DATA& qualifying_data,
+                                const TPMT_SIG_SCHEME& in_scheme,
+                                AuthorizationDelegate* authorization_delegate,
+                                GetCommandAuditDigestResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetCommandAuditDigest(
+      privacy_handle, privacy_handle_name, sign_handle, sign_handle_name,
+      qualifying_data, in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetCommandAuditDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(GetCommandAuditDigestResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetCommandAuditDigestSync(
+    const TPMI_RH_ENDORSEMENT& privacy_handle,
+    const std::string& privacy_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    TPM2B_ATTEST* audit_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetCommandAuditDigest(
+      privacy_handle, privacy_handle_name, sign_handle, sign_handle_name,
+      qualifying_data, in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetCommandAuditDigest(response, audit_info, signature,
+                                           authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetTime(
+    const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+    const std::string& privacy_admin_handle_name,
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetTime;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string privacy_admin_handle_bytes;
+  rc = Serialize_TPMI_RH_ENDORSEMENT(privacy_admin_handle,
+                                     &privacy_admin_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(privacy_admin_handle_name.data(),
+               privacy_admin_handle_name.size());
+  handle_section_bytes += privacy_admin_handle_bytes;
+  command_size += privacy_admin_handle_bytes.size();
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetTime(
+    const std::string& response,
+    TPM2B_ATTEST* time_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetTime;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string time_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, time_info, &time_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetTimeErrorCallback(Tpm::GetTimeResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void GetTimeResponseParser(Tpm::GetTimeResponse callback,
+                           AuthorizationDelegate* authorization_delegate,
+                           const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST time_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_GetTime(response, &time_info, &signature,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetTimeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, time_info, signature);
+}
+
+void Tpm::GetTime(const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+                  const std::string& privacy_admin_handle_name,
+                  const TPMI_DH_OBJECT& sign_handle,
+                  const std::string& sign_handle_name,
+                  const TPM2B_DATA& qualifying_data,
+                  const TPMT_SIG_SCHEME& in_scheme,
+                  AuthorizationDelegate* authorization_delegate,
+                  GetTimeResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_GetTime(privacy_admin_handle, privacy_admin_handle_name,
+                               sign_handle, sign_handle_name, qualifying_data,
+                               in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetTimeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      GetTimeResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetTimeSync(const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+                        const std::string& privacy_admin_handle_name,
+                        const TPMI_DH_OBJECT& sign_handle,
+                        const std::string& sign_handle_name,
+                        const TPM2B_DATA& qualifying_data,
+                        const TPMT_SIG_SCHEME& in_scheme,
+                        TPM2B_ATTEST* time_info,
+                        TPMT_SIGNATURE* signature,
+                        AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_GetTime(privacy_admin_handle, privacy_admin_handle_name,
+                               sign_handle, sign_handle_name, qualifying_data,
+                               in_scheme, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetTime(response, time_info, signature,
+                             authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Commit(
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const UINT32& param_size,
+    const TPM2B_ECC_POINT& p1,
+    const TPM2B_SENSITIVE_DATA& s2,
+    const TPM2B_ECC_PARAMETER& y2,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Commit;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string param_size_bytes;
+  rc = Serialize_UINT32(param_size, &param_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string p1_bytes;
+  rc = Serialize_TPM2B_ECC_POINT(p1, &p1_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string s2_bytes;
+  rc = Serialize_TPM2B_SENSITIVE_DATA(s2, &s2_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string y2_bytes;
+  rc = Serialize_TPM2B_ECC_PARAMETER(y2, &y2_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(param_size_bytes.data(), param_size_bytes.size());
+  parameter_section_bytes += param_size_bytes;
+  command_size += param_size_bytes.size();
+  hash->Update(p1_bytes.data(), p1_bytes.size());
+  parameter_section_bytes += p1_bytes;
+  command_size += p1_bytes.size();
+  hash->Update(s2_bytes.data(), s2_bytes.size());
+  parameter_section_bytes += s2_bytes;
+  command_size += s2_bytes.size();
+  hash->Update(y2_bytes.data(), y2_bytes.size());
+  parameter_section_bytes += y2_bytes;
+  command_size += y2_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Commit(
+    const std::string& response,
+    UINT32* param_size_out,
+    TPM2B_ECC_POINT* k,
+    TPM2B_ECC_POINT* l,
+    TPM2B_ECC_POINT* e,
+    UINT16* counter,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Commit;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string param_size_out_bytes;
+  rc = Parse_UINT32(&buffer, param_size_out, &param_size_out_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string k_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, k, &k_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string l_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, l, &l_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string e_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, e, &e_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string counter_bytes;
+  rc = Parse_UINT16(&buffer, counter, &counter_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void CommitErrorCallback(Tpm::CommitResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, UINT32(), TPM2B_ECC_POINT(),
+                          TPM2B_ECC_POINT(), TPM2B_ECC_POINT(), UINT16());
+}
+
+void CommitResponseParser(Tpm::CommitResponse callback,
+                          AuthorizationDelegate* authorization_delegate,
+                          const std::string& response) {
+  VLOG(1) << __func__;
+  UINT32 param_size_out;
+  TPM2B_ECC_POINT k;
+  TPM2B_ECC_POINT l;
+  TPM2B_ECC_POINT e;
+  UINT16 counter;
+  TPM_RC rc = Tpm::ParseResponse_Commit(response, &param_size_out, &k, &l, &e,
+                                        &counter, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CommitErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, param_size_out, k, l, e, counter);
+}
+
+void Tpm::Commit(const TPMI_DH_OBJECT& sign_handle,
+                 const std::string& sign_handle_name,
+                 const UINT32& param_size,
+                 const TPM2B_ECC_POINT& p1,
+                 const TPM2B_SENSITIVE_DATA& s2,
+                 const TPM2B_ECC_PARAMETER& y2,
+                 AuthorizationDelegate* authorization_delegate,
+                 CommitResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Commit(sign_handle, sign_handle_name, param_size, p1, s2,
+                              y2, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CommitErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      CommitResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::CommitSync(const TPMI_DH_OBJECT& sign_handle,
+                       const std::string& sign_handle_name,
+                       const UINT32& param_size,
+                       const TPM2B_ECC_POINT& p1,
+                       const TPM2B_SENSITIVE_DATA& s2,
+                       const TPM2B_ECC_PARAMETER& y2,
+                       UINT32* param_size_out,
+                       TPM2B_ECC_POINT* k,
+                       TPM2B_ECC_POINT* l,
+                       TPM2B_ECC_POINT* e,
+                       UINT16* counter,
+                       AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Commit(sign_handle, sign_handle_name, param_size, p1, s2,
+                              y2, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Commit(response, param_size_out, k, l, e, counter,
+                            authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_EC_Ephemeral(
+    const UINT32& param_size,
+    const TPMI_ECC_CURVE& curve_id,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_EC_Ephemeral;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string param_size_bytes;
+  rc = Serialize_UINT32(param_size, &param_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string curve_id_bytes;
+  rc = Serialize_TPMI_ECC_CURVE(curve_id, &curve_id_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(param_size_bytes.data(), param_size_bytes.size());
+  parameter_section_bytes += param_size_bytes;
+  command_size += param_size_bytes.size();
+  hash->Update(curve_id_bytes.data(), curve_id_bytes.size());
+  parameter_section_bytes += curve_id_bytes;
+  command_size += curve_id_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_EC_Ephemeral(
+    const std::string& response,
+    UINT32* param_size_out,
+    TPM2B_ECC_POINT* q,
+    UINT16* counter,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_EC_Ephemeral;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string param_size_out_bytes;
+  rc = Parse_UINT32(&buffer, param_size_out, &param_size_out_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string q_bytes;
+  rc = Parse_TPM2B_ECC_POINT(&buffer, q, &q_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string counter_bytes;
+  rc = Parse_UINT16(&buffer, counter, &counter_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void EC_EphemeralErrorCallback(Tpm::EC_EphemeralResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, UINT32(), TPM2B_ECC_POINT(), UINT16());
+}
+
+void EC_EphemeralResponseParser(Tpm::EC_EphemeralResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  UINT32 param_size_out;
+  TPM2B_ECC_POINT q;
+  UINT16 counter;
+  TPM_RC rc = Tpm::ParseResponse_EC_Ephemeral(response, &param_size_out, &q,
+                                              &counter, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EC_EphemeralErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, param_size_out, q, counter);
+}
+
+void Tpm::EC_Ephemeral(const UINT32& param_size,
+                       const TPMI_ECC_CURVE& curve_id,
+                       AuthorizationDelegate* authorization_delegate,
+                       EC_EphemeralResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EC_Ephemeral(param_size, curve_id, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EC_EphemeralErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      EC_EphemeralResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::EC_EphemeralSync(const UINT32& param_size,
+                             const TPMI_ECC_CURVE& curve_id,
+                             UINT32* param_size_out,
+                             TPM2B_ECC_POINT* q,
+                             UINT16* counter,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EC_Ephemeral(param_size, curve_id, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_EC_Ephemeral(response, param_size_out, q, counter,
+                                  authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_VerifySignature(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_DIGEST& digest,
+    const TPMT_SIGNATURE& signature,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_VerifySignature;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string digest_bytes;
+  rc = Serialize_TPM2B_DIGEST(digest, &digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Serialize_TPMT_SIGNATURE(signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = digest_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    digest_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(digest_bytes.data(), digest_bytes.size());
+  parameter_section_bytes += digest_bytes;
+  command_size += digest_bytes.size();
+  hash->Update(signature_bytes.data(), signature_bytes.size());
+  parameter_section_bytes += signature_bytes;
+  command_size += signature_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_VerifySignature(
+    const std::string& response,
+    TPMT_TK_VERIFIED* validation,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_VerifySignature;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string validation_bytes;
+  rc = Parse_TPMT_TK_VERIFIED(&buffer, validation, &validation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void VerifySignatureErrorCallback(Tpm::VerifySignatureResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMT_TK_VERIFIED());
+}
+
+void VerifySignatureResponseParser(
+    Tpm::VerifySignatureResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPMT_TK_VERIFIED validation;
+  TPM_RC rc = Tpm::ParseResponse_VerifySignature(response, &validation,
+                                                 authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(VerifySignatureErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, validation);
+}
+
+void Tpm::VerifySignature(const TPMI_DH_OBJECT& key_handle,
+                          const std::string& key_handle_name,
+                          const TPM2B_DIGEST& digest,
+                          const TPMT_SIGNATURE& signature,
+                          AuthorizationDelegate* authorization_delegate,
+                          VerifySignatureResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_VerifySignature(key_handle, key_handle_name,
+                                               digest, signature, &command,
+                                               authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(VerifySignatureErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(VerifySignatureResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::VerifySignatureSync(const TPMI_DH_OBJECT& key_handle,
+                                const std::string& key_handle_name,
+                                const TPM2B_DIGEST& digest,
+                                const TPMT_SIGNATURE& signature,
+                                TPMT_TK_VERIFIED* validation,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_VerifySignature(key_handle, key_handle_name,
+                                               digest, signature, &command,
+                                               authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_VerifySignature(response, validation,
+                                     authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Sign(
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_DIGEST& digest,
+    const TPMT_SIG_SCHEME& in_scheme,
+    const TPMT_TK_HASHCHECK& validation,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Sign;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string digest_bytes;
+  rc = Serialize_TPM2B_DIGEST(digest, &digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string validation_bytes;
+  rc = Serialize_TPMT_TK_HASHCHECK(validation, &validation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = digest_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    digest_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(digest_bytes.data(), digest_bytes.size());
+  parameter_section_bytes += digest_bytes;
+  command_size += digest_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(validation_bytes.data(), validation_bytes.size());
+  parameter_section_bytes += validation_bytes;
+  command_size += validation_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Sign(const std::string& response,
+                               TPMT_SIGNATURE* signature,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Sign;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SignErrorCallback(Tpm::SignResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMT_SIGNATURE());
+}
+
+void SignResponseParser(Tpm::SignResponse callback,
+                        AuthorizationDelegate* authorization_delegate,
+                        const std::string& response) {
+  VLOG(1) << __func__;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc =
+      Tpm::ParseResponse_Sign(response, &signature, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SignErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, signature);
+}
+
+void Tpm::Sign(const TPMI_DH_OBJECT& key_handle,
+               const std::string& key_handle_name,
+               const TPM2B_DIGEST& digest,
+               const TPMT_SIG_SCHEME& in_scheme,
+               const TPMT_TK_HASHCHECK& validation,
+               AuthorizationDelegate* authorization_delegate,
+               SignResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Sign(key_handle, key_handle_name, digest, in_scheme,
+                            validation, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SignErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      SignResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SignSync(const TPMI_DH_OBJECT& key_handle,
+                     const std::string& key_handle_name,
+                     const TPM2B_DIGEST& digest,
+                     const TPMT_SIG_SCHEME& in_scheme,
+                     const TPMT_TK_HASHCHECK& validation,
+                     TPMT_SIGNATURE* signature,
+                     AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_Sign(key_handle, key_handle_name, digest, in_scheme,
+                            validation, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Sign(response, signature, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SetCommandCodeAuditStatus(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const TPMI_ALG_HASH& audit_alg,
+    const TPML_CC& set_list,
+    const TPML_CC& clear_list,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SetCommandCodeAuditStatus;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string audit_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(audit_alg, &audit_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string set_list_bytes;
+  rc = Serialize_TPML_CC(set_list, &set_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string clear_list_bytes;
+  rc = Serialize_TPML_CC(clear_list, &clear_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(audit_alg_bytes.data(), audit_alg_bytes.size());
+  parameter_section_bytes += audit_alg_bytes;
+  command_size += audit_alg_bytes.size();
+  hash->Update(set_list_bytes.data(), set_list_bytes.size());
+  parameter_section_bytes += set_list_bytes;
+  command_size += set_list_bytes.size();
+  hash->Update(clear_list_bytes.data(), clear_list_bytes.size());
+  parameter_section_bytes += clear_list_bytes;
+  command_size += clear_list_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SetCommandCodeAuditStatus(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SetCommandCodeAuditStatus;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SetCommandCodeAuditStatusErrorCallback(
+    Tpm::SetCommandCodeAuditStatusResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void SetCommandCodeAuditStatusResponseParser(
+    Tpm::SetCommandCodeAuditStatusResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_SetCommandCodeAuditStatus(
+      response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        SetCommandCodeAuditStatusErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::SetCommandCodeAuditStatus(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const TPMI_ALG_HASH& audit_alg,
+    const TPML_CC& set_list,
+    const TPML_CC& clear_list,
+    AuthorizationDelegate* authorization_delegate,
+    SetCommandCodeAuditStatusResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetCommandCodeAuditStatus(
+      auth, auth_name, audit_alg, set_list, clear_list, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        SetCommandCodeAuditStatusErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(SetCommandCodeAuditStatusResponseParser,
+                     std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SetCommandCodeAuditStatusSync(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const TPMI_ALG_HASH& audit_alg,
+    const TPML_CC& set_list,
+    const TPML_CC& clear_list,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetCommandCodeAuditStatus(
+      auth, auth_name, audit_alg, set_list, clear_list, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc =
+      ParseResponse_SetCommandCodeAuditStatus(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_Extend(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPML_DIGEST_VALUES& digests,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_Extend;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_handle_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_handle, &pcr_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string digests_bytes;
+  rc = Serialize_TPML_DIGEST_VALUES(digests, &digests_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_handle_name.data(), pcr_handle_name.size());
+  handle_section_bytes += pcr_handle_bytes;
+  command_size += pcr_handle_bytes.size();
+  hash->Update(digests_bytes.data(), digests_bytes.size());
+  parameter_section_bytes += digests_bytes;
+  command_size += digests_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_Extend(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_Extend;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_ExtendErrorCallback(Tpm::PCR_ExtendResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PCR_ExtendResponseParser(Tpm::PCR_ExtendResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PCR_Extend(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ExtendErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PCR_Extend(const TPMI_DH_PCR& pcr_handle,
+                     const std::string& pcr_handle_name,
+                     const TPML_DIGEST_VALUES& digests,
+                     AuthorizationDelegate* authorization_delegate,
+                     PCR_ExtendResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Extend(pcr_handle, pcr_handle_name, digests,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ExtendErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PCR_ExtendResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_ExtendSync(const TPMI_DH_PCR& pcr_handle,
+                           const std::string& pcr_handle_name,
+                           const TPML_DIGEST_VALUES& digests,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Extend(pcr_handle, pcr_handle_name, digests,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_Extend(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_Event(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPM2B_EVENT& event_data,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_Event;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_handle_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_handle, &pcr_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string event_data_bytes;
+  rc = Serialize_TPM2B_EVENT(event_data, &event_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = event_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    event_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_handle_name.data(), pcr_handle_name.size());
+  handle_section_bytes += pcr_handle_bytes;
+  command_size += pcr_handle_bytes.size();
+  hash->Update(event_data_bytes.data(), event_data_bytes.size());
+  parameter_section_bytes += event_data_bytes;
+  command_size += event_data_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_Event(
+    const std::string& response,
+    TPML_DIGEST_VALUES* digests,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_Event;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string digests_bytes;
+  rc = Parse_TPML_DIGEST_VALUES(&buffer, digests, &digests_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_EventErrorCallback(Tpm::PCR_EventResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPML_DIGEST_VALUES());
+}
+
+void PCR_EventResponseParser(Tpm::PCR_EventResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPML_DIGEST_VALUES digests;
+  TPM_RC rc =
+      Tpm::ParseResponse_PCR_Event(response, &digests, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_EventErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, digests);
+}
+
+void Tpm::PCR_Event(const TPMI_DH_PCR& pcr_handle,
+                    const std::string& pcr_handle_name,
+                    const TPM2B_EVENT& event_data,
+                    AuthorizationDelegate* authorization_delegate,
+                    PCR_EventResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_PCR_Event(pcr_handle, pcr_handle_name, event_data,
+                                 &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_EventErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PCR_EventResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_EventSync(const TPMI_DH_PCR& pcr_handle,
+                          const std::string& pcr_handle_name,
+                          const TPM2B_EVENT& event_data,
+                          TPML_DIGEST_VALUES* digests,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_PCR_Event(pcr_handle, pcr_handle_name, event_data,
+                                 &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_Event(response, digests, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_Read(
+    const TPML_PCR_SELECTION& pcr_selection_in,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_Read;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_selection_in_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(pcr_selection_in, &pcr_selection_in_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_selection_in_bytes.data(), pcr_selection_in_bytes.size());
+  parameter_section_bytes += pcr_selection_in_bytes;
+  command_size += pcr_selection_in_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_Read(
+    const std::string& response,
+    UINT32* pcr_update_counter,
+    TPML_PCR_SELECTION* pcr_selection_out,
+    TPML_DIGEST* pcr_values,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_Read;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string pcr_update_counter_bytes;
+  rc = Parse_UINT32(&buffer, pcr_update_counter, &pcr_update_counter_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_selection_out_bytes;
+  rc = Parse_TPML_PCR_SELECTION(&buffer, pcr_selection_out,
+                                &pcr_selection_out_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_values_bytes;
+  rc = Parse_TPML_DIGEST(&buffer, pcr_values, &pcr_values_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_ReadErrorCallback(Tpm::PCR_ReadResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, UINT32(), TPML_PCR_SELECTION(),
+                          TPML_DIGEST());
+}
+
+void PCR_ReadResponseParser(Tpm::PCR_ReadResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  UINT32 pcr_update_counter;
+  TPML_PCR_SELECTION pcr_selection_out;
+  TPML_DIGEST pcr_values;
+  TPM_RC rc = Tpm::ParseResponse_PCR_Read(response, &pcr_update_counter,
+                                          &pcr_selection_out, &pcr_values,
+                                          authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, pcr_update_counter, pcr_selection_out,
+                          pcr_values);
+}
+
+void Tpm::PCR_Read(const TPML_PCR_SELECTION& pcr_selection_in,
+                   AuthorizationDelegate* authorization_delegate,
+                   PCR_ReadResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Read(pcr_selection_in, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PCR_ReadResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_ReadSync(const TPML_PCR_SELECTION& pcr_selection_in,
+                         UINT32* pcr_update_counter,
+                         TPML_PCR_SELECTION* pcr_selection_out,
+                         TPML_DIGEST* pcr_values,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Read(pcr_selection_in, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_Read(response, pcr_update_counter, pcr_selection_out,
+                              pcr_values, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_Allocate(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    const TPML_PCR_SELECTION& pcr_allocation,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_Allocate;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_allocation_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(pcr_allocation, &pcr_allocation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(pcr_allocation_bytes.data(), pcr_allocation_bytes.size());
+  parameter_section_bytes += pcr_allocation_bytes;
+  command_size += pcr_allocation_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_Allocate(
+    const std::string& response,
+    TPMI_YES_NO* allocation_success,
+    UINT32* max_pcr,
+    UINT32* size_needed,
+    UINT32* size_available,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_Allocate;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string allocation_success_bytes;
+  rc =
+      Parse_TPMI_YES_NO(&buffer, allocation_success, &allocation_success_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string max_pcr_bytes;
+  rc = Parse_UINT32(&buffer, max_pcr, &max_pcr_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string size_needed_bytes;
+  rc = Parse_UINT32(&buffer, size_needed, &size_needed_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string size_available_bytes;
+  rc = Parse_UINT32(&buffer, size_available, &size_available_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_AllocateErrorCallback(Tpm::PCR_AllocateResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_YES_NO(), UINT32(), UINT32(),
+                          UINT32());
+}
+
+void PCR_AllocateResponseParser(Tpm::PCR_AllocateResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_YES_NO allocation_success;
+  UINT32 max_pcr;
+  UINT32 size_needed;
+  UINT32 size_available;
+  TPM_RC rc = Tpm::ParseResponse_PCR_Allocate(
+      response, &allocation_success, &max_pcr, &size_needed, &size_available,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_AllocateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, allocation_success, max_pcr, size_needed,
+                          size_available);
+}
+
+void Tpm::PCR_Allocate(const TPMI_RH_PLATFORM& auth_handle,
+                       const std::string& auth_handle_name,
+                       const TPML_PCR_SELECTION& pcr_allocation,
+                       AuthorizationDelegate* authorization_delegate,
+                       PCR_AllocateResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Allocate(auth_handle, auth_handle_name,
+                                            pcr_allocation, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_AllocateErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PCR_AllocateResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_AllocateSync(const TPMI_RH_PLATFORM& auth_handle,
+                             const std::string& auth_handle_name,
+                             const TPML_PCR_SELECTION& pcr_allocation,
+                             TPMI_YES_NO* allocation_success,
+                             UINT32* max_pcr,
+                             UINT32* size_needed,
+                             UINT32* size_available,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Allocate(auth_handle, auth_handle_name,
+                                            pcr_allocation, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_Allocate(response, allocation_success, max_pcr,
+                                  size_needed, size_available,
+                                  authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_SetAuthPolicy(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_DH_PCR& pcr_num,
+    const std::string& pcr_num_name,
+    const TPM2B_DIGEST& auth_policy,
+    const TPMI_ALG_HASH& policy_digest,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_SetAuthPolicy;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_policy_bytes;
+  rc = Serialize_TPM2B_DIGEST(auth_policy, &auth_policy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_digest_bytes;
+  rc = Serialize_TPMI_ALG_HASH(policy_digest, &policy_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_num_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_num, &pcr_num_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_policy_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_policy_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(pcr_num_name.data(), pcr_num_name.size());
+  handle_section_bytes += pcr_num_bytes;
+  command_size += pcr_num_bytes.size();
+  hash->Update(auth_policy_bytes.data(), auth_policy_bytes.size());
+  parameter_section_bytes += auth_policy_bytes;
+  command_size += auth_policy_bytes.size();
+  hash->Update(policy_digest_bytes.data(), policy_digest_bytes.size());
+  parameter_section_bytes += policy_digest_bytes;
+  command_size += policy_digest_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_SetAuthPolicy(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_SetAuthPolicy;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_SetAuthPolicyErrorCallback(Tpm::PCR_SetAuthPolicyResponse callback,
+                                    TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PCR_SetAuthPolicyResponseParser(
+    Tpm::PCR_SetAuthPolicyResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PCR_SetAuthPolicy(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_SetAuthPolicyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PCR_SetAuthPolicy(const TPMI_RH_PLATFORM& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPMI_DH_PCR& pcr_num,
+                            const std::string& pcr_num_name,
+                            const TPM2B_DIGEST& auth_policy,
+                            const TPMI_ALG_HASH& policy_digest,
+                            AuthorizationDelegate* authorization_delegate,
+                            PCR_SetAuthPolicyResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_SetAuthPolicy(
+      auth_handle, auth_handle_name, pcr_num, pcr_num_name, auth_policy,
+      policy_digest, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_SetAuthPolicyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PCR_SetAuthPolicyResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_SetAuthPolicySync(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_DH_PCR& pcr_num,
+    const std::string& pcr_num_name,
+    const TPM2B_DIGEST& auth_policy,
+    const TPMI_ALG_HASH& policy_digest,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_SetAuthPolicy(
+      auth_handle, auth_handle_name, pcr_num, pcr_num_name, auth_policy,
+      policy_digest, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_SetAuthPolicy(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_SetAuthValue(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPM2B_DIGEST& auth,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_SetAuthValue;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_handle_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_handle, &pcr_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPM2B_DIGEST(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_handle_name.data(), pcr_handle_name.size());
+  handle_section_bytes += pcr_handle_bytes;
+  command_size += pcr_handle_bytes.size();
+  hash->Update(auth_bytes.data(), auth_bytes.size());
+  parameter_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_SetAuthValue(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_SetAuthValue;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_SetAuthValueErrorCallback(Tpm::PCR_SetAuthValueResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PCR_SetAuthValueResponseParser(
+    Tpm::PCR_SetAuthValueResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PCR_SetAuthValue(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_SetAuthValueErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PCR_SetAuthValue(const TPMI_DH_PCR& pcr_handle,
+                           const std::string& pcr_handle_name,
+                           const TPM2B_DIGEST& auth,
+                           AuthorizationDelegate* authorization_delegate,
+                           PCR_SetAuthValueResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_SetAuthValue(
+      pcr_handle, pcr_handle_name, auth, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_SetAuthValueErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PCR_SetAuthValueResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_SetAuthValueSync(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    const TPM2B_DIGEST& auth,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_SetAuthValue(
+      pcr_handle, pcr_handle_name, auth, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_SetAuthValue(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PCR_Reset(
+    const TPMI_DH_PCR& pcr_handle,
+    const std::string& pcr_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PCR_Reset;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_handle_bytes;
+  rc = Serialize_TPMI_DH_PCR(pcr_handle, &pcr_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(pcr_handle_name.data(), pcr_handle_name.size());
+  handle_section_bytes += pcr_handle_bytes;
+  command_size += pcr_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PCR_Reset(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PCR_Reset;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PCR_ResetErrorCallback(Tpm::PCR_ResetResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PCR_ResetResponseParser(Tpm::PCR_ResetResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PCR_Reset(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ResetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PCR_Reset(const TPMI_DH_PCR& pcr_handle,
+                    const std::string& pcr_handle_name,
+                    AuthorizationDelegate* authorization_delegate,
+                    PCR_ResetResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Reset(pcr_handle, pcr_handle_name, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PCR_ResetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PCR_ResetResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PCR_ResetSync(const TPMI_DH_PCR& pcr_handle,
+                          const std::string& pcr_handle_name,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PCR_Reset(pcr_handle, pcr_handle_name, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PCR_Reset(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicySigned(
+    const TPMI_DH_OBJECT& auth_object,
+    const std::string& auth_object_name,
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_NONCE& nonce_tpm,
+    const TPM2B_DIGEST& cp_hash_a,
+    const TPM2B_NONCE& policy_ref,
+    const INT32& expiration,
+    const TPMT_SIGNATURE& auth,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicySigned;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_object_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(auth_object, &auth_object_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nonce_tpm_bytes;
+  rc = Serialize_TPM2B_NONCE(nonce_tpm, &nonce_tpm_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string cp_hash_a_bytes;
+  rc = Serialize_TPM2B_DIGEST(cp_hash_a, &cp_hash_a_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ref_bytes;
+  rc = Serialize_TPM2B_NONCE(policy_ref, &policy_ref_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string expiration_bytes;
+  rc = Serialize_INT32(expiration, &expiration_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMT_SIGNATURE(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = nonce_tpm_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    nonce_tpm_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_object_name.data(), auth_object_name.size());
+  handle_section_bytes += auth_object_bytes;
+  command_size += auth_object_bytes.size();
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(nonce_tpm_bytes.data(), nonce_tpm_bytes.size());
+  parameter_section_bytes += nonce_tpm_bytes;
+  command_size += nonce_tpm_bytes.size();
+  hash->Update(cp_hash_a_bytes.data(), cp_hash_a_bytes.size());
+  parameter_section_bytes += cp_hash_a_bytes;
+  command_size += cp_hash_a_bytes.size();
+  hash->Update(policy_ref_bytes.data(), policy_ref_bytes.size());
+  parameter_section_bytes += policy_ref_bytes;
+  command_size += policy_ref_bytes.size();
+  hash->Update(expiration_bytes.data(), expiration_bytes.size());
+  parameter_section_bytes += expiration_bytes;
+  command_size += expiration_bytes.size();
+  hash->Update(auth_bytes.data(), auth_bytes.size());
+  parameter_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicySigned(
+    const std::string& response,
+    TPM2B_TIMEOUT* timeout,
+    TPMT_TK_AUTH* policy_ticket,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicySigned;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string timeout_bytes;
+  rc = Parse_TPM2B_TIMEOUT(&buffer, timeout, &timeout_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ticket_bytes;
+  rc = Parse_TPMT_TK_AUTH(&buffer, policy_ticket, &policy_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicySignedErrorCallback(Tpm::PolicySignedResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_TIMEOUT(), TPMT_TK_AUTH());
+}
+
+void PolicySignedResponseParser(Tpm::PolicySignedResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_TIMEOUT timeout;
+  TPMT_TK_AUTH policy_ticket;
+  TPM_RC rc = Tpm::ParseResponse_PolicySigned(
+      response, &timeout, &policy_ticket, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicySignedErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, timeout, policy_ticket);
+}
+
+void Tpm::PolicySigned(const TPMI_DH_OBJECT& auth_object,
+                       const std::string& auth_object_name,
+                       const TPMI_SH_POLICY& policy_session,
+                       const std::string& policy_session_name,
+                       const TPM2B_NONCE& nonce_tpm,
+                       const TPM2B_DIGEST& cp_hash_a,
+                       const TPM2B_NONCE& policy_ref,
+                       const INT32& expiration,
+                       const TPMT_SIGNATURE& auth,
+                       AuthorizationDelegate* authorization_delegate,
+                       PolicySignedResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicySigned(
+      auth_object, auth_object_name, policy_session, policy_session_name,
+      nonce_tpm, cp_hash_a, policy_ref, expiration, auth, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicySignedErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicySignedResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicySignedSync(const TPMI_DH_OBJECT& auth_object,
+                             const std::string& auth_object_name,
+                             const TPMI_SH_POLICY& policy_session,
+                             const std::string& policy_session_name,
+                             const TPM2B_NONCE& nonce_tpm,
+                             const TPM2B_DIGEST& cp_hash_a,
+                             const TPM2B_NONCE& policy_ref,
+                             const INT32& expiration,
+                             const TPMT_SIGNATURE& auth,
+                             TPM2B_TIMEOUT* timeout,
+                             TPMT_TK_AUTH* policy_ticket,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicySigned(
+      auth_object, auth_object_name, policy_session, policy_session_name,
+      nonce_tpm, cp_hash_a, policy_ref, expiration, auth, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicySigned(response, timeout, policy_ticket,
+                                  authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicySecret(
+    const TPMI_DH_ENTITY& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_NONCE& nonce_tpm,
+    const TPM2B_DIGEST& cp_hash_a,
+    const TPM2B_NONCE& policy_ref,
+    const INT32& expiration,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicySecret;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_DH_ENTITY(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nonce_tpm_bytes;
+  rc = Serialize_TPM2B_NONCE(nonce_tpm, &nonce_tpm_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string cp_hash_a_bytes;
+  rc = Serialize_TPM2B_DIGEST(cp_hash_a, &cp_hash_a_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ref_bytes;
+  rc = Serialize_TPM2B_NONCE(policy_ref, &policy_ref_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string expiration_bytes;
+  rc = Serialize_INT32(expiration, &expiration_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = nonce_tpm_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    nonce_tpm_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(nonce_tpm_bytes.data(), nonce_tpm_bytes.size());
+  parameter_section_bytes += nonce_tpm_bytes;
+  command_size += nonce_tpm_bytes.size();
+  hash->Update(cp_hash_a_bytes.data(), cp_hash_a_bytes.size());
+  parameter_section_bytes += cp_hash_a_bytes;
+  command_size += cp_hash_a_bytes.size();
+  hash->Update(policy_ref_bytes.data(), policy_ref_bytes.size());
+  parameter_section_bytes += policy_ref_bytes;
+  command_size += policy_ref_bytes.size();
+  hash->Update(expiration_bytes.data(), expiration_bytes.size());
+  parameter_section_bytes += expiration_bytes;
+  command_size += expiration_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicySecret(
+    const std::string& response,
+    TPM2B_TIMEOUT* timeout,
+    TPMT_TK_AUTH* policy_ticket,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicySecret;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string timeout_bytes;
+  rc = Parse_TPM2B_TIMEOUT(&buffer, timeout, &timeout_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ticket_bytes;
+  rc = Parse_TPMT_TK_AUTH(&buffer, policy_ticket, &policy_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicySecretErrorCallback(Tpm::PolicySecretResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_TIMEOUT(), TPMT_TK_AUTH());
+}
+
+void PolicySecretResponseParser(Tpm::PolicySecretResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_TIMEOUT timeout;
+  TPMT_TK_AUTH policy_ticket;
+  TPM_RC rc = Tpm::ParseResponse_PolicySecret(
+      response, &timeout, &policy_ticket, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicySecretErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, timeout, policy_ticket);
+}
+
+void Tpm::PolicySecret(const TPMI_DH_ENTITY& auth_handle,
+                       const std::string& auth_handle_name,
+                       const TPMI_SH_POLICY& policy_session,
+                       const std::string& policy_session_name,
+                       const TPM2B_NONCE& nonce_tpm,
+                       const TPM2B_DIGEST& cp_hash_a,
+                       const TPM2B_NONCE& policy_ref,
+                       const INT32& expiration,
+                       AuthorizationDelegate* authorization_delegate,
+                       PolicySecretResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicySecret(
+      auth_handle, auth_handle_name, policy_session, policy_session_name,
+      nonce_tpm, cp_hash_a, policy_ref, expiration, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicySecretErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicySecretResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicySecretSync(const TPMI_DH_ENTITY& auth_handle,
+                             const std::string& auth_handle_name,
+                             const TPMI_SH_POLICY& policy_session,
+                             const std::string& policy_session_name,
+                             const TPM2B_NONCE& nonce_tpm,
+                             const TPM2B_DIGEST& cp_hash_a,
+                             const TPM2B_NONCE& policy_ref,
+                             const INT32& expiration,
+                             TPM2B_TIMEOUT* timeout,
+                             TPMT_TK_AUTH* policy_ticket,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicySecret(
+      auth_handle, auth_handle_name, policy_session, policy_session_name,
+      nonce_tpm, cp_hash_a, policy_ref, expiration, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicySecret(response, timeout, policy_ticket,
+                                  authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyTicket(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_TIMEOUT& timeout,
+    const TPM2B_DIGEST& cp_hash_a,
+    const TPM2B_NONCE& policy_ref,
+    const TPM2B_NAME& auth_name,
+    const TPMT_TK_AUTH& ticket,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyTicket;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string timeout_bytes;
+  rc = Serialize_TPM2B_TIMEOUT(timeout, &timeout_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string cp_hash_a_bytes;
+  rc = Serialize_TPM2B_DIGEST(cp_hash_a, &cp_hash_a_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ref_bytes;
+  rc = Serialize_TPM2B_NONCE(policy_ref, &policy_ref_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_name_bytes;
+  rc = Serialize_TPM2B_NAME(auth_name, &auth_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string ticket_bytes;
+  rc = Serialize_TPMT_TK_AUTH(ticket, &ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = timeout_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    timeout_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(timeout_bytes.data(), timeout_bytes.size());
+  parameter_section_bytes += timeout_bytes;
+  command_size += timeout_bytes.size();
+  hash->Update(cp_hash_a_bytes.data(), cp_hash_a_bytes.size());
+  parameter_section_bytes += cp_hash_a_bytes;
+  command_size += cp_hash_a_bytes.size();
+  hash->Update(policy_ref_bytes.data(), policy_ref_bytes.size());
+  parameter_section_bytes += policy_ref_bytes;
+  command_size += policy_ref_bytes.size();
+  hash->Update(auth_name_bytes.data(), auth_name_bytes.size());
+  parameter_section_bytes += auth_name_bytes;
+  command_size += auth_name_bytes.size();
+  hash->Update(ticket_bytes.data(), ticket_bytes.size());
+  parameter_section_bytes += ticket_bytes;
+  command_size += ticket_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyTicket(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyTicket;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyTicketErrorCallback(Tpm::PolicyTicketResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyTicketResponseParser(Tpm::PolicyTicketResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyTicket(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyTicketErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyTicket(const TPMI_SH_POLICY& policy_session,
+                       const std::string& policy_session_name,
+                       const TPM2B_TIMEOUT& timeout,
+                       const TPM2B_DIGEST& cp_hash_a,
+                       const TPM2B_NONCE& policy_ref,
+                       const TPM2B_NAME& auth_name,
+                       const TPMT_TK_AUTH& ticket,
+                       AuthorizationDelegate* authorization_delegate,
+                       PolicyTicketResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyTicket(
+      policy_session, policy_session_name, timeout, cp_hash_a, policy_ref,
+      auth_name, ticket, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyTicketErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyTicketResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyTicketSync(const TPMI_SH_POLICY& policy_session,
+                             const std::string& policy_session_name,
+                             const TPM2B_TIMEOUT& timeout,
+                             const TPM2B_DIGEST& cp_hash_a,
+                             const TPM2B_NONCE& policy_ref,
+                             const TPM2B_NAME& auth_name,
+                             const TPMT_TK_AUTH& ticket,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyTicket(
+      policy_session, policy_session_name, timeout, cp_hash_a, policy_ref,
+      auth_name, ticket, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyTicket(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyOR(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPML_DIGEST& p_hash_list,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyOR;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string p_hash_list_bytes;
+  rc = Serialize_TPML_DIGEST(p_hash_list, &p_hash_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(p_hash_list_bytes.data(), p_hash_list_bytes.size());
+  parameter_section_bytes += p_hash_list_bytes;
+  command_size += p_hash_list_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyOR(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyOR;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyORErrorCallback(Tpm::PolicyORResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyORResponseParser(Tpm::PolicyORResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyOR(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyORErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyOR(const TPMI_SH_POLICY& policy_session,
+                   const std::string& policy_session_name,
+                   const TPML_DIGEST& p_hash_list,
+                   AuthorizationDelegate* authorization_delegate,
+                   PolicyORResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_PolicyOR(policy_session, policy_session_name,
+                                p_hash_list, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyORErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyORResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyORSync(const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         const TPML_DIGEST& p_hash_list,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_PolicyOR(policy_session, policy_session_name,
+                                p_hash_list, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyOR(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyPCR(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_DIGEST& pcr_digest,
+    const TPML_PCR_SELECTION& pcrs,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyPCR;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcr_digest_bytes;
+  rc = Serialize_TPM2B_DIGEST(pcr_digest, &pcr_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string pcrs_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(pcrs, &pcrs_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = pcr_digest_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    pcr_digest_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(pcr_digest_bytes.data(), pcr_digest_bytes.size());
+  parameter_section_bytes += pcr_digest_bytes;
+  command_size += pcr_digest_bytes.size();
+  hash->Update(pcrs_bytes.data(), pcrs_bytes.size());
+  parameter_section_bytes += pcrs_bytes;
+  command_size += pcrs_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyPCR(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyPCR;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyPCRErrorCallback(Tpm::PolicyPCRResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyPCRResponseParser(Tpm::PolicyPCRResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyPCR(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyPCRErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyPCR(const TPMI_SH_POLICY& policy_session,
+                    const std::string& policy_session_name,
+                    const TPM2B_DIGEST& pcr_digest,
+                    const TPML_PCR_SELECTION& pcrs,
+                    AuthorizationDelegate* authorization_delegate,
+                    PolicyPCRResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPCR(policy_session, policy_session_name,
+                                         pcr_digest, pcrs, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyPCRErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyPCRResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyPCRSync(const TPMI_SH_POLICY& policy_session,
+                          const std::string& policy_session_name,
+                          const TPM2B_DIGEST& pcr_digest,
+                          const TPML_PCR_SELECTION& pcrs,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPCR(policy_session, policy_session_name,
+                                         pcr_digest, pcrs, &command,
+                                         authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyPCR(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyLocality(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPMA_LOCALITY& locality,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyLocality;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string locality_bytes;
+  rc = Serialize_TPMA_LOCALITY(locality, &locality_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(locality_bytes.data(), locality_bytes.size());
+  parameter_section_bytes += locality_bytes;
+  command_size += locality_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyLocality(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyLocality;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyLocalityErrorCallback(Tpm::PolicyLocalityResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyLocalityResponseParser(Tpm::PolicyLocalityResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyLocality(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyLocalityErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyLocality(const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         const TPMA_LOCALITY& locality,
+                         AuthorizationDelegate* authorization_delegate,
+                         PolicyLocalityResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyLocality(policy_session,
+                                              policy_session_name, locality,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyLocalityErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyLocalityResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyLocalitySync(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               const TPMA_LOCALITY& locality,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyLocality(policy_session,
+                                              policy_session_name, locality,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyLocality(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyNV(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_OPERAND& operand_b,
+    const UINT16& offset,
+    const TPM_EO& operation,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyNV;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string operand_b_bytes;
+  rc = Serialize_TPM2B_OPERAND(operand_b, &operand_b_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string offset_bytes;
+  rc = Serialize_UINT16(offset, &offset_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string operation_bytes;
+  rc = Serialize_TPM_EO(operation, &operation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = operand_b_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    operand_b_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(operand_b_bytes.data(), operand_b_bytes.size());
+  parameter_section_bytes += operand_b_bytes;
+  command_size += operand_b_bytes.size();
+  hash->Update(offset_bytes.data(), offset_bytes.size());
+  parameter_section_bytes += offset_bytes;
+  command_size += offset_bytes.size();
+  hash->Update(operation_bytes.data(), operation_bytes.size());
+  parameter_section_bytes += operation_bytes;
+  command_size += operation_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyNV(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyNV;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyNVErrorCallback(Tpm::PolicyNVResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyNVResponseParser(Tpm::PolicyNVResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyNV(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNVErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyNV(const TPMI_RH_NV_AUTH& auth_handle,
+                   const std::string& auth_handle_name,
+                   const TPMI_RH_NV_INDEX& nv_index,
+                   const std::string& nv_index_name,
+                   const TPMI_SH_POLICY& policy_session,
+                   const std::string& policy_session_name,
+                   const TPM2B_OPERAND& operand_b,
+                   const UINT16& offset,
+                   const TPM_EO& operation,
+                   AuthorizationDelegate* authorization_delegate,
+                   PolicyNVResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNV(
+      auth_handle, auth_handle_name, nv_index, nv_index_name, policy_session,
+      policy_session_name, operand_b, offset, operation, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNVErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyNVResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyNVSync(const TPMI_RH_NV_AUTH& auth_handle,
+                         const std::string& auth_handle_name,
+                         const TPMI_RH_NV_INDEX& nv_index,
+                         const std::string& nv_index_name,
+                         const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         const TPM2B_OPERAND& operand_b,
+                         const UINT16& offset,
+                         const TPM_EO& operation,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNV(
+      auth_handle, auth_handle_name, nv_index, nv_index_name, policy_session,
+      policy_session_name, operand_b, offset, operation, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyNV(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyCounterTimer(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_OPERAND& operand_b,
+    const UINT16& offset,
+    const TPM_EO& operation,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyCounterTimer;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string operand_b_bytes;
+  rc = Serialize_TPM2B_OPERAND(operand_b, &operand_b_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string offset_bytes;
+  rc = Serialize_UINT16(offset, &offset_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string operation_bytes;
+  rc = Serialize_TPM_EO(operation, &operation_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = operand_b_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    operand_b_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(operand_b_bytes.data(), operand_b_bytes.size());
+  parameter_section_bytes += operand_b_bytes;
+  command_size += operand_b_bytes.size();
+  hash->Update(offset_bytes.data(), offset_bytes.size());
+  parameter_section_bytes += offset_bytes;
+  command_size += offset_bytes.size();
+  hash->Update(operation_bytes.data(), operation_bytes.size());
+  parameter_section_bytes += operation_bytes;
+  command_size += operation_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyCounterTimer(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyCounterTimer;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyCounterTimerErrorCallback(Tpm::PolicyCounterTimerResponse callback,
+                                     TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyCounterTimerResponseParser(
+    Tpm::PolicyCounterTimerResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyCounterTimer(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCounterTimerErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyCounterTimer(const TPMI_SH_POLICY& policy_session,
+                             const std::string& policy_session_name,
+                             const TPM2B_OPERAND& operand_b,
+                             const UINT16& offset,
+                             const TPM_EO& operation,
+                             AuthorizationDelegate* authorization_delegate,
+                             PolicyCounterTimerResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCounterTimer(
+      policy_session, policy_session_name, operand_b, offset, operation,
+      &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCounterTimerErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyCounterTimerResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyCounterTimerSync(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_OPERAND& operand_b,
+    const UINT16& offset,
+    const TPM_EO& operation,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCounterTimer(
+      policy_session, policy_session_name, operand_b, offset, operation,
+      &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyCounterTimer(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyCommandCode(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM_CC& code,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyCommandCode;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string code_bytes;
+  rc = Serialize_TPM_CC(code, &code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(code_bytes.data(), code_bytes.size());
+  parameter_section_bytes += code_bytes;
+  command_size += code_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyCommandCode(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyCommandCode;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyCommandCodeErrorCallback(Tpm::PolicyCommandCodeResponse callback,
+                                    TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyCommandCodeResponseParser(
+    Tpm::PolicyCommandCodeResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyCommandCode(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCommandCodeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyCommandCode(const TPMI_SH_POLICY& policy_session,
+                            const std::string& policy_session_name,
+                            const TPM_CC& code,
+                            AuthorizationDelegate* authorization_delegate,
+                            PolicyCommandCodeResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCommandCode(
+      policy_session, policy_session_name, code, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCommandCodeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyCommandCodeResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyCommandCodeSync(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM_CC& code,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCommandCode(
+      policy_session, policy_session_name, code, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyCommandCode(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyPhysicalPresence(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyPhysicalPresence;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyPhysicalPresence(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyPhysicalPresence;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyPhysicalPresenceErrorCallback(
+    Tpm::PolicyPhysicalPresenceResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyPhysicalPresenceResponseParser(
+    Tpm::PolicyPhysicalPresenceResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyPhysicalPresence(response,
+                                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        PolicyPhysicalPresenceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyPhysicalPresence(const TPMI_SH_POLICY& policy_session,
+                                 const std::string& policy_session_name,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 PolicyPhysicalPresenceResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPhysicalPresence(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        PolicyPhysicalPresenceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyPhysicalPresenceResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyPhysicalPresenceSync(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPhysicalPresence(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyPhysicalPresence(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyCpHash(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_DIGEST& cp_hash_a,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyCpHash;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string cp_hash_a_bytes;
+  rc = Serialize_TPM2B_DIGEST(cp_hash_a, &cp_hash_a_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = cp_hash_a_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    cp_hash_a_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(cp_hash_a_bytes.data(), cp_hash_a_bytes.size());
+  parameter_section_bytes += cp_hash_a_bytes;
+  command_size += cp_hash_a_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyCpHash(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyCpHash;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyCpHashErrorCallback(Tpm::PolicyCpHashResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyCpHashResponseParser(Tpm::PolicyCpHashResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyCpHash(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCpHashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyCpHash(const TPMI_SH_POLICY& policy_session,
+                       const std::string& policy_session_name,
+                       const TPM2B_DIGEST& cp_hash_a,
+                       AuthorizationDelegate* authorization_delegate,
+                       PolicyCpHashResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCpHash(policy_session, policy_session_name,
+                                            cp_hash_a, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyCpHashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PolicyCpHashResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyCpHashSync(const TPMI_SH_POLICY& policy_session,
+                             const std::string& policy_session_name,
+                             const TPM2B_DIGEST& cp_hash_a,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyCpHash(policy_session, policy_session_name,
+                                            cp_hash_a, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyCpHash(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyNameHash(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_DIGEST& name_hash,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyNameHash;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string name_hash_bytes;
+  rc = Serialize_TPM2B_DIGEST(name_hash, &name_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = name_hash_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    name_hash_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(name_hash_bytes.data(), name_hash_bytes.size());
+  parameter_section_bytes += name_hash_bytes;
+  command_size += name_hash_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyNameHash(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyNameHash;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyNameHashErrorCallback(Tpm::PolicyNameHashResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyNameHashResponseParser(Tpm::PolicyNameHashResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyNameHash(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNameHashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyNameHash(const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         const TPM2B_DIGEST& name_hash,
+                         AuthorizationDelegate* authorization_delegate,
+                         PolicyNameHashResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNameHash(policy_session,
+                                              policy_session_name, name_hash,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNameHashErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyNameHashResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyNameHashSync(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               const TPM2B_DIGEST& name_hash,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNameHash(policy_session,
+                                              policy_session_name, name_hash,
+                                              &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyNameHash(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyDuplicationSelect(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_NAME& object_name,
+    const TPM2B_NAME& new_parent_name,
+    const TPMI_YES_NO& include_object,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyDuplicationSelect;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_name_bytes;
+  rc = Serialize_TPM2B_NAME(object_name, &object_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_parent_name_bytes;
+  rc = Serialize_TPM2B_NAME(new_parent_name, &new_parent_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string include_object_bytes;
+  rc = Serialize_TPMI_YES_NO(include_object, &include_object_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = object_name_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    object_name_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(object_name_bytes.data(), object_name_bytes.size());
+  parameter_section_bytes += object_name_bytes;
+  command_size += object_name_bytes.size();
+  hash->Update(new_parent_name_bytes.data(), new_parent_name_bytes.size());
+  parameter_section_bytes += new_parent_name_bytes;
+  command_size += new_parent_name_bytes.size();
+  hash->Update(include_object_bytes.data(), include_object_bytes.size());
+  parameter_section_bytes += include_object_bytes;
+  command_size += include_object_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyDuplicationSelect(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyDuplicationSelect;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyDuplicationSelectErrorCallback(
+    Tpm::PolicyDuplicationSelectResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyDuplicationSelectResponseParser(
+    Tpm::PolicyDuplicationSelectResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PolicyDuplicationSelect(
+      response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        PolicyDuplicationSelectErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyDuplicationSelect(const TPMI_SH_POLICY& policy_session,
+                                  const std::string& policy_session_name,
+                                  const TPM2B_NAME& object_name,
+                                  const TPM2B_NAME& new_parent_name,
+                                  const TPMI_YES_NO& include_object,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  PolicyDuplicationSelectResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyDuplicationSelect(
+      policy_session, policy_session_name, object_name, new_parent_name,
+      include_object, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        PolicyDuplicationSelectErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyDuplicationSelectResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyDuplicationSelectSync(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_NAME& object_name,
+    const TPM2B_NAME& new_parent_name,
+    const TPMI_YES_NO& include_object,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyDuplicationSelect(
+      policy_session, policy_session_name, object_name, new_parent_name,
+      include_object, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyDuplicationSelect(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyAuthorize(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPM2B_DIGEST& approved_policy,
+    const TPM2B_NONCE& policy_ref,
+    const TPM2B_NAME& key_sign,
+    const TPMT_TK_VERIFIED& check_ticket,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyAuthorize;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string approved_policy_bytes;
+  rc = Serialize_TPM2B_DIGEST(approved_policy, &approved_policy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_ref_bytes;
+  rc = Serialize_TPM2B_NONCE(policy_ref, &policy_ref_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_sign_bytes;
+  rc = Serialize_TPM2B_NAME(key_sign, &key_sign_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string check_ticket_bytes;
+  rc = Serialize_TPMT_TK_VERIFIED(check_ticket, &check_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = approved_policy_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    approved_policy_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(approved_policy_bytes.data(), approved_policy_bytes.size());
+  parameter_section_bytes += approved_policy_bytes;
+  command_size += approved_policy_bytes.size();
+  hash->Update(policy_ref_bytes.data(), policy_ref_bytes.size());
+  parameter_section_bytes += policy_ref_bytes;
+  command_size += policy_ref_bytes.size();
+  hash->Update(key_sign_bytes.data(), key_sign_bytes.size());
+  parameter_section_bytes += key_sign_bytes;
+  command_size += key_sign_bytes.size();
+  hash->Update(check_ticket_bytes.data(), check_ticket_bytes.size());
+  parameter_section_bytes += check_ticket_bytes;
+  command_size += check_ticket_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyAuthorize(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyAuthorize;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyAuthorizeErrorCallback(Tpm::PolicyAuthorizeResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyAuthorizeResponseParser(
+    Tpm::PolicyAuthorizeResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyAuthorize(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyAuthorizeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyAuthorize(const TPMI_SH_POLICY& policy_session,
+                          const std::string& policy_session_name,
+                          const TPM2B_DIGEST& approved_policy,
+                          const TPM2B_NONCE& policy_ref,
+                          const TPM2B_NAME& key_sign,
+                          const TPMT_TK_VERIFIED& check_ticket,
+                          AuthorizationDelegate* authorization_delegate,
+                          PolicyAuthorizeResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyAuthorize(
+      policy_session, policy_session_name, approved_policy, policy_ref,
+      key_sign, check_ticket, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyAuthorizeErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyAuthorizeResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyAuthorizeSync(const TPMI_SH_POLICY& policy_session,
+                                const std::string& policy_session_name,
+                                const TPM2B_DIGEST& approved_policy,
+                                const TPM2B_NONCE& policy_ref,
+                                const TPM2B_NAME& key_sign,
+                                const TPMT_TK_VERIFIED& check_ticket,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyAuthorize(
+      policy_session, policy_session_name, approved_policy, policy_ref,
+      key_sign, check_ticket, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyAuthorize(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyAuthValue(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyAuthValue;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyAuthValue(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyAuthValue;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyAuthValueErrorCallback(Tpm::PolicyAuthValueResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyAuthValueResponseParser(
+    Tpm::PolicyAuthValueResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyAuthValue(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyAuthValueErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyAuthValue(const TPMI_SH_POLICY& policy_session,
+                          const std::string& policy_session_name,
+                          AuthorizationDelegate* authorization_delegate,
+                          PolicyAuthValueResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyAuthValue(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyAuthValueErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyAuthValueResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyAuthValueSync(const TPMI_SH_POLICY& policy_session,
+                                const std::string& policy_session_name,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyAuthValue(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyAuthValue(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyPassword(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyPassword;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyPassword(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyPassword;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyPasswordErrorCallback(Tpm::PolicyPasswordResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyPasswordResponseParser(Tpm::PolicyPasswordResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyPassword(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyPasswordErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyPassword(const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         AuthorizationDelegate* authorization_delegate,
+                         PolicyPasswordResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPassword(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyPasswordErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyPasswordResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyPasswordSync(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyPassword(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyPassword(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyGetDigest(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyGetDigest;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyGetDigest(
+    const std::string& response,
+    TPM2B_DIGEST* policy_digest,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyGetDigest;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string policy_digest_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, policy_digest, &policy_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyGetDigestErrorCallback(Tpm::PolicyGetDigestResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_DIGEST());
+}
+
+void PolicyGetDigestResponseParser(
+    Tpm::PolicyGetDigestResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_DIGEST policy_digest;
+  TPM_RC rc = Tpm::ParseResponse_PolicyGetDigest(response, &policy_digest,
+                                                 authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyGetDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, policy_digest);
+}
+
+void Tpm::PolicyGetDigest(const TPMI_SH_POLICY& policy_session,
+                          const std::string& policy_session_name,
+                          AuthorizationDelegate* authorization_delegate,
+                          PolicyGetDigestResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyGetDigest(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyGetDigestErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyGetDigestResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyGetDigestSync(const TPMI_SH_POLICY& policy_session,
+                                const std::string& policy_session_name,
+                                TPM2B_DIGEST* policy_digest,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyGetDigest(
+      policy_session, policy_session_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyGetDigest(response, policy_digest,
+                                     authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PolicyNvWritten(
+    const TPMI_SH_POLICY& policy_session,
+    const std::string& policy_session_name,
+    const TPMI_YES_NO& written_set,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PolicyNvWritten;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string policy_session_bytes;
+  rc = Serialize_TPMI_SH_POLICY(policy_session, &policy_session_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string written_set_bytes;
+  rc = Serialize_TPMI_YES_NO(written_set, &written_set_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(policy_session_name.data(), policy_session_name.size());
+  handle_section_bytes += policy_session_bytes;
+  command_size += policy_session_bytes.size();
+  hash->Update(written_set_bytes.data(), written_set_bytes.size());
+  parameter_section_bytes += written_set_bytes;
+  command_size += written_set_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PolicyNvWritten(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PolicyNvWritten;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PolicyNvWrittenErrorCallback(Tpm::PolicyNvWrittenResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PolicyNvWrittenResponseParser(
+    Tpm::PolicyNvWrittenResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_PolicyNvWritten(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNvWrittenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PolicyNvWritten(const TPMI_SH_POLICY& policy_session,
+                          const std::string& policy_session_name,
+                          const TPMI_YES_NO& written_set,
+                          AuthorizationDelegate* authorization_delegate,
+                          PolicyNvWrittenResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNvWritten(
+      policy_session, policy_session_name, written_set, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PolicyNvWrittenErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(PolicyNvWrittenResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PolicyNvWrittenSync(const TPMI_SH_POLICY& policy_session,
+                                const std::string& policy_session_name,
+                                const TPMI_YES_NO& written_set,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PolicyNvWritten(
+      policy_session, policy_session_name, written_set, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PolicyNvWritten(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_CreatePrimary(
+    const TPMI_RH_HIERARCHY& primary_handle,
+    const std::string& primary_handle_name,
+    const TPM2B_SENSITIVE_CREATE& in_sensitive,
+    const TPM2B_PUBLIC& in_public,
+    const TPM2B_DATA& outside_info,
+    const TPML_PCR_SELECTION& creation_pcr,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_CreatePrimary;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string primary_handle_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(primary_handle, &primary_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_sensitive_bytes;
+  rc = Serialize_TPM2B_SENSITIVE_CREATE(in_sensitive, &in_sensitive_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_public_bytes;
+  rc = Serialize_TPM2B_PUBLIC(in_public, &in_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string outside_info_bytes;
+  rc = Serialize_TPM2B_DATA(outside_info, &outside_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_pcr_bytes;
+  rc = Serialize_TPML_PCR_SELECTION(creation_pcr, &creation_pcr_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = in_sensitive_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    in_sensitive_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(primary_handle_name.data(), primary_handle_name.size());
+  handle_section_bytes += primary_handle_bytes;
+  command_size += primary_handle_bytes.size();
+  hash->Update(in_sensitive_bytes.data(), in_sensitive_bytes.size());
+  parameter_section_bytes += in_sensitive_bytes;
+  command_size += in_sensitive_bytes.size();
+  hash->Update(in_public_bytes.data(), in_public_bytes.size());
+  parameter_section_bytes += in_public_bytes;
+  command_size += in_public_bytes.size();
+  hash->Update(outside_info_bytes.data(), outside_info_bytes.size());
+  parameter_section_bytes += outside_info_bytes;
+  command_size += outside_info_bytes.size();
+  hash->Update(creation_pcr_bytes.data(), creation_pcr_bytes.size());
+  parameter_section_bytes += creation_pcr_bytes;
+  command_size += creation_pcr_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_CreatePrimary(
+    const std::string& response,
+    TPM_HANDLE* object_handle,
+    TPM2B_PUBLIC* out_public,
+    TPM2B_CREATION_DATA* creation_data,
+    TPM2B_DIGEST* creation_hash,
+    TPMT_TK_CREATION* creation_ticket,
+    TPM2B_NAME* name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string object_handle_bytes;
+  rc = Parse_TPM_HANDLE(&buffer, object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_CreatePrimary;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string out_public_bytes;
+  rc = Parse_TPM2B_PUBLIC(&buffer, out_public, &out_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_data_bytes;
+  rc = Parse_TPM2B_CREATION_DATA(&buffer, creation_data, &creation_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_hash_bytes;
+  rc = Parse_TPM2B_DIGEST(&buffer, creation_hash, &creation_hash_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string creation_ticket_bytes;
+  rc = Parse_TPMT_TK_CREATION(&buffer, creation_ticket, &creation_ticket_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, name, &name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void CreatePrimaryErrorCallback(Tpm::CreatePrimaryResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM_HANDLE(), TPM2B_PUBLIC(),
+                          TPM2B_CREATION_DATA(), TPM2B_DIGEST(),
+                          TPMT_TK_CREATION(), TPM2B_NAME());
+}
+
+void CreatePrimaryResponseParser(Tpm::CreatePrimaryResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_HANDLE object_handle;
+  TPM2B_PUBLIC out_public;
+  TPM2B_CREATION_DATA creation_data;
+  TPM2B_DIGEST creation_hash;
+  TPMT_TK_CREATION creation_ticket;
+  TPM2B_NAME name;
+  TPM_RC rc = Tpm::ParseResponse_CreatePrimary(
+      response, &object_handle, &out_public, &creation_data, &creation_hash,
+      &creation_ticket, &name, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CreatePrimaryErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, object_handle, out_public, creation_data,
+                          creation_hash, creation_ticket, name);
+}
+
+void Tpm::CreatePrimary(const TPMI_RH_HIERARCHY& primary_handle,
+                        const std::string& primary_handle_name,
+                        const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                        const TPM2B_PUBLIC& in_public,
+                        const TPM2B_DATA& outside_info,
+                        const TPML_PCR_SELECTION& creation_pcr,
+                        AuthorizationDelegate* authorization_delegate,
+                        CreatePrimaryResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_CreatePrimary(
+      primary_handle, primary_handle_name, in_sensitive, in_public,
+      outside_info, creation_pcr, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(CreatePrimaryErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      CreatePrimaryResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::CreatePrimarySync(const TPMI_RH_HIERARCHY& primary_handle,
+                              const std::string& primary_handle_name,
+                              const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                              const TPM2B_PUBLIC& in_public,
+                              const TPM2B_DATA& outside_info,
+                              const TPML_PCR_SELECTION& creation_pcr,
+                              TPM_HANDLE* object_handle,
+                              TPM2B_PUBLIC* out_public,
+                              TPM2B_CREATION_DATA* creation_data,
+                              TPM2B_DIGEST* creation_hash,
+                              TPMT_TK_CREATION* creation_ticket,
+                              TPM2B_NAME* name,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_CreatePrimary(
+      primary_handle, primary_handle_name, in_sensitive, in_public,
+      outside_info, creation_pcr, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_CreatePrimary(
+      response, object_handle, out_public, creation_data, creation_hash,
+      creation_ticket, name, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_HierarchyControl(
+    const TPMI_RH_HIERARCHY& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_ENABLES& enable,
+    const TPMI_YES_NO& state,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_HierarchyControl;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string enable_bytes;
+  rc = Serialize_TPMI_RH_ENABLES(enable, &enable_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string state_bytes;
+  rc = Serialize_TPMI_YES_NO(state, &state_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(enable_bytes.data(), enable_bytes.size());
+  parameter_section_bytes += enable_bytes;
+  command_size += enable_bytes.size();
+  hash->Update(state_bytes.data(), state_bytes.size());
+  parameter_section_bytes += state_bytes;
+  command_size += state_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_HierarchyControl(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_HierarchyControl;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HierarchyControlErrorCallback(Tpm::HierarchyControlResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void HierarchyControlResponseParser(
+    Tpm::HierarchyControlResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_HierarchyControl(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HierarchyControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::HierarchyControl(const TPMI_RH_HIERARCHY& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPMI_RH_ENABLES& enable,
+                           const TPMI_YES_NO& state,
+                           AuthorizationDelegate* authorization_delegate,
+                           HierarchyControlResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HierarchyControl(auth_handle, auth_handle_name,
+                                                enable, state, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HierarchyControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(HierarchyControlResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HierarchyControlSync(
+    const TPMI_RH_HIERARCHY& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_ENABLES& enable,
+    const TPMI_YES_NO& state,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HierarchyControl(auth_handle, auth_handle_name,
+                                                enable, state, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_HierarchyControl(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SetPrimaryPolicy(
+    const TPMI_RH_HIERARCHY& auth_handle,
+    const std::string& auth_handle_name,
+    const TPM2B_DIGEST& auth_policy,
+    const TPMI_ALG_HASH& hash_alg,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SetPrimaryPolicy;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_policy_bytes;
+  rc = Serialize_TPM2B_DIGEST(auth_policy, &auth_policy_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string hash_alg_bytes;
+  rc = Serialize_TPMI_ALG_HASH(hash_alg, &hash_alg_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_policy_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_policy_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(auth_policy_bytes.data(), auth_policy_bytes.size());
+  parameter_section_bytes += auth_policy_bytes;
+  command_size += auth_policy_bytes.size();
+  hash->Update(hash_alg_bytes.data(), hash_alg_bytes.size());
+  parameter_section_bytes += hash_alg_bytes;
+  command_size += hash_alg_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SetPrimaryPolicy(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SetPrimaryPolicy;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SetPrimaryPolicyErrorCallback(Tpm::SetPrimaryPolicyResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void SetPrimaryPolicyResponseParser(
+    Tpm::SetPrimaryPolicyResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_SetPrimaryPolicy(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SetPrimaryPolicyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::SetPrimaryPolicy(const TPMI_RH_HIERARCHY& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPM2B_DIGEST& auth_policy,
+                           const TPMI_ALG_HASH& hash_alg,
+                           AuthorizationDelegate* authorization_delegate,
+                           SetPrimaryPolicyResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetPrimaryPolicy(auth_handle, auth_handle_name,
+                                                auth_policy, hash_alg, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SetPrimaryPolicyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(SetPrimaryPolicyResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SetPrimaryPolicySync(
+    const TPMI_RH_HIERARCHY& auth_handle,
+    const std::string& auth_handle_name,
+    const TPM2B_DIGEST& auth_policy,
+    const TPMI_ALG_HASH& hash_alg,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetPrimaryPolicy(auth_handle, auth_handle_name,
+                                                auth_policy, hash_alg, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_SetPrimaryPolicy(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ChangePPS(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ChangePPS;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ChangePPS(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ChangePPS;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ChangePPSErrorCallback(Tpm::ChangePPSResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ChangePPSResponseParser(Tpm::ChangePPSResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_ChangePPS(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ChangePPSErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::ChangePPS(const TPMI_RH_PLATFORM& auth_handle,
+                    const std::string& auth_handle_name,
+                    AuthorizationDelegate* authorization_delegate,
+                    ChangePPSResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ChangePPS(auth_handle, auth_handle_name,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ChangePPSErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ChangePPSResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ChangePPSSync(const TPMI_RH_PLATFORM& auth_handle,
+                          const std::string& auth_handle_name,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ChangePPS(auth_handle, auth_handle_name,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ChangePPS(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ChangeEPS(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ChangeEPS;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ChangeEPS(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ChangeEPS;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ChangeEPSErrorCallback(Tpm::ChangeEPSResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ChangeEPSResponseParser(Tpm::ChangeEPSResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_ChangeEPS(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ChangeEPSErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::ChangeEPS(const TPMI_RH_PLATFORM& auth_handle,
+                    const std::string& auth_handle_name,
+                    AuthorizationDelegate* authorization_delegate,
+                    ChangeEPSResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ChangeEPS(auth_handle, auth_handle_name,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ChangeEPSErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ChangeEPSResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ChangeEPSSync(const TPMI_RH_PLATFORM& auth_handle,
+                          const std::string& auth_handle_name,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ChangeEPS(auth_handle, auth_handle_name,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ChangeEPS(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_Clear(
+    const TPMI_RH_CLEAR& auth_handle,
+    const std::string& auth_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_Clear;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_CLEAR(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_Clear(const std::string& response,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_Clear;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ClearErrorCallback(Tpm::ClearResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ClearResponseParser(Tpm::ClearResponse callback,
+                         AuthorizationDelegate* authorization_delegate,
+                         const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_Clear(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClearErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::Clear(const TPMI_RH_CLEAR& auth_handle,
+                const std::string& auth_handle_name,
+                AuthorizationDelegate* authorization_delegate,
+                ClearResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Clear(auth_handle, auth_handle_name, &command,
+                                     authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClearErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ClearResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ClearSync(const TPMI_RH_CLEAR& auth_handle,
+                      const std::string& auth_handle_name,
+                      AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_Clear(auth_handle, auth_handle_name, &command,
+                                     authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_Clear(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ClearControl(
+    const TPMI_RH_CLEAR& auth,
+    const std::string& auth_name,
+    const TPMI_YES_NO& disable,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ClearControl;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_CLEAR(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string disable_bytes;
+  rc = Serialize_TPMI_YES_NO(disable, &disable_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(disable_bytes.data(), disable_bytes.size());
+  parameter_section_bytes += disable_bytes;
+  command_size += disable_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ClearControl(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ClearControl;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ClearControlErrorCallback(Tpm::ClearControlResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ClearControlResponseParser(Tpm::ClearControlResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_ClearControl(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClearControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::ClearControl(const TPMI_RH_CLEAR& auth,
+                       const std::string& auth_name,
+                       const TPMI_YES_NO& disable,
+                       AuthorizationDelegate* authorization_delegate,
+                       ClearControlResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClearControl(auth, auth_name, disable, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClearControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ClearControlResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ClearControlSync(const TPMI_RH_CLEAR& auth,
+                             const std::string& auth_name,
+                             const TPMI_YES_NO& disable,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClearControl(auth, auth_name, disable, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ClearControl(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_HierarchyChangeAuth(
+    const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPM2B_AUTH& new_auth,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_HierarchyChangeAuth;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_HIERARCHY_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_auth_bytes;
+  rc = Serialize_TPM2B_AUTH(new_auth, &new_auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = new_auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    new_auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(new_auth_bytes.data(), new_auth_bytes.size());
+  parameter_section_bytes += new_auth_bytes;
+  command_size += new_auth_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_HierarchyChangeAuth(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_HierarchyChangeAuth;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void HierarchyChangeAuthErrorCallback(Tpm::HierarchyChangeAuthResponse callback,
+                                      TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void HierarchyChangeAuthResponseParser(
+    Tpm::HierarchyChangeAuthResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_HierarchyChangeAuth(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HierarchyChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::HierarchyChangeAuth(const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+                              const std::string& auth_handle_name,
+                              const TPM2B_AUTH& new_auth,
+                              AuthorizationDelegate* authorization_delegate,
+                              HierarchyChangeAuthResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HierarchyChangeAuth(
+      auth_handle, auth_handle_name, new_auth, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(HierarchyChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(HierarchyChangeAuthResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::HierarchyChangeAuthSync(
+    const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPM2B_AUTH& new_auth,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_HierarchyChangeAuth(
+      auth_handle, auth_handle_name, new_auth, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_HierarchyChangeAuth(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_DictionaryAttackLockReset(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_DictionaryAttackLockReset;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string lock_handle_bytes;
+  rc = Serialize_TPMI_RH_LOCKOUT(lock_handle, &lock_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(lock_handle_name.data(), lock_handle_name.size());
+  handle_section_bytes += lock_handle_bytes;
+  command_size += lock_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_DictionaryAttackLockReset(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_DictionaryAttackLockReset;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void DictionaryAttackLockResetErrorCallback(
+    Tpm::DictionaryAttackLockResetResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void DictionaryAttackLockResetResponseParser(
+    Tpm::DictionaryAttackLockResetResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_DictionaryAttackLockReset(
+      response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        DictionaryAttackLockResetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::DictionaryAttackLockReset(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    AuthorizationDelegate* authorization_delegate,
+    DictionaryAttackLockResetResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_DictionaryAttackLockReset(
+      lock_handle, lock_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        DictionaryAttackLockResetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(DictionaryAttackLockResetResponseParser,
+                     std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::DictionaryAttackLockResetSync(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_DictionaryAttackLockReset(
+      lock_handle, lock_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc =
+      ParseResponse_DictionaryAttackLockReset(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_DictionaryAttackParameters(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    const UINT32& new_max_tries,
+    const UINT32& new_recovery_time,
+    const UINT32& lockout_recovery,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_DictionaryAttackParameters;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string lock_handle_bytes;
+  rc = Serialize_TPMI_RH_LOCKOUT(lock_handle, &lock_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_max_tries_bytes;
+  rc = Serialize_UINT32(new_max_tries, &new_max_tries_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_recovery_time_bytes;
+  rc = Serialize_UINT32(new_recovery_time, &new_recovery_time_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string lockout_recovery_bytes;
+  rc = Serialize_UINT32(lockout_recovery, &lockout_recovery_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(lock_handle_name.data(), lock_handle_name.size());
+  handle_section_bytes += lock_handle_bytes;
+  command_size += lock_handle_bytes.size();
+  hash->Update(new_max_tries_bytes.data(), new_max_tries_bytes.size());
+  parameter_section_bytes += new_max_tries_bytes;
+  command_size += new_max_tries_bytes.size();
+  hash->Update(new_recovery_time_bytes.data(), new_recovery_time_bytes.size());
+  parameter_section_bytes += new_recovery_time_bytes;
+  command_size += new_recovery_time_bytes.size();
+  hash->Update(lockout_recovery_bytes.data(), lockout_recovery_bytes.size());
+  parameter_section_bytes += lockout_recovery_bytes;
+  command_size += lockout_recovery_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_DictionaryAttackParameters(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_DictionaryAttackParameters;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void DictionaryAttackParametersErrorCallback(
+    Tpm::DictionaryAttackParametersResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void DictionaryAttackParametersResponseParser(
+    Tpm::DictionaryAttackParametersResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_DictionaryAttackParameters(
+      response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        DictionaryAttackParametersErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::DictionaryAttackParameters(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    const UINT32& new_max_tries,
+    const UINT32& new_recovery_time,
+    const UINT32& lockout_recovery,
+    AuthorizationDelegate* authorization_delegate,
+    DictionaryAttackParametersResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_DictionaryAttackParameters(
+      lock_handle, lock_handle_name, new_max_tries, new_recovery_time,
+      lockout_recovery, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        DictionaryAttackParametersErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(DictionaryAttackParametersResponseParser,
+                     std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::DictionaryAttackParametersSync(
+    const TPMI_RH_LOCKOUT& lock_handle,
+    const std::string& lock_handle_name,
+    const UINT32& new_max_tries,
+    const UINT32& new_recovery_time,
+    const UINT32& lockout_recovery,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_DictionaryAttackParameters(
+      lock_handle, lock_handle_name, new_max_tries, new_recovery_time,
+      lockout_recovery, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_DictionaryAttackParameters(response,
+                                                authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_PP_Commands(
+    const TPMI_RH_PLATFORM& auth,
+    const std::string& auth_name,
+    const TPML_CC& set_list,
+    const TPML_CC& clear_list,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_PP_Commands;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string set_list_bytes;
+  rc = Serialize_TPML_CC(set_list, &set_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string clear_list_bytes;
+  rc = Serialize_TPML_CC(clear_list, &clear_list_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(set_list_bytes.data(), set_list_bytes.size());
+  parameter_section_bytes += set_list_bytes;
+  command_size += set_list_bytes.size();
+  hash->Update(clear_list_bytes.data(), clear_list_bytes.size());
+  parameter_section_bytes += clear_list_bytes;
+  command_size += clear_list_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_PP_Commands(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_PP_Commands;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void PP_CommandsErrorCallback(Tpm::PP_CommandsResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void PP_CommandsResponseParser(Tpm::PP_CommandsResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_PP_Commands(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PP_CommandsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::PP_Commands(const TPMI_RH_PLATFORM& auth,
+                      const std::string& auth_name,
+                      const TPML_CC& set_list,
+                      const TPML_CC& clear_list,
+                      AuthorizationDelegate* authorization_delegate,
+                      PP_CommandsResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PP_Commands(
+      auth, auth_name, set_list, clear_list, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(PP_CommandsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      PP_CommandsResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::PP_CommandsSync(const TPMI_RH_PLATFORM& auth,
+                            const std::string& auth_name,
+                            const TPML_CC& set_list,
+                            const TPML_CC& clear_list,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_PP_Commands(
+      auth, auth_name, set_list, clear_list, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_PP_Commands(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_SetAlgorithmSet(
+    const TPMI_RH_PLATFORM& auth_handle,
+    const std::string& auth_handle_name,
+    const UINT32& algorithm_set,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_SetAlgorithmSet;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string algorithm_set_bytes;
+  rc = Serialize_UINT32(algorithm_set, &algorithm_set_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(algorithm_set_bytes.data(), algorithm_set_bytes.size());
+  parameter_section_bytes += algorithm_set_bytes;
+  command_size += algorithm_set_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_SetAlgorithmSet(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_SetAlgorithmSet;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void SetAlgorithmSetErrorCallback(Tpm::SetAlgorithmSetResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void SetAlgorithmSetResponseParser(
+    Tpm::SetAlgorithmSetResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_SetAlgorithmSet(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SetAlgorithmSetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::SetAlgorithmSet(const TPMI_RH_PLATFORM& auth_handle,
+                          const std::string& auth_handle_name,
+                          const UINT32& algorithm_set,
+                          AuthorizationDelegate* authorization_delegate,
+                          SetAlgorithmSetResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetAlgorithmSet(auth_handle, auth_handle_name,
+                                               algorithm_set, &command,
+                                               authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(SetAlgorithmSetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(SetAlgorithmSetResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::SetAlgorithmSetSync(const TPMI_RH_PLATFORM& auth_handle,
+                                const std::string& auth_handle_name,
+                                const UINT32& algorithm_set,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_SetAlgorithmSet(auth_handle, auth_handle_name,
+                                               algorithm_set, &command,
+                                               authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_SetAlgorithmSet(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_FieldUpgradeStart(
+    const TPMI_RH_PLATFORM& authorization,
+    const std::string& authorization_name,
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_DIGEST& fu_digest,
+    const TPMT_SIGNATURE& manifest_signature,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_FieldUpgradeStart;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(authorization, &authorization_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string key_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(key_handle, &key_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string fu_digest_bytes;
+  rc = Serialize_TPM2B_DIGEST(fu_digest, &fu_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string manifest_signature_bytes;
+  rc = Serialize_TPMT_SIGNATURE(manifest_signature, &manifest_signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = fu_digest_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    fu_digest_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(authorization_name.data(), authorization_name.size());
+  handle_section_bytes += authorization_bytes;
+  command_size += authorization_bytes.size();
+  hash->Update(key_handle_name.data(), key_handle_name.size());
+  handle_section_bytes += key_handle_bytes;
+  command_size += key_handle_bytes.size();
+  hash->Update(fu_digest_bytes.data(), fu_digest_bytes.size());
+  parameter_section_bytes += fu_digest_bytes;
+  command_size += fu_digest_bytes.size();
+  hash->Update(manifest_signature_bytes.data(),
+               manifest_signature_bytes.size());
+  parameter_section_bytes += manifest_signature_bytes;
+  command_size += manifest_signature_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_FieldUpgradeStart(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_FieldUpgradeStart;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void FieldUpgradeStartErrorCallback(Tpm::FieldUpgradeStartResponse callback,
+                                    TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void FieldUpgradeStartResponseParser(
+    Tpm::FieldUpgradeStartResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_FieldUpgradeStart(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FieldUpgradeStartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::FieldUpgradeStart(const TPMI_RH_PLATFORM& authorization,
+                            const std::string& authorization_name,
+                            const TPMI_DH_OBJECT& key_handle,
+                            const std::string& key_handle_name,
+                            const TPM2B_DIGEST& fu_digest,
+                            const TPMT_SIGNATURE& manifest_signature,
+                            AuthorizationDelegate* authorization_delegate,
+                            FieldUpgradeStartResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FieldUpgradeStart(
+      authorization, authorization_name, key_handle, key_handle_name, fu_digest,
+      manifest_signature, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FieldUpgradeStartErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(FieldUpgradeStartResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::FieldUpgradeStartSync(
+    const TPMI_RH_PLATFORM& authorization,
+    const std::string& authorization_name,
+    const TPMI_DH_OBJECT& key_handle,
+    const std::string& key_handle_name,
+    const TPM2B_DIGEST& fu_digest,
+    const TPMT_SIGNATURE& manifest_signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FieldUpgradeStart(
+      authorization, authorization_name, key_handle, key_handle_name, fu_digest,
+      manifest_signature, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_FieldUpgradeStart(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_FieldUpgradeData(
+    const TPM2B_MAX_BUFFER& fu_data,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_FieldUpgradeData;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string fu_data_bytes;
+  rc = Serialize_TPM2B_MAX_BUFFER(fu_data, &fu_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = fu_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    fu_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(fu_data_bytes.data(), fu_data_bytes.size());
+  parameter_section_bytes += fu_data_bytes;
+  command_size += fu_data_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_FieldUpgradeData(
+    const std::string& response,
+    TPMT_HA* next_digest,
+    TPMT_HA* first_digest,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_FieldUpgradeData;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string next_digest_bytes;
+  rc = Parse_TPMT_HA(&buffer, next_digest, &next_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string first_digest_bytes;
+  rc = Parse_TPMT_HA(&buffer, first_digest, &first_digest_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void FieldUpgradeDataErrorCallback(Tpm::FieldUpgradeDataResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMT_HA(), TPMT_HA());
+}
+
+void FieldUpgradeDataResponseParser(
+    Tpm::FieldUpgradeDataResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPMT_HA next_digest;
+  TPMT_HA first_digest;
+  TPM_RC rc = Tpm::ParseResponse_FieldUpgradeData(
+      response, &next_digest, &first_digest, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FieldUpgradeDataErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, next_digest, first_digest);
+}
+
+void Tpm::FieldUpgradeData(const TPM2B_MAX_BUFFER& fu_data,
+                           AuthorizationDelegate* authorization_delegate,
+                           FieldUpgradeDataResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FieldUpgradeData(fu_data, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FieldUpgradeDataErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(FieldUpgradeDataResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::FieldUpgradeDataSync(
+    const TPM2B_MAX_BUFFER& fu_data,
+    TPMT_HA* next_digest,
+    TPMT_HA* first_digest,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FieldUpgradeData(fu_data, &command,
+                                                authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_FieldUpgradeData(response, next_digest, first_digest,
+                                      authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_FirmwareRead(
+    const UINT32& sequence_number,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_FirmwareRead;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sequence_number_bytes;
+  rc = Serialize_UINT32(sequence_number, &sequence_number_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sequence_number_bytes.data(), sequence_number_bytes.size());
+  parameter_section_bytes += sequence_number_bytes;
+  command_size += sequence_number_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_FirmwareRead(
+    const std::string& response,
+    TPM2B_MAX_BUFFER* fu_data,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_FirmwareRead;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string fu_data_bytes;
+  rc = Parse_TPM2B_MAX_BUFFER(&buffer, fu_data, &fu_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void FirmwareReadErrorCallback(Tpm::FirmwareReadResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_MAX_BUFFER());
+}
+
+void FirmwareReadResponseParser(Tpm::FirmwareReadResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_MAX_BUFFER fu_data;
+  TPM_RC rc = Tpm::ParseResponse_FirmwareRead(response, &fu_data,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FirmwareReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, fu_data);
+}
+
+void Tpm::FirmwareRead(const UINT32& sequence_number,
+                       AuthorizationDelegate* authorization_delegate,
+                       FirmwareReadResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FirmwareRead(sequence_number, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FirmwareReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      FirmwareReadResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::FirmwareReadSync(const UINT32& sequence_number,
+                             TPM2B_MAX_BUFFER* fu_data,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FirmwareRead(sequence_number, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_FirmwareRead(response, fu_data, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ContextSave(
+    const TPMI_DH_CONTEXT& save_handle,
+    const std::string& save_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ContextSave;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string save_handle_bytes;
+  rc = Serialize_TPMI_DH_CONTEXT(save_handle, &save_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(save_handle_name.data(), save_handle_name.size());
+  handle_section_bytes += save_handle_bytes;
+  command_size += save_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ContextSave(
+    const std::string& response,
+    TPMS_CONTEXT* context,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ContextSave;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string context_bytes;
+  rc = Parse_TPMS_CONTEXT(&buffer, context, &context_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ContextSaveErrorCallback(Tpm::ContextSaveResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMS_CONTEXT());
+}
+
+void ContextSaveResponseParser(Tpm::ContextSaveResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPMS_CONTEXT context;
+  TPM_RC rc = Tpm::ParseResponse_ContextSave(response, &context,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ContextSaveErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, context);
+}
+
+void Tpm::ContextSave(const TPMI_DH_CONTEXT& save_handle,
+                      const std::string& save_handle_name,
+                      AuthorizationDelegate* authorization_delegate,
+                      ContextSaveResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ContextSave(save_handle, save_handle_name,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ContextSaveErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ContextSaveResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ContextSaveSync(const TPMI_DH_CONTEXT& save_handle,
+                            const std::string& save_handle_name,
+                            TPMS_CONTEXT* context,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ContextSave(save_handle, save_handle_name,
+                                           &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ContextSave(response, context, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ContextLoad(
+    const TPMS_CONTEXT& context,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ContextLoad;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string context_bytes;
+  rc = Serialize_TPMS_CONTEXT(context, &context_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(context_bytes.data(), context_bytes.size());
+  parameter_section_bytes += context_bytes;
+  command_size += context_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ContextLoad(
+    const std::string& response,
+    TPMI_DH_CONTEXT* loaded_handle,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  std::string loaded_handle_bytes;
+  rc = Parse_TPMI_DH_CONTEXT(&buffer, loaded_handle, &loaded_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_CC command_code = TPM_CC_ContextLoad;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ContextLoadErrorCallback(Tpm::ContextLoadResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_DH_CONTEXT());
+}
+
+void ContextLoadResponseParser(Tpm::ContextLoadResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_DH_CONTEXT loaded_handle;
+  TPM_RC rc = Tpm::ParseResponse_ContextLoad(response, &loaded_handle,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ContextLoadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, loaded_handle);
+}
+
+void Tpm::ContextLoad(const TPMS_CONTEXT& context,
+                      AuthorizationDelegate* authorization_delegate,
+                      ContextLoadResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_ContextLoad(context, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ContextLoadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ContextLoadResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ContextLoadSync(const TPMS_CONTEXT& context,
+                            TPMI_DH_CONTEXT* loaded_handle,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_ContextLoad(context, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ContextLoad(response, loaded_handle,
+                                 authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_FlushContext(
+    const TPMI_DH_CONTEXT& flush_handle,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_FlushContext;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string flush_handle_bytes;
+  rc = Serialize_TPMI_DH_CONTEXT(flush_handle, &flush_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(flush_handle_bytes.data(), flush_handle_bytes.size());
+  parameter_section_bytes += flush_handle_bytes;
+  command_size += flush_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_FlushContext(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_FlushContext;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void FlushContextErrorCallback(Tpm::FlushContextResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void FlushContextResponseParser(Tpm::FlushContextResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_FlushContext(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FlushContextErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::FlushContext(const TPMI_DH_CONTEXT& flush_handle,
+                       AuthorizationDelegate* authorization_delegate,
+                       FlushContextResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FlushContext(flush_handle, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(FlushContextErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      FlushContextResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::FlushContextSync(const TPMI_DH_CONTEXT& flush_handle,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_FlushContext(flush_handle, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_FlushContext(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_EvictControl(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const TPMI_DH_OBJECT& object_handle,
+    const std::string& object_handle_name,
+    const TPMI_DH_PERSISTENT& persistent_handle,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_EvictControl;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string object_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(object_handle, &object_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string persistent_handle_bytes;
+  rc =
+      Serialize_TPMI_DH_PERSISTENT(persistent_handle, &persistent_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(object_handle_name.data(), object_handle_name.size());
+  handle_section_bytes += object_handle_bytes;
+  command_size += object_handle_bytes.size();
+  hash->Update(persistent_handle_bytes.data(), persistent_handle_bytes.size());
+  parameter_section_bytes += persistent_handle_bytes;
+  command_size += persistent_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_EvictControl(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_EvictControl;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void EvictControlErrorCallback(Tpm::EvictControlResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void EvictControlResponseParser(Tpm::EvictControlResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_EvictControl(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EvictControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::EvictControl(const TPMI_RH_PROVISION& auth,
+                       const std::string& auth_name,
+                       const TPMI_DH_OBJECT& object_handle,
+                       const std::string& object_handle_name,
+                       const TPMI_DH_PERSISTENT& persistent_handle,
+                       AuthorizationDelegate* authorization_delegate,
+                       EvictControlResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EvictControl(
+      auth, auth_name, object_handle, object_handle_name, persistent_handle,
+      &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(EvictControlErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      EvictControlResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::EvictControlSync(const TPMI_RH_PROVISION& auth,
+                             const std::string& auth_name,
+                             const TPMI_DH_OBJECT& object_handle,
+                             const std::string& object_handle_name,
+                             const TPMI_DH_PERSISTENT& persistent_handle,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_EvictControl(
+      auth, auth_name, object_handle, object_handle_name, persistent_handle,
+      &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_EvictControl(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ReadClock(
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ReadClock;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ReadClock(
+    const std::string& response,
+    TPMS_TIME_INFO* current_time,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ReadClock;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string current_time_bytes;
+  rc = Parse_TPMS_TIME_INFO(&buffer, current_time, &current_time_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ReadClockErrorCallback(Tpm::ReadClockResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMS_TIME_INFO());
+}
+
+void ReadClockResponseParser(Tpm::ReadClockResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPMS_TIME_INFO current_time;
+  TPM_RC rc = Tpm::ParseResponse_ReadClock(response, &current_time,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ReadClockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, current_time);
+}
+
+void Tpm::ReadClock(AuthorizationDelegate* authorization_delegate,
+                    ReadClockResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ReadClock(&command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ReadClockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ReadClockResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ReadClockSync(TPMS_TIME_INFO* current_time,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ReadClock(&command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ReadClock(response, current_time, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ClockSet(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const UINT64& new_time,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ClockSet;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_time_bytes;
+  rc = Serialize_UINT64(new_time, &new_time_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(new_time_bytes.data(), new_time_bytes.size());
+  parameter_section_bytes += new_time_bytes;
+  command_size += new_time_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ClockSet(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ClockSet;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ClockSetErrorCallback(Tpm::ClockSetResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ClockSetResponseParser(Tpm::ClockSetResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_ClockSet(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClockSetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::ClockSet(const TPMI_RH_PROVISION& auth,
+                   const std::string& auth_name,
+                   const UINT64& new_time,
+                   AuthorizationDelegate* authorization_delegate,
+                   ClockSetResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClockSet(auth, auth_name, new_time, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClockSetErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      ClockSetResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ClockSetSync(const TPMI_RH_PROVISION& auth,
+                         const std::string& auth_name,
+                         const UINT64& new_time,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClockSet(auth, auth_name, new_time, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ClockSet(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_ClockRateAdjust(
+    const TPMI_RH_PROVISION& auth,
+    const std::string& auth_name,
+    const TPM_CLOCK_ADJUST& rate_adjust,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_ClockRateAdjust;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string rate_adjust_bytes;
+  rc = Serialize_TPM_CLOCK_ADJUST(rate_adjust, &rate_adjust_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_name.data(), auth_name.size());
+  handle_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(rate_adjust_bytes.data(), rate_adjust_bytes.size());
+  parameter_section_bytes += rate_adjust_bytes;
+  command_size += rate_adjust_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_ClockRateAdjust(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_ClockRateAdjust;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void ClockRateAdjustErrorCallback(Tpm::ClockRateAdjustResponse callback,
+                                  TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void ClockRateAdjustResponseParser(
+    Tpm::ClockRateAdjustResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_ClockRateAdjust(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClockRateAdjustErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::ClockRateAdjust(const TPMI_RH_PROVISION& auth,
+                          const std::string& auth_name,
+                          const TPM_CLOCK_ADJUST& rate_adjust,
+                          AuthorizationDelegate* authorization_delegate,
+                          ClockRateAdjustResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClockRateAdjust(
+      auth, auth_name, rate_adjust, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(ClockRateAdjustErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(ClockRateAdjustResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::ClockRateAdjustSync(const TPMI_RH_PROVISION& auth,
+                                const std::string& auth_name,
+                                const TPM_CLOCK_ADJUST& rate_adjust,
+                                AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_ClockRateAdjust(
+      auth, auth_name, rate_adjust, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_ClockRateAdjust(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_GetCapability(
+    const TPM_CAP& capability,
+    const UINT32& property,
+    const UINT32& property_count,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_GetCapability;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string capability_bytes;
+  rc = Serialize_TPM_CAP(capability, &capability_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string property_bytes;
+  rc = Serialize_UINT32(property, &property_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string property_count_bytes;
+  rc = Serialize_UINT32(property_count, &property_count_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(capability_bytes.data(), capability_bytes.size());
+  parameter_section_bytes += capability_bytes;
+  command_size += capability_bytes.size();
+  hash->Update(property_bytes.data(), property_bytes.size());
+  parameter_section_bytes += property_bytes;
+  command_size += property_bytes.size();
+  hash->Update(property_count_bytes.data(), property_count_bytes.size());
+  parameter_section_bytes += property_count_bytes;
+  command_size += property_count_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_GetCapability(
+    const std::string& response,
+    TPMI_YES_NO* more_data,
+    TPMS_CAPABILITY_DATA* capability_data,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_GetCapability;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  std::string more_data_bytes;
+  rc = Parse_TPMI_YES_NO(&buffer, more_data, &more_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string capability_data_bytes;
+  rc = Parse_TPMS_CAPABILITY_DATA(&buffer, capability_data,
+                                  &capability_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void GetCapabilityErrorCallback(Tpm::GetCapabilityResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPMI_YES_NO(), TPMS_CAPABILITY_DATA());
+}
+
+void GetCapabilityResponseParser(Tpm::GetCapabilityResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPMI_YES_NO more_data;
+  TPMS_CAPABILITY_DATA capability_data;
+  TPM_RC rc = Tpm::ParseResponse_GetCapability(
+      response, &more_data, &capability_data, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetCapabilityErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, more_data, capability_data);
+}
+
+void Tpm::GetCapability(const TPM_CAP& capability,
+                        const UINT32& property,
+                        const UINT32& property_count,
+                        AuthorizationDelegate* authorization_delegate,
+                        GetCapabilityResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetCapability(
+      capability, property, property_count, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(GetCapabilityErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      GetCapabilityResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::GetCapabilitySync(const TPM_CAP& capability,
+                              const UINT32& property,
+                              const UINT32& property_count,
+                              TPMI_YES_NO* more_data,
+                              TPMS_CAPABILITY_DATA* capability_data,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_GetCapability(
+      capability, property, property_count, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_GetCapability(response, more_data, capability_data,
+                                   authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_TestParms(
+    const TPMT_PUBLIC_PARMS& parameters,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_TestParms;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string parameters_bytes;
+  rc = Serialize_TPMT_PUBLIC_PARMS(parameters, &parameters_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(parameters_bytes.data(), parameters_bytes.size());
+  parameter_section_bytes += parameters_bytes;
+  command_size += parameters_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_TestParms(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_TestParms;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void TestParmsErrorCallback(Tpm::TestParmsResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void TestParmsResponseParser(Tpm::TestParmsResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_TestParms(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(TestParmsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::TestParms(const TPMT_PUBLIC_PARMS& parameters,
+                    AuthorizationDelegate* authorization_delegate,
+                    TestParmsResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_TestParms(parameters, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(TestParmsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      TestParmsResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::TestParmsSync(const TPMT_PUBLIC_PARMS& parameters,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc =
+      SerializeCommand_TestParms(parameters, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_TestParms(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_DefineSpace(
+    const TPMI_RH_PROVISION& auth_handle,
+    const std::string& auth_handle_name,
+    const TPM2B_AUTH& auth,
+    const TPM2B_NV_PUBLIC& public_info,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_DefineSpace;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_bytes;
+  rc = Serialize_TPM2B_AUTH(auth, &auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string public_info_bytes;
+  rc = Serialize_TPM2B_NV_PUBLIC(public_info, &public_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(auth_bytes.data(), auth_bytes.size());
+  parameter_section_bytes += auth_bytes;
+  command_size += auth_bytes.size();
+  hash->Update(public_info_bytes.data(), public_info_bytes.size());
+  parameter_section_bytes += public_info_bytes;
+  command_size += public_info_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_DefineSpace(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_DefineSpace;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_DefineSpaceErrorCallback(Tpm::NV_DefineSpaceResponse callback,
+                                 TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_DefineSpaceResponseParser(Tpm::NV_DefineSpaceResponse callback,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_NV_DefineSpace(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_DefineSpaceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_DefineSpace(const TPMI_RH_PROVISION& auth_handle,
+                         const std::string& auth_handle_name,
+                         const TPM2B_AUTH& auth,
+                         const TPM2B_NV_PUBLIC& public_info,
+                         AuthorizationDelegate* authorization_delegate,
+                         NV_DefineSpaceResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_DefineSpace(auth_handle, auth_handle_name,
+                                              auth, public_info, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_DefineSpaceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(NV_DefineSpaceResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_DefineSpaceSync(const TPMI_RH_PROVISION& auth_handle,
+                               const std::string& auth_handle_name,
+                               const TPM2B_AUTH& auth,
+                               const TPM2B_NV_PUBLIC& public_info,
+                               AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_DefineSpace(auth_handle, auth_handle_name,
+                                              auth, public_info, &command,
+                                              authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_DefineSpace(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_UndefineSpace(
+    const TPMI_RH_PROVISION& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_UndefineSpace;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_UndefineSpace(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_UndefineSpace;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_UndefineSpaceErrorCallback(Tpm::NV_UndefineSpaceResponse callback,
+                                   TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_UndefineSpaceResponseParser(
+    Tpm::NV_UndefineSpaceResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_NV_UndefineSpace(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_UndefineSpaceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_UndefineSpace(const TPMI_RH_PROVISION& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPMI_RH_NV_INDEX& nv_index,
+                           const std::string& nv_index_name,
+                           AuthorizationDelegate* authorization_delegate,
+                           NV_UndefineSpaceResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_UndefineSpace(
+      auth_handle, auth_handle_name, nv_index, nv_index_name, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_UndefineSpaceErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(NV_UndefineSpaceResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_UndefineSpaceSync(
+    const TPMI_RH_PROVISION& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_UndefineSpace(
+      auth_handle, auth_handle_name, nv_index, nv_index_name, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_UndefineSpace(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_UndefineSpaceSpecial(
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPMI_RH_PLATFORM& platform,
+    const std::string& platform_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_UndefineSpaceSpecial;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string platform_bytes;
+  rc = Serialize_TPMI_RH_PLATFORM(platform, &platform_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(platform_name.data(), platform_name.size());
+  handle_section_bytes += platform_bytes;
+  command_size += platform_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_UndefineSpaceSpecial(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_UndefineSpaceSpecial;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_UndefineSpaceSpecialErrorCallback(
+    Tpm::NV_UndefineSpaceSpecialResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_UndefineSpaceSpecialResponseParser(
+    Tpm::NV_UndefineSpaceSpecialResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_UndefineSpaceSpecial(
+      response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        NV_UndefineSpaceSpecialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_UndefineSpaceSpecial(const TPMI_RH_NV_INDEX& nv_index,
+                                  const std::string& nv_index_name,
+                                  const TPMI_RH_PLATFORM& platform,
+                                  const std::string& platform_name,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  NV_UndefineSpaceSpecialResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_UndefineSpaceSpecial(
+      nv_index, nv_index_name, platform, platform_name, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter = base::BindOnce(
+        NV_UndefineSpaceSpecialErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(NV_UndefineSpaceSpecialResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_UndefineSpaceSpecialSync(
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPMI_RH_PLATFORM& platform,
+    const std::string& platform_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_UndefineSpaceSpecial(
+      nv_index, nv_index_name, platform, platform_name, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_UndefineSpaceSpecial(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_ReadPublic(
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_ReadPublic;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_ReadPublic(
+    const std::string& response,
+    TPM2B_NV_PUBLIC* nv_public,
+    TPM2B_NAME* nv_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_ReadPublic;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string nv_public_bytes;
+  rc = Parse_TPM2B_NV_PUBLIC(&buffer, nv_public, &nv_public_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_name_bytes;
+  rc = Parse_TPM2B_NAME(&buffer, nv_name, &nv_name_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_ReadPublicErrorCallback(Tpm::NV_ReadPublicResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_NV_PUBLIC(), TPM2B_NAME());
+}
+
+void NV_ReadPublicResponseParser(Tpm::NV_ReadPublicResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_NV_PUBLIC nv_public;
+  TPM2B_NAME nv_name;
+  TPM_RC rc = Tpm::ParseResponse_NV_ReadPublic(response, &nv_public, &nv_name,
+                                               authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadPublicErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, nv_public, nv_name);
+}
+
+void Tpm::NV_ReadPublic(const TPMI_RH_NV_INDEX& nv_index,
+                        const std::string& nv_index_name,
+                        AuthorizationDelegate* authorization_delegate,
+                        NV_ReadPublicResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ReadPublic(nv_index, nv_index_name, &command,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadPublicErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_ReadPublicResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_ReadPublicSync(const TPMI_RH_NV_INDEX& nv_index,
+                              const std::string& nv_index_name,
+                              TPM2B_NV_PUBLIC* nv_public,
+                              TPM2B_NAME* nv_name,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ReadPublic(nv_index, nv_index_name, &command,
+                                             authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_ReadPublic(response, nv_public, nv_name,
+                                   authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_Write(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPM2B_MAX_NV_BUFFER& data,
+    const UINT16& offset,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_Write;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string data_bytes;
+  rc = Serialize_TPM2B_MAX_NV_BUFFER(data, &data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string offset_bytes;
+  rc = Serialize_UINT16(offset, &offset_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(data_bytes.data(), data_bytes.size());
+  parameter_section_bytes += data_bytes;
+  command_size += data_bytes.size();
+  hash->Update(offset_bytes.data(), offset_bytes.size());
+  parameter_section_bytes += offset_bytes;
+  command_size += offset_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_Write(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_Write;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_WriteErrorCallback(Tpm::NV_WriteResponse callback,
+                           TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_WriteResponseParser(Tpm::NV_WriteResponse callback,
+                            AuthorizationDelegate* authorization_delegate,
+                            const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_Write(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_WriteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_Write(const TPMI_RH_NV_AUTH& auth_handle,
+                   const std::string& auth_handle_name,
+                   const TPMI_RH_NV_INDEX& nv_index,
+                   const std::string& nv_index_name,
+                   const TPM2B_MAX_NV_BUFFER& data,
+                   const UINT16& offset,
+                   AuthorizationDelegate* authorization_delegate,
+                   NV_WriteResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Write(auth_handle, auth_handle_name, nv_index,
+                                        nv_index_name, data, offset, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_WriteErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_WriteResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_WriteSync(const TPMI_RH_NV_AUTH& auth_handle,
+                         const std::string& auth_handle_name,
+                         const TPMI_RH_NV_INDEX& nv_index,
+                         const std::string& nv_index_name,
+                         const TPM2B_MAX_NV_BUFFER& data,
+                         const UINT16& offset,
+                         AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Write(auth_handle, auth_handle_name, nv_index,
+                                        nv_index_name, data, offset, &command,
+                                        authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_Write(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_Increment(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_Increment;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_Increment(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_Increment;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_IncrementErrorCallback(Tpm::NV_IncrementResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_IncrementResponseParser(Tpm::NV_IncrementResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_Increment(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_IncrementErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_Increment(const TPMI_RH_NV_AUTH& auth_handle,
+                       const std::string& auth_handle_name,
+                       const TPMI_RH_NV_INDEX& nv_index,
+                       const std::string& nv_index_name,
+                       AuthorizationDelegate* authorization_delegate,
+                       NV_IncrementResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Increment(auth_handle, auth_handle_name,
+                                            nv_index, nv_index_name, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_IncrementErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_IncrementResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_IncrementSync(const TPMI_RH_NV_AUTH& auth_handle,
+                             const std::string& auth_handle_name,
+                             const TPMI_RH_NV_INDEX& nv_index,
+                             const std::string& nv_index_name,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Increment(auth_handle, auth_handle_name,
+                                            nv_index, nv_index_name, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_Increment(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_Extend(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPM2B_MAX_NV_BUFFER& data,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_Extend;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string data_bytes;
+  rc = Serialize_TPM2B_MAX_NV_BUFFER(data, &data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(data_bytes.data(), data_bytes.size());
+  parameter_section_bytes += data_bytes;
+  command_size += data_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_Extend(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_Extend;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_ExtendErrorCallback(Tpm::NV_ExtendResponse callback,
+                            TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_ExtendResponseParser(Tpm::NV_ExtendResponse callback,
+                             AuthorizationDelegate* authorization_delegate,
+                             const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_Extend(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ExtendErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_Extend(const TPMI_RH_NV_AUTH& auth_handle,
+                    const std::string& auth_handle_name,
+                    const TPMI_RH_NV_INDEX& nv_index,
+                    const std::string& nv_index_name,
+                    const TPM2B_MAX_NV_BUFFER& data,
+                    AuthorizationDelegate* authorization_delegate,
+                    NV_ExtendResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Extend(auth_handle, auth_handle_name,
+                                         nv_index, nv_index_name, data,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ExtendErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_ExtendResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_ExtendSync(const TPMI_RH_NV_AUTH& auth_handle,
+                          const std::string& auth_handle_name,
+                          const TPMI_RH_NV_INDEX& nv_index,
+                          const std::string& nv_index_name,
+                          const TPM2B_MAX_NV_BUFFER& data,
+                          AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Extend(auth_handle, auth_handle_name,
+                                         nv_index, nv_index_name, data,
+                                         &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_Extend(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_SetBits(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const UINT64& bits,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_SetBits;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string bits_bytes;
+  rc = Serialize_UINT64(bits, &bits_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(bits_bytes.data(), bits_bytes.size());
+  parameter_section_bytes += bits_bytes;
+  command_size += bits_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_SetBits(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_SetBits;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_SetBitsErrorCallback(Tpm::NV_SetBitsResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_SetBitsResponseParser(Tpm::NV_SetBitsResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_SetBits(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_SetBitsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_SetBits(const TPMI_RH_NV_AUTH& auth_handle,
+                     const std::string& auth_handle_name,
+                     const TPMI_RH_NV_INDEX& nv_index,
+                     const std::string& nv_index_name,
+                     const UINT64& bits,
+                     AuthorizationDelegate* authorization_delegate,
+                     NV_SetBitsResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_SetBits(auth_handle, auth_handle_name,
+                                          nv_index, nv_index_name, bits,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_SetBitsErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_SetBitsResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_SetBitsSync(const TPMI_RH_NV_AUTH& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPMI_RH_NV_INDEX& nv_index,
+                           const std::string& nv_index_name,
+                           const UINT64& bits,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_SetBits(auth_handle, auth_handle_name,
+                                          nv_index, nv_index_name, bits,
+                                          &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_SetBits(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_WriteLock(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_WriteLock;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_WriteLock(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_WriteLock;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_WriteLockErrorCallback(Tpm::NV_WriteLockResponse callback,
+                               TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_WriteLockResponseParser(Tpm::NV_WriteLockResponse callback,
+                                AuthorizationDelegate* authorization_delegate,
+                                const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_WriteLock(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_WriteLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_WriteLock(const TPMI_RH_NV_AUTH& auth_handle,
+                       const std::string& auth_handle_name,
+                       const TPMI_RH_NV_INDEX& nv_index,
+                       const std::string& nv_index_name,
+                       AuthorizationDelegate* authorization_delegate,
+                       NV_WriteLockResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_WriteLock(auth_handle, auth_handle_name,
+                                            nv_index, nv_index_name, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_WriteLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_WriteLockResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_WriteLockSync(const TPMI_RH_NV_AUTH& auth_handle,
+                             const std::string& auth_handle_name,
+                             const TPMI_RH_NV_INDEX& nv_index,
+                             const std::string& nv_index_name,
+                             AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_WriteLock(auth_handle, auth_handle_name,
+                                            nv_index, nv_index_name, &command,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_WriteLock(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_GlobalWriteLock(
+    const TPMI_RH_PROVISION& auth_handle,
+    const std::string& auth_handle_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_GlobalWriteLock;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_PROVISION(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_GlobalWriteLock(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_GlobalWriteLock;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_GlobalWriteLockErrorCallback(Tpm::NV_GlobalWriteLockResponse callback,
+                                     TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_GlobalWriteLockResponseParser(
+    Tpm::NV_GlobalWriteLockResponse callback,
+    AuthorizationDelegate* authorization_delegate,
+    const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_NV_GlobalWriteLock(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_GlobalWriteLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_GlobalWriteLock(const TPMI_RH_PROVISION& auth_handle,
+                             const std::string& auth_handle_name,
+                             AuthorizationDelegate* authorization_delegate,
+                             NV_GlobalWriteLockResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_GlobalWriteLock(
+      auth_handle, auth_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_GlobalWriteLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser =
+      base::BindOnce(NV_GlobalWriteLockResponseParser, std::move(callback),
+                     authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_GlobalWriteLockSync(
+    const TPMI_RH_PROVISION& auth_handle,
+    const std::string& auth_handle_name,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_GlobalWriteLock(
+      auth_handle, auth_handle_name, &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_GlobalWriteLock(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_Read(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const UINT16& size,
+    const UINT16& offset,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_Read;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string size_bytes;
+  rc = Serialize_UINT16(size, &size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string offset_bytes;
+  rc = Serialize_UINT16(offset, &offset_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(size_bytes.data(), size_bytes.size());
+  parameter_section_bytes += size_bytes;
+  command_size += size_bytes.size();
+  hash->Update(offset_bytes.data(), offset_bytes.size());
+  parameter_section_bytes += offset_bytes;
+  command_size += offset_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_Read(
+    const std::string& response,
+    TPM2B_MAX_NV_BUFFER* data,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_Read;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string data_bytes;
+  rc = Parse_TPM2B_MAX_NV_BUFFER(&buffer, data, &data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_ReadErrorCallback(Tpm::NV_ReadResponse callback, TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_MAX_NV_BUFFER());
+}
+
+void NV_ReadResponseParser(Tpm::NV_ReadResponse callback,
+                           AuthorizationDelegate* authorization_delegate,
+                           const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_MAX_NV_BUFFER data;
+  TPM_RC rc =
+      Tpm::ParseResponse_NV_Read(response, &data, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, data);
+}
+
+void Tpm::NV_Read(const TPMI_RH_NV_AUTH& auth_handle,
+                  const std::string& auth_handle_name,
+                  const TPMI_RH_NV_INDEX& nv_index,
+                  const std::string& nv_index_name,
+                  const UINT16& size,
+                  const UINT16& offset,
+                  AuthorizationDelegate* authorization_delegate,
+                  NV_ReadResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Read(auth_handle, auth_handle_name, nv_index,
+                                       nv_index_name, size, offset, &command,
+                                       authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_ReadResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_ReadSync(const TPMI_RH_NV_AUTH& auth_handle,
+                        const std::string& auth_handle_name,
+                        const TPMI_RH_NV_INDEX& nv_index,
+                        const std::string& nv_index_name,
+                        const UINT16& size,
+                        const UINT16& offset,
+                        TPM2B_MAX_NV_BUFFER* data,
+                        AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Read(auth_handle, auth_handle_name, nv_index,
+                                       nv_index_name, size, offset, &command,
+                                       authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_Read(response, data, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_ReadLock(
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_ReadLock;
+  bool is_command_parameter_encryption_possible = false;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_ReadLock(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_ReadLock;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_ReadLockErrorCallback(Tpm::NV_ReadLockResponse callback,
+                              TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_ReadLockResponseParser(Tpm::NV_ReadLockResponse callback,
+                               AuthorizationDelegate* authorization_delegate,
+                               const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc = Tpm::ParseResponse_NV_ReadLock(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_ReadLock(const TPMI_RH_NV_AUTH& auth_handle,
+                      const std::string& auth_handle_name,
+                      const TPMI_RH_NV_INDEX& nv_index,
+                      const std::string& nv_index_name,
+                      AuthorizationDelegate* authorization_delegate,
+                      NV_ReadLockResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ReadLock(auth_handle, auth_handle_name,
+                                           nv_index, nv_index_name, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ReadLockErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_ReadLockResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_ReadLockSync(const TPMI_RH_NV_AUTH& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPMI_RH_NV_INDEX& nv_index,
+                            const std::string& nv_index_name,
+                            AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ReadLock(auth_handle, auth_handle_name,
+                                           nv_index, nv_index_name, &command,
+                                           authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_ReadLock(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_ChangeAuth(
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPM2B_AUTH& new_auth,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_ChangeAuth;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = false;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string new_auth_bytes;
+  rc = Serialize_TPM2B_AUTH(new_auth, &new_auth_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = new_auth_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    new_auth_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(new_auth_bytes.data(), new_auth_bytes.size());
+  parameter_section_bytes += new_auth_bytes;
+  command_size += new_auth_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_ChangeAuth(
+    const std::string& response,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_ChangeAuth;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_ChangeAuthErrorCallback(Tpm::NV_ChangeAuthResponse callback,
+                                TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code);
+}
+
+void NV_ChangeAuthResponseParser(Tpm::NV_ChangeAuthResponse callback,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 const std::string& response) {
+  VLOG(1) << __func__;
+  TPM_RC rc =
+      Tpm::ParseResponse_NV_ChangeAuth(response, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc);
+}
+
+void Tpm::NV_ChangeAuth(const TPMI_RH_NV_INDEX& nv_index,
+                        const std::string& nv_index_name,
+                        const TPM2B_AUTH& new_auth,
+                        AuthorizationDelegate* authorization_delegate,
+                        NV_ChangeAuthResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ChangeAuth(nv_index, nv_index_name, new_auth,
+                                             &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_ChangeAuthErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_ChangeAuthResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_ChangeAuthSync(const TPMI_RH_NV_INDEX& nv_index,
+                              const std::string& nv_index_name,
+                              const TPM2B_AUTH& new_auth,
+                              AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_ChangeAuth(nv_index, nv_index_name, new_auth,
+                                             &command, authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_ChangeAuth(response, authorization_delegate);
+  return rc;
+}
+
+TPM_RC Tpm::SerializeCommand_NV_Certify(
+    const TPMI_DH_OBJECT& sign_handle,
+    const std::string& sign_handle_name,
+    const TPMI_RH_NV_AUTH& auth_handle,
+    const std::string& auth_handle_name,
+    const TPMI_RH_NV_INDEX& nv_index,
+    const std::string& nv_index_name,
+    const TPM2B_DATA& qualifying_data,
+    const TPMT_SIG_SCHEME& in_scheme,
+    const UINT16& size,
+    const UINT16& offset,
+    std::string* serialized_command,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  TPM_RC rc = TPM_RC_SUCCESS;
+  TPMI_ST_COMMAND_TAG tag = TPM_ST_NO_SESSIONS;
+  UINT32 command_size = 10;  // Header size.
+  std::string handle_section_bytes;
+  std::string parameter_section_bytes;
+  TPM_CC command_code = TPM_CC_NV_Certify;
+  bool is_command_parameter_encryption_possible = true;
+  bool is_response_parameter_encryption_possible = true;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string sign_handle_bytes;
+  rc = Serialize_TPMI_DH_OBJECT(sign_handle, &sign_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string auth_handle_bytes;
+  rc = Serialize_TPMI_RH_NV_AUTH(auth_handle, &auth_handle_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string nv_index_bytes;
+  rc = Serialize_TPMI_RH_NV_INDEX(nv_index, &nv_index_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string qualifying_data_bytes;
+  rc = Serialize_TPM2B_DATA(qualifying_data, &qualifying_data_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string in_scheme_bytes;
+  rc = Serialize_TPMT_SIG_SCHEME(in_scheme, &in_scheme_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string size_bytes;
+  rc = Serialize_UINT16(size, &size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string offset_bytes;
+  rc = Serialize_UINT16(offset, &offset_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (authorization_delegate) {
+    // Encrypt just the parameter data, not the size.
+    std::string tmp = qualifying_data_bytes.substr(2);
+    if (!authorization_delegate->EncryptCommandParameter(&tmp)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    qualifying_data_bytes.replace(2, std::string::npos, tmp);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(sign_handle_name.data(), sign_handle_name.size());
+  handle_section_bytes += sign_handle_bytes;
+  command_size += sign_handle_bytes.size();
+  hash->Update(auth_handle_name.data(), auth_handle_name.size());
+  handle_section_bytes += auth_handle_bytes;
+  command_size += auth_handle_bytes.size();
+  hash->Update(nv_index_name.data(), nv_index_name.size());
+  handle_section_bytes += nv_index_bytes;
+  command_size += nv_index_bytes.size();
+  hash->Update(qualifying_data_bytes.data(), qualifying_data_bytes.size());
+  parameter_section_bytes += qualifying_data_bytes;
+  command_size += qualifying_data_bytes.size();
+  hash->Update(in_scheme_bytes.data(), in_scheme_bytes.size());
+  parameter_section_bytes += in_scheme_bytes;
+  command_size += in_scheme_bytes.size();
+  hash->Update(size_bytes.data(), size_bytes.size());
+  parameter_section_bytes += size_bytes;
+  command_size += size_bytes.size();
+  hash->Update(offset_bytes.data(), offset_bytes.size());
+  parameter_section_bytes += offset_bytes;
+  command_size += offset_bytes.size();
+  std::string command_hash(32, 0);
+  hash->Finish(std::data(command_hash), command_hash.size());
+  std::string authorization_section_bytes;
+  std::string authorization_size_bytes;
+  if (authorization_delegate) {
+    if (!authorization_delegate->GetCommandAuthorization(
+            command_hash, is_command_parameter_encryption_possible,
+            is_response_parameter_encryption_possible,
+            &authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+    if (!authorization_section_bytes.empty()) {
+      tag = TPM_ST_SESSIONS;
+      std::string tmp;
+      rc = Serialize_UINT32(authorization_section_bytes.size(),
+                            &authorization_size_bytes);
+      if (rc != TPM_RC_SUCCESS) {
+        return rc;
+      }
+      command_size +=
+          authorization_size_bytes.size() + authorization_section_bytes.size();
+    }
+  }
+  std::string tag_bytes;
+  rc = Serialize_TPMI_ST_COMMAND_TAG(tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string command_size_bytes;
+  rc = Serialize_UINT32(command_size, &command_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  *serialized_command = tag_bytes + command_size_bytes + command_code_bytes +
+                        handle_section_bytes + authorization_size_bytes +
+                        authorization_section_bytes + parameter_section_bytes;
+  CHECK(serialized_command->size() == command_size) << "Command size mismatch!";
+  VLOG(2) << "Command: "
+          << base::HexEncode(serialized_command->data(),
+                             serialized_command->size());
+  return TPM_RC_SUCCESS;
+}
+
+TPM_RC Tpm::ParseResponse_NV_Certify(
+    const std::string& response,
+    TPM2B_ATTEST* certify_info,
+    TPMT_SIGNATURE* signature,
+    AuthorizationDelegate* authorization_delegate) {
+  VLOG(3) << __func__;
+  VLOG(2) << "Response: " << base::HexEncode(response.data(), response.size());
+  TPM_RC rc = TPM_RC_SUCCESS;
+  std::string buffer(response);
+  TPM_ST tag;
+  std::string tag_bytes;
+  rc = Parse_TPM_ST(&buffer, &tag, &tag_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  UINT32 response_size;
+  std::string response_size_bytes;
+  rc = Parse_UINT32(&buffer, &response_size, &response_size_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  TPM_RC response_code;
+  std::string response_code_bytes;
+  rc = Parse_TPM_RC(&buffer, &response_code, &response_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  if (response_size != response.size()) {
+    return TPM_RC_SIZE;
+  }
+  if (response_code != TPM_RC_SUCCESS) {
+    return response_code;
+  }
+  TPM_CC command_code = TPM_CC_NV_Certify;
+  std::string command_code_bytes;
+  rc = Serialize_TPM_CC(command_code, &command_code_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string authorization_section_bytes;
+  if (tag == TPM_ST_SESSIONS) {
+    UINT32 parameter_section_size = buffer.size();
+    rc = Parse_UINT32(&buffer, &parameter_section_size, nullptr);
+    if (rc != TPM_RC_SUCCESS) {
+      return rc;
+    }
+    if (parameter_section_size > buffer.size()) {
+      return TPM_RC_INSUFFICIENT;
+    }
+    authorization_section_bytes = buffer.substr(parameter_section_size);
+    // Keep the parameter section in |buffer|.
+    buffer.erase(parameter_section_size);
+  }
+  std::unique_ptr<crypto::SecureHash> hash(
+      crypto::SecureHash::Create(crypto::SecureHash::SHA256));
+  hash->Update(response_code_bytes.data(), response_code_bytes.size());
+  hash->Update(command_code_bytes.data(), command_code_bytes.size());
+  hash->Update(buffer.data(), buffer.size());
+  std::string response_hash(32, 0);
+  hash->Finish(std::data(response_hash), response_hash.size());
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    if (!authorization_delegate->CheckResponseAuthorization(
+            response_hash, authorization_section_bytes)) {
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+    }
+  }
+  if (tag == TPM_ST_SESSIONS) {
+    if (!authorization_delegate)
+      return TRUNKS_RC_AUTHORIZATION_FAILED;
+
+    // Parse the encrypted parameter size.
+    UINT16 size;
+    std::string size_buffer = buffer.substr(0, 2);
+    if (TPM_RC result = Parse_UINT16(&size_buffer, &size, nullptr); result) {
+      return result;
+    }
+    if (buffer.size() < 2 + size) {
+      return TPM_RC_INSUFFICIENT;
+    }
+
+    // Decrypt just the parameter data, not the size.
+    std::string decrypted_data = buffer.substr(2, size);
+    if (!authorization_delegate->DecryptResponseParameter(&decrypted_data)) {
+      return TRUNKS_RC_ENCRYPTION_FAILED;
+    }
+    buffer.replace(2, size, decrypted_data);
+  }
+  std::string certify_info_bytes;
+  rc = Parse_TPM2B_ATTEST(&buffer, certify_info, &certify_info_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string signature_bytes;
+  rc = Parse_TPMT_SIGNATURE(&buffer, signature, &signature_bytes);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  return TPM_RC_SUCCESS;
+}
+
+void NV_CertifyErrorCallback(Tpm::NV_CertifyResponse callback,
+                             TPM_RC response_code) {
+  VLOG(1) << __func__;
+  std::move(callback).Run(response_code, TPM2B_ATTEST(), TPMT_SIGNATURE());
+}
+
+void NV_CertifyResponseParser(Tpm::NV_CertifyResponse callback,
+                              AuthorizationDelegate* authorization_delegate,
+                              const std::string& response) {
+  VLOG(1) << __func__;
+  TPM2B_ATTEST certify_info;
+  TPMT_SIGNATURE signature;
+  TPM_RC rc = Tpm::ParseResponse_NV_Certify(response, &certify_info, &signature,
+                                            authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_CertifyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  std::move(callback).Run(rc, certify_info, signature);
+}
+
+void Tpm::NV_Certify(const TPMI_DH_OBJECT& sign_handle,
+                     const std::string& sign_handle_name,
+                     const TPMI_RH_NV_AUTH& auth_handle,
+                     const std::string& auth_handle_name,
+                     const TPMI_RH_NV_INDEX& nv_index,
+                     const std::string& nv_index_name,
+                     const TPM2B_DATA& qualifying_data,
+                     const TPMT_SIG_SCHEME& in_scheme,
+                     const UINT16& size,
+                     const UINT16& offset,
+                     AuthorizationDelegate* authorization_delegate,
+                     NV_CertifyResponse callback) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Certify(
+      sign_handle, sign_handle_name, auth_handle, auth_handle_name, nv_index,
+      nv_index_name, qualifying_data, in_scheme, size, offset, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    base::OnceCallback<void(TPM_RC)> error_reporter =
+        base::BindOnce(NV_CertifyErrorCallback, std::move(callback));
+    std::move(error_reporter).Run(rc);
+    return;
+  }
+  base::OnceCallback<void(const std::string&)> parser = base::BindOnce(
+      NV_CertifyResponseParser, std::move(callback), authorization_delegate);
+  transceiver_->SendCommand(command, std::move(parser));
+}
+
+TPM_RC Tpm::NV_CertifySync(const TPMI_DH_OBJECT& sign_handle,
+                           const std::string& sign_handle_name,
+                           const TPMI_RH_NV_AUTH& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPMI_RH_NV_INDEX& nv_index,
+                           const std::string& nv_index_name,
+                           const TPM2B_DATA& qualifying_data,
+                           const TPMT_SIG_SCHEME& in_scheme,
+                           const UINT16& size,
+                           const UINT16& offset,
+                           TPM2B_ATTEST* certify_info,
+                           TPMT_SIGNATURE* signature,
+                           AuthorizationDelegate* authorization_delegate) {
+  VLOG(1) << __func__;
+  std::string command;
+  TPM_RC rc = SerializeCommand_NV_Certify(
+      sign_handle, sign_handle_name, auth_handle, auth_handle_name, nv_index,
+      nv_index_name, qualifying_data, in_scheme, size, offset, &command,
+      authorization_delegate);
+  if (rc != TPM_RC_SUCCESS) {
+    return rc;
+  }
+  std::string response = transceiver_->SendCommandAndWait(command);
+  rc = ParseResponse_NV_Certify(response, certify_info, signature,
+                                authorization_delegate);
+  return rc;
+}
+
+}  // namespace trunks
diff --git a/tpm_generated/tpm_generated.h b/tpm_generated/tpm_generated.h
new file mode 100644
index 000000000..873c145fc
--- /dev/null
+++ b/tpm_generated/tpm_generated.h
@@ -0,0 +1,6075 @@
+// Copyright 2019 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// THIS CODE IS GENERATED - DO NOT MODIFY!
+
+#ifndef TRUNKS_TPM_GENERATED_H_
+#define TRUNKS_TPM_GENERATED_H_
+
+#include <string>
+
+#include "callback.h"
+#include "hex.h"
+#include "trunks_export.h"
+
+// Mini-libchrome: reproduces just the parts of libchrome that this file needs.
+// Embedded in an anonymous namespace so we're not polluting base.
+namespace {
+namespace base {
+using trunks::BindOnce;
+using trunks::HexEncode;
+using trunks::OnceCallback;
+}
+}
+
+namespace trunks {
+
+class AuthorizationDelegate;
+class CommandTransceiver;
+
+#if !defined(SHA1_DIGEST_SIZE)
+#define SHA1_DIGEST_SIZE 20
+#endif
+#if !defined(SHA1_BLOCK_SIZE)
+#define SHA1_BLOCK_SIZE 64
+#endif
+#if !defined(SHA1_DER_SIZE)
+#define SHA1_DER_SIZE 15
+#endif
+#if !defined(SHA1_DER)
+#define SHA1_DER                                                            \
+  {                                                                         \
+    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, \
+        0x00, 0x04, 0x14                                                    \
+  }
+#endif
+#if !defined(SHA256_DIGEST_SIZE)
+#define SHA256_DIGEST_SIZE 32
+#endif
+#if !defined(SHA256_BLOCK_SIZE)
+#define SHA256_BLOCK_SIZE 64
+#endif
+#if !defined(SHA256_DER_SIZE)
+#define SHA256_DER_SIZE 19
+#endif
+#if !defined(SHA256_DER)
+#define SHA256_DER                                                          \
+  {                                                                         \
+    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, \
+        0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20                            \
+  }
+#endif
+#if !defined(SHA384_DIGEST_SIZE)
+#define SHA384_DIGEST_SIZE 48
+#endif
+#if !defined(SHA384_BLOCK_SIZE)
+#define SHA384_BLOCK_SIZE 128
+#endif
+#if !defined(SHA384_DER_SIZE)
+#define SHA384_DER_SIZE 19
+#endif
+#if !defined(SHA384_DER)
+#define SHA384_DER                                                          \
+  {                                                                         \
+    0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, \
+        0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30                            \
+  }
+#endif
+#if !defined(SHA512_DIGEST_SIZE)
+#define SHA512_DIGEST_SIZE 64
+#endif
+#if !defined(SHA512_BLOCK_SIZE)
+#define SHA512_BLOCK_SIZE 128
+#endif
+#if !defined(SHA512_DER_SIZE)
+#define SHA512_DER_SIZE 19
+#endif
+#if !defined(SHA512_DER)
+#define SHA512_DER                                                          \
+  {                                                                         \
+    0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, \
+        0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40                            \
+  }
+#endif
+#if !defined(SM3_256_DIGEST_SIZE)
+#define SM3_256_DIGEST_SIZE 32
+#endif
+#if !defined(SM3_256_BLOCK_SIZE)
+#define SM3_256_BLOCK_SIZE 64
+#endif
+#if !defined(SM3_256_DER_SIZE)
+#define SM3_256_DER_SIZE 18
+#endif
+#if !defined(SM3_256_DER)
+#define SM3_256_DER                                                         \
+  {                                                                         \
+    0x30, 0x30, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x81, 0x1c, 0x81, 0x45, 0x01, \
+        0x83, 0x11, 0x05, 0x00, 0x04, 0x20                                  \
+  }
+#endif
+#if !defined(MAX_SESSION_NUMBER)
+#define MAX_SESSION_NUMBER 3
+#endif
+#if !defined(YES)
+#define YES 1
+#endif
+#if !defined(NO)
+#define NO 0
+#endif
+#if !defined(TRUE)
+#define TRUE 1
+#endif
+#if !defined(FALSE)
+#define FALSE 0
+#endif
+#if !defined(SET)
+#define SET 1
+#endif
+#if !defined(CLEAR)
+#define CLEAR 0
+#endif
+#if !defined(BIG_ENDIAN_TPM)
+#define BIG_ENDIAN_TPM NO
+#endif
+#if !defined(LITTLE_ENDIAN_TPM)
+#define LITTLE_ENDIAN_TPM YES
+#endif
+#if !defined(NO_AUTO_ALIGN)
+#define NO_AUTO_ALIGN NO
+#endif
+#if !defined(RSA_KEY_SIZES_BITS)
+#define RSA_KEY_SIZES_BITS \
+  { 1024, 2048 }
+#endif
+#if !defined(MAX_RSA_KEY_BITS)
+#define MAX_RSA_KEY_BITS 2048
+#endif
+#if !defined(MAX_RSA_KEY_BYTES)
+#define MAX_RSA_KEY_BYTES ((MAX_RSA_KEY_BITS + 7) / 8)
+#endif
+#if !defined(ECC_CURVES)
+#define ECC_CURVES                                      \
+  {                                                     \
+    trunks::TPM_ECC_NIST_P256, trunks::TPM_ECC_BN_P256, \
+        trunks::TPM_ECC_SM2_P256                        \
+  }
+#endif
+#if !defined(ECC_KEY_SIZES_BITS)
+#define ECC_KEY_SIZES_BITS \
+  { 256 }
+#endif
+#if !defined(MAX_ECC_KEY_BITS)
+#define MAX_ECC_KEY_BITS 256
+#endif
+#if !defined(MAX_ECC_KEY_BYTES)
+#define MAX_ECC_KEY_BYTES ((MAX_ECC_KEY_BITS + 7) / 8)
+#endif
+#if !defined(AES_KEY_SIZES_BITS)
+#define AES_KEY_SIZES_BITS \
+  { 128 }
+#endif
+#if !defined(MAX_AES_KEY_BITS)
+#define MAX_AES_KEY_BITS 128
+#endif
+#if !defined(MAX_AES_BLOCK_SIZE_BYTES)
+#define MAX_AES_BLOCK_SIZE_BYTES 16
+#endif
+#if !defined(MAX_AES_KEY_BYTES)
+#define MAX_AES_KEY_BYTES ((MAX_AES_KEY_BITS + 7) / 8)
+#endif
+#if !defined(SM4_KEY_SIZES_BITS)
+#define SM4_KEY_SIZES_BITS \
+  { 128 }
+#endif
+#if !defined(MAX_SM4_KEY_BITS)
+#define MAX_SM4_KEY_BITS 128
+#endif
+#if !defined(MAX_SM4_BLOCK_SIZE_BYTES)
+#define MAX_SM4_BLOCK_SIZE_BYTES 16
+#endif
+#if !defined(MAX_SM4_KEY_BYTES)
+#define MAX_SM4_KEY_BYTES ((MAX_SM4_KEY_BITS + 7) / 8)
+#endif
+#if !defined(MAX_SYM_KEY_BITS)
+#define MAX_SYM_KEY_BITS MAX_AES_KEY_BITS
+#endif
+#if !defined(MAX_SYM_KEY_BYTES)
+#define MAX_SYM_KEY_BYTES MAX_AES_KEY_BYTES
+#endif
+#if !defined(MAX_SYM_BLOCK_SIZE)
+#define MAX_SYM_BLOCK_SIZE MAX_AES_BLOCK_SIZE_BYTES
+#endif
+#if !defined(FIELD_UPGRADE_IMPLEMENTED)
+#define FIELD_UPGRADE_IMPLEMENTED NO
+#endif
+#if !defined(BSIZE)
+#define BSIZE trunks::UINT16
+#endif
+#if !defined(BUFFER_ALIGNMENT)
+#define BUFFER_ALIGNMENT 4
+#endif
+#if !defined(IMPLEMENTATION_PCR)
+#define IMPLEMENTATION_PCR 24
+#endif
+#if !defined(PLATFORM_PCR)
+#define PLATFORM_PCR 24
+#endif
+#if !defined(DRTM_PCR)
+#define DRTM_PCR 17
+#endif
+#if !defined(HCRTM_PCR)
+#define HCRTM_PCR 0
+#endif
+#if !defined(NUM_LOCALITIES)
+#define NUM_LOCALITIES 5
+#endif
+#if !defined(MAX_HANDLE_NUM)
+#define MAX_HANDLE_NUM 3
+#endif
+#if !defined(MAX_ACTIVE_SESSIONS)
+#define MAX_ACTIVE_SESSIONS 64
+#endif
+#if !defined(CONTEXT_SLOT)
+#define CONTEXT_SLOT trunks::UINT16
+#endif
+#if !defined(CONTEXT_COUNTER)
+#define CONTEXT_COUNTER trunks::UINT64
+#endif
+#if !defined(MAX_LOADED_SESSIONS)
+#define MAX_LOADED_SESSIONS 3
+#endif
+#if !defined(MAX_SESSION_NUM)
+#define MAX_SESSION_NUM 3
+#endif
+#if !defined(MAX_LOADED_OBJECTS)
+#define MAX_LOADED_OBJECTS 3
+#endif
+#if !defined(MIN_EVICT_OBJECTS)
+#define MIN_EVICT_OBJECTS 2
+#endif
+#if !defined(PCR_SELECT_MIN)
+#define PCR_SELECT_MIN ((PLATFORM_PCR + 7) / 8)
+#endif
+#if !defined(PCR_SELECT_MAX)
+#define PCR_SELECT_MAX ((IMPLEMENTATION_PCR + 7) / 8)
+#endif
+#if !defined(NUM_POLICY_PCR_GROUP)
+#define NUM_POLICY_PCR_GROUP 1
+#endif
+#if !defined(NUM_AUTHVALUE_PCR_GROUP)
+#define NUM_AUTHVALUE_PCR_GROUP 1
+#endif
+#if !defined(MAX_CONTEXT_SIZE)
+#define MAX_CONTEXT_SIZE 4000
+#endif
+#if !defined(MAX_DIGEST_BUFFER)
+#define MAX_DIGEST_BUFFER 1024
+#endif
+#if !defined(MAX_NV_INDEX_SIZE)
+#define MAX_NV_INDEX_SIZE 2048
+#endif
+#if !defined(MAX_NV_BUFFER_SIZE)
+#define MAX_NV_BUFFER_SIZE 1024
+#endif
+#if !defined(MAX_CAP_BUFFER)
+#define MAX_CAP_BUFFER 1024
+#endif
+#if !defined(NV_MEMORY_SIZE)
+#define NV_MEMORY_SIZE 16384
+#endif
+#if !defined(NUM_STATIC_PCR)
+#define NUM_STATIC_PCR 16
+#endif
+#if !defined(MAX_ALG_LIST_SIZE)
+#define MAX_ALG_LIST_SIZE 64
+#endif
+#if !defined(TIMER_PRESCALE)
+#define TIMER_PRESCALE 100000
+#endif
+#if !defined(PRIMARY_SEED_SIZE)
+#define PRIMARY_SEED_SIZE 32
+#endif
+#if !defined(CONTEXT_ENCRYPT_ALG)
+#define CONTEXT_ENCRYPT_ALG trunks::TPM_ALG_AES
+#endif
+#if !defined(CONTEXT_ENCRYPT_KEY_BITS)
+#define CONTEXT_ENCRYPT_KEY_BITS MAX_SYM_KEY_BITS
+#endif
+#if !defined(CONTEXT_ENCRYPT_KEY_BYTES)
+#define CONTEXT_ENCRYPT_KEY_BYTES ((CONTEXT_ENCRYPT_KEY_BITS + 7) / 8)
+#endif
+#if !defined(CONTEXT_INTEGRITY_HASH_ALG)
+#define CONTEXT_INTEGRITY_HASH_ALG trunks::TPM_ALG_SHA256
+#endif
+#if !defined(CONTEXT_INTEGRITY_HASH_SIZE)
+#define CONTEXT_INTEGRITY_HASH_SIZE SHA256_DIGEST_SIZE
+#endif
+#if !defined(PROOF_SIZE)
+#define PROOF_SIZE CONTEXT_INTEGRITY_HASH_SIZE
+#endif
+#if !defined(NV_CLOCK_UPDATE_INTERVAL)
+#define NV_CLOCK_UPDATE_INTERVAL 12
+#endif
+#if !defined(NUM_POLICY_PCR)
+#define NUM_POLICY_PCR 1
+#endif
+#if !defined(MAX_COMMAND_SIZE)
+#define MAX_COMMAND_SIZE 4096
+#endif
+#if !defined(MAX_RESPONSE_SIZE)
+#define MAX_RESPONSE_SIZE 4096
+#endif
+#if !defined(ORDERLY_BITS)
+#define ORDERLY_BITS 8
+#endif
+#if !defined(MAX_ORDERLY_COUNT)
+#define MAX_ORDERLY_COUNT ((1 << ORDERLY_BITS) - 1)
+#endif
+#if !defined(ALG_ID_FIRST)
+#define ALG_ID_FIRST trunks::TPM_ALG_FIRST
+#endif
+#if !defined(ALG_ID_LAST)
+#define ALG_ID_LAST trunks::TPM_ALG_LAST
+#endif
+#if !defined(MAX_SYM_DATA)
+#define MAX_SYM_DATA 128
+#endif
+#if !defined(MAX_RNG_ENTROPY_SIZE)
+#define MAX_RNG_ENTROPY_SIZE 64
+#endif
+#if !defined(RAM_INDEX_SPACE)
+#define RAM_INDEX_SPACE 512
+#endif
+#if !defined(RSA_DEFAULT_PUBLIC_EXPONENT)
+#define RSA_DEFAULT_PUBLIC_EXPONENT 0x00010001
+#endif
+#if !defined(ENABLE_PCR_NO_INCREMENT)
+#define ENABLE_PCR_NO_INCREMENT YES
+#endif
+#if !defined(CRT_FORMAT_RSA)
+#define CRT_FORMAT_RSA YES
+#endif
+#if !defined(PRIVATE_VENDOR_SPECIFIC_BYTES)
+#define PRIVATE_VENDOR_SPECIFIC_BYTES \
+  ((MAX_RSA_KEY_BYTES / 2) * (3 + CRT_FORMAT_RSA * 2))
+#endif
+#if !defined(MAX_CAP_DATA)
+#define MAX_CAP_DATA \
+  (MAX_CAP_BUFFER - sizeof(trunks::TPM_CAP) - sizeof(trunks::UINT32))
+#endif
+#if !defined(MAX_CAP_ALGS)
+#define MAX_CAP_ALGS (trunks::TPM_ALG_LAST - trunks::TPM_ALG_FIRST + 1)
+#endif
+#if !defined(MAX_CAP_HANDLES)
+#define MAX_CAP_HANDLES (MAX_CAP_DATA / sizeof(trunks::TPM_HANDLE))
+#endif
+#if !defined(MAX_CAP_CC)
+#define MAX_CAP_CC ((trunks::TPM_CC_LAST - trunks::TPM_CC_FIRST) + 1)
+#endif
+#if !defined(MAX_CAP_CCE)
+#define MAX_CAP_CCE ((trunks::TPM_CCE_LAST - trunks::TPM_CCE_FIRST) + 1)
+#endif
+#if !defined(MAX_CAP_CC_ALL)
+#define MAX_CAP_CC_ALL (MAX_CAP_CC + MAX_CAP_CCE)
+#endif
+#if !defined(MAX_TPM_PROPERTIES)
+#define MAX_TPM_PROPERTIES (MAX_CAP_DATA / sizeof(trunks::TPMS_TAGGED_PROPERTY))
+#endif
+#if !defined(MAX_PCR_PROPERTIES)
+#define MAX_PCR_PROPERTIES \
+  (MAX_CAP_DATA / sizeof(trunks::TPMS_TAGGED_PCR_SELECT))
+#endif
+#if !defined(MAX_ECC_CURVES)
+#define MAX_ECC_CURVES (MAX_CAP_DATA / sizeof(trunks::TPM_ECC_CURVE))
+#endif
+#if !defined(HASH_COUNT)
+#define HASH_COUNT 5
+#endif
+
+typedef uint8_t UINT8;
+typedef uint8_t BYTE;
+typedef int8_t INT8;
+typedef int BOOL;
+typedef uint16_t UINT16;
+typedef int16_t INT16;
+typedef uint32_t UINT32;
+typedef int32_t INT32;
+typedef uint64_t UINT64;
+typedef int64_t INT64;
+typedef UINT32 TPM_ALGORITHM_ID;
+typedef UINT32 TPM_MODIFIER_INDICATOR;
+typedef UINT32 TPM_AUTHORIZATION_SIZE;
+typedef UINT32 TPM_PARAMETER_SIZE;
+typedef UINT16 TPM_KEY_SIZE;
+typedef UINT16 TPM_KEY_BITS;
+typedef UINT32 TPM_HANDLE;
+struct TPM2B_DIGEST;
+typedef TPM2B_DIGEST TPM2B_NONCE;
+typedef TPM2B_DIGEST TPM2B_AUTH;
+typedef TPM2B_DIGEST TPM2B_OPERAND;
+struct TPMS_SCHEME_SIGHASH;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_HMAC;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSASSA;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSAPSS;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECDSA;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_SM2;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECSCHNORR;
+typedef BYTE TPMI_YES_NO;
+typedef TPM_HANDLE TPMI_DH_OBJECT;
+typedef TPM_HANDLE TPMI_DH_PERSISTENT;
+typedef TPM_HANDLE TPMI_DH_ENTITY;
+typedef TPM_HANDLE TPMI_DH_PCR;
+typedef TPM_HANDLE TPMI_SH_AUTH_SESSION;
+typedef TPM_HANDLE TPMI_SH_HMAC;
+typedef TPM_HANDLE TPMI_SH_POLICY;
+typedef TPM_HANDLE TPMI_DH_CONTEXT;
+typedef TPM_HANDLE TPMI_RH_HIERARCHY;
+typedef TPM_HANDLE TPMI_RH_ENABLES;
+typedef TPM_HANDLE TPMI_RH_HIERARCHY_AUTH;
+typedef TPM_HANDLE TPMI_RH_PLATFORM;
+typedef TPM_HANDLE TPMI_RH_OWNER;
+typedef TPM_HANDLE TPMI_RH_ENDORSEMENT;
+typedef TPM_HANDLE TPMI_RH_PROVISION;
+typedef TPM_HANDLE TPMI_RH_CLEAR;
+typedef TPM_HANDLE TPMI_RH_NV_AUTH;
+typedef TPM_HANDLE TPMI_RH_LOCKOUT;
+typedef TPM_HANDLE TPMI_RH_NV_INDEX;
+typedef UINT16 TPM_ALG_ID;
+typedef TPM_ALG_ID TPMI_ALG_HASH;
+typedef TPM_ALG_ID TPMI_ALG_ASYM;
+typedef TPM_ALG_ID TPMI_ALG_SYM;
+typedef TPM_ALG_ID TPMI_ALG_SYM_OBJECT;
+typedef TPM_ALG_ID TPMI_ALG_SYM_MODE;
+typedef TPM_ALG_ID TPMI_ALG_KDF;
+typedef TPM_ALG_ID TPMI_ALG_SIG_SCHEME;
+typedef TPM_ALG_ID TPMI_ECC_KEY_EXCHANGE;
+typedef UINT16 TPM_ST;
+typedef TPM_ST TPMI_ST_COMMAND_TAG;
+typedef TPM_ST TPMI_ST_ATTEST;
+typedef TPM_KEY_BITS TPMI_AES_KEY_BITS;
+typedef TPM_KEY_BITS TPMI_SM4_KEY_BITS;
+typedef TPM_ALG_ID TPMI_ALG_KEYEDHASH_SCHEME;
+typedef TPM_ALG_ID TPMI_ALG_ASYM_SCHEME;
+typedef TPM_ALG_ID TPMI_ALG_RSA_SCHEME;
+typedef TPM_ALG_ID TPMI_ALG_RSA_DECRYPT;
+typedef TPM_KEY_BITS TPMI_RSA_KEY_BITS;
+typedef TPM_ALG_ID TPMI_ALG_ECC_SCHEME;
+typedef UINT16 TPM_ECC_CURVE;
+typedef TPM_ECC_CURVE TPMI_ECC_CURVE;
+typedef TPM_ALG_ID TPMI_ALG_PUBLIC;
+typedef UINT32 TPMA_ALGORITHM;
+typedef UINT32 TPMA_OBJECT;
+typedef UINT8 TPMA_SESSION;
+typedef UINT8 TPMA_LOCALITY;
+typedef UINT32 TPMA_PERMANENT;
+typedef UINT32 TPMA_STARTUP_CLEAR;
+typedef UINT32 TPMA_MEMORY;
+typedef UINT32 TPM_CC;
+typedef TPM_CC TPMA_CC;
+typedef UINT32 TPM_NV_INDEX;
+typedef UINT32 TPMA_NV;
+typedef UINT32 TPM_SPEC;
+typedef UINT32 TPM_GENERATED;
+typedef UINT32 TPM_RC;
+typedef INT8 TPM_CLOCK_ADJUST;
+typedef UINT16 TPM_EO;
+typedef UINT16 TPM_SU;
+typedef UINT8 TPM_SE;
+typedef UINT32 TPM_CAP;
+typedef UINT32 TPM_PT;
+typedef UINT32 TPM_PT_PCR;
+typedef UINT32 TPM_PS;
+typedef UINT8 TPM_HT;
+typedef UINT32 TPM_RH;
+typedef TPM_HANDLE TPM_HC;
+
+constexpr TPM_SPEC TPM_SPEC_FAMILY = 0x322E3000;
+constexpr TPM_SPEC TPM_SPEC_LEVEL = 00;
+constexpr TPM_SPEC TPM_SPEC_VERSION = 99;
+constexpr TPM_SPEC TPM_SPEC_YEAR = 2013;
+constexpr TPM_SPEC TPM_SPEC_DAY_OF_YEAR = 304;
+constexpr TPM_GENERATED TPM_GENERATED_VALUE = 0xff544347;
+constexpr TPM_ALG_ID TPM_ALG_ERROR = 0x0000;
+constexpr TPM_ALG_ID TPM_ALG_FIRST = 0x0001;
+constexpr TPM_ALG_ID TPM_ALG_RSA = 0x0001;
+constexpr TPM_ALG_ID TPM_ALG_SHA = 0x0004;
+constexpr TPM_ALG_ID TPM_ALG_SHA1 = 0x0004;
+constexpr TPM_ALG_ID TPM_ALG_HMAC = 0x0005;
+constexpr TPM_ALG_ID TPM_ALG_AES = 0x0006;
+constexpr TPM_ALG_ID TPM_ALG_MGF1 = 0x0007;
+constexpr TPM_ALG_ID TPM_ALG_KEYEDHASH = 0x0008;
+constexpr TPM_ALG_ID TPM_ALG_XOR = 0x000A;
+constexpr TPM_ALG_ID TPM_ALG_SHA256 = 0x000B;
+constexpr TPM_ALG_ID TPM_ALG_SHA384 = 0x000C;
+constexpr TPM_ALG_ID TPM_ALG_SHA512 = 0x000D;
+constexpr TPM_ALG_ID TPM_ALG_NULL = 0x0010;
+constexpr TPM_ALG_ID TPM_ALG_SM3_256 = 0x0012;
+constexpr TPM_ALG_ID TPM_ALG_SM4 = 0x0013;
+constexpr TPM_ALG_ID TPM_ALG_RSASSA = 0x0014;
+constexpr TPM_ALG_ID TPM_ALG_RSAES = 0x0015;
+constexpr TPM_ALG_ID TPM_ALG_RSAPSS = 0x0016;
+constexpr TPM_ALG_ID TPM_ALG_OAEP = 0x0017;
+constexpr TPM_ALG_ID TPM_ALG_ECDSA = 0x0018;
+constexpr TPM_ALG_ID TPM_ALG_ECDH = 0x0019;
+constexpr TPM_ALG_ID TPM_ALG_ECDAA = 0x001A;
+constexpr TPM_ALG_ID TPM_ALG_SM2 = 0x001B;
+constexpr TPM_ALG_ID TPM_ALG_ECSCHNORR = 0x001C;
+constexpr TPM_ALG_ID TPM_ALG_ECMQV = 0x001D;
+constexpr TPM_ALG_ID TPM_ALG_KDF1_SP800_56a = 0x0020;
+constexpr TPM_ALG_ID TPM_ALG_KDF2 = 0x0021;
+constexpr TPM_ALG_ID TPM_ALG_KDF1_SP800_108 = 0x0022;
+constexpr TPM_ALG_ID TPM_ALG_ECC = 0x0023;
+constexpr TPM_ALG_ID TPM_ALG_SYMCIPHER = 0x0025;
+constexpr TPM_ALG_ID TPM_ALG_CTR = 0x0040;
+constexpr TPM_ALG_ID TPM_ALG_OFB = 0x0041;
+constexpr TPM_ALG_ID TPM_ALG_CBC = 0x0042;
+constexpr TPM_ALG_ID TPM_ALG_CFB = 0x0043;
+constexpr TPM_ALG_ID TPM_ALG_ECB = 0x0044;
+constexpr TPM_ALG_ID TPM_ALG_LAST = 0x0044;
+constexpr TPM_ECC_CURVE TPM_ECC_NONE = 0x0000;
+constexpr TPM_ECC_CURVE TPM_ECC_NIST_P192 = 0x0001;
+constexpr TPM_ECC_CURVE TPM_ECC_NIST_P224 = 0x0002;
+constexpr TPM_ECC_CURVE TPM_ECC_NIST_P256 = 0x0003;
+constexpr TPM_ECC_CURVE TPM_ECC_NIST_P384 = 0x0004;
+constexpr TPM_ECC_CURVE TPM_ECC_NIST_P521 = 0x0005;
+constexpr TPM_ECC_CURVE TPM_ECC_BN_P256 = 0x0010;
+constexpr TPM_ECC_CURVE TPM_ECC_BN_P638 = 0x0011;
+constexpr TPM_ECC_CURVE TPM_ECC_SM2_P256 = 0x0020;
+constexpr TPM_CC TPM_CC_FIRST = 0x0000011F;
+constexpr TPM_CC TPM_CC_PP_FIRST = 0x0000011F;
+constexpr TPM_CC TPM_CC_NV_UndefineSpaceSpecial = 0x0000011F;
+constexpr TPM_CC TPM_CC_EvictControl = 0x00000120;
+constexpr TPM_CC TPM_CC_HierarchyControl = 0x00000121;
+constexpr TPM_CC TPM_CC_NV_UndefineSpace = 0x00000122;
+constexpr TPM_CC TPM_CC_ChangeEPS = 0x00000124;
+constexpr TPM_CC TPM_CC_ChangePPS = 0x00000125;
+constexpr TPM_CC TPM_CC_Clear = 0x00000126;
+constexpr TPM_CC TPM_CC_ClearControl = 0x00000127;
+constexpr TPM_CC TPM_CC_ClockSet = 0x00000128;
+constexpr TPM_CC TPM_CC_HierarchyChangeAuth = 0x00000129;
+constexpr TPM_CC TPM_CC_NV_DefineSpace = 0x0000012A;
+constexpr TPM_CC TPM_CC_PCR_Allocate = 0x0000012B;
+constexpr TPM_CC TPM_CC_PCR_SetAuthPolicy = 0x0000012C;
+constexpr TPM_CC TPM_CC_PP_Commands = 0x0000012D;
+constexpr TPM_CC TPM_CC_SetPrimaryPolicy = 0x0000012E;
+constexpr TPM_CC TPM_CC_FieldUpgradeStart = 0x0000012F;
+constexpr TPM_CC TPM_CC_ClockRateAdjust = 0x00000130;
+constexpr TPM_CC TPM_CC_CreatePrimary = 0x00000131;
+constexpr TPM_CC TPM_CC_NV_GlobalWriteLock = 0x00000132;
+constexpr TPM_CC TPM_CC_PP_LAST = 0x00000132;
+constexpr TPM_CC TPM_CC_GetCommandAuditDigest = 0x00000133;
+constexpr TPM_CC TPM_CC_NV_Increment = 0x00000134;
+constexpr TPM_CC TPM_CC_NV_SetBits = 0x00000135;
+constexpr TPM_CC TPM_CC_NV_Extend = 0x00000136;
+constexpr TPM_CC TPM_CC_NV_Write = 0x00000137;
+constexpr TPM_CC TPM_CC_NV_WriteLock = 0x00000138;
+constexpr TPM_CC TPM_CC_DictionaryAttackLockReset = 0x00000139;
+constexpr TPM_CC TPM_CC_DictionaryAttackParameters = 0x0000013A;
+constexpr TPM_CC TPM_CC_NV_ChangeAuth = 0x0000013B;
+constexpr TPM_CC TPM_CC_PCR_Event = 0x0000013C;
+constexpr TPM_CC TPM_CC_PCR_Reset = 0x0000013D;
+constexpr TPM_CC TPM_CC_SequenceComplete = 0x0000013E;
+constexpr TPM_CC TPM_CC_SetAlgorithmSet = 0x0000013F;
+constexpr TPM_CC TPM_CC_SetCommandCodeAuditStatus = 0x00000140;
+constexpr TPM_CC TPM_CC_FieldUpgradeData = 0x00000141;
+constexpr TPM_CC TPM_CC_IncrementalSelfTest = 0x00000142;
+constexpr TPM_CC TPM_CC_SelfTest = 0x00000143;
+constexpr TPM_CC TPM_CC_Startup = 0x00000144;
+constexpr TPM_CC TPM_CC_Shutdown = 0x00000145;
+constexpr TPM_CC TPM_CC_StirRandom = 0x00000146;
+constexpr TPM_CC TPM_CC_ActivateCredential = 0x00000147;
+constexpr TPM_CC TPM_CC_Certify = 0x00000148;
+constexpr TPM_CC TPM_CC_PolicyNV = 0x00000149;
+constexpr TPM_CC TPM_CC_CertifyCreation = 0x0000014A;
+constexpr TPM_CC TPM_CC_Duplicate = 0x0000014B;
+constexpr TPM_CC TPM_CC_GetTime = 0x0000014C;
+constexpr TPM_CC TPM_CC_GetSessionAuditDigest = 0x0000014D;
+constexpr TPM_CC TPM_CC_NV_Read = 0x0000014E;
+constexpr TPM_CC TPM_CC_NV_ReadLock = 0x0000014F;
+constexpr TPM_CC TPM_CC_ObjectChangeAuth = 0x00000150;
+constexpr TPM_CC TPM_CC_PolicySecret = 0x00000151;
+constexpr TPM_CC TPM_CC_Rewrap = 0x00000152;
+constexpr TPM_CC TPM_CC_Create = 0x00000153;
+constexpr TPM_CC TPM_CC_ECDH_ZGen = 0x00000154;
+constexpr TPM_CC TPM_CC_HMAC = 0x00000155;
+constexpr TPM_CC TPM_CC_Import = 0x00000156;
+constexpr TPM_CC TPM_CC_Load = 0x00000157;
+constexpr TPM_CC TPM_CC_Quote = 0x00000158;
+constexpr TPM_CC TPM_CC_RSA_Decrypt = 0x00000159;
+constexpr TPM_CC TPM_CC_HMAC_Start = 0x0000015B;
+constexpr TPM_CC TPM_CC_SequenceUpdate = 0x0000015C;
+constexpr TPM_CC TPM_CC_Sign = 0x0000015D;
+constexpr TPM_CC TPM_CC_Unseal = 0x0000015E;
+constexpr TPM_CC TPM_CC_PolicySigned = 0x00000160;
+constexpr TPM_CC TPM_CC_ContextLoad = 0x00000161;
+constexpr TPM_CC TPM_CC_ContextSave = 0x00000162;
+constexpr TPM_CC TPM_CC_ECDH_KeyGen = 0x00000163;
+constexpr TPM_CC TPM_CC_EncryptDecrypt = 0x00000164;
+constexpr TPM_CC TPM_CC_FlushContext = 0x00000165;
+constexpr TPM_CC TPM_CC_LoadExternal = 0x00000167;
+constexpr TPM_CC TPM_CC_MakeCredential = 0x00000168;
+constexpr TPM_CC TPM_CC_NV_ReadPublic = 0x00000169;
+constexpr TPM_CC TPM_CC_PolicyAuthorize = 0x0000016A;
+constexpr TPM_CC TPM_CC_PolicyAuthValue = 0x0000016B;
+constexpr TPM_CC TPM_CC_PolicyCommandCode = 0x0000016C;
+constexpr TPM_CC TPM_CC_PolicyCounterTimer = 0x0000016D;
+constexpr TPM_CC TPM_CC_PolicyCpHash = 0x0000016E;
+constexpr TPM_CC TPM_CC_PolicyLocality = 0x0000016F;
+constexpr TPM_CC TPM_CC_PolicyNameHash = 0x00000170;
+constexpr TPM_CC TPM_CC_PolicyOR = 0x00000171;
+constexpr TPM_CC TPM_CC_PolicyTicket = 0x00000172;
+constexpr TPM_CC TPM_CC_ReadPublic = 0x00000173;
+constexpr TPM_CC TPM_CC_RSA_Encrypt = 0x00000174;
+constexpr TPM_CC TPM_CC_StartAuthSession = 0x00000176;
+constexpr TPM_CC TPM_CC_VerifySignature = 0x00000177;
+constexpr TPM_CC TPM_CC_ECC_Parameters = 0x00000178;
+constexpr TPM_CC TPM_CC_FirmwareRead = 0x00000179;
+constexpr TPM_CC TPM_CC_GetCapability = 0x0000017A;
+constexpr TPM_CC TPM_CC_GetRandom = 0x0000017B;
+constexpr TPM_CC TPM_CC_GetTestResult = 0x0000017C;
+constexpr TPM_CC TPM_CC_Hash = 0x0000017D;
+constexpr TPM_CC TPM_CC_PCR_Read = 0x0000017E;
+constexpr TPM_CC TPM_CC_PolicyPCR = 0x0000017F;
+constexpr TPM_CC TPM_CC_PolicyRestart = 0x00000180;
+constexpr TPM_CC TPM_CC_ReadClock = 0x00000181;
+constexpr TPM_CC TPM_CC_PCR_Extend = 0x00000182;
+constexpr TPM_CC TPM_CC_PCR_SetAuthValue = 0x00000183;
+constexpr TPM_CC TPM_CC_NV_Certify = 0x00000184;
+constexpr TPM_CC TPM_CC_EventSequenceComplete = 0x00000185;
+constexpr TPM_CC TPM_CC_HashSequenceStart = 0x00000186;
+constexpr TPM_CC TPM_CC_PolicyPhysicalPresence = 0x00000187;
+constexpr TPM_CC TPM_CC_PolicyDuplicationSelect = 0x00000188;
+constexpr TPM_CC TPM_CC_PolicyGetDigest = 0x00000189;
+constexpr TPM_CC TPM_CC_TestParms = 0x0000018A;
+constexpr TPM_CC TPM_CC_Commit = 0x0000018B;
+constexpr TPM_CC TPM_CC_PolicyPassword = 0x0000018C;
+constexpr TPM_CC TPM_CC_ZGen_2Phase = 0x0000018D;
+constexpr TPM_CC TPM_CC_EC_Ephemeral = 0x0000018E;
+constexpr TPM_CC TPM_CC_PolicyNvWritten = 0x0000018F;
+constexpr TPM_CC TPM_CC_LAST = 0x0000018F;
+constexpr TPM_CC TPM_CCE_FIRST = 0x20008001;
+constexpr TPM_CC TPM_CCE_PolicyFidoSigned = 0x20008001;
+constexpr TPM_CC TPM_CCE_LAST = 0x20008001;
+constexpr TPM_RC TPM_RC_SUCCESS = 0x000;
+constexpr TPM_RC TPM_RC_BAD_TAG = 0x01E;
+constexpr TPM_RC RC_VER1 = 0x100;
+constexpr TPM_RC TPM_RC_INITIALIZE = RC_VER1 + 0x000;
+constexpr TPM_RC TPM_RC_FAILURE = RC_VER1 + 0x001;
+constexpr TPM_RC TPM_RC_SEQUENCE = RC_VER1 + 0x003;
+constexpr TPM_RC TPM_RC_PRIVATE = RC_VER1 + 0x00B;
+constexpr TPM_RC TPM_RC_HMAC = RC_VER1 + 0x019;
+constexpr TPM_RC TPM_RC_DISABLED = RC_VER1 + 0x020;
+constexpr TPM_RC TPM_RC_EXCLUSIVE = RC_VER1 + 0x021;
+constexpr TPM_RC TPM_RC_AUTH_TYPE = RC_VER1 + 0x024;
+constexpr TPM_RC TPM_RC_AUTH_MISSING = RC_VER1 + 0x025;
+constexpr TPM_RC TPM_RC_POLICY = RC_VER1 + 0x026;
+constexpr TPM_RC TPM_RC_PCR = RC_VER1 + 0x027;
+constexpr TPM_RC TPM_RC_PCR_CHANGED = RC_VER1 + 0x028;
+constexpr TPM_RC TPM_RC_UPGRADE = RC_VER1 + 0x02D;
+constexpr TPM_RC TPM_RC_TOO_MANY_CONTEXTS = RC_VER1 + 0x02E;
+constexpr TPM_RC TPM_RC_AUTH_UNAVAILABLE = RC_VER1 + 0x02F;
+constexpr TPM_RC TPM_RC_REBOOT = RC_VER1 + 0x030;
+constexpr TPM_RC TPM_RC_UNBALANCED = RC_VER1 + 0x031;
+constexpr TPM_RC TPM_RC_COMMAND_SIZE = RC_VER1 + 0x042;
+constexpr TPM_RC TPM_RC_COMMAND_CODE = RC_VER1 + 0x043;
+constexpr TPM_RC TPM_RC_AUTHSIZE = RC_VER1 + 0x044;
+constexpr TPM_RC TPM_RC_AUTH_CONTEXT = RC_VER1 + 0x045;
+constexpr TPM_RC TPM_RC_NV_RANGE = RC_VER1 + 0x046;
+constexpr TPM_RC TPM_RC_NV_SIZE = RC_VER1 + 0x047;
+constexpr TPM_RC TPM_RC_NV_LOCKED = RC_VER1 + 0x048;
+constexpr TPM_RC TPM_RC_NV_AUTHORIZATION = RC_VER1 + 0x049;
+constexpr TPM_RC TPM_RC_NV_UNINITIALIZED = RC_VER1 + 0x04A;
+constexpr TPM_RC TPM_RC_NV_SPACE = RC_VER1 + 0x04B;
+constexpr TPM_RC TPM_RC_NV_DEFINED = RC_VER1 + 0x04C;
+constexpr TPM_RC TPM_RC_BAD_CONTEXT = RC_VER1 + 0x050;
+constexpr TPM_RC TPM_RC_CPHASH = RC_VER1 + 0x051;
+constexpr TPM_RC TPM_RC_PARENT = RC_VER1 + 0x052;
+constexpr TPM_RC TPM_RC_NEEDS_TEST = RC_VER1 + 0x053;
+constexpr TPM_RC TPM_RC_NO_RESULT = RC_VER1 + 0x054;
+constexpr TPM_RC TPM_RC_SENSITIVE = RC_VER1 + 0x055;
+constexpr TPM_RC RC_MAX_FM0 = RC_VER1 + 0x07F;
+constexpr TPM_RC RC_FMT1 = 0x080;
+constexpr TPM_RC TPM_RC_ASYMMETRIC = RC_FMT1 + 0x001;
+constexpr TPM_RC TPM_RC_ATTRIBUTES = RC_FMT1 + 0x002;
+constexpr TPM_RC TPM_RC_HASH = RC_FMT1 + 0x003;
+constexpr TPM_RC TPM_RC_VALUE = RC_FMT1 + 0x004;
+constexpr TPM_RC TPM_RC_HIERARCHY = RC_FMT1 + 0x005;
+constexpr TPM_RC TPM_RC_KEY_SIZE = RC_FMT1 + 0x007;
+constexpr TPM_RC TPM_RC_MGF = RC_FMT1 + 0x008;
+constexpr TPM_RC TPM_RC_MODE = RC_FMT1 + 0x009;
+constexpr TPM_RC TPM_RC_TYPE = RC_FMT1 + 0x00A;
+constexpr TPM_RC TPM_RC_HANDLE = RC_FMT1 + 0x00B;
+constexpr TPM_RC TPM_RC_KDF = RC_FMT1 + 0x00C;
+constexpr TPM_RC TPM_RC_RANGE = RC_FMT1 + 0x00D;
+constexpr TPM_RC TPM_RC_AUTH_FAIL = RC_FMT1 + 0x00E;
+constexpr TPM_RC TPM_RC_NONCE = RC_FMT1 + 0x00F;
+constexpr TPM_RC TPM_RC_PP = RC_FMT1 + 0x010;
+constexpr TPM_RC TPM_RC_SCHEME = RC_FMT1 + 0x012;
+constexpr TPM_RC TPM_RC_SIZE = RC_FMT1 + 0x015;
+constexpr TPM_RC TPM_RC_SYMMETRIC = RC_FMT1 + 0x016;
+constexpr TPM_RC TPM_RC_TAG = RC_FMT1 + 0x017;
+constexpr TPM_RC TPM_RC_SELECTOR = RC_FMT1 + 0x018;
+constexpr TPM_RC TPM_RC_INSUFFICIENT = RC_FMT1 + 0x01A;
+constexpr TPM_RC TPM_RC_SIGNATURE = RC_FMT1 + 0x01B;
+constexpr TPM_RC TPM_RC_KEY = RC_FMT1 + 0x01C;
+constexpr TPM_RC TPM_RC_POLICY_FAIL = RC_FMT1 + 0x01D;
+constexpr TPM_RC TPM_RC_INTEGRITY = RC_FMT1 + 0x01F;
+constexpr TPM_RC TPM_RC_TICKET = RC_FMT1 + 0x020;
+constexpr TPM_RC TPM_RC_RESERVED_BITS = RC_FMT1 + 0x021;
+constexpr TPM_RC TPM_RC_BAD_AUTH = RC_FMT1 + 0x022;
+constexpr TPM_RC TPM_RC_EXPIRED = RC_FMT1 + 0x023;
+constexpr TPM_RC TPM_RC_POLICY_CC = RC_FMT1 + 0x024;
+constexpr TPM_RC TPM_RC_BINDING = RC_FMT1 + 0x025;
+constexpr TPM_RC TPM_RC_CURVE = RC_FMT1 + 0x026;
+constexpr TPM_RC TPM_RC_ECC_POINT = RC_FMT1 + 0x027;
+constexpr TPM_RC RC_WARN = 0x900;
+constexpr TPM_RC TPM_RC_CONTEXT_GAP = RC_WARN + 0x001;
+constexpr TPM_RC TPM_RC_OBJECT_MEMORY = RC_WARN + 0x002;
+constexpr TPM_RC TPM_RC_SESSION_MEMORY = RC_WARN + 0x003;
+constexpr TPM_RC TPM_RC_MEMORY = RC_WARN + 0x004;
+constexpr TPM_RC TPM_RC_SESSION_HANDLES = RC_WARN + 0x005;
+constexpr TPM_RC TPM_RC_OBJECT_HANDLES = RC_WARN + 0x006;
+constexpr TPM_RC TPM_RC_LOCALITY = RC_WARN + 0x007;
+constexpr TPM_RC TPM_RC_YIELDED = RC_WARN + 0x008;
+constexpr TPM_RC TPM_RC_CANCELED = RC_WARN + 0x009;
+constexpr TPM_RC TPM_RC_TESTING = RC_WARN + 0x00A;
+constexpr TPM_RC TPM_RC_REFERENCE_H0 = RC_WARN + 0x010;
+constexpr TPM_RC TPM_RC_REFERENCE_H1 = RC_WARN + 0x011;
+constexpr TPM_RC TPM_RC_REFERENCE_H2 = RC_WARN + 0x012;
+constexpr TPM_RC TPM_RC_REFERENCE_H3 = RC_WARN + 0x013;
+constexpr TPM_RC TPM_RC_REFERENCE_H4 = RC_WARN + 0x014;
+constexpr TPM_RC TPM_RC_REFERENCE_H5 = RC_WARN + 0x015;
+constexpr TPM_RC TPM_RC_REFERENCE_H6 = RC_WARN + 0x016;
+constexpr TPM_RC TPM_RC_REFERENCE_S0 = RC_WARN + 0x018;
+constexpr TPM_RC TPM_RC_REFERENCE_S1 = RC_WARN + 0x019;
+constexpr TPM_RC TPM_RC_REFERENCE_S2 = RC_WARN + 0x01A;
+constexpr TPM_RC TPM_RC_REFERENCE_S3 = RC_WARN + 0x01B;
+constexpr TPM_RC TPM_RC_REFERENCE_S4 = RC_WARN + 0x01C;
+constexpr TPM_RC TPM_RC_REFERENCE_S5 = RC_WARN + 0x01D;
+constexpr TPM_RC TPM_RC_REFERENCE_S6 = RC_WARN + 0x01E;
+constexpr TPM_RC TPM_RC_NV_RATE = RC_WARN + 0x020;
+constexpr TPM_RC TPM_RC_LOCKOUT = RC_WARN + 0x021;
+constexpr TPM_RC TPM_RC_RETRY = RC_WARN + 0x022;
+constexpr TPM_RC TPM_RC_NV_UNAVAILABLE = RC_WARN + 0x023;
+constexpr TPM_RC TPM_RC_NOT_USED = RC_WARN + 0x7F;
+constexpr TPM_RC TPM_RC_H = 0x000;
+constexpr TPM_RC TPM_RC_P = 0x040;
+constexpr TPM_RC TPM_RC_S = 0x800;
+constexpr TPM_RC TPM_RC_1 = 0x100;
+constexpr TPM_RC TPM_RC_2 = 0x200;
+constexpr TPM_RC TPM_RC_3 = 0x300;
+constexpr TPM_RC TPM_RC_4 = 0x400;
+constexpr TPM_RC TPM_RC_5 = 0x500;
+constexpr TPM_RC TPM_RC_6 = 0x600;
+constexpr TPM_RC TPM_RC_7 = 0x700;
+constexpr TPM_RC TPM_RC_8 = 0x800;
+constexpr TPM_RC TPM_RC_9 = 0x900;
+constexpr TPM_RC TPM_RC_A = 0xA00;
+constexpr TPM_RC TPM_RC_B = 0xB00;
+constexpr TPM_RC TPM_RC_C = 0xC00;
+constexpr TPM_RC TPM_RC_D = 0xD00;
+constexpr TPM_RC TPM_RC_E = 0xE00;
+constexpr TPM_RC TPM_RC_F = 0xF00;
+constexpr TPM_RC TPM_RC_N_MASK = 0xF00;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_COARSE_SLOWER = -3;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_MEDIUM_SLOWER = -2;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_FINE_SLOWER = -1;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_NO_CHANGE = 0;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_FINE_FASTER = 1;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_MEDIUM_FASTER = 2;
+constexpr TPM_CLOCK_ADJUST TPM_CLOCK_COARSE_FASTER = 3;
+constexpr TPM_EO TPM_EO_EQ = 0x0000;
+constexpr TPM_EO TPM_EO_NEQ = 0x0001;
+constexpr TPM_EO TPM_EO_SIGNED_GT = 0x0002;
+constexpr TPM_EO TPM_EO_UNSIGNED_GT = 0x0003;
+constexpr TPM_EO TPM_EO_SIGNED_LT = 0x0004;
+constexpr TPM_EO TPM_EO_UNSIGNED_LT = 0x0005;
+constexpr TPM_EO TPM_EO_SIGNED_GE = 0x0006;
+constexpr TPM_EO TPM_EO_UNSIGNED_GE = 0x0007;
+constexpr TPM_EO TPM_EO_SIGNED_LE = 0x0008;
+constexpr TPM_EO TPM_EO_UNSIGNED_LE = 0x0009;
+constexpr TPM_EO TPM_EO_BITSET = 0x000A;
+constexpr TPM_EO TPM_EO_BITCLEAR = 0x000B;
+constexpr TPM_ST TPM_ST_RSP_COMMAND = 0x00C4;
+constexpr TPM_ST TPM_ST_NULL = 0X8000;
+constexpr TPM_ST TPM_ST_NO_SESSIONS = 0x8001;
+constexpr TPM_ST TPM_ST_SESSIONS = 0x8002;
+constexpr TPM_ST TPM_ST_ATTEST_NV = 0x8014;
+constexpr TPM_ST TPM_ST_ATTEST_COMMAND_AUDIT = 0x8015;
+constexpr TPM_ST TPM_ST_ATTEST_SESSION_AUDIT = 0x8016;
+constexpr TPM_ST TPM_ST_ATTEST_CERTIFY = 0x8017;
+constexpr TPM_ST TPM_ST_ATTEST_QUOTE = 0x8018;
+constexpr TPM_ST TPM_ST_ATTEST_TIME = 0x8019;
+constexpr TPM_ST TPM_ST_ATTEST_CREATION = 0x801A;
+constexpr TPM_ST TPM_ST_CREATION = 0x8021;
+constexpr TPM_ST TPM_ST_VERIFIED = 0x8022;
+constexpr TPM_ST TPM_ST_AUTH_SECRET = 0x8023;
+constexpr TPM_ST TPM_ST_HASHCHECK = 0x8024;
+constexpr TPM_ST TPM_ST_AUTH_SIGNED = 0x8025;
+constexpr TPM_ST TPM_ST_FU_MANIFEST = 0x8029;
+constexpr TPM_SU TPM_SU_CLEAR = 0x0000;
+constexpr TPM_SU TPM_SU_STATE = 0x0001;
+constexpr TPM_SE TPM_SE_HMAC = 0x00;
+constexpr TPM_SE TPM_SE_POLICY = 0x01;
+constexpr TPM_SE TPM_SE_TRIAL = 0x03;
+constexpr TPM_CAP TPM_CAP_FIRST = 0x00000000;
+constexpr TPM_CAP TPM_CAP_ALGS = 0x00000000;
+constexpr TPM_CAP TPM_CAP_HANDLES = 0x00000001;
+constexpr TPM_CAP TPM_CAP_COMMANDS = 0x00000002;
+constexpr TPM_CAP TPM_CAP_PP_COMMANDS = 0x00000003;
+constexpr TPM_CAP TPM_CAP_AUDIT_COMMANDS = 0x00000004;
+constexpr TPM_CAP TPM_CAP_PCRS = 0x00000005;
+constexpr TPM_CAP TPM_CAP_TPM_PROPERTIES = 0x00000006;
+constexpr TPM_CAP TPM_CAP_PCR_PROPERTIES = 0x00000007;
+constexpr TPM_CAP TPM_CAP_ECC_CURVES = 0x00000008;
+constexpr TPM_CAP TPM_CAP_LAST = 0x00000008;
+constexpr TPM_CAP TPM_CAP_VENDOR_PROPERTY = 0x00000100;
+constexpr TPM_PT TPM_PT_NONE = 0x00000000;
+constexpr TPM_PT PT_GROUP = 0x00000100;
+constexpr TPM_PT PT_FIXED = PT_GROUP * 1;
+constexpr TPM_PT TPM_PT_FAMILY_INDICATOR = PT_FIXED + 0;
+constexpr TPM_PT TPM_PT_LEVEL = PT_FIXED + 1;
+constexpr TPM_PT TPM_PT_REVISION = PT_FIXED + 2;
+constexpr TPM_PT TPM_PT_DAY_OF_YEAR = PT_FIXED + 3;
+constexpr TPM_PT TPM_PT_YEAR = PT_FIXED + 4;
+constexpr TPM_PT TPM_PT_MANUFACTURER = PT_FIXED + 5;
+constexpr TPM_PT TPM_PT_VENDOR_STRING_1 = PT_FIXED + 6;
+constexpr TPM_PT TPM_PT_VENDOR_STRING_2 = PT_FIXED + 7;
+constexpr TPM_PT TPM_PT_VENDOR_STRING_3 = PT_FIXED + 8;
+constexpr TPM_PT TPM_PT_VENDOR_STRING_4 = PT_FIXED + 9;
+constexpr TPM_PT TPM_PT_VENDOR_TPM_TYPE = PT_FIXED + 10;
+constexpr TPM_PT TPM_PT_FIRMWARE_VERSION_1 = PT_FIXED + 11;
+constexpr TPM_PT TPM_PT_FIRMWARE_VERSION_2 = PT_FIXED + 12;
+constexpr TPM_PT TPM_PT_INPUT_BUFFER = PT_FIXED + 13;
+constexpr TPM_PT TPM_PT_HR_TRANSIENT_MIN = PT_FIXED + 14;
+constexpr TPM_PT TPM_PT_HR_PERSISTENT_MIN = PT_FIXED + 15;
+constexpr TPM_PT TPM_PT_HR_LOADED_MIN = PT_FIXED + 16;
+constexpr TPM_PT TPM_PT_ACTIVE_SESSIONS_MAX = PT_FIXED + 17;
+constexpr TPM_PT TPM_PT_PCR_COUNT = PT_FIXED + 18;
+constexpr TPM_PT TPM_PT_PCR_SELECT_MIN = PT_FIXED + 19;
+constexpr TPM_PT TPM_PT_CONTEXT_GAP_MAX = PT_FIXED + 20;
+constexpr TPM_PT TPM_PT_NV_COUNTERS_MAX = PT_FIXED + 22;
+constexpr TPM_PT TPM_PT_NV_INDEX_MAX = PT_FIXED + 23;
+constexpr TPM_PT TPM_PT_MEMORY = PT_FIXED + 24;
+constexpr TPM_PT TPM_PT_CLOCK_UPDATE = PT_FIXED + 25;
+constexpr TPM_PT TPM_PT_CONTEXT_HASH = PT_FIXED + 26;
+constexpr TPM_PT TPM_PT_CONTEXT_SYM = PT_FIXED + 27;
+constexpr TPM_PT TPM_PT_CONTEXT_SYM_SIZE = PT_FIXED + 28;
+constexpr TPM_PT TPM_PT_ORDERLY_COUNT = PT_FIXED + 29;
+constexpr TPM_PT TPM_PT_MAX_COMMAND_SIZE = PT_FIXED + 30;
+constexpr TPM_PT TPM_PT_MAX_RESPONSE_SIZE = PT_FIXED + 31;
+constexpr TPM_PT TPM_PT_MAX_DIGEST = PT_FIXED + 32;
+constexpr TPM_PT TPM_PT_MAX_OBJECT_CONTEXT = PT_FIXED + 33;
+constexpr TPM_PT TPM_PT_MAX_SESSION_CONTEXT = PT_FIXED + 34;
+constexpr TPM_PT TPM_PT_PS_FAMILY_INDICATOR = PT_FIXED + 35;
+constexpr TPM_PT TPM_PT_PS_LEVEL = PT_FIXED + 36;
+constexpr TPM_PT TPM_PT_PS_REVISION = PT_FIXED + 37;
+constexpr TPM_PT TPM_PT_PS_DAY_OF_YEAR = PT_FIXED + 38;
+constexpr TPM_PT TPM_PT_PS_YEAR = PT_FIXED + 39;
+constexpr TPM_PT TPM_PT_SPLIT_MAX = PT_FIXED + 40;
+constexpr TPM_PT TPM_PT_TOTAL_COMMANDS = PT_FIXED + 41;
+constexpr TPM_PT TPM_PT_LIBRARY_COMMANDS = PT_FIXED + 42;
+constexpr TPM_PT TPM_PT_VENDOR_COMMANDS = PT_FIXED + 43;
+constexpr TPM_PT TPM_PT_NV_BUFFER_MAX = PT_FIXED + 44;
+constexpr TPM_PT PT_VAR = PT_GROUP * 2;
+constexpr TPM_PT TPM_PT_PERMANENT = PT_VAR + 0;
+constexpr TPM_PT TPM_PT_STARTUP_CLEAR = PT_VAR + 1;
+constexpr TPM_PT TPM_PT_HR_NV_INDEX = PT_VAR + 2;
+constexpr TPM_PT TPM_PT_HR_LOADED = PT_VAR + 3;
+constexpr TPM_PT TPM_PT_HR_LOADED_AVAIL = PT_VAR + 4;
+constexpr TPM_PT TPM_PT_HR_ACTIVE = PT_VAR + 5;
+constexpr TPM_PT TPM_PT_HR_ACTIVE_AVAIL = PT_VAR + 6;
+constexpr TPM_PT TPM_PT_HR_TRANSIENT_AVAIL = PT_VAR + 7;
+constexpr TPM_PT TPM_PT_HR_PERSISTENT = PT_VAR + 8;
+constexpr TPM_PT TPM_PT_HR_PERSISTENT_AVAIL = PT_VAR + 9;
+constexpr TPM_PT TPM_PT_NV_COUNTERS = PT_VAR + 10;
+constexpr TPM_PT TPM_PT_NV_COUNTERS_AVAIL = PT_VAR + 11;
+constexpr TPM_PT TPM_PT_ALGORITHM_SET = PT_VAR + 12;
+constexpr TPM_PT TPM_PT_LOADED_CURVES = PT_VAR + 13;
+constexpr TPM_PT TPM_PT_LOCKOUT_COUNTER = PT_VAR + 14;
+constexpr TPM_PT TPM_PT_MAX_AUTH_FAIL = PT_VAR + 15;
+constexpr TPM_PT TPM_PT_LOCKOUT_INTERVAL = PT_VAR + 16;
+constexpr TPM_PT TPM_PT_LOCKOUT_RECOVERY = PT_VAR + 17;
+constexpr TPM_PT TPM_PT_NV_WRITE_RECOVERY = PT_VAR + 18;
+constexpr TPM_PT TPM_PT_AUDIT_COUNTER_0 = PT_VAR + 19;
+constexpr TPM_PT TPM_PT_AUDIT_COUNTER_1 = PT_VAR + 20;
+constexpr TPM_PT_PCR TPM_PT_PCR_FIRST = 0x00000000;
+constexpr TPM_PT_PCR TPM_PT_PCR_SAVE = 0x00000000;
+constexpr TPM_PT_PCR TPM_PT_PCR_EXTEND_L0 = 0x00000001;
+constexpr TPM_PT_PCR TPM_PT_PCR_RESET_L0 = 0x00000002;
+constexpr TPM_PT_PCR TPM_PT_PCR_EXTEND_L1 = 0x00000003;
+constexpr TPM_PT_PCR TPM_PT_PCR_RESET_L1 = 0x00000004;
+constexpr TPM_PT_PCR TPM_PT_PCR_EXTEND_L2 = 0x00000005;
+constexpr TPM_PT_PCR TPM_PT_PCR_RESET_L2 = 0x00000006;
+constexpr TPM_PT_PCR TPM_PT_PCR_EXTEND_L3 = 0x00000007;
+constexpr TPM_PT_PCR TPM_PT_PCR_RESET_L3 = 0x00000008;
+constexpr TPM_PT_PCR TPM_PT_PCR_EXTEND_L4 = 0x00000009;
+constexpr TPM_PT_PCR TPM_PT_PCR_RESET_L4 = 0x0000000A;
+constexpr TPM_PT_PCR TPM_PT_PCR_NO_INCREMENT = 0x00000011;
+constexpr TPM_PT_PCR TPM_PT_PCR_DRTM_RESET = 0x00000012;
+constexpr TPM_PT_PCR TPM_PT_PCR_POLICY = 0x00000013;
+constexpr TPM_PT_PCR TPM_PT_PCR_AUTH = 0x00000014;
+constexpr TPM_PT_PCR TPM_PT_PCR_LAST = 0x00000014;
+constexpr TPM_PS TPM_PS_MAIN = 0x00000000;
+constexpr TPM_PS TPM_PS_PC = 0x00000001;
+constexpr TPM_PS TPM_PS_PDA = 0x00000002;
+constexpr TPM_PS TPM_PS_CELL_PHONE = 0x00000003;
+constexpr TPM_PS TPM_PS_SERVER = 0x00000004;
+constexpr TPM_PS TPM_PS_PERIPHERAL = 0x00000005;
+constexpr TPM_PS TPM_PS_TSS = 0x00000006;
+constexpr TPM_PS TPM_PS_STORAGE = 0x00000007;
+constexpr TPM_PS TPM_PS_AUTHENTICATION = 0x00000008;
+constexpr TPM_PS TPM_PS_EMBEDDED = 0x00000009;
+constexpr TPM_PS TPM_PS_HARDCOPY = 0x0000000A;
+constexpr TPM_PS TPM_PS_INFRASTRUCTURE = 0x0000000B;
+constexpr TPM_PS TPM_PS_VIRTUALIZATION = 0x0000000C;
+constexpr TPM_PS TPM_PS_TNC = 0x0000000D;
+constexpr TPM_PS TPM_PS_MULTI_TENANT = 0x0000000E;
+constexpr TPM_PS TPM_PS_TC = 0x0000000F;
+constexpr TPM_HT TPM_HT_PCR = 0x00;
+constexpr TPM_HT TPM_HT_NV_INDEX = 0x01;
+constexpr TPM_HT TPM_HT_HMAC_SESSION = 0x02;
+constexpr TPM_HT TPM_HT_LOADED_SESSION = 0x02;
+constexpr TPM_HT TPM_HT_POLICY_SESSION = 0x03;
+constexpr TPM_HT TPM_HT_ACTIVE_SESSION = 0x03;
+constexpr TPM_HT TPM_HT_PERMANENT = 0x40;
+constexpr TPM_HT TPM_HT_TRANSIENT = 0x80;
+constexpr TPM_HT TPM_HT_PERSISTENT = 0x81;
+constexpr TPM_RH TPM_RH_FIRST = 0x40000000;
+constexpr TPM_RH TPM_RH_SRK = 0x40000000;
+constexpr TPM_RH TPM_RH_OWNER = 0x40000001;
+constexpr TPM_RH TPM_RH_REVOKE = 0x40000002;
+constexpr TPM_RH TPM_RH_TRANSPORT = 0x40000003;
+constexpr TPM_RH TPM_RH_OPERATOR = 0x40000004;
+constexpr TPM_RH TPM_RH_ADMIN = 0x40000005;
+constexpr TPM_RH TPM_RH_EK = 0x40000006;
+constexpr TPM_RH TPM_RH_NULL = 0x40000007;
+constexpr TPM_RH TPM_RH_UNASSIGNED = 0x40000008;
+constexpr TPM_RH TPM_RS_PW = 0x40000009;
+constexpr TPM_RH TPM_RH_LOCKOUT = 0x4000000A;
+constexpr TPM_RH TPM_RH_ENDORSEMENT = 0x4000000B;
+constexpr TPM_RH TPM_RH_PLATFORM = 0x4000000C;
+constexpr TPM_RH TPM_RH_PLATFORM_NV = 0x4000000D;
+constexpr TPM_RH TPM_RH_LAST = 0x4000000D;
+constexpr TPM_HC HR_HANDLE_MASK = 0x00FFFFFF;
+constexpr TPM_HC HR_RANGE_MASK = 0xFF000000;
+constexpr TPM_HC HR_SHIFT = 24;
+constexpr TPM_HC HR_PCR = (TPM_HT_PCR << HR_SHIFT);
+constexpr TPM_HC HR_HMAC_SESSION = (TPM_HT_HMAC_SESSION << HR_SHIFT);
+constexpr TPM_HC HR_POLICY_SESSION = (TPM_HT_POLICY_SESSION << HR_SHIFT);
+constexpr TPM_HC HR_TRANSIENT = (TPM_HT_TRANSIENT << HR_SHIFT);
+constexpr TPM_HC HR_PERSISTENT = (TPM_HT_PERSISTENT << HR_SHIFT);
+constexpr TPM_HC HR_NV_INDEX = (TPM_HT_NV_INDEX << HR_SHIFT);
+constexpr TPM_HC HR_PERMANENT = (TPM_HT_PERMANENT << HR_SHIFT);
+constexpr TPM_HC PCR_FIRST = (HR_PCR + 0);
+constexpr TPM_HC PCR_LAST = (PCR_FIRST + IMPLEMENTATION_PCR - 1);
+constexpr TPM_HC HMAC_SESSION_FIRST = (HR_HMAC_SESSION + 0);
+constexpr TPM_HC HMAC_SESSION_LAST =
+    (HMAC_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1);
+constexpr TPM_HC LOADED_SESSION_LAST = HMAC_SESSION_LAST;
+constexpr TPM_HC POLICY_SESSION_FIRST = (HR_POLICY_SESSION + 0);
+constexpr TPM_HC POLICY_SESSION_LAST =
+    (POLICY_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1);
+constexpr TPM_HC TRANSIENT_FIRST = (HR_TRANSIENT + 0);
+constexpr TPM_HC ACTIVE_SESSION_FIRST = POLICY_SESSION_FIRST;
+constexpr TPM_HC ACTIVE_SESSION_LAST = POLICY_SESSION_LAST;
+constexpr TPM_HC TRANSIENT_LAST = (TRANSIENT_FIRST + MAX_LOADED_OBJECTS - 1);
+constexpr TPM_HC PERSISTENT_FIRST = (HR_PERSISTENT + 0);
+constexpr TPM_HC PERSISTENT_LAST = (PERSISTENT_FIRST + 0x00FFFFFF);
+constexpr TPM_HC PLATFORM_PERSISTENT = (PERSISTENT_FIRST + 0x00800000);
+constexpr TPM_HC NV_INDEX_FIRST = (HR_NV_INDEX + 0);
+constexpr TPM_HC NV_INDEX_LAST = (NV_INDEX_FIRST + 0x00FFFFFF);
+constexpr TPM_HC PERMANENT_FIRST = TPM_RH_FIRST;
+constexpr TPM_HC PERMANENT_LAST = TPM_RH_LAST;
+
+struct TPMS_ALGORITHM_DESCRIPTION {
+  TPM_ALG_ID alg = {};
+  TPMA_ALGORITHM attributes = {};
+};
+
+union TPMU_HA {
+  BYTE sha1[SHA1_DIGEST_SIZE];
+  BYTE sha256[SHA256_DIGEST_SIZE];
+  BYTE sm3_256[SM3_256_DIGEST_SIZE];
+  BYTE sha384[SHA384_DIGEST_SIZE];
+  BYTE sha512[SHA512_DIGEST_SIZE];
+};
+
+struct TPMT_HA {
+  TPMI_ALG_HASH hash_alg = {};
+  TPMU_HA digest = {};
+};
+
+struct TPM2B_DIGEST {
+  UINT16 size = {};
+  BYTE buffer[sizeof(TPMU_HA)] = {};
+};
+
+struct TPM2B_DATA {
+  UINT16 size = {};
+  BYTE buffer[sizeof(TPMT_HA)] = {};
+};
+
+struct TPM2B_EVENT {
+  UINT16 size = {};
+  BYTE buffer[1024] = {};
+};
+
+struct TPM2B_MAX_BUFFER {
+  UINT16 size = {};
+  BYTE buffer[MAX_DIGEST_BUFFER] = {};
+};
+
+struct TPM2B_MAX_NV_BUFFER {
+  UINT16 size = {};
+  BYTE buffer[MAX_NV_BUFFER_SIZE] = {};
+};
+
+struct TPM2B_TIMEOUT {
+  UINT16 size = {};
+  BYTE buffer[sizeof(UINT64)] = {};
+};
+
+struct TPM2B_IV {
+  UINT16 size = {};
+  BYTE buffer[MAX_SYM_BLOCK_SIZE] = {};
+};
+
+union TPMU_NAME {
+  TPMT_HA digest;
+  TPM_HANDLE handle;
+};
+
+struct TPM2B_NAME {
+  UINT16 size = {};
+  BYTE name[sizeof(TPMU_NAME)] = {};
+};
+
+struct TPMS_PCR_SELECT {
+  UINT8 sizeof_select = {};
+  BYTE pcr_select[PCR_SELECT_MAX] = {};
+};
+
+struct TPMS_PCR_SELECTION {
+  TPMI_ALG_HASH hash = {};
+  UINT8 sizeof_select = {};
+  BYTE pcr_select[PCR_SELECT_MAX] = {};
+};
+
+struct TPMT_TK_CREATION {
+  TPM_ST tag = {};
+  TPMI_RH_HIERARCHY hierarchy = {};
+  TPM2B_DIGEST digest = {};
+};
+
+struct TPMT_TK_VERIFIED {
+  TPM_ST tag = {};
+  TPMI_RH_HIERARCHY hierarchy = {};
+  TPM2B_DIGEST digest = {};
+};
+
+struct TPMT_TK_AUTH {
+  TPM_ST tag = {};
+  TPMI_RH_HIERARCHY hierarchy = {};
+  TPM2B_DIGEST digest = {};
+};
+
+struct TPMT_TK_HASHCHECK {
+  TPM_ST tag = {};
+  TPMI_RH_HIERARCHY hierarchy = {};
+  TPM2B_DIGEST digest = {};
+};
+
+struct TPMS_ALG_PROPERTY {
+  TPM_ALG_ID alg = {};
+  TPMA_ALGORITHM alg_properties = {};
+};
+
+struct TPMS_TAGGED_PROPERTY {
+  TPM_PT property = {};
+  UINT32 value = {};
+};
+
+struct TPMS_TAGGED_PCR_SELECT {
+  TPM_PT tag = {};
+  UINT8 sizeof_select = {};
+  BYTE pcr_select[PCR_SELECT_MAX] = {};
+};
+
+struct TPML_CC {
+  UINT32 count = {};
+  TPM_CC command_codes[MAX_CAP_CC_ALL] = {};
+};
+
+struct TPML_CCA {
+  UINT32 count = {};
+  TPMA_CC command_attributes[MAX_CAP_CC_ALL] = {};
+};
+
+struct TPML_ALG {
+  UINT32 count = {};
+  TPM_ALG_ID algorithms[MAX_ALG_LIST_SIZE] = {};
+};
+
+struct TPML_HANDLE {
+  UINT32 count = {};
+  TPM_HANDLE handle[MAX_CAP_HANDLES] = {};
+};
+
+struct TPML_DIGEST {
+  UINT32 count = {};
+  TPM2B_DIGEST digests[8] = {};
+};
+
+struct TPML_DIGEST_VALUES {
+  UINT32 count = {};
+  TPMT_HA digests[HASH_COUNT] = {};
+};
+
+struct TPM2B_DIGEST_VALUES {
+  UINT16 size = {};
+  BYTE buffer[sizeof(TPML_DIGEST_VALUES)] = {};
+};
+
+struct TPML_PCR_SELECTION {
+  UINT32 count = {};
+  TPMS_PCR_SELECTION pcr_selections[HASH_COUNT] = {};
+};
+
+struct TPML_ALG_PROPERTY {
+  UINT32 count = {};
+  TPMS_ALG_PROPERTY alg_properties[MAX_CAP_ALGS] = {};
+};
+
+struct TPML_TAGGED_TPM_PROPERTY {
+  UINT32 count = {};
+  TPMS_TAGGED_PROPERTY tpm_property[MAX_TPM_PROPERTIES] = {};
+};
+
+struct TPML_TAGGED_PCR_PROPERTY {
+  UINT32 count = {};
+  TPMS_TAGGED_PCR_SELECT pcr_property[MAX_PCR_PROPERTIES] = {};
+};
+
+struct TPML_ECC_CURVE {
+  UINT32 count = {};
+  TPM_ECC_CURVE ecc_curves[MAX_ECC_CURVES] = {};
+};
+
+union TPMU_CAPABILITIES {
+  TPML_ALG_PROPERTY algorithms;
+  TPML_HANDLE handles;
+  TPML_CCA command;
+  TPML_CC pp_commands;
+  TPML_CC audit_commands;
+  TPML_PCR_SELECTION assigned_pcr;
+  TPML_TAGGED_TPM_PROPERTY tpm_properties;
+  TPML_TAGGED_PCR_PROPERTY pcr_properties;
+  TPML_ECC_CURVE ecc_curves;
+};
+
+struct TPMS_CAPABILITY_DATA {
+  TPM_CAP capability = {};
+  TPMU_CAPABILITIES data = {};
+};
+
+struct TPMS_CLOCK_INFO {
+  UINT64 clock = {};
+  UINT32 reset_count = {};
+  UINT32 restart_count = {};
+  TPMI_YES_NO safe = {};
+};
+
+struct TPMS_TIME_INFO {
+  UINT64 time = {};
+  TPMS_CLOCK_INFO clock_info = {};
+};
+
+struct TPMS_TIME_ATTEST_INFO {
+  TPMS_TIME_INFO time = {};
+  UINT64 firmware_version = {};
+};
+
+struct TPMS_CERTIFY_INFO {
+  TPM2B_NAME name = {};
+  TPM2B_NAME qualified_name = {};
+};
+
+struct TPMS_QUOTE_INFO {
+  TPML_PCR_SELECTION pcr_select = {};
+  TPM2B_DIGEST pcr_digest = {};
+};
+
+struct TPMS_COMMAND_AUDIT_INFO {
+  UINT64 audit_counter = {};
+  TPM_ALG_ID digest_alg = {};
+  TPM2B_DIGEST audit_digest = {};
+  TPM2B_DIGEST command_digest = {};
+};
+
+struct TPMS_SESSION_AUDIT_INFO {
+  TPMI_YES_NO exclusive_session = {};
+  TPM2B_DIGEST session_digest = {};
+};
+
+struct TPMS_CREATION_INFO {
+  TPM2B_NAME object_name = {};
+  TPM2B_DIGEST creation_hash = {};
+};
+
+struct TPMS_NV_CERTIFY_INFO {
+  TPM2B_NAME index_name = {};
+  UINT16 offset = {};
+  TPM2B_MAX_NV_BUFFER nv_contents = {};
+};
+
+union TPMU_ATTEST {
+  TPMS_CERTIFY_INFO certify;
+  TPMS_CREATION_INFO creation;
+  TPMS_QUOTE_INFO quote;
+  TPMS_COMMAND_AUDIT_INFO command_audit;
+  TPMS_SESSION_AUDIT_INFO session_audit;
+  TPMS_TIME_ATTEST_INFO time;
+  TPMS_NV_CERTIFY_INFO nv;
+};
+
+struct TPMS_ATTEST {
+  TPM_GENERATED magic = {};
+  TPMI_ST_ATTEST type = {};
+  TPM2B_NAME qualified_signer = {};
+  TPM2B_DATA extra_data = {};
+  TPMS_CLOCK_INFO clock_info = {};
+  UINT64 firmware_version = {};
+  TPMU_ATTEST attested = {};
+};
+
+struct TPM2B_ATTEST {
+  UINT16 size = {};
+  BYTE attestation_data[sizeof(TPMS_ATTEST)] = {};
+};
+
+struct TPMS_AUTH_COMMAND {
+  TPMI_SH_AUTH_SESSION session_handle = {};
+  TPM2B_NONCE nonce = {};
+  TPMA_SESSION session_attributes = {};
+  TPM2B_AUTH hmac = {};
+};
+
+struct TPMS_AUTH_RESPONSE {
+  TPM2B_NONCE nonce = {};
+  TPMA_SESSION session_attributes = {};
+  TPM2B_AUTH hmac = {};
+};
+
+union TPMU_SYM_KEY_BITS {
+  TPMI_AES_KEY_BITS aes;
+  TPMI_SM4_KEY_BITS sm4;
+  TPM_KEY_BITS sym;
+  TPMI_ALG_HASH xor_;
+};
+
+union TPMU_SYM_MODE {
+  TPMI_ALG_SYM_MODE aes;
+  TPMI_ALG_SYM_MODE sm4;
+  TPMI_ALG_SYM_MODE sym;
+};
+
+union TPMU_SYM_DETAILS {};
+
+struct TPMT_SYM_DEF {
+  TPMI_ALG_SYM algorithm = {};
+  TPMU_SYM_KEY_BITS key_bits = {};
+  TPMU_SYM_MODE mode = {};
+  TPMU_SYM_DETAILS details = {};
+};
+
+struct TPMT_SYM_DEF_OBJECT {
+  TPMI_ALG_SYM_OBJECT algorithm = {};
+  TPMU_SYM_KEY_BITS key_bits = {};
+  TPMU_SYM_MODE mode = {};
+  TPMU_SYM_DETAILS details = {};
+};
+
+struct TPM2B_SYM_KEY {
+  UINT16 size = {};
+  BYTE buffer[MAX_SYM_KEY_BYTES] = {};
+};
+
+struct TPMS_SYMCIPHER_PARMS {
+  TPMT_SYM_DEF_OBJECT sym = {};
+};
+
+struct TPM2B_SENSITIVE_DATA {
+  UINT16 size = {};
+  BYTE buffer[MAX_SYM_DATA] = {};
+};
+
+struct TPMS_SENSITIVE_CREATE {
+  TPM2B_AUTH user_auth = {};
+  TPM2B_SENSITIVE_DATA data = {};
+};
+
+struct TPM2B_SENSITIVE_CREATE {
+  UINT16 size = {};
+  TPMS_SENSITIVE_CREATE sensitive = {};
+};
+
+struct TPMS_SCHEME_SIGHASH {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_XOR {
+  TPMI_ALG_HASH hash_alg = {};
+  TPMI_ALG_KDF kdf = {};
+};
+
+union TPMU_SCHEME_KEYEDHASH {
+  TPMS_SCHEME_HMAC hmac;
+  TPMS_SCHEME_XOR xor_;
+};
+
+struct TPMT_KEYEDHASH_SCHEME {
+  TPMI_ALG_KEYEDHASH_SCHEME scheme = {};
+  TPMU_SCHEME_KEYEDHASH details = {};
+};
+
+struct TPMS_SCHEME_ECDAA {
+  TPMI_ALG_HASH hash_alg = {};
+  UINT16 count = {};
+};
+
+union TPMU_SIG_SCHEME {
+  TPMS_SCHEME_RSASSA rsassa;
+  TPMS_SCHEME_RSAPSS rsapss;
+  TPMS_SCHEME_ECDSA ecdsa;
+  TPMS_SCHEME_SM2 sm2;
+  TPMS_SCHEME_ECDAA ecdaa;
+  TPMS_SCHEME_ECSCHNORR ec_schnorr;
+  TPMS_SCHEME_HMAC hmac;
+  TPMS_SCHEME_SIGHASH any;
+};
+
+struct TPMT_SIG_SCHEME {
+  TPMI_ALG_SIG_SCHEME scheme = {};
+  TPMU_SIG_SCHEME details = {};
+};
+
+struct TPMS_SCHEME_OAEP {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_ECDH {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_MGF1 {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_KDF1_SP800_56a {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_KDF2 {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+struct TPMS_SCHEME_KDF1_SP800_108 {
+  TPMI_ALG_HASH hash_alg = {};
+};
+
+union TPMU_KDF_SCHEME {
+  TPMS_SCHEME_MGF1 mgf1;
+  TPMS_SCHEME_KDF1_SP800_56a kdf1_sp800_56a;
+  TPMS_SCHEME_KDF2 kdf2;
+  TPMS_SCHEME_KDF1_SP800_108 kdf1_sp800_108;
+};
+
+struct TPMT_KDF_SCHEME {
+  TPMI_ALG_KDF scheme = {};
+  TPMU_KDF_SCHEME details = {};
+};
+
+union TPMU_ASYM_SCHEME {
+  TPMS_SCHEME_RSASSA rsassa;
+  TPMS_SCHEME_RSAPSS rsapss;
+  TPMS_SCHEME_OAEP oaep;
+  TPMS_SCHEME_ECDSA ecdsa;
+  TPMS_SCHEME_SM2 sm2;
+  TPMS_SCHEME_ECDAA ecdaa;
+  TPMS_SCHEME_ECSCHNORR ec_schnorr;
+  TPMS_SCHEME_ECDH ecdh;
+  TPMS_SCHEME_SIGHASH any_sig;
+};
+
+struct TPMT_ASYM_SCHEME {
+  TPMI_ALG_ASYM_SCHEME scheme = {};
+  TPMU_ASYM_SCHEME details = {};
+};
+
+struct TPMT_RSA_SCHEME {
+  TPMI_ALG_RSA_SCHEME scheme = {};
+  TPMU_ASYM_SCHEME details = {};
+};
+
+struct TPMT_RSA_DECRYPT {
+  TPMI_ALG_RSA_DECRYPT scheme = {};
+  TPMU_ASYM_SCHEME details = {};
+};
+
+struct TPM2B_PUBLIC_KEY_RSA {
+  UINT16 size = {};
+  BYTE buffer[MAX_RSA_KEY_BYTES] = {};
+};
+
+struct TPM2B_PRIVATE_KEY_RSA {
+  UINT16 size = {};
+  BYTE buffer[MAX_RSA_KEY_BYTES / 2] = {};
+};
+
+struct TPM2B_ECC_PARAMETER {
+  UINT16 size = {};
+  BYTE buffer[MAX_ECC_KEY_BYTES] = {};
+};
+
+struct TPMS_ECC_POINT {
+  TPM2B_ECC_PARAMETER x = {};
+  TPM2B_ECC_PARAMETER y = {};
+};
+
+struct TPM2B_ECC_POINT {
+  UINT16 size = {};
+  TPMS_ECC_POINT point = {};
+};
+
+struct TPMT_ECC_SCHEME {
+  TPMI_ALG_ECC_SCHEME scheme = {};
+  TPMU_SIG_SCHEME details = {};
+};
+
+struct TPMS_ALGORITHM_DETAIL_ECC {
+  TPM_ECC_CURVE curve_id = {};
+  UINT16 key_size = {};
+  TPMT_KDF_SCHEME kdf = {};
+  TPMT_ECC_SCHEME sign = {};
+  TPM2B_ECC_PARAMETER p = {};
+  TPM2B_ECC_PARAMETER a = {};
+  TPM2B_ECC_PARAMETER b = {};
+  TPM2B_ECC_PARAMETER g_x = {};
+  TPM2B_ECC_PARAMETER g_y = {};
+  TPM2B_ECC_PARAMETER n = {};
+  TPM2B_ECC_PARAMETER h = {};
+};
+
+struct TPMS_SIGNATURE_RSASSA {
+  TPMI_ALG_HASH hash = {};
+  TPM2B_PUBLIC_KEY_RSA sig = {};
+};
+
+struct TPMS_SIGNATURE_RSAPSS {
+  TPMI_ALG_HASH hash = {};
+  TPM2B_PUBLIC_KEY_RSA sig = {};
+};
+
+struct TPMS_SIGNATURE_ECDSA {
+  TPMI_ALG_HASH hash = {};
+  TPM2B_ECC_PARAMETER signature_r = {};
+  TPM2B_ECC_PARAMETER signature_s = {};
+};
+
+union TPMU_SIGNATURE {
+  TPMS_SIGNATURE_RSASSA rsassa;
+  TPMS_SIGNATURE_RSAPSS rsapss;
+  TPMS_SIGNATURE_ECDSA ecdsa;
+  TPMS_SIGNATURE_ECDSA sm2;
+  TPMS_SIGNATURE_ECDSA ecdaa;
+  TPMS_SIGNATURE_ECDSA ecschnorr;
+  TPMT_HA hmac;
+  TPMS_SCHEME_SIGHASH any;
+};
+
+struct TPMT_SIGNATURE {
+  TPMI_ALG_SIG_SCHEME sig_alg = {};
+  TPMU_SIGNATURE signature = {};
+};
+
+union TPMU_ENCRYPTED_SECRET {
+  BYTE ecc[sizeof(TPMS_ECC_POINT)];
+  BYTE rsa[MAX_RSA_KEY_BYTES];
+  BYTE symmetric[sizeof(TPM2B_DIGEST)];
+  BYTE keyed_hash[sizeof(TPM2B_DIGEST)];
+};
+
+struct TPM2B_ENCRYPTED_SECRET {
+  UINT16 size = {};
+  BYTE secret[sizeof(TPMU_ENCRYPTED_SECRET)] = {};
+};
+
+struct TPMS_KEYEDHASH_PARMS {
+  TPMT_KEYEDHASH_SCHEME scheme = {};
+};
+
+struct TPMS_ASYM_PARMS {
+  TPMT_SYM_DEF_OBJECT symmetric = {};
+  TPMT_ASYM_SCHEME scheme = {};
+};
+
+struct TPMS_RSA_PARMS {
+  TPMT_SYM_DEF_OBJECT symmetric = {};
+  TPMT_RSA_SCHEME scheme = {};
+  TPMI_RSA_KEY_BITS key_bits = {};
+  UINT32 exponent = {};
+};
+
+struct TPMS_ECC_PARMS {
+  TPMT_SYM_DEF_OBJECT symmetric = {};
+  TPMT_ECC_SCHEME scheme = {};
+  TPMI_ECC_CURVE curve_id = {};
+  TPMT_KDF_SCHEME kdf = {};
+};
+
+union TPMU_PUBLIC_PARMS {
+  TPMS_KEYEDHASH_PARMS keyed_hash_detail;
+  TPMS_SYMCIPHER_PARMS sym_detail;
+  TPMS_RSA_PARMS rsa_detail;
+  TPMS_ECC_PARMS ecc_detail;
+  TPMS_ASYM_PARMS asym_detail;
+};
+
+struct TPMT_PUBLIC_PARMS {
+  TPMI_ALG_PUBLIC type = {};
+  TPMU_PUBLIC_PARMS parameters = {};
+};
+
+union TPMU_PUBLIC_ID {
+  TPM2B_DIGEST keyed_hash;
+  TPM2B_DIGEST sym;
+  TPM2B_PUBLIC_KEY_RSA rsa;
+  TPMS_ECC_POINT ecc;
+};
+
+struct TPMT_PUBLIC {
+  TPMI_ALG_PUBLIC type = {};
+  TPMI_ALG_HASH name_alg = {};
+  TPMA_OBJECT object_attributes = {};
+  TPM2B_DIGEST auth_policy = {};
+  TPMU_PUBLIC_PARMS parameters = {};
+  TPMU_PUBLIC_ID unique = {};
+};
+
+struct TPM2B_PUBLIC {
+  UINT16 size = {};
+  TPMT_PUBLIC public_area = {};
+};
+
+struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
+  UINT16 size = {};
+  BYTE buffer[PRIVATE_VENDOR_SPECIFIC_BYTES] = {};
+};
+
+union TPMU_SENSITIVE_COMPOSITE {
+  TPM2B_PRIVATE_KEY_RSA rsa;
+  TPM2B_ECC_PARAMETER ecc;
+  TPM2B_SENSITIVE_DATA bits;
+  TPM2B_SYM_KEY sym;
+  TPM2B_PRIVATE_VENDOR_SPECIFIC any;
+};
+
+struct TPMT_SENSITIVE {
+  TPMI_ALG_PUBLIC sensitive_type = {};
+  TPM2B_AUTH auth_value = {};
+  TPM2B_DIGEST seed_value = {};
+  TPMU_SENSITIVE_COMPOSITE sensitive = {};
+};
+
+struct TPM2B_SENSITIVE {
+  UINT16 size = {};
+  TPMT_SENSITIVE sensitive_area = {};
+};
+
+struct TPM2B_PRIVATE {
+  UINT16 size = {};
+  BYTE buffer[MAX_DIGEST_BUFFER] = {};
+};
+
+struct TPM2B_ID_OBJECT {
+  UINT16 size = {};
+  BYTE credential[MAX_DIGEST_BUFFER] = {};
+};
+
+struct TPMS_NV_PUBLIC {
+  TPMI_RH_NV_INDEX nv_index = {};
+  TPMI_ALG_HASH name_alg = {};
+  TPMA_NV attributes = {};
+  TPM2B_DIGEST auth_policy = {};
+  UINT16 data_size = {};
+};
+
+struct TPM2B_NV_PUBLIC {
+  UINT16 size = {};
+  TPMS_NV_PUBLIC nv_public = {};
+};
+
+struct TPM2B_CONTEXT_SENSITIVE {
+  UINT16 size = {};
+  BYTE buffer[MAX_CONTEXT_SIZE] = {};
+};
+
+struct TPMS_CONTEXT_DATA {
+  TPM2B_DIGEST integrity = {};
+  TPM2B_CONTEXT_SENSITIVE encrypted = {};
+};
+
+struct TPM2B_CONTEXT_DATA {
+  UINT16 size = {};
+  BYTE buffer[sizeof(TPMS_CONTEXT_DATA)] = {};
+};
+
+struct TPMS_CONTEXT {
+  UINT64 sequence = {};
+  TPMI_DH_CONTEXT saved_handle = {};
+  TPMI_RH_HIERARCHY hierarchy = {};
+  TPM2B_CONTEXT_DATA context_blob = {};
+};
+
+struct TPMS_CREATION_DATA {
+  TPML_PCR_SELECTION pcr_select = {};
+  TPM2B_DIGEST pcr_digest = {};
+  TPMA_LOCALITY locality = {};
+  TPM_ALG_ID parent_name_alg = {};
+  TPM2B_NAME parent_name = {};
+  TPM2B_NAME parent_qualified_name = {};
+  TPM2B_DATA outside_info = {};
+};
+
+struct TPM2B_CREATION_DATA {
+  UINT16 size = {};
+  TPMS_CREATION_DATA creation_data = {};
+};
+
+struct FIDO_DATA_RANGE {
+  UINT16 offset = {};
+  UINT16 size = {};
+};
+
+TRUNKS_EXPORT size_t GetNumberOfRequestHandles(TPM_CC command_code);
+TRUNKS_EXPORT size_t GetNumberOfResponseHandles(TPM_CC command_code);
+
+TRUNKS_EXPORT TPM_RC Serialize_uint8_t(const uint8_t& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_uint8_t(std::string* buffer,
+                                   uint8_t* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_int8_t(const int8_t& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_int8_t(std::string* buffer,
+                                  int8_t* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_int(const int& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_int(std::string* buffer,
+                               int* value,
+                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_uint16_t(const uint16_t& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_uint16_t(std::string* buffer,
+                                    uint16_t* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_int16_t(const int16_t& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_int16_t(std::string* buffer,
+                                   int16_t* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_uint32_t(const uint32_t& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_uint32_t(std::string* buffer,
+                                    uint32_t* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_int32_t(const int32_t& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_int32_t(std::string* buffer,
+                                   int32_t* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_uint64_t(const uint64_t& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_uint64_t(std::string* buffer,
+                                    uint64_t* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_int64_t(const int64_t& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_int64_t(std::string* buffer,
+                                   int64_t* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_UINT8(const UINT8& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_UINT8(std::string* buffer,
+                                 UINT8* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_BYTE(const BYTE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_BYTE(std::string* buffer,
+                                BYTE* value,
+                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_INT8(const INT8& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_INT8(std::string* buffer,
+                                INT8* value,
+                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_BOOL(const BOOL& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_BOOL(std::string* buffer,
+                                BOOL* value,
+                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_UINT16(const UINT16& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_UINT16(std::string* buffer,
+                                  UINT16* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_INT16(const INT16& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_INT16(std::string* buffer,
+                                 INT16* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_UINT32(const UINT32& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_UINT32(std::string* buffer,
+                                  UINT32* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_INT32(const INT32& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_INT32(std::string* buffer,
+                                 INT32* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_UINT64(const UINT64& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_UINT64(std::string* buffer,
+                                  UINT64* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_INT64(const INT64& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_INT64(std::string* buffer,
+                                 INT64* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_ALGORITHM_ID(const TPM_ALGORITHM_ID& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_ALGORITHM_ID(std::string* buffer,
+                                            TPM_ALGORITHM_ID* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_MODIFIER_INDICATOR(
+    const TPM_MODIFIER_INDICATOR& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_MODIFIER_INDICATOR(std::string* buffer,
+                                                  TPM_MODIFIER_INDICATOR* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_AUTHORIZATION_SIZE(
+    const TPM_AUTHORIZATION_SIZE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_AUTHORIZATION_SIZE(std::string* buffer,
+                                                  TPM_AUTHORIZATION_SIZE* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_PARAMETER_SIZE(
+    const TPM_PARAMETER_SIZE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_PARAMETER_SIZE(std::string* buffer,
+                                              TPM_PARAMETER_SIZE* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_KEY_SIZE(const TPM_KEY_SIZE& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_KEY_SIZE(std::string* buffer,
+                                        TPM_KEY_SIZE* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_KEY_BITS(const TPM_KEY_BITS& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_KEY_BITS(std::string* buffer,
+                                        TPM_KEY_BITS* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_HANDLE(const TPM_HANDLE& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_HANDLE(std::string* buffer,
+                                      TPM_HANDLE* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_NONCE(const TPM2B_NONCE& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_NONCE(std::string* buffer,
+                                       TPM2B_NONCE* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_AUTH(const TPM2B_AUTH& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_AUTH(std::string* buffer,
+                                      TPM2B_AUTH* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_OPERAND(const TPM2B_OPERAND& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_OPERAND(std::string* buffer,
+                                         TPM2B_OPERAND* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_HMAC(const TPMS_SCHEME_HMAC& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_HMAC(std::string* buffer,
+                                            TPMS_SCHEME_HMAC* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_RSASSA(
+    const TPMS_SCHEME_RSASSA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_RSASSA(std::string* buffer,
+                                              TPMS_SCHEME_RSASSA* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_RSAPSS(
+    const TPMS_SCHEME_RSAPSS& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_RSAPSS(std::string* buffer,
+                                              TPMS_SCHEME_RSAPSS* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_ECDSA(const TPMS_SCHEME_ECDSA& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_ECDSA(std::string* buffer,
+                                             TPMS_SCHEME_ECDSA* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_SM2(const TPMS_SCHEME_SM2& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_SM2(std::string* buffer,
+                                           TPMS_SCHEME_SM2* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_ECSCHNORR(
+    const TPMS_SCHEME_ECSCHNORR& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_ECSCHNORR(std::string* buffer,
+                                                 TPMS_SCHEME_ECSCHNORR* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_YES_NO(const TPMI_YES_NO& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_YES_NO(std::string* buffer,
+                                       TPMI_YES_NO* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_DH_OBJECT(const TPMI_DH_OBJECT& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_DH_OBJECT(std::string* buffer,
+                                          TPMI_DH_OBJECT* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_DH_PERSISTENT(
+    const TPMI_DH_PERSISTENT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_DH_PERSISTENT(std::string* buffer,
+                                              TPMI_DH_PERSISTENT* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_DH_ENTITY(const TPMI_DH_ENTITY& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_DH_ENTITY(std::string* buffer,
+                                          TPMI_DH_ENTITY* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_DH_PCR(const TPMI_DH_PCR& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_DH_PCR(std::string* buffer,
+                                       TPMI_DH_PCR* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_SH_AUTH_SESSION(
+    const TPMI_SH_AUTH_SESSION& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_SH_AUTH_SESSION(std::string* buffer,
+                                                TPMI_SH_AUTH_SESSION* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_SH_HMAC(const TPMI_SH_HMAC& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_SH_HMAC(std::string* buffer,
+                                        TPMI_SH_HMAC* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_SH_POLICY(const TPMI_SH_POLICY& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_SH_POLICY(std::string* buffer,
+                                          TPMI_SH_POLICY* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_DH_CONTEXT(const TPMI_DH_CONTEXT& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_DH_CONTEXT(std::string* buffer,
+                                           TPMI_DH_CONTEXT* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_HIERARCHY(const TPMI_RH_HIERARCHY& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_HIERARCHY(std::string* buffer,
+                                             TPMI_RH_HIERARCHY* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_ENABLES(const TPMI_RH_ENABLES& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_ENABLES(std::string* buffer,
+                                           TPMI_RH_ENABLES* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_HIERARCHY_AUTH(
+    const TPMI_RH_HIERARCHY_AUTH& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_HIERARCHY_AUTH(std::string* buffer,
+                                                  TPMI_RH_HIERARCHY_AUTH* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_PLATFORM(const TPMI_RH_PLATFORM& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_PLATFORM(std::string* buffer,
+                                            TPMI_RH_PLATFORM* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_OWNER(const TPMI_RH_OWNER& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_OWNER(std::string* buffer,
+                                         TPMI_RH_OWNER* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_ENDORSEMENT(
+    const TPMI_RH_ENDORSEMENT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_ENDORSEMENT(std::string* buffer,
+                                               TPMI_RH_ENDORSEMENT* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_PROVISION(const TPMI_RH_PROVISION& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_PROVISION(std::string* buffer,
+                                             TPMI_RH_PROVISION* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_CLEAR(const TPMI_RH_CLEAR& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_CLEAR(std::string* buffer,
+                                         TPMI_RH_CLEAR* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_NV_AUTH(const TPMI_RH_NV_AUTH& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_NV_AUTH(std::string* buffer,
+                                           TPMI_RH_NV_AUTH* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_LOCKOUT(const TPMI_RH_LOCKOUT& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_LOCKOUT(std::string* buffer,
+                                           TPMI_RH_LOCKOUT* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RH_NV_INDEX(const TPMI_RH_NV_INDEX& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RH_NV_INDEX(std::string* buffer,
+                                            TPMI_RH_NV_INDEX* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_HASH(const TPMI_ALG_HASH& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_HASH(std::string* buffer,
+                                         TPMI_ALG_HASH* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_ASYM(const TPMI_ALG_ASYM& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_ASYM(std::string* buffer,
+                                         TPMI_ALG_ASYM* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_SYM(const TPMI_ALG_SYM& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_SYM(std::string* buffer,
+                                        TPMI_ALG_SYM* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_SYM_OBJECT(
+    const TPMI_ALG_SYM_OBJECT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_SYM_OBJECT(std::string* buffer,
+                                               TPMI_ALG_SYM_OBJECT* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_SYM_MODE(const TPMI_ALG_SYM_MODE& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_SYM_MODE(std::string* buffer,
+                                             TPMI_ALG_SYM_MODE* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_KDF(const TPMI_ALG_KDF& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_KDF(std::string* buffer,
+                                        TPMI_ALG_KDF* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_SIG_SCHEME(
+    const TPMI_ALG_SIG_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_SIG_SCHEME(std::string* buffer,
+                                               TPMI_ALG_SIG_SCHEME* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ECC_KEY_EXCHANGE(
+    const TPMI_ECC_KEY_EXCHANGE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ECC_KEY_EXCHANGE(std::string* buffer,
+                                                 TPMI_ECC_KEY_EXCHANGE* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ST_COMMAND_TAG(
+    const TPMI_ST_COMMAND_TAG& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ST_COMMAND_TAG(std::string* buffer,
+                                               TPMI_ST_COMMAND_TAG* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ST_ATTEST(const TPMI_ST_ATTEST& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ST_ATTEST(std::string* buffer,
+                                          TPMI_ST_ATTEST* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_AES_KEY_BITS(const TPMI_AES_KEY_BITS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_AES_KEY_BITS(std::string* buffer,
+                                             TPMI_AES_KEY_BITS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_SM4_KEY_BITS(const TPMI_SM4_KEY_BITS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_SM4_KEY_BITS(std::string* buffer,
+                                             TPMI_SM4_KEY_BITS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_KEYEDHASH_SCHEME(
+    const TPMI_ALG_KEYEDHASH_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMI_ALG_KEYEDHASH_SCHEME(std::string* buffer,
+                                TPMI_ALG_KEYEDHASH_SCHEME* value,
+                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_ASYM_SCHEME(
+    const TPMI_ALG_ASYM_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_ASYM_SCHEME(std::string* buffer,
+                                                TPMI_ALG_ASYM_SCHEME* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_RSA_SCHEME(
+    const TPMI_ALG_RSA_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_RSA_SCHEME(std::string* buffer,
+                                               TPMI_ALG_RSA_SCHEME* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_RSA_DECRYPT(
+    const TPMI_ALG_RSA_DECRYPT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_RSA_DECRYPT(std::string* buffer,
+                                                TPMI_ALG_RSA_DECRYPT* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_RSA_KEY_BITS(const TPMI_RSA_KEY_BITS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_RSA_KEY_BITS(std::string* buffer,
+                                             TPMI_RSA_KEY_BITS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_ECC_SCHEME(
+    const TPMI_ALG_ECC_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_ECC_SCHEME(std::string* buffer,
+                                               TPMI_ALG_ECC_SCHEME* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ECC_CURVE(const TPMI_ECC_CURVE& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ECC_CURVE(std::string* buffer,
+                                          TPMI_ECC_CURVE* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMI_ALG_PUBLIC(const TPMI_ALG_PUBLIC& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMI_ALG_PUBLIC(std::string* buffer,
+                                           TPMI_ALG_PUBLIC* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_ALGORITHM(const TPMA_ALGORITHM& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_ALGORITHM(std::string* buffer,
+                                          TPMA_ALGORITHM* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_OBJECT(const TPMA_OBJECT& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_OBJECT(std::string* buffer,
+                                       TPMA_OBJECT* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_SESSION(const TPMA_SESSION& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_SESSION(std::string* buffer,
+                                        TPMA_SESSION* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_LOCALITY(const TPMA_LOCALITY& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_LOCALITY(std::string* buffer,
+                                         TPMA_LOCALITY* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_PERMANENT(const TPMA_PERMANENT& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_PERMANENT(std::string* buffer,
+                                          TPMA_PERMANENT* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_STARTUP_CLEAR(
+    const TPMA_STARTUP_CLEAR& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_STARTUP_CLEAR(std::string* buffer,
+                                              TPMA_STARTUP_CLEAR* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_MEMORY(const TPMA_MEMORY& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_MEMORY(std::string* buffer,
+                                       TPMA_MEMORY* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_CC(const TPMA_CC& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_CC(std::string* buffer,
+                                   TPMA_CC* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_NV_INDEX(const TPM_NV_INDEX& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_NV_INDEX(std::string* buffer,
+                                        TPM_NV_INDEX* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMA_NV(const TPMA_NV& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMA_NV(std::string* buffer,
+                                   TPMA_NV* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_SPEC(const TPM_SPEC& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_SPEC(std::string* buffer,
+                                    TPM_SPEC* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_GENERATED(const TPM_GENERATED& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_GENERATED(std::string* buffer,
+                                         TPM_GENERATED* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_ALG_ID(const TPM_ALG_ID& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_ALG_ID(std::string* buffer,
+                                      TPM_ALG_ID* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_ECC_CURVE(const TPM_ECC_CURVE& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_ECC_CURVE(std::string* buffer,
+                                         TPM_ECC_CURVE* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_CC(const TPM_CC& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_CC(std::string* buffer,
+                                  TPM_CC* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_RC(const TPM_RC& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_RC(std::string* buffer,
+                                  TPM_RC* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_CLOCK_ADJUST(const TPM_CLOCK_ADJUST& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_CLOCK_ADJUST(std::string* buffer,
+                                            TPM_CLOCK_ADJUST* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_EO(const TPM_EO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_EO(std::string* buffer,
+                                  TPM_EO* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_ST(const TPM_ST& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_ST(std::string* buffer,
+                                  TPM_ST* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_SU(const TPM_SU& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_SU(std::string* buffer,
+                                  TPM_SU* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_SE(const TPM_SE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_SE(std::string* buffer,
+                                  TPM_SE* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_CAP(const TPM_CAP& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_CAP(std::string* buffer,
+                                   TPM_CAP* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_PT(const TPM_PT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_PT(std::string* buffer,
+                                  TPM_PT* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_PT_PCR(const TPM_PT_PCR& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_PT_PCR(std::string* buffer,
+                                      TPM_PT_PCR* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_PS(const TPM_PS& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_PS(std::string* buffer,
+                                  TPM_PS* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_HT(const TPM_HT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_HT(std::string* buffer,
+                                  TPM_HT* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_RH(const TPM_RH& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_RH(std::string* buffer,
+                                  TPM_RH* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM_HC(const TPM_HC& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM_HC(std::string* buffer,
+                                  TPM_HC* value,
+                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ALGORITHM_DESCRIPTION(
+    const TPMS_ALGORITHM_DESCRIPTION& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_ALGORITHM_DESCRIPTION(std::string* buffer,
+                                 TPMS_ALGORITHM_DESCRIPTION* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_HA(const TPMT_HA& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_HA(std::string* buffer,
+                                   TPMT_HA* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_DIGEST(const TPM2B_DIGEST& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_DIGEST(std::string* buffer,
+                                        TPM2B_DIGEST* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_DIGEST Make_TPM2B_DIGEST(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_DIGEST(const TPM2B_DIGEST& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_DATA(const TPM2B_DATA& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_DATA(std::string* buffer,
+                                      TPM2B_DATA* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_DATA Make_TPM2B_DATA(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_DATA(const TPM2B_DATA& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_EVENT(const TPM2B_EVENT& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_EVENT(std::string* buffer,
+                                       TPM2B_EVENT* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_EVENT Make_TPM2B_EVENT(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_EVENT(const TPM2B_EVENT& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_MAX_BUFFER(const TPM2B_MAX_BUFFER& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_MAX_BUFFER(std::string* buffer,
+                                            TPM2B_MAX_BUFFER* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_MAX_BUFFER Make_TPM2B_MAX_BUFFER(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_MAX_BUFFER(
+    const TPM2B_MAX_BUFFER& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_MAX_NV_BUFFER(
+    const TPM2B_MAX_NV_BUFFER& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_MAX_NV_BUFFER(std::string* buffer,
+                                               TPM2B_MAX_NV_BUFFER* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_MAX_NV_BUFFER
+Make_TPM2B_MAX_NV_BUFFER(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_MAX_NV_BUFFER(
+    const TPM2B_MAX_NV_BUFFER& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_TIMEOUT(const TPM2B_TIMEOUT& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_TIMEOUT(std::string* buffer,
+                                         TPM2B_TIMEOUT* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_TIMEOUT Make_TPM2B_TIMEOUT(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_TIMEOUT(const TPM2B_TIMEOUT& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_IV(const TPM2B_IV& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_IV(std::string* buffer,
+                                    TPM2B_IV* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_IV Make_TPM2B_IV(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_IV(const TPM2B_IV& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_NAME(const TPM2B_NAME& value,
+                                          std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_NAME(std::string* buffer,
+                                      TPM2B_NAME* value,
+                                      std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_NAME Make_TPM2B_NAME(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_NAME(const TPM2B_NAME& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_PCR_SELECT(const TPMS_PCR_SELECT& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_PCR_SELECT(std::string* buffer,
+                                           TPMS_PCR_SELECT* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_PCR_SELECTION(
+    const TPMS_PCR_SELECTION& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_PCR_SELECTION(std::string* buffer,
+                                              TPMS_PCR_SELECTION* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_TK_CREATION(const TPMT_TK_CREATION& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_TK_CREATION(std::string* buffer,
+                                            TPMT_TK_CREATION* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_TK_VERIFIED(const TPMT_TK_VERIFIED& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_TK_VERIFIED(std::string* buffer,
+                                            TPMT_TK_VERIFIED* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_TK_AUTH(const TPMT_TK_AUTH& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_TK_AUTH(std::string* buffer,
+                                        TPMT_TK_AUTH* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_TK_HASHCHECK(const TPMT_TK_HASHCHECK& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_TK_HASHCHECK(std::string* buffer,
+                                             TPMT_TK_HASHCHECK* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ALG_PROPERTY(const TPMS_ALG_PROPERTY& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_ALG_PROPERTY(std::string* buffer,
+                                             TPMS_ALG_PROPERTY* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_TAGGED_PROPERTY(
+    const TPMS_TAGGED_PROPERTY& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_TAGGED_PROPERTY(std::string* buffer,
+                                                TPMS_TAGGED_PROPERTY* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_TAGGED_PCR_SELECT(
+    const TPMS_TAGGED_PCR_SELECT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_TAGGED_PCR_SELECT(std::string* buffer,
+                                                  TPMS_TAGGED_PCR_SELECT* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_CC(const TPML_CC& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_CC(std::string* buffer,
+                                   TPML_CC* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_CCA(const TPML_CCA& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_CCA(std::string* buffer,
+                                    TPML_CCA* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_ALG(const TPML_ALG& value,
+                                        std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_ALG(std::string* buffer,
+                                    TPML_ALG* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_HANDLE(const TPML_HANDLE& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_HANDLE(std::string* buffer,
+                                       TPML_HANDLE* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_DIGEST(const TPML_DIGEST& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_DIGEST(std::string* buffer,
+                                       TPML_DIGEST* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_DIGEST_VALUES(
+    const TPML_DIGEST_VALUES& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_DIGEST_VALUES(std::string* buffer,
+                                              TPML_DIGEST_VALUES* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_DIGEST_VALUES(
+    const TPM2B_DIGEST_VALUES& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_DIGEST_VALUES(std::string* buffer,
+                                               TPM2B_DIGEST_VALUES* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_DIGEST_VALUES
+Make_TPM2B_DIGEST_VALUES(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_DIGEST_VALUES(
+    const TPM2B_DIGEST_VALUES& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_PCR_SELECTION(
+    const TPML_PCR_SELECTION& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_PCR_SELECTION(std::string* buffer,
+                                              TPML_PCR_SELECTION* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_ALG_PROPERTY(const TPML_ALG_PROPERTY& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_ALG_PROPERTY(std::string* buffer,
+                                             TPML_ALG_PROPERTY* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_TAGGED_TPM_PROPERTY(
+    const TPML_TAGGED_TPM_PROPERTY& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPML_TAGGED_TPM_PROPERTY(std::string* buffer,
+                               TPML_TAGGED_TPM_PROPERTY* value,
+                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_TAGGED_PCR_PROPERTY(
+    const TPML_TAGGED_PCR_PROPERTY& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPML_TAGGED_PCR_PROPERTY(std::string* buffer,
+                               TPML_TAGGED_PCR_PROPERTY* value,
+                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPML_ECC_CURVE(const TPML_ECC_CURVE& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPML_ECC_CURVE(std::string* buffer,
+                                          TPML_ECC_CURVE* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CAPABILITY_DATA(
+    const TPMS_CAPABILITY_DATA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CAPABILITY_DATA(std::string* buffer,
+                                                TPMS_CAPABILITY_DATA* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CLOCK_INFO(const TPMS_CLOCK_INFO& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CLOCK_INFO(std::string* buffer,
+                                           TPMS_CLOCK_INFO* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_TIME_INFO(const TPMS_TIME_INFO& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_TIME_INFO(std::string* buffer,
+                                          TPMS_TIME_INFO* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_TIME_ATTEST_INFO(
+    const TPMS_TIME_ATTEST_INFO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_TIME_ATTEST_INFO(std::string* buffer,
+                                                 TPMS_TIME_ATTEST_INFO* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CERTIFY_INFO(const TPMS_CERTIFY_INFO& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CERTIFY_INFO(std::string* buffer,
+                                             TPMS_CERTIFY_INFO* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_QUOTE_INFO(const TPMS_QUOTE_INFO& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_QUOTE_INFO(std::string* buffer,
+                                           TPMS_QUOTE_INFO* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_COMMAND_AUDIT_INFO(
+    const TPMS_COMMAND_AUDIT_INFO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_COMMAND_AUDIT_INFO(std::string* buffer,
+                              TPMS_COMMAND_AUDIT_INFO* value,
+                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SESSION_AUDIT_INFO(
+    const TPMS_SESSION_AUDIT_INFO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_SESSION_AUDIT_INFO(std::string* buffer,
+                              TPMS_SESSION_AUDIT_INFO* value,
+                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CREATION_INFO(
+    const TPMS_CREATION_INFO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CREATION_INFO(std::string* buffer,
+                                              TPMS_CREATION_INFO* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_NV_CERTIFY_INFO(
+    const TPMS_NV_CERTIFY_INFO& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_NV_CERTIFY_INFO(std::string* buffer,
+                                                TPMS_NV_CERTIFY_INFO* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ATTEST(const TPMS_ATTEST& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_ATTEST(std::string* buffer,
+                                       TPMS_ATTEST* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_ATTEST(const TPM2B_ATTEST& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_ATTEST(std::string* buffer,
+                                        TPM2B_ATTEST* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_ATTEST Make_TPM2B_ATTEST(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_ATTEST(const TPM2B_ATTEST& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_AUTH_COMMAND(const TPMS_AUTH_COMMAND& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_AUTH_COMMAND(std::string* buffer,
+                                             TPMS_AUTH_COMMAND* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_AUTH_RESPONSE(
+    const TPMS_AUTH_RESPONSE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_AUTH_RESPONSE(std::string* buffer,
+                                              TPMS_AUTH_RESPONSE* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_SYM_DEF(const TPMT_SYM_DEF& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_SYM_DEF(std::string* buffer,
+                                        TPMT_SYM_DEF* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_SYM_DEF_OBJECT(
+    const TPMT_SYM_DEF_OBJECT& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_SYM_DEF_OBJECT(std::string* buffer,
+                                               TPMT_SYM_DEF_OBJECT* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_SYM_KEY(const TPM2B_SYM_KEY& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_SYM_KEY(std::string* buffer,
+                                         TPM2B_SYM_KEY* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_SYM_KEY Make_TPM2B_SYM_KEY(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_SYM_KEY(const TPM2B_SYM_KEY& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SYMCIPHER_PARMS(
+    const TPMS_SYMCIPHER_PARMS& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SYMCIPHER_PARMS(std::string* buffer,
+                                                TPMS_SYMCIPHER_PARMS* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_SENSITIVE_DATA(
+    const TPM2B_SENSITIVE_DATA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_SENSITIVE_DATA(std::string* buffer,
+                                                TPM2B_SENSITIVE_DATA* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_SENSITIVE_DATA
+Make_TPM2B_SENSITIVE_DATA(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_SENSITIVE_DATA(
+    const TPM2B_SENSITIVE_DATA& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SENSITIVE_CREATE(
+    const TPMS_SENSITIVE_CREATE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SENSITIVE_CREATE(std::string* buffer,
+                                                 TPMS_SENSITIVE_CREATE* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_SENSITIVE_CREATE(
+    const TPM2B_SENSITIVE_CREATE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_SENSITIVE_CREATE(std::string* buffer,
+                                                  TPM2B_SENSITIVE_CREATE* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_SENSITIVE_CREATE
+Make_TPM2B_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_SIGHASH(
+    const TPMS_SCHEME_SIGHASH& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_SIGHASH(std::string* buffer,
+                                               TPMS_SCHEME_SIGHASH* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_XOR(const TPMS_SCHEME_XOR& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_XOR(std::string* buffer,
+                                           TPMS_SCHEME_XOR* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_KEYEDHASH_SCHEME(
+    const TPMT_KEYEDHASH_SCHEME& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_KEYEDHASH_SCHEME(std::string* buffer,
+                                                 TPMT_KEYEDHASH_SCHEME* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_ECDAA(const TPMS_SCHEME_ECDAA& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_ECDAA(std::string* buffer,
+                                             TPMS_SCHEME_ECDAA* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_SIG_SCHEME(const TPMT_SIG_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_SIG_SCHEME(std::string* buffer,
+                                           TPMT_SIG_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_OAEP(const TPMS_SCHEME_OAEP& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_OAEP(std::string* buffer,
+                                            TPMS_SCHEME_OAEP* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_ECDH(const TPMS_SCHEME_ECDH& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_ECDH(std::string* buffer,
+                                            TPMS_SCHEME_ECDH* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_MGF1(const TPMS_SCHEME_MGF1& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_MGF1(std::string* buffer,
+                                            TPMS_SCHEME_MGF1* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_KDF1_SP800_56a(
+    const TPMS_SCHEME_KDF1_SP800_56a& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_SCHEME_KDF1_SP800_56a(std::string* buffer,
+                                 TPMS_SCHEME_KDF1_SP800_56a* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_KDF2(const TPMS_SCHEME_KDF2& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SCHEME_KDF2(std::string* buffer,
+                                            TPMS_SCHEME_KDF2* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SCHEME_KDF1_SP800_108(
+    const TPMS_SCHEME_KDF1_SP800_108& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_SCHEME_KDF1_SP800_108(std::string* buffer,
+                                 TPMS_SCHEME_KDF1_SP800_108* value,
+                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_KDF_SCHEME(const TPMT_KDF_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_KDF_SCHEME(std::string* buffer,
+                                           TPMT_KDF_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_ASYM_SCHEME(const TPMT_ASYM_SCHEME& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_ASYM_SCHEME(std::string* buffer,
+                                            TPMT_ASYM_SCHEME* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_RSA_SCHEME(const TPMT_RSA_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_RSA_SCHEME(std::string* buffer,
+                                           TPMT_RSA_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_RSA_DECRYPT(const TPMT_RSA_DECRYPT& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_RSA_DECRYPT(std::string* buffer,
+                                            TPMT_RSA_DECRYPT* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_PUBLIC_KEY_RSA(
+    const TPM2B_PUBLIC_KEY_RSA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_PUBLIC_KEY_RSA(std::string* buffer,
+                                                TPM2B_PUBLIC_KEY_RSA* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_PUBLIC_KEY_RSA
+Make_TPM2B_PUBLIC_KEY_RSA(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_PUBLIC_KEY_RSA(
+    const TPM2B_PUBLIC_KEY_RSA& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_PRIVATE_KEY_RSA(
+    const TPM2B_PRIVATE_KEY_RSA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_PRIVATE_KEY_RSA(std::string* buffer,
+                                                 TPM2B_PRIVATE_KEY_RSA* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_PRIVATE_KEY_RSA
+Make_TPM2B_PRIVATE_KEY_RSA(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_PRIVATE_KEY_RSA(
+    const TPM2B_PRIVATE_KEY_RSA& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_ECC_PARAMETER(
+    const TPM2B_ECC_PARAMETER& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_ECC_PARAMETER(std::string* buffer,
+                                               TPM2B_ECC_PARAMETER* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_ECC_PARAMETER
+Make_TPM2B_ECC_PARAMETER(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_ECC_PARAMETER(
+    const TPM2B_ECC_PARAMETER& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ECC_POINT(const TPMS_ECC_POINT& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_ECC_POINT(std::string* buffer,
+                                          TPMS_ECC_POINT* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_ECC_POINT(const TPM2B_ECC_POINT& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_ECC_POINT(std::string* buffer,
+                                           TPM2B_ECC_POINT* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_ECC_POINT Make_TPM2B_ECC_POINT(const TPMS_ECC_POINT& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_ECC_SCHEME(const TPMT_ECC_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_ECC_SCHEME(std::string* buffer,
+                                           TPMT_ECC_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ALGORITHM_DETAIL_ECC(
+    const TPMS_ALGORITHM_DETAIL_ECC& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMS_ALGORITHM_DETAIL_ECC(std::string* buffer,
+                                TPMS_ALGORITHM_DETAIL_ECC* value,
+                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SIGNATURE_RSASSA(
+    const TPMS_SIGNATURE_RSASSA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SIGNATURE_RSASSA(std::string* buffer,
+                                                 TPMS_SIGNATURE_RSASSA* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SIGNATURE_RSAPSS(
+    const TPMS_SIGNATURE_RSAPSS& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SIGNATURE_RSAPSS(std::string* buffer,
+                                                 TPMS_SIGNATURE_RSAPSS* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_SIGNATURE_ECDSA(
+    const TPMS_SIGNATURE_ECDSA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_SIGNATURE_ECDSA(std::string* buffer,
+                                                TPMS_SIGNATURE_ECDSA* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_SIGNATURE(const TPMT_SIGNATURE& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_SIGNATURE(std::string* buffer,
+                                          TPMT_SIGNATURE* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_ENCRYPTED_SECRET(
+    const TPM2B_ENCRYPTED_SECRET& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_ENCRYPTED_SECRET(std::string* buffer,
+                                                  TPM2B_ENCRYPTED_SECRET* value,
+                                                  std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_ENCRYPTED_SECRET
+Make_TPM2B_ENCRYPTED_SECRET(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_ENCRYPTED_SECRET(
+    const TPM2B_ENCRYPTED_SECRET& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_KEYEDHASH_PARMS(
+    const TPMS_KEYEDHASH_PARMS& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_KEYEDHASH_PARMS(std::string* buffer,
+                                                TPMS_KEYEDHASH_PARMS* value,
+                                                std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ASYM_PARMS(const TPMS_ASYM_PARMS& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_ASYM_PARMS(std::string* buffer,
+                                           TPMS_ASYM_PARMS* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_RSA_PARMS(const TPMS_RSA_PARMS& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_RSA_PARMS(std::string* buffer,
+                                          TPMS_RSA_PARMS* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_ECC_PARMS(const TPMS_ECC_PARMS& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_ECC_PARMS(std::string* buffer,
+                                          TPMS_ECC_PARMS* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_PUBLIC_PARMS(const TPMT_PUBLIC_PARMS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_PUBLIC_PARMS(std::string* buffer,
+                                             TPMT_PUBLIC_PARMS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_PUBLIC(const TPMT_PUBLIC& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_PUBLIC(std::string* buffer,
+                                       TPMT_PUBLIC* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_PUBLIC(const TPM2B_PUBLIC& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_PUBLIC(std::string* buffer,
+                                        TPM2B_PUBLIC* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_PUBLIC Make_TPM2B_PUBLIC(const TPMT_PUBLIC& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_PRIVATE_VENDOR_SPECIFIC(
+    const TPM2B_PRIVATE_VENDOR_SPECIFIC& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPM2B_PRIVATE_VENDOR_SPECIFIC(std::string* buffer,
+                                    TPM2B_PRIVATE_VENDOR_SPECIFIC* value,
+                                    std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_PRIVATE_VENDOR_SPECIFIC
+Make_TPM2B_PRIVATE_VENDOR_SPECIFIC(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_PRIVATE_VENDOR_SPECIFIC(
+    const TPM2B_PRIVATE_VENDOR_SPECIFIC& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMT_SENSITIVE(const TPMT_SENSITIVE& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMT_SENSITIVE(std::string* buffer,
+                                          TPMT_SENSITIVE* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_SENSITIVE(const TPM2B_SENSITIVE& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_SENSITIVE(std::string* buffer,
+                                           TPM2B_SENSITIVE* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_SENSITIVE Make_TPM2B_SENSITIVE(const TPMT_SENSITIVE& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_PRIVATE(const TPM2B_PRIVATE& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_PRIVATE(std::string* buffer,
+                                         TPM2B_PRIVATE* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_PRIVATE Make_TPM2B_PRIVATE(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_PRIVATE(const TPM2B_PRIVATE& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_ID_OBJECT(const TPM2B_ID_OBJECT& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_ID_OBJECT(std::string* buffer,
+                                           TPM2B_ID_OBJECT* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_ID_OBJECT Make_TPM2B_ID_OBJECT(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_ID_OBJECT(
+    const TPM2B_ID_OBJECT& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_NV_PUBLIC(const TPMS_NV_PUBLIC& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_NV_PUBLIC(std::string* buffer,
+                                          TPMS_NV_PUBLIC* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_NV_PUBLIC(const TPM2B_NV_PUBLIC& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_NV_PUBLIC(std::string* buffer,
+                                           TPM2B_NV_PUBLIC* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_NV_PUBLIC Make_TPM2B_NV_PUBLIC(const TPMS_NV_PUBLIC& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_CONTEXT_SENSITIVE(
+    const TPM2B_CONTEXT_SENSITIVE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPM2B_CONTEXT_SENSITIVE(std::string* buffer,
+                              TPM2B_CONTEXT_SENSITIVE* value,
+                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_CONTEXT_SENSITIVE
+Make_TPM2B_CONTEXT_SENSITIVE(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_CONTEXT_SENSITIVE(
+    const TPM2B_CONTEXT_SENSITIVE& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CONTEXT_DATA(const TPMS_CONTEXT_DATA& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CONTEXT_DATA(std::string* buffer,
+                                             TPMS_CONTEXT_DATA* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_CONTEXT_DATA(
+    const TPM2B_CONTEXT_DATA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_CONTEXT_DATA(std::string* buffer,
+                                              TPM2B_CONTEXT_DATA* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_CONTEXT_DATA
+Make_TPM2B_CONTEXT_DATA(const std::string& bytes);
+TRUNKS_EXPORT std::string StringFrom_TPM2B_CONTEXT_DATA(
+    const TPM2B_CONTEXT_DATA& tpm2b);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CONTEXT(const TPMS_CONTEXT& value,
+                                            std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CONTEXT(std::string* buffer,
+                                        TPMS_CONTEXT* value,
+                                        std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMS_CREATION_DATA(
+    const TPMS_CREATION_DATA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMS_CREATION_DATA(std::string* buffer,
+                                              TPMS_CREATION_DATA* value,
+                                              std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPM2B_CREATION_DATA(
+    const TPM2B_CREATION_DATA& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPM2B_CREATION_DATA(std::string* buffer,
+                                               TPM2B_CREATION_DATA* value,
+                                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM2B_CREATION_DATA
+Make_TPM2B_CREATION_DATA(const TPMS_CREATION_DATA& inner);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_HA(const TPMU_HA& value,
+                                       std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_HA(std::string* buffer,
+                                   TPMU_HA* value,
+                                   std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_NAME(const TPMU_NAME& value,
+                                         std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_NAME(std::string* buffer,
+                                     TPMU_NAME* value,
+                                     std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_CAPABILITIES(const TPMU_CAPABILITIES& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_CAPABILITIES(std::string* buffer,
+                                             TPMU_CAPABILITIES* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_ATTEST(const TPMU_ATTEST& value,
+                                           std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_ATTEST(std::string* buffer,
+                                       TPMU_ATTEST* value,
+                                       std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SYM_KEY_BITS(const TPMU_SYM_KEY_BITS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SYM_KEY_BITS(std::string* buffer,
+                                             TPMU_SYM_KEY_BITS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SYM_MODE(const TPMU_SYM_MODE& value,
+                                             std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SYM_MODE(std::string* buffer,
+                                         TPMU_SYM_MODE* value,
+                                         std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SCHEME_KEYEDHASH(
+    const TPMU_SCHEME_KEYEDHASH& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SCHEME_KEYEDHASH(std::string* buffer,
+                                                 TPMU_SCHEME_KEYEDHASH* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SIG_SCHEME(const TPMU_SIG_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SIG_SCHEME(std::string* buffer,
+                                           TPMU_SIG_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_KDF_SCHEME(const TPMU_KDF_SCHEME& value,
+                                               std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_KDF_SCHEME(std::string* buffer,
+                                           TPMU_KDF_SCHEME* value,
+                                           std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_ASYM_SCHEME(const TPMU_ASYM_SCHEME& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_ASYM_SCHEME(std::string* buffer,
+                                            TPMU_ASYM_SCHEME* value,
+                                            std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SIGNATURE(const TPMU_SIGNATURE& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SIGNATURE(std::string* buffer,
+                                          TPMU_SIGNATURE* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_ENCRYPTED_SECRET(
+    const TPMU_ENCRYPTED_SECRET& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_ENCRYPTED_SECRET(std::string* buffer,
+                                                 TPMU_ENCRYPTED_SECRET* value,
+                                                 std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_PUBLIC_ID(const TPMU_PUBLIC_ID& value,
+                                              std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_PUBLIC_ID(std::string* buffer,
+                                          TPMU_PUBLIC_ID* value,
+                                          std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_PUBLIC_PARMS(const TPMU_PUBLIC_PARMS& value,
+                                                 std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_PUBLIC_PARMS(std::string* buffer,
+                                             TPMU_PUBLIC_PARMS* value,
+                                             std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SENSITIVE_COMPOSITE(
+    const TPMU_SENSITIVE_COMPOSITE& value, std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC
+Parse_TPMU_SENSITIVE_COMPOSITE(std::string* buffer,
+                               TPMU_SENSITIVE_COMPOSITE* value,
+                               std::string* value_bytes);
+
+TRUNKS_EXPORT TPM_RC Serialize_TPMU_SYM_DETAILS(const TPMU_SYM_DETAILS& value,
+                                                std::string* buffer);
+
+TRUNKS_EXPORT TPM_RC Parse_TPMU_SYM_DETAILS(std::string* buffer,
+                                            TPMU_SYM_DETAILS* value,
+                                            std::string* value_bytes);
+
+class TRUNKS_EXPORT Tpm {
+ public:
+  // Does not take ownership of |transceiver|.
+  explicit Tpm(CommandTransceiver* transceiver) : transceiver_(transceiver) {}
+  Tpm(const Tpm&) = delete;
+  Tpm& operator=(const Tpm&) = delete;
+
+  virtual ~Tpm() {}
+  CommandTransceiver* get_transceiver() { return transceiver_; }
+
+  typedef base::OnceCallback<void(TPM_RC response_code)> StartupResponse;
+  static TPM_RC SerializeCommand_Startup(
+      const TPM_SU& startup_type,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Startup(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Startup(const TPM_SU& startup_type,
+                       AuthorizationDelegate* authorization_delegate,
+                       StartupResponse callback);
+  virtual TPM_RC StartupSync(const TPM_SU& startup_type,
+                             AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ShutdownResponse;
+  static TPM_RC SerializeCommand_Shutdown(
+      const TPM_SU& shutdown_type,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Shutdown(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Shutdown(const TPM_SU& shutdown_type,
+                        AuthorizationDelegate* authorization_delegate,
+                        ShutdownResponse callback);
+  virtual TPM_RC ShutdownSync(const TPM_SU& shutdown_type,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> SelfTestResponse;
+  static TPM_RC SerializeCommand_SelfTest(
+      const TPMI_YES_NO& full_test,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SelfTest(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SelfTest(const TPMI_YES_NO& full_test,
+                        AuthorizationDelegate* authorization_delegate,
+                        SelfTestResponse callback);
+  virtual TPM_RC SelfTestSync(const TPMI_YES_NO& full_test,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPML_ALG& to_do_list)>
+      IncrementalSelfTestResponse;
+  static TPM_RC SerializeCommand_IncrementalSelfTest(
+      const TPML_ALG& to_test,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_IncrementalSelfTest(
+      const std::string& response,
+      TPML_ALG* to_do_list,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void IncrementalSelfTest(
+      const TPML_ALG& to_test,
+      AuthorizationDelegate* authorization_delegate,
+      IncrementalSelfTestResponse callback);
+  virtual TPM_RC IncrementalSelfTestSync(
+      const TPML_ALG& to_test,
+      TPML_ALG* to_do_list,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_MAX_BUFFER& out_data,
+                                  const TPM_RC& test_result)>
+      GetTestResultResponse;
+  static TPM_RC SerializeCommand_GetTestResult(
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetTestResult(
+      const std::string& response,
+      TPM2B_MAX_BUFFER* out_data,
+      TPM_RC* test_result,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetTestResult(AuthorizationDelegate* authorization_delegate,
+                             GetTestResultResponse callback);
+  virtual TPM_RC GetTestResultSync(
+      TPM2B_MAX_BUFFER* out_data,
+      TPM_RC* test_result,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_SH_AUTH_SESSION& session_handle,
+                                  const TPM2B_NONCE& nonce_tpm)>
+      StartAuthSessionResponse;
+  static TPM_RC SerializeCommand_StartAuthSession(
+      const TPMI_DH_OBJECT& tpm_key,
+      const std::string& tpm_key_name,
+      const TPMI_DH_ENTITY& bind,
+      const std::string& bind_name,
+      const TPM2B_NONCE& nonce_caller,
+      const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+      const TPM_SE& session_type,
+      const TPMT_SYM_DEF& symmetric,
+      const TPMI_ALG_HASH& auth_hash,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_StartAuthSession(
+      const std::string& response,
+      TPMI_SH_AUTH_SESSION* session_handle,
+      TPM2B_NONCE* nonce_tpm,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void StartAuthSession(const TPMI_DH_OBJECT& tpm_key,
+                                const std::string& tpm_key_name,
+                                const TPMI_DH_ENTITY& bind,
+                                const std::string& bind_name,
+                                const TPM2B_NONCE& nonce_caller,
+                                const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+                                const TPM_SE& session_type,
+                                const TPMT_SYM_DEF& symmetric,
+                                const TPMI_ALG_HASH& auth_hash,
+                                AuthorizationDelegate* authorization_delegate,
+                                StartAuthSessionResponse callback);
+  virtual TPM_RC StartAuthSessionSync(
+      const TPMI_DH_OBJECT& tpm_key,
+      const std::string& tpm_key_name,
+      const TPMI_DH_ENTITY& bind,
+      const std::string& bind_name,
+      const TPM2B_NONCE& nonce_caller,
+      const TPM2B_ENCRYPTED_SECRET& encrypted_salt,
+      const TPM_SE& session_type,
+      const TPMT_SYM_DEF& symmetric,
+      const TPMI_ALG_HASH& auth_hash,
+      TPMI_SH_AUTH_SESSION* session_handle,
+      TPM2B_NONCE* nonce_tpm,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyRestartResponse;
+  static TPM_RC SerializeCommand_PolicyRestart(
+      const TPMI_SH_POLICY& session_handle,
+      const std::string& session_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyRestart(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyRestart(const TPMI_SH_POLICY& session_handle,
+                             const std::string& session_handle_name,
+                             AuthorizationDelegate* authorization_delegate,
+                             PolicyRestartResponse callback);
+  virtual TPM_RC PolicyRestartSync(
+      const TPMI_SH_POLICY& session_handle,
+      const std::string& session_handle_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PRIVATE& out_private,
+                                  const TPM2B_PUBLIC& out_public,
+                                  const TPM2B_CREATION_DATA& creation_data,
+                                  const TPM2B_DIGEST& creation_hash,
+                                  const TPMT_TK_CREATION& creation_ticket)>
+      CreateResponse;
+  static TPM_RC SerializeCommand_Create(
+      const TPMI_DH_OBJECT& parent_handle,
+      const std::string& parent_handle_name,
+      const TPM2B_SENSITIVE_CREATE& in_sensitive,
+      const TPM2B_PUBLIC& in_public,
+      const TPM2B_DATA& outside_info,
+      const TPML_PCR_SELECTION& creation_pcr,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Create(
+      const std::string& response,
+      TPM2B_PRIVATE* out_private,
+      TPM2B_PUBLIC* out_public,
+      TPM2B_CREATION_DATA* creation_data,
+      TPM2B_DIGEST* creation_hash,
+      TPMT_TK_CREATION* creation_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Create(const TPMI_DH_OBJECT& parent_handle,
+                      const std::string& parent_handle_name,
+                      const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                      const TPM2B_PUBLIC& in_public,
+                      const TPM2B_DATA& outside_info,
+                      const TPML_PCR_SELECTION& creation_pcr,
+                      AuthorizationDelegate* authorization_delegate,
+                      CreateResponse callback);
+  virtual TPM_RC CreateSync(const TPMI_DH_OBJECT& parent_handle,
+                            const std::string& parent_handle_name,
+                            const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                            const TPM2B_PUBLIC& in_public,
+                            const TPM2B_DATA& outside_info,
+                            const TPML_PCR_SELECTION& creation_pcr,
+                            TPM2B_PRIVATE* out_private,
+                            TPM2B_PUBLIC* out_public,
+                            TPM2B_CREATION_DATA* creation_data,
+                            TPM2B_DIGEST* creation_hash,
+                            TPMT_TK_CREATION* creation_ticket,
+                            AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM_HANDLE& object_handle,
+                                  const TPM2B_NAME& name)>
+      LoadResponse;
+  static TPM_RC SerializeCommand_Load(
+      const TPMI_DH_OBJECT& parent_handle,
+      const std::string& parent_handle_name,
+      const TPM2B_PRIVATE& in_private,
+      const TPM2B_PUBLIC& in_public,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Load(
+      const std::string& response,
+      TPM_HANDLE* object_handle,
+      TPM2B_NAME* name,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Load(const TPMI_DH_OBJECT& parent_handle,
+                    const std::string& parent_handle_name,
+                    const TPM2B_PRIVATE& in_private,
+                    const TPM2B_PUBLIC& in_public,
+                    AuthorizationDelegate* authorization_delegate,
+                    LoadResponse callback);
+  virtual TPM_RC LoadSync(const TPMI_DH_OBJECT& parent_handle,
+                          const std::string& parent_handle_name,
+                          const TPM2B_PRIVATE& in_private,
+                          const TPM2B_PUBLIC& in_public,
+                          TPM_HANDLE* object_handle,
+                          TPM2B_NAME* name,
+                          AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM_HANDLE& object_handle,
+                                  const TPM2B_NAME& name)>
+      LoadExternalResponse;
+  static TPM_RC SerializeCommand_LoadExternal(
+      const TPM2B_SENSITIVE& in_private,
+      const TPM2B_PUBLIC& in_public,
+      const TPMI_RH_HIERARCHY& hierarchy,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_LoadExternal(
+      const std::string& response,
+      TPM_HANDLE* object_handle,
+      TPM2B_NAME* name,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void LoadExternal(const TPM2B_SENSITIVE& in_private,
+                            const TPM2B_PUBLIC& in_public,
+                            const TPMI_RH_HIERARCHY& hierarchy,
+                            AuthorizationDelegate* authorization_delegate,
+                            LoadExternalResponse callback);
+  virtual TPM_RC LoadExternalSync(
+      const TPM2B_SENSITIVE& in_private,
+      const TPM2B_PUBLIC& in_public,
+      const TPMI_RH_HIERARCHY& hierarchy,
+      TPM_HANDLE* object_handle,
+      TPM2B_NAME* name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PUBLIC& out_public,
+                                  const TPM2B_NAME& name,
+                                  const TPM2B_NAME& qualified_name)>
+      ReadPublicResponse;
+  static TPM_RC SerializeCommand_ReadPublic(
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ReadPublic(
+      const std::string& response,
+      TPM2B_PUBLIC* out_public,
+      TPM2B_NAME* name,
+      TPM2B_NAME* qualified_name,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ReadPublic(const TPMI_DH_OBJECT& object_handle,
+                          const std::string& object_handle_name,
+                          AuthorizationDelegate* authorization_delegate,
+                          ReadPublicResponse callback);
+  virtual TPM_RC ReadPublicSync(const TPMI_DH_OBJECT& object_handle,
+                                const std::string& object_handle_name,
+                                TPM2B_PUBLIC* out_public,
+                                TPM2B_NAME* name,
+                                TPM2B_NAME* qualified_name,
+                                AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& cert_info)>
+      ActivateCredentialResponse;
+  static TPM_RC SerializeCommand_ActivateCredential(
+      const TPMI_DH_OBJECT& activate_handle,
+      const std::string& activate_handle_name,
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_ID_OBJECT& credential_blob,
+      const TPM2B_ENCRYPTED_SECRET& secret,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ActivateCredential(
+      const std::string& response,
+      TPM2B_DIGEST* cert_info,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ActivateCredential(const TPMI_DH_OBJECT& activate_handle,
+                                  const std::string& activate_handle_name,
+                                  const TPMI_DH_OBJECT& key_handle,
+                                  const std::string& key_handle_name,
+                                  const TPM2B_ID_OBJECT& credential_blob,
+                                  const TPM2B_ENCRYPTED_SECRET& secret,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  ActivateCredentialResponse callback);
+  virtual TPM_RC ActivateCredentialSync(
+      const TPMI_DH_OBJECT& activate_handle,
+      const std::string& activate_handle_name,
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_ID_OBJECT& credential_blob,
+      const TPM2B_ENCRYPTED_SECRET& secret,
+      TPM2B_DIGEST* cert_info,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ID_OBJECT& credential_blob,
+                                  const TPM2B_ENCRYPTED_SECRET& secret)>
+      MakeCredentialResponse;
+  static TPM_RC SerializeCommand_MakeCredential(
+      const TPMI_DH_OBJECT& handle,
+      const std::string& handle_name,
+      const TPM2B_DIGEST& credential,
+      const TPM2B_NAME& object_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_MakeCredential(
+      const std::string& response,
+      TPM2B_ID_OBJECT* credential_blob,
+      TPM2B_ENCRYPTED_SECRET* secret,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void MakeCredential(const TPMI_DH_OBJECT& handle,
+                              const std::string& handle_name,
+                              const TPM2B_DIGEST& credential,
+                              const TPM2B_NAME& object_name,
+                              AuthorizationDelegate* authorization_delegate,
+                              MakeCredentialResponse callback);
+  virtual TPM_RC MakeCredentialSync(
+      const TPMI_DH_OBJECT& handle,
+      const std::string& handle_name,
+      const TPM2B_DIGEST& credential,
+      const TPM2B_NAME& object_name,
+      TPM2B_ID_OBJECT* credential_blob,
+      TPM2B_ENCRYPTED_SECRET* secret,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_SENSITIVE_DATA& out_data)>
+      UnsealResponse;
+  static TPM_RC SerializeCommand_Unseal(
+      const TPMI_DH_OBJECT& item_handle,
+      const std::string& item_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Unseal(
+      const std::string& response,
+      TPM2B_SENSITIVE_DATA* out_data,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Unseal(const TPMI_DH_OBJECT& item_handle,
+                      const std::string& item_handle_name,
+                      AuthorizationDelegate* authorization_delegate,
+                      UnsealResponse callback);
+  virtual TPM_RC UnsealSync(const TPMI_DH_OBJECT& item_handle,
+                            const std::string& item_handle_name,
+                            TPM2B_SENSITIVE_DATA* out_data,
+                            AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PRIVATE& out_private)>
+      ObjectChangeAuthResponse;
+  static TPM_RC SerializeCommand_ObjectChangeAuth(
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_OBJECT& parent_handle,
+      const std::string& parent_handle_name,
+      const TPM2B_AUTH& new_auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ObjectChangeAuth(
+      const std::string& response,
+      TPM2B_PRIVATE* out_private,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ObjectChangeAuth(const TPMI_DH_OBJECT& object_handle,
+                                const std::string& object_handle_name,
+                                const TPMI_DH_OBJECT& parent_handle,
+                                const std::string& parent_handle_name,
+                                const TPM2B_AUTH& new_auth,
+                                AuthorizationDelegate* authorization_delegate,
+                                ObjectChangeAuthResponse callback);
+  virtual TPM_RC ObjectChangeAuthSync(
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_OBJECT& parent_handle,
+      const std::string& parent_handle_name,
+      const TPM2B_AUTH& new_auth,
+      TPM2B_PRIVATE* out_private,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DATA& encryption_key_out,
+                                  const TPM2B_PRIVATE& duplicate,
+                                  const TPM2B_ENCRYPTED_SECRET& out_sym_seed)>
+      DuplicateResponse;
+  static TPM_RC SerializeCommand_Duplicate(
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_OBJECT& new_parent_handle,
+      const std::string& new_parent_handle_name,
+      const TPM2B_DATA& encryption_key_in,
+      const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Duplicate(
+      const std::string& response,
+      TPM2B_DATA* encryption_key_out,
+      TPM2B_PRIVATE* duplicate,
+      TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Duplicate(const TPMI_DH_OBJECT& object_handle,
+                         const std::string& object_handle_name,
+                         const TPMI_DH_OBJECT& new_parent_handle,
+                         const std::string& new_parent_handle_name,
+                         const TPM2B_DATA& encryption_key_in,
+                         const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                         AuthorizationDelegate* authorization_delegate,
+                         DuplicateResponse callback);
+  virtual TPM_RC DuplicateSync(const TPMI_DH_OBJECT& object_handle,
+                               const std::string& object_handle_name,
+                               const TPMI_DH_OBJECT& new_parent_handle,
+                               const std::string& new_parent_handle_name,
+                               const TPM2B_DATA& encryption_key_in,
+                               const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                               TPM2B_DATA* encryption_key_out,
+                               TPM2B_PRIVATE* duplicate,
+                               TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PRIVATE& out_duplicate,
+                                  const TPM2B_ENCRYPTED_SECRET& out_sym_seed)>
+      RewrapResponse;
+  static TPM_RC SerializeCommand_Rewrap(
+      const TPMI_DH_OBJECT& old_parent,
+      const std::string& old_parent_name,
+      const TPMI_DH_OBJECT& new_parent,
+      const std::string& new_parent_name,
+      const TPM2B_PRIVATE& in_duplicate,
+      const TPM2B_NAME& name,
+      const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Rewrap(
+      const std::string& response,
+      TPM2B_PRIVATE* out_duplicate,
+      TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Rewrap(const TPMI_DH_OBJECT& old_parent,
+                      const std::string& old_parent_name,
+                      const TPMI_DH_OBJECT& new_parent,
+                      const std::string& new_parent_name,
+                      const TPM2B_PRIVATE& in_duplicate,
+                      const TPM2B_NAME& name,
+                      const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                      AuthorizationDelegate* authorization_delegate,
+                      RewrapResponse callback);
+  virtual TPM_RC RewrapSync(const TPMI_DH_OBJECT& old_parent,
+                            const std::string& old_parent_name,
+                            const TPMI_DH_OBJECT& new_parent,
+                            const std::string& new_parent_name,
+                            const TPM2B_PRIVATE& in_duplicate,
+                            const TPM2B_NAME& name,
+                            const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                            TPM2B_PRIVATE* out_duplicate,
+                            TPM2B_ENCRYPTED_SECRET* out_sym_seed,
+                            AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PRIVATE& out_private)>
+      ImportResponse;
+  static TPM_RC SerializeCommand_Import(
+      const TPMI_DH_OBJECT& parent_handle,
+      const std::string& parent_handle_name,
+      const TPM2B_DATA& encryption_key,
+      const TPM2B_PUBLIC& object_public,
+      const TPM2B_PRIVATE& duplicate,
+      const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+      const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Import(
+      const std::string& response,
+      TPM2B_PRIVATE* out_private,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Import(const TPMI_DH_OBJECT& parent_handle,
+                      const std::string& parent_handle_name,
+                      const TPM2B_DATA& encryption_key,
+                      const TPM2B_PUBLIC& object_public,
+                      const TPM2B_PRIVATE& duplicate,
+                      const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                      const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                      AuthorizationDelegate* authorization_delegate,
+                      ImportResponse callback);
+  virtual TPM_RC ImportSync(const TPMI_DH_OBJECT& parent_handle,
+                            const std::string& parent_handle_name,
+                            const TPM2B_DATA& encryption_key,
+                            const TPM2B_PUBLIC& object_public,
+                            const TPM2B_PRIVATE& duplicate,
+                            const TPM2B_ENCRYPTED_SECRET& in_sym_seed,
+                            const TPMT_SYM_DEF_OBJECT& symmetric_alg,
+                            TPM2B_PRIVATE* out_private,
+                            AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PUBLIC_KEY_RSA& out_data)>
+      RSA_EncryptResponse;
+  static TPM_RC SerializeCommand_RSA_Encrypt(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_PUBLIC_KEY_RSA& message,
+      const TPMT_RSA_DECRYPT& in_scheme,
+      const TPM2B_DATA& label,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_RSA_Encrypt(
+      const std::string& response,
+      TPM2B_PUBLIC_KEY_RSA* out_data,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void RSA_Encrypt(const TPMI_DH_OBJECT& key_handle,
+                           const std::string& key_handle_name,
+                           const TPM2B_PUBLIC_KEY_RSA& message,
+                           const TPMT_RSA_DECRYPT& in_scheme,
+                           const TPM2B_DATA& label,
+                           AuthorizationDelegate* authorization_delegate,
+                           RSA_EncryptResponse callback);
+  virtual TPM_RC RSA_EncryptSync(const TPMI_DH_OBJECT& key_handle,
+                                 const std::string& key_handle_name,
+                                 const TPM2B_PUBLIC_KEY_RSA& message,
+                                 const TPMT_RSA_DECRYPT& in_scheme,
+                                 const TPM2B_DATA& label,
+                                 TPM2B_PUBLIC_KEY_RSA* out_data,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_PUBLIC_KEY_RSA& message)>
+      RSA_DecryptResponse;
+  static TPM_RC SerializeCommand_RSA_Decrypt(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+      const TPMT_RSA_DECRYPT& in_scheme,
+      const TPM2B_DATA& label,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_RSA_Decrypt(
+      const std::string& response,
+      TPM2B_PUBLIC_KEY_RSA* message,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void RSA_Decrypt(const TPMI_DH_OBJECT& key_handle,
+                           const std::string& key_handle_name,
+                           const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+                           const TPMT_RSA_DECRYPT& in_scheme,
+                           const TPM2B_DATA& label,
+                           AuthorizationDelegate* authorization_delegate,
+                           RSA_DecryptResponse callback);
+  virtual TPM_RC RSA_DecryptSync(const TPMI_DH_OBJECT& key_handle,
+                                 const std::string& key_handle_name,
+                                 const TPM2B_PUBLIC_KEY_RSA& cipher_text,
+                                 const TPMT_RSA_DECRYPT& in_scheme,
+                                 const TPM2B_DATA& label,
+                                 TPM2B_PUBLIC_KEY_RSA* message,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ECC_POINT& z_point,
+                                  const TPM2B_ECC_POINT& pub_point)>
+      ECDH_KeyGenResponse;
+  static TPM_RC SerializeCommand_ECDH_KeyGen(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ECDH_KeyGen(
+      const std::string& response,
+      TPM2B_ECC_POINT* z_point,
+      TPM2B_ECC_POINT* pub_point,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ECDH_KeyGen(const TPMI_DH_OBJECT& key_handle,
+                           const std::string& key_handle_name,
+                           AuthorizationDelegate* authorization_delegate,
+                           ECDH_KeyGenResponse callback);
+  virtual TPM_RC ECDH_KeyGenSync(const TPMI_DH_OBJECT& key_handle,
+                                 const std::string& key_handle_name,
+                                 TPM2B_ECC_POINT* z_point,
+                                 TPM2B_ECC_POINT* pub_point,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ECC_POINT& out_point)>
+      ECDH_ZGenResponse;
+  static TPM_RC SerializeCommand_ECDH_ZGen(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_ECC_POINT& in_point,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ECDH_ZGen(
+      const std::string& response,
+      TPM2B_ECC_POINT* out_point,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ECDH_ZGen(const TPMI_DH_OBJECT& key_handle,
+                         const std::string& key_handle_name,
+                         const TPM2B_ECC_POINT& in_point,
+                         AuthorizationDelegate* authorization_delegate,
+                         ECDH_ZGenResponse callback);
+  virtual TPM_RC ECDH_ZGenSync(const TPMI_DH_OBJECT& key_handle,
+                               const std::string& key_handle_name,
+                               const TPM2B_ECC_POINT& in_point,
+                               TPM2B_ECC_POINT* out_point,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMS_ALGORITHM_DETAIL_ECC& parameters)>
+      ECC_ParametersResponse;
+  static TPM_RC SerializeCommand_ECC_Parameters(
+      const TPMI_ECC_CURVE& curve_id,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ECC_Parameters(
+      const std::string& response,
+      TPMS_ALGORITHM_DETAIL_ECC* parameters,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ECC_Parameters(const TPMI_ECC_CURVE& curve_id,
+                              AuthorizationDelegate* authorization_delegate,
+                              ECC_ParametersResponse callback);
+  virtual TPM_RC ECC_ParametersSync(
+      const TPMI_ECC_CURVE& curve_id,
+      TPMS_ALGORITHM_DETAIL_ECC* parameters,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ECC_POINT& out_z1,
+                                  const TPM2B_ECC_POINT& out_z2)>
+      ZGen_2PhaseResponse;
+  static TPM_RC SerializeCommand_ZGen_2Phase(
+      const TPMI_DH_OBJECT& key_a,
+      const std::string& key_a_name,
+      const TPM2B_ECC_POINT& in_qs_b,
+      const TPM2B_ECC_POINT& in_qe_b,
+      const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+      const UINT16& counter,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ZGen_2Phase(
+      const std::string& response,
+      TPM2B_ECC_POINT* out_z1,
+      TPM2B_ECC_POINT* out_z2,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ZGen_2Phase(const TPMI_DH_OBJECT& key_a,
+                           const std::string& key_a_name,
+                           const TPM2B_ECC_POINT& in_qs_b,
+                           const TPM2B_ECC_POINT& in_qe_b,
+                           const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+                           const UINT16& counter,
+                           AuthorizationDelegate* authorization_delegate,
+                           ZGen_2PhaseResponse callback);
+  virtual TPM_RC ZGen_2PhaseSync(const TPMI_DH_OBJECT& key_a,
+                                 const std::string& key_a_name,
+                                 const TPM2B_ECC_POINT& in_qs_b,
+                                 const TPM2B_ECC_POINT& in_qe_b,
+                                 const TPMI_ECC_KEY_EXCHANGE& in_scheme,
+                                 const UINT16& counter,
+                                 TPM2B_ECC_POINT* out_z1,
+                                 TPM2B_ECC_POINT* out_z2,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_MAX_BUFFER& out_data,
+                                  const TPM2B_IV& iv_out)>
+      EncryptDecryptResponse;
+  static TPM_RC SerializeCommand_EncryptDecrypt(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPMI_YES_NO& decrypt,
+      const TPMI_ALG_SYM_MODE& mode,
+      const TPM2B_IV& iv_in,
+      const TPM2B_MAX_BUFFER& in_data,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_EncryptDecrypt(
+      const std::string& response,
+      TPM2B_MAX_BUFFER* out_data,
+      TPM2B_IV* iv_out,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void EncryptDecrypt(const TPMI_DH_OBJECT& key_handle,
+                              const std::string& key_handle_name,
+                              const TPMI_YES_NO& decrypt,
+                              const TPMI_ALG_SYM_MODE& mode,
+                              const TPM2B_IV& iv_in,
+                              const TPM2B_MAX_BUFFER& in_data,
+                              AuthorizationDelegate* authorization_delegate,
+                              EncryptDecryptResponse callback);
+  virtual TPM_RC EncryptDecryptSync(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPMI_YES_NO& decrypt,
+      const TPMI_ALG_SYM_MODE& mode,
+      const TPM2B_IV& iv_in,
+      const TPM2B_MAX_BUFFER& in_data,
+      TPM2B_MAX_BUFFER* out_data,
+      TPM2B_IV* iv_out,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& out_hash,
+                                  const TPMT_TK_HASHCHECK& validation)>
+      HashResponse;
+  static TPM_RC SerializeCommand_Hash(
+      const TPM2B_MAX_BUFFER& data,
+      const TPMI_ALG_HASH& hash_alg,
+      const TPMI_RH_HIERARCHY& hierarchy,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Hash(
+      const std::string& response,
+      TPM2B_DIGEST* out_hash,
+      TPMT_TK_HASHCHECK* validation,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Hash(const TPM2B_MAX_BUFFER& data,
+                    const TPMI_ALG_HASH& hash_alg,
+                    const TPMI_RH_HIERARCHY& hierarchy,
+                    AuthorizationDelegate* authorization_delegate,
+                    HashResponse callback);
+  virtual TPM_RC HashSync(const TPM2B_MAX_BUFFER& data,
+                          const TPMI_ALG_HASH& hash_alg,
+                          const TPMI_RH_HIERARCHY& hierarchy,
+                          TPM2B_DIGEST* out_hash,
+                          TPMT_TK_HASHCHECK* validation,
+                          AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& out_hmac)>
+      HMACResponse;
+  static TPM_RC SerializeCommand_HMAC(
+      const TPMI_DH_OBJECT& handle,
+      const std::string& handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      const TPMI_ALG_HASH& hash_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_HMAC(
+      const std::string& response,
+      TPM2B_DIGEST* out_hmac,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void HMAC(const TPMI_DH_OBJECT& handle,
+                    const std::string& handle_name,
+                    const TPM2B_MAX_BUFFER& buffer,
+                    const TPMI_ALG_HASH& hash_alg,
+                    AuthorizationDelegate* authorization_delegate,
+                    HMACResponse callback);
+  virtual TPM_RC HMACSync(const TPMI_DH_OBJECT& handle,
+                          const std::string& handle_name,
+                          const TPM2B_MAX_BUFFER& buffer,
+                          const TPMI_ALG_HASH& hash_alg,
+                          TPM2B_DIGEST* out_hmac,
+                          AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& random_bytes)>
+      GetRandomResponse;
+  static TPM_RC SerializeCommand_GetRandom(
+      const UINT16& bytes_requested,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetRandom(
+      const std::string& response,
+      TPM2B_DIGEST* random_bytes,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetRandom(const UINT16& bytes_requested,
+                         AuthorizationDelegate* authorization_delegate,
+                         GetRandomResponse callback);
+  virtual TPM_RC GetRandomSync(const UINT16& bytes_requested,
+                               TPM2B_DIGEST* random_bytes,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> StirRandomResponse;
+  static TPM_RC SerializeCommand_StirRandom(
+      const TPM2B_SENSITIVE_DATA& in_data,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_StirRandom(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void StirRandom(const TPM2B_SENSITIVE_DATA& in_data,
+                          AuthorizationDelegate* authorization_delegate,
+                          StirRandomResponse callback);
+  virtual TPM_RC StirRandomSync(const TPM2B_SENSITIVE_DATA& in_data,
+                                AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_DH_OBJECT& sequence_handle)>
+      HMAC_StartResponse;
+  static TPM_RC SerializeCommand_HMAC_Start(
+      const TPMI_DH_OBJECT& handle,
+      const std::string& handle_name,
+      const TPM2B_AUTH& auth,
+      const TPMI_ALG_HASH& hash_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_HMAC_Start(
+      const std::string& response,
+      TPMI_DH_OBJECT* sequence_handle,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void HMAC_Start(const TPMI_DH_OBJECT& handle,
+                          const std::string& handle_name,
+                          const TPM2B_AUTH& auth,
+                          const TPMI_ALG_HASH& hash_alg,
+                          AuthorizationDelegate* authorization_delegate,
+                          HMAC_StartResponse callback);
+  virtual TPM_RC HMAC_StartSync(const TPMI_DH_OBJECT& handle,
+                                const std::string& handle_name,
+                                const TPM2B_AUTH& auth,
+                                const TPMI_ALG_HASH& hash_alg,
+                                TPMI_DH_OBJECT* sequence_handle,
+                                AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_DH_OBJECT& sequence_handle)>
+      HashSequenceStartResponse;
+  static TPM_RC SerializeCommand_HashSequenceStart(
+      const TPM2B_AUTH& auth,
+      const TPMI_ALG_HASH& hash_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_HashSequenceStart(
+      const std::string& response,
+      TPMI_DH_OBJECT* sequence_handle,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void HashSequenceStart(const TPM2B_AUTH& auth,
+                                 const TPMI_ALG_HASH& hash_alg,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 HashSequenceStartResponse callback);
+  virtual TPM_RC HashSequenceStartSync(
+      const TPM2B_AUTH& auth,
+      const TPMI_ALG_HASH& hash_alg,
+      TPMI_DH_OBJECT* sequence_handle,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> SequenceUpdateResponse;
+  static TPM_RC SerializeCommand_SequenceUpdate(
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SequenceUpdate(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SequenceUpdate(const TPMI_DH_OBJECT& sequence_handle,
+                              const std::string& sequence_handle_name,
+                              const TPM2B_MAX_BUFFER& buffer,
+                              AuthorizationDelegate* authorization_delegate,
+                              SequenceUpdateResponse callback);
+  virtual TPM_RC SequenceUpdateSync(
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& result,
+                                  const TPMT_TK_HASHCHECK& validation)>
+      SequenceCompleteResponse;
+  static TPM_RC SerializeCommand_SequenceComplete(
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      const TPMI_RH_HIERARCHY& hierarchy,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SequenceComplete(
+      const std::string& response,
+      TPM2B_DIGEST* result,
+      TPMT_TK_HASHCHECK* validation,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SequenceComplete(const TPMI_DH_OBJECT& sequence_handle,
+                                const std::string& sequence_handle_name,
+                                const TPM2B_MAX_BUFFER& buffer,
+                                const TPMI_RH_HIERARCHY& hierarchy,
+                                AuthorizationDelegate* authorization_delegate,
+                                SequenceCompleteResponse callback);
+  virtual TPM_RC SequenceCompleteSync(
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      const TPMI_RH_HIERARCHY& hierarchy,
+      TPM2B_DIGEST* result,
+      TPMT_TK_HASHCHECK* validation,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPML_DIGEST_VALUES& results)>
+      EventSequenceCompleteResponse;
+  static TPM_RC SerializeCommand_EventSequenceComplete(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_EventSequenceComplete(
+      const std::string& response,
+      TPML_DIGEST_VALUES* results,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void EventSequenceComplete(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      AuthorizationDelegate* authorization_delegate,
+      EventSequenceCompleteResponse callback);
+  virtual TPM_RC EventSequenceCompleteSync(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPMI_DH_OBJECT& sequence_handle,
+      const std::string& sequence_handle_name,
+      const TPM2B_MAX_BUFFER& buffer,
+      TPML_DIGEST_VALUES* results,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& certify_info,
+                                  const TPMT_SIGNATURE& signature)>
+      CertifyResponse;
+  static TPM_RC SerializeCommand_Certify(
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Certify(
+      const std::string& response,
+      TPM2B_ATTEST* certify_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Certify(const TPMI_DH_OBJECT& object_handle,
+                       const std::string& object_handle_name,
+                       const TPMI_DH_OBJECT& sign_handle,
+                       const std::string& sign_handle_name,
+                       const TPM2B_DATA& qualifying_data,
+                       const TPMT_SIG_SCHEME& in_scheme,
+                       AuthorizationDelegate* authorization_delegate,
+                       CertifyResponse callback);
+  virtual TPM_RC CertifySync(const TPMI_DH_OBJECT& object_handle,
+                             const std::string& object_handle_name,
+                             const TPMI_DH_OBJECT& sign_handle,
+                             const std::string& sign_handle_name,
+                             const TPM2B_DATA& qualifying_data,
+                             const TPMT_SIG_SCHEME& in_scheme,
+                             TPM2B_ATTEST* certify_info,
+                             TPMT_SIGNATURE* signature,
+                             AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& certify_info,
+                                  const TPMT_SIGNATURE& signature)>
+      CertifyCreationResponse;
+  static TPM_RC SerializeCommand_CertifyCreation(
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPM2B_DIGEST& creation_hash,
+      const TPMT_SIG_SCHEME& in_scheme,
+      const TPMT_TK_CREATION& creation_ticket,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_CertifyCreation(
+      const std::string& response,
+      TPM2B_ATTEST* certify_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void CertifyCreation(const TPMI_DH_OBJECT& sign_handle,
+                               const std::string& sign_handle_name,
+                               const TPMI_DH_OBJECT& object_handle,
+                               const std::string& object_handle_name,
+                               const TPM2B_DATA& qualifying_data,
+                               const TPM2B_DIGEST& creation_hash,
+                               const TPMT_SIG_SCHEME& in_scheme,
+                               const TPMT_TK_CREATION& creation_ticket,
+                               AuthorizationDelegate* authorization_delegate,
+                               CertifyCreationResponse callback);
+  virtual TPM_RC CertifyCreationSync(
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPM2B_DIGEST& creation_hash,
+      const TPMT_SIG_SCHEME& in_scheme,
+      const TPMT_TK_CREATION& creation_ticket,
+      TPM2B_ATTEST* certify_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& quoted,
+                                  const TPMT_SIGNATURE& signature)>
+      QuoteResponse;
+  static TPM_RC SerializeCommand_Quote(
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      const TPML_PCR_SELECTION& pcrselect,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Quote(
+      const std::string& response,
+      TPM2B_ATTEST* quoted,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Quote(const TPMI_DH_OBJECT& sign_handle,
+                     const std::string& sign_handle_name,
+                     const TPM2B_DATA& qualifying_data,
+                     const TPMT_SIG_SCHEME& in_scheme,
+                     const TPML_PCR_SELECTION& pcrselect,
+                     AuthorizationDelegate* authorization_delegate,
+                     QuoteResponse callback);
+  virtual TPM_RC QuoteSync(const TPMI_DH_OBJECT& sign_handle,
+                           const std::string& sign_handle_name,
+                           const TPM2B_DATA& qualifying_data,
+                           const TPMT_SIG_SCHEME& in_scheme,
+                           const TPML_PCR_SELECTION& pcrselect,
+                           TPM2B_ATTEST* quoted,
+                           TPMT_SIGNATURE* signature,
+                           AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& audit_info,
+                                  const TPMT_SIGNATURE& signature)>
+      GetSessionAuditDigestResponse;
+  static TPM_RC SerializeCommand_GetSessionAuditDigest(
+      const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+      const std::string& privacy_admin_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_SH_HMAC& session_handle,
+      const std::string& session_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetSessionAuditDigest(
+      const std::string& response,
+      TPM2B_ATTEST* audit_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetSessionAuditDigest(
+      const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+      const std::string& privacy_admin_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_SH_HMAC& session_handle,
+      const std::string& session_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      AuthorizationDelegate* authorization_delegate,
+      GetSessionAuditDigestResponse callback);
+  virtual TPM_RC GetSessionAuditDigestSync(
+      const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+      const std::string& privacy_admin_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_SH_HMAC& session_handle,
+      const std::string& session_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      TPM2B_ATTEST* audit_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& audit_info,
+                                  const TPMT_SIGNATURE& signature)>
+      GetCommandAuditDigestResponse;
+  static TPM_RC SerializeCommand_GetCommandAuditDigest(
+      const TPMI_RH_ENDORSEMENT& privacy_handle,
+      const std::string& privacy_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetCommandAuditDigest(
+      const std::string& response,
+      TPM2B_ATTEST* audit_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetCommandAuditDigest(
+      const TPMI_RH_ENDORSEMENT& privacy_handle,
+      const std::string& privacy_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      AuthorizationDelegate* authorization_delegate,
+      GetCommandAuditDigestResponse callback);
+  virtual TPM_RC GetCommandAuditDigestSync(
+      const TPMI_RH_ENDORSEMENT& privacy_handle,
+      const std::string& privacy_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      TPM2B_ATTEST* audit_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& time_info,
+                                  const TPMT_SIGNATURE& signature)>
+      GetTimeResponse;
+  static TPM_RC SerializeCommand_GetTime(
+      const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+      const std::string& privacy_admin_handle_name,
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetTime(
+      const std::string& response,
+      TPM2B_ATTEST* time_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetTime(const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+                       const std::string& privacy_admin_handle_name,
+                       const TPMI_DH_OBJECT& sign_handle,
+                       const std::string& sign_handle_name,
+                       const TPM2B_DATA& qualifying_data,
+                       const TPMT_SIG_SCHEME& in_scheme,
+                       AuthorizationDelegate* authorization_delegate,
+                       GetTimeResponse callback);
+  virtual TPM_RC GetTimeSync(const TPMI_RH_ENDORSEMENT& privacy_admin_handle,
+                             const std::string& privacy_admin_handle_name,
+                             const TPMI_DH_OBJECT& sign_handle,
+                             const std::string& sign_handle_name,
+                             const TPM2B_DATA& qualifying_data,
+                             const TPMT_SIG_SCHEME& in_scheme,
+                             TPM2B_ATTEST* time_info,
+                             TPMT_SIGNATURE* signature,
+                             AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const UINT32& param_size_out,
+                                  const TPM2B_ECC_POINT& k,
+                                  const TPM2B_ECC_POINT& l,
+                                  const TPM2B_ECC_POINT& e,
+                                  const UINT16& counter)>
+      CommitResponse;
+  static TPM_RC SerializeCommand_Commit(
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const UINT32& param_size,
+      const TPM2B_ECC_POINT& p1,
+      const TPM2B_SENSITIVE_DATA& s2,
+      const TPM2B_ECC_PARAMETER& y2,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Commit(
+      const std::string& response,
+      UINT32* param_size_out,
+      TPM2B_ECC_POINT* k,
+      TPM2B_ECC_POINT* l,
+      TPM2B_ECC_POINT* e,
+      UINT16* counter,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Commit(const TPMI_DH_OBJECT& sign_handle,
+                      const std::string& sign_handle_name,
+                      const UINT32& param_size,
+                      const TPM2B_ECC_POINT& p1,
+                      const TPM2B_SENSITIVE_DATA& s2,
+                      const TPM2B_ECC_PARAMETER& y2,
+                      AuthorizationDelegate* authorization_delegate,
+                      CommitResponse callback);
+  virtual TPM_RC CommitSync(const TPMI_DH_OBJECT& sign_handle,
+                            const std::string& sign_handle_name,
+                            const UINT32& param_size,
+                            const TPM2B_ECC_POINT& p1,
+                            const TPM2B_SENSITIVE_DATA& s2,
+                            const TPM2B_ECC_PARAMETER& y2,
+                            UINT32* param_size_out,
+                            TPM2B_ECC_POINT* k,
+                            TPM2B_ECC_POINT* l,
+                            TPM2B_ECC_POINT* e,
+                            UINT16* counter,
+                            AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const UINT32& param_size_out,
+                                  const TPM2B_ECC_POINT& q,
+                                  const UINT16& counter)>
+      EC_EphemeralResponse;
+  static TPM_RC SerializeCommand_EC_Ephemeral(
+      const UINT32& param_size,
+      const TPMI_ECC_CURVE& curve_id,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_EC_Ephemeral(
+      const std::string& response,
+      UINT32* param_size_out,
+      TPM2B_ECC_POINT* q,
+      UINT16* counter,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void EC_Ephemeral(const UINT32& param_size,
+                            const TPMI_ECC_CURVE& curve_id,
+                            AuthorizationDelegate* authorization_delegate,
+                            EC_EphemeralResponse callback);
+  virtual TPM_RC EC_EphemeralSync(
+      const UINT32& param_size,
+      const TPMI_ECC_CURVE& curve_id,
+      UINT32* param_size_out,
+      TPM2B_ECC_POINT* q,
+      UINT16* counter,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMT_TK_VERIFIED& validation)>
+      VerifySignatureResponse;
+  static TPM_RC SerializeCommand_VerifySignature(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_DIGEST& digest,
+      const TPMT_SIGNATURE& signature,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_VerifySignature(
+      const std::string& response,
+      TPMT_TK_VERIFIED* validation,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void VerifySignature(const TPMI_DH_OBJECT& key_handle,
+                               const std::string& key_handle_name,
+                               const TPM2B_DIGEST& digest,
+                               const TPMT_SIGNATURE& signature,
+                               AuthorizationDelegate* authorization_delegate,
+                               VerifySignatureResponse callback);
+  virtual TPM_RC VerifySignatureSync(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_DIGEST& digest,
+      const TPMT_SIGNATURE& signature,
+      TPMT_TK_VERIFIED* validation,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMT_SIGNATURE& signature)>
+      SignResponse;
+  static TPM_RC SerializeCommand_Sign(
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_DIGEST& digest,
+      const TPMT_SIG_SCHEME& in_scheme,
+      const TPMT_TK_HASHCHECK& validation,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Sign(
+      const std::string& response,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Sign(const TPMI_DH_OBJECT& key_handle,
+                    const std::string& key_handle_name,
+                    const TPM2B_DIGEST& digest,
+                    const TPMT_SIG_SCHEME& in_scheme,
+                    const TPMT_TK_HASHCHECK& validation,
+                    AuthorizationDelegate* authorization_delegate,
+                    SignResponse callback);
+  virtual TPM_RC SignSync(const TPMI_DH_OBJECT& key_handle,
+                          const std::string& key_handle_name,
+                          const TPM2B_DIGEST& digest,
+                          const TPMT_SIG_SCHEME& in_scheme,
+                          const TPMT_TK_HASHCHECK& validation,
+                          TPMT_SIGNATURE* signature,
+                          AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      SetCommandCodeAuditStatusResponse;
+  static TPM_RC SerializeCommand_SetCommandCodeAuditStatus(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPMI_ALG_HASH& audit_alg,
+      const TPML_CC& set_list,
+      const TPML_CC& clear_list,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SetCommandCodeAuditStatus(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SetCommandCodeAuditStatus(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPMI_ALG_HASH& audit_alg,
+      const TPML_CC& set_list,
+      const TPML_CC& clear_list,
+      AuthorizationDelegate* authorization_delegate,
+      SetCommandCodeAuditStatusResponse callback);
+  virtual TPM_RC SetCommandCodeAuditStatusSync(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPMI_ALG_HASH& audit_alg,
+      const TPML_CC& set_list,
+      const TPML_CC& clear_list,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PCR_ExtendResponse;
+  static TPM_RC SerializeCommand_PCR_Extend(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPML_DIGEST_VALUES& digests,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_Extend(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_Extend(const TPMI_DH_PCR& pcr_handle,
+                          const std::string& pcr_handle_name,
+                          const TPML_DIGEST_VALUES& digests,
+                          AuthorizationDelegate* authorization_delegate,
+                          PCR_ExtendResponse callback);
+  virtual TPM_RC PCR_ExtendSync(const TPMI_DH_PCR& pcr_handle,
+                                const std::string& pcr_handle_name,
+                                const TPML_DIGEST_VALUES& digests,
+                                AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPML_DIGEST_VALUES& digests)>
+      PCR_EventResponse;
+  static TPM_RC SerializeCommand_PCR_Event(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPM2B_EVENT& event_data,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_Event(
+      const std::string& response,
+      TPML_DIGEST_VALUES* digests,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_Event(const TPMI_DH_PCR& pcr_handle,
+                         const std::string& pcr_handle_name,
+                         const TPM2B_EVENT& event_data,
+                         AuthorizationDelegate* authorization_delegate,
+                         PCR_EventResponse callback);
+  virtual TPM_RC PCR_EventSync(const TPMI_DH_PCR& pcr_handle,
+                               const std::string& pcr_handle_name,
+                               const TPM2B_EVENT& event_data,
+                               TPML_DIGEST_VALUES* digests,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const UINT32& pcr_update_counter,
+                                  const TPML_PCR_SELECTION& pcr_selection_out,
+                                  const TPML_DIGEST& pcr_values)>
+      PCR_ReadResponse;
+  static TPM_RC SerializeCommand_PCR_Read(
+      const TPML_PCR_SELECTION& pcr_selection_in,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_Read(
+      const std::string& response,
+      UINT32* pcr_update_counter,
+      TPML_PCR_SELECTION* pcr_selection_out,
+      TPML_DIGEST* pcr_values,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_Read(const TPML_PCR_SELECTION& pcr_selection_in,
+                        AuthorizationDelegate* authorization_delegate,
+                        PCR_ReadResponse callback);
+  virtual TPM_RC PCR_ReadSync(const TPML_PCR_SELECTION& pcr_selection_in,
+                              UINT32* pcr_update_counter,
+                              TPML_PCR_SELECTION* pcr_selection_out,
+                              TPML_DIGEST* pcr_values,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_YES_NO& allocation_success,
+                                  const UINT32& max_pcr,
+                                  const UINT32& size_needed,
+                                  const UINT32& size_available)>
+      PCR_AllocateResponse;
+  static TPM_RC SerializeCommand_PCR_Allocate(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const TPML_PCR_SELECTION& pcr_allocation,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_Allocate(
+      const std::string& response,
+      TPMI_YES_NO* allocation_success,
+      UINT32* max_pcr,
+      UINT32* size_needed,
+      UINT32* size_available,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_Allocate(const TPMI_RH_PLATFORM& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPML_PCR_SELECTION& pcr_allocation,
+                            AuthorizationDelegate* authorization_delegate,
+                            PCR_AllocateResponse callback);
+  virtual TPM_RC PCR_AllocateSync(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const TPML_PCR_SELECTION& pcr_allocation,
+      TPMI_YES_NO* allocation_success,
+      UINT32* max_pcr,
+      UINT32* size_needed,
+      UINT32* size_available,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PCR_SetAuthPolicyResponse;
+  static TPM_RC SerializeCommand_PCR_SetAuthPolicy(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_DH_PCR& pcr_num,
+      const std::string& pcr_num_name,
+      const TPM2B_DIGEST& auth_policy,
+      const TPMI_ALG_HASH& policy_digest,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_SetAuthPolicy(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_SetAuthPolicy(const TPMI_RH_PLATFORM& auth_handle,
+                                 const std::string& auth_handle_name,
+                                 const TPMI_DH_PCR& pcr_num,
+                                 const std::string& pcr_num_name,
+                                 const TPM2B_DIGEST& auth_policy,
+                                 const TPMI_ALG_HASH& policy_digest,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 PCR_SetAuthPolicyResponse callback);
+  virtual TPM_RC PCR_SetAuthPolicySync(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_DH_PCR& pcr_num,
+      const std::string& pcr_num_name,
+      const TPM2B_DIGEST& auth_policy,
+      const TPMI_ALG_HASH& policy_digest,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PCR_SetAuthValueResponse;
+  static TPM_RC SerializeCommand_PCR_SetAuthValue(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPM2B_DIGEST& auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_SetAuthValue(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_SetAuthValue(const TPMI_DH_PCR& pcr_handle,
+                                const std::string& pcr_handle_name,
+                                const TPM2B_DIGEST& auth,
+                                AuthorizationDelegate* authorization_delegate,
+                                PCR_SetAuthValueResponse callback);
+  virtual TPM_RC PCR_SetAuthValueSync(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      const TPM2B_DIGEST& auth,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PCR_ResetResponse;
+  static TPM_RC SerializeCommand_PCR_Reset(
+      const TPMI_DH_PCR& pcr_handle,
+      const std::string& pcr_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PCR_Reset(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PCR_Reset(const TPMI_DH_PCR& pcr_handle,
+                         const std::string& pcr_handle_name,
+                         AuthorizationDelegate* authorization_delegate,
+                         PCR_ResetResponse callback);
+  virtual TPM_RC PCR_ResetSync(const TPMI_DH_PCR& pcr_handle,
+                               const std::string& pcr_handle_name,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_TIMEOUT& timeout,
+                                  const TPMT_TK_AUTH& policy_ticket)>
+      PolicySignedResponse;
+  static TPM_RC SerializeCommand_PolicySigned(
+      const TPMI_DH_OBJECT& auth_object,
+      const std::string& auth_object_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NONCE& nonce_tpm,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const INT32& expiration,
+      const TPMT_SIGNATURE& auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicySigned(
+      const std::string& response,
+      TPM2B_TIMEOUT* timeout,
+      TPMT_TK_AUTH* policy_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicySigned(const TPMI_DH_OBJECT& auth_object,
+                            const std::string& auth_object_name,
+                            const TPMI_SH_POLICY& policy_session,
+                            const std::string& policy_session_name,
+                            const TPM2B_NONCE& nonce_tpm,
+                            const TPM2B_DIGEST& cp_hash_a,
+                            const TPM2B_NONCE& policy_ref,
+                            const INT32& expiration,
+                            const TPMT_SIGNATURE& auth,
+                            AuthorizationDelegate* authorization_delegate,
+                            PolicySignedResponse callback);
+  virtual TPM_RC PolicySignedSync(
+      const TPMI_DH_OBJECT& auth_object,
+      const std::string& auth_object_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NONCE& nonce_tpm,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const INT32& expiration,
+      const TPMT_SIGNATURE& auth,
+      TPM2B_TIMEOUT* timeout,
+      TPMT_TK_AUTH* policy_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_TIMEOUT& timeout,
+                                  const TPMT_TK_AUTH& policy_ticket)>
+      PolicySecretResponse;
+  static TPM_RC SerializeCommand_PolicySecret(
+      const TPMI_DH_ENTITY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NONCE& nonce_tpm,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const INT32& expiration,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicySecret(
+      const std::string& response,
+      TPM2B_TIMEOUT* timeout,
+      TPMT_TK_AUTH* policy_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicySecret(const TPMI_DH_ENTITY& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPMI_SH_POLICY& policy_session,
+                            const std::string& policy_session_name,
+                            const TPM2B_NONCE& nonce_tpm,
+                            const TPM2B_DIGEST& cp_hash_a,
+                            const TPM2B_NONCE& policy_ref,
+                            const INT32& expiration,
+                            AuthorizationDelegate* authorization_delegate,
+                            PolicySecretResponse callback);
+  virtual TPM_RC PolicySecretSync(
+      const TPMI_DH_ENTITY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NONCE& nonce_tpm,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const INT32& expiration,
+      TPM2B_TIMEOUT* timeout,
+      TPMT_TK_AUTH* policy_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyTicketResponse;
+  static TPM_RC SerializeCommand_PolicyTicket(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_TIMEOUT& timeout,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const TPM2B_NAME& auth_name,
+      const TPMT_TK_AUTH& ticket,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyTicket(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyTicket(const TPMI_SH_POLICY& policy_session,
+                            const std::string& policy_session_name,
+                            const TPM2B_TIMEOUT& timeout,
+                            const TPM2B_DIGEST& cp_hash_a,
+                            const TPM2B_NONCE& policy_ref,
+                            const TPM2B_NAME& auth_name,
+                            const TPMT_TK_AUTH& ticket,
+                            AuthorizationDelegate* authorization_delegate,
+                            PolicyTicketResponse callback);
+  virtual TPM_RC PolicyTicketSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_TIMEOUT& timeout,
+      const TPM2B_DIGEST& cp_hash_a,
+      const TPM2B_NONCE& policy_ref,
+      const TPM2B_NAME& auth_name,
+      const TPMT_TK_AUTH& ticket,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyORResponse;
+  static TPM_RC SerializeCommand_PolicyOR(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPML_DIGEST& p_hash_list,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyOR(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyOR(const TPMI_SH_POLICY& policy_session,
+                        const std::string& policy_session_name,
+                        const TPML_DIGEST& p_hash_list,
+                        AuthorizationDelegate* authorization_delegate,
+                        PolicyORResponse callback);
+  virtual TPM_RC PolicyORSync(const TPMI_SH_POLICY& policy_session,
+                              const std::string& policy_session_name,
+                              const TPML_DIGEST& p_hash_list,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyPCRResponse;
+  static TPM_RC SerializeCommand_PolicyPCR(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& pcr_digest,
+      const TPML_PCR_SELECTION& pcrs,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyPCR(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyPCR(const TPMI_SH_POLICY& policy_session,
+                         const std::string& policy_session_name,
+                         const TPM2B_DIGEST& pcr_digest,
+                         const TPML_PCR_SELECTION& pcrs,
+                         AuthorizationDelegate* authorization_delegate,
+                         PolicyPCRResponse callback);
+  virtual TPM_RC PolicyPCRSync(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               const TPM2B_DIGEST& pcr_digest,
+                               const TPML_PCR_SELECTION& pcrs,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyLocalityResponse;
+  static TPM_RC SerializeCommand_PolicyLocality(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPMA_LOCALITY& locality,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyLocality(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyLocality(const TPMI_SH_POLICY& policy_session,
+                              const std::string& policy_session_name,
+                              const TPMA_LOCALITY& locality,
+                              AuthorizationDelegate* authorization_delegate,
+                              PolicyLocalityResponse callback);
+  virtual TPM_RC PolicyLocalitySync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPMA_LOCALITY& locality,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyNVResponse;
+  static TPM_RC SerializeCommand_PolicyNV(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_OPERAND& operand_b,
+      const UINT16& offset,
+      const TPM_EO& operation,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyNV(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyNV(const TPMI_RH_NV_AUTH& auth_handle,
+                        const std::string& auth_handle_name,
+                        const TPMI_RH_NV_INDEX& nv_index,
+                        const std::string& nv_index_name,
+                        const TPMI_SH_POLICY& policy_session,
+                        const std::string& policy_session_name,
+                        const TPM2B_OPERAND& operand_b,
+                        const UINT16& offset,
+                        const TPM_EO& operation,
+                        AuthorizationDelegate* authorization_delegate,
+                        PolicyNVResponse callback);
+  virtual TPM_RC PolicyNVSync(const TPMI_RH_NV_AUTH& auth_handle,
+                              const std::string& auth_handle_name,
+                              const TPMI_RH_NV_INDEX& nv_index,
+                              const std::string& nv_index_name,
+                              const TPMI_SH_POLICY& policy_session,
+                              const std::string& policy_session_name,
+                              const TPM2B_OPERAND& operand_b,
+                              const UINT16& offset,
+                              const TPM_EO& operation,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyCounterTimerResponse;
+  static TPM_RC SerializeCommand_PolicyCounterTimer(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_OPERAND& operand_b,
+      const UINT16& offset,
+      const TPM_EO& operation,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyCounterTimer(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyCounterTimer(const TPMI_SH_POLICY& policy_session,
+                                  const std::string& policy_session_name,
+                                  const TPM2B_OPERAND& operand_b,
+                                  const UINT16& offset,
+                                  const TPM_EO& operation,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  PolicyCounterTimerResponse callback);
+  virtual TPM_RC PolicyCounterTimerSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_OPERAND& operand_b,
+      const UINT16& offset,
+      const TPM_EO& operation,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyCommandCodeResponse;
+  static TPM_RC SerializeCommand_PolicyCommandCode(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM_CC& code,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyCommandCode(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyCommandCode(const TPMI_SH_POLICY& policy_session,
+                                 const std::string& policy_session_name,
+                                 const TPM_CC& code,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 PolicyCommandCodeResponse callback);
+  virtual TPM_RC PolicyCommandCodeSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM_CC& code,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyPhysicalPresenceResponse;
+  static TPM_RC SerializeCommand_PolicyPhysicalPresence(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyPhysicalPresence(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyPhysicalPresence(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      AuthorizationDelegate* authorization_delegate,
+      PolicyPhysicalPresenceResponse callback);
+  virtual TPM_RC PolicyPhysicalPresenceSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyCpHashResponse;
+  static TPM_RC SerializeCommand_PolicyCpHash(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& cp_hash_a,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyCpHash(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyCpHash(const TPMI_SH_POLICY& policy_session,
+                            const std::string& policy_session_name,
+                            const TPM2B_DIGEST& cp_hash_a,
+                            AuthorizationDelegate* authorization_delegate,
+                            PolicyCpHashResponse callback);
+  virtual TPM_RC PolicyCpHashSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& cp_hash_a,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyNameHashResponse;
+  static TPM_RC SerializeCommand_PolicyNameHash(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& name_hash,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyNameHash(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyNameHash(const TPMI_SH_POLICY& policy_session,
+                              const std::string& policy_session_name,
+                              const TPM2B_DIGEST& name_hash,
+                              AuthorizationDelegate* authorization_delegate,
+                              PolicyNameHashResponse callback);
+  virtual TPM_RC PolicyNameHashSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& name_hash,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyDuplicationSelectResponse;
+  static TPM_RC SerializeCommand_PolicyDuplicationSelect(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NAME& object_name,
+      const TPM2B_NAME& new_parent_name,
+      const TPMI_YES_NO& include_object,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyDuplicationSelect(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyDuplicationSelect(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NAME& object_name,
+      const TPM2B_NAME& new_parent_name,
+      const TPMI_YES_NO& include_object,
+      AuthorizationDelegate* authorization_delegate,
+      PolicyDuplicationSelectResponse callback);
+  virtual TPM_RC PolicyDuplicationSelectSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_NAME& object_name,
+      const TPM2B_NAME& new_parent_name,
+      const TPMI_YES_NO& include_object,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyAuthorizeResponse;
+  static TPM_RC SerializeCommand_PolicyAuthorize(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& approved_policy,
+      const TPM2B_NONCE& policy_ref,
+      const TPM2B_NAME& key_sign,
+      const TPMT_TK_VERIFIED& check_ticket,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyAuthorize(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyAuthorize(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               const TPM2B_DIGEST& approved_policy,
+                               const TPM2B_NONCE& policy_ref,
+                               const TPM2B_NAME& key_sign,
+                               const TPMT_TK_VERIFIED& check_ticket,
+                               AuthorizationDelegate* authorization_delegate,
+                               PolicyAuthorizeResponse callback);
+  virtual TPM_RC PolicyAuthorizeSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPM2B_DIGEST& approved_policy,
+      const TPM2B_NONCE& policy_ref,
+      const TPM2B_NAME& key_sign,
+      const TPMT_TK_VERIFIED& check_ticket,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyAuthValueResponse;
+  static TPM_RC SerializeCommand_PolicyAuthValue(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyAuthValue(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyAuthValue(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               AuthorizationDelegate* authorization_delegate,
+                               PolicyAuthValueResponse callback);
+  virtual TPM_RC PolicyAuthValueSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PolicyPasswordResponse;
+  static TPM_RC SerializeCommand_PolicyPassword(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyPassword(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyPassword(const TPMI_SH_POLICY& policy_session,
+                              const std::string& policy_session_name,
+                              AuthorizationDelegate* authorization_delegate,
+                              PolicyPasswordResponse callback);
+  virtual TPM_RC PolicyPasswordSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_DIGEST& policy_digest)>
+      PolicyGetDigestResponse;
+  static TPM_RC SerializeCommand_PolicyGetDigest(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyGetDigest(
+      const std::string& response,
+      TPM2B_DIGEST* policy_digest,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyGetDigest(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               AuthorizationDelegate* authorization_delegate,
+                               PolicyGetDigestResponse callback);
+  virtual TPM_RC PolicyGetDigestSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      TPM2B_DIGEST* policy_digest,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyNvWrittenResponse;
+  static TPM_RC SerializeCommand_PolicyNvWritten(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPMI_YES_NO& written_set,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyNvWritten(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PolicyNvWritten(const TPMI_SH_POLICY& policy_session,
+                               const std::string& policy_session_name,
+                               const TPMI_YES_NO& written_set,
+                               AuthorizationDelegate* authorization_delegate,
+                               PolicyNvWrittenResponse callback);
+  virtual TPM_RC PolicyNvWrittenSync(
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const TPMI_YES_NO& written_set,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM_HANDLE& object_handle,
+                                  const TPM2B_PUBLIC& out_public,
+                                  const TPM2B_CREATION_DATA& creation_data,
+                                  const TPM2B_DIGEST& creation_hash,
+                                  const TPMT_TK_CREATION& creation_ticket,
+                                  const TPM2B_NAME& name)>
+      CreatePrimaryResponse;
+  static TPM_RC SerializeCommand_CreatePrimary(
+      const TPMI_RH_HIERARCHY& primary_handle,
+      const std::string& primary_handle_name,
+      const TPM2B_SENSITIVE_CREATE& in_sensitive,
+      const TPM2B_PUBLIC& in_public,
+      const TPM2B_DATA& outside_info,
+      const TPML_PCR_SELECTION& creation_pcr,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_CreatePrimary(
+      const std::string& response,
+      TPM_HANDLE* object_handle,
+      TPM2B_PUBLIC* out_public,
+      TPM2B_CREATION_DATA* creation_data,
+      TPM2B_DIGEST* creation_hash,
+      TPMT_TK_CREATION* creation_ticket,
+      TPM2B_NAME* name,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void CreatePrimary(const TPMI_RH_HIERARCHY& primary_handle,
+                             const std::string& primary_handle_name,
+                             const TPM2B_SENSITIVE_CREATE& in_sensitive,
+                             const TPM2B_PUBLIC& in_public,
+                             const TPM2B_DATA& outside_info,
+                             const TPML_PCR_SELECTION& creation_pcr,
+                             AuthorizationDelegate* authorization_delegate,
+                             CreatePrimaryResponse callback);
+  virtual TPM_RC CreatePrimarySync(
+      const TPMI_RH_HIERARCHY& primary_handle,
+      const std::string& primary_handle_name,
+      const TPM2B_SENSITIVE_CREATE& in_sensitive,
+      const TPM2B_PUBLIC& in_public,
+      const TPM2B_DATA& outside_info,
+      const TPML_PCR_SELECTION& creation_pcr,
+      TPM_HANDLE* object_handle,
+      TPM2B_PUBLIC* out_public,
+      TPM2B_CREATION_DATA* creation_data,
+      TPM2B_DIGEST* creation_hash,
+      TPMT_TK_CREATION* creation_ticket,
+      TPM2B_NAME* name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      HierarchyControlResponse;
+  static TPM_RC SerializeCommand_HierarchyControl(
+      const TPMI_RH_HIERARCHY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_ENABLES& enable,
+      const TPMI_YES_NO& state,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_HierarchyControl(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void HierarchyControl(const TPMI_RH_HIERARCHY& auth_handle,
+                                const std::string& auth_handle_name,
+                                const TPMI_RH_ENABLES& enable,
+                                const TPMI_YES_NO& state,
+                                AuthorizationDelegate* authorization_delegate,
+                                HierarchyControlResponse callback);
+  virtual TPM_RC HierarchyControlSync(
+      const TPMI_RH_HIERARCHY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_ENABLES& enable,
+      const TPMI_YES_NO& state,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      SetPrimaryPolicyResponse;
+  static TPM_RC SerializeCommand_SetPrimaryPolicy(
+      const TPMI_RH_HIERARCHY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_DIGEST& auth_policy,
+      const TPMI_ALG_HASH& hash_alg,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SetPrimaryPolicy(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SetPrimaryPolicy(const TPMI_RH_HIERARCHY& auth_handle,
+                                const std::string& auth_handle_name,
+                                const TPM2B_DIGEST& auth_policy,
+                                const TPMI_ALG_HASH& hash_alg,
+                                AuthorizationDelegate* authorization_delegate,
+                                SetPrimaryPolicyResponse callback);
+  virtual TPM_RC SetPrimaryPolicySync(
+      const TPMI_RH_HIERARCHY& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_DIGEST& auth_policy,
+      const TPMI_ALG_HASH& hash_alg,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ChangePPSResponse;
+  static TPM_RC SerializeCommand_ChangePPS(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ChangePPS(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ChangePPS(const TPMI_RH_PLATFORM& auth_handle,
+                         const std::string& auth_handle_name,
+                         AuthorizationDelegate* authorization_delegate,
+                         ChangePPSResponse callback);
+  virtual TPM_RC ChangePPSSync(const TPMI_RH_PLATFORM& auth_handle,
+                               const std::string& auth_handle_name,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ChangeEPSResponse;
+  static TPM_RC SerializeCommand_ChangeEPS(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ChangeEPS(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ChangeEPS(const TPMI_RH_PLATFORM& auth_handle,
+                         const std::string& auth_handle_name,
+                         AuthorizationDelegate* authorization_delegate,
+                         ChangeEPSResponse callback);
+  virtual TPM_RC ChangeEPSSync(const TPMI_RH_PLATFORM& auth_handle,
+                               const std::string& auth_handle_name,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ClearResponse;
+  static TPM_RC SerializeCommand_Clear(
+      const TPMI_RH_CLEAR& auth_handle,
+      const std::string& auth_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_Clear(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void Clear(const TPMI_RH_CLEAR& auth_handle,
+                     const std::string& auth_handle_name,
+                     AuthorizationDelegate* authorization_delegate,
+                     ClearResponse callback);
+  virtual TPM_RC ClearSync(const TPMI_RH_CLEAR& auth_handle,
+                           const std::string& auth_handle_name,
+                           AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ClearControlResponse;
+  static TPM_RC SerializeCommand_ClearControl(
+      const TPMI_RH_CLEAR& auth,
+      const std::string& auth_name,
+      const TPMI_YES_NO& disable,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ClearControl(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ClearControl(const TPMI_RH_CLEAR& auth,
+                            const std::string& auth_name,
+                            const TPMI_YES_NO& disable,
+                            AuthorizationDelegate* authorization_delegate,
+                            ClearControlResponse callback);
+  virtual TPM_RC ClearControlSync(
+      const TPMI_RH_CLEAR& auth,
+      const std::string& auth_name,
+      const TPMI_YES_NO& disable,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      HierarchyChangeAuthResponse;
+  static TPM_RC SerializeCommand_HierarchyChangeAuth(
+      const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_AUTH& new_auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_HierarchyChangeAuth(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void HierarchyChangeAuth(
+      const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_AUTH& new_auth,
+      AuthorizationDelegate* authorization_delegate,
+      HierarchyChangeAuthResponse callback);
+  virtual TPM_RC HierarchyChangeAuthSync(
+      const TPMI_RH_HIERARCHY_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_AUTH& new_auth,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      DictionaryAttackLockResetResponse;
+  static TPM_RC SerializeCommand_DictionaryAttackLockReset(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_DictionaryAttackLockReset(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void DictionaryAttackLockReset(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      AuthorizationDelegate* authorization_delegate,
+      DictionaryAttackLockResetResponse callback);
+  virtual TPM_RC DictionaryAttackLockResetSync(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      DictionaryAttackParametersResponse;
+  static TPM_RC SerializeCommand_DictionaryAttackParameters(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      const UINT32& new_max_tries,
+      const UINT32& new_recovery_time,
+      const UINT32& lockout_recovery,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_DictionaryAttackParameters(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void DictionaryAttackParameters(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      const UINT32& new_max_tries,
+      const UINT32& new_recovery_time,
+      const UINT32& lockout_recovery,
+      AuthorizationDelegate* authorization_delegate,
+      DictionaryAttackParametersResponse callback);
+  virtual TPM_RC DictionaryAttackParametersSync(
+      const TPMI_RH_LOCKOUT& lock_handle,
+      const std::string& lock_handle_name,
+      const UINT32& new_max_tries,
+      const UINT32& new_recovery_time,
+      const UINT32& lockout_recovery,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> PP_CommandsResponse;
+  static TPM_RC SerializeCommand_PP_Commands(
+      const TPMI_RH_PLATFORM& auth,
+      const std::string& auth_name,
+      const TPML_CC& set_list,
+      const TPML_CC& clear_list,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PP_Commands(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void PP_Commands(const TPMI_RH_PLATFORM& auth,
+                           const std::string& auth_name,
+                           const TPML_CC& set_list,
+                           const TPML_CC& clear_list,
+                           AuthorizationDelegate* authorization_delegate,
+                           PP_CommandsResponse callback);
+  virtual TPM_RC PP_CommandsSync(const TPMI_RH_PLATFORM& auth,
+                                 const std::string& auth_name,
+                                 const TPML_CC& set_list,
+                                 const TPML_CC& clear_list,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      SetAlgorithmSetResponse;
+  static TPM_RC SerializeCommand_SetAlgorithmSet(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const UINT32& algorithm_set,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_SetAlgorithmSet(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void SetAlgorithmSet(const TPMI_RH_PLATFORM& auth_handle,
+                               const std::string& auth_handle_name,
+                               const UINT32& algorithm_set,
+                               AuthorizationDelegate* authorization_delegate,
+                               SetAlgorithmSetResponse callback);
+  virtual TPM_RC SetAlgorithmSetSync(
+      const TPMI_RH_PLATFORM& auth_handle,
+      const std::string& auth_handle_name,
+      const UINT32& algorithm_set,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      FieldUpgradeStartResponse;
+  static TPM_RC SerializeCommand_FieldUpgradeStart(
+      const TPMI_RH_PLATFORM& authorization,
+      const std::string& authorization_name,
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_DIGEST& fu_digest,
+      const TPMT_SIGNATURE& manifest_signature,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_FieldUpgradeStart(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void FieldUpgradeStart(const TPMI_RH_PLATFORM& authorization,
+                                 const std::string& authorization_name,
+                                 const TPMI_DH_OBJECT& key_handle,
+                                 const std::string& key_handle_name,
+                                 const TPM2B_DIGEST& fu_digest,
+                                 const TPMT_SIGNATURE& manifest_signature,
+                                 AuthorizationDelegate* authorization_delegate,
+                                 FieldUpgradeStartResponse callback);
+  virtual TPM_RC FieldUpgradeStartSync(
+      const TPMI_RH_PLATFORM& authorization,
+      const std::string& authorization_name,
+      const TPMI_DH_OBJECT& key_handle,
+      const std::string& key_handle_name,
+      const TPM2B_DIGEST& fu_digest,
+      const TPMT_SIGNATURE& manifest_signature,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMT_HA& next_digest,
+                                  const TPMT_HA& first_digest)>
+      FieldUpgradeDataResponse;
+  static TPM_RC SerializeCommand_FieldUpgradeData(
+      const TPM2B_MAX_BUFFER& fu_data,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_FieldUpgradeData(
+      const std::string& response,
+      TPMT_HA* next_digest,
+      TPMT_HA* first_digest,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void FieldUpgradeData(const TPM2B_MAX_BUFFER& fu_data,
+                                AuthorizationDelegate* authorization_delegate,
+                                FieldUpgradeDataResponse callback);
+  virtual TPM_RC FieldUpgradeDataSync(
+      const TPM2B_MAX_BUFFER& fu_data,
+      TPMT_HA* next_digest,
+      TPMT_HA* first_digest,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_MAX_BUFFER& fu_data)>
+      FirmwareReadResponse;
+  static TPM_RC SerializeCommand_FirmwareRead(
+      const UINT32& sequence_number,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_FirmwareRead(
+      const std::string& response,
+      TPM2B_MAX_BUFFER* fu_data,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void FirmwareRead(const UINT32& sequence_number,
+                            AuthorizationDelegate* authorization_delegate,
+                            FirmwareReadResponse callback);
+  virtual TPM_RC FirmwareReadSync(
+      const UINT32& sequence_number,
+      TPM2B_MAX_BUFFER* fu_data,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMS_CONTEXT& context)>
+      ContextSaveResponse;
+  static TPM_RC SerializeCommand_ContextSave(
+      const TPMI_DH_CONTEXT& save_handle,
+      const std::string& save_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ContextSave(
+      const std::string& response,
+      TPMS_CONTEXT* context,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ContextSave(const TPMI_DH_CONTEXT& save_handle,
+                           const std::string& save_handle_name,
+                           AuthorizationDelegate* authorization_delegate,
+                           ContextSaveResponse callback);
+  virtual TPM_RC ContextSaveSync(const TPMI_DH_CONTEXT& save_handle,
+                                 const std::string& save_handle_name,
+                                 TPMS_CONTEXT* context,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_DH_CONTEXT& loaded_handle)>
+      ContextLoadResponse;
+  static TPM_RC SerializeCommand_ContextLoad(
+      const TPMS_CONTEXT& context,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ContextLoad(
+      const std::string& response,
+      TPMI_DH_CONTEXT* loaded_handle,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ContextLoad(const TPMS_CONTEXT& context,
+                           AuthorizationDelegate* authorization_delegate,
+                           ContextLoadResponse callback);
+  virtual TPM_RC ContextLoadSync(const TPMS_CONTEXT& context,
+                                 TPMI_DH_CONTEXT* loaded_handle,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> FlushContextResponse;
+  static TPM_RC SerializeCommand_FlushContext(
+      const TPMI_DH_CONTEXT& flush_handle,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_FlushContext(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void FlushContext(const TPMI_DH_CONTEXT& flush_handle,
+                            AuthorizationDelegate* authorization_delegate,
+                            FlushContextResponse callback);
+  virtual TPM_RC FlushContextSync(
+      const TPMI_DH_CONTEXT& flush_handle,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> EvictControlResponse;
+  static TPM_RC SerializeCommand_EvictControl(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_PERSISTENT& persistent_handle,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_EvictControl(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void EvictControl(const TPMI_RH_PROVISION& auth,
+                            const std::string& auth_name,
+                            const TPMI_DH_OBJECT& object_handle,
+                            const std::string& object_handle_name,
+                            const TPMI_DH_PERSISTENT& persistent_handle,
+                            AuthorizationDelegate* authorization_delegate,
+                            EvictControlResponse callback);
+  virtual TPM_RC EvictControlSync(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPMI_DH_OBJECT& object_handle,
+      const std::string& object_handle_name,
+      const TPMI_DH_PERSISTENT& persistent_handle,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMS_TIME_INFO& current_time)>
+      ReadClockResponse;
+  static TPM_RC SerializeCommand_ReadClock(
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ReadClock(
+      const std::string& response,
+      TPMS_TIME_INFO* current_time,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ReadClock(AuthorizationDelegate* authorization_delegate,
+                         ReadClockResponse callback);
+  virtual TPM_RC ReadClockSync(TPMS_TIME_INFO* current_time,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> ClockSetResponse;
+  static TPM_RC SerializeCommand_ClockSet(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const UINT64& new_time,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ClockSet(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ClockSet(const TPMI_RH_PROVISION& auth,
+                        const std::string& auth_name,
+                        const UINT64& new_time,
+                        AuthorizationDelegate* authorization_delegate,
+                        ClockSetResponse callback);
+  virtual TPM_RC ClockSetSync(const TPMI_RH_PROVISION& auth,
+                              const std::string& auth_name,
+                              const UINT64& new_time,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      ClockRateAdjustResponse;
+  static TPM_RC SerializeCommand_ClockRateAdjust(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPM_CLOCK_ADJUST& rate_adjust,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_ClockRateAdjust(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void ClockRateAdjust(const TPMI_RH_PROVISION& auth,
+                               const std::string& auth_name,
+                               const TPM_CLOCK_ADJUST& rate_adjust,
+                               AuthorizationDelegate* authorization_delegate,
+                               ClockRateAdjustResponse callback);
+  virtual TPM_RC ClockRateAdjustSync(
+      const TPMI_RH_PROVISION& auth,
+      const std::string& auth_name,
+      const TPM_CLOCK_ADJUST& rate_adjust,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPMI_YES_NO& more_data,
+                                  const TPMS_CAPABILITY_DATA& capability_data)>
+      GetCapabilityResponse;
+  static TPM_RC SerializeCommand_GetCapability(
+      const TPM_CAP& capability,
+      const UINT32& property,
+      const UINT32& property_count,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_GetCapability(
+      const std::string& response,
+      TPMI_YES_NO* more_data,
+      TPMS_CAPABILITY_DATA* capability_data,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void GetCapability(const TPM_CAP& capability,
+                             const UINT32& property,
+                             const UINT32& property_count,
+                             AuthorizationDelegate* authorization_delegate,
+                             GetCapabilityResponse callback);
+  virtual TPM_RC GetCapabilitySync(
+      const TPM_CAP& capability,
+      const UINT32& property,
+      const UINT32& property_count,
+      TPMI_YES_NO* more_data,
+      TPMS_CAPABILITY_DATA* capability_data,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> TestParmsResponse;
+  static TPM_RC SerializeCommand_TestParms(
+      const TPMT_PUBLIC_PARMS& parameters,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_TestParms(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void TestParms(const TPMT_PUBLIC_PARMS& parameters,
+                         AuthorizationDelegate* authorization_delegate,
+                         TestParmsResponse callback);
+  virtual TPM_RC TestParmsSync(const TPMT_PUBLIC_PARMS& parameters,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_DefineSpaceResponse;
+  static TPM_RC SerializeCommand_NV_DefineSpace(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_AUTH& auth,
+      const TPM2B_NV_PUBLIC& public_info,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_DefineSpace(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_DefineSpace(const TPMI_RH_PROVISION& auth_handle,
+                              const std::string& auth_handle_name,
+                              const TPM2B_AUTH& auth,
+                              const TPM2B_NV_PUBLIC& public_info,
+                              AuthorizationDelegate* authorization_delegate,
+                              NV_DefineSpaceResponse callback);
+  virtual TPM_RC NV_DefineSpaceSync(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      const TPM2B_AUTH& auth,
+      const TPM2B_NV_PUBLIC& public_info,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      NV_UndefineSpaceResponse;
+  static TPM_RC SerializeCommand_NV_UndefineSpace(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_UndefineSpace(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_UndefineSpace(const TPMI_RH_PROVISION& auth_handle,
+                                const std::string& auth_handle_name,
+                                const TPMI_RH_NV_INDEX& nv_index,
+                                const std::string& nv_index_name,
+                                AuthorizationDelegate* authorization_delegate,
+                                NV_UndefineSpaceResponse callback);
+  virtual TPM_RC NV_UndefineSpaceSync(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      NV_UndefineSpaceSpecialResponse;
+  static TPM_RC SerializeCommand_NV_UndefineSpaceSpecial(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPMI_RH_PLATFORM& platform,
+      const std::string& platform_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_UndefineSpaceSpecial(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_UndefineSpaceSpecial(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPMI_RH_PLATFORM& platform,
+      const std::string& platform_name,
+      AuthorizationDelegate* authorization_delegate,
+      NV_UndefineSpaceSpecialResponse callback);
+  virtual TPM_RC NV_UndefineSpaceSpecialSync(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPMI_RH_PLATFORM& platform,
+      const std::string& platform_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_NV_PUBLIC& nv_public,
+                                  const TPM2B_NAME& nv_name)>
+      NV_ReadPublicResponse;
+  static TPM_RC SerializeCommand_NV_ReadPublic(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_ReadPublic(
+      const std::string& response,
+      TPM2B_NV_PUBLIC* nv_public,
+      TPM2B_NAME* nv_name,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_ReadPublic(const TPMI_RH_NV_INDEX& nv_index,
+                             const std::string& nv_index_name,
+                             AuthorizationDelegate* authorization_delegate,
+                             NV_ReadPublicResponse callback);
+  virtual TPM_RC NV_ReadPublicSync(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      TPM2B_NV_PUBLIC* nv_public,
+      TPM2B_NAME* nv_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_WriteResponse;
+  static TPM_RC SerializeCommand_NV_Write(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPM2B_MAX_NV_BUFFER& data,
+      const UINT16& offset,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_Write(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_Write(const TPMI_RH_NV_AUTH& auth_handle,
+                        const std::string& auth_handle_name,
+                        const TPMI_RH_NV_INDEX& nv_index,
+                        const std::string& nv_index_name,
+                        const TPM2B_MAX_NV_BUFFER& data,
+                        const UINT16& offset,
+                        AuthorizationDelegate* authorization_delegate,
+                        NV_WriteResponse callback);
+  virtual TPM_RC NV_WriteSync(const TPMI_RH_NV_AUTH& auth_handle,
+                              const std::string& auth_handle_name,
+                              const TPMI_RH_NV_INDEX& nv_index,
+                              const std::string& nv_index_name,
+                              const TPM2B_MAX_NV_BUFFER& data,
+                              const UINT16& offset,
+                              AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_IncrementResponse;
+  static TPM_RC SerializeCommand_NV_Increment(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_Increment(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_Increment(const TPMI_RH_NV_AUTH& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPMI_RH_NV_INDEX& nv_index,
+                            const std::string& nv_index_name,
+                            AuthorizationDelegate* authorization_delegate,
+                            NV_IncrementResponse callback);
+  virtual TPM_RC NV_IncrementSync(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_ExtendResponse;
+  static TPM_RC SerializeCommand_NV_Extend(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPM2B_MAX_NV_BUFFER& data,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_Extend(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_Extend(const TPMI_RH_NV_AUTH& auth_handle,
+                         const std::string& auth_handle_name,
+                         const TPMI_RH_NV_INDEX& nv_index,
+                         const std::string& nv_index_name,
+                         const TPM2B_MAX_NV_BUFFER& data,
+                         AuthorizationDelegate* authorization_delegate,
+                         NV_ExtendResponse callback);
+  virtual TPM_RC NV_ExtendSync(const TPMI_RH_NV_AUTH& auth_handle,
+                               const std::string& auth_handle_name,
+                               const TPMI_RH_NV_INDEX& nv_index,
+                               const std::string& nv_index_name,
+                               const TPM2B_MAX_NV_BUFFER& data,
+                               AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_SetBitsResponse;
+  static TPM_RC SerializeCommand_NV_SetBits(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const UINT64& bits,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_SetBits(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_SetBits(const TPMI_RH_NV_AUTH& auth_handle,
+                          const std::string& auth_handle_name,
+                          const TPMI_RH_NV_INDEX& nv_index,
+                          const std::string& nv_index_name,
+                          const UINT64& bits,
+                          AuthorizationDelegate* authorization_delegate,
+                          NV_SetBitsResponse callback);
+  virtual TPM_RC NV_SetBitsSync(const TPMI_RH_NV_AUTH& auth_handle,
+                                const std::string& auth_handle_name,
+                                const TPMI_RH_NV_INDEX& nv_index,
+                                const std::string& nv_index_name,
+                                const UINT64& bits,
+                                AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_WriteLockResponse;
+  static TPM_RC SerializeCommand_NV_WriteLock(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_WriteLock(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_WriteLock(const TPMI_RH_NV_AUTH& auth_handle,
+                            const std::string& auth_handle_name,
+                            const TPMI_RH_NV_INDEX& nv_index,
+                            const std::string& nv_index_name,
+                            AuthorizationDelegate* authorization_delegate,
+                            NV_WriteLockResponse callback);
+  virtual TPM_RC NV_WriteLockSync(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      NV_GlobalWriteLockResponse;
+  static TPM_RC SerializeCommand_NV_GlobalWriteLock(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_GlobalWriteLock(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_GlobalWriteLock(const TPMI_RH_PROVISION& auth_handle,
+                                  const std::string& auth_handle_name,
+                                  AuthorizationDelegate* authorization_delegate,
+                                  NV_GlobalWriteLockResponse callback);
+  virtual TPM_RC NV_GlobalWriteLockSync(
+      const TPMI_RH_PROVISION& auth_handle,
+      const std::string& auth_handle_name,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_MAX_NV_BUFFER& data)>
+      NV_ReadResponse;
+  static TPM_RC SerializeCommand_NV_Read(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const UINT16& size,
+      const UINT16& offset,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_Read(
+      const std::string& response,
+      TPM2B_MAX_NV_BUFFER* data,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_Read(const TPMI_RH_NV_AUTH& auth_handle,
+                       const std::string& auth_handle_name,
+                       const TPMI_RH_NV_INDEX& nv_index,
+                       const std::string& nv_index_name,
+                       const UINT16& size,
+                       const UINT16& offset,
+                       AuthorizationDelegate* authorization_delegate,
+                       NV_ReadResponse callback);
+  virtual TPM_RC NV_ReadSync(const TPMI_RH_NV_AUTH& auth_handle,
+                             const std::string& auth_handle_name,
+                             const TPMI_RH_NV_INDEX& nv_index,
+                             const std::string& nv_index_name,
+                             const UINT16& size,
+                             const UINT16& offset,
+                             TPM2B_MAX_NV_BUFFER* data,
+                             AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_ReadLockResponse;
+  static TPM_RC SerializeCommand_NV_ReadLock(
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_ReadLock(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_ReadLock(const TPMI_RH_NV_AUTH& auth_handle,
+                           const std::string& auth_handle_name,
+                           const TPMI_RH_NV_INDEX& nv_index,
+                           const std::string& nv_index_name,
+                           AuthorizationDelegate* authorization_delegate,
+                           NV_ReadLockResponse callback);
+  virtual TPM_RC NV_ReadLockSync(const TPMI_RH_NV_AUTH& auth_handle,
+                                 const std::string& auth_handle_name,
+                                 const TPMI_RH_NV_INDEX& nv_index,
+                                 const std::string& nv_index_name,
+                                 AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code)> NV_ChangeAuthResponse;
+  static TPM_RC SerializeCommand_NV_ChangeAuth(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPM2B_AUTH& new_auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_ChangeAuth(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_ChangeAuth(const TPMI_RH_NV_INDEX& nv_index,
+                             const std::string& nv_index_name,
+                             const TPM2B_AUTH& new_auth,
+                             AuthorizationDelegate* authorization_delegate,
+                             NV_ChangeAuthResponse callback);
+  virtual TPM_RC NV_ChangeAuthSync(
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPM2B_AUTH& new_auth,
+      AuthorizationDelegate* authorization_delegate);
+  typedef base::OnceCallback<void(TPM_RC response_code,
+                                  const TPM2B_ATTEST& certify_info,
+                                  const TPMT_SIGNATURE& signature)>
+      NV_CertifyResponse;
+  static TPM_RC SerializeCommand_NV_Certify(
+      const TPMI_DH_OBJECT& sign_handle,
+      const std::string& sign_handle_name,
+      const TPMI_RH_NV_AUTH& auth_handle,
+      const std::string& auth_handle_name,
+      const TPMI_RH_NV_INDEX& nv_index,
+      const std::string& nv_index_name,
+      const TPM2B_DATA& qualifying_data,
+      const TPMT_SIG_SCHEME& in_scheme,
+      const UINT16& size,
+      const UINT16& offset,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_NV_Certify(
+      const std::string& response,
+      TPM2B_ATTEST* certify_info,
+      TPMT_SIGNATURE* signature,
+      AuthorizationDelegate* authorization_delegate);
+  virtual void NV_Certify(const TPMI_DH_OBJECT& sign_handle,
+                          const std::string& sign_handle_name,
+                          const TPMI_RH_NV_AUTH& auth_handle,
+                          const std::string& auth_handle_name,
+                          const TPMI_RH_NV_INDEX& nv_index,
+                          const std::string& nv_index_name,
+                          const TPM2B_DATA& qualifying_data,
+                          const TPMT_SIG_SCHEME& in_scheme,
+                          const UINT16& size,
+                          const UINT16& offset,
+                          AuthorizationDelegate* authorization_delegate,
+                          NV_CertifyResponse callback);
+  virtual TPM_RC NV_CertifySync(const TPMI_DH_OBJECT& sign_handle,
+                                const std::string& sign_handle_name,
+                                const TPMI_RH_NV_AUTH& auth_handle,
+                                const std::string& auth_handle_name,
+                                const TPMI_RH_NV_INDEX& nv_index,
+                                const std::string& nv_index_name,
+                                const TPM2B_DATA& qualifying_data,
+                                const TPMT_SIG_SCHEME& in_scheme,
+                                const UINT16& size,
+                                const UINT16& offset,
+                                TPM2B_ATTEST* certify_info,
+                                TPMT_SIGNATURE* signature,
+                                AuthorizationDelegate* authorization_delegate);
+
+  typedef base::OnceCallback<void(TPM_RC response_code)>
+      PolicyFidoSignedResponse;
+  static TPM_RC SerializeCommand_PolicyFidoSigned(
+      const TPMI_DH_OBJECT& auth_object,
+      const std::string& auth_object_name,
+      const TPMI_SH_POLICY& policy_session,
+      const std::string& policy_session_name,
+      const std::string& auth_data,
+      const std::vector<FIDO_DATA_RANGE>& auth_data_descr,
+      const TPMT_SIGNATURE& auth,
+      std::string* serialized_command,
+      AuthorizationDelegate* authorization_delegate);
+  static TPM_RC ParseResponse_PolicyFidoSigned(
+      const std::string& response,
+      AuthorizationDelegate* authorization_delegate);
+
+ private:
+  CommandTransceiver* transceiver_;
+};
+
+}  // namespace trunks
+
+#endif  // TRUNKS_TPM_GENERATED_H_
diff --git a/tpm_generated/tpm_generated_test.cc b/tpm_generated/tpm_generated_test.cc
new file mode 100644
index 000000000..5e8fefa30
--- /dev/null
+++ b/tpm_generated/tpm_generated_test.cc
@@ -0,0 +1,458 @@
+// Copyright 2014 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Note: These tests are not generated. They test generated code.
+
+#include <iterator>
+#include <utility>
+
+#include <gtest/gtest.h>
+
+#include "mock_authorization_delegate.h"
+#include "mock_command_transceiver.h"
+#include "tpm_generated.h"
+
+using testing::_;
+using testing::DoAll;
+using testing::Invoke;
+using testing::Return;
+using testing::SetArgPointee;
+using testing::StrictMock;
+using testing::WithArg;
+
+namespace trunks {
+
+// This test is designed to get good coverage of the different types of code
+// generated for serializing and parsing structures / unions / typedefs.
+TEST(GeneratorTest, SerializeParseStruct) {
+  TPM2B_CREATION_DATA data;
+  memset(&data, 0, sizeof(TPM2B_CREATION_DATA));
+  data.size = sizeof(TPMS_CREATION_DATA);
+  data.creation_data.pcr_select.count = 1;
+  data.creation_data.pcr_select.pcr_selections[0].hash = TPM_ALG_SHA256;
+  data.creation_data.pcr_select.pcr_selections[0].sizeof_select = 1;
+  data.creation_data.pcr_select.pcr_selections[0].pcr_select[0] = 0;
+  data.creation_data.pcr_digest.size = 2;
+  data.creation_data.locality = 0;
+  data.creation_data.parent_name_alg = TPM_ALG_SHA256;
+  data.creation_data.parent_name.size = 3;
+  data.creation_data.parent_qualified_name.size = 4;
+  data.creation_data.outside_info.size = 5;
+  std::string buffer;
+  TPM_RC rc = Serialize_TPM2B_CREATION_DATA(data, &buffer);
+  ASSERT_EQ(TPM_RC_SUCCESS, rc);
+  EXPECT_EQ(35u, buffer.size());
+  TPM2B_CREATION_DATA data2;
+  memset(&data2, 0, sizeof(TPM2B_CREATION_DATA));
+  std::string buffer_before = buffer;
+  std::string buffer_parsed;
+  rc = Parse_TPM2B_CREATION_DATA(&buffer, &data2, &buffer_parsed);
+  ASSERT_EQ(TPM_RC_SUCCESS, rc);
+  EXPECT_EQ(0u, buffer.size());
+  EXPECT_EQ(buffer_before, buffer_parsed);
+  EXPECT_EQ(data.size, data2.size);
+  EXPECT_EQ(0, memcmp(&data.creation_data, &data2.creation_data,
+                      sizeof(TPMS_CREATION_DATA)));
+}
+
+// This tests serializing and parsing TPM2B_ structures with zero |size|, in
+// which case the enclosed structure isn't marshalled.
+TEST(GeneratorTest, SerializeParseEmptyStruct) {
+  TPM2B_CREATION_DATA data;
+  memset(&data, 0, sizeof(TPM2B_CREATION_DATA));
+  std::string buffer;
+  TPM_RC rc = Serialize_TPM2B_CREATION_DATA(data, &buffer);
+  ASSERT_EQ(TPM_RC_SUCCESS, rc);
+  EXPECT_EQ(2u, buffer.size());
+  TPM2B_CREATION_DATA data2;
+  memset(&data2, 0, sizeof(TPM2B_CREATION_DATA));
+  std::string buffer_before = buffer;
+  std::string buffer_parsed;
+  rc = Parse_TPM2B_CREATION_DATA(&buffer, &data2, &buffer_parsed);
+  ASSERT_EQ(TPM_RC_SUCCESS, rc);
+  EXPECT_EQ(0u, buffer.size());
+  EXPECT_EQ(buffer_before, buffer_parsed);
+  EXPECT_EQ(data.size, data2.size);
+  EXPECT_EQ(0, memcmp(&data.creation_data, &data2.creation_data,
+                      sizeof(TPMS_CREATION_DATA)));
+}
+
+TEST(GeneratorTest, SerializeBufferOverflow) {
+  TPM2B_MAX_BUFFER value;
+  value.size = std::size(value.buffer) + 1;
+  std::string tmp;
+  EXPECT_EQ(TPM_RC_INSUFFICIENT, Serialize_TPM2B_MAX_BUFFER(value, &tmp));
+}
+
+TEST(GeneratorTest, ParseBufferOverflow) {
+  TPM2B_MAX_BUFFER tmp;
+  // Case 1: Sufficient source but overflow the destination.
+  std::string malformed1 = "\x10\x00";
+  malformed1 += std::string(0x1000, 'A');
+  ASSERT_GT(0x1000u, sizeof(tmp.buffer));
+  EXPECT_EQ(TPM_RC_INSUFFICIENT,
+            Parse_TPM2B_MAX_BUFFER(&malformed1, &tmp, nullptr));
+  // Case 2: Sufficient destination but overflow the source.
+  std::string malformed2 = "\x00\x01";
+  EXPECT_EQ(TPM_RC_INSUFFICIENT,
+            Parse_TPM2B_MAX_BUFFER(&malformed2, &tmp, nullptr));
+}
+
+TEST(GeneratorTest, SynchronousCommand) {
+  // A hand-rolled TPM2_Startup command.
+  std::string expected_command(
+      "\x80\x01"          // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0C"  // size=12
+      "\x00\x00\x01\x44"  // code=TPM_CC_Startup
+      "\x00\x00",         // param=TPM_SU_CLEAR
+      12);
+  std::string command_response(
+      "\x80\x01"           // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0A"   // size=10
+      "\x00\x00\x00\x00",  // code=TPM_RC_SUCCESS
+      10);
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommandAndWait(expected_command))
+      .WillOnce(Return(command_response));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(Return(true));
+  Tpm tpm(&transceiver);
+  EXPECT_EQ(TPM_RC_SUCCESS, tpm.StartupSync(TPM_SU_CLEAR, &authorization));
+}
+
+TEST(GeneratorTest, SynchronousCommandWithError) {
+  // A hand-rolled TPM2_Startup command.
+  std::string expected_command(
+      "\x80\x01"          // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0C"  // size=12
+      "\x00\x00\x01\x44"  // code=TPM_CC_Startup
+      "\x00\x00",         // param=TPM_SU_CLEAR
+      12);
+  std::string command_response(
+      "\x80\x01"           // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0A"   // size=10
+      "\x00\x00\x01\x01",  // code=TPM_RC_FAILURE
+      10);
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommandAndWait(expected_command))
+      .WillOnce(Return(command_response));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(Return(true));
+  Tpm tpm(&transceiver);
+  EXPECT_EQ(TPM_RC_FAILURE, tpm.StartupSync(TPM_SU_CLEAR, &authorization));
+}
+
+TEST(GeneratorTest, SynchronousCommandResponseTest) {
+  std::string auth_in(10, 'A');
+  std::string auth_out(10, 'B');
+  std::string auth_size("\x00\x00\x00\x0A", 4);
+  std::string handle_in("\x40\x00\x00\x07", 4);  // primary_handle = TPM_RH_NULL
+  std::string handle_out("\x80\x00\x00\x01", 4);  // out_handle
+  std::string sensitive(
+      "\x00\x05"   // sensitive.size = 5
+      "\x00\x01"   // sensitive.auth.size = 1
+      "\x61"       // sensitive.auth.buffer[0] = 0x65
+      "\x00\x00",  // sensitive.data.size = 0
+      7);
+  std::string public_data(
+      "\x00\x12"  // public.size = 18
+      "\x00\x25"  // public.type = TPM_ALG_SYMCIPHER
+      "\x00\x0B"  // public.name_alg = SHA256
+      "\x00\x00\x00\x00"
+      "\x00\x00"   // public.auth_policy.size = 0
+      "\x00\x06"   // public.sym.alg = TPM_ALG_AES
+      "\x00\x80"   // public.sym.key_bits = 128
+      "\x00\x43"   // public.sym.mode = TPM_ALG_CFB
+      "\x00\x00",  // public.unique.size = 0
+      20);
+  std::string outside("\x00\x00", 2);             // outside_info.size = 0
+  std::string pcr_select("\x00\x00\x00\x00", 4);  // pcr_select.size = 0
+
+  std::string data(
+      "\x00\x0F"          // creation_data.size = 15
+      "\x00\x00\x00\x00"  // creation.pcr = 0
+      "\x00\x00"          // creation.digest.size = 0
+      "\x00"              // creation.locality = 0
+      "\x00\x00"          // creation.parent_alg = 0
+      "\x00\x00"          // creation.parent_name.size = 0
+      "\x00\x00"
+      "\x00\x00",  // creation.outside.size = 0
+      17);
+  std::string hash(
+      "\x00\x01"
+      "\x62",
+      3);
+  std::string ticket(
+      "\x80\x02"          // tag = TPM_ST_SESSIONS
+      "\x40\x00\x00\x07"  // parent = TPM_RH_NULL
+      "\x00\x00",
+      8);
+  std::string name(
+      "\x00\x03"
+      "KEY",
+      5);
+  std::string parameter_size("\x00\x00\x00\x35", 4);  // param_size = 38
+
+  std::string command_tag(
+      "\x80\x02"           // tag = TPM_ST_SESSIONS
+      "\x00\x00\x00\x3D"   // size = 61
+      "\x00\x00\x01\x31",  // code = TPM_CC_CreatePrimary
+      10);
+  std::string response_tag(
+      "\x80\x02"           // tag = TPM_ST_SESSIONS
+      "\x00\x00\x00\x51"   // size = 79
+      "\x00\x00\x00\x00",  // rc = TPM_RC_SUCCESS
+      10);
+
+  std::string expected_command = command_tag + handle_in + auth_size + auth_in +
+                                 sensitive + public_data + outside + pcr_select;
+  std::string command_response = response_tag + handle_out + parameter_size +
+                                 public_data + data + hash + ticket + name +
+                                 auth_out;
+
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommandAndWait(expected_command))
+      .WillOnce(Return(command_response));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(DoAll(SetArgPointee<3>(auth_in), Return(true)));
+  EXPECT_CALL(authorization, CheckResponseAuthorization(_, auth_out))
+      .WillOnce(Return(true));
+  EXPECT_CALL(authorization, EncryptCommandParameter(_)).WillOnce(Return(true));
+  EXPECT_CALL(authorization, DecryptResponseParameter(_))
+      .WillOnce(Return(true));
+
+  TPM2B_SENSITIVE_CREATE in_sensitive;
+  in_sensitive.size = sizeof(TPMS_SENSITIVE_CREATE);
+  in_sensitive.sensitive.user_auth.size = 1;
+  in_sensitive.sensitive.user_auth.buffer[0] = 'a';
+  in_sensitive.sensitive.data.size = 0;
+  TPM2B_PUBLIC in_public;
+  in_public.size = sizeof(TPMT_PUBLIC);
+  in_public.public_area.type = TPM_ALG_SYMCIPHER;
+  in_public.public_area.name_alg = TPM_ALG_SHA256;
+  in_public.public_area.object_attributes = 0;
+  in_public.public_area.auth_policy.size = 0;
+  in_public.public_area.parameters.sym_detail.sym.algorithm = TPM_ALG_AES;
+  in_public.public_area.parameters.sym_detail.sym.key_bits.aes = 128;
+  in_public.public_area.parameters.sym_detail.sym.mode.aes = TPM_ALG_CFB;
+  in_public.public_area.unique.sym.size = 0;
+  TPM2B_DATA outside_info;
+  outside_info.size = 0;
+  TPML_PCR_SELECTION create_pcr;
+  create_pcr.count = 0;
+
+  TPM_HANDLE key_handle;
+  TPM2B_PUBLIC out_public;
+  TPM2B_CREATION_DATA creation_data;
+  TPM2B_DIGEST creation_hash;
+  TPMT_TK_CREATION creation_ticket;
+  TPM2B_NAME key_name;
+
+  Tpm tpm(&transceiver);
+  TPM_RC rc = tpm.CreatePrimarySync(
+      trunks::TPM_RH_NULL, "", in_sensitive, in_public, outside_info,
+      create_pcr, &key_handle, &out_public, &creation_data, &creation_hash,
+      &creation_ticket, &key_name, &authorization);
+  ASSERT_EQ(rc, TPM_RC_SUCCESS);
+  EXPECT_EQ(key_handle, 0x80000001);
+  EXPECT_EQ(out_public.size, sizeof(TPMT_PUBLIC));
+  EXPECT_EQ(creation_data.size, sizeof(TPMS_CREATION_DATA));
+  EXPECT_EQ(creation_hash.size, 1);
+  EXPECT_EQ(creation_hash.buffer[0], 'b');
+  EXPECT_EQ(creation_ticket.tag, 0x8002);
+  EXPECT_EQ(creation_ticket.hierarchy, 0x40000007u);
+  EXPECT_EQ(creation_ticket.digest.size, 0);
+  EXPECT_EQ(key_name.size, 3);
+  EXPECT_EQ(key_name.name[0], 'K');
+  EXPECT_EQ(key_name.name[1], 'E');
+  EXPECT_EQ(key_name.name[2], 'Y');
+}
+
+// A fixture for asynchronous command flow tests.
+class CommandFlowTest : public testing::Test {
+ public:
+  CommandFlowTest() : response_code_(TPM_RC_SUCCESS) {}
+  ~CommandFlowTest() override {}
+
+  void StartupCallback(TPM_RC response_code) { response_code_ = response_code; }
+
+  void CertifyCallback(TPM_RC response_code,
+                       const TPM2B_ATTEST& certify_info,
+                       const TPMT_SIGNATURE& signature) {
+    response_code_ = response_code;
+    signed_data_ = StringFrom_TPM2B_ATTEST(certify_info);
+    signature_ =
+        StringFrom_TPM2B_PUBLIC_KEY_RSA(signature.signature.rsassa.sig);
+  }
+
+ protected:
+  void Run() {}
+
+  TPM_RC response_code_;
+  std::string signature_;
+  std::string signed_data_;
+};
+
+// A functor for posting command responses.
+class PostResponse {
+ public:
+  explicit PostResponse(const std::string& response) : response_(response) {}
+  void operator()(base::OnceCallback<void(const std::string&)> callback) {
+    std::move(callback).Run(response_);
+  }
+
+ private:
+  std::string response_;
+};
+
+// A functor to handle fake encryption / decryption of parameters.
+class Encryptor {
+ public:
+  Encryptor(const std::string& expected_input, const std::string& output)
+      : expected_input_(expected_input), output_(output) {}
+  bool operator()(std::string* value) {
+    EXPECT_EQ(expected_input_, *value);
+    value->assign(output_);
+    return true;
+  }
+
+ private:
+  std::string expected_input_;
+  std::string output_;
+};
+
+TEST_F(CommandFlowTest, SimpleCommandFlow) {
+  // A hand-rolled TPM2_Startup command.
+  std::string expected_command(
+      "\x80\x01"          // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0C"  // size=12
+      "\x00\x00\x01\x44"  // code=TPM_CC_Startup
+      "\x00\x00",         // param=TPM_SU_CLEAR
+      12);
+  std::string command_response(
+      "\x80\x01"           // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0A"   // size=10
+      "\x00\x00\x00\x00",  // code=TPM_RC_SUCCESS
+      10);
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommand(expected_command, _))
+      .WillOnce(WithArg<1>(Invoke(PostResponse(command_response))));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(Return(true));
+  Tpm tpm(&transceiver);
+  response_code_ = TPM_RC_FAILURE;
+  tpm.Startup(TPM_SU_CLEAR, &authorization,
+              std::function<void(TPM_RC)>([this](TPM_RC response_code) {
+                this->StartupCallback(response_code);
+              }));
+  Run();
+  EXPECT_EQ(TPM_RC_SUCCESS, response_code_);
+}
+
+TEST_F(CommandFlowTest, SimpleCommandFlowWithError) {
+  // A hand-rolled TPM2_Startup command.
+  std::string expected_command(
+      "\x80\x01"          // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0C"  // size=12
+      "\x00\x00\x01\x44"  // code=TPM_CC_Startup
+      "\x00\x00",         // param=TPM_SU_CLEAR
+      12);
+  std::string command_response(
+      "\x80\x01"           // tag=TPM_ST_NO_SESSIONS
+      "\x00\x00\x00\x0A"   // size=10
+      "\x00\x00\x01\x01",  // code=TPM_RC_FAILURE
+      10);
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommand(expected_command, _))
+      .WillOnce(WithArg<1>(Invoke(PostResponse(command_response))));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(Return(true));
+  Tpm tpm(&transceiver);
+  tpm.Startup(TPM_SU_CLEAR, &authorization,
+              std::function<void(TPM_RC)>([this](TPM_RC response_code) {
+                this->StartupCallback(response_code);
+              }));
+  Run();
+  EXPECT_EQ(TPM_RC_FAILURE, response_code_);
+}
+
+// This test is designed to get good coverage of the different types of code
+// generated for command / response processing. It covers:
+// - input handles
+// - authorization
+// - multiple input and output parameters
+// - parameter encryption and decryption
+TEST_F(CommandFlowTest, FullCommandFlow) {
+  // A hand-rolled TPM2_Certify command.
+  std::string auth_in(10, 'A');
+  std::string auth_out(20, 'B');
+  std::string user_data(
+      "\x00\x0C"
+      "ct_user_data",
+      14);
+  std::string scheme("\x00\x10", 2);  // scheme=TPM_ALG_NULL
+  std::string signed_data(
+      "\x00\x0E"
+      "ct_signed_data",
+      16);
+  std::string signature(
+      "\x00\x14"    // sig_scheme=RSASSA
+      "\x00\x0B"    // hash_scheme=SHA256
+      "\x00\x09"    // signature size
+      "signature",  // signature bytes
+      15);
+  std::string expected_command(
+      "\x80\x02"           // tag=TPM_ST_SESSIONS
+      "\x00\x00\x00\x30"   // size=48
+      "\x00\x00\x01\x48"   // code=TPM_CC_Certify
+      "\x11\x22\x33\x44"   // @objectHandle
+      "\x55\x66\x77\x88"   // @signHandle
+      "\x00\x00\x00\x0A",  // auth_size=10
+      22);
+  expected_command += auth_in + user_data + scheme;
+  std::string command_response(
+      "\x80\x02"           // tag=TPM_ST_SESSIONS
+      "\x00\x00\x00\x41"   // size=65
+      "\x00\x00\x00\x00"   // code=TPM_RC_SUCCESS
+      "\x00\x00\x00\x1F",  // param_size=31
+      14);
+  command_response += signed_data + signature + auth_out;
+
+  StrictMock<MockCommandTransceiver> transceiver;
+  EXPECT_CALL(transceiver, SendCommand(expected_command, _))
+      .WillOnce(WithArg<1>(Invoke(PostResponse(command_response))));
+  StrictMock<MockAuthorizationDelegate> authorization;
+  EXPECT_CALL(authorization, GetCommandAuthorization(_, _, _, _))
+      .WillOnce(DoAll(SetArgPointee<3>(auth_in), Return(true)));
+  EXPECT_CALL(authorization, CheckResponseAuthorization(_, auth_out))
+      .WillOnce(Return(true));
+  EXPECT_CALL(authorization, EncryptCommandParameter(_))
+      .WillOnce(Invoke(Encryptor("pt_user_data", "ct_user_data")));
+  EXPECT_CALL(authorization, DecryptResponseParameter(_))
+      .WillOnce(Invoke(Encryptor("ct_signed_data", "pt_signed_data")));
+
+  TPMT_SIG_SCHEME null_scheme;
+  null_scheme.scheme = TPM_ALG_NULL;
+  null_scheme.details.rsassa.hash_alg = TPM_ALG_SHA256;
+  Tpm tpm(&transceiver);
+  tpm.Certify(
+      0x11223344u, "object_handle", 0x55667788u, "sign_handle",
+      Make_TPM2B_DATA("pt_user_data"), null_scheme, &authorization,
+      std::function<void(TPM_RC, const TPM2B_ATTEST&, const TPMT_SIGNATURE&)>(
+          [this](TPM_RC response_code, const TPM2B_ATTEST& certify_info,
+                 const TPMT_SIGNATURE& signature) {
+            this->CertifyCallback(response_code, certify_info, signature);
+          }));
+  Run();
+  ASSERT_EQ(TPM_RC_SUCCESS, response_code_);
+  EXPECT_EQ("pt_signed_data", signed_data_);
+  EXPECT_EQ("signature", signature_);
+}
+
+}  // namespace trunks
diff --git a/tpm_generated/trunks_export.h b/tpm_generated/trunks_export.h
new file mode 100644
index 000000000..3e95015a5
--- /dev/null
+++ b/tpm_generated/trunks_export.h
@@ -0,0 +1,12 @@
+// Copyright 2015 The ChromiumOS Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef TRUNKS_TRUNKS_EXPORT_H_
+#define TRUNKS_TRUNKS_EXPORT_H_
+
+// Use this for any class or function that needs to be exported from libtrunks.
+// E.g. TRUNKS_EXPORT void foo();
+#define TRUNKS_EXPORT __attribute__((__visibility__("default")))
+
+#endif  // TRUNKS_TRUNKS_EXPORT_H_
```

