```diff
diff --git a/.clang-format b/.clang-format
index ba0bff311e..2759015822 100644
--- a/.clang-format
+++ b/.clang-format
@@ -14,7 +14,7 @@ AttributeMacros: ['__', 'NO_RETURN']
 BinPackArguments: false
 BinPackParameters: false
 BreakConstructorInitializers: BeforeColon
-BreakBeforeTernaryOperators: false
+BreakBeforeTernaryOperators: true
 ColumnLimit: 100
 CommentPragmas: NOLINT:.*
 ConstructorInitializerAllOnOneLineOrOnePerLine: true
diff --git a/.clang-format-java-2 b/.clang-format-java-2
index 956bdcde6b..84eee46d67 100644
--- a/.clang-format-java-2
+++ b/.clang-format-java-2
@@ -16,7 +16,7 @@ AttributeMacros: ['__', 'NO_RETURN']
 BinPackArguments: false
 BinPackParameters: false
 BreakConstructorInitializers: BeforeColon
-BreakBeforeTernaryOperators: false
+BreakBeforeTernaryOperators: true
 ColumnLimit: 100
 CommentPragmas: NOLINT:.*
 ConstructorInitializerAllOnOneLineOrOnePerLine: true
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 29ecd3bfe3..095baad00c 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -142,6 +142,9 @@
     {
       "name": "art-run-test-055-enum-performance"
     },
+    {
+      "name": "art-run-test-057-math-intrinsics"
+    },
     {
       "name": "art-run-test-058-enum-order"
     },
@@ -529,6 +532,12 @@
     {
       "name": "art-run-test-2279-second-inner-loop-references-first"
     },
+    {
+      "name": "art-run-test-2282-checker-always-throws-try-catch"
+    },
+    {
+      "name": "art-run-test-2283-checker-remove-null-check"
+    },
     {
       "name": "art-run-test-300-package-override"
     },
@@ -1378,6 +1387,12 @@
     {
       "name": "art-run-test-857-default-access"
     },
+    {
+      "name": "art-run-test-858-checker-unsafe"
+    },
+    {
+      "name": "art-run-test-859-checker-var-handles-intrinsics"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -1404,6 +1419,9 @@
         }
       ]
     },
+    {
+      "name": "art_standalone_dex2oat_cts_tests"
+    },
     {
       "name": "art_standalone_dex2oat_tests"
     },
@@ -1460,6 +1478,9 @@
     {
       "name": "art_standalone_sigchain_tests"
     },
+    {
+      "name": "libnativebridge-lazy-tests"
+    },
     {
       "name": "libnativebridge-tests"
     },
@@ -1612,6 +1633,9 @@
     {
       "name": "art-run-test-055-enum-performance[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-057-math-intrinsics[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-058-enum-order[com.google.android.art.apex]"
     },
@@ -1999,6 +2023,12 @@
     {
       "name": "art-run-test-2279-second-inner-loop-references-first[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-2282-checker-always-throws-try-catch[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-2283-checker-remove-null-check[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-300-package-override[com.google.android.art.apex]"
     },
@@ -2848,6 +2878,12 @@
     {
       "name": "art-run-test-857-default-access[com.google.android.art.apex]"
     },
+    {
+      "name": "art-run-test-858-checker-unsafe[com.google.android.art.apex]"
+    },
+    {
+      "name": "art-run-test-859-checker-var-handles-intrinsics[com.google.android.art.apex]"
+    },
     {
       "name": "art-run-test-963-default-range-smali[com.google.android.art.apex]"
     },
@@ -2874,6 +2910,9 @@
         }
       ]
     },
+    {
+      "name": "art_standalone_dex2oat_cts_tests[com.google.android.art.apex]"
+    },
     {
       "name": "art_standalone_dex2oat_tests[com.google.android.art.apex]"
     },
@@ -2930,6 +2969,9 @@
     {
       "name": "art_standalone_sigchain_tests[com.google.android.art.apex]"
     },
+    {
+      "name": "libnativebridge-lazy-tests[com.google.android.art.apex]"
+    },
     {
       "name": "libnativebridge-tests[com.google.android.art.apex]"
     },
@@ -3097,6 +3139,9 @@
     {
       "name": "art-run-test-055-enum-performance"
     },
+    {
+      "name": "art-run-test-057-math-intrinsics"
+    },
     {
       "name": "art-run-test-058-enum-order"
     },
@@ -3484,6 +3529,12 @@
     {
       "name": "art-run-test-2279-second-inner-loop-references-first"
     },
+    {
+      "name": "art-run-test-2282-checker-always-throws-try-catch"
+    },
+    {
+      "name": "art-run-test-2283-checker-remove-null-check"
+    },
     {
       "name": "art-run-test-300-package-override"
     },
@@ -4333,6 +4384,12 @@
     {
       "name": "art-run-test-857-default-access"
     },
+    {
+      "name": "art-run-test-858-checker-unsafe"
+    },
+    {
+      "name": "art-run-test-859-checker-var-handles-intrinsics"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -4354,6 +4411,9 @@
     {
       "name": "art_standalone_compiler_tests"
     },
+    {
+      "name": "art_standalone_dex2oat_cts_tests"
+    },
     {
       "name": "art_standalone_dex2oat_tests"
     },
@@ -4405,6 +4465,9 @@
     {
       "name": "art_standalone_sigchain_tests"
     },
+    {
+      "name": "libnativebridge-lazy-tests"
+    },
     {
       "name": "libnativebridge-tests"
     },
@@ -4569,6 +4632,9 @@
     {
       "name": "art-run-test-055-enum-performance"
     },
+    {
+      "name": "art-run-test-057-math-intrinsics"
+    },
     {
       "name": "art-run-test-058-enum-order"
     },
@@ -4956,6 +5022,12 @@
     {
       "name": "art-run-test-2279-second-inner-loop-references-first"
     },
+    {
+      "name": "art-run-test-2282-checker-always-throws-try-catch"
+    },
+    {
+      "name": "art-run-test-2283-checker-remove-null-check"
+    },
     {
       "name": "art-run-test-300-package-override"
     },
@@ -5805,6 +5877,12 @@
     {
       "name": "art-run-test-857-default-access"
     },
+    {
+      "name": "art-run-test-858-checker-unsafe"
+    },
+    {
+      "name": "art-run-test-859-checker-var-handles-intrinsics"
+    },
     {
       "name": "art-run-test-963-default-range-smali"
     },
@@ -5826,6 +5904,9 @@
     {
       "name": "art_standalone_compiler_tests"
     },
+    {
+      "name": "art_standalone_dex2oat_cts_tests"
+    },
     {
       "name": "art_standalone_dex2oat_tests"
     },
@@ -5874,6 +5955,9 @@
     {
       "name": "art_standalone_sigchain_tests"
     },
+    {
+      "name": "libnativebridge-lazy-tests"
+    },
     {
       "name": "libnativebridge-tests"
     },
@@ -5888,13 +5972,5 @@
     {
       "name": "ComposHostTestCases"
     }
-  ],
-  "postsubmit": [
-    {
-      "name": "art-run-test-057-math-intrinsics"
-    },
-    {
-      "name": "art_standalone_dex2oat_cts_tests"
-    }
   ]
 }
diff --git a/adbconnection/Android.bp b/adbconnection/Android.bp
index 9763d662db..941aac5ed6 100644
--- a/adbconnection/Android.bp
+++ b/adbconnection/Android.bp
@@ -43,18 +43,11 @@ cc_defaults {
         "libbase",
         "libadbconnection_client",
     ],
-    target: {
-        host: {
-        },
-        darwin: {
-            enabled: false,
-        },
-    },
     header_libs: [
         "libnativehelper_header_only",
         "dt_fd_forward_export",
     ],
-    required: [
+    runtime_libs: [
         "libjdwp",
         "libdt_fd_forward",
     ],
diff --git a/artd/Android.bp b/artd/Android.bp
index ea4de5219f..63e4914f04 100644
--- a/artd/Android.bp
+++ b/artd/Android.bp
@@ -64,7 +64,7 @@ art_cc_binary {
         "libartservice",
         "libarttools",
         "libbase",
-        "libdexfile",
+        "libdexfile#impl",
     ],
     apex_available: [
         "com.android.art",
@@ -75,6 +75,9 @@ art_cc_binary {
 art_cc_defaults {
     name: "art_artd_tests_defaults",
     defaults: ["artd_defaults"],
+    header_libs: [
+        "libarttools_testing",
+    ],
     static_libs: [
         "libgmock",
     ],
@@ -83,7 +86,7 @@ art_cc_defaults {
         "file_utils_test.cc",
         "path_utils_test.cc",
     ],
-    data: [
+    device_common_data: [
         ":art-gtest-jars-Main",
         ":art-gtest-jars-Nested",
     ],
@@ -107,6 +110,7 @@ art_cc_test {
         "libarttools",
         "libbase",
         "libdexfile",
+        "libprofile",
     ],
 }
 
@@ -123,6 +127,7 @@ art_cc_test {
         "libarttools",
         "libbase",
         "libdexfile",
+        "libprofile",
     ],
     test_config_template: "art_standalone_artd_tests.xml",
 }
diff --git a/artd/artd.cc b/artd/artd.cc
index 493cc10926..41309f91a6 100644
--- a/artd/artd.cc
+++ b/artd/artd.cc
@@ -17,7 +17,9 @@
 #include "artd.h"
 
 #include <fcntl.h>
+#include <sys/inotify.h>
 #include <sys/mount.h>
+#include <sys/poll.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -34,6 +36,7 @@
 #include <map>
 #include <memory>
 #include <mutex>
+#include <new>
 #include <optional>
 #include <ostream>
 #include <regex>
@@ -45,9 +48,11 @@
 #include <utility>
 #include <vector>
 
+#include "aidl/com/android/server/art/ArtConstants.h"
 #include "aidl/com/android/server/art/BnArtd.h"
 #include "aidl/com/android/server/art/DexoptTrigger.h"
 #include "aidl/com/android/server/art/IArtdCancellationSignal.h"
+#include "aidl/com/android/server/art/IArtdNotification.h"
 #include "android-base/errors.h"
 #include "android-base/file.h"
 #include "android-base/logging.h"
@@ -55,6 +60,7 @@
 #include "android-base/result.h"
 #include "android-base/scopeguard.h"
 #include "android-base/strings.h"
+#include "android-base/unique_fd.h"
 #include "android/binder_auto_utils.h"
 #include "android/binder_interface_utils.h"
 #include "android/binder_manager.h"
@@ -68,6 +74,8 @@
 #include "base/mem_map.h"
 #include "base/memfd.h"
 #include "base/os.h"
+#include "base/pidfd.h"
+#include "base/time_utils.h"
 #include "base/zip_archive.h"
 #include "cmdline_types.h"
 #include "dex/dex_file_loader.h"
@@ -90,6 +98,7 @@ namespace artd {
 
 namespace {
 
+using ::aidl::com::android::server::art::ArtConstants;
 using ::aidl::com::android::server::art::ArtdDexoptResult;
 using ::aidl::com::android::server::art::ArtifactsLocation;
 using ::aidl::com::android::server::art::ArtifactsPath;
@@ -102,6 +111,7 @@ using ::aidl::com::android::server::art::FsPermission;
 using ::aidl::com::android::server::art::GetDexoptNeededResult;
 using ::aidl::com::android::server::art::GetDexoptStatusResult;
 using ::aidl::com::android::server::art::IArtdCancellationSignal;
+using ::aidl::com::android::server::art::IArtdNotification;
 using ::aidl::com::android::server::art::MergeProfileOptions;
 using ::aidl::com::android::server::art::OutputArtifacts;
 using ::aidl::com::android::server::art::OutputProfile;
@@ -109,6 +119,7 @@ using ::aidl::com::android::server::art::PriorityClass;
 using ::aidl::com::android::server::art::ProfilePath;
 using ::aidl::com::android::server::art::RuntimeArtifactsPath;
 using ::aidl::com::android::server::art::VdexPath;
+using ::android::base::Basename;
 using ::android::base::Dirname;
 using ::android::base::ErrnoError;
 using ::android::base::Error;
@@ -120,6 +131,7 @@ using ::android::base::Result;
 using ::android::base::Split;
 using ::android::base::Tokenize;
 using ::android::base::Trim;
+using ::android::base::unique_fd;
 using ::android::base::WriteStringToFd;
 using ::android::base::WriteStringToFile;
 using ::android::fs_mgr::FstabEntry;
@@ -131,6 +143,7 @@ using ::art::tools::GetProcMountsAncestorsOfPath;
 using ::art::tools::NonFatal;
 using ::ndk::ScopedAStatus;
 
+using PrimaryCurProfilePath = ProfilePath::PrimaryCurProfilePath;
 using TmpProfilePath = ProfilePath::TmpProfilePath;
 using WritableProfilePath = ProfilePath::WritableProfilePath;
 
@@ -372,7 +385,8 @@ CopyAndRewriteProfileResult AnalyzeCopyAndRewriteProfileFailure(
     if (zip_archive == nullptr) {
       return bad_profile(error_msg);
     }
-    std::unique_ptr<ZipEntry> zip_entry(zip_archive->Find("primary.prof", &error_msg));
+    std::unique_ptr<ZipEntry> zip_entry(
+        zip_archive->Find(ArtConstants::DEX_METADATA_PROFILE_ENTRY, &error_msg));
     if (zip_entry == nullptr || zip_entry->GetUncompressedLength() == 0) {
       return no_profile;
     }
@@ -1405,6 +1419,124 @@ ScopedAStatus Artd::getProfileSize(const ProfilePath& in_profile, int64_t* _aidl
   return ScopedAStatus::ok();
 }
 
+ScopedAStatus Artd::initProfileSaveNotification(const PrimaryCurProfilePath& in_profilePath,
+                                                int in_pid,
+                                                std::shared_ptr<IArtdNotification>* _aidl_return) {
+  RETURN_FATAL_IF_PRE_REBOOT(options_);
+
+  std::string path = OR_RETURN_FATAL(BuildPrimaryCurProfilePath(in_profilePath));
+
+  unique_fd inotify_fd(inotify_init1(IN_NONBLOCK | IN_CLOEXEC));
+  if (inotify_fd < 0) {
+    return NonFatal(ART_FORMAT("Failed to inotify_init1: {}", strerror(errno)));
+  }
+
+  // Watch the dir rather than the file itself because profiles are moved in rather than updated in
+  // place.
+  std::string dir = Dirname(path);
+  int wd = inotify_add_watch(inotify_fd, dir.c_str(), IN_MOVED_TO);
+  if (wd < 0) {
+    return NonFatal(ART_FORMAT("Failed to inotify_add_watch '{}': {}", dir, strerror(errno)));
+  }
+
+  unique_fd pidfd = PidfdOpen(in_pid, /*flags=*/0);
+  if (pidfd < 0) {
+    if (errno == ESRCH) {
+      // The process has gone now.
+      LOG(INFO) << ART_FORMAT("Process exited without sending notification '{}'", path);
+      *_aidl_return = ndk::SharedRefBase::make<ArtdNotification>();
+      return ScopedAStatus::ok();
+    }
+    return NonFatal(ART_FORMAT("Failed to pidfd_open {}: {}", in_pid, strerror(errno)));
+  }
+
+  *_aidl_return = ndk::SharedRefBase::make<ArtdNotification>(
+      poll_, path, std::move(inotify_fd), std::move(pidfd));
+  return ScopedAStatus::ok();
+}
+
+ScopedAStatus ArtdNotification::wait(int in_timeoutMs, bool* _aidl_return) {
+  auto cleanup = make_scope_guard([&, this] { CleanUp(); });
+
+  if (!mu_.try_lock()) {
+    return Fatal("`wait` can be called only once");
+  }
+  std::lock_guard<std::mutex> lock(mu_, std::adopt_lock);
+  LOG(INFO) << ART_FORMAT("Waiting for notification '{}'", path_);
+
+  if (is_called_) {
+    return Fatal("`wait` can be called only once");
+  }
+  is_called_ = true;
+
+  if (done_) {
+    *_aidl_return = true;
+    return ScopedAStatus::ok();
+  }
+
+  struct pollfd pollfds[2]{
+      {.fd = inotify_fd_.get(), .events = POLLIN},
+      {.fd = pidfd_.get(), .events = POLLIN},
+  };
+
+  constexpr size_t kBufSize = sizeof(struct inotify_event) + NAME_MAX + 1;
+  std::unique_ptr<uint8_t[]> buf(new (std::align_val_t(alignof(struct inotify_event)))
+                                     uint8_t[kBufSize]);
+  std::string basename = Basename(path_);
+
+  uint64_t start_time = MilliTime();
+  int64_t remaining_time_ms = in_timeoutMs;
+  while (remaining_time_ms > 0) {
+    int ret = TEMP_FAILURE_RETRY(poll_(pollfds, arraysize(pollfds), remaining_time_ms));
+    if (ret < 0) {
+      return NonFatal(
+          ART_FORMAT("Failed to poll to wait for notification '{}': {}", path_, strerror(errno)));
+    }
+    if (ret == 0) {
+      // Timeout.
+      break;
+    }
+    if ((pollfds[0].revents & POLLIN) != 0) {
+      ssize_t len = TEMP_FAILURE_RETRY(read(inotify_fd_, buf.get(), kBufSize));
+      if (len < 0) {
+        return NonFatal(ART_FORMAT(
+            "Failed to read inotify fd for notification '{}': {}", path_, strerror(errno)));
+      }
+      const struct inotify_event* event;
+      for (uint8_t* ptr = buf.get(); ptr < buf.get() + len;
+           ptr += sizeof(struct inotify_event) + event->len) {
+        event = (const struct inotify_event*)ptr;
+        if (event->len > 0 && event->name == basename) {
+          LOG(INFO) << ART_FORMAT("Received notification '{}'", path_);
+          *_aidl_return = true;
+          return ScopedAStatus::ok();
+        }
+      }
+      remaining_time_ms = in_timeoutMs - (MilliTime() - start_time);
+      continue;
+    }
+    if ((pollfds[1].revents & POLLIN) != 0) {
+      LOG(INFO) << ART_FORMAT("Process exited without sending notification '{}'", path_);
+      *_aidl_return = true;
+      return ScopedAStatus::ok();
+    }
+    LOG(FATAL) << "Unreachable code";
+    UNREACHABLE();
+  }
+
+  LOG(INFO) << ART_FORMAT("Timed out while waiting for notification '{}'", path_);
+  *_aidl_return = false;
+  return ScopedAStatus::ok();
+}
+
+ArtdNotification::~ArtdNotification() { CleanUp(); }
+
+void ArtdNotification::CleanUp() {
+  std::lock_guard<std::mutex> lock(mu_);
+  inotify_fd_.reset();
+  pidfd_.reset();
+}
+
 ScopedAStatus Artd::commitPreRebootStagedFiles(const std::vector<ArtifactsPath>& in_artifacts,
                                                const std::vector<WritableProfilePath>& in_profiles,
                                                bool* _aidl_return) {
@@ -1497,6 +1629,7 @@ ScopedAStatus Artd::checkPreRebootSystemRequirements(const std::string& in_chroo
 Result<void> Artd::Start() {
   OR_RETURN(SetLogVerbosity());
   MemMap::Init();
+  Runtime::AllowPageSizeAccess();
 
   ScopedAStatus status = ScopedAStatus::fromStatus(AServiceManager_registerLazyService(
       this->asBinder().get(), options_.is_pre_reboot ? kPreRebootServiceName : kServiceName));
@@ -1636,9 +1769,14 @@ bool Artd::ShouldUseDex2Oat64() {
          props_->GetBool("dalvik.vm.dex2oat64.enabled", /*default_value=*/false);
 }
 
+bool Artd::ShouldUseDebugBinaries() {
+  return props_->GetOrEmpty("persist.sys.dalvik.vm.lib.2") == "libartd.so";
+}
+
 Result<std::string> Artd::GetDex2Oat() {
-  std::string binary_name = ShouldUseDex2Oat64() ? "dex2oat64" : "dex2oat32";
-  // TODO(b/234351700): Should we use the "d" variant?
+  std::string binary_name = ShouldUseDebugBinaries() ?
+                                (ShouldUseDex2Oat64() ? "dex2oatd64" : "dex2oatd32") :
+                                (ShouldUseDex2Oat64() ? "dex2oat64" : "dex2oat32");
   return BuildArtBinPath(binary_name);
 }
 
@@ -1675,9 +1813,8 @@ void Artd::AddCompilerConfigFlags(const std::string& instruction_set,
                      props_->GetOrEmpty("dalvik.vm.dex2oat-max-image-block-size"))
       .AddIfNonEmpty("--very-large-app-threshold=%s",
                      props_->GetOrEmpty("dalvik.vm.dex2oat-very-large"))
-      .AddIfNonEmpty(
-          "--resolve-startup-const-strings=%s",
-          props_->GetOrEmpty("dalvik.vm.dex2oat-resolve-startup-strings"));
+      .AddIfNonEmpty("--resolve-startup-const-strings=%s",
+                     props_->GetOrEmpty("dalvik.vm.dex2oat-resolve-startup-strings"));
 
   args.AddIf(dexopt_options.debuggable, "--debuggable")
       .AddIf(props_->GetBool("debug.generate-debug-info", /*default_value=*/false),
diff --git a/artd/artd.h b/artd/artd.h
index 3b3375b841..8ce82e0dd5 100644
--- a/artd/artd.h
+++ b/artd/artd.h
@@ -17,7 +17,9 @@
 #ifndef ART_ARTD_ARTD_H_
 #define ART_ARTD_ARTD_H_
 
+#include <sys/inotify.h>
 #include <sys/mount.h>
+#include <sys/poll.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
@@ -35,10 +37,13 @@
 
 #include "aidl/com/android/server/art/BnArtd.h"
 #include "aidl/com/android/server/art/BnArtdCancellationSignal.h"
+#include "aidl/com/android/server/art/BnArtdNotification.h"
 #include "android-base/result.h"
 #include "android-base/thread_annotations.h"
+#include "android-base/unique_fd.h"
 #include "android/binder_auto_utils.h"
 #include "base/os.h"
+#include "base/pidfd.h"
 #include "exec_utils.h"
 #include "oat/oat_file_assistant_context.h"
 #include "tools/cmdline_builder.h"
@@ -47,6 +52,13 @@
 namespace art {
 namespace artd {
 
+// Define these function types instead of getting them from C headers because those from glibc C
+// headers contain the unwanted `noexcept`.
+using KillFn = int(pid_t, int);
+using FstatFn = int(int, struct stat*);
+using PollFn = int(struct pollfd*, nfds_t, int);
+using MountFn = int(const char*, const char*, const char*, uint32_t, const void*);
+
 android::base::Result<void> Restorecon(
     const std::string& path,
     const std::optional<
@@ -62,8 +74,7 @@ struct Options {
 
 class ArtdCancellationSignal : public aidl::com::android::server::art::BnArtdCancellationSignal {
  public:
-  explicit ArtdCancellationSignal(std::function<int(pid_t, int)> kill_func)
-      : kill_(std::move(kill_func)) {}
+  explicit ArtdCancellationSignal(std::function<KillFn> kill_func) : kill_(std::move(kill_func)) {}
 
   ndk::ScopedAStatus cancel() override;
 
@@ -82,32 +93,58 @@ class ArtdCancellationSignal : public aidl::com::android::server::art::BnArtdCan
   // The pids of currently running child processes that are bound to this signal.
   std::unordered_set<pid_t> pids_ GUARDED_BY(mu_);
 
-  std::function<int(pid_t, int)> kill_;
+  std::function<KillFn> kill_;
+};
+
+class ArtdNotification : public aidl::com::android::server::art::BnArtdNotification {
+ public:
+  ArtdNotification() : done_(true) {}
+  ArtdNotification(std::function<PollFn> poll_func,
+                   const std::string& path,
+                   android::base::unique_fd&& inotify_fd,
+                   android::base::unique_fd&& pidfd)
+      : poll_(poll_func),
+        path_(std::move(path)),
+        inotify_fd_(std::move(inotify_fd)),
+        pidfd_(std::move(pidfd)),
+        done_(false) {}
+
+  ndk::ScopedAStatus wait(int in_timeoutMs, bool* _aidl_return) EXCLUDES(mu_) override;
+
+  virtual ~ArtdNotification();
+
+ private:
+  void CleanUp() EXCLUDES(mu_);
+
+  const std::function<PollFn> poll_;
+
+  std::mutex mu_;
+  std::string path_ GUARDED_BY(mu_);
+  android::base::unique_fd inotify_fd_ GUARDED_BY(mu_);
+  android::base::unique_fd pidfd_ GUARDED_BY(mu_);
+  bool done_ GUARDED_BY(mu_);
+  bool is_called_ GUARDED_BY(mu_) = false;
 };
 
 class Artd : public aidl::com::android::server::art::BnArtd {
  public:
-  explicit Artd(
-      Options&& options,
-      std::unique_ptr<art::tools::SystemProperties> props =
-          std::make_unique<art::tools::SystemProperties>(),
-      std::unique_ptr<ExecUtils> exec_utils = std::make_unique<ExecUtils>(),
-      std::function<int(pid_t, int)> kill_func = kill,
-      std::function<int(int, struct stat*)> fstat_func = fstat,
-      std::function<int(const char*, const char*, const char*, uint32_t, const void*)> mount_func =
-          mount,
-      std::function<android::base::Result<void>(
-          const std::string&,
-          const std::optional<
-              aidl::com::android::server::art::OutputArtifacts::PermissionSettings::SeContext>&,
-          bool)> restorecon_func = Restorecon,
-      std::optional<std::string> pre_reboot_tmp_dir = std::nullopt,
-      std::optional<std::string> init_environ_rc_path = std::nullopt)
+  explicit Artd(Options&& options,
+                std::unique_ptr<art::tools::SystemProperties> props =
+                    std::make_unique<art::tools::SystemProperties>(),
+                std::unique_ptr<ExecUtils> exec_utils = std::make_unique<ExecUtils>(),
+                std::function<KillFn> kill_func = kill,
+                std::function<FstatFn> fstat_func = fstat,
+                std::function<PollFn> poll_func = poll,
+                std::function<MountFn> mount_func = mount,
+                std::function<decltype(Restorecon)> restorecon_func = Restorecon,
+                std::optional<std::string> pre_reboot_tmp_dir = std::nullopt,
+                std::optional<std::string> init_environ_rc_path = std::nullopt)
       : options_(std::move(options)),
         props_(std::move(props)),
         exec_utils_(std::move(exec_utils)),
         kill_(std::move(kill_func)),
         fstat_(std::move(fstat_func)),
+        poll_(std::move(poll_func)),
         mount_(std::move(mount_func)),
         restorecon_(std::move(restorecon_func)),
         pre_reboot_tmp_dir_(std::move(pre_reboot_tmp_dir)),
@@ -228,6 +265,11 @@ class Artd : public aidl::com::android::server::art::BnArtd {
   ndk::ScopedAStatus getProfileSize(const aidl::com::android::server::art::ProfilePath& in_profile,
                                     int64_t* _aidl_return) override;
 
+  ndk::ScopedAStatus initProfileSaveNotification(
+      const aidl::com::android::server::art::ProfilePath::PrimaryCurProfilePath& in_profilePath,
+      int in_pid,
+      std::shared_ptr<aidl::com::android::server::art::IArtdNotification>* _aidl_return) override;
+
   ndk::ScopedAStatus commitPreRebootStagedFiles(
       const std::vector<aidl::com::android::server::art::ArtifactsPath>& in_artifacts,
       const std::vector<aidl::com::android::server::art::ProfilePath::WritableProfilePath>&
@@ -280,6 +322,8 @@ class Artd : public aidl::com::android::server::art::BnArtd {
 
   bool ShouldUseDex2Oat64();
 
+  bool ShouldUseDebugBinaries();
+
   android::base::Result<std::string> GetDex2Oat();
 
   bool ShouldCreateSwapFileForDexopt();
@@ -328,15 +372,11 @@ class Artd : public aidl::com::android::server::art::BnArtd {
   const Options options_;
   const std::unique_ptr<art::tools::SystemProperties> props_;
   const std::unique_ptr<ExecUtils> exec_utils_;
-  const std::function<int(pid_t, int)> kill_;
-  const std::function<int(int, struct stat*)> fstat_;
-  const std::function<int(const char*, const char*, const char*, uint32_t, const void*)> mount_;
-  const std::function<android::base::Result<void>(
-      const std::string&,
-      const std::optional<
-          aidl::com::android::server::art::OutputArtifacts::PermissionSettings::SeContext>&,
-      bool)>
-      restorecon_;
+  const std::function<KillFn> kill_;
+  const std::function<FstatFn> fstat_;
+  const std::function<PollFn> poll_;
+  const std::function<MountFn> mount_;
+  const std::function<decltype(Restorecon)> restorecon_;
   const std::optional<std::string> pre_reboot_tmp_dir_;
   const std::optional<std::string> init_environ_rc_path_;
 };
diff --git a/artd/artd_test.cc b/artd/artd_test.cc
index 34950eee74..0a06a0917d 100644
--- a/artd/artd_test.cc
+++ b/artd/artd_test.cc
@@ -36,6 +36,7 @@
 #include <optional>
 #include <string>
 #include <thread>
+#include <tuple>
 #include <type_traits>
 #include <utility>
 #include <vector>
@@ -56,15 +57,20 @@
 #include "base/array_ref.h"
 #include "base/common_art_test.h"
 #include "base/macros.h"
+#include "base/pidfd.h"
 #include "exec_utils.h"
+#include "file_utils.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "oat/oat_file.h"
 #include "path_utils.h"
+#include "profile/profile_compilation_info.cc"
 #include "profman/profman_result.h"
 #include "testing.h"
 #include "tools/binder_utils.h"
 #include "tools/system_properties.h"
+#include "tools/testing.h"
+#include "vdex_file.h"
 #include "ziparchive/zip_writer.h"
 
 extern char** environ;
@@ -82,6 +88,7 @@ using ::aidl::com::android::server::art::DexoptOptions;
 using ::aidl::com::android::server::art::FileVisibility;
 using ::aidl::com::android::server::art::FsPermission;
 using ::aidl::com::android::server::art::IArtdCancellationSignal;
+using ::aidl::com::android::server::art::IArtdNotification;
 using ::aidl::com::android::server::art::OutputArtifacts;
 using ::aidl::com::android::server::art::OutputProfile;
 using ::aidl::com::android::server::art::PriorityClass;
@@ -89,6 +96,7 @@ using ::aidl::com::android::server::art::ProfilePath;
 using ::aidl::com::android::server::art::RuntimeArtifactsPath;
 using ::aidl::com::android::server::art::VdexPath;
 using ::android::base::Append;
+using ::android::base::Dirname;
 using ::android::base::Error;
 using ::android::base::make_scope_guard;
 using ::android::base::ParseInt;
@@ -100,6 +108,8 @@ using ::android::base::Split;
 using ::android::base::WriteStringToFd;
 using ::android::base::WriteStringToFile;
 using ::android::base::testing::HasValue;
+using ::art::tools::GetBin;
+using ::art::tools::ScopedExec;
 using ::testing::_;
 using ::testing::AllOf;
 using ::testing::AnyNumber;
@@ -339,7 +349,8 @@ class ArtdTest : public CommonArtTest {
                                            std::move(mock_props),
                                            std::move(mock_exec_utils),
                                            mock_kill_.AsStdFunction(),
-                                           mock_fstat_.AsStdFunction());
+                                           mock_fstat_.AsStdFunction(),
+                                           mock_poll_.AsStdFunction());
     scratch_dir_ = std::make_unique<ScratchDir>();
     scratch_path_ = scratch_dir_->GetPath();
     // Remove the trailing '/';
@@ -529,8 +540,9 @@ class ArtdTest : public CommonArtTest {
       ScopedUnsetEnvironmentVariable("ANDROID_EXPAND");
   MockSystemProperties* mock_props_;
   MockExecUtils* mock_exec_utils_;
-  MockFunction<int(pid_t, int)> mock_kill_;
-  MockFunction<int(int, struct stat*)> mock_fstat_;
+  MockFunction<KillFn> mock_kill_;
+  MockFunction<FstatFn> mock_fstat_;
+  MockFunction<PollFn> mock_poll_;
 
   std::string dex_file_;
   std::string isa_;
@@ -582,7 +594,14 @@ class ArtdTest : public CommonArtTest {
   }
 };
 
-TEST_F(ArtdTest, ConstantsAreInSync) { EXPECT_STREQ(ArtConstants::REASON_VDEX, kReasonVdex); }
+TEST_F(ArtdTest, ConstantsAreInSync) {
+  EXPECT_STREQ(ArtConstants::REASON_VDEX, kReasonVdex);
+  EXPECT_STREQ(ArtConstants::DEX_METADATA_FILE_EXT, kDmExtension);
+  EXPECT_STREQ(ArtConstants::SECURE_DEX_METADATA_FILE_EXT, kSdmExtension);
+  EXPECT_STREQ(ArtConstants::DEX_METADATA_PROFILE_ENTRY,
+               ProfileCompilationInfo::kDexMetadataProfileEntry);
+  EXPECT_STREQ(ArtConstants::DEX_METADATA_VDEX_ENTRY, VdexFile::kVdexNameInDmFile);
+}
 
 TEST_F(ArtdTest, isAlive) {
   bool result = false;
@@ -2526,6 +2545,118 @@ TEST_F(ArtdTest, getProfileSize) {
   EXPECT_EQ(aidl_return, 1);
 }
 
+class ArtdProfileSaveNotificationTest : public ArtdTest {
+ protected:
+  void SetUp() override {
+    ArtdTest::SetUp();
+
+    std::vector<std::string> args{GetBin("sleep"), "10"};
+    std::tie(pid_, scope_guard_) = ScopedExec(args, /*wait=*/false);
+    notification_file_ = OR_FAIL(BuildPrimaryCurProfilePath(profile_path_));
+    std::filesystem::create_directories(Dirname(notification_file_));
+  }
+
+  const PrimaryCurProfilePath profile_path_{
+      .userId = 0,
+      .packageName = "com.android.foo",
+      .profileName = "primary",
+  };
+  std::string notification_file_;
+  int pid_;
+  std::unique_ptr<ScopeGuard<std::function<void()>>> scope_guard_;
+};
+
+TEST_F(ArtdProfileSaveNotificationTest, initAndWaitSuccess) {
+  // Use a condvar to sequence the NewFile::CommitOrAbandon calls.
+  constexpr std::chrono::duration<int> kTimeout = std::chrono::seconds(1);
+  std::condition_variable wait_started_cv;
+  std::mutex mu;
+
+  EXPECT_CALL(mock_poll_, Call)
+      .Times(2)
+      .WillRepeatedly(DoAll(
+          [&](auto, auto, auto) {
+            // Step 3, 5.
+            std::unique_lock<std::mutex> lock(mu);
+            wait_started_cv.notify_one();
+          },
+          poll));
+
+  std::shared_ptr<IArtdNotification> notification;
+  ASSERT_STATUS_OK(artd_->initProfileSaveNotification(profile_path_, pid_, &notification));
+
+  std::unique_lock<std::mutex> lock(mu);
+
+  // Step 1.
+  std::thread t([&] {
+    // Step 2.
+    bool aidl_return;
+    ASSERT_STATUS_OK(notification->wait(/*in_timeoutMs=*/1000, &aidl_return));
+    // Step 7.
+    EXPECT_TRUE(aidl_return);
+  });
+  wait_started_cv.wait_for(lock, kTimeout);
+
+  // Step 4.
+  std::unique_ptr<NewFile> unrelated_file = OR_FAIL(NewFile::Create(
+      Dirname(notification_file_) + "/unrelated.prof", FsPermission{.uid = -1, .gid = -1}));
+  OR_FAIL(unrelated_file->CommitOrAbandon());
+  wait_started_cv.wait_for(lock, kTimeout);
+
+  // Step 6.
+  std::unique_ptr<NewFile> file =
+      OR_FAIL(NewFile::Create(notification_file_, FsPermission{.uid = -1, .gid = -1}));
+  OR_FAIL(file->CommitOrAbandon());
+
+  t.join();
+}
+
+TEST_F(ArtdProfileSaveNotificationTest, initAndWaitProcessGone) {
+  EXPECT_CALL(mock_poll_, Call).WillOnce(poll);
+
+  std::shared_ptr<IArtdNotification> notification;
+  ASSERT_STATUS_OK(artd_->initProfileSaveNotification(profile_path_, pid_, &notification));
+
+  std::thread t([&] {
+    bool aidl_return;
+    ASSERT_STATUS_OK(notification->wait(/*in_timeoutMs=*/1000, &aidl_return));
+    EXPECT_TRUE(aidl_return);
+  });
+
+  kill(pid_, SIGKILL);
+
+  t.join();
+}
+
+TEST_F(ArtdProfileSaveNotificationTest, initAndWaitTimeout) {
+  EXPECT_CALL(mock_poll_, Call).WillOnce(poll).WillOnce(Return(0));
+
+  std::shared_ptr<IArtdNotification> notification;
+  ASSERT_STATUS_OK(artd_->initProfileSaveNotification(profile_path_, pid_, &notification));
+
+  std::unique_ptr<NewFile> unrelated_file = OR_FAIL(NewFile::Create(
+      Dirname(notification_file_) + "/unrelated.prof", FsPermission{.uid = -1, .gid = -1}));
+  OR_FAIL(unrelated_file->CommitOrAbandon());
+
+  bool aidl_return;
+  ASSERT_STATUS_OK(notification->wait(/*in_timeoutMs=*/1000, &aidl_return));
+  EXPECT_FALSE(aidl_return);
+}
+
+TEST_F(ArtdProfileSaveNotificationTest, initProcessGone) {
+  // Kill the process before pidfd_open.
+  scope_guard_.reset();
+
+  EXPECT_CALL(mock_poll_, Call).Times(0);
+
+  std::shared_ptr<IArtdNotification> notification;
+  ASSERT_STATUS_OK(artd_->initProfileSaveNotification(profile_path_, pid_, &notification));
+
+  bool aidl_return;
+  ASSERT_STATUS_OK(notification->wait(/*in_timeoutMs=*/1000, &aidl_return));
+  EXPECT_TRUE(aidl_return);
+}
+
 TEST_F(ArtdTest, commitPreRebootStagedFiles) {
   CreateFile(android_data_ + "/dalvik-cache/arm64/system@app@Foo@Foo.apk@classes.dex.staged",
              "new_odex_1");
@@ -2694,6 +2825,7 @@ class ArtdPreRebootTest : public ArtdTest {
                                            std::move(mock_exec_utils),
                                            mock_kill_.AsStdFunction(),
                                            mock_fstat_.AsStdFunction(),
+                                           mock_poll_.AsStdFunction(),
                                            mock_mount_.AsStdFunction(),
                                            mock_restorecon_.AsStdFunction(),
                                            pre_reboot_tmp_dir_,
diff --git a/artd/binder/com/android/server/art/ArtConstants.aidl b/artd/binder/com/android/server/art/ArtConstants.aidl
index e9f702ef07..53fa75dead 100644
--- a/artd/binder/com/android/server/art/ArtConstants.aidl
+++ b/artd/binder/com/android/server/art/ArtConstants.aidl
@@ -19,14 +19,54 @@ package com.android.server.art;
 /**
  * Constants used by ART Service Java code that must be kept in sync with those in ART native code.
  *
+ * A test in art/artd/artd_test.cc checks that the constants are in sync.
+ *
  * @hide
  */
 parcelable ArtConstants {
     /**
-     * A special compilation reason to indicate that only the VDEX file is usable. Keep in sync with
-     * {@code kReasonVdex} in art/runtime/oat_file.h.
+     * A special compilation reason to indicate that only the VDEX file is usable.
      *
      * This isn't a valid reason to feed into DexoptParams.
+     *
+     * Keep in sync with {@code kReasonVdex} in art/runtime/oat_file.h.
      */
     const @utf8InCpp String REASON_VDEX = "vdex";
+
+    /**
+     * The file extension of the dex metadata file.
+     *
+     * Keep in sync with {@code kDmExtension} in art/libartbase/base/file_utils.h.
+     */
+    const @utf8InCpp String DEX_METADATA_FILE_EXT = ".dm";
+
+    /**
+     * The file extension of the profile file.
+     *
+     * Currently, there is no counterpart in the runtime code because the profile paths are passed
+     * from the framework.
+     */
+    const @utf8InCpp String PROFILE_FILE_EXT = ".prof";
+
+    /**
+     * The file extension of the secure dex metadata file.
+     *
+     * Keep in sync with {@code kSdmExtension} in art/libartbase/base/file_utils.h.
+     */
+    const @utf8InCpp String SECURE_DEX_METADATA_FILE_EXT = ".sdm";
+
+    /**
+     * The name of the profile entry in the dex metadata file.
+     *
+     * Keep in sync with {@code ProfileCompilationInfo::kDexMetadataProfileEntry} in
+     * art/libprofile/profile/profile_compilation_info.cc.
+     */
+    const @utf8InCpp String DEX_METADATA_PROFILE_ENTRY = "primary.prof";
+
+    /**
+     * The name of the vdex entry in the dex metadata file.
+     *
+     * Keep in sync with {@code VdexFile::kVdexNameInDmFile} in art/runtime/vdex_file.h.
+     */
+    const @utf8InCpp String DEX_METADATA_VDEX_ENTRY = "primary.vdex";
 }
diff --git a/artd/binder/com/android/server/art/IArtd.aidl b/artd/binder/com/android/server/art/IArtd.aidl
index 75b634dffa..7e9cf9da58 100644
--- a/artd/binder/com/android/server/art/IArtd.aidl
+++ b/artd/binder/com/android/server/art/IArtd.aidl
@@ -273,6 +273,20 @@ interface IArtd {
      */
     long getProfileSize(in com.android.server.art.ProfilePath profile);
 
+    /**
+     * Returns a notification handle to wait for a process to finish profile save
+     * ({@code ProfileCompilationInfo::Save}).
+     *
+     * A forced profile save can be triggered by sending {@code SIGUSR1} to the process.
+     *
+     * Throws fatal and non-fatal errors.
+     *
+     * Not supported in Pre-reboot Dexopt mode.
+     */
+    @PropagateAllowBlocking
+    com.android.server.art.IArtdNotification initProfileSaveNotification(
+            in com.android.server.art.ProfilePath.PrimaryCurProfilePath profilePath, int pid);
+
     /**
      * Moves the staged files of the given artifacts and profiles to the permanent locations,
      * replacing old files if they exist. Removes the staged files and restores the old files at
diff --git a/artd/binder/com/android/server/art/IArtdNotification.aidl b/artd/binder/com/android/server/art/IArtdNotification.aidl
new file mode 100644
index 0000000000..e3487962dd
--- /dev/null
+++ b/artd/binder/com/android/server/art/IArtdNotification.aidl
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.art;
+
+/**
+ * A notification handle. Must be created by `IArtd.initProfileSaveNotification`.
+ *
+ * @hide
+ */
+interface IArtdNotification {
+    /**
+     * Blocks until the process sends the notification or exits. Can only be called once.
+     *
+     * Throws fatal and non-fatal errors.
+     *
+     * @return true on success; false on timeout.
+     */
+    boolean wait(int timeoutMs);
+}
diff --git a/artd/path_utils.cc b/artd/path_utils.cc
index 8348a7605d..52bae7097e 100644
--- a/artd/path_utils.cc
+++ b/artd/path_utils.cc
@@ -20,6 +20,7 @@
 #include <string>
 #include <vector>
 
+#include "aidl/com/android/server/art/ArtConstants.h"
 #include "aidl/com/android/server/art/BnArtd.h"
 #include "android-base/errors.h"
 #include "android-base/result.h"
@@ -37,6 +38,7 @@ namespace artd {
 
 namespace {
 
+using ::aidl::com::android::server::art::ArtConstants;
 using ::aidl::com::android::server::art::ArtifactsPath;
 using ::aidl::com::android::server::art::DexMetadataPath;
 using ::aidl::com::android::server::art::OutputArtifacts;
@@ -112,10 +114,10 @@ std::vector<std::string> ListManagedFiles(const std::string& android_data,
       // we use more granular patterns to avoid accidentally deleting apps' files.
       std::string secondary_oat_dir = data_dir + "/**/oat";
       for (const char* suffix : {"", ".*.tmp", kPreRebootSuffix}) {
-        patterns.push_back(secondary_oat_dir + "/*.prof" + suffix);
-        patterns.push_back(secondary_oat_dir + "/*/*.odex" + suffix);
-        patterns.push_back(secondary_oat_dir + "/*/*.vdex" + suffix);
-        patterns.push_back(secondary_oat_dir + "/*/*.art" + suffix);
+        patterns.push_back(secondary_oat_dir + "/*" + ArtConstants::PROFILE_FILE_EXT + suffix);
+        patterns.push_back(secondary_oat_dir + "/*/*" + kOdexExtension + suffix);
+        patterns.push_back(secondary_oat_dir + "/*/*" + kVdexExtension + suffix);
+        patterns.push_back(secondary_oat_dir + "/*/*" + kArtExtension + suffix);
       }
       // Runtime image files.
       patterns.push_back(RuntimeImage::GetRuntimeImageDir(data_dir) + "**");
@@ -183,8 +185,8 @@ Result<RawArtifactsPath> BuildArtifactsPath(const ArtifactsPath& artifacts_path)
     }
   }
 
-  path.vdex_path = ReplaceFileExtension(path.oat_path, "vdex");
-  path.art_path = ReplaceFileExtension(path.oat_path, "art");
+  path.vdex_path = ReplaceFileExtension(path.oat_path, kVdexExtension);
+  path.art_path = ReplaceFileExtension(path.oat_path, kArtExtension);
 
   if (artifacts_path.isPreReboot) {
     path.oat_path += kPreRebootSuffix;
@@ -199,36 +201,39 @@ Result<std::string> BuildPrimaryRefProfilePath(
     const PrimaryRefProfilePath& primary_ref_profile_path) {
   OR_RETURN(ValidatePathElement(primary_ref_profile_path.packageName, "packageName"));
   OR_RETURN(ValidatePathElementSubstring(primary_ref_profile_path.profileName, "profileName"));
-  return ART_FORMAT("{}/misc/profiles/ref/{}/{}.prof{}",
+  return ART_FORMAT("{}/misc/profiles/ref/{}/{}{}{}",
                     OR_RETURN(GetAndroidDataOrError()),
                     primary_ref_profile_path.packageName,
                     primary_ref_profile_path.profileName,
+                    ArtConstants::PROFILE_FILE_EXT,
                     primary_ref_profile_path.isPreReboot ? kPreRebootSuffix : "");
 }
 
 Result<std::string> BuildPrebuiltProfilePath(const PrebuiltProfilePath& prebuilt_profile_path) {
   OR_RETURN(ValidateDexPath(prebuilt_profile_path.dexPath));
-  return prebuilt_profile_path.dexPath + ".prof";
+  return prebuilt_profile_path.dexPath + ArtConstants::PROFILE_FILE_EXT;
 }
 
 Result<std::string> BuildPrimaryCurProfilePath(
     const PrimaryCurProfilePath& primary_cur_profile_path) {
   OR_RETURN(ValidatePathElement(primary_cur_profile_path.packageName, "packageName"));
   OR_RETURN(ValidatePathElementSubstring(primary_cur_profile_path.profileName, "profileName"));
-  return ART_FORMAT("{}/misc/profiles/cur/{}/{}/{}.prof",
+  return ART_FORMAT("{}/misc/profiles/cur/{}/{}/{}{}",
                     OR_RETURN(GetAndroidDataOrError()),
                     primary_cur_profile_path.userId,
                     primary_cur_profile_path.packageName,
-                    primary_cur_profile_path.profileName);
+                    primary_cur_profile_path.profileName,
+                    ArtConstants::PROFILE_FILE_EXT);
 }
 
 Result<std::string> BuildSecondaryRefProfilePath(
     const SecondaryRefProfilePath& secondary_ref_profile_path) {
   OR_RETURN(ValidateDexPath(secondary_ref_profile_path.dexPath));
   std::filesystem::path dex_path(secondary_ref_profile_path.dexPath);
-  return ART_FORMAT("{}/oat/{}.prof{}",
+  return ART_FORMAT("{}/oat/{}{}{}",
                     dex_path.parent_path().string(),
                     dex_path.filename().string(),
+                    ArtConstants::PROFILE_FILE_EXT,
                     secondary_ref_profile_path.isPreReboot ? kPreRebootSuffix : "");
 }
 
@@ -236,8 +241,10 @@ Result<std::string> BuildSecondaryCurProfilePath(
     const SecondaryCurProfilePath& secondary_cur_profile_path) {
   OR_RETURN(ValidateDexPath(secondary_cur_profile_path.dexPath));
   std::filesystem::path dex_path(secondary_cur_profile_path.dexPath);
-  return ART_FORMAT(
-      "{}/oat/{}.cur.prof", dex_path.parent_path().string(), dex_path.filename().string());
+  return ART_FORMAT("{}/oat/{}.cur{}",
+                    dex_path.parent_path().string(),
+                    dex_path.filename().string(),
+                    ArtConstants::PROFILE_FILE_EXT);
 }
 
 Result<std::string> BuildWritableProfilePath(const WritableProfilePath& profile_path) {
@@ -265,7 +272,7 @@ Result<std::string> BuildTmpProfilePath(const TmpProfilePath& tmp_profile_path)
 
 Result<std::string> BuildDexMetadataPath(const DexMetadataPath& dex_metadata_path) {
   OR_RETURN(ValidateDexPath(dex_metadata_path.dexPath));
-  return ReplaceFileExtension(dex_metadata_path.dexPath, "dm");
+  return ReplaceFileExtension(dex_metadata_path.dexPath, kDmExtension);
 }
 
 Result<std::string> BuildProfileOrDmPath(const ProfilePath& profile_path) {
diff --git a/build/Android.common_path.mk b/build/Android.common_path.mk
index 95eeeb430a..bb75398b39 100644
--- a/build/Android.common_path.mk
+++ b/build/Android.common_path.mk
@@ -65,7 +65,7 @@ HOST_BOOT_IMAGE_JARS += $(HOST_OUT)/apex/com.android.i18n/javalib/core-icu4j.jar
 $(HOST_OUT)/apex/com.android.i18n/javalib/core-icu4j.jar : $(HOST_OUT_JAVA_LIBRARIES)/core-icu4j-hostdex.jar
 	$(copy-file-to-target)
 
-HOST_CORE_IMG_OUTS += $(HOST_BOOT_IMAGE_JARS) $(HOST_BOOT_IMAGE) $(2ND_HOST_BOOT_IMAGE)
+HOST_CORE_IMG_OUTS += $(HOST_BOOT_IMAGE_JARS)
 
 HOST_TEST_CORE_JARS := $(addsuffix -hostdex,$(CORE_IMG_JARS) core-icu4j conscrypt)
 ART_HOST_DEX_DEPENDENCIES := $(foreach jar,$(HOST_TEST_CORE_JARS),$(HOST_OUT_JAVA_LIBRARIES)/$(jar).jar)
diff --git a/build/Android.gtest.mk b/build/Android.gtest.mk
index ae40d01db4..fae37a2f76 100644
--- a/build/Android.gtest.mk
+++ b/build/Android.gtest.mk
@@ -235,11 +235,6 @@ define define-art-gtest-rule-host
   #       * ART_HOST_ARCH := x86_64
   #       * 2ND_ART_HOST_ARCH := x86
   #       * 2ND_HOST_ARCH := x86
-  ifeq ($(HOST_PREFER_32_BIT),true)
-    gtest_deps += $$(2ND_HOST_BOOT_IMAGE) # Depend on the 32-bit boot image.
-  else
-    gtest_deps += $$($(3)HOST_BOOT_IMAGE)
-  endif
 
 .PHONY: $$(gtest_build_rule)
 $$(gtest_build_rule) : $$(gtest_exe) $$(gtest_deps)
diff --git a/build/apex/Android.bp b/build/apex/Android.bp
index 312d40477d..43423f35e6 100644
--- a/build/apex/Android.bp
+++ b/build/apex/Android.bp
@@ -12,104 +12,6 @@ package {
     default_applicable_licenses: ["art_license"],
 }
 
-// Binaries for which both 32- and 64-bit versions are built, if possible.
-art_runtime_binaries_both = [
-    "dalvikvm",
-    "dex2oat",
-]
-
-// Binaries for which the "first" version is preferred.
-art_runtime_binaries_first = [
-    "art_boot",
-    "art_exec",
-    "artd",
-    "dexdump",
-    "dexlist",
-    "dexopt_chroot_setup",
-    "dexoptanalyzer",
-    "oatdump",
-    "profman",
-]
-
-// - Base requirements (libraries).
-//
-// Note: ART on-device chroot-based testing and benchmarking is not yet using
-// the ART APEX, meaning that copies of some of these libraries have to be
-// installed in `/system` for the ART Buildbot set-up to work properly. This is
-// done by the `standalone-apex-files` Make phony target, used by the ART
-// Buildbot and Golem (see `art/Android.mk`). If you add libraries to this list,
-// you may have to also add them to `PRIVATE_ART_APEX_DEPENDENCY_LIBS` in
-// `art/Android.mk`.
-// TODO(b/121117762): Remove this note when both the ART Buildbot and Golem use
-// the ART APEX.
-art_runtime_base_native_shared_libs_minus_libart = [
-    // External API (having APEX stubs).
-    "libdexfile",
-    "libnativebridge",
-    "libnativehelper",
-    "libnativeloader",
-    "libsigchain",
-    // libadbconnection is internal and loaded with dlopen(), but it cannot use
-    // "required" because of cyclic dependency (b/124505714).
-    "libadbconnection",
-    // TODO(b/124476339): Clean up the following libraries once "required"
-    // dependencies work with APEX libraries.
-    "libdt_fd_forward",
-    "libdt_socket",
-    "libjdwp",
-    "libnpt",
-    "libopenjdkjvm",
-    "libopenjdkjvmti",
-    "libperfetto_hprof",
-]
-// Actual version of ART runtime base libs, used in non-test ART APEXes.
-art_runtime_base_native_shared_libs = ["libart"] +
-    art_runtime_base_native_shared_libs_minus_libart
-// "Broken" version of ART runtime base libs, used for testing purposes.
-art_runtime_base_broken_native_shared_libs = ["libart-broken"] +
-    art_runtime_base_native_shared_libs_minus_libart
-
-// - Debug variants (libraries).
-art_runtime_debug_native_shared_libs = [
-    "libadbconnectiond",
-    "libartd",
-    "libdexfiled",
-    "libopenjdkjvmd",
-    "libopenjdkjvmtid",
-    "libperfetto_hprofd",
-    // Libraries needed to execute ART run-tests.
-    // TODO(b/124476339): When bug 124476339 is fixed, add these libraries as `runtime_libs`
-    // dependencies of `libartd-compiler`, and remove them here.
-    "libart-disassembler",
-    "libartd-disassembler",
-]
-
-// Debug binaries for which both 32- and 64-bit versions are built, if possible.
-art_debug_binaries_both = [
-    "dex2oatd",
-    "imgdiag",
-    "imgdiagd",
-]
-
-// Debug binaries for which the "first" version is preferred.
-art_debug_binaries_first = [
-    "dexanalyze",
-    "dexoptanalyzerd",
-    "oatdumpd",
-    "profmand",
-]
-
-// Core Java libraries.
-// This list must be the same as art-bootclasspath-fragment because it's that which is pulled in
-// through bootclasspath_fragments below. (com.android.art-defaults-minus-odrefresh)
-libcore_java_libs = [
-    "core-oj",
-    "core-libart",
-    "okhttp",
-    "bouncycastle",
-    "apache-xml",
-]
-
 // Create combined library which is used for compiling run-tests.
 // This is much easier than trying to make the test depend on them directly,
 // or than trying to make the test compilation depend on the apex module.
@@ -117,35 +19,19 @@ libcore_java_libs = [
 java_library {
     name: "art-run-test-bootclasspath",
     sdk_version: "core_platform",
-    static_libs: libcore_java_libs + [
+    static_libs: [
         "framework-annotations-lib",
+        // Core Java libraries. This list must be the same as
+        // art-bootclasspath-fragment because it's that which is pulled in
+        // through bootclasspath_fragments in com.android-art-base-defaults.
+        "core-oj",
+        "core-libart",
+        "okhttp",
+        "bouncycastle",
+        "apache-xml",
     ],
 }
 
-// Native libraries that support the core Java libraries.
-//
-// Note: ART on-device chroot-based testing and benchmarking is not yet using
-// the ART APEX, meaning that copies of some of these libraries have to be
-// installed in `/system` for the ART Buildbot set-up to work properly. This is
-// done by the `standalone-apex-files` Make phony target, used by the ART
-// Buildbot and Golem (see `art/Android.mk`). If you add libraries to this list,
-// you may have to also add them to `PRIVATE_ART_APEX_DEPENDENCY_LIBS` in
-// `art/Android.mk`.
-// TODO(b/121117762): Remove this note when both the ART Buildbot and Golem use
-// the ART APEX.
-libcore_native_shared_libs = [
-    // External API (having APEX stubs).
-    "libandroidio",
-    // TODO(b/124476339): Clean up the following libraries once "required"
-    // dependencies work with APEX libraries.
-    "libexpat",
-    "libjavacore",
-    "libopenjdk",
-]
-libcore_debug_native_shared_libs = [
-    "libopenjdkd",
-]
-
 android_app_certificate {
     name: "com.android.art.certificate",
     certificate: "com.android.art",
@@ -157,18 +43,10 @@ apex_key {
     private_key: "com.android.art.pem",
 }
 
-// Default shared by all ART APEXes.
-apex_defaults {
-    name: "com.android.art-base-defaults",
-
-    target: {
-        windows: {
-            // When the Soong config variable above sets enabled:true, it
-            // overrides the default false for targets, so we need to disable
-            // windows explicitly.
-            enabled: false,
-        },
-    },
+linker_config {
+    name: "art-linker-config",
+    src: "linker.config.json",
+    installable: false,
 }
 
 prebuilt_etc {
@@ -178,32 +56,24 @@ prebuilt_etc {
     installable: false,
 }
 
-// Default values shared by APEXes except test_broken_com.android.art.
+prebuilt_etc {
+    name: "dirty-image-objects-art",
+    src: "dirty-image-objects",
+    filename: "dirty-image-objects",
+    installable: false,
+}
+
+// Default shared by all ART APEXes.
 apex_defaults {
-    name: "com.android.art-defaults-minus-odrefresh",
-    defaults: [
-        "com.android.art-base-defaults",
-        "s-launched-apex-module",
-    ],
-    compile_multilib: "both",
+    name: "com.android.art-base-defaults",
+    defaults: ["s-launched-apex-module"],
+
     manifest: "manifest-art.json",
+    key: "com.android.art.key",
+    certificate: ":com.android.art.certificate",
     bootclasspath_fragments: ["art-bootclasspath-fragment"],
     systemserverclasspath_fragments: ["art-systemserverclasspath-fragment"],
     compat_configs: ["libcore-platform-compat-config"],
-    native_shared_libs: art_runtime_base_native_shared_libs +
-        libcore_native_shared_libs,
-    multilib: {
-        both: {
-            binaries: art_runtime_binaries_both,
-        },
-        first: {
-            binaries: art_runtime_binaries_first,
-            jni_libs: [
-                "libartservice",
-            ],
-        },
-    },
-    key: "com.android.art.key",
     required: [
         "com.android.i18n",
     ],
@@ -211,16 +81,71 @@ apex_defaults {
         "art-linker-config",
         "com.android.art.init.rc",
         "current_sdkinfo",
+        "dirty-image-objects-art",
+    ],
+
+    compile_multilib: "both",
+
+    // Note: ART Golem benchmarking does not use the ART APEX, meaning that
+    // copies of some of these libraries have to be installed in `/system` for
+    // the setup to work properly. This is done by the `standalone-apex-files`
+    // Make phony target (see `art/Android.mk`). If you add libraries to this
+    // list, you may have to also add them to `PRIVATE_ART_APEX_DEPENDENCY_LIBS`
+    // in `art/Android.mk`.
+    native_shared_libs: [
+        // ART
+        // External API (having APEX stubs).
+        "libdexfile",
+        "libnativebridge",
+        "libnativehelper",
+        "libnativeloader",
+        "libsigchain",
+        // These libraries are loaded at runtime from libart (either through
+        // dlopen() or by instructing the user to load with -Xplugin), but they
+        // cannot be runtime_lib dependencies from there because of cyclic
+        // dependencies (b/124505714).
+        "libadbconnection",
+        "libopenjdkjvmti",
+        "libperfetto_hprof",
+        // Likewise libart is loaded at runtime from libnativeloader and also must
+        // be specified explicitly due to cyclic dependencies. However, it's not
+        // listed directly here since test_broken_com.android.art uses a different
+        // implementation.
+
+        // Libcore
+        // External API (having APEX stubs).
+        "libandroidio",
+        // This library is loaded at runtime from libart but cannot be a runtime_lib
+        // dependency from there because of cyclic dependencies (b/124505714).
+        "libopenjdk",
+        // These libraries are internal dependencies in libcore, but they don't get
+        // pulled in automatically into apex_test modules.
+        "libexpat",
+        "libopenjdkjvm",
     ],
-}
 
-// Default values shared by Release, Debug, and Testing APEXes.
-apex_defaults {
-    name: "com.android.art-defaults",
-    defaults: ["com.android.art-defaults-minus-odrefresh"],
     multilib: {
+        both: {
+            binaries: [
+                "dalvikvm",
+                "dex2oat",
+            ],
+        },
         first: {
-            binaries: ["odrefresh"],
+            binaries: [
+                "art_boot",
+                "art_exec",
+                "artd",
+                "dexdump",
+                "dexlist",
+                "dexopt_chroot_setup",
+                "dexoptanalyzer",
+                "oatdump",
+                "profman",
+            ],
+            jni_libs: [
+                "libartservice",
+            ],
         },
     },
 }
@@ -228,22 +153,30 @@ apex_defaults {
 // Default values shared by Debug and Testing ART APEXes.
 apex_defaults {
     name: "com.android.art-devel-defaults",
-    defaults: ["com.android.art-defaults"],
-    // Use a different manifest for the Debug & Testing ART APEXes (which have
-    // no prebuilts and are thus always built from sources), with a high version
-    // number that ensures that these packages can be installed on virtually all
-    // Android dessert releases.
-    manifest: "manifest-art-debug.json",
-    native_shared_libs: art_runtime_debug_native_shared_libs +
-        libcore_debug_native_shared_libs,
+    defaults: ["com.android.art-base-defaults"],
+
+    native_shared_libs: [
+        "libadbconnectiond",
+        "libdexfiled",
+        "libopenjdkd",
+        "libopenjdkjvmtid",
+        "libperfetto_hprofd",
+    ],
+
     multilib: {
         both: {
-            binaries: art_debug_binaries_both,
+            binaries: [
+                "dex2oatd",
+                "imgdiag",
+                "imgdiagd",
+            ],
         },
         first: {
-            binaries: art_debug_binaries_first,
-            jni_libs: [
-                "libartserviced",
+            binaries: [
+                "dexanalyze",
+                "dexoptanalyzerd",
+                "oatdumpd",
+                "profmand",
             ],
         },
     },
@@ -253,62 +186,49 @@ apex_defaults {
 // `libart-broken` instead of `libart`.
 apex_test {
     name: "test_broken_com.android.art",
-    // Use of "s-launched-apex-module" does not imply that this is a released
-    // module.
-    defaults: [
-        "com.android.art-base-defaults",
-        "s-launched-apex-module",
-    ],
-
-    // Only include native libraries in this test APEX. The intention
-    // was to not include binaries (and maybe other artifacts) for now,
-    // as they'd pull the "non-broken" `libart` module into this test
-    // APEX and overwrite `libart-broken`. However, with
-    // unwanted_transitive_deps we can ensure `libart` gets excluded
-    // anyway.
-    // TODO(mast): Add back the binaries and clean this up.
-    native_shared_libs: art_runtime_base_broken_native_shared_libs,
-    unwanted_transitive_deps: ["libart"],
-    compile_multilib: "both",
-
-    key: "com.android.art.key",
+    defaults: ["com.android.art-base-defaults"],
     manifest: "test_apex_manifest.json",
     file_contexts: ":com.android.art-file_contexts",
-    certificate: ":com.android.art.certificate",
     installable: false,
     compressible: false,
+
+    native_shared_libs: ["libart-broken"],
+    unwanted_transitive_deps: ["libart"],
 }
 
 apex_test {
     name: "test_jitzygote_com.android.art",
-    defaults: ["com.android.art-defaults-minus-odrefresh"],
+    defaults: ["com.android.art-base-defaults"],
+    manifest: "test_apex_manifest.json",
+    file_contexts: ":com.android.art-file_contexts",
+    installable: false,
+
+    native_shared_libs: ["libart"],
     multilib: {
         first: {
             binaries: ["odrefresh_broken"],
         },
     },
-    key: "com.android.art.key",
-    manifest: "test_apex_manifest.json",
-    file_contexts: ":com.android.art-file_contexts",
-    certificate: ":com.android.art.certificate",
-    installable: false,
 }
 
 // Same as "com.android.art" APEX, but also contains "imgdiag" binary.
 // Used to collect dirty-image-objects.
 apex_test {
     name: "test_imgdiag_com.android.art",
-    defaults: ["com.android.art-defaults"],
+    defaults: ["com.android.art-base-defaults"],
+    manifest: "test_apex_manifest.json",
+    file_contexts: ":com.android.art-file_contexts",
+    installable: false,
+
+    native_shared_libs: ["libart"],
     multilib: {
         both: {
             binaries: ["imgdiag"],
         },
+        first: {
+            binaries: ["odrefresh"],
+        },
     },
-    key: "com.android.art.key",
-    manifest: "test_apex_manifest.json",
-    file_contexts: ":com.android.art-file_contexts",
-    certificate: ":com.android.art.certificate",
-    installable: false,
 }
 
 // Release version of the ART APEX module (not containing debug
@@ -316,8 +236,15 @@ apex_test {
 // storage-constrained devices in userdebug and eng builds.
 apex {
     name: "com.android.art",
-    defaults: ["com.android.art-defaults"],
-    certificate: ":com.android.art.certificate",
+    defaults: ["com.android.art-base-defaults"],
+
+    native_shared_libs: ["libart"],
+    multilib: {
+        first: {
+            binaries: ["odrefresh"],
+        },
+    },
+
     visibility: [
         "//art/build/sdk",
         "//packages/modules/common/build",
@@ -330,7 +257,23 @@ apex {
 apex {
     name: "com.android.art.debug",
     defaults: ["com.android.art-devel-defaults"],
-    certificate: ":com.android.art.certificate",
+    // Use a different manifest for this APEX (which has no prebuilts and is
+    // thus always built from sources), with a high version number that ensures
+    // that these packages can be installed on virtually all Android dessert
+    // releases.
+    manifest: "manifest-art-debug.json",
+
+    native_shared_libs: [
+        "libart",
+        "libartd",
+    ],
+    multilib: {
+        first: {
+            binaries: ["odrefresh"],
+            jni_libs: ["libartserviced"],
+        },
+    },
+
     visibility: [
         "//packages/modules/common/build",
     ],
@@ -369,9 +312,13 @@ apex_test {
     name: "com.android.art.testing",
     defaults: ["com.android.art-devel-defaults"],
     file_contexts: ":com.android.art.debug-file_contexts",
-    certificate: ":com.android.art.certificate",
     tests: art_gtests,
     binaries: ["signal_dumper"], // Need signal_dumper for run-tests.
+    // Use a different manifest for this APEX (which has no prebuilts and is
+    // thus always built from sources), with a high version number that ensures
+    // that these packages can be installed on virtually all Android dessert
+    // releases.
+    manifest: "manifest-art-debug.json",
     // Mark this test APEX as non-updatable, as its contains
     // additional files (used only for testing) that would not pass
     // dependency checks performed on updatable APEXes (see
@@ -387,9 +334,16 @@ apex_test {
     // and b/233357459). Marking this APEX as "future updatable"
     // disables all symlink optimizations for it.
     future_updatable: true,
+
+    native_shared_libs: [
+        "libart",
+        "libartd",
+    ],
     multilib: {
         first: {
             tests: art_gtests_first,
+            binaries: ["odrefresh"],
+            jni_libs: ["libartserviced"],
         },
     },
 }
@@ -432,10 +386,12 @@ cc_defaults {
     },
 }
 
-genrule {
+java_genrule {
     name: "art-check-release-apex-gen",
+    host_supported: true,
+    device_supported: false,
     defaults: ["art-check-apex-gen-defaults"],
-    srcs: [":com.android.art"],
+    device_common_srcs: [":com.android.art"],
     cmd: art_check_apex_gen_stem +
         " --flavor release" +
         " $(in)" +
@@ -450,10 +406,12 @@ cc_prebuilt_binary {
     srcs: [":art-check-release-apex-gen"],
 }
 
-genrule {
+java_genrule {
     name: "art-check-debug-apex-gen",
+    host_supported: true,
+    device_supported: false,
     defaults: ["art-check-apex-gen-defaults"],
-    srcs: [":com.android.art.debug"],
+    device_common_srcs: [":com.android.art.debug"],
     cmd: art_check_apex_gen_stem +
         " --flavor debug" +
         " $(in)" +
@@ -468,10 +426,12 @@ cc_prebuilt_binary {
     srcs: [":art-check-debug-apex-gen"],
 }
 
-genrule {
+java_genrule {
     name: "art-check-testing-apex-gen",
+    host_supported: true,
+    device_supported: false,
     defaults: ["art-check-apex-gen-defaults"],
-    srcs: [":com.android.art.testing"],
+    device_common_srcs: [":com.android.art.testing"],
     cmd: art_check_apex_gen_stem +
         " --flavor testing" +
         " $(in)" +
@@ -486,32 +446,16 @@ cc_prebuilt_binary {
     srcs: [":art-check-testing-apex-gen"],
 }
 
-linker_config {
-    name: "art-linker-config",
-    src: "linker.config.json",
-    installable: false,
-}
-
-// sdk module types have 3 (maybe 4 for windows?) variants: linux, android, and common_os.
-// common_os depends on the linux/android variants and packages their artifacts into a zip file.
-// We want access to that zip file in art_release_zip, so we need to depend on only the common_os
-// variant of art-module-host-exports, which is what sdk_genrule does. Since sdk_genrule only has
-// 1 variant, we can then depend on it from a different type of genrule like regular genrule.
-sdk_genrule {
-    name: "art-module-host-exports-for-genrule",
-    srcs: [":art-module-host-exports"],
-    out: ["art-module-host-exports-current.zip"],
-    cmd: "cp $(in) $(out)",
-}
-
 // A zip containing ART binaries and ART bootclasspath jars.
 // At the time of writing, this is only for Compiler Explorer (https://godbolt.org).
-genrule {
+java_genrule {
     name: "art_release_zip",
     srcs: [
-        ":art-module-host-exports-for-genrule",
         ":com.android.art",
     ],
+    common_os_srcs: [
+        ":art-module-host-exports",
+    ],
     out: [
         "art_release.zip",
     ],
@@ -534,7 +478,7 @@ genrule {
         "-f $(genDir)/extracted/javalib/bouncycastle.jar " +
         "-f $(genDir)/extracted/javalib/apache-xml.jar && " +
 
-        "$(location merge_zips) $(out) $(out).tmp $(location :art-module-host-exports-for-genrule)",
+        "$(location merge_zips) $(out) $(out).tmp $(location :art-module-host-exports)",
     dist: {
         targets: ["droidcore"],
     },
diff --git a/build/apex/art_apex_test.py b/build/apex/art_apex_test.py
index 1b82302d7a..3c39e43b9f 100755
--- a/build/apex/art_apex_test.py
+++ b/build/apex/art_apex_test.py
@@ -24,7 +24,6 @@ import os.path
 import shutil
 import subprocess
 import sys
-import zipfile
 
 logging.basicConfig(format='%(message)s')
 
@@ -131,78 +130,6 @@ class TargetApexProvider:
     return apex_map
 
 
-class HostApexProvider:
-  def __init__(self, apex, tmpdir):
-    self._tmpdir = tmpdir
-    self._folder_cache = {}
-    self._payload = os.path.join(self._tmpdir, 'apex_payload.zip')
-    # Extract payload to tmpdir.
-    apex_zip = zipfile.ZipFile(apex)
-    apex_zip.extract('apex_payload.zip', tmpdir)
-
-  def __del__(self):
-    # Delete temps.
-    if os.path.exists(self._payload):
-      os.remove(self._payload)
-
-  def get(self, path):
-    apex_dir, name = os.path.split(path)
-    if not apex_dir:
-      apex_dir = ''
-    apex_map = self.read_dir(apex_dir)
-    return apex_map[name] if name in apex_map else None
-
-  def read_dir(self, apex_dir):
-    if apex_dir in self._folder_cache:
-      return self._folder_cache[apex_dir]
-    if not self._folder_cache:
-      self.parse_zip()
-    if apex_dir in self._folder_cache:
-      return self._folder_cache[apex_dir]
-    return {}
-
-  def parse_zip(self):
-    apex_zip = zipfile.ZipFile(self._payload)
-    infos = apex_zip.infolist()
-    for zipinfo in infos:
-      path = zipinfo.filename
-
-      # Assume no empty file is stored.
-      assert path
-
-      def get_octal(val, index):
-        return (val >> (index * 3)) & 0x7
-
-      def bits_is_exec(val):
-        # TODO: Enforce group/other, too?
-        return get_octal(val, 2) & 1 == 1
-
-      is_zipinfo = True
-      while path:
-        apex_dir, base = os.path.split(path)
-        # TODO: If directories are stored, base will be empty.
-
-        if apex_dir not in self._folder_cache:
-          self._folder_cache[apex_dir] = {}
-        dir_map = self._folder_cache[apex_dir]
-        if base not in dir_map:
-          if is_zipinfo:
-            bits = (zipinfo.external_attr >> 16) & 0xFFFF
-            is_dir = get_octal(bits, 4) == 4
-            is_symlink = get_octal(bits, 4) == 2
-            is_exec = bits_is_exec(bits)
-            size = zipinfo.file_size
-          else:
-            is_exec = False  # Seems we can't get this easily?
-            is_symlink = False
-            is_dir = True
-            # Use a negative value as an indicator of undefined/unknown size.
-            size = -1
-          dir_map[base] = FSObject(base, is_dir, is_exec, is_symlink, size)
-        is_zipinfo = False
-        path = apex_dir
-
-
 # DO NOT USE DIRECTLY! This is an "abstract" base class.
 class Checker:
   def __init__(self, provider):
@@ -498,20 +425,29 @@ class ReleaseChecker:
     self._checker.check_file('etc/init.rc')
     self._checker.check_file('etc/linker.config.pb')
     self._checker.check_file('etc/sdkinfo.pb')
+    self._checker.check_file('etc/dirty-image-objects')
 
     # Check flagging files that don't get added in builds on master-art.
     # TODO(b/345713436): Make flags work on master-art.
     self._checker.check_optional_file('etc/aconfig_flags.pb')
+    self._checker.check_optional_file('etc/flag.info')
     self._checker.check_optional_file('etc/flag.map')
     self._checker.check_optional_file('etc/flag.val')
     self._checker.check_optional_file('etc/package.map')
 
     # Check binaries for ART.
+    self._checker.check_executable('art_boot')
+    self._checker.check_executable('art_exec')
+    self._checker.check_executable('artd')
     self._checker.check_executable('dexdump')
     self._checker.check_executable('dexlist')
+    self._checker.check_executable('dexopt_chroot_setup')
     self._checker.check_executable('dexoptanalyzer')
+    self._checker.check_executable('oatdump')
+    self._checker.check_executable('odrefresh')
     self._checker.check_executable('profman')
     self._checker.check_symlinked_multilib_executable('dalvikvm')
+    self._checker.check_symlinked_multilib_executable('dex2oat')
 
     # Check exported libraries for ART.
     self._checker.check_native_library('libdexfile')
@@ -525,12 +461,21 @@ class ReleaseChecker:
     self._checker.check_native_library('libart-disassembler')
     self._checker.check_native_library('libartbase')
     self._checker.check_native_library('libartpalette')
-    self._checker.check_prefer64_library('libarttools')
     self._checker.check_native_library('libdt_fd_forward')
     self._checker.check_native_library('libopenjdkjvm')
     self._checker.check_native_library('libopenjdkjvmti')
+    self._checker.check_native_library('libperfetto_hprof')
     self._checker.check_native_library('libprofile')
     self._checker.check_native_library('libsigchain')
+    self._checker.check_prefer64_library('libartservice')
+    self._checker.check_prefer64_library('libarttools')
+
+    # Check internal Java libraries for ART.
+    self._checker.check_java_library('service-art')
+    self._checker.check_file('javalib/service-art.jar.prof')
+
+    # Check exported native libraries for Managed Core Library.
+    self._checker.check_native_library('libandroidio')
 
     # Check Java libraries for Managed Core Library.
     self._checker.check_java_library('apache-xml')
@@ -560,6 +505,7 @@ class ReleaseChecker:
     self._checker.check_native_library('libbase')
     self._checker.check_native_library('libc++')
     self._checker.check_native_library('libdt_socket')
+    self._checker.check_native_library('libexpat')
     self._checker.check_native_library('libjdwp')
     self._checker.check_native_library('liblz4')
     self._checker.check_native_library('liblzma')
@@ -572,65 +518,6 @@ class ReleaseChecker:
     self._checker.check_optional_native_library('libclang_rt.ubsan*')
 
 
-class ReleaseTargetChecker:
-  def __init__(self, checker):
-    self._checker = checker
-
-  def __str__(self):
-    return 'Release (Target) Checker'
-
-  def run(self):
-    # We don't check for the presence of the JSON APEX manifest (file
-    # `apex_manifest.json`, only present in target APEXes), as it is only
-    # included for compatibility reasons with Android Q and will likely be
-    # removed in Android R.
-
-    # Check binaries for ART.
-    self._checker.check_executable('art_boot')
-    self._checker.check_executable('art_exec')
-    self._checker.check_executable('artd')
-    self._checker.check_executable('dexopt_chroot_setup')
-    self._checker.check_executable('oatdump')
-    self._checker.check_executable('odrefresh')
-    self._checker.check_symlinked_multilib_executable('dex2oat')
-
-    # Check internal libraries for ART.
-    self._checker.check_prefer64_library('libartservice')
-    self._checker.check_native_library('libperfetto_hprof')
-
-    # Check internal Java libraries
-    self._checker.check_java_library('service-art')
-    self._checker.check_file('javalib/service-art.jar.prof')
-
-    # Check exported native libraries for Managed Core Library.
-    self._checker.check_native_library('libandroidio')
-
-    # Check internal native library dependencies.
-    self._checker.check_native_library('libexpat')
-
-
-class ReleaseHostChecker:
-  def __init__(self, checker):
-    self._checker = checker
-
-  def __str__(self):
-    return 'Release (Host) Checker'
-
-  def run(self):
-    # Check binaries for ART.
-    self._checker.check_executable('hprof-conv')
-    self._checker.check_symlinked_first_executable('dex2oatd')
-    self._checker.check_symlinked_first_executable('dex2oat')
-
-    # Check exported native libraries for Managed Core Library.
-    self._checker.check_native_library('libicu')
-    self._checker.check_native_library('libandroidio')
-
-    # Check internal libraries for Managed Core Library.
-    self._checker.check_native_library('libexpat-host')
-    self._checker.check_native_library('libz-host')
-
-
 class DebugChecker:
   def __init__(self, checker):
     self._checker = checker
@@ -645,8 +532,10 @@ class DebugChecker:
 
     # Check debug binaries for ART.
     self._checker.check_executable('dexoptanalyzerd')
-    self._checker.check_symlinked_multilib_executable('imgdiagd')
+    self._checker.check_executable('oatdumpd')
     self._checker.check_executable('profmand')
+    self._checker.check_symlinked_multilib_executable('dex2oatd')
+    self._checker.check_symlinked_multilib_executable('imgdiagd')
 
     # Check exported libraries for ART.
     self._checker.check_native_library('libdexfiled')
@@ -658,28 +547,13 @@ class DebugChecker:
     self._checker.check_native_library('libartd-disassembler')
     self._checker.check_native_library('libopenjdkjvmd')
     self._checker.check_native_library('libopenjdkjvmtid')
+    self._checker.check_native_library('libperfetto_hprofd')
     self._checker.check_native_library('libprofiled')
+    self._checker.check_prefer64_library('libartserviced')
 
     # Check internal libraries for Managed Core Library.
     self._checker.check_native_library('libopenjdkd')
 
-
-class DebugTargetChecker:
-  def __init__(self, checker):
-    self._checker = checker
-
-  def __str__(self):
-    return 'Debug (Target) Checker'
-
-  def run(self):
-    # Check ART debug binaries.
-    self._checker.check_executable('oatdumpd')
-    self._checker.check_symlinked_multilib_executable('dex2oatd')
-
-    # Check ART internal libraries.
-    self._checker.check_prefer64_library('libartserviced')
-    self._checker.check_native_library('libperfetto_hprofd')
-
     # Check internal native library dependencies.
     #
     # Like in the release package, we check that we don't get other dependencies
@@ -696,12 +570,12 @@ class DebugTargetChecker:
     # (There are currently no debug-only native libraries.)
 
 
-class TestingTargetChecker:
+class TestingChecker:
   def __init__(self, checker):
     self._checker = checker
 
   def __str__(self):
-    return 'Testing (Target) Checker'
+    return 'Testing Checker'
 
   def run(self):
     # Check test directories.
@@ -887,9 +761,6 @@ class Tree:
 
 # Note: do not sys.exit early, for __del__ cleanup.
 def art_apex_test_main(test_args):
-  if test_args.host and test_args.flattened:
-    logging.error('Both of --host and --flattened set')
-    return 1
   if test_args.list and test_args.tree:
     logging.error('Both of --list and --tree set')
     return 1
@@ -899,7 +770,7 @@ def art_apex_test_main(test_args):
   if not test_args.flattened and not test_args.tmpdir:
     logging.error('Need a tmpdir.')
     return 1
-  if not test_args.flattened and not test_args.host:
+  if not test_args.flattened:
     if not test_args.deapexer:
       logging.error('Need deapexer.')
       return 1
@@ -910,49 +781,33 @@ def art_apex_test_main(test_args):
       logging.error('Need fsck.erofs.')
       return 1
 
-  if test_args.host:
-    # Host APEX.
-    if test_args.flavor not in [FLAVOR_DEBUG, FLAVOR_AUTO]:
-      logging.error('Using option --host with non-Debug APEX')
-      return 1
-    # Host APEX is always a debug flavor (for now).
-    test_args.flavor = FLAVOR_DEBUG
-  else:
-    # Device APEX.
+  if test_args.flavor == FLAVOR_AUTO:
+    logging.warning('--flavor=auto, trying to autodetect. This may be incorrect!')
+    # The order of flavors in the list below matters, as the release tag (empty string) will
+    # match any package name.
+    for flavor in [ FLAVOR_DEBUG, FLAVOR_TESTING, FLAVOR_RELEASE ]:
+      flavor_tag = flavor
+      # Special handling for the release flavor, whose name is no longer part of the Release ART
+      # APEX file name (`com.android.art.capex` / `com.android.art`).
+      if flavor == FLAVOR_RELEASE:
+        flavor_tag = ''
+      flavor_pattern = '*.%s*' % flavor_tag
+      if fnmatch.fnmatch(test_args.apex, flavor_pattern):
+        test_args.flavor = flavor
+        logging.warning('  Detected %s flavor', flavor)
+        break
     if test_args.flavor == FLAVOR_AUTO:
-      logging.warning('--flavor=auto, trying to autodetect. This may be incorrect!')
-      # The order of flavors in the list below matters, as the release tag (empty string) will
-      # match any package name.
-      for flavor in [ FLAVOR_DEBUG, FLAVOR_TESTING, FLAVOR_RELEASE ]:
-        flavor_tag = flavor
-        # Special handling for the release flavor, whose name is no longer part of the Release ART
-        # APEX file name (`com.android.art.capex` / `com.android.art`).
-        if flavor == FLAVOR_RELEASE:
-          flavor_tag = ''
-        flavor_pattern = '*.%s*' % flavor_tag
-        if fnmatch.fnmatch(test_args.apex, flavor_pattern):
-          test_args.flavor = flavor
-          logging.warning('  Detected %s flavor', flavor)
-          break
-      if test_args.flavor == FLAVOR_AUTO:
-        logging.error('  Could not detect APEX flavor, neither %s, %s nor %s for \'%s\'',
-                    FLAVOR_RELEASE, FLAVOR_DEBUG, FLAVOR_TESTING, test_args.apex)
-        return 1
-
-  try:
-    if test_args.host:
-      apex_provider = HostApexProvider(test_args.apex, test_args.tmpdir)
-    else:
-      apex_dir = test_args.apex
-      if not test_args.flattened:
-        # Extract the apex. It would be nice to use the output from "deapexer list"
-        # to avoid this work, but it doesn't provide info about executable bits.
-        apex_dir = extract_apex(test_args.apex, test_args.deapexer, test_args.debugfs,
-                                test_args.fsckerofs, test_args.tmpdir)
-      apex_provider = TargetApexProvider(apex_dir)
-  except (zipfile.BadZipFile, zipfile.LargeZipFile) as e:
-    logging.error('Failed to create provider: %s', e)
-    return 1
+      logging.error('  Could not detect APEX flavor, neither %s, %s nor %s for \'%s\'',
+                  FLAVOR_RELEASE, FLAVOR_DEBUG, FLAVOR_TESTING, test_args.apex)
+      return 1
+
+  apex_dir = test_args.apex
+  if not test_args.flattened:
+    # Extract the apex. It would be nice to use the output from "deapexer list"
+    # to avoid this work, but it doesn't provide info about executable bits.
+    apex_dir = extract_apex(test_args.apex, test_args.deapexer, test_args.debugfs,
+                            test_args.fsckerofs, test_args.tmpdir)
+  apex_provider = TargetApexProvider(apex_dir)
 
   if test_args.tree:
     Tree(apex_provider, test_args.apex, test_args.size).print_tree()
@@ -989,16 +844,10 @@ def art_apex_test_main(test_args):
     base_checker = MultilibChecker(apex_provider)
 
   checkers.append(ReleaseChecker(base_checker))
-  if test_args.host:
-    checkers.append(ReleaseHostChecker(base_checker))
-  else:
-    checkers.append(ReleaseTargetChecker(base_checker))
   if test_args.flavor == FLAVOR_DEBUG or test_args.flavor == FLAVOR_TESTING:
     checkers.append(DebugChecker(base_checker))
-    if not test_args.host:
-      checkers.append(DebugTargetChecker(base_checker))
   if test_args.flavor == FLAVOR_TESTING:
-    checkers.append(TestingTargetChecker(base_checker))
+    checkers.append(TestingChecker(base_checker))
 
   # This checker must be last.
   checkers.append(NoSuperfluousFilesChecker(base_checker))
@@ -1041,25 +890,22 @@ def art_apex_test_default(test_parser):
                   test_args.debugfs)
     sys.exit(1)
 
-  # TODO: Add host support.
   # TODO: Add support for flattened APEX packages.
   configs = [
-    {'name': 'com.android.art.capex',         'flavor': FLAVOR_RELEASE, 'host': False},
-    {'name': 'com.android.art.debug.capex',   'flavor': FLAVOR_DEBUG,   'host': False},
+    {'name': 'com.android.art.capex',         'flavor': FLAVOR_RELEASE},
+    {'name': 'com.android.art.debug.capex',   'flavor': FLAVOR_DEBUG},
     # Note: The Testing ART APEX is not a Compressed APEX.
-    {'name': 'com.android.art.testing.apex',  'flavor': FLAVOR_TESTING, 'host': False},
+    {'name': 'com.android.art.testing.apex',  'flavor': FLAVOR_TESTING},
   ]
 
   for config in configs:
     logging.info(config['name'])
-    # TODO: Host will need different path.
     test_args.apex = '%s/system/apex/%s' % (product_out, config['name'])
     if not os.path.exists(test_args.apex):
       failed = True
       logging.error('Cannot find APEX %s. Please build it first.', test_args.apex)
       continue
     test_args.flavor = config['flavor']
-    test_args.host = config['host']
     failed = art_apex_test_main(test_args) != 0
 
   if failed:
@@ -1071,8 +917,6 @@ if __name__ == '__main__':
 
   parser.add_argument('apex', help='APEX file input')
 
-  parser.add_argument('--host', help='Check as host APEX', action='store_true')
-
   parser.add_argument('--flattened', help='Check as flattened (target) APEX', action='store_true')
 
   parser.add_argument('--flavor', help='Check as FLAVOR APEX', choices=FLAVORS_ALL,
diff --git a/build/apex/dirty-image-objects b/build/apex/dirty-image-objects
new file mode 100644
index 0000000000..3be86c13a1
--- /dev/null
+++ b/build/apex/dirty-image-objects
@@ -0,0 +1,632 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#
+#
+# Dirty-image-objects file for boot image.
+# The image writer will bin these objects together in the image.
+# More info about dirty objects format and how to collect the data can be
+# found in: art/imgdiag/dirty_image_objects.md
+# This particular file was generated by:
+# https://android-build.corp.google.com/test_investigate/invocation/I55400010326683472/
+#
+Ljava/security/Signature;.signatureInfo:Ljava/util/Map;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.8:Ljava/util/concurrent/ConcurrentHashMap$Node; 0
+Ljava/util/Collections$UnmodifiableMap; 1
+Ljava/util/Collections$UnmodifiableRandomAccessList; 3
+Ljava/lang/String$CaseInsensitiveComparator; 4
+Ljava/time/format/TextStyle;.NARROW_STANDALONE:Ljava/time/format/TextStyle; 4
+Ljava/time/format/TextStyle;.SHORT_STANDALONE:Ljava/time/format/TextStyle; 4
+Ljava/time/format/DateTimeFormatterBuilder$ZoneTextPrinterParser;.cache:Ljava/util/Map; 4
+Ljava/time/format/DateTimeTextProvider;.CACHE:Ljava/util/concurrent/ConcurrentMap; 4
+Ljava/time/format/TextStyle;.SHORT:Ljava/time/format/TextStyle; 4
+Ljava/util/Collections$UnmodifiableCollection; 4
+Ljava/time/format/TextStyle;.NARROW:Ljava/time/format/TextStyle; 4
+Ljava/time/format/TextStyle;.FULL_STANDALONE:Ljava/time/format/TextStyle; 4
+Ljava/util/Collections$UnmodifiableList; 4
+Ljava/lang/String;.CASE_INSENSITIVE_ORDER:Ljava/util/Comparator; 4
+Lcom/android/org/bouncycastle/jce/provider/BouncyCastleProvider; 7
+Ljavax/crypto/IllegalBlockSizeException; 7
+Lsun/util/logging/PlatformLogger; 8
+Ljava/security/cert/CertificateException; 18
+Lcom/android/org/bouncycastle/jcajce/provider/asymmetric/dsa/DSAUtil;.dsaOids:[Lcom/android/org/bouncycastle/asn1/ASN1ObjectIdentifier;.0:Lcom/android/org/bouncycastle/asn1/ASN1ObjectIdentifier; 18
+Ljava/time/DateTimeException; 18
+Ljava/io/FileReader; 18
+Ljava/lang/ref/Reference; 23
+Ljava/lang/Package; 23
+Ljava/lang/ref/ReferenceQueue; 23
+Ljava/security/PublicKey; 26
+Ljava/math/MathContext; 26
+Ljava/util/LinkedHashMap$LinkedValues; 26
+[Ljava/security/cert/Certificate; 26
+Ljava/security/cert/Certificate; 26
+Ljava/lang/UnsatisfiedLinkError; 27
+I 35
+F 36
+Z 37
+B 37
+J 38
+S 39
+C 39
+D 39
+Ljava/util/Collections$SingletonSet; 40
+Ljava/util/LinkedList; 48
+Ljava/util/concurrent/ConcurrentHashMap; 49
+Ljava/util/concurrent/ConcurrentMap; 50
+Ljava/net/URL; 51
+Ljava/util/regex/Pattern; 52
+Ljava/util/Currency; 53
+Ljava/util/Calendar; 54
+Ljava/util/concurrent/atomic/AtomicInteger; 55
+Ljava/util/concurrent/atomic/AtomicLong; 55
+Ljava/util/concurrent/atomic/AtomicBoolean; 56
+Ljava/lang/StringBuilder; 57
+Ljava/lang/StringBuffer; 57
+Ljava/net/URI; 58
+Ljava/util/UUID; 59
+Ljava/math/BigDecimal; 60
+Ljava/util/LinkedHashMap; 61
+Ljava/util/SequencedMap; 62
+Ljava/util/SequencedCollection; 63
+Ljava/lang/Class$Caches;.genericInterfaces:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap; 64
+Ljava/util/List; 65
+Ljava/lang/String; 66
+Llibcore/util/NativeAllocationRegistry;.registries:Ljava/util/Map; 67
+Ljava/nio/charset/Charset;.cache2:Ljava/util/HashMap; 84
+Lsun/security/x509/X500Name;.orgName_oid:Lsun/security/util/ObjectIdentifier; 85
+Lsun/security/x509/X500Name;.countryName_oid:Lsun/security/util/ObjectIdentifier; 85
+Lsun/security/x509/X500Name;.commonName_oid:Lsun/security/util/ObjectIdentifier; 85
+Lsun/security/x509/PKIXExtensions;.CertificatePolicies_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/provider/X509Factory;.certCache:Lsun/security/util/Cache;.cacheMap:Ljava/util/Map; 86
+Lsun/security/x509/PKIXExtensions;.PolicyConstraints_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.AuthorityKey_Id:Lsun/security/util/ObjectIdentifier; 86
+Ljava/security/cert/PKIXRevocationChecker$Option;.NO_FALLBACK:Ljava/security/cert/PKIXRevocationChecker$Option; 86
+Ljava/security/cert/PKIXRevocationChecker$Option;.ONLY_END_ENTITY:Ljava/security/cert/PKIXRevocationChecker$Option; 86
+Lsun/security/x509/PKIXExtensions;.PolicyMappings_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.SubjectAlternativeName_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.BasicConstraints_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.ExtendedKeyUsage_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.NameConstraints_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/x509/PKIXExtensions;.KeyUsage_Id:Lsun/security/util/ObjectIdentifier; 86
+Lsun/security/provider/X509Factory;.certCache:Lsun/security/util/Cache; 86
+Lsun/security/x509/PKIXExtensions;.InhibitAnyPolicy_Id:Lsun/security/util/ObjectIdentifier; 86
+Ljava/net/Inet6AddressImpl;.addressCache:Ljava/net/AddressCache;.cache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap; 87
+Ljava/net/Proxy;.NO_PROXY:Ljava/net/Proxy;.type:Ljava/net/Proxy$Type; 88
+Ljava/net/ProxySelector;.theProxySelector:Ljava/net/ProxySelector; 89
+Ljava/lang/IllegalAccessException; 90
+Ljavax/net/ssl/SSLSocketFactory; 90
+Ljavax/net/ssl/HttpsURLConnection$NoPreloadHolder; 90
+Lcom/android/okhttp/internal/http/AuthenticatorAdapter;.INSTANCE:Lcom/android/okhttp/Authenticator; 91
+Lcom/android/okhttp/Protocol;.HTTP_1_1:Lcom/android/okhttp/Protocol; 91
+Lcom/android/okhttp/okio/AsyncTimeout; 91
+Lcom/android/okhttp/Dns;.SYSTEM:Lcom/android/okhttp/Dns; 92
+Lcom/android/okhttp/ConfigAwareConnectionPool;.instance:Lcom/android/okhttp/ConfigAwareConnectionPool; 92
+Lcom/android/okhttp/ConfigAwareConnectionPool;.instance:Lcom/android/okhttp/ConfigAwareConnectionPool;.networkEventDispatcher:Llibcore/net/event/NetworkEventDispatcher;.listeners:Ljava/util/List; 92
+Lcom/android/okhttp/okio/SegmentPool; 93
+Ljava/net/URL;.handlers:Ljava/util/Hashtable;.table:[Ljava/util/Hashtable$HashtableEntry; 94
+Ljava/net/URL;.handlers:Ljava/util/Hashtable; 94
+Lcom/android/org/bouncycastle/crypto/CryptoServicesRegistrar; 95
+Ljavax/net/ssl/SSLSessionContext; 96
+Ljavax/net/SocketFactory; 97
+Ljava/security/Security;.spiMap:Ljava/util/Map; 98
+Lsun/security/x509/X500Name;.orgUnitName_oid:Lsun/security/util/ObjectIdentifier; 99
+Lsun/security/x509/X500Name;.localityName_oid:Lsun/security/util/ObjectIdentifier; 100
+Lsun/security/x509/X500Name;.stateName_oid:Lsun/security/util/ObjectIdentifier; 101
+Ljava/security/Signature;.signatureInfo:Ljava/util/Map; 102
+Ljava/security/Signature;.signatureInfo:Ljava/util/Map;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.13:Ljava/util/concurrent/ConcurrentHashMap$Node;.next:Ljava/util/concurrent/ConcurrentHashMap$Node;.next:Ljava/util/concurrent/ConcurrentHashMap$Node; 103
+Lsun/security/provider/certpath/CertId;.SHA1_ALGID:Lsun/security/x509/AlgorithmId;.algid:Lsun/security/util/ObjectIdentifier; 104
+Ljava/security/cert/PKIXRevocationChecker$Option;.SOFT_FAIL:Ljava/security/cert/PKIXRevocationChecker$Option; 104
+Ljava/security/cert/PKIXRevocationChecker$Option;.PREFER_CRLS:Ljava/security/cert/PKIXRevocationChecker$Option; 104
+Lsun/security/x509/PKIXExtensions;.SubjectKey_Id:Lsun/security/util/ObjectIdentifier; 105
+Ljava/lang/reflect/Proxy;.proxyClassCache:Ljava/lang/reflect/WeakCache;.map:Ljava/util/concurrent/ConcurrentMap; 106
+Ljava/lang/reflect/Proxy;.proxyClassCache:Ljava/lang/reflect/WeakCache;.reverseMap:Ljava/util/concurrent/ConcurrentMap; 107
+Ljava/lang/reflect/Proxy$ProxyClassFactory;.nextUniqueNumber:Ljava/util/concurrent/atomic/AtomicLong; 107
+Llibcore/reflect/AnnotationFactory;.cache:Ljava/util/Map; 108
+Llibcore/reflect/AnnotationFactory;.cache:Ljava/util/Map;.table:[Ljava/util/WeakHashMap$Entry; 108
+Ljava/lang/Integer;.SMALL_NONNEG_VALUES:[Ljava/lang/String; 119
+Ljava/lang/Object; 120
+Ljava/util/concurrent/LinkedTransferQueue; 121
+Lsun/util/logging/PlatformLogger$Level;.dexCache:Ljava/lang/Object; 121
+Ljava/lang/invoke/MethodType;.internTable:Ljdk/internal/util/ReferencedKeySet;.map:Ljdk/internal/util/ReferencedKeyMap;.map:Ljava/util/Map; 121
+Ljava/util/concurrent/LinkedTransferQueue$DualNode; 122
+Ljava/util/concurrent/ThreadLocalRandom; 123
+Lsun/nio/ch/SharedFileLockTable;.lockMap:Ljava/util/concurrent/ConcurrentHashMap; 124
+Ljava/util/concurrent/Executors$DefaultThreadFactory;.poolNumber:Ljava/util/concurrent/atomic/AtomicInteger; 128
+Ljava/nio/charset/Charset; 129
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap; 130
+Ljdk/internal/ref/CleanerFactory;.commonCleaner:Ljava/lang/ref/Cleaner;.impl:Ljdk/internal/ref/CleanerImpl;.phantomCleanableList:Ljdk/internal/ref/PhantomCleanable; 131
+Ldalvik/system/RuntimeHooks; 133
+Ldalvik/system/SocketTagger; 133
+Ljava/util/Random;.seedUniquifier:Ljava/util/concurrent/atomic/AtomicLong; 133
+Landroid/compat/Compatibility; 133
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.systemContext:Ljava/util/logging/LogManager$LoggerContext;.namedLoggers:Ljava/util/Hashtable;.table:[Ljava/util/Hashtable$HashtableEntry; 133
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.systemContext:Ljava/util/logging/LogManager$LoggerContext;.namedLoggers:Ljava/util/Hashtable; 133
+Ljava/util/Locale; 133
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.systemContext:Ljava/util/logging/LogManager$LoggerContext;.root:Ljava/util/logging/LogManager$LogNode; 133
+Ljava/lang/ThreadGroup;.mainThreadGroup:Ljava/lang/ThreadGroup; 133
+Ljava/lang/System; 133
+Ljava/util/TimeZone; 133
+Ljava/lang/ThreadGroup;.systemThreadGroup:Ljava/lang/ThreadGroup; 133
+Ldalvik/system/CloseGuard; 133
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager; 133
+Ljava/lang/Daemons$HeapTaskDaemon;.INSTANCE:Ljava/lang/Daemons$HeapTaskDaemon; 133
+Ljava/security/Provider; 133
+Ljava/lang/ThreadLocal;.nextHashCode:Ljava/util/concurrent/atomic/AtomicInteger; 133
+Ljava/lang/Daemons;.DAEMONS:[Ljava/lang/Daemons$Daemon;.2:Ljava/lang/Daemons$FinalizerDaemon; 133
+Ldalvik/system/ZygoteHooks; 133
+Lsun/misc/Cleaner; 133
+Ldalvik/system/VMRuntime;.THE_ONE:Ldalvik/system/VMRuntime; 133
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.userContext:Ljava/util/logging/LogManager$LoggerContext;.namedLoggers:Ljava/util/Hashtable; 133
+Ljava/lang/Daemons$ReferenceQueueDaemon;.INSTANCE:Ljava/lang/Daemons$ReferenceQueueDaemon;.progressCounter:Ljava/util/concurrent/atomic/AtomicInteger; 134
+Ljava/lang/Daemons; 134
+Ljava/lang/Daemons;.DAEMONS:[Ljava/lang/Daemons$Daemon;.2:Ljava/lang/Daemons$FinalizerDaemon;.progressCounter:Ljava/util/concurrent/atomic/AtomicInteger; 134
+Ljava/lang/Thread; 134
+Ljava/lang/ref/FinalizerReference; 134
+Ljava/lang/Daemons$ReferenceQueueDaemon;.INSTANCE:Ljava/lang/Daemons$ReferenceQueueDaemon; 134
+Ldalvik/system/VMRuntime;.THE_ONE:Ldalvik/system/VMRuntime;.allocationCount:Ljava/util/concurrent/atomic/AtomicInteger; 134
+Ldalvik/system/BaseDexClassLoader; 135
+Llibcore/net/NetworkSecurityPolicy; 135
+Lsun/security/jca/Providers; 135
+Llibcore/io/Libcore; 135
+Ljava/security/Security;.version:Ljava/util/concurrent/atomic/AtomicInteger; 135
+Ljava/util/Locale$NoImagePreloadHolder; 137
+Ljava/lang/Daemons$FinalizerWatchdogDaemon;.INSTANCE:Ljava/lang/Daemons$FinalizerWatchdogDaemon; 138
+Landroid/system/StructTimeval; 141
+Landroid/system/UnixSocketAddress; 141
+Landroid/system/StructPollfd; 141
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry; 148
+Ljava/lang/Integer;.SMALL_NEG_VALUES:[Ljava/lang/String; 149
+Ljava/util/zip/ZipFile$Source;.files:Ljava/util/HashMap; 150
+Ljava/lang/invoke/MethodType;.objectOnlyTypes:[Ljava/lang/invoke/MethodType; 157
+Ljavax/net/ssl/SSLContext; 158
+Ljavax/net/ssl/HttpsURLConnection; 158
+Lsun/nio/ch/FileChannelImpl$Unmapper; 159
+Ljava/io/FileDescriptor; 161
+Ljava/util/Date; 190
+Ljava/lang/Runtime;.currentRuntime:Ljava/lang/Runtime;.shutdownHooks:Ljava/util/List;.elementData:[Ljava/lang/Object; 191
+Ljava/lang/Runtime;.currentRuntime:Ljava/lang/Runtime;.shutdownHooks:Ljava/util/List; 191
+Ljava/util/Map; 192
+Ljava/util/HashMap; 193
+Ljava/util/ArrayList; 194
+Ljava/util/AbstractMap; 195
+Lsun/security/provider/X509Factory; 196
+Llibcore/icu/DecimalFormatData;.CACHE:Ljava/util/concurrent/ConcurrentHashMap; 197
+Ljava/util/Currency;.instances:Ljava/util/concurrent/ConcurrentMap; 200
+Ljava/text/DateFormatSymbols;.cachedInstances:Ljava/util/concurrent/ConcurrentMap; 201
+Ljava/text/SimpleDateFormat;.cachedNumberFormatData:Ljava/util/concurrent/ConcurrentMap; 202
+Ljava/util/Calendar;.cachedLocaleData:Ljava/util/concurrent/ConcurrentMap; 203
+[Ljava/lang/Throwable; 208
+Ljava/lang/ref/WeakReference; 209
+Lorg/json/JSONArray; 210
+Lorg/json/JSONObject; 211
+Ljava/io/File; 212
+Ljava/nio/Bits; 213
+Ljava/nio/DirectByteBuffer; 214
+Ljava/nio/ByteBuffer; 216
+Ljava/io/InputStream; 217
+Ljava/lang/Number; 220
+Ljava/io/ObjectInputStream; 221
+Ljava/io/ObjectOutputStream; 221
+Ljava/io/ObjectStreamClass$Caches;.reflectors:Ljava/util/concurrent/ConcurrentMap; 222
+Ljava/io/ObjectStreamClass$Caches;.localDescs:Ljava/util/concurrent/ConcurrentMap; 222
+Ljava/lang/Throwable; 223
+Ldalvik/system/ZipPathValidator; 228
+Ljava/lang/reflect/Method; 263
+Ljava/text/DontCareFieldPosition;.INSTANCE:Ljava/text/FieldPosition; 266
+Ljava/lang/Void; 268
+Ljava/util/Observer; 269
+Ljava/util/concurrent/ConcurrentSkipListMap$Node; 270
+Ljava/lang/ClassNotFoundException; 271
+Ljava/util/Timer;.nextSerialNumber:Ljava/util/concurrent/atomic/AtomicInteger; 272
+Ljava/lang/Class; 273
+Ljava/lang/Comparable; 274
+Ljava/lang/Cloneable; 275
+Ljava/lang/Iterable; 276
+Ljava/util/Iterator; 277
+Ljava/util/ListIterator; 277
+Ljava/util/Collection; 278
+Ljava/lang/Enum; 279
+Ljava/lang/CharSequence; 280
+Ljava/util/Set; 281
+Ljava/lang/annotation/Annotation; 282
+Ljava/util/concurrent/ExecutorService; 283
+Ljava/util/concurrent/ScheduledExecutorService; 284
+Ljava/util/concurrent/Executor; 284
+Ljava/math/BigInteger; 286
+[B 287
+[S 295
+[C 296
+Ljava/lang/Deprecated; 297
+Ljava/lang/annotation/Target; 298
+Ljava/lang/annotation/Retention; 298
+Ljava/lang/annotation/Documented; 298
+Ljava/lang/BootClassLoader; 299
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.177:Ljava/lang/Long; 300
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.181:Ljava/lang/Long; 301
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.186:Ljava/lang/Long; 302
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.183:Ljava/lang/Long; 303
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.180:Ljava/lang/Long; 304
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.190:Ljava/lang/Long; 305
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.176:Ljava/lang/Long; 306
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.228:Ljava/lang/Long; 308
+Ljava/net/URLConnection; 316
+Ljava/util/HashSet; 317
+Ljava/sql/Timestamp; 318
+Ljava/sql/Date; 319
+Ljava/sql/Time; 320
+Ljava/util/SortedSet; 321
+Ljava/util/concurrent/ConcurrentNavigableMap; 321
+Ljava/util/SortedMap; 322
+Ljava/util/NavigableMap; 323
+Ljava/util/RandomAccess; 324
+Ljava/util/concurrent/ForkJoinTask$Aux; 326
+Ljava/util/concurrent/ConcurrentLinkedDeque$Node; 327
+Ljava/util/concurrent/CancellationException; 330
+Ljava/lang/Character$UnicodeBlock;.HALFWIDTH_AND_FULLWIDTH_FORMS:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.HIRAGANA:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.BOPOMOFO_EXTENDED:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.CJK_COMPATIBILITY:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.HANGUL_JAMO:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.CJK_RADICALS_SUPPLEMENT:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.KATAKANA:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.CJK_SYMBOLS_AND_PUNCTUATION:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.KANBUN:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.HANGUL_COMPATIBILITY_JAMO:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.ENCLOSED_CJK_LETTERS_AND_MONTHS:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.HANGUL_SYLLABLES:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.KANGXI_RADICALS:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.BOPOMOFO:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.CJK_COMPATIBILITY_FORMS:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.KATAKANA_PHONETIC_EXTENSIONS:Ljava/lang/Character$UnicodeBlock; 335
+Ljava/lang/Character$UnicodeBlock;.CJK_UNIFIED_IDEOGRAPHS:Ljava/lang/Character$UnicodeBlock; 336
+Ljava/lang/Character$UnicodeBlock;.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B:Ljava/lang/Character$UnicodeBlock; 336
+Ljava/lang/Character$UnicodeBlock;.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A:Ljava/lang/Character$UnicodeBlock; 336
+Ljava/lang/Character$UnicodeBlock;.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT:Ljava/lang/Character$UnicodeBlock; 336
+Ljava/lang/Character$UnicodeBlock;.CJK_COMPATIBILITY_IDEOGRAPHS:Ljava/lang/Character$UnicodeBlock; 336
+Ljava/security/interfaces/DSAPublicKey; 354
+Ljava/security/interfaces/DSAKey; 354
+Ljava/lang/NumberFormatException; 356
+Ljava/lang/reflect/Modifier; 365
+Ljava/lang/ProcessBuilder; 365
+Ljava/util/concurrent/ConcurrentLinkedDeque; 365
+Ljava/util/concurrent/Future; 365
+Ljava/lang/Runtime; 365
+Ljava/util/Collections$SynchronizedList; 366
+Ljava/util/Collections$SynchronizedRandomAccessList; 366
+Ldalvik/system/CloseGuard;.MESSAGE:Ljava/lang/String; 370
+Llibcore/util/NativeAllocationRegistry; 370
+Lorg/apache/harmony/dalvik/ddmc/DdmServer;.mHandlerMap:Ljava/util/HashMap; 370
+Ljava/util/SimpleTimeZone; 371
+Ljava/util/Collections$EmptyMap; 373
+Ljava/lang/NoSuchFieldError; 374
+Ljava/lang/IndexOutOfBoundsException; 374
+Ljava/lang/InstantiationError; 374
+Ljava/lang/StackOverflowError; 374
+Ljava/util/Hashtable; 374
+Ljava/lang/IllegalThreadStateException; 374
+Ljava/util/WeakHashMap; 374
+Ljava/lang/InternalError; 374
+Ljava/lang/LinkageError; 374
+Ljava/lang/VerifyError; 374
+Ljava/lang/StringIndexOutOfBoundsException; 374
+Ljava/util/TreeSet; 374
+Ljava/util/zip/ZipException; 374
+Ljava/lang/AutoCloseable; 374
+Ljava/lang/OutOfMemoryError; 374
+Ljava/lang/InstantiationException; 374
+Ljava/util/BitSet; 374
+Ljava/lang/IllegalMonitorStateException; 374
+Ljava/lang/TypeNotPresentException; 374
+Ljava/util/concurrent/atomic/AtomicLongArray; 374
+Ljava/lang/Appendable; 374
+Ljava/util/concurrent/atomic/AtomicIntegerArray; 374
+Ljava/lang/NegativeArraySizeException; 374
+Ljava/security/interfaces/RSAPrivateCrtKey; 381
+Lorg/xmlpull/v1/XmlPullParserException; 387
+Ljava/util/concurrent/BlockingQueue; 392
+Ljava/util/concurrent/PriorityBlockingQueue; 392
+Ljava/security/InvalidAlgorithmParameterException; 392
+Ljava/net/ResponseCache; 394
+Ljava/util/logging/Filter; 395
+Ljava/util/EnumSet; 396
+Ljavax/xml/datatype/Duration; 397
+[Ljava/lang/Double; 400
+Ljava/util/Scanner; 410
+Ljava/lang/UnsupportedOperationException; 413
+Ljava/lang/reflect/Type; 414
+Ljava/lang/ThreadLocal; 414
+Lorg/json/JSONObject$1; 414
+Ljava/util/concurrent/CopyOnWriteArrayList; 416
+Landroid/system/ErrnoException; 420
+Ljava/io/FileNotFoundException; 421
+[Ljava/lang/String; 424
+Ljava/security/Signature;.signatureInfo:Ljava/util/Map;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node; 425
+Ljava/security/Signature;.signatureInfo:Ljava/util/Map;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.4:Ljava/util/concurrent/ConcurrentHashMap$Node;.next:Ljava/util/concurrent/ConcurrentHashMap$Node; 426
+[F 432
+[D 433
+[Z 434
+Ljava/net/ProxySelector; 438
+Ljava/lang/IllegalAccessError; 439
+Ljava/util/TreeMap; 440
+Ljava/text/SimpleDateFormat; 441
+Ljava/io/Closeable; 441
+Ljava/security/Security;.props:Ljava/util/Properties;.map:Ljava/util/concurrent/ConcurrentHashMap; 442
+[[I 442
+Ldalvik/system/VMDebug;.runtimeStatsMap:Ljava/util/HashMap; 442
+Lsun/net/spi/DefaultProxySelector;.props:[[Ljava/lang/String;.1:[Ljava/lang/String;.0:Ljava/lang/String; 442
+Ljava/security/Security;.props:Ljava/util/Properties;.map:Ljava/util/concurrent/ConcurrentHashMap;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.26:Ljava/util/concurrent/ConcurrentHashMap$Node; 442
+Lsun/net/spi/DefaultProxySelector;.props:[[Ljava/lang/String;.0:[Ljava/lang/String;.0:Ljava/lang/String; 442
+Ljava/util/concurrent/ConcurrentHashMap$Segment; 443
+Ljava/util/concurrent/locks/ReentrantLock$Sync; 443
+Ljava/util/concurrent/locks/AbstractOwnableSynchronizer; 443
+Ljava/util/concurrent/locks/ReentrantLock; 443
+Ljava/util/concurrent/locks/AbstractQueuedSynchronizer; 443
+Ljava/util/concurrent/locks/ReentrantLock$NonfairSync; 443
+[Ljava/util/concurrent/ConcurrentHashMap$Segment; 443
+Ljavax/net/ssl/SSLPeerUnverifiedException; 451
+Ljava/net/ProtocolException; 451
+Ljavax/net/ssl/SSLProtocolException; 451
+Lcom/android/okhttp/internal/huc/HttpsURLConnectionImpl; 453
+Ljava/io/EOFException; 456
+[Ljava/lang/Integer; 459
+Ljava/util/concurrent/ConcurrentLinkedQueue; 461
+Ljava/util/concurrent/ConcurrentLinkedQueue$Node; 462
+Ljava/lang/AbstractMethodError; 463
+Ljava/lang/InterruptedException; 464
+Ljava/net/Inet4Address; 465
+Ljava/lang/ref/SoftReference; 466
+Ljava/net/Socket; 471
+Ljava/lang/ClassLoader; 472
+[Ljava/lang/Object; 479
+Lcom/android/okhttp/OkHttpClient; 481
+Lcom/android/okhttp/Protocol;.SPDY_3:Lcom/android/okhttp/Protocol; 481
+Lcom/android/okhttp/Protocol;.HTTP_2:Lcom/android/okhttp/Protocol; 481
+Ljava/lang/Runnable; 488
+Ljava/lang/NoClassDefFoundError; 494
+Ljava/lang/NoSuchMethodError; 495
+Lsun/security/x509/X500Name;.internedOIDs:Ljava/util/Map;.table:[Ljava/util/HashMap$Node;.29:Ljava/util/HashMap$Node;.next:Ljava/util/HashMap$Node; 498
+Ljava/util/NavigableSet; 500
+Ljava/lang/constant/ConstantDesc; 501
+Ljava/lang/constant/Constable; 502
+Ljava/net/InetSocketAddress; 503
+Lsun/misc/Unsafe; 504
+Ljava/util/Queue; 507
+Ljava/net/InetAddress; 509
+Ljava/util/concurrent/ForkJoinPool; 510
+Ljava/util/concurrent/ForkJoinPool$WorkQueue; 511
+[Ljava/util/concurrent/ForkJoinTask; 511
+Ljava/util/concurrent/ForkJoinTask; 512
+Ljava/util/concurrent/CompletableFuture; 513
+Ljava/nio/channels/spi/SelectorProvider; 514
+Lsun/nio/ch/Net; 514
+Lsun/nio/ch/Util; 514
+Ljava/net/StandardProtocolFamily;.INET:Ljava/net/StandardProtocolFamily; 515
+Ljava/net/StandardSocketOptions;.SO_BROADCAST:Ljava/net/SocketOption; 515
+Ljava/net/StandardProtocolFamily;.INET6:Ljava/net/StandardProtocolFamily; 515
+Ljava/net/HttpURLConnection; 516
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache; 518
+Ljava/text/DecimalFormat; 519
+Ljava/util/HashMap$Values; 519
+[Ljava/io/File; 519
+Ldalvik/system/BaseDexClassLoader$Reporter; 519
+Ljava/lang/ThreadDeath; 519
+Ljava/util/concurrent/CopyOnWriteArraySet; 520
+Ljava/io/FileSystem; 521
+Ljava/nio/file/Path; 521
+Ljava/util/ArrayDeque; 523
+Ljava/util/Deque; 524
+Ljava/net/ConnectException; 525
+[I 527
+Ljava/lang/Float; 533
+Ljava/lang/Long; 534
+Ljava/lang/Boolean; 534
+Ljava/security/Security;.props:Ljava/util/Properties;.map:Ljava/util/concurrent/ConcurrentHashMap;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.12:Ljava/util/concurrent/ConcurrentHashMap$Node;.next:Ljava/util/concurrent/ConcurrentHashMap$Node; 539
+Ljava/security/Security;.props:Ljava/util/Properties;.map:Ljava/util/concurrent/ConcurrentHashMap;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.30:Ljava/util/concurrent/ConcurrentHashMap$Node; 539
+Ljavax/net/ssl/SSLServerSocketFactory; 540
+Ljava/lang/RuntimeException; 542
+Ljava/lang/NullPointerException; 543
+Ljava/io/IOException; 545
+Llibcore/util/NativeAllocationRegistry;.registries:Ljava/util/Map;.queue:Ljava/lang/ref/ReferenceQueue; 552
+[Ljava/lang/StackTraceElement; 558
+Ljava/lang/StackTraceElement; 559
+Ljava/util/AbstractList; 560
+Ljava/util/AbstractCollection; 561
+Ljava/util/AbstractSet; 562
+Lorg/json/JSONException; 563
+Ldalvik/system/VMRuntime; 567
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.185:Ljava/lang/Long; 568
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.155:Ljava/lang/Long; 569
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.191:Ljava/lang/Long; 569
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.187:Ljava/lang/Long; 570
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.146:Ljava/lang/Long; 571
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.184:Ljava/lang/Long; 571
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.154:Ljava/lang/Long; 572
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.145:Ljava/lang/Long; 573
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.188:Ljava/lang/Long; 573
+Ljava/util/concurrent/atomic/AtomicReference; 574
+Ljava/util/concurrent/TimeUnit; 575
+Ljava/util/concurrent/TimeUnit;.DAYS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.HOURS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.MINUTES:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.MICROSECONDS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.MILLISECONDS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.NANOSECONDS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/util/concurrent/TimeUnit;.SECONDS:Ljava/util/concurrent/TimeUnit; 576
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.150:Ljava/lang/Long; 578
+Ljava/nio/channels/ClosedByInterruptException; 578
+Ljava/util/concurrent/CompletableFuture$Completion; 578
+Ljava/util/Observable; 578
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.158:Ljava/lang/Long; 579
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.182:Ljava/lang/Long; 580
+Lcom/android/okhttp/internal/huc/HttpURLConnectionImpl; 581
+Ljava/io/FileOutputStream; 581
+Ljava/io/FileInputStream; 581
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.159:Ljava/lang/Long; 581
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.151:Ljava/lang/Long; 582
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.156:Ljava/lang/Long; 583
+Ljava/lang/SecurityException; 586
+Ljava/lang/ArrayIndexOutOfBoundsException; 587
+Ljava/util/ConcurrentModificationException; 588
+Ljava/lang/ClassCastException; 589
+Ljava/lang/IllegalStateException; 593
+Ljava/lang/Exception; 594
+Ljava/lang/Runtime;.currentRuntime:Ljava/lang/Runtime; 595
+Ljava/util/Random; 596
+Ljava/util/Collections$SingletonList; 597
+Ljava/util/Arrays$ArrayList; 598
+Lsun/security/x509/X500Name;.internedOIDs:Ljava/util/Map;.table:[Ljava/util/HashMap$Node; 599
+Lsun/security/x509/X500Name;.internedOIDs:Ljava/util/Map; 599
+Lsun/security/x509/X500Name;.SERIALNUMBER_OID:Lsun/security/util/ObjectIdentifier; 600
+Ljava/security/cert/X509Certificate; 601
+Ljava/lang/ThreadGroup;.mainThreadGroup:Ljava/lang/ThreadGroup;.name:Ljava/lang/String; 603
+Ljava/util/concurrent/ThreadPoolExecutor$Worker; 603
+Lcom/android/okhttp/Protocol;.HTTP_1_1:Lcom/android/okhttp/Protocol;.protocol:Ljava/lang/String; 603
+Lsun/security/x509/CRLReasonCodeExtension;.REASON:Ljava/lang/String; 605
+Ljava/text/NumberFormat$Field;.instanceMap:Ljava/util/Map;.table:[Ljava/util/HashMap$Node;.6:Ljava/util/HashMap$Node;.key:Ljava/lang/Object; 605
+Lcom/android/okhttp/HttpUrl;.PATH_SEGMENT_ENCODE_SET_URI:Ljava/lang/String; 605
+Ljava/io/InterruptedIOException; 606
+Ljava/net/HttpCookie; 607
+Ljava/time/DayOfWeek;.TUESDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.SUNDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.SATURDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.WEDNESDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.THURSDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.MONDAY:Ljava/time/DayOfWeek; 608
+Ljava/time/DayOfWeek;.FRIDAY:Ljava/time/DayOfWeek; 608
+Ljava/lang/NoSuchMethodException; 610
+Ljava/lang/ClassValue;.nextHashCode:Ljava/util/concurrent/atomic/AtomicInteger; 612
+Ljava/util/Collections$SingletonMap; 613
+Ljava/util/Collections; 616
+Ljava/lang/IllegalArgumentException; 621
+Lsun/util/locale/BaseLocale$Cache;.CACHE:Lsun/util/locale/BaseLocale$Cache;.map:Ljava/util/concurrent/ConcurrentMap; 623
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.loggerRefQueue:Ljava/lang/ref/ReferenceQueue; 626
+Ljava/util/Collections$SynchronizedMap; 632
+Ljava/awt/font/TextAttribute;.instanceMap:Ljava/util/Map;.table:[Ljava/util/HashMap$Node;.11:Ljava/util/HashMap$Node;.key:Ljava/lang/Object; 640
+Llibcore/icu/SimpleDateFormatData;.CACHE:Ljava/util/concurrent/ConcurrentHashMap; 641
+Ljava/nio/charset/spi/CharsetProvider; 642
+Ljavax/net/ssl/SSLException; 649
+Ljavax/net/ssl/SSLHandshakeException; 650
+Ljava/net/UnknownHostException; 651
+Ljava/net/SocketTimeoutException; 652
+Ljava/security/cert/CertPathValidatorException; 653
+Ljava/io/ObjectStreamField; 653
+Ljava/util/WeakHashMap;.NULL_KEY:Ljava/lang/Object; 654
+Ljava/util/NoSuchElementException; 657
+Ljava/lang/invoke/MethodType;.internTable:Ljdk/internal/util/ReferencedKeySet;.map:Ljdk/internal/util/ReferencedKeyMap;.stale:Ljava/lang/ref/ReferenceQueue; 658
+Ljava/util/Locale;.ITALIAN:Ljava/util/Locale; 659
+Llibcore/icu/ICU; 659
+Ljava/util/Locale;.FRENCH:Ljava/util/Locale; 659
+Ljava/util/Locale;.JAPANESE:Ljava/util/Locale; 660
+Ljava/util/Locale;.KOREAN:Ljava/util/Locale; 660
+Ljava/util/Locale;.CHINESE:Ljava/util/Locale; 661
+Ljava/util/Locale;.KOREA:Ljava/util/Locale; 662
+Ljava/util/Locale;.ITALY:Ljava/util/Locale; 663
+Ljava/util/Locale;.CANADA_FRENCH:Ljava/util/Locale; 663
+Ljava/util/Locale;.FRANCE:Ljava/util/Locale; 663
+Ljava/util/Locale;.GERMANY:Ljava/util/Locale; 664
+Ljava/util/Locale;.JAPAN:Ljava/util/Locale; 665
+Lsun/util/locale/BaseLocale$Cache;.CACHE:Lsun/util/locale/BaseLocale$Cache;.map:Ljava/util/concurrent/ConcurrentMap;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.22:Ljava/util/concurrent/ConcurrentHashMap$Node;.val:Ljava/lang/Object;.referent:Ljava/lang/Object; 666
+Lsun/util/locale/BaseLocale$Cache;.CACHE:Lsun/util/locale/BaseLocale$Cache;.map:Ljava/util/concurrent/ConcurrentMap;.table:[Ljava/util/concurrent/ConcurrentHashMap$Node;.29:Ljava/util/concurrent/ConcurrentHashMap$Node;.val:Ljava/lang/Object;.referent:Ljava/lang/Object; 666
+Ljava/util/Locale;.GERMAN:Ljava/util/Locale; 667
+Ljava/util/Locale;.CANADA:Ljava/util/Locale; 668
+Ljava/util/Locale$Cache;.LOCALECACHE:Ljava/util/Locale$Cache;.map:Ljava/util/concurrent/ConcurrentMap; 669
+Ljava/util/Locale;.UK:Ljava/util/Locale; 670
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry; 671
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry; 672
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry; 673
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.head:Ljava/util/LinkedHashMap$Entry; 674
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry; 674
+Ljava/lang/Enum;.sharedConstantsCache:Llibcore/util/BasicLruCache;.map:Ljava/util/LinkedHashMap;.tail:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry;.before:Ljava/util/LinkedHashMap$Entry; 674
+Ljava/util/logging/LogRecord;.globalSequenceNumber:Ljava/util/concurrent/atomic/AtomicLong; 675
+Ljava/util/LinkedHashSet; 683
+Lorg/xmlpull/v1/XmlPullParser; 685
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.153:Ljava/lang/Long; 685
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.134:Ljava/lang/Long; 688
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.126:Ljava/lang/Long; 688
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.189:Ljava/lang/Long; 690
+Ljava/net/CookieHandler; 699
+Ljava/security/interfaces/RSAPrivateKey; 700
+Ljava/io/Serializable; 701
+Lsun/security/x509/PKIXExtensions;.OCSPNoCheck_Id:Lsun/security/util/ObjectIdentifier; 705
+Ljava/util/IdentityHashMap;.NULL_KEY:Ljava/lang/Object; 708
+[Ljava/security/cert/X509Certificate; 709
+Ljavax/net/ssl/SSLEngine; 710
+Ljava/util/Comparator; 717
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.157:Ljava/lang/Long; 718
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.179:Ljava/lang/Long; 718
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.178:Ljava/lang/Long; 718
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.208:Ljava/lang/Long; 719
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.152:Ljava/lang/Long; 720
+Ljava/lang/Integer; 720
+Ljava/util/zip/DataFormatException; 722
+Ljava/io/BufferedReader; 730
+Lsun/util/calendar/CalendarSystem;.calendars:Ljava/util/concurrent/ConcurrentMap; 735
+Lcom/android/okhttp/Protocol; 738
+Ljava/nio/HeapByteBuffer; 738
+Ljava/util/logging/LogManager;.manager:Ljava/util/logging/LogManager;.userContext:Ljava/util/logging/LogManager$LoggerContext; 740
+Lsun/nio/ch/SharedFileLockTable;.queue:Ljava/lang/ref/ReferenceQueue; 741
+Ljavax/net/ServerSocketFactory; 742
+Ljava/util/logging/FileHandler;.locks:Ljava/util/Set;.map:Ljava/util/HashMap; 743
+Ljava/nio/file/StandardOpenOption;.CREATE_NEW:Ljava/nio/file/StandardOpenOption; 743
+Ljava/util/logging/FileHandler; 743
+Ljava/nio/file/StandardOpenOption;.APPEND:Ljava/nio/file/StandardOpenOption; 744
+Ljava/nio/file/StandardOpenOption;.WRITE:Ljava/nio/file/StandardOpenOption; 745
+Ljava/nio/file/StandardOpenOption;.CREATE:Ljava/nio/file/StandardOpenOption; 746
+Ljava/nio/file/StandardOpenOption;.TRUNCATE_EXISTING:Ljava/nio/file/StandardOpenOption; 747
+Lcom/android/okhttp/Address; 748
+Ljava/net/SocketException; 749
+Ljava/net/Inet6AddressImpl; 754
+[J 756
+Ljava/lang/NoSuchFieldException; 757
+Ljava/lang/reflect/InvocationTargetException; 758
+Ljava/lang/Class$Caches;.genericInterfaces:Llibcore/util/BasicLruCache; 763
+Ljava/nio/Buffer; 763
+Ljava/lang/Character$UnicodeBlock;.CYRILLIC:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.CYRILLIC_EXTENDED_A:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.ARABIC_PRESENTATION_FORMS_A:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.ARABIC_SUPPLEMENT:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.ARABIC:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.ARABIC_PRESENTATION_FORMS_B:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.DEVANAGARI_EXTENDED:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.CYRILLIC_SUPPLEMENTARY:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.CYRILLIC_EXTENDED_B:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.THAI:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.BENGALI:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.DEVANAGARI:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.LATIN_EXTENDED_A:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.LATIN_EXTENDED_B:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.LATIN_1_SUPPLEMENT:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/lang/Character$UnicodeBlock;.BASIC_LATIN:Ljava/lang/Character$UnicodeBlock; 770
+Ljava/util/Map$Entry; 771
+Ljava/time/Instant; 772
+Ljava/time/Duration; 772
+Ljava/nio/file/NoSuchFileException; 775
+Ljava/net/MalformedURLException; 780
+Ljdk/internal/math/FloatingDecimal;.B2AC_NEGATIVE_ZERO:Ljdk/internal/math/FloatingDecimal$BinaryToASCIIConverter;.buffer:[C 784
+Ljava/util/concurrent/ExecutionException; 786
+Ljava/lang/StackStreamFactory; 791
+Ldalvik/system/BlockGuard; 792
+Ljava/util/Collections$EmptyList; 794
+Lcom/android/okhttp/internalandroidapi/HttpURLConnectionFactory$DnsAdapter; 798
+Ljava/net/Inet6Address; 799
+Ljava/util/concurrent/TimeoutException; 807
+Ljava/util/Locale;.CHINA:Ljava/util/Locale; 808
+Ljava/util/Locale;.TAIWAN:Ljava/util/Locale; 809
+Ljava/util/Collections$SynchronizedSet; 810
+Ljava/util/Collections$SynchronizedCollection; 811
+Landroid/system/StructLinger; 815
+Ljava/util/RegularEnumSet; 820
+[Ljava/lang/Enum; 820
+Ljava/util/EnumSet$SerializationProxy; 820
+Ljava/lang/Long$LongCache;.archivedCache:[Ljava/lang/Long;.147:Ljava/lang/Long; 822
diff --git a/build/boot/boot-image-profile.txt b/build/boot/boot-image-profile.txt
index 3bcd685db7..b2f916130f 100644
--- a/build/boot/boot-image-profile.txt
+++ b/build/boot/boot-image-profile.txt
@@ -883,10 +883,8 @@ HSPLcom/android/org/bouncycastle/crypto/engines/AESEngine;->subWord(I)I
 HSPLcom/android/org/bouncycastle/crypto/engines/AESEngine;->unpackBlock([BI)V
 HSPLcom/android/org/bouncycastle/crypto/engines/DESEngine;-><clinit>()V
 HSPLcom/android/org/bouncycastle/crypto/engines/DESEngine;-><init>()V
-HSPLcom/android/org/bouncycastle/crypto/engines/DESEngine;->generateWorkingKey(Z[B)[I
 HSPLcom/android/org/bouncycastle/crypto/generators/PKCS12ParametersGenerator;->generateDerivedKey(II)[B
 HSPLcom/android/org/bouncycastle/crypto/macs/HMac;-><clinit>()V
-HSPLcom/android/org/bouncycastle/crypto/macs/HMac;->getMacSize()I
 HSPLcom/android/org/bouncycastle/crypto/macs/HMac;->init(Lcom/android/org/bouncycastle/crypto/CipherParameters;)V
 HSPLcom/android/org/bouncycastle/crypto/macs/HMac;->update([BII)V
 HSPLcom/android/org/bouncycastle/crypto/modes/CBCBlockCipher;-><init>(Lcom/android/org/bouncycastle/crypto/BlockCipher;)V
@@ -904,7 +902,6 @@ HSPLcom/android/org/bouncycastle/crypto/params/AsymmetricKeyParameter;-><init>(Z
 HSPLcom/android/org/bouncycastle/crypto/params/DSAKeyParameters;-><init>(ZLcom/android/org/bouncycastle/crypto/params/DSAParameters;)V
 HSPLcom/android/org/bouncycastle/crypto/params/DSAParameters;-><init>(Ljava/math/BigInteger;Ljava/math/BigInteger;Ljava/math/BigInteger;)V
 HSPLcom/android/org/bouncycastle/crypto/params/DSAPublicKeyParameters;-><init>(Ljava/math/BigInteger;Lcom/android/org/bouncycastle/crypto/params/DSAParameters;)V
-HSPLcom/android/org/bouncycastle/crypto/params/KeyParameter;-><init>([B)V
 HSPLcom/android/org/bouncycastle/crypto/params/ParametersWithIV;-><init>(Lcom/android/org/bouncycastle/crypto/CipherParameters;[BII)V
 HSPLcom/android/org/bouncycastle/jcajce/provider/asymmetric/DSA$Mappings;->configure(Lcom/android/org/bouncycastle/jcajce/provider/config/ConfigurableProvider;)V
 HSPLcom/android/org/bouncycastle/jcajce/provider/asymmetric/dsa/BCDSAPublicKey;->getParams()Ljava/security/interfaces/DSAParams;
@@ -1101,6 +1098,7 @@ HSPLdalvik/system/VMRuntime;->getSdkVersion()I
 HSPLdalvik/system/VMRuntime;->getTargetSdkVersion()I
 HSPLdalvik/system/VMRuntime;->hiddenApiUsed(ILjava/lang/String;Ljava/lang/String;IZ)V
 HSPLdalvik/system/VMRuntime;->notifyNativeAllocation()V
+HSPLdalvik/system/VMRuntime;->onPostCleanup()V+]Ljava/util/Iterator;Ljava/util/ArrayList$Itr;]Ljava/util/List;Ljava/util/ArrayList;
 HSPLdalvik/system/VMRuntime;->registerNativeAllocation(I)V
 HSPLdalvik/system/VMRuntime;->registerNativeFree(I)V
 HSPLdalvik/system/VMRuntime;->runFinalization(J)V
@@ -1540,7 +1538,6 @@ HSPLjava/io/ObjectStreamClass$Caches;->-$$Nest$sfgetlocalDescsQueue()Ljava/lang/
 HSPLjava/io/ObjectStreamClass$Caches;->-$$Nest$sfgetreflectorsQueue()Ljava/lang/ref/ReferenceQueue;
 HSPLjava/io/ObjectStreamClass$ClassDataSlot;-><init>(Ljava/io/ObjectStreamClass;Z)V
 HSPLjava/io/ObjectStreamClass$EntryFuture;-><init>()V
-HSPLjava/io/ObjectStreamClass$EntryFuture;-><init>(Ljava/io/ObjectStreamClass$EntryFuture-IA;)V
 HSPLjava/io/ObjectStreamClass$EntryFuture;->get()Ljava/lang/Object;
 HSPLjava/io/ObjectStreamClass$EntryFuture;->getOwner()Ljava/lang/Thread;
 HSPLjava/io/ObjectStreamClass$EntryFuture;->set(Ljava/lang/Object;)Z
@@ -2043,6 +2040,7 @@ HSPLjava/lang/Daemons$HeapTaskDaemon;->interrupt(Ljava/lang/Thread;)V
 HSPLjava/lang/Daemons$HeapTaskDaemon;->runInternal()V
 HSPLjava/lang/Daemons$ReferenceQueueDaemon;->-$$Nest$fgetprogressCounter(Ljava/lang/Daemons$ReferenceQueueDaemon;)Ljava/util/concurrent/atomic/AtomicInteger;
 HSPLjava/lang/Daemons$ReferenceQueueDaemon;->-$$Nest$sfgetINSTANCE()Ljava/lang/Daemons$ReferenceQueueDaemon;
+HSPLjava/lang/Daemons$ReferenceQueueDaemon;->onRefQueueEmptyAfterGc()V
 HSPLjava/lang/Daemons$ReferenceQueueDaemon;->runInternal()V
 HSPLjava/lang/Daemons;->-$$Nest$sfgetpostZygoteFork()Z
 HSPLjava/lang/Daemons;->-$$Nest$sfgetzygoteStartLatch()Ljava/util/concurrent/CountDownLatch;
@@ -2128,10 +2126,12 @@ HSPLjava/lang/Integer;->byteValue()B
 HSPLjava/lang/Integer;->compare(II)I
 HSPLjava/lang/Integer;->compareTo(Ljava/lang/Integer;)I
 HSPLjava/lang/Integer;->compareTo(Ljava/lang/Object;)I
+HSPLjava/lang/Integer;->compress(II)I
 HSPLjava/lang/Integer;->decode(Ljava/lang/String;)Ljava/lang/Integer;
 HSPLjava/lang/Integer;->divideUnsigned(II)I
 HSPLjava/lang/Integer;->doubleValue()D
 HSPLjava/lang/Integer;->equals(Ljava/lang/Object;)Z
+HSPLjava/lang/Integer;->expand(II)I
 HSPLjava/lang/Integer;->floatValue()F
 HSPLjava/lang/Integer;->formatUnsignedInt(II[BII)V
 HSPLjava/lang/Integer;->getChars(II[B)I
@@ -2149,8 +2149,10 @@ HSPLjava/lang/Integer;->max(II)I
 HSPLjava/lang/Integer;->min(II)I
 HSPLjava/lang/Integer;->numberOfLeadingZeros(I)I
 HSPLjava/lang/Integer;->numberOfTrailingZeros(I)I
+HSPLjava/lang/Integer;->parallelSuffix(I)I
 HSPLjava/lang/Integer;->parseInt(Ljava/lang/String;)I
 HSPLjava/lang/Integer;->parseInt(Ljava/lang/String;I)I
+HSPLjava/lang/Integer;->remainderUnsigned(II)I
 HSPLjava/lang/Integer;->reverse(I)I
 HSPLjava/lang/Integer;->reverseBytes(I)I
 HSPLjava/lang/Integer;->rotateLeft(II)I
@@ -2178,10 +2180,12 @@ HSPLjava/lang/Long;->compare(JJ)I
 HSPLjava/lang/Long;->compareTo(Ljava/lang/Long;)I
 HSPLjava/lang/Long;->compareTo(Ljava/lang/Object;)I
 HSPLjava/lang/Long;->compareUnsigned(JJ)I
+HSPLjava/lang/Long;->compress(JJ)J
 HSPLjava/lang/Long;->decode(Ljava/lang/String;)Ljava/lang/Long;
 HSPLjava/lang/Long;->divideUnsigned(JJ)J
 HSPLjava/lang/Long;->doubleValue()D
 HSPLjava/lang/Long;->equals(Ljava/lang/Object;)Z
+HSPLjava/lang/Long;->expand(JJ)J
 HSPLjava/lang/Long;->formatUnsignedLong0(JI[BII)V
 HSPLjava/lang/Long;->getChars(JI[B)I
 HSPLjava/lang/Long;->getChars(JI[C)I
@@ -2195,9 +2199,11 @@ HSPLjava/lang/Long;->longValue()J
 HSPLjava/lang/Long;->lowestOneBit(J)J
 HSPLjava/lang/Long;->numberOfLeadingZeros(J)I
 HSPLjava/lang/Long;->numberOfTrailingZeros(J)I
+HSPLjava/lang/Long;->parallelSuffix(J)J
 HSPLjava/lang/Long;->parseLong(Ljava/lang/CharSequence;III)J
 HSPLjava/lang/Long;->parseLong(Ljava/lang/String;)J
 HSPLjava/lang/Long;->parseLong(Ljava/lang/String;I)J
+HSPLjava/lang/Long;->remainderUnsigned(JJ)J
 HSPLjava/lang/Long;->reverse(J)J
 HSPLjava/lang/Long;->reverseBytes(J)J
 HSPLjava/lang/Long;->rotateLeft(JI)J
@@ -2251,6 +2257,7 @@ HSPLjava/lang/Math;->round(D)J
 HSPLjava/lang/Math;->round(F)I
 HSPLjava/lang/Math;->scalb(FI)F
 HSPLjava/lang/Math;->setRandomSeedInternal(J)V
+HSPLjava/lang/Math;->signum(D)D
 HSPLjava/lang/Math;->signum(F)F
 HSPLjava/lang/Math;->subtractExact(JJ)J
 HSPLjava/lang/Math;->toDegrees(D)D
@@ -2346,12 +2353,12 @@ HSPLjava/lang/String;->copyValueOf([C)Ljava/lang/String;
 HSPLjava/lang/String;->endsWith(Ljava/lang/String;)Z
 HSPLjava/lang/String;->equals(Ljava/lang/Object;)Z
 HSPLjava/lang/String;->equalsIgnoreCase(Ljava/lang/String;)Z
+HSPLjava/lang/String;->fillBytes([BIB)V
 HSPLjava/lang/String;->format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
 HSPLjava/lang/String;->format(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
 HSPLjava/lang/String;->getBytes()[B
 HSPLjava/lang/String;->getBytes(Ljava/lang/String;)[B
 HSPLjava/lang/String;->getBytes(Ljava/nio/charset/Charset;)[B
-HSPLjava/lang/String;->getBytes([BIB)V
 HSPLjava/lang/String;->getChars(II[CI)V
 HSPLjava/lang/String;->getChars([CI)V
 HSPLjava/lang/String;->hashCode()I
@@ -2618,7 +2625,6 @@ HSPLjava/lang/ThreadLocal;->set(Ljava/lang/Object;)V
 HSPLjava/lang/ThreadLocal;->setInitialValue()Ljava/lang/Object;
 HSPLjava/lang/ThreadLocal;->withInitial(Ljava/util/function/Supplier;)Ljava/lang/ThreadLocal;
 HSPLjava/lang/Throwable$PrintStreamOrWriter;-><init>()V
-HSPLjava/lang/Throwable$PrintStreamOrWriter;-><init>(Ljava/lang/Throwable$PrintStreamOrWriter-IA;)V
 HSPLjava/lang/Throwable$WrappedPrintStream;-><init>(Ljava/io/PrintStream;)V
 HSPLjava/lang/Throwable$WrappedPrintStream;->lock()Ljava/lang/Object;
 HSPLjava/lang/Throwable$WrappedPrintStream;->println(Ljava/lang/Object;)V
@@ -2688,15 +2694,6 @@ HSPLjava/lang/invoke/MethodHandles$Lookup;->findFieldOfType(Ljava/lang/Class;Lja
 HSPLjava/lang/invoke/MethodHandles$Lookup;->findVarHandle(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;
 HSPLjava/lang/invoke/MethodHandles$Lookup;->unreflect(Ljava/lang/reflect/Method;)Ljava/lang/invoke/MethodHandle;
 HSPLjava/lang/invoke/MethodHandles;->lookup()Ljava/lang/invoke/MethodHandles$Lookup;
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry;-><init>(Ljava/lang/Object;)V
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry;-><init>(Ljava/lang/Object;Ljava/lang/ref/ReferenceQueue;)V
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry;->equals(Ljava/lang/Object;)Z
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry;->hashCode()I
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet;->add(Ljava/lang/Object;)Ljava/lang/Object;
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet;->expungeStaleElements()V
-HSPLjava/lang/invoke/MethodType$ConcurrentWeakInternSet;->get(Ljava/lang/Object;)Ljava/lang/Object;
-HSPLjava/lang/invoke/MethodType;-><init>(Ljava/lang/Class;[Ljava/lang/Class;Z)V
-HSPLjava/lang/invoke/MethodType;-><init>([Ljava/lang/Class;Ljava/lang/Class;)V
 HSPLjava/lang/invoke/MethodType;->checkPtype(Ljava/lang/Class;)V
 HSPLjava/lang/invoke/MethodType;->checkPtypes([Ljava/lang/Class;)I
 HSPLjava/lang/invoke/MethodType;->checkRtype(Ljava/lang/Class;)V
@@ -2732,7 +2729,7 @@ HSPLjava/lang/ref/Cleaner$1;->apply(Ljava/lang/Object;)Ljava/lang/Object;
 HSPLjava/lang/ref/Cleaner$1;->apply(Ljava/lang/ref/Cleaner;)Ljdk/internal/ref/CleanerImpl;
 HSPLjava/lang/ref/Cleaner;->register(Ljava/lang/Object;Ljava/lang/Runnable;)Ljava/lang/ref/Cleaner$Cleanable;
 HSPLjava/lang/ref/FinalizerReference$Sentinel;-><init>()V
-HSPLjava/lang/ref/FinalizerReference$Sentinel;-><init>(Ljava/lang/ref/FinalizerReference$Sentinel-IA;)V
+SPLjava/lang/ref/FinalizerReference$Sentinel;-><init>(Ljava/lang/ref/FinalizerReference-IA;)V
 HSPLjava/lang/ref/FinalizerReference$Sentinel;->awaitFinalization(J)V
 HSPLjava/lang/ref/FinalizerReference$Sentinel;->finalize()V
 HSPLjava/lang/ref/FinalizerReference;-><init>(Ljava/lang/Object;Ljava/lang/ref/ReferenceQueue;)V
@@ -3176,7 +3173,6 @@ HSPLjava/net/Inet4Address;->isLoopbackAddress()Z
 HSPLjava/net/Inet4Address;->isMulticastAddress()Z
 HSPLjava/net/Inet4Address;->numericToTextFormat([B)Ljava/lang/String;
 HSPLjava/net/Inet6Address$Inet6AddressHolder;-><init>(Ljava/net/Inet6Address;)V
-HSPLjava/net/Inet6Address$Inet6AddressHolder;-><init>(Ljava/net/Inet6Address;Ljava/net/Inet6Address$Inet6AddressHolder-IA;)V
 HSPLjava/net/Inet6Address$Inet6AddressHolder;->equals(Ljava/lang/Object;)Z
 HSPLjava/net/Inet6Address$Inet6AddressHolder;->hashCode()I
 HSPLjava/net/Inet6Address$Inet6AddressHolder;->init([BI)V
@@ -3493,50 +3489,7 @@ HSPLjava/net/URLStreamHandler;->parseURL(Ljava/net/URL;Ljava/lang/String;II)V
 HSPLjava/net/URLStreamHandler;->setURL(Ljava/net/URL;Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
 HSPLjava/net/URLStreamHandler;->toExternalForm(Ljava/net/URL;)Ljava/lang/String;
 HSPLjava/net/UnknownHostException;-><init>(Ljava/lang/String;)V
-HSPLjava/nio/Bits;->char0(C)B
-HSPLjava/nio/Bits;->char1(C)B
-HSPLjava/nio/Bits;->getFloat(Ljava/nio/ByteBuffer;IZ)F
-HSPLjava/nio/Bits;->getFloatL(Ljava/nio/ByteBuffer;I)F
-HSPLjava/nio/Bits;->getInt(Ljava/nio/ByteBuffer;IZ)I
-HSPLjava/nio/Bits;->getIntB(Ljava/nio/ByteBuffer;I)I
-HSPLjava/nio/Bits;->getIntL(Ljava/nio/ByteBuffer;I)I
-HSPLjava/nio/Bits;->getLong(Ljava/nio/ByteBuffer;IZ)J
-HSPLjava/nio/Bits;->getLongB(Ljava/nio/ByteBuffer;I)J
-HSPLjava/nio/Bits;->getLongL(Ljava/nio/ByteBuffer;I)J
-HSPLjava/nio/Bits;->getShort(Ljava/nio/ByteBuffer;IZ)S
-HSPLjava/nio/Bits;->getShortB(Ljava/nio/ByteBuffer;I)S
-HSPLjava/nio/Bits;->getShortL(Ljava/nio/ByteBuffer;I)S
-HSPLjava/nio/Bits;->int0(I)B
-HSPLjava/nio/Bits;->int1(I)B
-HSPLjava/nio/Bits;->int2(I)B
-HSPLjava/nio/Bits;->int3(I)B
-HSPLjava/nio/Bits;->long0(J)B
-HSPLjava/nio/Bits;->long1(J)B
-HSPLjava/nio/Bits;->long2(J)B
-HSPLjava/nio/Bits;->long3(J)B
-HSPLjava/nio/Bits;->long4(J)B
-HSPLjava/nio/Bits;->long5(J)B
-HSPLjava/nio/Bits;->long6(J)B
-HSPLjava/nio/Bits;->long7(J)B
-HSPLjava/nio/Bits;->makeInt(BBBB)I
-HSPLjava/nio/Bits;->makeLong(BBBBBBBB)J
-HSPLjava/nio/Bits;->makeShort(BB)S
 HSPLjava/nio/Bits;->pageSize()I
-HSPLjava/nio/Bits;->putChar(Ljava/nio/ByteBuffer;ICZ)V
-HSPLjava/nio/Bits;->putCharB(Ljava/nio/ByteBuffer;IC)V
-HSPLjava/nio/Bits;->putCharL(Ljava/nio/ByteBuffer;IC)V
-HSPLjava/nio/Bits;->putFloat(Ljava/nio/ByteBuffer;IFZ)V
-HSPLjava/nio/Bits;->putInt(Ljava/nio/ByteBuffer;IIZ)V
-HSPLjava/nio/Bits;->putIntB(Ljava/nio/ByteBuffer;II)V
-HSPLjava/nio/Bits;->putIntL(Ljava/nio/ByteBuffer;II)V
-HSPLjava/nio/Bits;->putLong(Ljava/nio/ByteBuffer;IJZ)V
-HSPLjava/nio/Bits;->putLongB(Ljava/nio/ByteBuffer;IJ)V
-HSPLjava/nio/Bits;->putLongL(Ljava/nio/ByteBuffer;IJ)V
-HSPLjava/nio/Bits;->putShort(Ljava/nio/ByteBuffer;ISZ)V
-HSPLjava/nio/Bits;->putShortB(Ljava/nio/ByteBuffer;IS)V
-HSPLjava/nio/Bits;->putShortL(Ljava/nio/ByteBuffer;IS)V
-HSPLjava/nio/Bits;->short0(S)B
-HSPLjava/nio/Bits;->short1(S)B
 HSPLjava/nio/Buffer;-><init>(IIIII)V
 HSPLjava/nio/Buffer;->capacity()I
 HSPLjava/nio/Buffer;->checkBounds(III)V
@@ -3712,12 +3665,16 @@ HSPLjava/nio/HeapByteBuffer;->get(I)B
 HSPLjava/nio/HeapByteBuffer;->get([BII)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->getFloat()F
 HSPLjava/nio/HeapByteBuffer;->getFloat(I)F
+HSPLjava/nio/HeapByteBuffer;->getFloatUnchecked(I)F
 HSPLjava/nio/HeapByteBuffer;->getInt()I
 HSPLjava/nio/HeapByteBuffer;->getInt(I)I
+HSPLjava/nio/HeapByteBuffer;->getIntUnchecked(I)I
 HSPLjava/nio/HeapByteBuffer;->getLong()J
 HSPLjava/nio/HeapByteBuffer;->getLong(I)J
+HSPLjava/nio/HeapByteBuffer;->getLongUnchecked(I)J
 HSPLjava/nio/HeapByteBuffer;->getShort()S
 HSPLjava/nio/HeapByteBuffer;->getShort(I)S
+HSPLjava/nio/HeapByteBuffer;->getShortUnchecked(I)S
 HSPLjava/nio/HeapByteBuffer;->getUnchecked(I[III)V
 HSPLjava/nio/HeapByteBuffer;->getUnchecked(I[SII)V
 HSPLjava/nio/HeapByteBuffer;->isDirect()Z
@@ -3728,13 +3685,19 @@ HSPLjava/nio/HeapByteBuffer;->put(IB)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->put(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->put([BII)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->putChar(C)Ljava/nio/ByteBuffer;
+HSPLjava/nio/HeapByteBuffer;->putCharUnchecked(IC)V
+HSPLjava/nio/HeapByteBuffer;->putDoubleUnchecked(ID)V
 HSPLjava/nio/HeapByteBuffer;->putFloat(F)Ljava/nio/ByteBuffer;
+HSPLjava/nio/HeapByteBuffer;->putFloatUnchecked(IF)V
 HSPLjava/nio/HeapByteBuffer;->putInt(I)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->putInt(II)Ljava/nio/ByteBuffer;
+HSPLjava/nio/HeapByteBuffer;->putIntUnchecked(II)V
 HSPLjava/nio/HeapByteBuffer;->putLong(IJ)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->putLong(J)Ljava/nio/ByteBuffer;
+HSPLjava/nio/HeapByteBuffer;->putLongUnchecked(IJ)V
 HSPLjava/nio/HeapByteBuffer;->putShort(IS)Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->putShort(S)Ljava/nio/ByteBuffer;
+HSPLjava/nio/HeapByteBuffer;->putShortUnchecked(IS)V
 HSPLjava/nio/HeapByteBuffer;->slice()Ljava/nio/ByteBuffer;
 HSPLjava/nio/HeapByteBuffer;->throwIfReadOnly()V
 HSPLjava/nio/HeapCharBuffer;-><init>(II)V
@@ -4021,7 +3984,7 @@ HSPLjava/security/Provider$Service;->-$$Nest$fputtype(Ljava/security/Provider$Se
 HSPLjava/security/Provider$Service;->-$$Nest$maddAlias(Ljava/security/Provider$Service;Ljava/lang/String;)V
 HSPLjava/security/Provider$Service;->-$$Nest$misValid(Ljava/security/Provider$Service;)Z
 HSPLjava/security/Provider$Service;-><init>(Ljava/security/Provider;)V
-HSPLjava/security/Provider$Service;-><init>(Ljava/security/Provider;Ljava/security/Provider$Service-IA;)V
+SPLjava/security/Provider$Service;-><init>(Ljava/security/Provider;Ljava/security/Provider-IA;)V
 HSPLjava/security/Provider$Service;->addAlias(Ljava/lang/String;)V
 HSPLjava/security/Provider$Service;->addAttribute(Ljava/lang/String;Ljava/lang/String;)V
 HSPLjava/security/Provider$Service;->getAlgorithm()Ljava/lang/String;
@@ -4041,7 +4004,7 @@ HSPLjava/security/Provider$Service;->supportsKeyClass(Ljava/security/Key;)Z
 HSPLjava/security/Provider$Service;->supportsKeyFormat(Ljava/security/Key;)Z
 HSPLjava/security/Provider$Service;->supportsParameter(Ljava/lang/Object;)Z
 HSPLjava/security/Provider$ServiceKey;-><init>(Ljava/lang/String;Ljava/lang/String;Z)V
-HSPLjava/security/Provider$ServiceKey;-><init>(Ljava/lang/String;Ljava/lang/String;ZLjava/security/Provider$ServiceKey-IA;)V
+HSPLjava/security/Provider$ServiceKey;-><init>(Ljava/lang/String;Ljava/lang/String;ZLjava/security/Provider-IA;)V
 HSPLjava/security/Provider$ServiceKey;->equals(Ljava/lang/Object;)Z
 HSPLjava/security/Provider$ServiceKey;->hashCode()I
 HSPLjava/security/Provider$ServiceKey;->matches(Ljava/lang/String;Ljava/lang/String;)Z
@@ -4773,7 +4736,7 @@ HSPLjava/util/AbstractCollection;->toArray()[Ljava/lang/Object;
 HSPLjava/util/AbstractCollection;->toArray([Ljava/lang/Object;)[Ljava/lang/Object;
 HSPLjava/util/AbstractCollection;->toString()Ljava/lang/String;
 HSPLjava/util/AbstractList$Itr;-><init>(Ljava/util/AbstractList;)V
-HSPLjava/util/AbstractList$Itr;-><init>(Ljava/util/AbstractList;Ljava/util/AbstractList$Itr-IA;)V
+HSPLjava/util/AbstractList$Itr;-><init>(Ljava/util/AbstractList;Ljava/util/AbstractList-IA;)V
 HSPLjava/util/AbstractList$Itr;->checkForComodification()V
 HSPLjava/util/AbstractList$Itr;->hasNext()Z
 HSPLjava/util/AbstractList$Itr;->next()Ljava/lang/Object;
@@ -5006,6 +4969,7 @@ HSPLjava/util/Arrays$ArrayList;->spliterator()Ljava/util/Spliterator;
 HSPLjava/util/Arrays$ArrayList;->toArray()[Ljava/lang/Object;
 HSPLjava/util/Arrays$ArrayList;->toArray([Ljava/lang/Object;)[Ljava/lang/Object;
 HSPLjava/util/Arrays$ArrayList;->toArrayPreserveComponentType()[Ljava/lang/Object;
+HSPLjava/util/Arrays$ArrayList;->toArrayWithoutComponentType()[Ljava/lang/Object;
 HSPLjava/util/Arrays;->asList([Ljava/lang/Object;)Ljava/util/List;
 HSPLjava/util/Arrays;->binarySearch([CC)I
 HSPLjava/util/Arrays;->binarySearch([II)I
@@ -5167,7 +5131,7 @@ HSPLjava/util/Calendar;->setTimeZone(Ljava/util/TimeZone;)V
 HSPLjava/util/Calendar;->setWeekCountData(Ljava/util/Locale;)V
 HSPLjava/util/Calendar;->setZoneShared(Z)V
 HSPLjava/util/Calendar;->updateTime()V
-HSPLjava/util/Collection;->removeIf(Ljava/util/function/Predicate;)Z+]Ljava/util/Collection;megamorphic_types]Ljava/util/Iterator;megamorphic_types]Ljava/util/function/Predicate;Lcom/android/internal/telephony/data/DataNetworkController$$ExternalSyntheticLambda32;,Lcom/android/internal/telephony/data/DataNetworkController$$ExternalSyntheticLambda43;
+HSPLjava/util/Collection;->removeIf(Ljava/util/function/Predicate;)Z+]Ljava/util/Collection;megamorphic_types]Ljava/util/Iterator;megamorphic_types]Ljava/util/function/Predicate;Lcom/android/internal/telephony/data/DataNetworkController$$ExternalSyntheticLambda32;,Lcom/android/internal/telephony/data/DataNetworkController$$ExternalSyntheticLambda42;
 HSPLjava/util/Collection;->spliterator()Ljava/util/Spliterator;
 HSPLjava/util/Collection;->stream()Ljava/util/stream/Stream;+]Ljava/util/Collection;megamorphic_types
 HSPLjava/util/Collections$1;-><init>(Ljava/lang/Object;)V
@@ -5805,7 +5769,6 @@ HSPLjava/util/IdentityHashMap$IdentityHashMapIterator;->nextIndex()I
 HSPLjava/util/IdentityHashMap$KeyIterator;-><init>(Ljava/util/IdentityHashMap;)V
 HSPLjava/util/IdentityHashMap$KeyIterator;->next()Ljava/lang/Object;
 HSPLjava/util/IdentityHashMap$KeySet;-><init>(Ljava/util/IdentityHashMap;)V
-HSPLjava/util/IdentityHashMap$KeySet;-><init>(Ljava/util/IdentityHashMap;Ljava/util/IdentityHashMap$KeySet-IA;)V
 HSPLjava/util/IdentityHashMap$KeySet;->iterator()Ljava/util/Iterator;
 HSPLjava/util/IdentityHashMap$KeySet;->size()I
 HSPLjava/util/IdentityHashMap$ValueIterator;-><init>(Ljava/util/IdentityHashMap;)V
@@ -5848,7 +5811,6 @@ HSPLjava/util/ImmutableCollections$ListItr;-><init>(Ljava/util/List;I)V
 HSPLjava/util/ImmutableCollections$ListItr;->hasNext()Z
 HSPLjava/util/ImmutableCollections$ListItr;->next()Ljava/lang/Object;
 HSPLjava/util/ImmutableCollections$ListN;-><init>([Ljava/lang/Object;Z)V
-HSPLjava/util/ImmutableCollections$ListN;-><init>([Ljava/lang/Object;ZLjava/util/ImmutableCollections$ListN-IA;)V
 HSPLjava/util/ImmutableCollections$ListN;->get(I)Ljava/lang/Object;
 HSPLjava/util/ImmutableCollections$ListN;->size()I
 HSPLjava/util/ImmutableCollections$Map1;-><init>(Ljava/lang/Object;Ljava/lang/Object;)V
@@ -5857,7 +5819,7 @@ HSPLjava/util/ImmutableCollections$MapN;-><init>([Ljava/lang/Object;)V
 HSPLjava/util/ImmutableCollections$MapN;->containsKey(Ljava/lang/Object;)Z
 HSPLjava/util/ImmutableCollections$MapN;->get(Ljava/lang/Object;)Ljava/lang/Object;
 HSPLjava/util/ImmutableCollections$MapN;->probe(Ljava/lang/Object;)I
-HSPLjava/util/ImmutableCollections$Set12;-><init>(Ljava/lang/Object;Ljava/lang/Object;)V+]Ljava/lang/Object;missing_types
+HSPLjava/util/ImmutableCollections$Set12;-><init>(Ljava/lang/Object;Ljava/lang/Object;)V
 HSPLjava/util/ImmutableCollections$SetN;-><init>([Ljava/lang/Object;)V
 HSPLjava/util/ImmutableCollections$SetN;->contains(Ljava/lang/Object;)Z
 HSPLjava/util/ImmutableCollections$SetN;->probe(Ljava/lang/Object;)I
@@ -5991,8 +5953,12 @@ HSPLjava/util/List;->of()Ljava/util/List;
 HSPLjava/util/List;->of(Ljava/lang/Object;)Ljava/util/List;
 HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
 HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
+HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
+HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
+HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
+HSPLjava/util/List;->of(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List;
 HSPLjava/util/List;->of([Ljava/lang/Object;)Ljava/util/List;
-HSPLjava/util/List;->sort(Ljava/util/Comparator;)V+]Ljava/util/List;Ljava/util/ArrayList$SubList;,Ljava/util/LinkedList;]Ljava/util/ListIterator;Ljava/util/ArrayList$SubList$1;,Ljava/util/LinkedList$ListItr;
+HSPLjava/util/List;->sort(Ljava/util/Comparator;)V+]Ljava/util/List;Ljava/util/ArrayList$SubList;,Ljava/util/LinkedList;]Ljava/util/ListIterator;Ljava/util/AbstractList$ListItr;,Ljava/util/ArrayList$SubList$1;,Ljava/util/LinkedList$ListItr;
 HSPLjava/util/List;->spliterator()Ljava/util/Spliterator;
 HSPLjava/util/Locale$Builder;-><init>()V
 HSPLjava/util/Locale$Builder;->build()Ljava/util/Locale;
@@ -6006,7 +5972,6 @@ HSPLjava/util/Locale$Cache;->createObject(Ljava/lang/Object;)Ljava/util/Locale;
 HSPLjava/util/Locale$LocaleKey;->-$$Nest$fgetbase(Ljava/util/Locale$LocaleKey;)Lsun/util/locale/BaseLocale;
 HSPLjava/util/Locale$LocaleKey;->-$$Nest$fgetexts(Ljava/util/Locale$LocaleKey;)Lsun/util/locale/LocaleExtensions;
 HSPLjava/util/Locale$LocaleKey;-><init>(Lsun/util/locale/BaseLocale;Lsun/util/locale/LocaleExtensions;)V
-HSPLjava/util/Locale$LocaleKey;-><init>(Lsun/util/locale/BaseLocale;Lsun/util/locale/LocaleExtensions;Ljava/util/Locale$LocaleKey-IA;)V
 HSPLjava/util/Locale$LocaleKey;->equals(Ljava/lang/Object;)Z
 HSPLjava/util/Locale$LocaleKey;->hashCode()I
 HSPLjava/util/Locale;-><init>(Ljava/lang/String;)V
@@ -6251,7 +6216,7 @@ HSPLjava/util/SimpleTimeZone;->getOffset(J)I
 HSPLjava/util/SimpleTimeZone;->getOffsets(J[I)I
 HSPLjava/util/SimpleTimeZone;->getRawOffset()I
 HSPLjava/util/SimpleTimeZone;->hasSameRules(Ljava/util/TimeZone;)Z
-HSPLjava/util/Spliterator$OfInt;->forEachRemaining(Ljava/util/function/Consumer;)V+]Ljava/util/Spliterator$OfInt;Ljava/lang/StringUTF16$CodePointsSpliteratorForString;,Ljava/util/Spliterators$EmptySpliterator$OfInt;,Ljava/util/Spliterators$IntArraySpliterator;,Ljava/util/stream/Streams$RangeIntSpliterator;
+HSPLjava/util/Spliterator$OfInt;->forEachRemaining(Ljava/util/function/Consumer;)V+]Ljava/util/Spliterator$OfInt;Ljava/lang/StringUTF16$CodePointsSpliteratorForString;,Ljava/util/Spliterators$IntArraySpliterator;,Ljava/util/stream/Streams$RangeIntSpliterator;
 HSPLjava/util/Spliterator;->getExactSizeIfKnown()J+]Ljava/util/Spliterator;megamorphic_types
 HSPLjava/util/Spliterators$ArraySpliterator;-><init>([Ljava/lang/Object;I)V
 HSPLjava/util/Spliterators$ArraySpliterator;-><init>([Ljava/lang/Object;III)V
@@ -6559,10 +6524,9 @@ HSPLjava/util/WeakHashMap$HashIterator;-><init>(Ljava/util/WeakHashMap;)V
 HSPLjava/util/WeakHashMap$HashIterator;->hasNext()Z
 HSPLjava/util/WeakHashMap$HashIterator;->nextEntry()Ljava/util/WeakHashMap$Entry;
 HSPLjava/util/WeakHashMap$KeyIterator;-><init>(Ljava/util/WeakHashMap;)V
-HSPLjava/util/WeakHashMap$KeyIterator;-><init>(Ljava/util/WeakHashMap;Ljava/util/WeakHashMap$KeyIterator-IA;)V
+HSPLjava/util/WeakHashMap$KeyIterator;-><init>(Ljava/util/WeakHashMap;Ljava/util/WeakHashMap-IA;)V
 HSPLjava/util/WeakHashMap$KeyIterator;->next()Ljava/lang/Object;
 HSPLjava/util/WeakHashMap$KeySet;-><init>(Ljava/util/WeakHashMap;)V
-HSPLjava/util/WeakHashMap$KeySet;-><init>(Ljava/util/WeakHashMap;Ljava/util/WeakHashMap$KeySet-IA;)V
 HSPLjava/util/WeakHashMap$KeySet;->iterator()Ljava/util/Iterator;
 HSPLjava/util/WeakHashMap$KeySet;->size()I
 HSPLjava/util/WeakHashMap$ValueIterator;-><init>(Ljava/util/WeakHashMap;)V
@@ -6855,8 +6819,6 @@ HSPLjava/util/concurrent/Executors$DelegatedScheduledExecutorService;->schedule(
 HSPLjava/util/concurrent/Executors$DelegatedScheduledExecutorService;->schedule(Ljava/util/concurrent/Callable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;
 HSPLjava/util/concurrent/Executors$DelegatedScheduledExecutorService;->scheduleAtFixedRate(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;
 HSPLjava/util/concurrent/Executors$DelegatedScheduledExecutorService;->scheduleWithFixedDelay(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;
-HSPLjava/util/concurrent/Executors$FinalizableDelegatedExecutorService;-><init>(Ljava/util/concurrent/ExecutorService;)V
-HSPLjava/util/concurrent/Executors$FinalizableDelegatedExecutorService;->finalize()V
 HSPLjava/util/concurrent/Executors$RunnableAdapter;-><init>(Ljava/lang/Runnable;Ljava/lang/Object;)V
 HSPLjava/util/concurrent/Executors$RunnableAdapter;->call()Ljava/lang/Object;
 HSPLjava/util/concurrent/Executors;->callable(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;
@@ -7029,19 +6991,6 @@ HSPLjava/util/concurrent/Semaphore;->release(I)V
 HSPLjava/util/concurrent/Semaphore;->tryAcquire()Z
 HSPLjava/util/concurrent/Semaphore;->tryAcquire(IJLjava/util/concurrent/TimeUnit;)Z
 HSPLjava/util/concurrent/Semaphore;->tryAcquire(JLjava/util/concurrent/TimeUnit;)Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;-><init>(Ljava/lang/Object;)V
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->block()Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->casNext(Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;)Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->forgetWaiter()V
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->isCancelled()Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->isReleasable()Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack$SNode;->tryMatch(Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;)Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;-><init>()V
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;->casHead(Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;)Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;->clean(Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;)V
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;->isFulfilling(I)Z
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;->snode(Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;Ljava/lang/Object;Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;I)Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;
-HSPLjava/util/concurrent/SynchronousQueue$TransferStack;->transfer(Ljava/lang/Object;ZJ)Ljava/lang/Object;
 HSPLjava/util/concurrent/SynchronousQueue$Transferer;-><init>()V
 HSPLjava/util/concurrent/SynchronousQueue;-><init>()V
 HSPLjava/util/concurrent/SynchronousQueue;-><init>(Z)V
@@ -7242,6 +7191,7 @@ HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->doSi
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->enableWait(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionNode;)I
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->hasWaiters()Z
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->isOwnedBy(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer;)Z
+HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->newConditionNode()Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionNode;
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->signal()V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->signalAll()V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;->unlinkCancelledWaiters(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionNode;)V
@@ -7252,6 +7202,7 @@ HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;->getAndUnsetStat
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;->setPrevRelaxed(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;->setStatusRelaxed(I)V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer$SharedNode;-><init>()V
+HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->-$$Nest$mtryInitializeHead(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer;)Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->-$$Nest$sfgetU()Ljdk/internal/misc/Unsafe;
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;-><init>()V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->acquire(I)V
@@ -7263,7 +7214,7 @@ HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->apparentlyFirstQueue
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->casTail(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)Z
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->cleanQueue()V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->compareAndSetState(II)Z
-HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->enqueue(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)V
+HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->enqueue(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionNode;)V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->getFirstQueuedThread()Ljava/lang/Thread;
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->getState()I
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->hasQueuedPredecessors()Z
@@ -7278,7 +7229,7 @@ HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->signalNext(Ljava/uti
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->signalNextIfShared(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;)V
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->tryAcquireNanos(IJ)Z
 HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->tryAcquireSharedNanos(IJ)Z
-HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->tryInitializeHead()V
+HSPLjava/util/concurrent/locks/AbstractQueuedSynchronizer;->tryInitializeHead()Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node;
 HSPLjava/util/concurrent/locks/LockSupport;->park()V
 HSPLjava/util/concurrent/locks/LockSupport;->park(Ljava/lang/Object;)V
 HSPLjava/util/concurrent/locks/LockSupport;->parkNanos(J)V
@@ -7418,7 +7369,6 @@ HSPLjava/util/logging/ErrorManager;-><init>()V
 HSPLjava/util/logging/FileHandler$1;-><init>(Ljava/util/logging/FileHandler;)V
 HSPLjava/util/logging/FileHandler$1;->run()Ljava/lang/Object;
 HSPLjava/util/logging/FileHandler$InitializationErrorManager;-><init>()V
-HSPLjava/util/logging/FileHandler$InitializationErrorManager;-><init>(Ljava/util/logging/FileHandler$InitializationErrorManager-IA;)V
 HSPLjava/util/logging/FileHandler$MeteredStream;-><init>(Ljava/util/logging/FileHandler;Ljava/io/OutputStream;I)V
 HSPLjava/util/logging/FileHandler$MeteredStream;->close()V
 HSPLjava/util/logging/FileHandler$MeteredStream;->flush()V
@@ -7973,7 +7923,6 @@ HSPLjava/util/zip/CheckedInputStream;-><init>(Ljava/io/InputStream;Ljava/util/zi
 HSPLjava/util/zip/CheckedInputStream;->read()I
 HSPLjava/util/zip/CheckedInputStream;->read([BII)I
 HSPLjava/util/zip/Deflater$DeflaterZStreamRef;-><init>(Ljava/util/zip/Deflater;J)V
-HSPLjava/util/zip/Deflater$DeflaterZStreamRef;-><init>(Ljava/util/zip/Deflater;JLjava/util/zip/Deflater$DeflaterZStreamRef-IA;)V
 HSPLjava/util/zip/Deflater$DeflaterZStreamRef;->address()J
 HSPLjava/util/zip/Deflater$DeflaterZStreamRef;->clean()V
 HSPLjava/util/zip/Deflater$DeflaterZStreamRef;->run()V
@@ -8076,7 +8025,7 @@ HSPLjava/util/zip/ZipFile$CleanableResource;->releaseInflater(Ljava/util/zip/Inf
 HSPLjava/util/zip/ZipFile$CleanableResource;->run()V
 HSPLjava/util/zip/ZipFile$InflaterCleanupAction;->run()V
 HSPLjava/util/zip/ZipFile$Source$End;-><init>()V
-HSPLjava/util/zip/ZipFile$Source$End;-><init>(Ljava/util/zip/ZipFile$Source$End-IA;)V
+HSPLjava/util/zip/ZipFile$Source$End;-><init>(Ljava/util/zip/ZipFile-IA;)V
 HSPLjava/util/zip/ZipFile$Source$Key;-><init>(Ljava/io/File;Ljava/nio/file/attribute/BasicFileAttributes;Ljava/util/zip/ZipCoder;Z)V
 HSPLjava/util/zip/ZipFile$Source$Key;->equals(Ljava/lang/Object;)Z
 HSPLjava/util/zip/ZipFile$Source$Key;->hashCode()I
@@ -8362,6 +8311,27 @@ HSPLjavax/xml/parsers/SAXParserFactory;-><init>()V
 HSPLjavax/xml/parsers/SAXParserFactory;->newInstance()Ljavax/xml/parsers/SAXParserFactory;
 HSPLjdk/internal/access/SharedSecrets;->getJavaUtilCollectionAccess()Ljdk/internal/access/JavaUtilCollectionAccess;
 HSPLjdk/internal/access/SharedSecrets;->setJavaUtilCollectionAccess(Ljdk/internal/access/JavaUtilCollectionAccess;)V
+HSPLjdk/internal/math/DoubleToDecimal;->toString(D)Ljava/lang/String;
+HSPLjdk/internal/math/DoubleToDecimal;-><init>(Z)V
+HSPLjdk/internal/math/DoubleToDecimal;->split(DLjdk/internal/math/FormattedFPDecimal;)V
+HSPLjdk/internal/math/DoubleToDecimal;->appendTo(DLjava/lang/Appendable;)Ljava/lang/Appendable;
+HSPLjdk/internal/math/DoubleToDecimal;->toDecimalString(D)Ljava/lang/String;
+HSPLjdk/internal/math/DoubleToDecimal;->appendDecimalTo(DLjava/lang/Appendable;)Ljava/lang/Appendable;
+HSPLjdk/internal/math/DoubleToDecimal;->toDecimal(D)I
+HSPLjdk/internal/math/DoubleToDecimal;->toDecimal(IIILjdk/internal/math/FormattedFPDecimal;)I
+HSPLjdk/internal/math/DoubleToDecimal;->rop(JJJ)J
+HSPLjdk/internal/math/DoubleToDecimal;->toChars(JILjdk/internal/math/FormattedFPDecimal;)I
+HSPLjdk/internal/math/DoubleToDecimal;->toChars1(IIII)I
+HSPLjdk/internal/math/DoubleToDecimal;->toChars2(IIII)I
+HSPLjdk/internal/math/DoubleToDecimal;->toChars3(IIII)I
+HSPLjdk/internal/math/DoubleToDecimal;->lowDigits(I)V
+HSPLjdk/internal/math/DoubleToDecimal;->append8Digits(I)V
+HSPLjdk/internal/math/DoubleToDecimal;->removeTrailingZeroes()V
+HSPLjdk/internal/math/DoubleToDecimal;->y(I)I
+HSPLjdk/internal/math/DoubleToDecimal;->exponent(I)V
+HSPLjdk/internal/math/DoubleToDecimal;->append(I)V
+HSPLjdk/internal/math/DoubleToDecimal;->appendDigit(I)V
+HSPLjdk/internal/math/DoubleToDecimal;->charsToString()V
 HSPLjdk/internal/math/FDBigInteger;-><init>(J[CII)V
 HSPLjdk/internal/math/FDBigInteger;-><init>([II)V
 HSPLjdk/internal/math/FDBigInteger;->add(Ljdk/internal/math/FDBigInteger;)Ljdk/internal/math/FDBigInteger;
@@ -8421,6 +8391,25 @@ HSPLjdk/internal/math/FloatingDecimal;->parseFloat(Ljava/lang/String;)F
 HSPLjdk/internal/math/FloatingDecimal;->readJavaFormatString(Ljava/lang/String;)Ljdk/internal/math/FloatingDecimal$ASCIIToBinaryConverter;
 HSPLjdk/internal/math/FloatingDecimal;->toJavaFormatString(D)Ljava/lang/String;
 HSPLjdk/internal/math/FloatingDecimal;->toJavaFormatString(F)Ljava/lang/String;
+HSPLjdk/internal/math/FloatToDecimal;->toString(F)Ljava/lang/String;
+HSPLjdk/internal/math/FloatToDecimal;-><init>()V
+HSPLjdk/internal/math/FloatToDecimal;->appendTo(FLjava/lang/Appendable;)Ljava/lang/Appendable;
+HSPLjdk/internal/math/FloatToDecimal;->toDecimalString(F)Ljava/lang/String;
+HSPLjdk/internal/math/FloatToDecimal;->appendDecimalTo(FLjava/lang/Appendable;)Ljava/lang/Appendable;
+HSPLjdk/internal/math/FloatToDecimal;->toDecimal(F)I
+HSPLjdk/internal/math/FloatToDecimal;->toDecimal(III)I
+HSPLjdk/internal/math/FloatToDecimal;->rop(JJ)I
+HSPLjdk/internal/math/FloatToDecimal;->toChars(FI)I
+HSPLjdk/internal/math/FloatToDecimal;->toChars1(III)I
+HSPLjdk/internal/math/FloatToDecimal;->toChars2(III)I
+HSPLjdk/internal/math/FloatToDecimal;->toChars3(III)I
+HSPLjdk/internal/math/FloatToDecimal;->append8Digits(I)V
+HSPLjdk/internal/math/FloatToDecimal;->removeTrailingZeroes()V
+HSPLjdk/internal/math/FloatToDecimal;->y(I)I
+HSPLjdk/internal/math/FloatToDecimal;->exponent(I)V
+HSPLjdk/internal/math/FloatToDecimal;->append(I)V
+HSPLjdk/internal/math/FloatToDecimal;->appendDigit(I)V
+HSPLjdk/internal/math/FloatToDecimal;->charsToString()V
 HSPLjdk/internal/math/FormattedFloatingDecimal$1;-><init>()V
 HSPLjdk/internal/math/FormattedFloatingDecimal$1;->initialValue()Ljava/lang/Object;
 HSPLjdk/internal/math/FormattedFloatingDecimal$Form;-><clinit>()V
@@ -8436,6 +8425,35 @@ HSPLjdk/internal/math/FormattedFloatingDecimal;->getExponent()[C
 HSPLjdk/internal/math/FormattedFloatingDecimal;->getExponentRounded()I
 HSPLjdk/internal/math/FormattedFloatingDecimal;->getMantissa()[C
 HSPLjdk/internal/math/FormattedFloatingDecimal;->valueOf(DILjdk/internal/math/FormattedFloatingDecimal$Form;)Ljdk/internal/math/FormattedFloatingDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;-><init>()V
+HSPLjdk/internal/math/FormattedFPDecimal;->valueOf(DIC)Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->set(JII)V
+HSPLjdk/internal/math/FormattedFPDecimal;->getExponent()[C
+HSPLjdk/internal/math/FormattedFPDecimal;->getMantissa()[C
+HSPLjdk/internal/math/FormattedFPDecimal;->getExponentRounded()I
+HSPLjdk/internal/math/FormattedFPDecimal;->plain(I)Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->plainChars()Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->plainCharsPureInteger()V
+HSPLjdk/internal/math/FormattedFPDecimal;->plainCharsMixed()V
+HSPLjdk/internal/math/FormattedFPDecimal;->plainCharsPureFraction()V
+HSPLjdk/internal/math/FormattedFPDecimal;->scientific(I)Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->scientificChars(I)Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->scientificCharsWithFraction()V
+HSPLjdk/internal/math/FormattedFPDecimal;->scientificCharsNoFraction()V
+HSPLjdk/internal/math/FormattedFPDecimal;->general()Ljdk/internal/math/FormattedFPDecimal;
+HSPLjdk/internal/math/FormattedFPDecimal;->expChars()V
+HSPLjdk/internal/math/FormattedFPDecimal;->round(J)V
+HSPLjdk/internal/math/FormattedFPDecimal;->fillWithDigits(JII)J
+HSPLjdk/internal/math/FormattedFPDecimal;->fillWithZeroes(II)V
+HSPLjdk/internal/math/FormattedFPDecimal;->toDigit(J)C
+HSPLjdk/internal/math/FormattedFPDecimal;->toDigit(I)C
+HSPLjdk/internal/math/MathUtils;->pow10(I)J
+HSPLjdk/internal/math/MathUtils;->flog10pow2(I)I
+HSPLjdk/internal/math/MathUtils;->flog10threeQuartersPow2(I)I
+HSPLjdk/internal/math/MathUtils;->flog2pow10(I)J
+HSPLjdk/internal/math/MathUtils;->g1(I)J
+HSPLjdk/internal/math/MathUtils;->g0(I)J
+HSPLjdk/internal/misc/Unsafe;->arrayBaseOffset(Ljava/lang/Class;)I
 HSPLjdk/internal/misc/Unsafe;->compareAndSetObject(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z
 HSPLjdk/internal/misc/Unsafe;->getAndAddInt(Ljava/lang/Object;JI)I
 HSPLjdk/internal/misc/Unsafe;->getAndAddLong(Ljava/lang/Object;JJ)J
@@ -8478,12 +8496,14 @@ HSPLjdk/internal/ref/PhantomCleanable;->clean()V
 HSPLjdk/internal/ref/PhantomCleanable;->insert()V
 HSPLjdk/internal/ref/PhantomCleanable;->remove()Z
 HSPLjdk/internal/reflect/Reflection;->getCallerClass()Ljava/lang/Class;
+HSPLjdk/internal/util/ArraysSupport;->hashCode(I[BII)I
 HSPLjdk/internal/util/ArraysSupport;->mismatch([B[BI)I
 HSPLjdk/internal/util/ArraysSupport;->mismatch([FI[FII)I
 HSPLjdk/internal/util/ArraysSupport;->mismatch([I[II)I
 HSPLjdk/internal/util/ArraysSupport;->mismatch([J[JI)I
 HSPLjdk/internal/util/ArraysSupport;->mismatch([Z[ZI)I
 HSPLjdk/internal/util/ArraysSupport;->newLength(III)I
+HSPLjdk/internal/util/ArraysSupport;->vectorizedHashCode(Ljava/lang/Object;IIII)I
 HSPLjdk/internal/util/ArraysSupport;->vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I
 HSPLjdk/internal/util/Preconditions;->checkFromIndexSize(IIILjava/util/function/BiFunction;)I
 HSPLjdk/internal/util/Preconditions;->checkIndex(IILjava/util/function/BiFunction;)I
@@ -8813,7 +8833,7 @@ HSPLlibcore/util/NativeAllocationRegistry$CleanerThunk;->setNativePtr(J)V
 HSPLlibcore/util/NativeAllocationRegistry;->-$$Nest$fgetfreeFunction(Llibcore/util/NativeAllocationRegistry;)J
 HSPLlibcore/util/NativeAllocationRegistry;->-$$Nest$fgetsize(Llibcore/util/NativeAllocationRegistry;)J
 HSPLlibcore/util/NativeAllocationRegistry;->-$$Nest$smregisterNativeFree(J)V
-HSPLlibcore/util/NativeAllocationRegistry;-><init>(Ljava/lang/ClassLoader;JJZ)V
+HSPLlibcore/util/NativeAllocationRegistry;-><init>(Ljava/lang/ClassLoader;Ljava/lang/Class;JJZ)V+]Ljava/util/Map;Ljava/util/WeakHashMap;
 HSPLlibcore/util/NativeAllocationRegistry;->createMalloced(Ljava/lang/ClassLoader;J)Llibcore/util/NativeAllocationRegistry;
 HSPLlibcore/util/NativeAllocationRegistry;->createMalloced(Ljava/lang/ClassLoader;JJ)Llibcore/util/NativeAllocationRegistry;
 HSPLlibcore/util/NativeAllocationRegistry;->createNonmalloced(Ljava/lang/ClassLoader;JJ)Llibcore/util/NativeAllocationRegistry;
@@ -8843,9 +8863,7 @@ HSPLorg/apache/harmony/dalvik/ddmc/DdmServer;->dispatch(I[BII)Lorg/apache/harmon
 HSPLorg/apache/harmony/dalvik/ddmc/DdmServer;->sendChunk(Lorg/apache/harmony/dalvik/ddmc/Chunk;)V
 HSPLorg/apache/harmony/xml/ExpatAttributes;-><init>()V
 HSPLorg/apache/harmony/xml/ExpatParser$CurrentAttributes;-><init>(Lorg/apache/harmony/xml/ExpatParser;)V
-HSPLorg/apache/harmony/xml/ExpatParser$CurrentAttributes;-><init>(Lorg/apache/harmony/xml/ExpatParser;Lorg/apache/harmony/xml/ExpatParser$CurrentAttributes-IA;)V
 HSPLorg/apache/harmony/xml/ExpatParser$ExpatLocator;-><init>(Lorg/apache/harmony/xml/ExpatParser;)V
-HSPLorg/apache/harmony/xml/ExpatParser$ExpatLocator;-><init>(Lorg/apache/harmony/xml/ExpatParser;Lorg/apache/harmony/xml/ExpatParser$ExpatLocator-IA;)V
 HSPLorg/apache/harmony/xml/ExpatParser;-><init>(Ljava/lang/String;Lorg/apache/harmony/xml/ExpatReader;ZLjava/lang/String;Ljava/lang/String;)V
 HSPLorg/apache/harmony/xml/ExpatParser;->endDocument()V
 HSPLorg/apache/harmony/xml/ExpatParser;->endElement(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
@@ -9100,7 +9118,7 @@ HSPLsun/nio/ch/ChannelInputStream;->read(Ljava/nio/channels/ReadableByteChannel;
 HSPLsun/nio/ch/ChannelInputStream;->read([BII)I
 HSPLsun/nio/ch/DefaultSelectorProvider;->create()Ljava/nio/channels/spi/SelectorProvider;
 HSPLsun/nio/ch/FileChannelImpl$Unmapper;-><init>(JJILjava/io/FileDescriptor;)V
-HSPLsun/nio/ch/FileChannelImpl$Unmapper;-><init>(JJILjava/io/FileDescriptor;Lsun/nio/ch/FileChannelImpl$Unmapper-IA;)V
+HSPLsun/nio/ch/FileChannelImpl$Unmapper;-><init>(JJILjava/io/FileDescriptor;Lsun/nio/ch/FileChannelImpl-IA;)V
 HSPLsun/nio/ch/FileChannelImpl$Unmapper;->run()V
 HSPLsun/nio/ch/FileChannelImpl;-><init>(Ljava/io/FileDescriptor;Ljava/lang/String;ZZLjava/lang/Object;)V
 HSPLsun/nio/ch/FileChannelImpl;->ensureOpen()V
@@ -9418,7 +9436,6 @@ HSPLsun/security/action/GetPropertyAction;-><init>(Ljava/lang/String;)V
 HSPLsun/security/action/GetPropertyAction;->run()Ljava/lang/Object;
 HSPLsun/security/action/GetPropertyAction;->run()Ljava/lang/String;
 HSPLsun/security/jca/GetInstance$Instance;-><init>(Ljava/security/Provider;Ljava/lang/Object;)V
-HSPLsun/security/jca/GetInstance$Instance;-><init>(Ljava/security/Provider;Ljava/lang/Object;Lsun/security/jca/GetInstance$Instance-IA;)V
 HSPLsun/security/jca/GetInstance$Instance;->toArray()[Ljava/lang/Object;
 HSPLsun/security/jca/GetInstance;->checkSuperClass(Ljava/security/Provider$Service;Ljava/lang/Class;Ljava/lang/Class;)V
 HSPLsun/security/jca/GetInstance;->getInstance(Ljava/lang/String;Ljava/lang/Class;Ljava/lang/String;)Lsun/security/jca/GetInstance$Instance;
@@ -10045,7 +10062,6 @@ HSPLsun/util/locale/BaseLocale$Cache;->normalizeKey(Ljava/lang/Object;)Ljava/lan
 HSPLsun/util/locale/BaseLocale$Cache;->normalizeKey(Lsun/util/locale/BaseLocale$Key;)Lsun/util/locale/BaseLocale$Key;
 HSPLsun/util/locale/BaseLocale$Key;->-$$Nest$mgetBaseLocale(Lsun/util/locale/BaseLocale$Key;)Lsun/util/locale/BaseLocale;
 HSPLsun/util/locale/BaseLocale$Key;-><init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)V
-HSPLsun/util/locale/BaseLocale$Key;-><init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLsun/util/locale/BaseLocale$Key-IA;)V
 HSPLsun/util/locale/BaseLocale$Key;->equals(Ljava/lang/Object;)Z
 HSPLsun/util/locale/BaseLocale$Key;->getBaseLocale()Lsun/util/locale/BaseLocale;
 HSPLsun/util/locale/BaseLocale$Key;->hashCode()I
@@ -10172,8 +10188,15 @@ Landroid/system/StructTimespec;
 Landroid/system/StructTimeval;
 Landroid/system/StructUcred;
 Landroid/system/StructUtsname;
+Landroid/system/SystemCleaner;
 Landroid/system/UnixSocketAddress;
 Landroid/system/VmSocketAddress;
+Lcom/android/art/flags/FeatureFlags;
+Lcom/android/art/flags/FeatureFlagsImpl;
+Lcom/android/art/flags/Flags;
+Lcom/android/libcore/FeatureFlags;
+Lcom/android/libcore/FeatureFlagsImpl;
+Lcom/android/libcore/Flags;
 Lcom/android/okhttp/Address;
 Lcom/android/okhttp/AndroidInternal;
 Lcom/android/okhttp/AndroidShimResponseCache;
@@ -10339,12 +10362,14 @@ Lcom/android/org/bouncycastle/asn1/ASN1Boolean;
 Lcom/android/org/bouncycastle/asn1/ASN1Choice;
 Lcom/android/org/bouncycastle/asn1/ASN1Encodable;
 Lcom/android/org/bouncycastle/asn1/ASN1EncodableVector;
+Lcom/android/org/bouncycastle/asn1/ASN1Enumerated$$ExternalSyntheticOutline0;
 Lcom/android/org/bouncycastle/asn1/ASN1Enumerated;
 Lcom/android/org/bouncycastle/asn1/ASN1Exception;
 Lcom/android/org/bouncycastle/asn1/ASN1External;
 Lcom/android/org/bouncycastle/asn1/ASN1GeneralizedTime;
 Lcom/android/org/bouncycastle/asn1/ASN1InputStream;
 Lcom/android/org/bouncycastle/asn1/ASN1Integer;
+Lcom/android/org/bouncycastle/asn1/ASN1Null;
 Lcom/android/org/bouncycastle/asn1/ASN1Object;
 Lcom/android/org/bouncycastle/asn1/ASN1ObjectIdentifier$OidHandle;
 Lcom/android/org/bouncycastle/asn1/ASN1ObjectIdentifier;
@@ -10431,7 +10456,6 @@ Lcom/android/org/bouncycastle/crypto/DataLengthException;
 Lcom/android/org/bouncycastle/crypto/Digest;
 Lcom/android/org/bouncycastle/crypto/ExtendedDigest;
 Lcom/android/org/bouncycastle/crypto/InvalidCipherTextException;
-Lcom/android/org/bouncycastle/crypto/Mac;
 Lcom/android/org/bouncycastle/crypto/OutputLengthException;
 Lcom/android/org/bouncycastle/crypto/PBEParametersGenerator;
 Lcom/android/org/bouncycastle/crypto/RuntimeCryptoException;
@@ -10609,8 +10633,8 @@ Ldalvik/system/CloseGuard;
 Ldalvik/system/DelegateLastClassLoader;
 Ldalvik/system/DexClassLoader;
 Ldalvik/system/DexFile$DFEnum;
-Ldalvik/system/DexFile$OptimizationInfo-IA;
 Ldalvik/system/DexFile$OptimizationInfo;
+Ldalvik/system/DexFile-IA;
 Ldalvik/system/DexFile;
 Ldalvik/system/DexPathList$$ExternalSyntheticLambda0;
 Ldalvik/system/DexPathList$Element;
@@ -10636,7 +10660,6 @@ Ljava/awt/font/NumericShaper;
 Ljava/awt/font/TextAttribute;
 Ljava/io/Bits;
 Ljava/io/BufferedInputStream;
-Ljava/io/BufferedOutputStream;
 Ljava/io/BufferedReader;
 Ljava/io/BufferedWriter;
 Ljava/io/ByteArrayInputStream;
@@ -10703,8 +10726,8 @@ Ljava/io/ObjectOutputStream$Caches;
 Ljava/io/ObjectOutputStream$DebugTraceInfoStack;
 Ljava/io/ObjectOutputStream$HandleTable;
 Ljava/io/ObjectOutputStream$PutField;
-Ljava/io/ObjectOutputStream$PutFieldImpl;
 Ljava/io/ObjectOutputStream$ReplaceTable;
+Ljava/io/ObjectOutputStream;
 Ljava/io/ObjectStreamClass$$ExternalSyntheticLambda0;
 Ljava/io/ObjectStreamClass$$ExternalSyntheticLambda1;
 Ljava/io/ObjectStreamClass$$ExternalSyntheticLambda2;
@@ -10719,13 +10742,13 @@ Ljava/io/ObjectStreamClass$ClassDataSlot;
 Ljava/io/ObjectStreamClass$DefaultSUIDCompatibilityListener;
 Ljava/io/ObjectStreamClass$DeserializationConstructorsCache;
 Ljava/io/ObjectStreamClass$EntryFuture$1;
-Ljava/io/ObjectStreamClass$EntryFuture-IA;
 Ljava/io/ObjectStreamClass$EntryFuture;
 Ljava/io/ObjectStreamClass$ExceptionInfo;
 Ljava/io/ObjectStreamClass$FieldReflector;
 Ljava/io/ObjectStreamClass$FieldReflectorKey;
 Ljava/io/ObjectStreamClass$MemberSignature;
 Ljava/io/ObjectStreamClass$WeakClassKey;
+Ljava/io/ObjectStreamClass-IA;
 Ljava/io/ObjectStreamClass;
 Ljava/io/ObjectStreamConstants;
 Ljava/io/ObjectStreamException;
@@ -10837,6 +10860,7 @@ Ljava/lang/Iterable;
 Ljava/lang/LinkageError;
 Ljava/lang/Long$LongCache;
 Ljava/lang/Long;
+Ljava/lang/MatchException;
 Ljava/lang/Math$RandomNumberGeneratorHolder;
 Ljava/lang/Math;
 Ljava/lang/NegativeArraySizeException;
@@ -10888,8 +10912,8 @@ Ljava/lang/String$$ExternalSyntheticLambda0;
 Ljava/lang/String$$ExternalSyntheticLambda1;
 Ljava/lang/String$$ExternalSyntheticLambda2;
 Ljava/lang/String$$ExternalSyntheticLambda3;
-Ljava/lang/String$CaseInsensitiveComparator-IA;
 Ljava/lang/String$CaseInsensitiveComparator;
+Ljava/lang/String-IA;
 Ljava/lang/String;
 Ljava/lang/StringBuffer;
 Ljava/lang/StringBuilder;
@@ -10908,30 +10932,29 @@ Ljava/lang/System;
 Ljava/lang/Thread$1;
 Ljava/lang/Thread$Caches;
 Ljava/lang/Thread$State;
+Ljava/lang/Thread$ThreadIdentifiers;
 Ljava/lang/Thread$UncaughtExceptionHandler;
 Ljava/lang/Thread$WeakClassKey;
 Ljava/lang/Thread;
 Ljava/lang/ThreadDeath;
 Ljava/lang/ThreadGroup;
 Ljava/lang/ThreadLocal$ThreadLocalMap$Entry;
-Ljava/lang/ThreadLocal$ThreadLocalMap-IA;
 Ljava/lang/ThreadLocal$ThreadLocalMap;
+Ljava/lang/ThreadLocal-IA;
 Ljava/lang/ThreadLocal;
-Ljava/lang/Throwable$PrintStreamOrWriter-IA;
 Ljava/lang/Throwable$PrintStreamOrWriter;
 Ljava/lang/Throwable$SentinelHolder;
 Ljava/lang/Throwable$WrappedPrintStream;
 Ljava/lang/Throwable$WrappedPrintWriter;
+Ljava/lang/Throwable-IA;
 Ljava/lang/Throwable;
 Ljava/lang/TypeNotPresentException;
 Ljava/lang/UNIXProcess$1;
 Ljava/lang/UNIXProcess$2;
 Ljava/lang/UNIXProcess$3;
 Ljava/lang/UNIXProcess$ProcessPipeInputStream;
-Ljava/lang/UNIXProcess$ProcessPipeOutputStream;
 Ljava/lang/UNIXProcess$ProcessReaperThreadFactory$1;
 Ljava/lang/UNIXProcess$ProcessReaperThreadFactory;
-Ljava/lang/UNIXProcess;
 Ljava/lang/UnsatisfiedLinkError;
 Ljava/lang/UnsupportedClassVersionError;
 Ljava/lang/UnsupportedOperationException;
@@ -11002,8 +11025,7 @@ Ljava/lang/invoke/MethodHandles$$ExternalSyntheticLambda8;
 Ljava/lang/invoke/MethodHandles$$ExternalSyntheticLambda9;
 Ljava/lang/invoke/MethodHandles$Lookup;
 Ljava/lang/invoke/MethodHandles;
-Ljava/lang/invoke/MethodType$ConcurrentWeakInternSet$WeakEntry;
-Ljava/lang/invoke/MethodType$ConcurrentWeakInternSet;
+Ljava/lang/invoke/MethodType$1;
 Ljava/lang/invoke/MethodType;
 Ljava/lang/invoke/MethodTypeForm;
 Ljava/lang/invoke/SerializedLambda;
@@ -11047,8 +11069,8 @@ Ljava/lang/invoke/WrongMethodTypeException;
 Ljava/lang/ref/Cleaner$1;
 Ljava/lang/ref/Cleaner$Cleanable;
 Ljava/lang/ref/Cleaner;
-Ljava/lang/ref/FinalizerReference$Sentinel-IA;
 Ljava/lang/ref/FinalizerReference$Sentinel;
+Ljava/lang/ref/FinalizerReference-IA;
 Ljava/lang/ref/FinalizerReference;
 Ljava/lang/ref/PhantomReference;
 Ljava/lang/ref/Reference$SinkHolder$1;
@@ -11079,11 +11101,10 @@ Ljava/lang/reflect/ParameterizedType;
 Ljava/lang/reflect/Proxy$1;
 Ljava/lang/reflect/Proxy$Key1;
 Ljava/lang/reflect/Proxy$Key2;
-Ljava/lang/reflect/Proxy$KeyFactory-IA;
 Ljava/lang/reflect/Proxy$KeyFactory;
 Ljava/lang/reflect/Proxy$KeyX;
-Ljava/lang/reflect/Proxy$ProxyClassFactory-IA;
 Ljava/lang/reflect/Proxy$ProxyClassFactory;
+Ljava/lang/reflect/Proxy-IA;
 Ljava/lang/reflect/Proxy;
 Ljava/lang/reflect/RecordComponent;
 Ljava/lang/reflect/ReflectPermission;
@@ -11148,16 +11169,16 @@ Ljava/net/HttpURLConnection;
 Ljava/net/IDN;
 Ljava/net/InMemoryCookieStore;
 Ljava/net/Inet4Address;
-Ljava/net/Inet6Address$Inet6AddressHolder-IA;
 Ljava/net/Inet6Address$Inet6AddressHolder;
+Ljava/net/Inet6Address-IA;
 Ljava/net/Inet6Address;
 Ljava/net/Inet6AddressImpl;
 Ljava/net/InetAddress$1;
 Ljava/net/InetAddress$InetAddressHolder;
 Ljava/net/InetAddress;
 Ljava/net/InetAddressImpl;
-Ljava/net/InetSocketAddress$InetSocketAddressHolder-IA;
 Ljava/net/InetSocketAddress$InetSocketAddressHolder;
+Ljava/net/InetSocketAddress-IA;
 Ljava/net/InetSocketAddress;
 Ljava/net/InterfaceAddress;
 Ljava/net/JarURLConnection;
@@ -11387,11 +11408,10 @@ Ljava/security/PrivilegedActionException;
 Ljava/security/PrivilegedExceptionAction;
 Ljava/security/ProtectionDomain;
 Ljava/security/Provider$EngineDescription;
-Ljava/security/Provider$Service-IA;
 Ljava/security/Provider$Service;
-Ljava/security/Provider$ServiceKey-IA;
 Ljava/security/Provider$ServiceKey;
 Ljava/security/Provider$UString;
+Ljava/security/Provider-IA;
 Ljava/security/Provider;
 Ljava/security/ProviderException;
 Ljava/security/PublicKey;
@@ -11512,8 +11532,8 @@ Ljava/text/DecimalFormat;
 Ljava/text/DecimalFormatSymbols;
 Ljava/text/DontCareFieldPosition$1;
 Ljava/text/DontCareFieldPosition;
-Ljava/text/FieldPosition$Delegate-IA;
 Ljava/text/FieldPosition$Delegate;
+Ljava/text/FieldPosition-IA;
 Ljava/text/FieldPosition;
 Ljava/text/Format$Field;
 Ljava/text/Format$FieldDelegate;
@@ -11579,15 +11599,14 @@ Ljava/time/format/DateTimeFormatterBuilder$InstantPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$NumberPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$OffsetIdPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$PadPrinterParserDecorator;
-Ljava/time/format/DateTimeFormatterBuilder$PrefixTree$CI-IA;
 Ljava/time/format/DateTimeFormatterBuilder$PrefixTree$CI;
-Ljava/time/format/DateTimeFormatterBuilder$PrefixTree-IA;
 Ljava/time/format/DateTimeFormatterBuilder$PrefixTree;
 Ljava/time/format/DateTimeFormatterBuilder$SettingsParser;
 Ljava/time/format/DateTimeFormatterBuilder$StringLiteralPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$TextPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$ZoneIdPrinterParser;
 Ljava/time/format/DateTimeFormatterBuilder$ZoneTextPrinterParser;
+Ljava/time/format/DateTimeFormatterBuilder-IA;
 Ljava/time/format/DateTimeFormatterBuilder;
 Ljava/time/format/DateTimeParseContext;
 Ljava/time/format/DateTimeParseException;
@@ -11644,12 +11663,12 @@ Ljava/time/zone/ZoneRules;
 Ljava/time/zone/ZoneRulesException;
 Ljava/time/zone/ZoneRulesProvider;
 Ljava/util/AbstractCollection;
-Ljava/util/AbstractList$Itr-IA;
 Ljava/util/AbstractList$ListItr;
 Ljava/util/AbstractList$RandomAccessSpliterator;
 Ljava/util/AbstractList$RandomAccessSubList;
 Ljava/util/AbstractList$SubList$1;
 Ljava/util/AbstractList$SubList;
+Ljava/util/AbstractList-IA;
 Ljava/util/AbstractList;
 Ljava/util/AbstractMap$1;
 Ljava/util/AbstractMap$2$1;
@@ -11686,7 +11705,6 @@ Ljava/util/Calendar$Builder;
 Ljava/util/Calendar;
 Ljava/util/Collection;
 Ljava/util/Collections$2;
-Ljava/util/Collections$3;
 Ljava/util/Collections$AsLIFOQueue;
 Ljava/util/Collections$CheckedCollection;
 Ljava/util/Collections$CheckedList;
@@ -11700,10 +11718,7 @@ Ljava/util/Collections$CheckedSortedMap;
 Ljava/util/Collections$CheckedSortedSet;
 Ljava/util/Collections$CopiesList;
 Ljava/util/Collections$EmptyEnumeration;
-Ljava/util/Collections$EmptyList-IA;
 Ljava/util/Collections$EmptyListIterator;
-Ljava/util/Collections$EmptyMap-IA;
-Ljava/util/Collections$EmptySet-IA;
 Ljava/util/Collections$ReverseComparator2;
 Ljava/util/Collections$ReverseComparator;
 Ljava/util/Collections$SequencedSetFromMap;
@@ -11725,9 +11740,9 @@ Ljava/util/Collections$UnmodifiableSequencedCollection;
 Ljava/util/Collections$UnmodifiableSequencedMap;
 Ljava/util/Collections$UnmodifiableSequencedSet;
 Ljava/util/Collections$UnmodifiableSortedMap;
+Ljava/util/Collections-IA;
 Ljava/util/Collections;
 Ljava/util/ComparableTimSort;
-Ljava/util/Comparator$$ExternalSyntheticLambda0;
 Ljava/util/Comparator$$ExternalSyntheticLambda1;
 Ljava/util/Comparator$$ExternalSyntheticLambda2;
 Ljava/util/Comparator$$ExternalSyntheticLambda3;
@@ -11742,28 +11757,21 @@ Ljava/util/Date;
 Ljava/util/Deque;
 Ljava/util/Dictionary;
 Ljava/util/DoubleSummaryStatistics;
-Ljava/util/DualPivotQuicksort$Sorter-IA;
 Ljava/util/DualPivotQuicksort$Sorter;
+Ljava/util/DualPivotQuicksort-IA;
 Ljava/util/DualPivotQuicksort;
 Ljava/util/DuplicateFormatFlagsException;
 Ljava/util/EmptyStackException;
 Ljava/util/EnumMap$1;
-Ljava/util/EnumMap$EntryIterator$Entry-IA;
 Ljava/util/EnumMap$EntryIterator$Entry;
-Ljava/util/EnumMap$EntryIterator-IA;
 Ljava/util/EnumMap$EntryIterator;
-Ljava/util/EnumMap$EntrySet-IA;
 Ljava/util/EnumMap$EntrySet;
-Ljava/util/EnumMap$EnumMapIterator-IA;
 Ljava/util/EnumMap$EnumMapIterator;
-Ljava/util/EnumMap$KeyIterator-IA;
 Ljava/util/EnumMap$KeyIterator;
-Ljava/util/EnumMap$KeySet-IA;
 Ljava/util/EnumMap$KeySet;
-Ljava/util/EnumMap$ValueIterator-IA;
 Ljava/util/EnumMap$ValueIterator;
-Ljava/util/EnumMap$Values-IA;
 Ljava/util/EnumMap$Values;
+Ljava/util/EnumMap-IA;
 Ljava/util/EnumMap;
 Ljava/util/EnumSet$SerializationProxy;
 Ljava/util/EnumSet;
@@ -11789,31 +11797,22 @@ Ljava/util/HashMap$UnsafeHolder;
 Ljava/util/HashMap$ValueSpliterator;
 Ljava/util/HashMap;
 Ljava/util/HashSet;
-Ljava/util/Hashtable$EntrySet-IA;
 Ljava/util/Hashtable$EntrySet;
 Ljava/util/Hashtable$HashtableEntry;
-Ljava/util/Hashtable$KeySet-IA;
 Ljava/util/Hashtable$KeySet;
-Ljava/util/Hashtable$ValueCollection-IA;
 Ljava/util/Hashtable$ValueCollection;
+Ljava/util/Hashtable-IA;
 Ljava/util/Hashtable;
 Ljava/util/HexFormat;
-Ljava/util/IdentityHashMap$EntryIterator$Entry-IA;
 Ljava/util/IdentityHashMap$EntryIterator$Entry;
-Ljava/util/IdentityHashMap$EntryIterator-IA;
 Ljava/util/IdentityHashMap$EntryIterator;
-Ljava/util/IdentityHashMap$EntrySet-IA;
 Ljava/util/IdentityHashMap$EntrySet;
-Ljava/util/IdentityHashMap$IdentityHashMapIterator-IA;
 Ljava/util/IdentityHashMap$IdentityHashMapIterator;
-Ljava/util/IdentityHashMap$KeyIterator-IA;
 Ljava/util/IdentityHashMap$KeyIterator;
-Ljava/util/IdentityHashMap$KeySet-IA;
 Ljava/util/IdentityHashMap$KeySet;
-Ljava/util/IdentityHashMap$ValueIterator-IA;
 Ljava/util/IdentityHashMap$ValueIterator;
-Ljava/util/IdentityHashMap$Values-IA;
 Ljava/util/IdentityHashMap$Values;
+Ljava/util/IdentityHashMap-IA;
 Ljava/util/IdentityHashMap;
 Ljava/util/IllegalFormatArgumentIndexException;
 Ljava/util/IllegalFormatCodePointException;
@@ -11829,24 +11828,20 @@ Ljava/util/ImmutableCollections$AbstractImmutableMap;
 Ljava/util/ImmutableCollections$AbstractImmutableSet;
 Ljava/util/ImmutableCollections$Access$1;
 Ljava/util/ImmutableCollections$Access;
-Ljava/util/ImmutableCollections$ListN-IA;
 Ljava/util/ImmutableCollections$MapN$1;
 Ljava/util/ImmutableCollections$MapN$MapNIterator;
 Ljava/util/ImmutableCollections$SubList;
+Ljava/util/ImmutableCollections-IA;
 Ljava/util/ImmutableCollections;
 Ljava/util/InputMismatchException;
 Ljava/util/Iterator;
 Ljava/util/JumboEnumSet$EnumSetIterator;
 Ljava/util/JumboEnumSet;
 Ljava/util/KeyValueHolder;
-Ljava/util/LinkedHashMap$Entry;
-Ljava/util/LinkedHashMap$LinkedEntryIterator;
-Ljava/util/LinkedHashMap$LinkedEntrySet;
 Ljava/util/LinkedHashMap$LinkedHashIterator;
 Ljava/util/LinkedHashMap$ReversedLinkedHashMapView;
 Ljava/util/LinkedHashMap;
 Ljava/util/LinkedHashSet;
-Ljava/util/LinkedList$DescendingIterator-IA;
 Ljava/util/LinkedList$Node;
 Ljava/util/LinkedList;
 Ljava/util/List;
@@ -11861,7 +11856,6 @@ Ljava/util/Locale$IsoCountryCode$2;
 Ljava/util/Locale$IsoCountryCode$3;
 Ljava/util/Locale$IsoCountryCode;
 Ljava/util/Locale$LanguageRange;
-Ljava/util/Locale$LocaleKey-IA;
 Ljava/util/Locale$LocaleKey;
 Ljava/util/Locale$NoImagePreloadHolder;
 Ljava/util/Locale-IA;
@@ -11973,21 +11967,16 @@ Ljava/util/UUID;
 Ljava/util/UnknownFormatConversionException;
 Ljava/util/UnknownFormatFlagsException;
 Ljava/util/Vector$1;
-Ljava/util/Vector$Itr-IA;
 Ljava/util/Vector$Itr;
+Ljava/util/Vector-IA;
 Ljava/util/Vector;
 Ljava/util/WeakHashMap$Entry;
-Ljava/util/WeakHashMap$EntryIterator-IA;
 Ljava/util/WeakHashMap$EntryIterator;
-Ljava/util/WeakHashMap$EntrySet-IA;
 Ljava/util/WeakHashMap$EntrySet;
 Ljava/util/WeakHashMap$HashIterator;
-Ljava/util/WeakHashMap$KeyIterator-IA;
-Ljava/util/WeakHashMap$KeySet-IA;
-Ljava/util/WeakHashMap$ValueIterator-IA;
 Ljava/util/WeakHashMap$ValueIterator;
-Ljava/util/WeakHashMap$Values-IA;
 Ljava/util/WeakHashMap$Values;
+Ljava/util/WeakHashMap-IA;
 Ljava/util/WeakHashMap;
 Ljava/util/concurrent/AbstractExecutorService;
 Ljava/util/concurrent/ArrayBlockingQueue$Itrs;
@@ -12081,6 +12070,7 @@ Ljava/util/concurrent/Delayed;
 Ljava/util/concurrent/ExecutionException;
 Ljava/util/concurrent/Executor;
 Ljava/util/concurrent/ExecutorService;
+Ljava/util/concurrent/Executors$AutoShutdownDelegatedExecutorService$$ExternalSyntheticLambda0;
 Ljava/util/concurrent/Executors$DefaultThreadFactory;
 Ljava/util/concurrent/Executors$DelegatedExecutorService;
 Ljava/util/concurrent/Executors$RunnableAdapter;
@@ -12095,6 +12085,7 @@ Ljava/util/concurrent/ForkJoinPool;
 Ljava/util/concurrent/ForkJoinTask$Aux;
 Ljava/util/concurrent/ForkJoinTask;
 Ljava/util/concurrent/ForkJoinWorkerThread;
+Ljava/util/concurrent/Future$State;
 Ljava/util/concurrent/Future;
 Ljava/util/concurrent/FutureTask$WaitNode;
 Ljava/util/concurrent/FutureTask;
@@ -12105,6 +12096,8 @@ Ljava/util/concurrent/LinkedBlockingDeque;
 Ljava/util/concurrent/LinkedBlockingQueue$Itr;
 Ljava/util/concurrent/LinkedBlockingQueue$Node;
 Ljava/util/concurrent/LinkedBlockingQueue;
+Ljava/util/concurrent/LinkedTransferQueue$DualNode;
+Ljava/util/concurrent/LinkedTransferQueue;
 Ljava/util/concurrent/Phaser;
 Ljava/util/concurrent/PriorityBlockingQueue;
 Ljava/util/concurrent/RejectedExecutionException;
@@ -12119,10 +12112,6 @@ Ljava/util/concurrent/Semaphore$FairSync;
 Ljava/util/concurrent/Semaphore$NonfairSync;
 Ljava/util/concurrent/Semaphore$Sync;
 Ljava/util/concurrent/Semaphore;
-Ljava/util/concurrent/SynchronousQueue$TransferQueue$QNode;
-Ljava/util/concurrent/SynchronousQueue$TransferQueue;
-Ljava/util/concurrent/SynchronousQueue$TransferStack$SNode;
-Ljava/util/concurrent/SynchronousQueue$TransferStack;
 Ljava/util/concurrent/SynchronousQueue$Transferer;
 Ljava/util/concurrent/SynchronousQueue;
 Ljava/util/concurrent/ThreadFactory;
@@ -12133,6 +12122,7 @@ Ljava/util/concurrent/ThreadPoolExecutor$Worker;
 Ljava/util/concurrent/TimeUnit$1;
 Ljava/util/concurrent/TimeUnit;
 Ljava/util/concurrent/TimeoutException;
+Ljava/util/concurrent/TransferQueue;
 Ljava/util/concurrent/atomic/AtomicBoolean;
 Ljava/util/concurrent/atomic/AtomicInteger;
 Ljava/util/concurrent/atomic/AtomicIntegerArray;
@@ -12232,9 +12222,9 @@ Ljava/util/jar/Manifest;
 Ljava/util/logging/ConsoleHandler;
 Ljava/util/logging/ErrorManager;
 Ljava/util/logging/FileHandler$1;
-Ljava/util/logging/FileHandler$InitializationErrorManager-IA;
 Ljava/util/logging/FileHandler$InitializationErrorManager;
 Ljava/util/logging/FileHandler$MeteredStream;
+Ljava/util/logging/FileHandler-IA;
 Ljava/util/logging/FileHandler;
 Ljava/util/logging/Filter;
 Ljava/util/logging/Formatter;
@@ -12411,13 +12401,11 @@ Ljava/util/stream/Nodes$IntArrayNode;
 Ljava/util/stream/Nodes$IntFixedNodeBuilder;
 Ljava/util/stream/Nodes$IntSpinedNodeBuilder;
 Ljava/util/stream/Nodes$SpinedNodeBuilder;
-Ljava/util/stream/Nodes$ToArrayTask$OfInt-IA;
 Ljava/util/stream/Nodes$ToArrayTask$OfInt;
-Ljava/util/stream/Nodes$ToArrayTask$OfPrimitive-IA;
 Ljava/util/stream/Nodes$ToArrayTask$OfPrimitive;
-Ljava/util/stream/Nodes$ToArrayTask$OfRef-IA;
 Ljava/util/stream/Nodes$ToArrayTask$OfRef;
 Ljava/util/stream/Nodes$ToArrayTask;
+Ljava/util/stream/Nodes-IA;
 Ljava/util/stream/Nodes;
 Ljava/util/stream/PipelineHelper;
 Ljava/util/stream/ReduceOps$10;
@@ -12485,12 +12473,12 @@ Ljava/util/stream/StreamSpliterators$WrappingSpliterator;
 Ljava/util/stream/StreamSupport;
 Ljava/util/stream/Streams$1;
 Ljava/util/stream/Streams$2;
-Ljava/util/stream/Streams$AbstractStreamBuilderImpl-IA;
 Ljava/util/stream/Streams$AbstractStreamBuilderImpl;
 Ljava/util/stream/Streams$ConcatSpliterator$OfRef;
 Ljava/util/stream/Streams$ConcatSpliterator;
 Ljava/util/stream/Streams$RangeIntSpliterator;
 Ljava/util/stream/Streams$StreamBuilderImpl;
+Ljava/util/stream/Streams-IA;
 Ljava/util/stream/Streams;
 Ljava/util/stream/TerminalOp;
 Ljava/util/stream/TerminalSink;
@@ -12502,15 +12490,15 @@ Ljava/util/zip/CheckedInputStream;
 Ljava/util/zip/Checksum$1;
 Ljava/util/zip/Checksum;
 Ljava/util/zip/DataFormatException;
-Ljava/util/zip/Deflater$DeflaterZStreamRef-IA;
 Ljava/util/zip/Deflater$DeflaterZStreamRef;
+Ljava/util/zip/Deflater-IA;
 Ljava/util/zip/Deflater;
 Ljava/util/zip/DeflaterOutputStream;
 Ljava/util/zip/GZIPInputStream$1;
 Ljava/util/zip/GZIPInputStream;
 Ljava/util/zip/GZIPOutputStream;
-Ljava/util/zip/Inflater$InflaterZStreamRef-IA;
 Ljava/util/zip/Inflater$InflaterZStreamRef;
+Ljava/util/zip/Inflater-IA;
 Ljava/util/zip/Inflater;
 Ljava/util/zip/InflaterInputStream;
 Ljava/util/zip/ZipCoder$UTF8ZipCoder;
@@ -12521,13 +12509,13 @@ Ljava/util/zip/ZipError;
 Ljava/util/zip/ZipException;
 Ljava/util/zip/ZipFile$CleanableResource;
 Ljava/util/zip/ZipFile$InflaterCleanupAction;
-Ljava/util/zip/ZipFile$Source$End-IA;
 Ljava/util/zip/ZipFile$Source$End;
 Ljava/util/zip/ZipFile$Source$Key;
 Ljava/util/zip/ZipFile$Source;
 Ljava/util/zip/ZipFile$ZipEntryIterator;
 Ljava/util/zip/ZipFile$ZipFileInflaterInputStream;
 Ljava/util/zip/ZipFile$ZipFileInputStream;
+Ljava/util/zip/ZipFile-IA;
 Ljava/util/zip/ZipFile;
 Ljava/util/zip/ZipInputStream;
 Ljava/util/zip/ZipOutputStream;
@@ -12671,6 +12659,7 @@ Ljdk/internal/misc/TerminatingThreadLocal;
 Ljdk/internal/misc/Unsafe;
 Ljdk/internal/misc/UnsafeConstants;
 Ljdk/internal/misc/VM;
+Ljdk/internal/misc/VirtualThreads;
 Ljdk/internal/ref/CleanerFactory;
 Ljdk/internal/ref/CleanerImpl;
 Ljdk/internal/ref/PhantomCleanable;
@@ -12678,7 +12667,17 @@ Ljdk/internal/reflect/Reflection;
 Ljdk/internal/util/ArraysSupport;
 Ljdk/internal/util/NullableKeyValueHolder;
 Ljdk/internal/util/Preconditions;
+Ljdk/internal/util/ReferenceKey;
+Ljdk/internal/util/ReferencedKeyMap$$ExternalSyntheticLambda0;
+Ljdk/internal/util/ReferencedKeyMap$$ExternalSyntheticLambda1;
+Ljdk/internal/util/ReferencedKeyMap$$ExternalSyntheticLambda2;
+Ljdk/internal/util/ReferencedKeyMap$$ExternalSyntheticLambda3;
+Ljdk/internal/util/ReferencedKeyMap;
+Ljdk/internal/util/ReferencedKeySet;
+Ljdk/internal/util/SoftReferenceKey;
 Ljdk/internal/util/StaticProperty;
+Ljdk/internal/util/StrongReferenceKey;
+Ljdk/internal/util/WeakReferenceKey;
 Ljdk/internal/util/random/RandomSupport;
 Llibcore/content/type/MimeMap$$ExternalSyntheticLambda0;
 Llibcore/content/type/MimeMap$Builder$Element;
@@ -12695,6 +12694,16 @@ Llibcore/icu/SimpleDateFormatData;
 Llibcore/icu/TimeZoneNames$1;
 Llibcore/icu/TimeZoneNames$ZoneStringsCache;
 Llibcore/icu/TimeZoneNames;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch10;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch1;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch2;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch3;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch4;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch5;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch6;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch7;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch8;
+Llibcore/internal/Java21LanguageFeatures$$ExternalSyntheticTypeSwitch9;
 Llibcore/internal/StringPool;
 Llibcore/io/AsynchronousCloseMonitor;
 Llibcore/io/BlockGuardOs;
@@ -12757,11 +12766,10 @@ Lorg/apache/harmony/dalvik/ddmc/DdmServer;
 Lorg/apache/harmony/dalvik/ddmc/DdmVmInternal;
 Lorg/apache/harmony/xml/ExpatAttributes;
 Lorg/apache/harmony/xml/ExpatException;
-Lorg/apache/harmony/xml/ExpatParser$CurrentAttributes-IA;
 Lorg/apache/harmony/xml/ExpatParser$CurrentAttributes;
-Lorg/apache/harmony/xml/ExpatParser$ExpatLocator-IA;
 Lorg/apache/harmony/xml/ExpatParser$ExpatLocator;
 Lorg/apache/harmony/xml/ExpatParser$ParseException;
+Lorg/apache/harmony/xml/ExpatParser-IA;
 Lorg/apache/harmony/xml/ExpatParser;
 Lorg/apache/harmony/xml/ExpatReader;
 Lorg/apache/harmony/xml/dom/AttrImpl;
@@ -12877,8 +12885,8 @@ Lsun/nio/ch/DatagramDispatcher;
 Lsun/nio/ch/DefaultSelectorProvider;
 Lsun/nio/ch/DirectBuffer;
 Lsun/nio/ch/FileChannelImpl$SimpleFileLockTable;
-Lsun/nio/ch/FileChannelImpl$Unmapper-IA;
 Lsun/nio/ch/FileChannelImpl$Unmapper;
+Lsun/nio/ch/FileChannelImpl-IA;
 Lsun/nio/ch/FileDescriptorHolderSocketImpl;
 Lsun/nio/ch/FileDispatcher;
 Lsun/nio/ch/FileDispatcherImpl;
@@ -12963,8 +12971,8 @@ Lsun/reflect/misc/ReflectUtil;
 Lsun/security/action/GetBooleanAction;
 Lsun/security/action/GetIntegerAction;
 Lsun/security/action/GetPropertyAction;
-Lsun/security/jca/GetInstance$Instance-IA;
 Lsun/security/jca/GetInstance$Instance;
+Lsun/security/jca/GetInstance-IA;
 Lsun/security/jca/GetInstance;
 Lsun/security/jca/JCAUtil$CachedSecureRandomHolder;
 Lsun/security/jca/JCAUtil;
@@ -13002,8 +13010,8 @@ Lsun/security/provider/certpath/OCSP$RevocationStatus$CertStatus;
 Lsun/security/provider/certpath/OCSP$RevocationStatus;
 Lsun/security/provider/certpath/OCSP;
 Lsun/security/provider/certpath/OCSPResponse$ResponseStatus;
-Lsun/security/provider/certpath/OCSPResponse$SingleResponse-IA;
 Lsun/security/provider/certpath/OCSPResponse$SingleResponse;
+Lsun/security/provider/certpath/OCSPResponse-IA;
 Lsun/security/provider/certpath/OCSPResponse;
 Lsun/security/provider/certpath/PKIX$ValidatorParams;
 Lsun/security/provider/certpath/PKIX;
@@ -13014,8 +13022,8 @@ Lsun/security/provider/certpath/PolicyNodeImpl;
 Lsun/security/provider/certpath/RevocationChecker$1;
 Lsun/security/provider/certpath/RevocationChecker$2;
 Lsun/security/provider/certpath/RevocationChecker$Mode;
-Lsun/security/provider/certpath/RevocationChecker$RevocationProperties-IA;
 Lsun/security/provider/certpath/RevocationChecker$RevocationProperties;
+Lsun/security/provider/certpath/RevocationChecker-IA;
 Lsun/security/provider/certpath/RevocationChecker;
 Lsun/security/timestamp/TimestampToken;
 Lsun/security/util/AbstractAlgorithmConstraints$1;
@@ -13037,11 +13045,11 @@ Lsun/security/util/DerInputStream;
 Lsun/security/util/DerOutputStream;
 Lsun/security/util/DerValue;
 Lsun/security/util/DisabledAlgorithmConstraints$Constraint$Operator;
-Lsun/security/util/DisabledAlgorithmConstraints$Constraint-IA;
 Lsun/security/util/DisabledAlgorithmConstraints$Constraint;
 Lsun/security/util/DisabledAlgorithmConstraints$Constraints;
 Lsun/security/util/DisabledAlgorithmConstraints$KeySizeConstraint;
 Lsun/security/util/DisabledAlgorithmConstraints$jdkCAConstraint;
+Lsun/security/util/DisabledAlgorithmConstraints-IA;
 Lsun/security/util/DisabledAlgorithmConstraints;
 Lsun/security/util/FilePaths;
 Lsun/security/util/KeyUtil;
@@ -13145,13 +13153,12 @@ Lsun/util/calendar/JulianCalendar$Date;
 Lsun/util/calendar/JulianCalendar;
 Lsun/util/calendar/LocalGregorianCalendar;
 Lsun/util/locale/BaseLocale$Cache;
-Lsun/util/locale/BaseLocale$Key-IA;
 Lsun/util/locale/BaseLocale$Key;
 Lsun/util/locale/BaseLocale-IA;
 Lsun/util/locale/BaseLocale;
 Lsun/util/locale/Extension;
-Lsun/util/locale/InternalLocaleBuilder$CaseInsensitiveChar-IA;
 Lsun/util/locale/InternalLocaleBuilder$CaseInsensitiveChar;
+Lsun/util/locale/InternalLocaleBuilder-IA;
 Lsun/util/locale/InternalLocaleBuilder;
 Lsun/util/locale/LanguageTag;
 Lsun/util/locale/LocaleExtensions;
diff --git a/build/boot/preloaded-classes b/build/boot/preloaded-classes
index 69101c4ed1..08735d6365 100644
--- a/build/boot/preloaded-classes
+++ b/build/boot/preloaded-classes
@@ -50,8 +50,15 @@ android.system.StructTimespec
 android.system.StructTimeval
 android.system.StructUcred
 android.system.StructUtsname
+android.system.SystemCleaner
 android.system.UnixSocketAddress
 android.system.VmSocketAddress
+com.android.art.flags.FeatureFlags
+com.android.art.flags.FeatureFlagsImpl
+com.android.art.flags.Flags
+com.android.libcore.FeatureFlags
+com.android.libcore.FeatureFlagsImpl
+com.android.libcore.Flags
 com.android.okhttp.Address
 com.android.okhttp.AndroidInternal
 com.android.okhttp.AndroidShimResponseCache
@@ -217,12 +224,14 @@ com.android.org.bouncycastle.asn1.ASN1Boolean
 com.android.org.bouncycastle.asn1.ASN1Choice
 com.android.org.bouncycastle.asn1.ASN1Encodable
 com.android.org.bouncycastle.asn1.ASN1EncodableVector
+com.android.org.bouncycastle.asn1.ASN1Enumerated$$ExternalSyntheticOutline0
 com.android.org.bouncycastle.asn1.ASN1Enumerated
 com.android.org.bouncycastle.asn1.ASN1Exception
 com.android.org.bouncycastle.asn1.ASN1External
 com.android.org.bouncycastle.asn1.ASN1GeneralizedTime
 com.android.org.bouncycastle.asn1.ASN1InputStream
 com.android.org.bouncycastle.asn1.ASN1Integer
+com.android.org.bouncycastle.asn1.ASN1Null
 com.android.org.bouncycastle.asn1.ASN1Object
 com.android.org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle
 com.android.org.bouncycastle.asn1.ASN1ObjectIdentifier
@@ -309,7 +318,6 @@ com.android.org.bouncycastle.crypto.DataLengthException
 com.android.org.bouncycastle.crypto.Digest
 com.android.org.bouncycastle.crypto.ExtendedDigest
 com.android.org.bouncycastle.crypto.InvalidCipherTextException
-com.android.org.bouncycastle.crypto.Mac
 com.android.org.bouncycastle.crypto.OutputLengthException
 com.android.org.bouncycastle.crypto.PBEParametersGenerator
 com.android.org.bouncycastle.crypto.RuntimeCryptoException
@@ -487,8 +495,8 @@ dalvik.system.CloseGuard
 dalvik.system.DelegateLastClassLoader
 dalvik.system.DexClassLoader
 dalvik.system.DexFile$DFEnum
-dalvik.system.DexFile$OptimizationInfo-IA
 dalvik.system.DexFile$OptimizationInfo
+dalvik.system.DexFile-IA
 dalvik.system.DexFile
 dalvik.system.DexPathList$$ExternalSyntheticLambda0
 dalvik.system.DexPathList$Element
@@ -580,8 +588,8 @@ java.io.ObjectOutputStream$Caches
 java.io.ObjectOutputStream$DebugTraceInfoStack
 java.io.ObjectOutputStream$HandleTable
 java.io.ObjectOutputStream$PutField
-java.io.ObjectOutputStream$PutFieldImpl
 java.io.ObjectOutputStream$ReplaceTable
+java.io.ObjectOutputStream
 java.io.ObjectStreamClass$$ExternalSyntheticLambda0
 java.io.ObjectStreamClass$$ExternalSyntheticLambda1
 java.io.ObjectStreamClass$$ExternalSyntheticLambda2
@@ -596,13 +604,13 @@ java.io.ObjectStreamClass$ClassDataSlot
 java.io.ObjectStreamClass$DefaultSUIDCompatibilityListener
 java.io.ObjectStreamClass$DeserializationConstructorsCache
 java.io.ObjectStreamClass$EntryFuture$1
-java.io.ObjectStreamClass$EntryFuture-IA
 java.io.ObjectStreamClass$EntryFuture
 java.io.ObjectStreamClass$ExceptionInfo
 java.io.ObjectStreamClass$FieldReflector
 java.io.ObjectStreamClass$FieldReflectorKey
 java.io.ObjectStreamClass$MemberSignature
 java.io.ObjectStreamClass$WeakClassKey
+java.io.ObjectStreamClass-IA
 java.io.ObjectStreamClass
 java.io.ObjectStreamConstants
 java.io.ObjectStreamException
@@ -714,6 +722,7 @@ java.lang.Iterable
 java.lang.LinkageError
 java.lang.Long$LongCache
 java.lang.Long
+java.lang.MatchException
 java.lang.Math$RandomNumberGeneratorHolder
 java.lang.Math
 java.lang.NegativeArraySizeException
@@ -765,8 +774,8 @@ java.lang.String$$ExternalSyntheticLambda0
 java.lang.String$$ExternalSyntheticLambda1
 java.lang.String$$ExternalSyntheticLambda2
 java.lang.String$$ExternalSyntheticLambda3
-java.lang.String$CaseInsensitiveComparator-IA
 java.lang.String$CaseInsensitiveComparator
+java.lang.String-IA
 java.lang.String
 java.lang.StringBuffer
 java.lang.StringBuilder
@@ -785,30 +794,29 @@ java.lang.System
 java.lang.Thread$1
 java.lang.Thread$Caches
 java.lang.Thread$State
+java.lang.Thread$ThreadIdentifiers
 java.lang.Thread$UncaughtExceptionHandler
 java.lang.Thread$WeakClassKey
 java.lang.Thread
 java.lang.ThreadDeath
 java.lang.ThreadGroup
 java.lang.ThreadLocal$ThreadLocalMap$Entry
-java.lang.ThreadLocal$ThreadLocalMap-IA
 java.lang.ThreadLocal$ThreadLocalMap
+java.lang.ThreadLocal-IA
 java.lang.ThreadLocal
-java.lang.Throwable$PrintStreamOrWriter-IA
 java.lang.Throwable$PrintStreamOrWriter
 java.lang.Throwable$SentinelHolder
 java.lang.Throwable$WrappedPrintStream
 java.lang.Throwable$WrappedPrintWriter
+java.lang.Throwable-IA
 java.lang.Throwable
 java.lang.TypeNotPresentException
 java.lang.UNIXProcess$1
 java.lang.UNIXProcess$2
 java.lang.UNIXProcess$3
 java.lang.UNIXProcess$ProcessPipeInputStream
-java.lang.UNIXProcess$ProcessPipeOutputStream
 java.lang.UNIXProcess$ProcessReaperThreadFactory$1
 java.lang.UNIXProcess$ProcessReaperThreadFactory
-java.lang.UNIXProcess
 java.lang.UnsatisfiedLinkError
 java.lang.UnsupportedClassVersionError
 java.lang.UnsupportedOperationException
@@ -879,8 +887,7 @@ java.lang.invoke.MethodHandles$$ExternalSyntheticLambda8
 java.lang.invoke.MethodHandles$$ExternalSyntheticLambda9
 java.lang.invoke.MethodHandles$Lookup
 java.lang.invoke.MethodHandles
-java.lang.invoke.MethodType$ConcurrentWeakInternSet$WeakEntry
-java.lang.invoke.MethodType$ConcurrentWeakInternSet
+java.lang.invoke.MethodType$1
 java.lang.invoke.MethodType
 java.lang.invoke.MethodTypeForm
 java.lang.invoke.SerializedLambda
@@ -924,8 +931,8 @@ java.lang.invoke.WrongMethodTypeException
 java.lang.ref.Cleaner$1
 java.lang.ref.Cleaner$Cleanable
 java.lang.ref.Cleaner
-java.lang.ref.FinalizerReference$Sentinel-IA
 java.lang.ref.FinalizerReference$Sentinel
+java.lang.ref.FinalizerReference-IA
 java.lang.ref.FinalizerReference
 java.lang.ref.PhantomReference
 java.lang.ref.Reference$SinkHolder$1
@@ -956,11 +963,10 @@ java.lang.reflect.ParameterizedType
 java.lang.reflect.Proxy$1
 java.lang.reflect.Proxy$Key1
 java.lang.reflect.Proxy$Key2
-java.lang.reflect.Proxy$KeyFactory-IA
 java.lang.reflect.Proxy$KeyFactory
 java.lang.reflect.Proxy$KeyX
-java.lang.reflect.Proxy$ProxyClassFactory-IA
 java.lang.reflect.Proxy$ProxyClassFactory
+java.lang.reflect.Proxy-IA
 java.lang.reflect.Proxy
 java.lang.reflect.RecordComponent
 java.lang.reflect.ReflectPermission
@@ -1025,16 +1031,16 @@ java.net.HttpURLConnection
 java.net.IDN
 java.net.InMemoryCookieStore
 java.net.Inet4Address
-java.net.Inet6Address$Inet6AddressHolder-IA
 java.net.Inet6Address$Inet6AddressHolder
+java.net.Inet6Address-IA
 java.net.Inet6Address
 java.net.Inet6AddressImpl
 java.net.InetAddress$1
 java.net.InetAddress$InetAddressHolder
 java.net.InetAddress
 java.net.InetAddressImpl
-java.net.InetSocketAddress$InetSocketAddressHolder-IA
 java.net.InetSocketAddress$InetSocketAddressHolder
+java.net.InetSocketAddress-IA
 java.net.InetSocketAddress
 java.net.InterfaceAddress
 java.net.JarURLConnection
@@ -1264,11 +1270,10 @@ java.security.PrivilegedActionException
 java.security.PrivilegedExceptionAction
 java.security.ProtectionDomain
 java.security.Provider$EngineDescription
-java.security.Provider$Service-IA
 java.security.Provider$Service
-java.security.Provider$ServiceKey-IA
 java.security.Provider$ServiceKey
 java.security.Provider$UString
+java.security.Provider-IA
 java.security.Provider
 java.security.ProviderException
 java.security.PublicKey
@@ -1389,8 +1394,8 @@ java.text.DecimalFormat
 java.text.DecimalFormatSymbols
 java.text.DontCareFieldPosition$1
 java.text.DontCareFieldPosition
-java.text.FieldPosition$Delegate-IA
 java.text.FieldPosition$Delegate
+java.text.FieldPosition-IA
 java.text.FieldPosition
 java.text.Format$Field
 java.text.Format$FieldDelegate
@@ -1456,15 +1461,14 @@ java.time.format.DateTimeFormatterBuilder$InstantPrinterParser
 java.time.format.DateTimeFormatterBuilder$NumberPrinterParser
 java.time.format.DateTimeFormatterBuilder$OffsetIdPrinterParser
 java.time.format.DateTimeFormatterBuilder$PadPrinterParserDecorator
-java.time.format.DateTimeFormatterBuilder$PrefixTree$CI-IA
 java.time.format.DateTimeFormatterBuilder$PrefixTree$CI
-java.time.format.DateTimeFormatterBuilder$PrefixTree-IA
 java.time.format.DateTimeFormatterBuilder$PrefixTree
 java.time.format.DateTimeFormatterBuilder$SettingsParser
 java.time.format.DateTimeFormatterBuilder$StringLiteralPrinterParser
 java.time.format.DateTimeFormatterBuilder$TextPrinterParser
 java.time.format.DateTimeFormatterBuilder$ZoneIdPrinterParser
 java.time.format.DateTimeFormatterBuilder$ZoneTextPrinterParser
+java.time.format.DateTimeFormatterBuilder-IA
 java.time.format.DateTimeFormatterBuilder
 java.time.format.DateTimeParseContext
 java.time.format.DateTimeParseException
@@ -1521,12 +1525,12 @@ java.time.zone.ZoneRules
 java.time.zone.ZoneRulesException
 java.time.zone.ZoneRulesProvider
 java.util.AbstractCollection
-java.util.AbstractList$Itr-IA
 java.util.AbstractList$ListItr
 java.util.AbstractList$RandomAccessSpliterator
 java.util.AbstractList$RandomAccessSubList
 java.util.AbstractList$SubList$1
 java.util.AbstractList$SubList
+java.util.AbstractList-IA
 java.util.AbstractList
 java.util.AbstractMap$1
 java.util.AbstractMap$2$1
@@ -1563,7 +1567,6 @@ java.util.Calendar$Builder
 java.util.Calendar
 java.util.Collection
 java.util.Collections$2
-java.util.Collections$3
 java.util.Collections$AsLIFOQueue
 java.util.Collections$CheckedCollection
 java.util.Collections$CheckedList
@@ -1577,17 +1580,14 @@ java.util.Collections$CheckedSortedMap
 java.util.Collections$CheckedSortedSet
 java.util.Collections$CopiesList
 java.util.Collections$EmptyEnumeration
-java.util.Collections$EmptyList-IA
 java.util.Collections$EmptyListIterator
-java.util.Collections$EmptyMap-IA
-java.util.Collections$EmptySet-IA
 java.util.Collections$ReverseComparator2
 java.util.Collections$ReverseComparator
 java.util.Collections$SequencedSetFromMap
+java.util.Collections$SetFromMap
 java.util.Collections$SynchronizedList
 java.util.Collections$SynchronizedNavigableMap
 java.util.Collections$SynchronizedNavigableSet
-java.util.Collections$SynchronizedRandomAccessList
 java.util.Collections$SynchronizedSortedMap
 java.util.Collections$SynchronizedSortedSet
 java.util.Collections$UnmodifiableList$1
@@ -1600,6 +1600,7 @@ java.util.Collections$UnmodifiableSequencedCollection
 java.util.Collections$UnmodifiableSequencedMap
 java.util.Collections$UnmodifiableSequencedSet
 java.util.Collections$UnmodifiableSortedMap
+java.util.Collections-IA
 java.util.Collections
 java.util.ComparableTimSort
 java.util.Comparator$$ExternalSyntheticLambda1
@@ -1616,28 +1617,21 @@ java.util.Date
 java.util.Deque
 java.util.Dictionary
 java.util.DoubleSummaryStatistics
-java.util.DualPivotQuicksort$Sorter-IA
 java.util.DualPivotQuicksort$Sorter
+java.util.DualPivotQuicksort-IA
 java.util.DualPivotQuicksort
 java.util.DuplicateFormatFlagsException
 java.util.EmptyStackException
 java.util.EnumMap$1
-java.util.EnumMap$EntryIterator$Entry-IA
 java.util.EnumMap$EntryIterator$Entry
-java.util.EnumMap$EntryIterator-IA
 java.util.EnumMap$EntryIterator
-java.util.EnumMap$EntrySet-IA
 java.util.EnumMap$EntrySet
-java.util.EnumMap$EnumMapIterator-IA
 java.util.EnumMap$EnumMapIterator
-java.util.EnumMap$KeyIterator-IA
 java.util.EnumMap$KeyIterator
-java.util.EnumMap$KeySet-IA
 java.util.EnumMap$KeySet
-java.util.EnumMap$ValueIterator-IA
 java.util.EnumMap$ValueIterator
-java.util.EnumMap$Values-IA
 java.util.EnumMap$Values
+java.util.EnumMap-IA
 java.util.EnumMap
 java.util.EnumSet$SerializationProxy
 java.util.EnumSet
@@ -1663,31 +1657,22 @@ java.util.HashMap$UnsafeHolder
 java.util.HashMap$ValueSpliterator
 java.util.HashMap
 java.util.HashSet
-java.util.Hashtable$EntrySet-IA
 java.util.Hashtable$EntrySet
 java.util.Hashtable$HashtableEntry
-java.util.Hashtable$KeySet-IA
 java.util.Hashtable$KeySet
-java.util.Hashtable$ValueCollection-IA
 java.util.Hashtable$ValueCollection
+java.util.Hashtable-IA
 java.util.Hashtable
 java.util.HexFormat
-java.util.IdentityHashMap$EntryIterator$Entry-IA
 java.util.IdentityHashMap$EntryIterator$Entry
-java.util.IdentityHashMap$EntryIterator-IA
 java.util.IdentityHashMap$EntryIterator
-java.util.IdentityHashMap$EntrySet-IA
 java.util.IdentityHashMap$EntrySet
-java.util.IdentityHashMap$IdentityHashMapIterator-IA
 java.util.IdentityHashMap$IdentityHashMapIterator
-java.util.IdentityHashMap$KeyIterator-IA
 java.util.IdentityHashMap$KeyIterator
-java.util.IdentityHashMap$KeySet-IA
 java.util.IdentityHashMap$KeySet
-java.util.IdentityHashMap$ValueIterator-IA
 java.util.IdentityHashMap$ValueIterator
-java.util.IdentityHashMap$Values-IA
 java.util.IdentityHashMap$Values
+java.util.IdentityHashMap-IA
 java.util.IdentityHashMap
 java.util.IllegalFormatArgumentIndexException
 java.util.IllegalFormatCodePointException
@@ -1703,19 +1688,19 @@ java.util.ImmutableCollections$AbstractImmutableMap
 java.util.ImmutableCollections$AbstractImmutableSet
 java.util.ImmutableCollections$Access$1
 java.util.ImmutableCollections$Access
-java.util.ImmutableCollections$ListN-IA
+java.util.ImmutableCollections$MapN$1
+java.util.ImmutableCollections$MapN$MapNIterator
 java.util.ImmutableCollections$SubList
+java.util.ImmutableCollections-IA
 java.util.InputMismatchException
 java.util.Iterator
 java.util.JumboEnumSet$EnumSetIterator
 java.util.JumboEnumSet
-java.util.LinkedHashMap$LinkedEntryIterator
-java.util.LinkedHashMap$LinkedEntrySet
+java.util.KeyValueHolder
 java.util.LinkedHashMap$LinkedHashIterator
 java.util.LinkedHashMap$ReversedLinkedHashMapView
 java.util.LinkedHashMap
 java.util.LinkedHashSet
-java.util.LinkedList$DescendingIterator-IA
 java.util.LinkedList$Node
 java.util.LinkedList
 java.util.List
@@ -1730,7 +1715,6 @@ java.util.Locale$IsoCountryCode$2
 java.util.Locale$IsoCountryCode$3
 java.util.Locale$IsoCountryCode
 java.util.Locale$LanguageRange
-java.util.Locale$LocaleKey-IA
 java.util.Locale$LocaleKey
 java.util.Locale$NoImagePreloadHolder
 java.util.Locale-IA
@@ -1842,21 +1826,16 @@ java.util.UUID
 java.util.UnknownFormatConversionException
 java.util.UnknownFormatFlagsException
 java.util.Vector$1
-java.util.Vector$Itr-IA
 java.util.Vector$Itr
+java.util.Vector-IA
 java.util.Vector
 java.util.WeakHashMap$Entry
-java.util.WeakHashMap$EntryIterator-IA
 java.util.WeakHashMap$EntryIterator
-java.util.WeakHashMap$EntrySet-IA
 java.util.WeakHashMap$EntrySet
 java.util.WeakHashMap$HashIterator
-java.util.WeakHashMap$KeyIterator-IA
-java.util.WeakHashMap$KeySet-IA
-java.util.WeakHashMap$ValueIterator-IA
 java.util.WeakHashMap$ValueIterator
-java.util.WeakHashMap$Values-IA
 java.util.WeakHashMap$Values
+java.util.WeakHashMap-IA
 java.util.WeakHashMap
 java.util.concurrent.AbstractExecutorService
 java.util.concurrent.ArrayBlockingQueue$Itrs
@@ -1889,7 +1868,6 @@ java.util.concurrent.ConcurrentHashMap$ForEachTransformedMappingTask
 java.util.concurrent.ConcurrentHashMap$ForEachTransformedValueTask
 java.util.concurrent.ConcurrentHashMap$ForEachValueTask
 java.util.concurrent.ConcurrentHashMap$ForwardingNode
-java.util.concurrent.ConcurrentHashMap$KeyIterator
 java.util.concurrent.ConcurrentHashMap$KeySetView
 java.util.concurrent.ConcurrentHashMap$KeySpliterator
 java.util.concurrent.ConcurrentHashMap$MapReduceEntriesTask
@@ -1988,10 +1966,6 @@ java.util.concurrent.Semaphore$FairSync
 java.util.concurrent.Semaphore$NonfairSync
 java.util.concurrent.Semaphore$Sync
 java.util.concurrent.Semaphore
-java.util.concurrent.SynchronousQueue$TransferQueue$QNode
-java.util.concurrent.SynchronousQueue$TransferQueue
-java.util.concurrent.SynchronousQueue$TransferStack$SNode
-java.util.concurrent.SynchronousQueue$TransferStack
 java.util.concurrent.SynchronousQueue$Transferer
 java.util.concurrent.SynchronousQueue
 java.util.concurrent.ThreadFactory
@@ -2100,9 +2074,9 @@ java.util.jar.Manifest
 java.util.logging.ConsoleHandler
 java.util.logging.ErrorManager
 java.util.logging.FileHandler$1
-java.util.logging.FileHandler$InitializationErrorManager-IA
 java.util.logging.FileHandler$InitializationErrorManager
 java.util.logging.FileHandler$MeteredStream
+java.util.logging.FileHandler-IA
 java.util.logging.FileHandler
 java.util.logging.Filter
 java.util.logging.Formatter
@@ -2279,13 +2253,11 @@ java.util.stream.Nodes$IntArrayNode
 java.util.stream.Nodes$IntFixedNodeBuilder
 java.util.stream.Nodes$IntSpinedNodeBuilder
 java.util.stream.Nodes$SpinedNodeBuilder
-java.util.stream.Nodes$ToArrayTask$OfInt-IA
 java.util.stream.Nodes$ToArrayTask$OfInt
-java.util.stream.Nodes$ToArrayTask$OfPrimitive-IA
 java.util.stream.Nodes$ToArrayTask$OfPrimitive
-java.util.stream.Nodes$ToArrayTask$OfRef-IA
 java.util.stream.Nodes$ToArrayTask$OfRef
 java.util.stream.Nodes$ToArrayTask
+java.util.stream.Nodes-IA
 java.util.stream.Nodes
 java.util.stream.PipelineHelper
 java.util.stream.ReduceOps$10
@@ -2353,12 +2325,12 @@ java.util.stream.StreamSpliterators$WrappingSpliterator
 java.util.stream.StreamSupport
 java.util.stream.Streams$1
 java.util.stream.Streams$2
-java.util.stream.Streams$AbstractStreamBuilderImpl-IA
 java.util.stream.Streams$AbstractStreamBuilderImpl
 java.util.stream.Streams$ConcatSpliterator$OfRef
 java.util.stream.Streams$ConcatSpliterator
 java.util.stream.Streams$RangeIntSpliterator
 java.util.stream.Streams$StreamBuilderImpl
+java.util.stream.Streams-IA
 java.util.stream.Streams
 java.util.stream.TerminalOp
 java.util.stream.TerminalSink
@@ -2370,15 +2342,14 @@ java.util.zip.CheckedInputStream
 java.util.zip.Checksum$1
 java.util.zip.Checksum
 java.util.zip.DataFormatException
-java.util.zip.Deflater$DeflaterZStreamRef-IA
 java.util.zip.Deflater$DeflaterZStreamRef
+java.util.zip.Deflater-IA
 java.util.zip.Deflater
 java.util.zip.DeflaterOutputStream
 java.util.zip.GZIPInputStream$1
-java.util.zip.GZIPInputStream
 java.util.zip.GZIPOutputStream
-java.util.zip.Inflater$InflaterZStreamRef-IA
 java.util.zip.Inflater$InflaterZStreamRef
+java.util.zip.Inflater-IA
 java.util.zip.Inflater
 java.util.zip.InflaterInputStream
 java.util.zip.ZipCoder$UTF8ZipCoder
@@ -2389,14 +2360,16 @@ java.util.zip.ZipError
 java.util.zip.ZipException
 java.util.zip.ZipFile$CleanableResource
 java.util.zip.ZipFile$InflaterCleanupAction
-java.util.zip.ZipFile$Source$End-IA
 java.util.zip.ZipFile$Source$End
 java.util.zip.ZipFile$Source$Key
 java.util.zip.ZipFile$Source
 java.util.zip.ZipFile$ZipEntryIterator
+java.util.zip.ZipFile$ZipFileInflaterInputStream
 java.util.zip.ZipFile$ZipFileInputStream
+java.util.zip.ZipFile-IA
 java.util.zip.ZipFile
 java.util.zip.ZipInputStream
+java.util.zip.ZipOutputStream
 java.util.zip.ZipUtils
 javax.crypto.AEADBadTagException
 javax.crypto.BadPaddingException
@@ -2536,6 +2509,7 @@ jdk.internal.misc.TerminatingThreadLocal
 jdk.internal.misc.Unsafe
 jdk.internal.misc.UnsafeConstants
 jdk.internal.misc.VM
+jdk.internal.misc.VirtualThreads
 jdk.internal.ref.CleanerFactory
 jdk.internal.ref.CleanerImpl
 jdk.internal.ref.PhantomCleanable
@@ -2543,7 +2517,17 @@ jdk.internal.reflect.Reflection
 jdk.internal.util.ArraysSupport
 jdk.internal.util.NullableKeyValueHolder
 jdk.internal.util.Preconditions
+jdk.internal.util.ReferenceKey
+jdk.internal.util.ReferencedKeyMap$$ExternalSyntheticLambda0
+jdk.internal.util.ReferencedKeyMap$$ExternalSyntheticLambda1
+jdk.internal.util.ReferencedKeyMap$$ExternalSyntheticLambda2
+jdk.internal.util.ReferencedKeyMap$$ExternalSyntheticLambda3
+jdk.internal.util.ReferencedKeyMap
+jdk.internal.util.ReferencedKeySet
+jdk.internal.util.SoftReferenceKey
 jdk.internal.util.StaticProperty
+jdk.internal.util.StrongReferenceKey
+jdk.internal.util.WeakReferenceKey
 jdk.internal.util.random.RandomSupport
 libcore.content.type.MimeMap$$ExternalSyntheticLambda0
 libcore.content.type.MimeMap$Builder$Element
@@ -2560,6 +2544,16 @@ libcore.icu.SimpleDateFormatData
 libcore.icu.TimeZoneNames$1
 libcore.icu.TimeZoneNames$ZoneStringsCache
 libcore.icu.TimeZoneNames
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch10
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch1
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch2
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch3
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch4
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch5
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch6
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch7
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch8
+libcore.internal.Java21LanguageFeatures$$ExternalSyntheticTypeSwitch9
 libcore.internal.StringPool
 libcore.io.AsynchronousCloseMonitor
 libcore.io.BlockGuardOs
@@ -2622,11 +2616,10 @@ org.apache.harmony.dalvik.ddmc.DdmServer
 org.apache.harmony.dalvik.ddmc.DdmVmInternal
 org.apache.harmony.xml.ExpatAttributes
 org.apache.harmony.xml.ExpatException
-org.apache.harmony.xml.ExpatParser$CurrentAttributes-IA
 org.apache.harmony.xml.ExpatParser$CurrentAttributes
-org.apache.harmony.xml.ExpatParser$ExpatLocator-IA
 org.apache.harmony.xml.ExpatParser$ExpatLocator
 org.apache.harmony.xml.ExpatParser$ParseException
+org.apache.harmony.xml.ExpatParser-IA
 org.apache.harmony.xml.ExpatParser
 org.apache.harmony.xml.ExpatReader
 org.apache.harmony.xml.dom.AttrImpl
@@ -2634,9 +2627,7 @@ org.apache.harmony.xml.dom.CDATASectionImpl
 org.apache.harmony.xml.dom.CharacterDataImpl
 org.apache.harmony.xml.dom.CommentImpl
 org.apache.harmony.xml.dom.DOMImplementationImpl
-org.apache.harmony.xml.dom.DocumentImpl
 org.apache.harmony.xml.dom.DocumentTypeImpl
-org.apache.harmony.xml.dom.ElementImpl
 org.apache.harmony.xml.dom.EntityReferenceImpl
 org.apache.harmony.xml.dom.InnerNodeImpl
 org.apache.harmony.xml.dom.LeafNodeImpl
@@ -2644,7 +2635,6 @@ org.apache.harmony.xml.dom.NodeImpl$1
 org.apache.harmony.xml.dom.NodeImpl
 org.apache.harmony.xml.dom.NodeListImpl
 org.apache.harmony.xml.dom.ProcessingInstructionImpl
-org.apache.harmony.xml.dom.TextImpl
 org.apache.harmony.xml.parsers.DocumentBuilderFactoryImpl
 org.apache.harmony.xml.parsers.DocumentBuilderImpl
 org.apache.harmony.xml.parsers.SAXParserFactoryImpl
@@ -2742,8 +2732,8 @@ sun.nio.ch.DatagramDispatcher
 sun.nio.ch.DefaultSelectorProvider
 sun.nio.ch.DirectBuffer
 sun.nio.ch.FileChannelImpl$SimpleFileLockTable
-sun.nio.ch.FileChannelImpl$Unmapper-IA
 sun.nio.ch.FileChannelImpl$Unmapper
+sun.nio.ch.FileChannelImpl-IA
 sun.nio.ch.FileDescriptorHolderSocketImpl
 sun.nio.ch.FileDispatcher
 sun.nio.ch.FileDispatcherImpl
@@ -2827,8 +2817,8 @@ sun.reflect.misc.ReflectUtil
 sun.security.action.GetBooleanAction
 sun.security.action.GetIntegerAction
 sun.security.action.GetPropertyAction
-sun.security.jca.GetInstance$Instance-IA
 sun.security.jca.GetInstance$Instance
+sun.security.jca.GetInstance-IA
 sun.security.jca.GetInstance
 sun.security.jca.JCAUtil$CachedSecureRandomHolder
 sun.security.jca.JCAUtil
@@ -2866,8 +2856,8 @@ sun.security.provider.certpath.OCSP$RevocationStatus$CertStatus
 sun.security.provider.certpath.OCSP$RevocationStatus
 sun.security.provider.certpath.OCSP
 sun.security.provider.certpath.OCSPResponse$ResponseStatus
-sun.security.provider.certpath.OCSPResponse$SingleResponse-IA
 sun.security.provider.certpath.OCSPResponse$SingleResponse
+sun.security.provider.certpath.OCSPResponse-IA
 sun.security.provider.certpath.OCSPResponse
 sun.security.provider.certpath.PKIX$ValidatorParams
 sun.security.provider.certpath.PKIX
@@ -2878,8 +2868,8 @@ sun.security.provider.certpath.PolicyNodeImpl
 sun.security.provider.certpath.RevocationChecker$1
 sun.security.provider.certpath.RevocationChecker$2
 sun.security.provider.certpath.RevocationChecker$Mode
-sun.security.provider.certpath.RevocationChecker$RevocationProperties-IA
 sun.security.provider.certpath.RevocationChecker$RevocationProperties
+sun.security.provider.certpath.RevocationChecker-IA
 sun.security.provider.certpath.RevocationChecker
 sun.security.timestamp.TimestampToken
 sun.security.util.AbstractAlgorithmConstraints$1
@@ -2901,11 +2891,11 @@ sun.security.util.DerInputStream
 sun.security.util.DerOutputStream
 sun.security.util.DerValue
 sun.security.util.DisabledAlgorithmConstraints$Constraint$Operator
-sun.security.util.DisabledAlgorithmConstraints$Constraint-IA
 sun.security.util.DisabledAlgorithmConstraints$Constraint
 sun.security.util.DisabledAlgorithmConstraints$Constraints
 sun.security.util.DisabledAlgorithmConstraints$KeySizeConstraint
 sun.security.util.DisabledAlgorithmConstraints$jdkCAConstraint
+sun.security.util.DisabledAlgorithmConstraints-IA
 sun.security.util.DisabledAlgorithmConstraints
 sun.security.util.FilePaths
 sun.security.util.KeyUtil
@@ -3009,13 +2999,12 @@ sun.util.calendar.JulianCalendar$Date
 sun.util.calendar.JulianCalendar
 sun.util.calendar.LocalGregorianCalendar
 sun.util.locale.BaseLocale$Cache
-sun.util.locale.BaseLocale$Key-IA
 sun.util.locale.BaseLocale$Key
 sun.util.locale.BaseLocale-IA
 sun.util.locale.BaseLocale
 sun.util.locale.Extension
-sun.util.locale.InternalLocaleBuilder$CaseInsensitiveChar-IA
 sun.util.locale.InternalLocaleBuilder$CaseInsensitiveChar
+sun.util.locale.InternalLocaleBuilder-IA
 sun.util.locale.InternalLocaleBuilder
 sun.util.locale.LanguageTag
 sun.util.locale.LocaleExtensions
diff --git a/build/flags/Android.bp b/build/flags/Android.bp
index 8ee33c7a6f..951ca39ba4 100644
--- a/build/flags/Android.bp
+++ b/build/flags/Android.bp
@@ -31,7 +31,8 @@ aconfig_declarations {
     visibility: [
         "//art:__subpackages__",
         "//libcore:__subpackages__",
-        "//frameworks/base", // Needed for exporting flags.
+        "//frameworks/base:__subpackages__",
+        "//packages/modules/UprobeStats:__subpackages__",
     ],
 }
 
@@ -59,3 +60,12 @@ java_aconfig_library {
         "//apex_available:anyapex",
     ],
 }
+
+java_aconfig_library {
+    name: "art-aconfig-flags-java-lib-host",
+    host_supported: true,
+    aconfig_declarations: "art-aconfig-flags",
+    visibility: [
+        "//cts/hostsidetests/compilation:__subpackages__",
+    ],
+}
diff --git a/build/flags/art-flags.aconfig b/build/flags/art-flags.aconfig
index e38f62a0ae..825a888330 100644
--- a/build/flags/art-flags.aconfig
+++ b/build/flags/art-flags.aconfig
@@ -34,3 +34,21 @@ flag {
   is_fixed_read_only: true
   is_exported: false
 }
+
+flag {
+  namespace: "system_performance"
+  name: "executable_method_file_offsets"
+  is_exported: true
+  description: "This flag includes the API for getting the compiled native executable offset info for a java method"
+  bug: "296108553"
+  is_fixed_read_only: true
+}
+
+flag {
+  name: "art_service_v3"
+  namespace: "art_mainline"
+  description: "Flag for all new ART Service APIs added in the 25Q2 version of the ART module."
+  bug: "373820009"
+  is_fixed_read_only: true
+  is_exported: true
+}
diff --git a/compiler/Android.bp b/compiler/Android.bp
index 05a599cf4a..ce087dacf7 100644
--- a/compiler/Android.bp
+++ b/compiler/Android.bp
@@ -50,7 +50,7 @@ art_cc_defaults {
     shared_libs: [
         "libartbase",
         "libprofile",
-        "libdexfile",
+        "libdexfile#impl",
     ],
     static_libs: ["libelffile"],
     codegen: {
@@ -93,7 +93,7 @@ art_cc_defaults {
     shared_libs: [
         "libartbased",
         "libprofiled",
-        "libdexfiled",
+        "libdexfiled#impl",
     ],
     static_libs: ["libelffiled"],
     codegen: {
@@ -159,6 +159,7 @@ art_cc_defaults {
         "optimizing/graph_checker.cc",
         "optimizing/graph_visualizer.cc",
         "optimizing/gvn.cc",
+        "optimizing/handle_cache.cc",
         "optimizing/induction_var_analysis.cc",
         "optimizing/induction_var_range.cc",
         "optimizing/inliner.cc",
@@ -174,11 +175,13 @@ art_cc_defaults {
         "optimizing/loop_analysis.cc",
         "optimizing/loop_optimization.cc",
         "optimizing/nodes.cc",
+        "optimizing/nodes_vector.cc",
         "optimizing/optimization.cc",
         "optimizing/optimizing_compiler.cc",
         "optimizing/parallel_move_resolver.cc",
         "optimizing/prepare_for_register_allocation.cc",
         "optimizing/profiling_info_builder.cc",
+        "optimizing/reference_type_info.cc",
         "optimizing/reference_type_propagation.cc",
         "optimizing/register_allocation_resolver.cc",
         "optimizing/register_allocator.cc",
@@ -370,10 +373,6 @@ art_cc_library_static {
     ],
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into com.android.art, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and this depends on libdexfiled.
-        "com.android.art",
     ],
 }
 
@@ -436,7 +435,7 @@ art_cc_library_static {
 
 art_cc_defaults {
     name: "art_compiler_tests_defaults",
-    data: [
+    device_common_data: [
         ":art-gtest-jars-ExceptionHandle",
         ":art-gtest-jars-Interfaces",
         ":art-gtest-jars-Main",
@@ -542,6 +541,7 @@ art_cc_defaults {
             shared_libs: [
                 "libartd-simulator",
             ],
+            required: ["art_boot_images"],
         },
     },
 }
diff --git a/compiler/common_compiler_test.cc b/compiler/common_compiler_test.cc
index 392a0d1001..f24406e599 100644
--- a/compiler/common_compiler_test.cc
+++ b/compiler/common_compiler_test.cc
@@ -186,7 +186,9 @@ class CommonCompilerTestImpl::OneCompiledMethodStorage final : public CompiledCo
 };
 
 std::unique_ptr<CompilerOptions> CommonCompilerTestImpl::CreateCompilerOptions(
-    InstructionSet instruction_set, const std::string& variant) {
+    InstructionSet instruction_set,
+    const std::string& variant,
+    const std::optional<std::string>& extra_features) {
   std::unique_ptr<CompilerOptions> compiler_options = std::make_unique<CompilerOptions>();
   compiler_options->emit_read_barrier_ = gUseReadBarrier;
   compiler_options->instruction_set_ = instruction_set;
@@ -194,6 +196,12 @@ std::unique_ptr<CompilerOptions> CommonCompilerTestImpl::CreateCompilerOptions(
   compiler_options->instruction_set_features_ =
       InstructionSetFeatures::FromVariant(instruction_set, variant, &error_msg);
   CHECK(compiler_options->instruction_set_features_ != nullptr) << error_msg;
+  if (extra_features) {
+    compiler_options->instruction_set_features_ =
+        compiler_options->instruction_set_features_->AddFeaturesFromString(*extra_features,
+                                                                           &error_msg);
+    CHECK_NE(compiler_options->instruction_set_features_, nullptr) << error_msg;
+  }
   return compiler_options;
 }
 
@@ -283,7 +291,6 @@ void CommonCompilerTestImpl::CompileMethod(ArtMethod* method) {
     } else {
       compiled_method = compiler->Compile(method->GetCodeItem(),
                                           method->GetAccessFlags(),
-                                          method->GetInvokeType(),
                                           method->GetClassDefIndex(),
                                           method->GetDexMethodIndex(),
                                           class_loader,
diff --git a/compiler/common_compiler_test.h b/compiler/common_compiler_test.h
index 32a5234797..80b26eefe9 100644
--- a/compiler/common_compiler_test.h
+++ b/compiler/common_compiler_test.h
@@ -44,8 +44,12 @@ template<class T> class Handle;
 // Export all symbols in `CommonCompilerTestImpl` for dex2oat tests.
 class EXPORT CommonCompilerTestImpl {
  public:
-  static std::unique_ptr<CompilerOptions> CreateCompilerOptions(InstructionSet instruction_set,
-                                                                const std::string& variant);
+  // Create compiler options from the given instruction set and variant. Optionally use a string of
+  // instruction set features in addition to the features from the variant.
+  static std::unique_ptr<CompilerOptions> CreateCompilerOptions(
+      InstructionSet instruction_set,
+      const std::string& variant,
+      const std::optional<std::string>& extra_features = std::nullopt);
 
   CommonCompilerTestImpl();
   virtual ~CommonCompilerTestImpl();
diff --git a/compiler/compiler.h b/compiler/compiler.h
index 843bbbb083..196b729b91 100644
--- a/compiler/compiler.h
+++ b/compiler/compiler.h
@@ -55,7 +55,6 @@ class Compiler {
 
   virtual CompiledMethod* Compile(const dex::CodeItem* code_item,
                                   uint32_t access_flags,
-                                  InvokeType invoke_type,
                                   uint16_t class_def_idx,
                                   uint32_t method_idx,
                                   Handle<mirror::ClassLoader> class_loader,
diff --git a/compiler/compiler_reflection_test.cc b/compiler/compiler_reflection_test.cc
index f3c07db136..f9cc02f16e 100644
--- a/compiler/compiler_reflection_test.cc
+++ b/compiler/compiler_reflection_test.cc
@@ -35,7 +35,7 @@ TEST_F(CompilerReflectionTest, StaticMainMethod) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
-  ObjPtr<mirror::Class> klass = class_linker_->FindClass(soa.Self(), "LMain;", class_loader);
+  ObjPtr<mirror::Class> klass = FindClass("LMain;", class_loader);
   ASSERT_TRUE(klass != nullptr);
 
   ArtMethod* method = klass->FindClassMethod("main",
diff --git a/compiler/dex/inline_method_analyser.cc b/compiler/dex/inline_method_analyser.cc
index 85cf83c099..c84d296c4e 100644
--- a/compiler/dex/inline_method_analyser.cc
+++ b/compiler/dex/inline_method_analyser.cc
@@ -62,6 +62,10 @@ class Matcher {
   bool Const0();
   bool IPutOnThis();
 
+  // Match Fn1 or Fn2. This should be used in combination of e.g. Required.
+  template <bool (Matcher::*Fn1)(), bool (Matcher::*Fn2)()>
+  bool Or();
+
  private:
   explicit Matcher(const CodeItemDataAccessor* code_item)
       : code_item_(code_item),
@@ -126,6 +130,11 @@ bool Matcher::IPutOnThis() {
       instruction_->VRegB_22c() == code_item_->RegistersSize() - code_item_->InsSize();
 }
 
+template <bool (Matcher::*Fn1)(), bool (Matcher::*Fn2)()>
+bool Matcher::Or() {
+  return (this->*Fn1)() || (this->*Fn2)();
+}
+
 bool Matcher::DoMatch(const CodeItemDataAccessor* code_item, MatchFn* const* pattern, size_t size) {
   Matcher matcher(code_item);
   while (matcher.pos_ != size) {
@@ -140,13 +149,18 @@ bool Matcher::DoMatch(const CodeItemDataAccessor* code_item, MatchFn* const* pat
 // sure we invoke a constructor either in the same class or superclass with at least "this".
 ArtMethod* GetTargetConstructor(ArtMethod* method, const Instruction* invoke_direct)
     REQUIRES_SHARED(Locks::mutator_lock_) {
-  DCHECK_EQ(invoke_direct->Opcode(), Instruction::INVOKE_DIRECT);
+  DCHECK(invoke_direct->Opcode() == Instruction::INVOKE_DIRECT ||
+         invoke_direct->Opcode() == Instruction::INVOKE_DIRECT_RANGE);
   if (kIsDebugBuild) {
+    uint16_t vregc = invoke_direct->Opcode() == Instruction::INVOKE_DIRECT
+                         ? invoke_direct->VRegC_35c()
+                         : invoke_direct->VRegC_3rc();
     CodeItemDataAccessor accessor(method->DexInstructionData());
-    DCHECK_EQ(invoke_direct->VRegC_35c(),
-              accessor.RegistersSize() - accessor.InsSize());
+    DCHECK_EQ(vregc, accessor.RegistersSize() - accessor.InsSize());
   }
-  uint32_t method_index = invoke_direct->VRegB_35c();
+  uint32_t method_index = invoke_direct->Opcode() == Instruction::INVOKE_DIRECT
+                              ? invoke_direct->VRegB_35c()
+                              : invoke_direct->VRegB_3rc();
   ArtMethod* target_method = Runtime::Current()->GetClassLinker()->LookupResolvedMethod(
       method_index, method->GetDexCache(), method->GetClassLoader());
   if (kIsDebugBuild && target_method != nullptr) {
@@ -162,25 +176,47 @@ ArtMethod* GetTargetConstructor(ArtMethod* method, const Instruction* invoke_dir
 size_t CountForwardedConstructorArguments(const CodeItemDataAccessor* code_item,
                                           const Instruction* invoke_direct,
                                           uint16_t zero_vreg_mask) {
-  DCHECK_EQ(invoke_direct->Opcode(), Instruction::INVOKE_DIRECT);
-  size_t number_of_args = invoke_direct->VRegA_35c();
+  DCHECK(invoke_direct->Opcode() == Instruction::INVOKE_DIRECT ||
+         invoke_direct->Opcode() == Instruction::INVOKE_DIRECT_RANGE);
+  size_t number_of_args = invoke_direct->Opcode() == Instruction::INVOKE_DIRECT
+                              ? invoke_direct->VRegA_35c()
+                              : invoke_direct->VRegA_3rc();
   DCHECK_NE(number_of_args, 0u);
-  uint32_t args[Instruction::kMaxVarArgRegs];
-  invoke_direct->GetVarArgs(args);
-  uint16_t this_vreg = args[0];
-  DCHECK_EQ(this_vreg, code_item->RegistersSize() - code_item->InsSize());  // Checked by verifier.
-  size_t forwarded = 1u;
-  while (forwarded < number_of_args &&
-      args[forwarded] == this_vreg + forwarded &&
-      (zero_vreg_mask & (1u << args[forwarded])) == 0) {
-    ++forwarded;
-  }
-  for (size_t i = forwarded; i != number_of_args; ++i) {
-    if ((zero_vreg_mask & (1u << args[i])) == 0) {
-      return static_cast<size_t>(-1);
+
+  if (invoke_direct->Opcode() == Instruction::INVOKE_DIRECT) {
+    uint32_t args[Instruction::kMaxVarArgRegs];
+    invoke_direct->GetVarArgs(args);
+    uint16_t this_vreg = args[0];
+    DCHECK_EQ(this_vreg,
+              code_item->RegistersSize() - code_item->InsSize());  // Checked by verifier.
+    size_t forwarded = 1u;
+    while (forwarded < number_of_args &&
+        args[forwarded] == this_vreg + forwarded &&
+        (zero_vreg_mask & (1u << args[forwarded])) == 0) {
+      ++forwarded;
+    }
+    for (size_t i = forwarded; i != number_of_args; ++i) {
+      if ((zero_vreg_mask & (1u << args[i])) == 0) {
+        return static_cast<size_t>(-1);
+      }
     }
+    return forwarded;
+  } else {
+    uint16_t this_vreg = invoke_direct->VRegC_3rc();
+    DCHECK_EQ(this_vreg,
+              code_item->RegistersSize() - code_item->InsSize());  // Checked by verifier.
+    size_t forwarded = 1u;
+    while (forwarded < number_of_args &&
+           (zero_vreg_mask & (1u << (this_vreg + forwarded))) == 0) {
+      ++forwarded;
+    }
+    for (size_t i = forwarded; i != number_of_args; ++i) {
+      if ((zero_vreg_mask & (1u << (this_vreg + i))) == 0) {
+        return static_cast<size_t>(-1);
+      }
+    }
+    return forwarded;
   }
-  return forwarded;
 }
 
 uint16_t GetZeroVRegMask(const Instruction* const0) {
@@ -210,7 +246,8 @@ bool RecordConstructorIPut(ArtMethod* method,
                            const Instruction* new_iput,
                            uint16_t this_vreg,
                            uint16_t zero_vreg_mask,
-                           /*inout*/ ConstructorIPutData (&iputs)[kMaxConstructorIPuts])
+                           /*inout*/ ConstructorIPutData (&iputs)[kMaxConstructorIPuts],
+                           /*inout*/ size_t& iput_count)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(IsInstructionIPut(new_iput->Opcode()));
   uint32_t field_index = new_iput->VRegC_22c();
@@ -221,46 +258,38 @@ bool RecordConstructorIPut(ArtMethod* method,
   }
   // Remove previous IPUT to the same field, if any. Different field indexes may refer
   // to the same field, so we need to compare resolved fields from the dex cache.
-  for (size_t old_pos = 0; old_pos != arraysize(iputs); ++old_pos) {
-    if (iputs[old_pos].field_index == DexFile::kDexNoIndex16) {
-      break;
-    }
+  for (size_t old_pos = 0, end = iput_count; old_pos < end; ++old_pos) {
     ArtField* f = class_linker->LookupResolvedField(iputs[old_pos].field_index,
                                                     method,
                                                     /* is_static= */ false);
     DCHECK(f != nullptr);
     if (f == field) {
-      auto back_it = std::copy(iputs + old_pos + 1, iputs + arraysize(iputs), iputs + old_pos);
+      auto back_it = std::copy(iputs + old_pos + 1, iputs + iput_count, iputs + old_pos);
       *back_it = ConstructorIPutData();
+      --iput_count;
       break;
     }
   }
   // If the stored value isn't zero, record the IPUT.
   if ((zero_vreg_mask & (1u << new_iput->VRegA_22c())) == 0u) {
-    size_t new_pos = 0;
-    while (new_pos != arraysize(iputs) && iputs[new_pos].field_index != DexFile::kDexNoIndex16) {
-      ++new_pos;
-    }
+    size_t new_pos = iput_count;
     if (new_pos == arraysize(iputs)) {
       return false;  // Exceeded capacity of the output array.
     }
     iputs[new_pos].field_index = field_index;
     iputs[new_pos].arg = new_iput->VRegA_22c() - this_vreg;
+    ++iput_count;
   }
   return true;
 }
 
 bool DoAnalyseConstructor(const CodeItemDataAccessor* code_item,
                           ArtMethod* method,
-                          /*inout*/ ConstructorIPutData (&iputs)[kMaxConstructorIPuts])
+                          /*inout*/ ConstructorIPutData (&iputs)[kMaxConstructorIPuts],
+                          /*inout*/ size_t &iput_count)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   // On entry we should not have any IPUTs yet.
-  DCHECK(std::all_of(
-      iputs,
-      iputs + arraysize(iputs),
-      [](const ConstructorIPutData& iput_data) {
-        return iput_data.field_index == DexFile::kDexNoIndex16;
-      }));
+  DCHECK_EQ(iput_count, 0u);
 
   // Limit the maximum number of code units we're willing to match.
   static constexpr size_t kMaxCodeUnits = 16u;
@@ -278,10 +307,12 @@ bool DoAnalyseConstructor(const CodeItemDataAccessor* code_item,
   // of the parameters or 0 and the code must then finish with RETURN_VOID.
   // The called constructor must be either java.lang.Object.<init>() or it
   // must also match the same pattern.
-  static Matcher::MatchFn* const kConstructorPattern[] = {
+  static constexpr Matcher::MatchFn* const kConstructorPattern[] = {
       &Matcher::Mark,
       &Matcher::Repeated<&Matcher::Const0>,
-      &Matcher::Required<&Matcher::Opcode<Instruction::INVOKE_DIRECT>>,
+      // Either invoke-direct or invoke-direct/range works
+      &Matcher::Required<&Matcher::Or<&Matcher::Opcode<Instruction::INVOKE_DIRECT>,
+                                      &Matcher::Opcode<Instruction::INVOKE_DIRECT_RANGE>>>,
       &Matcher::Mark,
       &Matcher::Repeated<&Matcher::Const0>,
       &Matcher::Repeated<&Matcher::IPutOnThis>,
@@ -307,15 +338,19 @@ bool DoAnalyseConstructor(const CodeItemDataAccessor* code_item,
     const Instruction& instruction = pair.Inst();
     if (instruction.Opcode() == Instruction::RETURN_VOID) {
       break;
-    } else if (instruction.Opcode() == Instruction::INVOKE_DIRECT) {
+    } else if (instruction.Opcode() == Instruction::INVOKE_DIRECT ||
+               instruction.Opcode() == Instruction::INVOKE_DIRECT_RANGE) {
       ArtMethod* target_method = GetTargetConstructor(method, &instruction);
       if (target_method == nullptr) {
         return false;
       }
       // We allow forwarding constructors only if they pass more arguments
       // to prevent infinite recursion.
+      size_t number_of_args = instruction.Opcode() == Instruction::INVOKE_DIRECT
+                                  ? instruction.VRegA_35c()
+                                  : instruction.VRegA_3rc();
       if (target_method->GetDeclaringClass() == method->GetDeclaringClass() &&
-          instruction.VRegA_35c() <= code_item->InsSize()) {
+          number_of_args <= code_item->InsSize()) {
         return false;
       }
       size_t forwarded = CountForwardedConstructorArguments(code_item, &instruction, zero_vreg_mask);
@@ -329,21 +364,21 @@ bool DoAnalyseConstructor(const CodeItemDataAccessor* code_item,
         if (!target_code_item.HasCodeItem()) {
           return false;  // Native constructor?
         }
-        if (!DoAnalyseConstructor(&target_code_item, target_method, iputs)) {
+        if (!DoAnalyseConstructor(&target_code_item, target_method, iputs, iput_count)) {
           return false;
         }
         // Prune IPUTs with zero input.
         auto kept_end = std::remove_if(
             iputs,
-            iputs + arraysize(iputs),
+            iputs + iput_count,
             [forwarded](const ConstructorIPutData& iput_data) {
               return iput_data.arg >= forwarded;
             });
+        iput_count = std::distance(iputs, kept_end);
         std::fill(kept_end, iputs + arraysize(iputs), ConstructorIPutData());
         // If we have any IPUTs from the call, check that the target method is in the same
         // dex file (compare DexCache references), otherwise field_indexes would be bogus.
-        if (iputs[0].field_index != DexFile::kDexNoIndex16 &&
-            target_method->GetDexCache() != method->GetDexCache()) {
+        if (iput_count > 0u && target_method->GetDexCache() != method->GetDexCache()) {
           return false;
         }
       }
@@ -355,7 +390,12 @@ bool DoAnalyseConstructor(const CodeItemDataAccessor* code_item,
     } else {
       DCHECK(IsInstructionIPut(instruction.Opcode()));
       DCHECK_EQ(instruction.VRegB_22c(), this_vreg);
-      if (!RecordConstructorIPut(method, &instruction, this_vreg, zero_vreg_mask, iputs)) {
+      if (!RecordConstructorIPut(method,
+                                 &instruction,
+                                 this_vreg,
+                                 zero_vreg_mask,
+                                 iputs,
+                                 iput_count)) {
         return false;
       }
     }
@@ -369,15 +409,13 @@ bool AnalyseConstructor(const CodeItemDataAccessor* code_item,
                         ArtMethod* method,
                         InlineMethod* result)
     REQUIRES_SHARED(Locks::mutator_lock_) {
+  size_t iput_count(0u);
   ConstructorIPutData iputs[kMaxConstructorIPuts];
-  if (!DoAnalyseConstructor(code_item, method, iputs)) {
+  if (!DoAnalyseConstructor(code_item, method, iputs, iput_count)) {
     return false;
   }
   static_assert(kMaxConstructorIPuts == 3, "Unexpected limit");  // Code below depends on this.
-  DCHECK_IMPLIES(iputs[0].field_index == DexFile::kDexNoIndex16,
-                 iputs[1].field_index == DexFile::kDexNoIndex16);
-  DCHECK_IMPLIES(iputs[1].field_index == DexFile::kDexNoIndex16,
-                 iputs[2].field_index == DexFile::kDexNoIndex16);
+  DCHECK_LE(iput_count, kMaxConstructorIPuts);
 
 #define STORE_IPUT(n)                                                         \
   do {                                                                        \
@@ -391,7 +429,7 @@ bool AnalyseConstructor(const CodeItemDataAccessor* code_item,
 #undef STORE_IPUT
 
   result->opcode = kInlineOpConstructor;
-  result->d.constructor_data.reserved = 0u;
+  result->d.constructor_data.iput_count = static_cast<uint16_t>(iput_count);
   return true;
 }
 
@@ -456,6 +494,7 @@ bool InlineMethodAnalyser::AnalyseMethodCode(ArtMethod* method,
     case Instruction::CONST_WIDE_32:
     case Instruction::CONST_WIDE_HIGH16:
     case Instruction::INVOKE_DIRECT:
+    case Instruction::INVOKE_DIRECT_RANGE:
       if (method != nullptr && !method->IsStatic() && method->IsConstructor()) {
         return AnalyseConstructor(code_item, method, result);
       }
diff --git a/compiler/dex/inline_method_analyser.h b/compiler/dex/inline_method_analyser.h
index 4cd5b824f1..68e8912c93 100644
--- a/compiler/dex/inline_method_analyser.h
+++ b/compiler/dex/inline_method_analyser.h
@@ -76,7 +76,7 @@ struct InlineConstructorData {
   uint16_t iput0_arg : 4;
   uint16_t iput1_arg : 4;
   uint16_t iput2_arg : 4;
-  uint16_t reserved : 4;
+  uint16_t iput_count: 4;
 };
 static_assert(sizeof(InlineConstructorData) == sizeof(uint64_t),
               "Invalid size of InlineConstructorData");
diff --git a/compiler/exception_test.cc b/compiler/exception_test.cc
index 0e289353c7..4eae96158e 100644
--- a/compiler/exception_test.cc
+++ b/compiler/exception_test.cc
@@ -61,7 +61,7 @@ class ExceptionTest : public CommonRuntimeTest {
     StackHandleScope<2> hs(soa.Self());
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("ExceptionHandle"))));
-    my_klass_ = class_linker_->FindClass(soa.Self(), "LExceptionHandle;", class_loader);
+    my_klass_ = FindClass("LExceptionHandle;", class_loader);
     ASSERT_TRUE(my_klass_ != nullptr);
     Handle<mirror::Class> klass(hs.NewHandle(my_klass_));
     class_linker_->EnsureInitialized(soa.Self(), klass, true, true);
diff --git a/compiler/jni/jni_compiler_test.cc b/compiler/jni/jni_compiler_test.cc
index 2f4a1b5f44..35ee1edafd 100644
--- a/compiler/jni/jni_compiler_test.cc
+++ b/compiler/jni/jni_compiler_test.cc
@@ -243,8 +243,7 @@ class JniCompilerTest : public CommonCompilerTest {
     Handle<mirror::ClassLoader> loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
     // Compile the native method before starting the runtime
-    Handle<mirror::Class> c =
-        hs.NewHandle(class_linker_->FindClass(self, "LMyClassNatives;", loader));
+    Handle<mirror::Class> c = hs.NewHandle(FindClass("LMyClassNatives;", loader));
     const auto pointer_size = class_linker_->GetImagePointerSize();
     ArtMethod* method = c->FindClassMethod(method_name, method_sig, pointer_size);
     ASSERT_TRUE(method != nullptr) << method_name << " " << method_sig;
diff --git a/compiler/linker/linker_patch.h b/compiler/linker/linker_patch.h
index b061e042f0..d73d88dcb2 100644
--- a/compiler/linker/linker_patch.h
+++ b/compiler/linker/linker_patch.h
@@ -50,6 +50,7 @@ class LinkerPatch {
     kIntrinsicReference,      // Boot image reference for an intrinsic, see IntrinsicObjects.
     kBootImageRelRo,
     kMethodRelative,
+    kMethodAppImageRelRo,
     kMethodBssEntry,
     kJniEntrypointRelative,
     kCallRelative,
@@ -93,6 +94,16 @@ class LinkerPatch {
     return patch;
   }
 
+  static LinkerPatch MethodAppImageRelRoPatch(size_t literal_offset,
+                                              const DexFile* target_dex_file,
+                                              uint32_t pc_insn_offset,
+                                              uint32_t target_method_idx) {
+    LinkerPatch patch(literal_offset, Type::kMethodAppImageRelRo, target_dex_file);
+    patch.method_idx_ = target_method_idx;
+    patch.pc_insn_offset_ = pc_insn_offset;
+    return patch;
+  }
+
   static LinkerPatch MethodBssEntryPatch(size_t literal_offset,
                                          const DexFile* target_dex_file,
                                          uint32_t pc_insn_offset,
@@ -244,6 +255,7 @@ class LinkerPatch {
 
   MethodReference TargetMethod() const {
     DCHECK(patch_type_ == Type::kMethodRelative ||
+           patch_type_ == Type::kMethodAppImageRelRo ||
            patch_type_ == Type::kMethodBssEntry ||
            patch_type_ == Type::kJniEntrypointRelative ||
            patch_type_ == Type::kCallRelative);
@@ -274,6 +286,7 @@ class LinkerPatch {
     DCHECK(patch_type_ == Type::kIntrinsicReference ||
            patch_type_ == Type::kBootImageRelRo ||
            patch_type_ == Type::kMethodRelative ||
+           patch_type_ == Type::kMethodAppImageRelRo ||
            patch_type_ == Type::kMethodBssEntry ||
            patch_type_ == Type::kJniEntrypointRelative ||
            patch_type_ == Type::kTypeRelative ||
@@ -282,7 +295,8 @@ class LinkerPatch {
            patch_type_ == Type::kPublicTypeBssEntry ||
            patch_type_ == Type::kPackageTypeBssEntry ||
            patch_type_ == Type::kStringRelative ||
-           patch_type_ == Type::kStringBssEntry);
+           patch_type_ == Type::kStringBssEntry ||
+           patch_type_ == Type::kMethodTypeBssEntry);
     return pc_insn_offset_;
   }
 
diff --git a/compiler/oat/jni_stub_hash_map_test.cc b/compiler/oat/jni_stub_hash_map_test.cc
index 2a26bcfae6..170381d988 100644
--- a/compiler/oat/jni_stub_hash_map_test.cc
+++ b/compiler/oat/jni_stub_hash_map_test.cc
@@ -88,8 +88,7 @@ class JniStubHashMapTest : public CommonCompilerTest {
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
     pointer_size_ = class_linker_->GetImagePointerSize();
-    ObjPtr<mirror::Class> klass =
-        class_linker_->FindClass(soa.Self(), "LMyClassNatives;", class_loader);
+    ObjPtr<mirror::Class> klass = FindClass("LMyClassNatives;", class_loader);
     ASSERT_TRUE(klass != nullptr);
     jklass_ = soa.AddLocalReference<jclass>(klass);
   }
diff --git a/compiler/optimizing/builder.cc b/compiler/optimizing/builder.cc
index 1dea39626c..a1318c917a 100644
--- a/compiler/optimizing/builder.cc
+++ b/compiler/optimizing/builder.cc
@@ -93,7 +93,6 @@ GraphAnalysisResult HGraphBuilder::BuildGraph() {
 
   graph_->SetNumberOfVRegs(code_item_accessor_.RegistersSize());
   graph_->SetNumberOfInVRegs(code_item_accessor_.InsSize());
-  graph_->SetMaximumNumberOfOutVRegs(code_item_accessor_.OutsSize());
 
   // Use ScopedArenaAllocator for all local allocations.
   ScopedArenaAllocator local_allocator(graph_->GetArenaStack());
@@ -157,7 +156,6 @@ void HGraphBuilder::BuildIntrinsicGraph(ArtMethod* method) {
   size_t return_vregs = 2u;
   graph_->SetNumberOfVRegs(return_vregs + num_arg_vregs);
   graph_->SetNumberOfInVRegs(num_arg_vregs);
-  graph_->SetMaximumNumberOfOutVRegs(num_arg_vregs);
 
   // Use ScopedArenaAllocator for all local allocations.
   ScopedArenaAllocator local_allocator(graph_->GetArenaStack());
diff --git a/compiler/optimizing/cha_guard_optimization.cc b/compiler/optimizing/cha_guard_optimization.cc
index 20a763cf6d..fb9d220a7b 100644
--- a/compiler/optimizing/cha_guard_optimization.cc
+++ b/compiler/optimizing/cha_guard_optimization.cc
@@ -30,7 +30,7 @@ namespace art HIDDEN {
 // As a consequence, we decided not to rely on other passes to remove them
 // (such as GVN or instruction simplifier).
 
-class CHAGuardVisitor : HGraphVisitor {
+class CHAGuardVisitor final : public HGraphVisitor {
  public:
   explicit CHAGuardVisitor(HGraph* graph)
       : HGraphVisitor(graph),
diff --git a/compiler/optimizing/code_generator.cc b/compiler/optimizing/code_generator.cc
index 51714ef548..cfccdb8934 100644
--- a/compiler/optimizing/code_generator.cc
+++ b/compiler/optimizing/code_generator.cc
@@ -377,7 +377,7 @@ void CodeGenerator::Compile() {
     RecordCatchBlockInfo();
   }
 
-  // Finalize instructions in assember;
+  // Finalize instructions in the assembler.
   Finalize();
 
   GetStackMapStream()->EndMethod(GetAssembler()->CodeSize());
@@ -632,11 +632,8 @@ void CodeGenerator::CreateStringBuilderAppendLocations(HStringBuilderAppend* ins
     stack_offset += sizeof(uint32_t);
   }
   DCHECK_EQ(f, 0u);
-
-  size_t param_size = stack_offset - static_cast<size_t>(pointer_size);
-  DCHECK_ALIGNED(param_size, kVRegSize);
-  size_t num_vregs = param_size / kVRegSize;
-  graph_->UpdateMaximumNumberOfOutVRegs(num_vregs);
+  DCHECK_EQ(stack_offset,
+            static_cast<size_t>(pointer_size) + kVRegSize * instruction->GetNumberOfOutVRegs());
 }
 
 void CodeGenerator::CreateUnresolvedFieldLocationSummary(
@@ -913,8 +910,9 @@ void CodeGenerator::BlockIfInRegister(Location location, bool is_out) const {
 }
 
 void CodeGenerator::AllocateLocations(HInstruction* instruction) {
+  ArenaAllocator* allocator = GetGraph()->GetAllocator();
   for (HEnvironment* env = instruction->GetEnvironment(); env != nullptr; env = env->GetParent()) {
-    env->AllocateLocations();
+    env->AllocateLocations(allocator);
   }
   instruction->Accept(GetLocationBuilder());
   DCHECK(CheckTypeConsistency(instruction));
diff --git a/compiler/optimizing/code_generator_arm64.cc b/compiler/optimizing/code_generator_arm64.cc
index 42d955ef9e..369d21af03 100644
--- a/compiler/optimizing/code_generator_arm64.cc
+++ b/compiler/optimizing/code_generator_arm64.cc
@@ -28,6 +28,7 @@
 #include "class_table.h"
 #include "code_generator_utils.h"
 #include "com_android_art_flags.h"
+#include "dex/dex_file_types.h"
 #include "entrypoints/quick/quick_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "gc/accounting/card_table.h"
@@ -138,6 +139,16 @@ inline Condition ARM64FPCondition(IfCondition cond, bool gt_bias) {
   }
 }
 
+Condition ARM64PCondition(HVecPredToBoolean::PCondKind cond) {
+  switch (cond) {
+    case HVecPredToBoolean::PCondKind::kFirst: return mi;
+    case HVecPredToBoolean::PCondKind::kNFirst: return pl;
+    default:
+      LOG(FATAL) << "Unsupported condition type: " << enum_cast<uint32_t>(cond);
+      UNREACHABLE();
+  }
+}
+
 Location ARM64ReturnLocation(DataType::Type return_type) {
   // Note that in practice, `LocationFrom(x0)` and `LocationFrom(w0)` create the
   // same Location object, and so do `LocationFrom(d0)` and `LocationFrom(s0)`,
@@ -264,6 +275,42 @@ class DivZeroCheckSlowPathARM64 : public SlowPathCodeARM64 {
   DISALLOW_COPY_AND_ASSIGN(DivZeroCheckSlowPathARM64);
 };
 
+class LoadMethodTypeSlowPathARM64 : public SlowPathCodeARM64 {
+ public:
+  explicit LoadMethodTypeSlowPathARM64(HLoadMethodType* mt) : SlowPathCodeARM64(mt) {}
+
+  void EmitNativeCode(CodeGenerator* codegen) override {
+    LocationSummary* locations = instruction_->GetLocations();
+    Location out = locations->Out();
+    CodeGeneratorARM64* arm64_codegen = down_cast<CodeGeneratorARM64*>(codegen);
+
+    __ Bind(GetEntryLabel());
+    SaveLiveRegisters(codegen, locations);
+
+    InvokeRuntimeCallingConvention calling_convention;
+    const dex::ProtoIndex proto_index = instruction_->AsLoadMethodType()->GetProtoIndex();
+    __ Mov(calling_convention.GetRegisterAt(0).W(), proto_index.index_);
+
+    arm64_codegen->InvokeRuntime(kQuickResolveMethodType,
+                                 instruction_,
+                                 instruction_->GetDexPc(),
+                                 this);
+    CheckEntrypointTypes<kQuickResolveMethodType, void*, uint32_t>();
+
+    DataType::Type type = instruction_->GetType();
+    arm64_codegen->MoveLocation(out, calling_convention.GetReturnLocation(type), type);
+    RestoreLiveRegisters(codegen, locations);
+
+    __ B(GetExitLabel());
+  }
+
+  const char* GetDescription() const override { return "LoadMethodTypeSlowPathARM64"; }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(LoadMethodTypeSlowPathARM64);
+};
+
+
 class LoadClassSlowPathARM64 : public SlowPathCodeARM64 {
  public:
   LoadClassSlowPathARM64(HLoadClass* cls, HInstruction* at)
@@ -554,11 +601,19 @@ void JumpTableARM64::EmitTable(CodeGeneratorARM64* codegen) {
 
   // We are about to use the assembler to place literals directly. Make sure we have enough
   // underlying code buffer and we have generated the jump table with right size.
-  EmissionCheckScope scope(codegen->GetVIXLAssembler(),
+  ExactAssemblyScope scope(codegen->GetVIXLAssembler(),
                            num_entries * sizeof(int32_t),
                            CodeBufferCheckScope::kExactSize);
+  codegen->GetVIXLAssembler()->bind(&table_start_);
+  for (uint32_t i = 0; i < num_entries; i++) {
+    codegen->GetVIXLAssembler()->place(jump_targets_[i].get());
+  }
+}
+
+void JumpTableARM64::FixTable(CodeGeneratorARM64* codegen) {
+  uint32_t num_entries = switch_instr_->GetNumEntries();
+  DCHECK_GE(num_entries, kPackedSwitchCompareJumpThreshold);
 
-  __ Bind(&table_start_);
   const ArenaVector<HBasicBlock*>& successors = switch_instr_->GetBlock()->GetSuccessors();
   for (uint32_t i = 0; i < num_entries; i++) {
     vixl::aarch64::Label* target_label = codegen->GetLabelOf(successors[i]);
@@ -566,8 +621,7 @@ void JumpTableARM64::EmitTable(CodeGeneratorARM64* codegen) {
     ptrdiff_t jump_offset = target_label->GetLocation() - table_start_.GetLocation();
     DCHECK_GT(jump_offset, std::numeric_limits<int32_t>::min());
     DCHECK_LE(jump_offset, std::numeric_limits<int32_t>::max());
-    Literal<int32_t> literal(jump_offset);
-    __ place(&literal);
+    jump_targets_[i].get()->UpdateValue(jump_offset, codegen->GetVIXLAssembler());
   }
 }
 
@@ -1032,6 +1086,7 @@ CodeGeneratorARM64::CodeGeneratorARM64(HGraph* graph,
       assembler_(graph->GetAllocator(),
                  compiler_options.GetInstructionSetFeatures()->AsArm64InstructionSetFeatures()),
       boot_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      app_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       method_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       app_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -1040,6 +1095,7 @@ CodeGeneratorARM64::CodeGeneratorARM64(HGraph* graph,
       package_type_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_string_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       string_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      method_type_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_jni_entrypoint_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_other_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       call_entrypoint_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -1072,14 +1128,14 @@ size_t CodeGeneratorARM64::GetSIMDRegisterWidth() const {
 
 #define __ GetVIXLAssembler()->
 
-void CodeGeneratorARM64::EmitJumpTables() {
+void CodeGeneratorARM64::FixJumpTables() {
   for (auto&& jump_table : jump_tables_) {
-    jump_table->EmitTable(this);
+    jump_table->FixTable(this);
   }
 }
 
 void CodeGeneratorARM64::Finalize() {
-  EmitJumpTables();
+  FixJumpTables();
 
   // Emit JIT baker read barrier slow paths.
   DCHECK(GetCompilerOptions().IsJitCompiler() || jit_baker_read_barrier_slow_paths_.empty());
@@ -4952,6 +5008,19 @@ void CodeGeneratorARM64::LoadMethod(MethodLoadKind load_kind, Location temp, HIn
       LoadBootImageRelRoEntry(WRegisterFrom(temp), boot_image_offset);
       break;
     }
+    case MethodLoadKind::kAppImageRelRo: {
+      DCHECK(GetCompilerOptions().IsAppImage());
+      // Add ADRP with its PC-relative method patch.
+      vixl::aarch64::Label* adrp_label =
+          NewAppImageMethodPatch(invoke->GetResolvedMethodReference());
+      EmitAdrpPlaceholder(adrp_label, XRegisterFrom(temp));
+      // Add LDR with its PC-relative method patch.
+      // Note: App image is in the low 4GiB and the entry is 32-bit, so emit a 32-bit load.
+      vixl::aarch64::Label* ldr_label =
+          NewAppImageMethodPatch(invoke->GetResolvedMethodReference(), adrp_label);
+      EmitLdrOffsetPlaceholder(ldr_label, WRegisterFrom(temp), XRegisterFrom(temp));
+      break;
+    }
     case MethodLoadKind::kBssEntry: {
       // Add ADRP with its PC-relative .bss entry patch.
       vixl::aarch64::Label* adrp_label = NewMethodBssEntryPatch(invoke->GetMethodReference());
@@ -5210,6 +5279,13 @@ vixl::aarch64::Label* CodeGeneratorARM64::NewBootImageMethodPatch(
       target_method.dex_file, target_method.index, adrp_label, &boot_image_method_patches_);
 }
 
+vixl::aarch64::Label* CodeGeneratorARM64::NewAppImageMethodPatch(
+    MethodReference target_method,
+    vixl::aarch64::Label* adrp_label) {
+  return NewPcRelativePatch(
+      target_method.dex_file, target_method.index, adrp_label, &app_image_method_patches_);
+}
+
 vixl::aarch64::Label* CodeGeneratorARM64::NewMethodBssEntryPatch(
     MethodReference target_method,
     vixl::aarch64::Label* adrp_label) {
@@ -5269,6 +5345,15 @@ vixl::aarch64::Label* CodeGeneratorARM64::NewStringBssEntryPatch(
   return NewPcRelativePatch(&dex_file, string_index.index_, adrp_label, &string_bss_entry_patches_);
 }
 
+vixl::aarch64::Label* CodeGeneratorARM64::NewMethodTypeBssEntryPatch(
+    HLoadMethodType* load_method_type,
+    vixl::aarch64::Label* adrp_label) {
+  return NewPcRelativePatch(&load_method_type->GetDexFile(),
+                            load_method_type->GetProtoIndex().index_,
+                            adrp_label,
+                            &method_type_bss_entry_patches_);
+}
+
 vixl::aarch64::Label* CodeGeneratorARM64::NewBootImageJniEntrypointPatch(
     MethodReference target_method,
     vixl::aarch64::Label* adrp_label) {
@@ -5439,6 +5524,7 @@ void CodeGeneratorARM64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* lin
   DCHECK(linker_patches->empty());
   size_t size =
       boot_image_method_patches_.size() +
+      app_image_method_patches_.size() +
       method_bss_entry_patches_.size() +
       boot_image_type_patches_.size() +
       app_image_type_patches_.size() +
@@ -5447,6 +5533,7 @@ void CodeGeneratorARM64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* lin
       package_type_bss_entry_patches_.size() +
       boot_image_string_patches_.size() +
       string_bss_entry_patches_.size() +
+      method_type_bss_entry_patches_.size() +
       boot_image_jni_entrypoint_patches_.size() +
       boot_image_other_patches_.size() +
       call_entrypoint_patches_.size() +
@@ -5464,6 +5551,7 @@ void CodeGeneratorARM64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* lin
     DCHECK(boot_image_type_patches_.empty());
     DCHECK(boot_image_string_patches_.empty());
   }
+  DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_method_patches_.empty());
   DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_type_patches_.empty());
   if (GetCompilerOptions().IsBootImage()) {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::IntrinsicReferencePatch>>(
@@ -5471,6 +5559,8 @@ void CodeGeneratorARM64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* lin
   } else {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::BootImageRelRoPatch>>(
         boot_image_other_patches_, linker_patches);
+    EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodAppImageRelRoPatch>(
+        app_image_method_patches_, linker_patches);
     EmitPcRelativeLinkerPatches<linker::LinkerPatch::TypeAppImageRelRoPatch>(
         app_image_type_patches_, linker_patches);
   }
@@ -5484,6 +5574,8 @@ void CodeGeneratorARM64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* lin
       package_type_bss_entry_patches_, linker_patches);
   EmitPcRelativeLinkerPatches<linker::LinkerPatch::StringBssEntryPatch>(
       string_bss_entry_patches_, linker_patches);
+  EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodTypeBssEntryPatch>(
+      method_type_bss_entry_patches_, linker_patches);
   EmitPcRelativeLinkerPatches<linker::LinkerPatch::RelativeJniEntrypointPatch>(
       boot_image_jni_entrypoint_patches_, linker_patches);
   for (const PatchInfo<vixl::aarch64::Label>& info : call_entrypoint_patches_) {
@@ -5782,13 +5874,70 @@ void InstructionCodeGeneratorARM64::VisitLoadMethodHandle(HLoadMethodHandle* loa
 }
 
 void LocationsBuilderARM64::VisitLoadMethodType(HLoadMethodType* load) {
-  InvokeRuntimeCallingConvention calling_convention;
-  Location location = LocationFrom(calling_convention.GetRegisterAt(0));
-  CodeGenerator::CreateLoadMethodTypeRuntimeCallLocationSummary(load, location, location);
+  if (load->GetLoadKind() == HLoadMethodType::LoadKind::kRuntimeCall) {
+    InvokeRuntimeCallingConvention calling_convention;
+    Location location = LocationFrom(calling_convention.GetRegisterAt(0));
+    CodeGenerator::CreateLoadMethodTypeRuntimeCallLocationSummary(load, location, location);
+  } else {
+    LocationSummary* locations =
+        new (GetGraph()->GetAllocator()) LocationSummary(load, LocationSummary::kCallOnSlowPath);
+    locations->SetOut(Location::RequiresRegister());
+    if (load->GetLoadKind() == HLoadMethodType::LoadKind::kBssEntry) {
+      if (codegen_->EmitNonBakerReadBarrier()) {
+        // For non-Baker read barrier we have a temp-clobbering call.
+      } else {
+        // Rely on the pResolveMethodType to save everything.
+        locations->SetCustomSlowPathCallerSaves(OneRegInReferenceOutSaveEverythingCallerSaves());
+      }
+    }
+  }
 }
 
 void InstructionCodeGeneratorARM64::VisitLoadMethodType(HLoadMethodType* load) {
-  codegen_->GenerateLoadMethodTypeRuntimeCall(load);
+  Location out_loc = load->GetLocations()->Out();
+  Register out = OutputRegister(load);
+
+  switch (load->GetLoadKind()) {
+    case HLoadMethodType::LoadKind::kBssEntry: {
+      // Add ADRP with its PC-relative Class .bss entry patch.
+      vixl::aarch64::Register temp = XRegisterFrom(out_loc);
+      vixl::aarch64::Label* adrp_label = codegen_->NewMethodTypeBssEntryPatch(load);
+      codegen_->EmitAdrpPlaceholder(adrp_label, temp);
+      // Add LDR with its PC-relative MethodType .bss entry patch.
+      vixl::aarch64::Label* ldr_label = codegen_->NewMethodTypeBssEntryPatch(load, adrp_label);
+      // /* GcRoot<mirror::MethodType> */ out = *(base_address + offset)  /* PC-relative */
+      // All aligned loads are implicitly atomic consume operations on ARM64.
+      codegen_->GenerateGcRootFieldLoad(load,
+                                        out_loc,
+                                        temp,
+                                        /* offset placeholder */ 0u,
+                                        ldr_label,
+                                        codegen_->GetCompilerReadBarrierOption());
+      SlowPathCodeARM64* slow_path =
+          new (codegen_->GetScopedAllocator()) LoadMethodTypeSlowPathARM64(load);
+      codegen_->AddSlowPath(slow_path);
+      __ Cbz(out, slow_path->GetEntryLabel());
+      __ Bind(slow_path->GetExitLabel());
+      codegen_->MaybeGenerateMarkingRegisterCheck(/* code = */ __LINE__);
+      return;
+    }
+    case HLoadMethodType::LoadKind::kJitTableAddress: {
+      __ Ldr(out, codegen_->DeduplicateJitMethodTypeLiteral(load->GetDexFile(),
+                                                            load->GetProtoIndex(),
+                                                            load->GetMethodType()));
+      codegen_->GenerateGcRootFieldLoad(load,
+                                        out_loc,
+                                        out.X(),
+                                        /* offset= */ 0,
+                                        /* fixup_label= */ nullptr,
+                                        codegen_->GetCompilerReadBarrierOption());
+      return;
+    }
+    default:
+      DCHECK_EQ(load->GetLoadKind(), HLoadMethodType::LoadKind::kRuntimeCall);
+      codegen_->GenerateLoadMethodTypeRuntimeCall(load);
+      break;
+  }
 }
 
 static MemOperand GetExceptionTlsAddress() {
@@ -6709,17 +6858,7 @@ void InstructionCodeGeneratorARM64::VisitPackedSwitch(HPackedSwitch* switch_inst
   Register value_reg = InputRegisterAt(switch_instr, 0);
   HBasicBlock* default_block = switch_instr->GetDefaultBlock();
 
-  // Roughly set 16 as max average assemblies generated per HIR in a graph.
-  static constexpr int32_t kMaxExpectedSizePerHInstruction = 16 * kInstructionSize;
-  // ADR has a limited range(+/-1MB), so we set a threshold for the number of HIRs in the graph to
-  // make sure we don't emit it if the target may run out of range.
-  // TODO: Instead of emitting all jump tables at the end of the code, we could keep track of ADR
-  // ranges and emit the tables only as required.
-  static constexpr int32_t kJumpTableInstructionThreshold = 1* MB / kMaxExpectedSizePerHInstruction;
-
-  if (num_entries <= kPackedSwitchCompareJumpThreshold ||
-      // Current instruction id is an upper bound of the number of HIRs in the graph.
-      GetGraph()->GetCurrentInstructionId() > kJumpTableInstructionThreshold) {
+  if (num_entries <= kPackedSwitchCompareJumpThreshold) {
     // Create a series of compare/jumps.
     UseScratchRegisterScope temps(codegen_->GetVIXLAssembler());
     Register temp = temps.AcquireW();
@@ -6771,15 +6910,25 @@ void InstructionCodeGeneratorARM64::VisitPackedSwitch(HPackedSwitch* switch_inst
     // immediate value for Adr. So we are free to use both VIXL blocked registers to reduce the
     // register pressure.
     Register table_base = temps.AcquireX();
+
+    const size_t jump_size = switch_instr->GetNumEntries() * sizeof(int32_t);
+    ExactAssemblyScope scope(codegen_->GetVIXLAssembler(),
+                             kInstructionSize * 4 + jump_size,
+                             CodeBufferCheckScope::kExactSize);
+
     // Load jump offset from the table.
-    __ Adr(table_base, jump_table->GetTableStartLabel());
+    // Note: the table start address is always in range as the table is emitted immediately
+    // after these 4 instructions.
+    __ adr(table_base, jump_table->GetTableStartLabel());
     Register jump_offset = temp_w;
-    __ Ldr(jump_offset, MemOperand(table_base, index, UXTW, 2));
+    __ ldr(jump_offset, MemOperand(table_base, index, UXTW, 2));
 
     // Jump to target block by branching to table_base(pc related) + offset.
     Register target_address = table_base;
-    __ Add(target_address, table_base, Operand(jump_offset, SXTW));
-    __ Br(target_address);
+    __ add(target_address, table_base, Operand(jump_offset, SXTW));
+    __ br(target_address);
+
+    jump_table->EmitTable(codegen_);
   }
 }
 
diff --git a/compiler/optimizing/code_generator_arm64.h b/compiler/optimizing/code_generator_arm64.h
index 9f226e9e63..7fefec93ff 100644
--- a/compiler/optimizing/code_generator_arm64.h
+++ b/compiler/optimizing/code_generator_arm64.h
@@ -130,6 +130,8 @@ const vixl::aarch64::CPURegList callee_saved_fp_registers(vixl::aarch64::CPURegi
                                                           vixl::aarch64::d15.GetCode());
 Location ARM64ReturnLocation(DataType::Type return_type);
 
+vixl::aarch64::Condition ARM64PCondition(HVecPredToBoolean::PCondKind cond);
+
 #define UNIMPLEMENTED_INTRINSIC_LIST_ARM64(V) \
   V(MathSignumFloat)                          \
   V(MathSignumDouble)                         \
@@ -158,7 +160,6 @@ Location ARM64ReturnLocation(DataType::Type return_type);
   V(SystemArrayCopyInt)                       \
   V(UnsafeArrayBaseOffset)                    \
   /* 1.8 */                                   \
-  V(MethodHandleInvokeExact)                  \
   V(MethodHandleInvoke)                       \
   /* OpenJDK 11 */                            \
   V(JdkUnsafeArrayBaseOffset)
@@ -183,17 +184,35 @@ class SlowPathCodeARM64 : public SlowPathCode {
 
 class JumpTableARM64 : public DeletableArenaObject<kArenaAllocSwitchTable> {
  public:
+  using VIXLInt32Literal = vixl::aarch64::Literal<int32_t>;
+
   explicit JumpTableARM64(HPackedSwitch* switch_instr)
-    : switch_instr_(switch_instr), table_start_() {}
+      : switch_instr_(switch_instr),
+        table_start_(),
+        jump_targets_(switch_instr->GetAllocator()->Adapter(kArenaAllocCodeGenerator)) {
+      uint32_t num_entries = switch_instr_->GetNumEntries();
+      for (uint32_t i = 0; i < num_entries; i++) {
+        VIXLInt32Literal* lit = new VIXLInt32Literal(0);
+        jump_targets_.emplace_back(lit);
+      }
+    }
 
   vixl::aarch64::Label* GetTableStartLabel() { return &table_start_; }
 
+  // Emits the jump table into the code buffer; jump target offsets are not yet known.
   void EmitTable(CodeGeneratorARM64* codegen);
 
+  // Updates the offsets in the jump table, to be used when the jump targets basic blocks
+  // addresses are resolved.
+  void FixTable(CodeGeneratorARM64* codegen);
+
  private:
   HPackedSwitch* const switch_instr_;
   vixl::aarch64::Label table_start_;
 
+  // Contains literals for the switch's jump targets.
+  ArenaVector<std::unique_ptr<VIXLInt32Literal>> jump_targets_;
+
   DISALLOW_COPY_AND_ASSIGN(JumpTableARM64);
 };
 
@@ -582,6 +601,14 @@ class InstructionCodeGeneratorARM64Sve : public InstructionCodeGeneratorARM64 {
       return vixl::aarch64::p2;
     }
   }
+
+  // Generate a vector comparison instruction based on the IfCondition.
+  void GenerateIntegerVecComparison(const vixl::aarch64::PRegisterWithLaneSize& pd,
+                                    const vixl::aarch64::PRegisterZ& pg,
+                                    const vixl::aarch64::ZRegister& zn,
+                                    const vixl::aarch64::ZRegister& zm,
+                                    IfCondition cond);
+  void HandleVecCondition(HVecCondition* instruction);
 };
 
 class LocationsBuilderARM64Sve : public LocationsBuilderARM64 {
@@ -595,6 +622,8 @@ class LocationsBuilderARM64Sve : public LocationsBuilderARM64 {
   FOR_EACH_CONCRETE_INSTRUCTION_VECTOR_COMMON(DECLARE_VISIT_INSTRUCTION)
 
 #undef DECLARE_VISIT_INSTRUCTION
+ private:
+  void HandleVecCondition(HVecCondition* instruction);
 };
 
 class ParallelMoveResolverARM64 : public ParallelMoveResolverNoSwap {
@@ -818,6 +847,13 @@ class CodeGeneratorARM64 : public CodeGenerator {
   vixl::aarch64::Label* NewBootImageMethodPatch(MethodReference target_method,
                                                 vixl::aarch64::Label* adrp_label = nullptr);
 
+  // Add a new app image method patch for an instruction and return the label
+  // to be bound before the instruction. The instruction will be either the
+  // ADRP (pass `adrp_label = null`) or the LDR (pass `adrp_label` pointing
+  // to the associated ADRP patch label).
+  vixl::aarch64::Label* NewAppImageMethodPatch(MethodReference target_method,
+                                               vixl::aarch64::Label* adrp_label = nullptr);
+
   // Add a new .bss entry method patch for an instruction and return
   // the label to be bound before the instruction. The instruction will be
   // either the ADRP (pass `adrp_label = null`) or the LDR (pass `adrp_label`
@@ -864,6 +900,13 @@ class CodeGeneratorARM64 : public CodeGenerator {
                                                dex::StringIndex string_index,
                                                vixl::aarch64::Label* adrp_label = nullptr);
 
+  // Add a new .bss entry MethodType patch for an instruction and return the label
+  // to be bound before the instruction. The instruction will be either the
+  // ADRP (pass `adrp_label = null`) or the ADD (pass `adrp_label` pointing
+  // to the associated ADRP patch label).
+  vixl::aarch64::Label* NewMethodTypeBssEntryPatch(HLoadMethodType* load_method_type,
+                                                   vixl::aarch64::Label* adrp_label = nullptr);
+
   // Add a new boot image JNI entrypoint patch for an instruction and return the label
   // to be bound before the instruction. The instruction will be either the
   // ADRP (pass `adrp_label = null`) or the LDR (pass `adrp_label` pointing
@@ -893,6 +936,13 @@ class CodeGeneratorARM64 : public CodeGenerator {
     return jit_patches_.DeduplicateJitClassLiteral(
         dex_file, class_index, handle, GetCodeGenerationData());
   }
+  vixl::aarch64::Literal<uint32_t>* DeduplicateJitMethodTypeLiteral(
+      const DexFile& dex_file,
+      dex::ProtoIndex proto_index,
+      Handle<mirror::MethodType> handle) {
+    return jit_patches_.DeduplicateJitMethodTypeLiteral(
+        dex_file, proto_index, handle, GetCodeGenerationData());
+  }
 
   void EmitAdrpPlaceholder(vixl::aarch64::Label* fixup_label, vixl::aarch64::Register reg);
   void EmitAddPlaceholder(vixl::aarch64::Label* fixup_label,
@@ -1144,7 +1194,7 @@ class CodeGeneratorARM64 : public CodeGenerator {
                                            vixl::aarch64::Label* adrp_label,
                                            ArenaDeque<PcRelativePatchInfo>* patches);
 
-  void EmitJumpTables();
+  void FixJumpTables();
 
   template <linker::LinkerPatch (*Factory)(size_t, const DexFile*, uint32_t, uint32_t)>
   static void EmitPcRelativeLinkerPatches(const ArenaDeque<PcRelativePatchInfo>& infos,
@@ -1171,6 +1221,8 @@ class CodeGeneratorARM64 : public CodeGenerator {
 
   // PC-relative method patch info for kBootImageLinkTimePcRelative.
   ArenaDeque<PcRelativePatchInfo> boot_image_method_patches_;
+  // PC-relative method patch info for kAppImageRelRo.
+  ArenaDeque<PcRelativePatchInfo> app_image_method_patches_;
   // PC-relative method patch info for kBssEntry.
   ArenaDeque<PcRelativePatchInfo> method_bss_entry_patches_;
   // PC-relative type patch info for kBootImageLinkTimePcRelative.
@@ -1187,6 +1239,8 @@ class CodeGeneratorARM64 : public CodeGenerator {
   ArenaDeque<PcRelativePatchInfo> boot_image_string_patches_;
   // PC-relative String patch info for kBssEntry.
   ArenaDeque<PcRelativePatchInfo> string_bss_entry_patches_;
+  // PC-relative MethodType patch info for kBssEntry.
+  ArenaDeque<PcRelativePatchInfo> method_type_bss_entry_patches_;
   // PC-relative method patch info for kBootImageLinkTimePcRelative+kCallCriticalNative.
   ArenaDeque<PcRelativePatchInfo> boot_image_jni_entrypoint_patches_;
   // PC-relative patch info for IntrinsicObjects for the boot image,
diff --git a/compiler/optimizing/code_generator_arm_vixl.cc b/compiler/optimizing/code_generator_arm_vixl.cc
index fb8f8c0153..e88d14b3eb 100644
--- a/compiler/optimizing/code_generator_arm_vixl.cc
+++ b/compiler/optimizing/code_generator_arm_vixl.cc
@@ -1944,6 +1944,7 @@ CodeGeneratorARMVIXL::CodeGeneratorARMVIXL(HGraph* graph,
       move_resolver_(graph->GetAllocator(), this),
       assembler_(graph->GetAllocator()),
       boot_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      app_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       method_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       app_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -5290,11 +5291,11 @@ void InstructionCodeGeneratorARMVIXL::HandleIntegerRotate(HBinaryOperation* rota
     // Arm32 and Thumb2 assemblers require a rotation on the interval [1,31],
     // so map all rotations to a +ve. equivalent in that range.
     // (e.g. left *or* right by -2 bits == 30 bits in the same direction.)
-    uint32_t rot = CodeGenerator::GetInt32ValueOf(rhs.GetConstant()) & 0x1F;
-
+    uint32_t rot = CodeGenerator::GetInt32ValueOf(rhs.GetConstant());
     if (rotate->IsRol()) {
       rot = -rot;
     }
+    rot &= 0x1f;
 
     if (rot) {
       // Rotate, mapping left rotations to right equivalents if necessary.
@@ -9557,6 +9558,14 @@ void CodeGeneratorARMVIXL::LoadMethod(MethodLoadKind load_kind, Location temp, H
       LoadBootImageRelRoEntry(RegisterFrom(temp), boot_image_offset);
       break;
     }
+    case MethodLoadKind::kAppImageRelRo: {
+      DCHECK(GetCompilerOptions().IsAppImage());
+      PcRelativePatchInfo* labels = NewAppImageMethodPatch(invoke->GetResolvedMethodReference());
+      vixl32::Register temp_reg = RegisterFrom(temp);
+      EmitMovwMovtPlaceholder(labels, temp_reg);
+      __ Ldr(temp_reg, MemOperand(temp_reg, /*offset=*/ 0));
+      break;
+    }
     case MethodLoadKind::kBssEntry: {
       PcRelativePatchInfo* labels = NewMethodBssEntryPatch(invoke->GetMethodReference());
       vixl32::Register temp_reg = RegisterFrom(temp);
@@ -9746,6 +9755,12 @@ CodeGeneratorARMVIXL::PcRelativePatchInfo* CodeGeneratorARMVIXL::NewBootImageMet
       target_method.dex_file, target_method.index, &boot_image_method_patches_);
 }
 
+CodeGeneratorARMVIXL::PcRelativePatchInfo* CodeGeneratorARMVIXL::NewAppImageMethodPatch(
+    MethodReference target_method) {
+  return NewPcRelativePatch(
+      target_method.dex_file, target_method.index, &app_image_method_patches_);
+}
+
 CodeGeneratorARMVIXL::PcRelativePatchInfo* CodeGeneratorARMVIXL::NewMethodBssEntryPatch(
     MethodReference target_method) {
   return NewPcRelativePatch(
@@ -9946,6 +9961,7 @@ void CodeGeneratorARMVIXL::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
   DCHECK(linker_patches->empty());
   size_t size =
       /* MOVW+MOVT for each entry */ 2u * boot_image_method_patches_.size() +
+      /* MOVW+MOVT for each entry */ 2u * app_image_method_patches_.size() +
       /* MOVW+MOVT for each entry */ 2u * method_bss_entry_patches_.size() +
       /* MOVW+MOVT for each entry */ 2u * boot_image_type_patches_.size() +
       /* MOVW+MOVT for each entry */ 2u * app_image_type_patches_.size() +
@@ -9970,6 +9986,7 @@ void CodeGeneratorARMVIXL::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
     DCHECK(boot_image_type_patches_.empty());
     DCHECK(boot_image_string_patches_.empty());
   }
+  DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_method_patches_.empty());
   DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_type_patches_.empty());
   if (GetCompilerOptions().IsBootImage()) {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::IntrinsicReferencePatch>>(
@@ -9977,6 +9994,8 @@ void CodeGeneratorARMVIXL::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
   } else {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::BootImageRelRoPatch>>(
         boot_image_other_patches_, linker_patches);
+    EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodAppImageRelRoPatch>(
+        app_image_method_patches_, linker_patches);
     EmitPcRelativeLinkerPatches<linker::LinkerPatch::TypeAppImageRelRoPatch>(
         app_image_type_patches_, linker_patches);
   }
diff --git a/compiler/optimizing/code_generator_arm_vixl.h b/compiler/optimizing/code_generator_arm_vixl.h
index 00b5a69b1d..ea8ec7e485 100644
--- a/compiler/optimizing/code_generator_arm_vixl.h
+++ b/compiler/optimizing/code_generator_arm_vixl.h
@@ -716,6 +716,7 @@ class CodeGeneratorARMVIXL : public CodeGenerator {
   PcRelativePatchInfo* NewBootImageIntrinsicPatch(uint32_t intrinsic_data);
   PcRelativePatchInfo* NewBootImageRelRoPatch(uint32_t boot_image_offset);
   PcRelativePatchInfo* NewBootImageMethodPatch(MethodReference target_method);
+  PcRelativePatchInfo* NewAppImageMethodPatch(MethodReference target_method);
   PcRelativePatchInfo* NewMethodBssEntryPatch(MethodReference target_method);
   PcRelativePatchInfo* NewBootImageTypePatch(const DexFile& dex_file, dex::TypeIndex type_index);
   PcRelativePatchInfo* NewAppImageTypePatch(const DexFile& dex_file, dex::TypeIndex type_index);
@@ -1035,6 +1036,8 @@ class CodeGeneratorARMVIXL : public CodeGenerator {
 
   // PC-relative method patch info for kBootImageLinkTimePcRelative.
   ArenaDeque<PcRelativePatchInfo> boot_image_method_patches_;
+  // PC-relative method patch info for kAppImageRelRo.
+  ArenaDeque<PcRelativePatchInfo> app_image_method_patches_;
   // PC-relative method patch info for kBssEntry.
   ArenaDeque<PcRelativePatchInfo> method_bss_entry_patches_;
   // PC-relative type patch info for kBootImageLinkTimePcRelative.
diff --git a/compiler/optimizing/code_generator_riscv64.cc b/compiler/optimizing/code_generator_riscv64.cc
index 43f855a915..c2d82b8033 100644
--- a/compiler/optimizing/code_generator_riscv64.cc
+++ b/compiler/optimizing/code_generator_riscv64.cc
@@ -2666,8 +2666,10 @@ void InstructionCodeGeneratorRISCV64::GenerateMethodEntryExitHook(HInstruction*
   __ Addi(tmp, tmp, -dchecked_integral_cast<int32_t>(kNumEntriesForWallClock * sizeof(void*)));
   __ Blt(tmp, tmp2, slow_path->GetEntryLabel());
 
-  // Update the index in the `Thread`.
-  __ Sd(tmp, TR, trace_buffer_curr_entry_offset);
+  // Update the index in the `Thread`. Temporarily free `tmp2` to be used by `Stored()`.
+  temps.FreeXRegister(tmp2);
+  __ Stored(tmp, TR, trace_buffer_curr_entry_offset);
+  tmp2 = temps.AllocateXRegister();
 
   // Record method pointer and trace action.
   __ Ld(tmp2, SP, 0);
@@ -5825,12 +5827,103 @@ void InstructionCodeGeneratorRISCV64::VisitVecPredToBoolean(HVecPredToBoolean* i
   LOG(FATAL) << "Unimplemented";
 }
 
-void LocationsBuilderRISCV64::VisitVecCondition(HVecCondition* instruction) {
+void LocationsBuilderRISCV64::VisitVecEqual(HVecEqual* instruction) {
   UNUSED(instruction);
   LOG(FATAL) << "Unimplemented";
 }
 
-void InstructionCodeGeneratorRISCV64::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorRISCV64::VisitVecEqual(HVecEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecNotEqual(HVecNotEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecNotEqual(HVecNotEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecLessThan(HVecLessThan* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecLessThan(HVecLessThan* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecGreaterThanOrEqual(HVecGreaterThanOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecBelow(HVecBelow* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecBelow(HVecBelow* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecAbove(HVecAbove* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecAbove(HVecAbove* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void LocationsBuilderRISCV64::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
+  UNUSED(instruction);
+  LOG(FATAL) << "Unimplemented";
+}
+
+void InstructionCodeGeneratorRISCV64::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
   UNUSED(instruction);
   LOG(FATAL) << "Unimplemented";
 }
@@ -5894,6 +5987,7 @@ CodeGeneratorRISCV64::CodeGeneratorRISCV64(HGraph* graph,
       uint64_literals_(std::less<uint64_t>(),
                        graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      app_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       method_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       app_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -6546,6 +6640,12 @@ CodeGeneratorRISCV64::PcRelativePatchInfo* CodeGeneratorRISCV64::NewBootImageMet
       target_method.dex_file, target_method.index, info_high, &boot_image_method_patches_);
 }
 
+CodeGeneratorRISCV64::PcRelativePatchInfo* CodeGeneratorRISCV64::NewAppImageMethodPatch(
+    MethodReference target_method, const PcRelativePatchInfo* info_high) {
+  return NewPcRelativePatch(
+      target_method.dex_file, target_method.index, info_high, &app_image_method_patches_);
+}
+
 CodeGeneratorRISCV64::PcRelativePatchInfo* CodeGeneratorRISCV64::NewMethodBssEntryPatch(
     MethodReference target_method, const PcRelativePatchInfo* info_high) {
   return NewPcRelativePatch(
@@ -6723,6 +6823,7 @@ void CodeGeneratorRISCV64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
   DCHECK(linker_patches->empty());
   size_t size =
       boot_image_method_patches_.size() +
+      app_image_method_patches_.size() +
       method_bss_entry_patches_.size() +
       boot_image_type_patches_.size() +
       app_image_type_patches_.size() +
@@ -6746,6 +6847,7 @@ void CodeGeneratorRISCV64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
     DCHECK(boot_image_type_patches_.empty());
     DCHECK(boot_image_string_patches_.empty());
   }
+  DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_method_patches_.empty());
   DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_type_patches_.empty());
   if (GetCompilerOptions().IsBootImage()) {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::IntrinsicReferencePatch>>(
@@ -6753,6 +6855,8 @@ void CodeGeneratorRISCV64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* l
   } else {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::BootImageRelRoPatch>>(
         boot_image_other_patches_, linker_patches);
+    EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodAppImageRelRoPatch>(
+        app_image_method_patches_, linker_patches);
     EmitPcRelativeLinkerPatches<linker::LinkerPatch::TypeAppImageRelRoPatch>(
         app_image_type_patches_, linker_patches);
   }
@@ -6853,6 +6957,17 @@ void CodeGeneratorRISCV64::LoadMethod(MethodLoadKind load_kind, Location temp, H
       LoadBootImageRelRoEntry(temp.AsRegister<XRegister>(), boot_image_offset);
       break;
     }
+    case MethodLoadKind::kAppImageRelRo: {
+      DCHECK(GetCompilerOptions().IsAppImage());
+      PcRelativePatchInfo* info_high =
+          NewAppImageMethodPatch(invoke->GetResolvedMethodReference());
+      EmitPcRelativeAuipcPlaceholder(info_high, temp.AsRegister<XRegister>());
+      PcRelativePatchInfo* info_low =
+          NewAppImageMethodPatch(invoke->GetResolvedMethodReference(), info_high);
+      EmitPcRelativeLwuPlaceholder(
+          info_low, temp.AsRegister<XRegister>(), temp.AsRegister<XRegister>());
+      break;
+    }
     case MethodLoadKind::kBssEntry: {
       PcRelativePatchInfo* info_high = NewMethodBssEntryPatch(invoke->GetMethodReference());
       EmitPcRelativeAuipcPlaceholder(info_high, temp.AsRegister<XRegister>());
diff --git a/compiler/optimizing/code_generator_riscv64.h b/compiler/optimizing/code_generator_riscv64.h
index dcd36ffe67..588243e86d 100644
--- a/compiler/optimizing/code_generator_riscv64.h
+++ b/compiler/optimizing/code_generator_riscv64.h
@@ -578,6 +578,8 @@ class CodeGeneratorRISCV64 : public CodeGenerator {
                                                   const PcRelativePatchInfo* info_high = nullptr);
   PcRelativePatchInfo* NewBootImageRelRoPatch(uint32_t boot_image_offset,
                                               const PcRelativePatchInfo* info_high = nullptr);
+  PcRelativePatchInfo* NewAppImageMethodPatch(MethodReference target_method,
+                                              const PcRelativePatchInfo* info_high = nullptr);
   PcRelativePatchInfo* NewBootImageMethodPatch(MethodReference target_method,
                                                const PcRelativePatchInfo* info_high = nullptr);
   PcRelativePatchInfo* NewMethodBssEntryPatch(MethodReference target_method,
@@ -817,6 +819,8 @@ class CodeGeneratorRISCV64 : public CodeGenerator {
 
   // PC-relative method patch info for kBootImageLinkTimePcRelative.
   ArenaDeque<PcRelativePatchInfo> boot_image_method_patches_;
+  // PC-relative method patch info for kAppImageRelRo.
+  ArenaDeque<PcRelativePatchInfo> app_image_method_patches_;
   // PC-relative method patch info for kBssEntry.
   ArenaDeque<PcRelativePatchInfo> method_bss_entry_patches_;
   // PC-relative type patch info for kBootImageLinkTimePcRelative.
diff --git a/compiler/optimizing/code_generator_vector_arm64_neon.cc b/compiler/optimizing/code_generator_vector_arm64_neon.cc
index 848b5e7567..53a2ec720e 100644
--- a/compiler/optimizing/code_generator_vector_arm64_neon.cc
+++ b/compiler/optimizing/code_generator_vector_arm64_neon.cc
@@ -1541,12 +1541,103 @@ void InstructionCodeGeneratorARM64Neon::VisitVecPredToBoolean(HVecPredToBoolean*
   UNREACHABLE();
 }
 
-void LocationsBuilderARM64Neon::VisitVecCondition(HVecCondition* instruction) {
+void LocationsBuilderARM64Neon::VisitVecEqual(HVecEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
 
-void InstructionCodeGeneratorARM64Neon::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorARM64Neon::VisitVecEqual(HVecEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecGreaterThanOrEqual(HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Neon::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARM64Neon::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
diff --git a/compiler/optimizing/code_generator_vector_arm64_sve.cc b/compiler/optimizing/code_generator_vector_arm64_sve.cc
index ef79932899..3d9bd9187f 100644
--- a/compiler/optimizing/code_generator_vector_arm64_sve.cc
+++ b/compiler/optimizing/code_generator_vector_arm64_sve.cc
@@ -1207,14 +1207,56 @@ void InstructionCodeGeneratorARM64Sve::VisitVecPredSetAll(HVecPredSetAll* instru
   }
 }
 
-void LocationsBuilderARM64Sve::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorARM64Sve::GenerateIntegerVecComparison(
+    const PRegisterWithLaneSize& pd,
+    const PRegisterZ& pg,
+    const ZRegister& zn,
+    const ZRegister& zm,
+    IfCondition cond) {
+  switch (cond) {
+    case kCondEQ:
+      __ Cmpeq(pd, pg, zn, zm);
+      return;
+    case kCondNE:
+      __ Cmpne(pd, pg, zn, zm);
+      return;
+    case kCondLT:
+      __ Cmplt(pd, pg, zn, zm);
+      return;
+    case kCondLE:
+      __ Cmple(pd, pg, zn, zm);
+      return;
+    case kCondGT:
+      __ Cmpgt(pd, pg, zn, zm);
+      return;
+    case kCondGE:
+      __ Cmpge(pd, pg, zn, zm);
+      return;
+    case kCondB:
+      __ Cmplo(pd, pg, zn, zm);
+      return;
+    case kCondBE:
+      __ Cmpls(pd, pg, zn, zm);
+      return;
+    case kCondA:
+      __ Cmphi(pd, pg, zn, zm);
+      return;
+    case kCondAE:
+      __ Cmphs(pd, pg, zn, zm);
+      return;
+  }
+  LOG(FATAL) << "Condition '" << enum_cast<uint32_t>(cond) << "' not supported: ";
+  UNREACHABLE();
+}
+
+void LocationsBuilderARM64Sve::HandleVecCondition(HVecCondition* instruction) {
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
   locations->SetInAt(0, Location::RequiresFpuRegister());
   locations->SetInAt(1, Location::RequiresFpuRegister());
   locations->SetOut(Location::RequiresRegister());
 }
 
-void InstructionCodeGeneratorARM64Sve::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorARM64Sve::HandleVecCondition(HVecCondition* instruction) {
   DCHECK(instruction->IsPredicated());
   LocationSummary* locations = instruction->GetLocations();
   const ZRegister left = ZRegisterFrom(locations->InAt(0));
@@ -1228,21 +1270,37 @@ void InstructionCodeGeneratorARM64Sve::VisitVecCondition(HVecCondition* instruct
             HVecOperation::ToSignedType(b->GetPackedType()));
   ValidateVectorLength(instruction);
 
-  // TODO: Support other condition OPs and types.
+  // TODO: Support other types, e.g: boolean, float and double.
   switch (instruction->GetPackedType()) {
     case DataType::Type::kUint8:
     case DataType::Type::kInt8:
-      __ Cmpeq(output_p_reg.VnB(), p_reg, left.VnB(), right.VnB());
+      GenerateIntegerVecComparison(output_p_reg.VnB(),
+                                   p_reg,
+                                   left.VnB(),
+                                   right.VnB(),
+                                   instruction->GetCondition());
       break;
     case DataType::Type::kUint16:
     case DataType::Type::kInt16:
-      __ Cmpeq(output_p_reg.VnH(), p_reg, left.VnH(), right.VnH());
+      GenerateIntegerVecComparison(output_p_reg.VnH(),
+                                   p_reg,
+                                   left.VnH(),
+                                   right.VnH(),
+                                   instruction->GetCondition());
       break;
     case DataType::Type::kInt32:
-      __ Cmpeq(output_p_reg.VnS(), p_reg, left.VnS(), right.VnS());
+      GenerateIntegerVecComparison(output_p_reg.VnS(),
+                                   p_reg,
+                                   left.VnS(),
+                                   right.VnS(),
+                                   instruction->GetCondition());
       break;
     case DataType::Type::kInt64:
-      __ Cmpeq(output_p_reg.VnD(), p_reg, left.VnD(), right.VnD());
+      GenerateIntegerVecComparison(output_p_reg.VnD(),
+                                   p_reg,
+                                   left.VnD(),
+                                   right.VnD(),
+                                   instruction->GetCondition());
       break;
     default:
       LOG(FATAL) << "Unsupported SIMD type: " << instruction->GetPackedType();
@@ -1250,6 +1308,24 @@ void InstructionCodeGeneratorARM64Sve::VisitVecCondition(HVecCondition* instruct
   }
 }
 
+#define FOR_EACH_VEC_CONDITION_INSTRUCTION(M) \
+  M(VecEqual)                                 \
+  M(VecNotEqual)                              \
+  M(VecLessThan)                              \
+  M(VecLessThanOrEqual)                       \
+  M(VecGreaterThan)                           \
+  M(VecGreaterThanOrEqual)                    \
+  M(VecBelow)                                 \
+  M(VecBelowOrEqual)                          \
+  M(VecAbove)                                 \
+  M(VecAboveOrEqual)
+#define DEFINE_VEC_CONDITION_VISITORS(Name)                                                     \
+void LocationsBuilderARM64Sve::Visit##Name(H##Name* comp) { HandleVecCondition(comp); }         \
+void InstructionCodeGeneratorARM64Sve::Visit##Name(H##Name* comp) { HandleVecCondition(comp); }
+FOR_EACH_VEC_CONDITION_INSTRUCTION(DEFINE_VEC_CONDITION_VISITORS)
+#undef DEFINE_VEC_CONDITION_VISITORS
+#undef FOR_EACH_VEC_CONDITION_INSTRUCTION
+
 void LocationsBuilderARM64Sve::VisitVecPredNot(HVecPredNot* instruction) {
   LocationSummary* locations = new (GetGraph()->GetAllocator()) LocationSummary(instruction);
   DCHECK(instruction->InputAt(0)->IsVecPredSetOperation());
@@ -1335,10 +1411,10 @@ void InstructionCodeGeneratorARM64Sve::VisitVecPredToBoolean(HVecPredToBoolean*
   // Instruction is not predicated, see nodes_vector.h
   DCHECK(!instruction->IsPredicated());
   Register reg = OutputRegister(instruction);
-  // Currently VecPredToBoolean is only used as part of vectorized loop check condition
-  // evaluation.
-  DCHECK(instruction->GetPCondKind() == HVecPredToBoolean::PCondKind::kNFirst);
-  __ Cset(reg, pl);
+  HInstruction *input = instruction->InputAt(0);
+  const PRegister output_p_reg = GetVecPredSetFixedOutPReg(input->AsVecPredSetOperation());
+  __ Ptest(output_p_reg, output_p_reg.VnB());
+  __ Cset(reg, ARM64PCondition(instruction->GetPCondKind()));
 }
 
 Location InstructionCodeGeneratorARM64Sve::AllocateSIMDScratchLocation(
diff --git a/compiler/optimizing/code_generator_vector_arm_vixl.cc b/compiler/optimizing/code_generator_vector_arm_vixl.cc
index 70f22af17b..5cf34dd500 100644
--- a/compiler/optimizing/code_generator_vector_arm_vixl.cc
+++ b/compiler/optimizing/code_generator_vector_arm_vixl.cc
@@ -1079,12 +1079,104 @@ void InstructionCodeGeneratorARMVIXL::VisitVecPredToBoolean(HVecPredToBoolean* i
   UNREACHABLE();
 }
 
-void LocationsBuilderARMVIXL::VisitVecCondition(HVecCondition* instruction) {
+void LocationsBuilderARMVIXL::VisitVecEqual(HVecEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
 
-void InstructionCodeGeneratorARMVIXL::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorARMVIXL::VisitVecEqual(HVecEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderARMVIXL::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorARMVIXL::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
diff --git a/compiler/optimizing/code_generator_vector_x86.cc b/compiler/optimizing/code_generator_vector_x86.cc
index 1f9b2578ac..da61764a7c 100644
--- a/compiler/optimizing/code_generator_vector_x86.cc
+++ b/compiler/optimizing/code_generator_vector_x86.cc
@@ -1411,12 +1411,104 @@ void InstructionCodeGeneratorX86::VisitVecPredToBoolean(HVecPredToBoolean* instr
   UNREACHABLE();
 }
 
-void LocationsBuilderX86::VisitVecCondition(HVecCondition* instruction) {
+void LocationsBuilderX86::VisitVecEqual(HVecEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
 
-void InstructionCodeGeneratorX86::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorX86::VisitVecEqual(HVecEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
diff --git a/compiler/optimizing/code_generator_vector_x86_64.cc b/compiler/optimizing/code_generator_vector_x86_64.cc
index 47afa3b4a1..1ecd5f063f 100644
--- a/compiler/optimizing/code_generator_vector_x86_64.cc
+++ b/compiler/optimizing/code_generator_vector_x86_64.cc
@@ -1384,12 +1384,103 @@ void InstructionCodeGeneratorX86_64::VisitVecPredToBoolean(HVecPredToBoolean* in
   UNREACHABLE();
 }
 
-void LocationsBuilderX86_64::VisitVecCondition(HVecCondition* instruction) {
+void LocationsBuilderX86_64::VisitVecEqual(HVecEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
 
-void InstructionCodeGeneratorX86_64::VisitVecCondition(HVecCondition* instruction) {
+void InstructionCodeGeneratorX86_64::VisitVecEqual(HVecEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecNotEqual(HVecNotEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecLessThan(HVecLessThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecLessThanOrEqual(HVecLessThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecGreaterThan(HVecGreaterThan* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecGreaterThanOrEqual(HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecGreaterThanOrEqual(
+    HVecGreaterThanOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecBelow(HVecBelow* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecBelowOrEqual(HVecBelowOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecAbove(HVecAbove* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void LocationsBuilderX86_64::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
+  LOG(FATAL) << "No SIMD for " << instruction->GetId();
+  UNREACHABLE();
+}
+
+void InstructionCodeGeneratorX86_64::VisitVecAboveOrEqual(HVecAboveOrEqual* instruction) {
   LOG(FATAL) << "No SIMD for " << instruction->GetId();
   UNREACHABLE();
 }
diff --git a/compiler/optimizing/code_generator_x86.cc b/compiler/optimizing/code_generator_x86.cc
index 7e3c6216eb..6db49c7771 100644
--- a/compiler/optimizing/code_generator_x86.cc
+++ b/compiler/optimizing/code_generator_x86.cc
@@ -1171,6 +1171,7 @@ CodeGeneratorX86::CodeGeneratorX86(HGraph* graph,
       assembler_(graph->GetAllocator(),
                  compiler_options.GetInstructionSetFeatures()->AsX86InstructionSetFeatures()),
       boot_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      app_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       method_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       app_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -5124,13 +5125,14 @@ void InstructionCodeGeneratorX86::HandleRotate(HBinaryOperation* rotate) {
     Register second_reg = second.AsRegister<Register>();
     DCHECK_EQ(second_reg, ECX);
 
+    __ movl(temp_reg, first_reg_hi);
     if (rotate->IsRol()) {
-      __ negl(second_reg);
+      __ shld(first_reg_hi, first_reg_lo, second_reg);
+      __ shld(first_reg_lo, temp_reg, second_reg);
+    } else {
+      __ shrd(first_reg_hi, first_reg_lo, second_reg);
+      __ shrd(first_reg_lo, temp_reg, second_reg);
     }
-
-    __ movl(temp_reg, first_reg_hi);
-    __ shrd(first_reg_hi, first_reg_lo, second_reg);
-    __ shrd(first_reg_lo, temp_reg, second_reg);
     __ movl(temp_reg, first_reg_hi);
     __ testl(second_reg, Immediate(32));
     __ cmovl(kNotEqual, first_reg_hi, first_reg_lo);
@@ -5550,6 +5552,13 @@ void CodeGeneratorX86::LoadMethod(MethodLoadKind load_kind, Location temp, HInvo
           GetBootImageOffset(invoke));
       break;
     }
+    case MethodLoadKind::kAppImageRelRo: {
+      DCHECK(GetCompilerOptions().IsAppImage());
+      Register base_reg = GetInvokeExtraParameter(invoke, temp.AsRegister<Register>());
+      __ movl(temp.AsRegister<Register>(), Address(base_reg, kPlaceholder32BitOffset));
+      RecordAppImageMethodPatch(invoke);
+      break;
+    }
     case MethodLoadKind::kBssEntry: {
       Register base_reg = GetInvokeExtraParameter(invoke, temp.AsRegister<Register>());
       __ movl(temp.AsRegister<Register>(), Address(base_reg, kPlaceholder32BitOffset));
@@ -5739,6 +5748,19 @@ void CodeGeneratorX86::RecordBootImageMethodPatch(HInvoke* invoke) {
   __ Bind(&boot_image_method_patches_.back().label);
 }
 
+void CodeGeneratorX86::RecordAppImageMethodPatch(HInvoke* invoke) {
+  size_t index = invoke->IsInvokeInterface()
+      ? invoke->AsInvokeInterface()->GetSpecialInputIndex()
+      : invoke->AsInvokeStaticOrDirect()->GetSpecialInputIndex();
+  HX86ComputeBaseMethodAddress* method_address =
+      invoke->InputAt(index)->AsX86ComputeBaseMethodAddress();
+  app_image_method_patches_.emplace_back(
+      method_address,
+      invoke->GetResolvedMethodReference().dex_file,
+      invoke->GetResolvedMethodReference().index);
+  __ Bind(&app_image_method_patches_.back().label);
+}
+
 void CodeGeneratorX86::RecordMethodBssEntryPatch(HInvoke* invoke) {
   size_t index = invoke->IsInvokeInterface()
       ? invoke->AsInvokeInterface()->GetSpecialInputIndex()
@@ -5900,6 +5922,7 @@ void CodeGeneratorX86::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* linke
   DCHECK(linker_patches->empty());
   size_t size =
       boot_image_method_patches_.size() +
+      app_image_method_patches_.size() +
       method_bss_entry_patches_.size() +
       boot_image_type_patches_.size() +
       app_image_type_patches_.size() +
@@ -5923,6 +5946,7 @@ void CodeGeneratorX86::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* linke
     DCHECK(boot_image_type_patches_.empty());
     DCHECK(boot_image_string_patches_.empty());
   }
+  DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_method_patches_.empty());
   DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_type_patches_.empty());
   if (GetCompilerOptions().IsBootImage()) {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::IntrinsicReferencePatch>>(
@@ -5930,6 +5954,8 @@ void CodeGeneratorX86::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* linke
   } else {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::BootImageRelRoPatch>>(
         boot_image_other_patches_, linker_patches);
+    EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodAppImageRelRoPatch>(
+        app_image_method_patches_, linker_patches);
     EmitPcRelativeLinkerPatches<linker::LinkerPatch::TypeAppImageRelRoPatch>(
         app_image_type_patches_, linker_patches);
   }
diff --git a/compiler/optimizing/code_generator_x86.h b/compiler/optimizing/code_generator_x86.h
index 321ee92e2e..fae6c7f801 100644
--- a/compiler/optimizing/code_generator_x86.h
+++ b/compiler/optimizing/code_generator_x86.h
@@ -548,6 +548,7 @@ class CodeGeneratorX86 : public CodeGenerator {
   void RecordBootImageRelRoPatch(HX86ComputeBaseMethodAddress* method_address,
                                  uint32_t boot_image_offset);
   void RecordBootImageMethodPatch(HInvoke* invoke);
+  void RecordAppImageMethodPatch(HInvoke* invoke);
   void RecordMethodBssEntryPatch(HInvoke* invoke);
   void RecordBootImageTypePatch(HLoadClass* load_class);
   void RecordAppImageTypePatch(HLoadClass* load_class);
@@ -783,6 +784,8 @@ class CodeGeneratorX86 : public CodeGenerator {
 
   // PC-relative method patch info for kBootImageLinkTimePcRelative.
   ArenaDeque<X86PcRelativePatchInfo> boot_image_method_patches_;
+  // PC-relative method patch info for kAppImageRelRo.
+  ArenaDeque<X86PcRelativePatchInfo> app_image_method_patches_;
   // PC-relative method patch info for kBssEntry.
   ArenaDeque<X86PcRelativePatchInfo> method_bss_entry_patches_;
   // PC-relative type patch info for kBootImageLinkTimePcRelative.
diff --git a/compiler/optimizing/code_generator_x86_64.cc b/compiler/optimizing/code_generator_x86_64.cc
index 51ded684c6..e9593d6c98 100644
--- a/compiler/optimizing/code_generator_x86_64.cc
+++ b/compiler/optimizing/code_generator_x86_64.cc
@@ -1142,6 +1142,13 @@ void CodeGeneratorX86_64::LoadMethod(MethodLoadKind load_kind, Location temp, HI
       RecordBootImageRelRoPatch(GetBootImageOffset(invoke));
       break;
     }
+    case MethodLoadKind::kAppImageRelRo: {
+      DCHECK(GetCompilerOptions().IsAppImage());
+      __ movl(temp.AsRegister<CpuRegister>(),
+              Address::Absolute(CodeGeneratorX86_64::kPlaceholder32BitOffset, /* no_rip= */ false));
+      RecordAppImageMethodPatch(invoke);
+      break;
+    }
     case MethodLoadKind::kBssEntry: {
       __ movq(temp.AsRegister<CpuRegister>(),
               Address::Absolute(kPlaceholder32BitOffset, /* no_rip= */ false));
@@ -1312,6 +1319,12 @@ void CodeGeneratorX86_64::RecordBootImageMethodPatch(HInvoke* invoke) {
   __ Bind(&boot_image_method_patches_.back().label);
 }
 
+void CodeGeneratorX86_64::RecordAppImageMethodPatch(HInvoke* invoke) {
+  app_image_method_patches_.emplace_back(invoke->GetResolvedMethodReference().dex_file,
+                                         invoke->GetResolvedMethodReference().index);
+  __ Bind(&app_image_method_patches_.back().label);
+}
+
 void CodeGeneratorX86_64::RecordMethodBssEntryPatch(HInvoke* invoke) {
   DCHECK(IsSameDexFile(GetGraph()->GetDexFile(), *invoke->GetMethodReference().dex_file) ||
          GetCompilerOptions().WithinOatFile(invoke->GetMethodReference().dex_file) ||
@@ -1452,6 +1465,7 @@ void CodeGeneratorX86_64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* li
   DCHECK(linker_patches->empty());
   size_t size =
       boot_image_method_patches_.size() +
+      app_image_method_patches_.size() +
       method_bss_entry_patches_.size() +
       boot_image_type_patches_.size() +
       app_image_type_patches_.size() +
@@ -1476,6 +1490,7 @@ void CodeGeneratorX86_64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* li
     DCHECK(boot_image_type_patches_.empty());
     DCHECK(boot_image_string_patches_.empty());
   }
+  DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_method_patches_.empty());
   DCHECK_IMPLIES(!GetCompilerOptions().IsAppImage(), app_image_type_patches_.empty());
   if (GetCompilerOptions().IsBootImage()) {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::IntrinsicReferencePatch>>(
@@ -1483,6 +1498,8 @@ void CodeGeneratorX86_64::EmitLinkerPatches(ArenaVector<linker::LinkerPatch>* li
   } else {
     EmitPcRelativeLinkerPatches<NoDexFileAdapter<linker::LinkerPatch::BootImageRelRoPatch>>(
         boot_image_other_patches_, linker_patches);
+    EmitPcRelativeLinkerPatches<linker::LinkerPatch::MethodAppImageRelRoPatch>(
+        app_image_method_patches_, linker_patches);
     EmitPcRelativeLinkerPatches<linker::LinkerPatch::TypeAppImageRelRoPatch>(
         app_image_type_patches_, linker_patches);
   }
@@ -1615,6 +1632,7 @@ CodeGeneratorX86_64::CodeGeneratorX86_64(HGraph* graph,
                  compiler_options.GetInstructionSetFeatures()->AsX86_64InstructionSetFeatures()),
       constant_area_start_(0),
       boot_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
+      app_image_method_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       method_bss_entry_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       boot_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
       app_image_type_patches_(graph->GetAllocator()->Adapter(kArenaAllocCodeGenerator)),
@@ -5104,11 +5122,11 @@ void InstructionCodeGeneratorX86_64::HandleRotate(HBinaryOperation* rotate) {
   }
 }
 
-void InstructionCodeGeneratorX86_64::VisitRor(HRor* ror) {
-  HandleRotate(ror);
+void LocationsBuilderX86_64::VisitRol(HRol* rol) {
+  HandleRotate(rol);
 }
 
-void LocationsBuilderX86_64::VisitRol(HRol* rol) {
+void InstructionCodeGeneratorX86_64::VisitRol(HRol* rol) {
   HandleRotate(rol);
 }
 
@@ -5116,8 +5134,8 @@ void LocationsBuilderX86_64::VisitRor(HRor* ror) {
   HandleRotate(ror);
 }
 
-void InstructionCodeGeneratorX86_64::VisitRol(HRol* rol) {
-  HandleRotate(rol);
+void InstructionCodeGeneratorX86_64::VisitRor(HRor* ror) {
+  HandleRotate(ror);
 }
 
 void LocationsBuilderX86_64::VisitShl(HShl* shl) {
diff --git a/compiler/optimizing/code_generator_x86_64.h b/compiler/optimizing/code_generator_x86_64.h
index b3eb1a0373..3024116402 100644
--- a/compiler/optimizing/code_generator_x86_64.h
+++ b/compiler/optimizing/code_generator_x86_64.h
@@ -542,6 +542,7 @@ class CodeGeneratorX86_64 : public CodeGenerator {
   void RecordBootImageIntrinsicPatch(uint32_t intrinsic_data);
   void RecordBootImageRelRoPatch(uint32_t boot_image_offset);
   void RecordBootImageMethodPatch(HInvoke* invoke);
+  void RecordAppImageMethodPatch(HInvoke* invoke);
   void RecordMethodBssEntryPatch(HInvoke* invoke);
   void RecordBootImageTypePatch(const DexFile& dex_file, dex::TypeIndex type_index);
   void RecordAppImageTypePatch(const DexFile& dex_file, dex::TypeIndex type_index);
@@ -750,6 +751,8 @@ class CodeGeneratorX86_64 : public CodeGenerator {
 
   // PC-relative method patch info for kBootImageLinkTimePcRelative.
   ArenaDeque<PatchInfo<Label>> boot_image_method_patches_;
+  // PC-relative method patch info for kAppImageRelRo.
+  ArenaDeque<PatchInfo<Label>> app_image_method_patches_;
   // PC-relative method patch info for kBssEntry.
   ArenaDeque<PatchInfo<Label>> method_bss_entry_patches_;
   // PC-relative type patch info for kBootImageLinkTimePcRelative.
diff --git a/compiler/optimizing/codegen_test.cc b/compiler/optimizing/codegen_test.cc
index 7365f0fb7f..98b0550c4d 100644
--- a/compiler/optimizing/codegen_test.cc
+++ b/compiler/optimizing/codegen_test.cc
@@ -56,7 +56,7 @@ static ::std::vector<CodegenTargetConfig> GetTargetConfigs() {
   };
 
   for (const CodegenTargetConfig& test_config : test_config_candidates) {
-    if (CanExecute(test_config.GetInstructionSet())) {
+    if (CanExecuteISA(test_config.GetInstructionSet())) {
       v.push_back(test_config);
     }
   }
@@ -73,6 +73,12 @@ class CodegenTest : public CommonCompilerTest, public OptimizingUnitTestHelper {
                       int64_t j,
                       DataType::Type type,
                       const CodegenTargetConfig target_config);
+  void TestPackedSwitch(const CodegenTargetConfig target_config);
+  void TestVectorComparison(IfCondition condition,
+                            int64_t lhs_value,
+                            int64_t rhs_value,
+                            DataType::Type type,
+                            CodeGenerator* codegen);
 };
 
 void CodegenTest::TestCode(const std::vector<uint16_t>& data, bool has_result, int32_t expected) {
@@ -593,6 +599,35 @@ TEST_F(CodegenTest, ReturnDivInt2Addr) {
   TestCode(data, true, 2);
 }
 
+static bool GetExpectedResultFromComparison(IfCondition condition, int64_t lhs, int64_t rhs) {
+  const uint64_t unsigned_lhs = lhs;
+  const uint64_t unsigned_rhs = rhs;
+  switch (condition) {
+    case kCondEQ:
+      return lhs == rhs;
+    case kCondNE:
+      return lhs != rhs;
+    case kCondLT:
+      return lhs < rhs;
+    case kCondLE:
+      return lhs <= rhs;
+    case kCondGT:
+      return lhs > rhs;
+    case kCondGE:
+      return lhs >= rhs;
+    case kCondB:
+      return unsigned_lhs < unsigned_rhs;
+    case kCondBE:
+      return unsigned_lhs <= unsigned_rhs;
+    case kCondA:
+      return unsigned_lhs > unsigned_rhs;
+    case kCondAE:
+      return unsigned_lhs >= unsigned_rhs;
+  }
+  LOG(FATAL) << "Condition '" << enum_cast<uint32_t>(condition) << "' not supported: ";
+  UNREACHABLE();
+}
+
 // Helper method.
 void CodegenTest::TestComparison(IfCondition condition,
                                  int64_t i,
@@ -612,47 +647,13 @@ void CodegenTest::TestComparison(IfCondition condition,
     op2 = graph_->GetLongConstant(j);
   }
 
-  bool expected_result = false;
-  const uint64_t x = i;
-  const uint64_t y = j;
-  switch (condition) {
-    case kCondEQ:
-      expected_result = (i == j);
-      break;
-    case kCondNE:
-      expected_result = (i != j);
-      break;
-    case kCondLT:
-      expected_result = (i < j);
-      break;
-    case kCondLE:
-      expected_result = (i <= j);
-      break;
-    case kCondGT:
-      expected_result = (i > j);
-      break;
-    case kCondGE:
-      expected_result = (i >= j);
-      break;
-    case kCondB:
-      expected_result = (x < y);
-      break;
-    case kCondBE:
-      expected_result = (x <= y);
-      break;
-    case kCondA:
-      expected_result = (x > y);
-      break;
-    case kCondAE:
-      expected_result = (x >= y);
-      break;
-  }
   HInstruction* comparison = MakeCondition(block, condition, op1, op2);
   MakeReturn(block, comparison);
 
   graph_->BuildDominatorTree();
   std::unique_ptr<CompilerOptions> compiler_options =
       CommonCompilerTest::CreateCompilerOptions(target_config.GetInstructionSet(), "default");
+  bool expected_result = GetExpectedResultFromComparison(condition, i, j);
   RunCode(target_config, *compiler_options, graph_, [](HGraph*) {}, true, expected_result);
 }
 
@@ -682,6 +683,72 @@ TEST_F(CodegenTest, ComparisonsLong) {
   }
 }
 
+// Tests a PackedSwitch in a very large HGraph; validates that the switch jump table is in
+// range for the PC-relative load in the codegen visitor.
+void CodegenTest::TestPackedSwitch(const CodegenTargetConfig target_config) {
+  HBasicBlock* return_block = InitEntryMainExitGraph();
+  constexpr DataType::Type data_type = DataType::Type::kInt32;
+
+  // A number of entries - we are interested to test jump table implementation.
+  constexpr size_t kNumSwitchEntries = 10;
+
+  // Number of jump targets (including a 'default' case).
+  constexpr size_t kNumBB = kNumSwitchEntries + 1;
+  // Some arbitrary value to be used as input.
+  constexpr int kInputValue = kNumBB - 4;
+
+  HInstruction* input = graph_->GetIntConstant(kInputValue);
+  HIntConstant* constant_1 = graph_->GetIntConstant(1);
+
+  HBasicBlock* switch_block = AddNewBlock();
+  entry_block_->ReplaceSuccessor(return_block, switch_block);
+
+  HPackedSwitch* hswitch = new (GetAllocator()) HPackedSwitch(0, kNumSwitchEntries, input);
+  switch_block->AddInstruction(hswitch);
+
+  std::vector<HInstruction*> phi_inputs {};
+
+  // Add switch jump target blocks.
+  for (int i = 0; i < kNumBB; i++) {
+    HBasicBlock* case_block = AddNewBlock();
+    case_block->AddPredecessor(switch_block);
+    case_block->AddSuccessor(return_block);
+
+    HIntConstant* case_value = graph_->GetIntConstant(i);
+    HAdd* add = MakeBinOp<HAdd>(case_block, data_type, input, case_value);
+    phi_inputs.emplace_back(add);
+
+    MakeGoto(case_block);
+  }
+
+  HPhi* phi = MakePhi(return_block, phi_inputs);
+  HInstruction* return_val = phi;
+
+  // Emit a huge number of HAdds - to simulate a very large HGraph.
+  constexpr int kNumOfAdds = 2 * 1024 * 1024;
+  for (int i = 0; i < kNumOfAdds; i++) {
+    return_val = MakeBinOp<HAdd>(return_block, data_type, return_val, constant_1);
+  }
+
+  MakeReturn(return_block, return_val);
+
+  graph_->BuildDominatorTree();
+  EXPECT_TRUE(CheckGraph());
+
+  std::unique_ptr<CompilerOptions> compiler_options =
+      CommonCompilerTest::CreateCompilerOptions(target_config.GetInstructionSet(), "default");
+  RunCode(target_config,
+          *compiler_options,
+          graph_,
+          [](HGraph*) {}, true, kNumOfAdds + 2 * kInputValue);
+}
+
+TEST_F(CodegenTest, PackedSwitchInHugeMethod) {
+  for (CodegenTargetConfig target_config : GetTargetConfigs()) {
+    TestPackedSwitch(target_config);
+  }
+}
+
 #ifdef ART_ENABLE_CODEGEN_arm
 TEST_F(CodegenTest, ARMVIXLParallelMoveResolver) {
   std::unique_ptr<CompilerOptions> compiler_options =
@@ -865,6 +932,123 @@ TEST_F(CodegenTest, ARM64FrameSizeNoSIMD) {
   EXPECT_EQ(codegen.GetFpuSpillSize(), kExpectedFPSpillSize);
 }
 
+// This test checks that the result of the VecPredToBoolean instruction doesn't depend on
+// conditional flags that can be updated by other instructions. For example:
+//
+//   VecPredWhile p0, opa, opb
+//   Below opb, opa
+//   VecPredToBoolean p0
+//
+// where Below updates conditions flags after VecPredWhile.
+TEST_F(CodegenTest, ARM64SvePredicateToBoolean) {
+  std::unique_ptr<CompilerOptions> compiler_options =
+      CommonCompilerTest::CreateCompilerOptions(InstructionSet::kArm64, "default", "sve");
+  for (int i = 0; i < 2; i++) {
+    for (int j = 0; j < 2; j++) {
+      HBasicBlock* block = InitEntryMainExitGraph();
+      TestCodeGeneratorARM64 codegen(graph_, *compiler_options);
+      if (!codegen.SupportsPredicatedSIMD()) {
+        GTEST_SKIP() << "Predicated SIMD is not supported.";
+      }
+
+      HInstruction *opa = graph_->GetIntConstant(i);
+      HInstruction *opb = graph_->GetIntConstant(j);
+      HVecPredWhile *pred_while = MakeVecPredWhile(block,
+                                                  opa,
+                                                  opb,
+                                                  HVecPredWhile::CondKind::kLO,
+                                                  DataType::Type::kInt32);
+      // Update condition flags by using Below instruction.
+      MakeCondition(block, IfCondition::kCondB, opb, opa);
+      HVecPredToBoolean *boolean = MakeVecPredToBoolean(block,
+                                                        pred_while,
+                                                        HVecPredToBoolean::PCondKind::kNFirst,
+                                                        DataType::Type::kInt32);
+      MakeReturn(block, boolean);
+
+      graph_->SetHasPredicatedSIMD(true);
+      graph_->BuildDominatorTree();
+
+      if (CanExecute(codegen)) {
+        RunCode(&codegen, graph_, [](HGraph*) {}, true, i >= j);
+      }
+    }
+  }
+}
+
+void CodegenTest::TestVectorComparison(IfCondition condition,
+                                       int64_t lhs_value,
+                                       int64_t rhs_value,
+                                       DataType::Type type,
+                                       CodeGenerator* codegen) {
+  HBasicBlock* block = entry_block_->GetSingleSuccessor();
+
+  size_t vector_size_in_bytes = codegen->GetSIMDRegisterWidth();
+
+  HVecPredSetAll* predicate = MakeVecPredSetAll(block,
+                                                graph_->GetIntConstant(1),
+                                                type,
+                                                vector_size_in_bytes);
+  HVecReplicateScalar* op1 = MakeVecReplicateScalar(block,
+                                                    graph_->GetConstant(type, lhs_value),
+                                                    type,
+                                                    vector_size_in_bytes,
+                                                    predicate);
+  HVecReplicateScalar* op2 = MakeVecReplicateScalar(block,
+                                                    graph_->GetConstant(type, rhs_value),
+                                                    type,
+                                                    vector_size_in_bytes,
+                                                    predicate);
+  HVecCondition* comparison = MakeVecCondition(block,
+                                               condition,
+                                               op1,
+                                               op2,
+                                               type,
+                                               vector_size_in_bytes,
+                                               predicate);
+  HInstruction* boolean_return = MakeVecPredToBoolean(block,
+                                                      comparison,
+                                                      HVecPredToBoolean::PCondKind::kFirst,
+                                                      type,
+                                                      vector_size_in_bytes);
+  MakeReturn(block, boolean_return);
+
+  graph_->SetHasPredicatedSIMD(true);
+  graph_->BuildDominatorTree();
+
+  if (CanExecute(*codegen)) {
+    bool expected_result = GetExpectedResultFromComparison(condition, lhs_value, rhs_value);
+    RunCode(codegen, graph_, [](HGraph*) {}, true, expected_result);
+  }
+}
+
+// Define tests ensuring that all types of conditions can be generated correctly and return the
+// expected result.
+#define DEFINE_CONDITION_TESTS(CondType)                                                         \
+TEST_F(CodegenTest, ComparisonsVector##CondType) {                                               \
+  std::unique_ptr<CompilerOptions> compiler_options =                                            \
+      CommonCompilerTest::CreateCompilerOptions(InstructionSet::kArm64, "default", "sve");       \
+  for (int64_t i = -1; i <= 1; i++) {                                                            \
+    for (int64_t j = -1; j <= 1; j++) {                                                          \
+      for (int cond = kCondFirst; cond <= kCondLast; cond++) {                                   \
+        InitEntryMainExitGraph();                                                                \
+        TestCodeGeneratorARM64 codegen(graph_, *compiler_options);                               \
+        if (!codegen.SupportsPredicatedSIMD()) {                                                 \
+          GTEST_SKIP() << "Predicated SIMD is not supported.";                                   \
+        }                                                                                        \
+        TestVectorComparison(                                                                    \
+            static_cast<IfCondition>(cond), i, j, DataType::Type::k##CondType, &codegen);        \
+      }                                                                                          \
+    }                                                                                            \
+  }                                                                                              \
+}
+DEFINE_CONDITION_TESTS(Uint8)
+DEFINE_CONDITION_TESTS(Int8)
+DEFINE_CONDITION_TESTS(Uint16)
+DEFINE_CONDITION_TESTS(Int16)
+DEFINE_CONDITION_TESTS(Int32)
+#undef DEFINE_CONDITION_TESTS
+
 #endif
 
 }  // namespace art
diff --git a/compiler/optimizing/codegen_test_utils.h b/compiler/optimizing/codegen_test_utils.h
index a8425c9915..130c796652 100644
--- a/compiler/optimizing/codegen_test_utils.h
+++ b/compiler/optimizing/codegen_test_utils.h
@@ -167,15 +167,30 @@ class TestCodeGeneratorX86 : public x86::CodeGeneratorX86 {
 };
 #endif
 
-static bool CanExecuteOnHardware(InstructionSet target_isa) {
+// Check that the current runtime ISA matches the target ISA.
+static bool DoesHardwareSupportISA(InstructionSet target_isa) {
   return (target_isa == kRuntimeISA)
       // Handle the special case of ARM, with two instructions sets (ARM32 and Thumb-2).
       || (kRuntimeISA == InstructionSet::kArm && target_isa == InstructionSet::kThumb2);
 }
 
-static bool CanExecute(InstructionSet target_isa) {
+// Check that the current runtime ISA matches the target ISA and the ISA features requested are
+// available on the hardware.
+static bool CanExecuteOnHardware(const CodeGenerator& codegen) {
+  const InstructionSetFeatures* isa_features =
+      codegen.GetCompilerOptions().GetInstructionSetFeatures();
+  return DoesHardwareSupportISA(codegen.GetInstructionSet())
+      && InstructionSetFeatures::FromHwcap()->HasAtLeast(isa_features);
+}
+
+static bool CanExecuteISA(InstructionSet target_isa) {
   CodeSimulatorContainer simulator(target_isa);
-  return CanExecuteOnHardware(target_isa) || simulator.CanSimulate();
+  return DoesHardwareSupportISA(target_isa) || simulator.CanSimulate();
+}
+
+static bool CanExecute(const CodeGenerator& codegen) {
+  CodeSimulatorContainer simulator(codegen.GetInstructionSet());
+  return CanExecuteOnHardware(codegen) || simulator.CanSimulate();
 }
 
 template <typename Expected>
@@ -200,14 +215,14 @@ inline int64_t SimulatorExecute<int64_t>(CodeSimulator* simulator, int64_t (*f)(
 }
 
 template <typename Expected>
-static void VerifyGeneratedCode(InstructionSet target_isa,
+static void VerifyGeneratedCode(const CodeGenerator& codegen,
                                 Expected (*f)(),
                                 bool has_result,
                                 Expected expected) {
-  ASSERT_TRUE(CanExecute(target_isa)) << "Target isa is not executable.";
+  ASSERT_TRUE(CanExecute(codegen)) << "Target isa is not executable.";
 
   // Verify on simulator.
-  CodeSimulatorContainer simulator(target_isa);
+  CodeSimulatorContainer simulator(codegen.GetInstructionSet());
   if (simulator.CanSimulate()) {
     Expected result = SimulatorExecute<Expected>(simulator.Get(), f);
     if (has_result) {
@@ -216,7 +231,7 @@ static void VerifyGeneratedCode(InstructionSet target_isa,
   }
 
   // Verify on hardware.
-  if (CanExecuteOnHardware(target_isa)) {
+  if (CanExecuteOnHardware(codegen)) {
     Expected result = f();
     if (has_result) {
       ASSERT_EQ(expected, result);
@@ -241,7 +256,7 @@ static void Run(const CodeGenerator& codegen,
 
   using fptr = Expected (*)();
   fptr f = reinterpret_cast<fptr>(reinterpret_cast<uintptr_t>(method_code));
-  VerifyGeneratedCode(target_isa, f, has_result, expected);
+  VerifyGeneratedCode(codegen, f, has_result, expected);
 }
 
 static void ValidateGraph(HGraph* graph) {
diff --git a/compiler/optimizing/constant_folding.cc b/compiler/optimizing/constant_folding.cc
index e31de9e1da..0ec60b5ead 100644
--- a/compiler/optimizing/constant_folding.cc
+++ b/compiler/optimizing/constant_folding.cc
@@ -72,7 +72,7 @@ class HConstantFoldingVisitor final : public HGraphDelegateVisitor {
 // This visitor tries to simplify operations with an absorbing input,
 // yielding a constant. For example `input * 0` is replaced by a
 // null constant.
-class InstructionWithAbsorbingInputSimplifier : public HGraphVisitor {
+class InstructionWithAbsorbingInputSimplifier final : public HGraphVisitor {
  public:
   explicit InstructionWithAbsorbingInputSimplifier(HGraph* graph) : HGraphVisitor(graph) {}
 
diff --git a/compiler/optimizing/data_type-inl.h b/compiler/optimizing/data_type-inl.h
index bbfe90451b..8f95ecb37a 100644
--- a/compiler/optimizing/data_type-inl.h
+++ b/compiler/optimizing/data_type-inl.h
@@ -36,8 +36,6 @@ constexpr DataType::Type DataTypeFromPrimitive(Primitive::Type type) {
     case Primitive::kPrimDouble: return DataType::Type::kFloat64;
     case Primitive::kPrimVoid: return DataType::Type::kVoid;
   }
-  LOG(FATAL) << "Unreachable";
-  UNREACHABLE();
 }
 
 // Note: Not declared in data_type.h to avoid pulling in "primitive.h".
@@ -81,8 +79,6 @@ constexpr char DataType::TypeId(DataType::Type type) {
     case DataType::Type::kReference: return 'l';  // Java reference (L).
     case DataType::Type::kVoid: return 'v';       // Java void (V).
   }
-  LOG(FATAL) << "Unreachable";
-  UNREACHABLE();
 }
 
 }  // namespace art
diff --git a/compiler/optimizing/graph_visualizer.cc b/compiler/optimizing/graph_visualizer.cc
index 0c42b9e85d..a0ec99ffc3 100644
--- a/compiler/optimizing/graph_visualizer.cc
+++ b/compiler/optimizing/graph_visualizer.cc
@@ -374,7 +374,11 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
       str << "->";
       DumpLocation(str, move->GetDestination());
     }
-    StartAttributeStream("moves") <<  moves;
+    StartAttributeStream("moves") << moves;
+  }
+
+  void VisitParameterValue(HParameterValue* instruction) override {
+    StartAttributeStream("is_this") << std::boolalpha << instruction->IsThis() << std::noboolalpha;
   }
 
   void VisitIntConstant(HIntConstant* instruction) override {
@@ -396,6 +400,7 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
   void VisitPhi(HPhi* phi) override {
     StartAttributeStream("reg") << phi->GetRegNumber();
     StartAttributeStream("is_catch_phi") << std::boolalpha << phi->IsCatchPhi() << std::noboolalpha;
+    StartAttributeStream("is_live") << std::boolalpha << phi->IsLive() << std::noboolalpha;
   }
 
   void VisitMemoryBarrier(HMemoryBarrier* barrier) override {
@@ -470,22 +475,36 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
         << bounds_check->IsStringCharAt() << std::noboolalpha;
   }
 
+  void VisitSuspendCheck(HSuspendCheck* suspend_check) override {
+    StartAttributeStream("is_no_op")
+        << std::boolalpha << suspend_check->IsNoOp() << std::noboolalpha;
+  }
+
   void VisitArrayGet(HArrayGet* array_get) override {
     StartAttributeStream("is_string_char_at") << std::boolalpha
         << array_get->IsStringCharAt() << std::noboolalpha;
   }
 
   void VisitArraySet(HArraySet* array_set) override {
-    StartAttributeStream("value_can_be_null") << std::boolalpha
-        << array_set->GetValueCanBeNull() << std::noboolalpha;
-    StartAttributeStream("needs_type_check") << std::boolalpha
-        << array_set->NeedsTypeCheck() << std::noboolalpha;
+    StartAttributeStream("value_can_be_null")
+        << std::boolalpha << array_set->GetValueCanBeNull() << std::noboolalpha;
+    StartAttributeStream("needs_type_check")
+        << std::boolalpha << array_set->NeedsTypeCheck() << std::noboolalpha;
+    StartAttributeStream("static_type_of_array_is_object_array")
+        << std::boolalpha << array_set->StaticTypeOfArrayIsObjectArray() << std::noboolalpha;
     StartAttributeStream("can_trigger_gc")
         << std::boolalpha << array_set->GetSideEffects().Includes(SideEffects::CanTriggerGC())
         << std::noboolalpha;
     StartAttributeStream("write_barrier_kind") << array_set->GetWriteBarrierKind();
   }
 
+  void VisitNewInstance(HNewInstance* new_instance) override {
+    StartAttributeStream("is_finalizable")
+        << std::boolalpha << new_instance->IsFinalizable() << std::noboolalpha;
+    StartAttributeStream("is_partial_materialization")
+        << std::boolalpha << new_instance->IsPartialMaterialization() << std::noboolalpha;
+  }
+
   void VisitCompare(HCompare* compare) override {
     StartAttributeStream("bias") << compare->GetBias();
     StartAttributeStream("comparison_type") << compare->GetComparisonType();
@@ -556,6 +575,8 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
                                                       /* with type */ false);
     StartAttributeStream("field_type") << iset->GetFieldType();
     StartAttributeStream("write_barrier_kind") << iset->GetWriteBarrierKind();
+    StartAttributeStream("value_can_be_null")
+        << std::boolalpha << iset->GetValueCanBeNull() << std::noboolalpha;
   }
 
   void VisitStaticFieldGet(HStaticFieldGet* sget) override {
@@ -571,6 +592,8 @@ class HGraphVisualizerPrinter final : public HGraphDelegateVisitor {
                                                       /* with type */ false);
     StartAttributeStream("field_type") << sset->GetFieldType();
     StartAttributeStream("write_barrier_kind") << sset->GetWriteBarrierKind();
+    StartAttributeStream("value_can_be_null")
+        << std::boolalpha << sset->GetValueCanBeNull() << std::noboolalpha;
   }
 
   void VisitUnresolvedInstanceFieldGet(HUnresolvedInstanceFieldGet* field_access) override {
diff --git a/compiler/optimizing/gvn.cc b/compiler/optimizing/gvn.cc
index cd3b07065c..8a5a4742ba 100644
--- a/compiler/optimizing/gvn.cc
+++ b/compiler/optimizing/gvn.cc
@@ -359,7 +359,8 @@ class GlobalValueNumberer : public ValueObject {
         side_effects_(side_effects),
         sets_(graph->GetBlocks().size(), nullptr, allocator_.Adapter(kArenaAllocGvn)),
         visited_blocks_(
-            &allocator_, graph->GetBlocks().size(), /* expandable= */ false, kArenaAllocGvn) {}
+            &allocator_, graph->GetBlocks().size(), /* expandable= */ false, kArenaAllocGvn),
+        did_optimization_(false) {}
 
   bool Run();
 
@@ -403,6 +404,9 @@ class GlobalValueNumberer : public ValueObject {
   // visited/unvisited Boolean.
   ArenaBitVector visited_blocks_;
 
+  // True if GVN did at least one removal.
+  bool did_optimization_;
+
   DISALLOW_COPY_AND_ASSIGN(GlobalValueNumberer);
 };
 
@@ -415,7 +419,7 @@ bool GlobalValueNumberer::Run() {
   for (HBasicBlock* block : graph_->GetReversePostOrder()) {
     VisitBasicBlock(block);
   }
-  return true;
+  return did_optimization_;
 }
 
 void GlobalValueNumberer::VisitBasicBlock(HBasicBlock* block) {
@@ -508,6 +512,7 @@ void GlobalValueNumberer::VisitBasicBlock(HBasicBlock* block) {
         // Or current is used by a phi, and we don't do OrderInputs() on a phi anyway.
         current->ReplaceWith(existing);
         current->GetBlock()->RemoveInstruction(current);
+        did_optimization_ = true;
       } else {
         set->Kill(current->GetSideEffects());
         set->Add(current);
diff --git a/libdexfile/dex/compact_dex_level.h b/compiler/optimizing/handle_cache-inl.h
similarity index 52%
rename from libdexfile/dex/compact_dex_level.h
rename to compiler/optimizing/handle_cache-inl.h
index e6b5446b5f..81da8f554f 100644
--- a/libdexfile/dex/compact_dex_level.h
+++ b/compiler/optimizing/handle_cache-inl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,20 +14,25 @@
  * limitations under the License.
  */
 
-#ifndef ART_LIBDEXFILE_DEX_COMPACT_DEX_LEVEL_H_
-#define ART_LIBDEXFILE_DEX_COMPACT_DEX_LEVEL_H_
+#ifndef ART_COMPILER_OPTIMIZING_HANDLE_CACHE_INL_H_
+#define ART_COMPILER_OPTIMIZING_HANDLE_CACHE_INL_H_
 
-namespace art {
+#include "handle_cache.h"
 
-// Optimization level for compact dex generation.
-// TODO(b/256664509): Clean this up.
-enum class CompactDexLevel {
-  // Level none means not generated.
-  kCompactDexLevelNone,
-  // Level fast means optimizations that don't take many resources to perform.
-  kCompactDexLevelFast,
-};
+#include "handle_scope-inl.h"
+
+namespace art HIDDEN {
+
+template <typename T>
+MutableHandle<T> HandleCache::NewHandle(T* object) {
+  return handles_->NewHandle(object);
+}
+
+template <typename T>
+MutableHandle<T> HandleCache::NewHandle(ObjPtr<T> object) {
+  return handles_->NewHandle(object);
+}
 
 }  // namespace art
 
-#endif  // ART_LIBDEXFILE_DEX_COMPACT_DEX_LEVEL_H_
+#endif  // ART_COMPILER_OPTIMIZING_HANDLE_CACHE_INL_H_
diff --git a/compiler/optimizing/handle_cache.cc b/compiler/optimizing/handle_cache.cc
new file mode 100644
index 0000000000..fbdc8bbf32
--- /dev/null
+++ b/compiler/optimizing/handle_cache.cc
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "handle_cache.h"
+
+#include "class_root-inl.h"
+#include "handle_scope-inl.h"
+#include "scoped_thread_state_change-inl.h"
+#include "thread-current-inl.h"
+
+namespace art HIDDEN {
+
+ReferenceTypeInfo::TypeHandle HandleCache::CreateRootHandle(VariableSizedHandleScope* handles,
+                                                            ClassRoot class_root) {
+  // Mutator lock is required for NewHandle and GetClassRoot().
+  ScopedObjectAccess soa(Thread::Current());
+  return handles->NewHandle(GetClassRoot(class_root));
+}
+
+}  // namespace art
diff --git a/compiler/optimizing/handle_cache.h b/compiler/optimizing/handle_cache.h
new file mode 100644
index 0000000000..56c3331aa9
--- /dev/null
+++ b/compiler/optimizing/handle_cache.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_COMPILER_OPTIMIZING_HANDLE_CACHE_H_
+#define ART_COMPILER_OPTIMIZING_HANDLE_CACHE_H_
+
+#include "base/macros.h"
+#include "class_root.h"
+#include "reference_type_info.h"
+
+namespace art HIDDEN {
+
+class VariableSizedHandleScope;
+
+class HandleCache {
+ public:
+  explicit HandleCache(VariableSizedHandleScope* handles) : handles_(handles) { }
+
+  VariableSizedHandleScope* GetHandles() { return handles_; }
+
+  template <typename T>
+  MutableHandle<T> NewHandle(T* object) REQUIRES_SHARED(Locks::mutator_lock_);
+
+  template <typename T>
+  MutableHandle<T> NewHandle(ObjPtr<T> object) REQUIRES_SHARED(Locks::mutator_lock_);
+
+  ReferenceTypeInfo::TypeHandle GetObjectClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangObject, &object_class_handle_);
+  }
+
+  ReferenceTypeInfo::TypeHandle GetClassClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangClass, &class_class_handle_);
+  }
+
+  ReferenceTypeInfo::TypeHandle GetMethodHandleClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangInvokeMethodHandleImpl, &method_handle_class_handle_);
+  }
+
+  ReferenceTypeInfo::TypeHandle GetMethodTypeClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangInvokeMethodType, &method_type_class_handle_);
+  }
+
+  ReferenceTypeInfo::TypeHandle GetStringClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangString, &string_class_handle_);
+  }
+
+  ReferenceTypeInfo::TypeHandle GetThrowableClassHandle() {
+    return GetRootHandle(ClassRoot::kJavaLangThrowable, &throwable_class_handle_);
+  }
+
+ private:
+  inline ReferenceTypeInfo::TypeHandle GetRootHandle(ClassRoot class_root,
+                                                     ReferenceTypeInfo::TypeHandle* cache) {
+    if (UNLIKELY(!ReferenceTypeInfo::IsValidHandle(*cache))) {
+      *cache = CreateRootHandle(handles_, class_root);
+    }
+    return *cache;
+  }
+
+  static ReferenceTypeInfo::TypeHandle CreateRootHandle(VariableSizedHandleScope* handles,
+                                                        ClassRoot class_root);
+
+  VariableSizedHandleScope* handles_;
+
+  ReferenceTypeInfo::TypeHandle object_class_handle_;
+  ReferenceTypeInfo::TypeHandle class_class_handle_;
+  ReferenceTypeInfo::TypeHandle method_handle_class_handle_;
+  ReferenceTypeInfo::TypeHandle method_type_class_handle_;
+  ReferenceTypeInfo::TypeHandle string_class_handle_;
+  ReferenceTypeInfo::TypeHandle throwable_class_handle_;
+};
+
+}  // namespace art
+
+#endif  // ART_COMPILER_OPTIMIZING_HANDLE_CACHE_H_
+
diff --git a/compiler/optimizing/inliner.cc b/compiler/optimizing/inliner.cc
index 90df4521e8..d679261d42 100644
--- a/compiler/optimizing/inliner.cc
+++ b/compiler/optimizing/inliner.cc
@@ -28,6 +28,7 @@
 #include "dex/inline_method_analyser.h"
 #include "driver/compiler_options.h"
 #include "driver/dex_compilation_unit.h"
+#include "handle_cache-inl.h"
 #include "instruction_simplifier.h"
 #include "intrinsics.h"
 #include "jit/jit.h"
@@ -421,7 +422,13 @@ static bool AlwaysThrows(ArtMethod* method)
   if (!method->IsCompilable() || !IsMethodVerified(method)) {
     return false;
   }
+
   // Skip native methods, methods with try blocks, and methods that are too large.
+  // TODO(solanes): We could correctly mark methods with try/catch blocks as always throwing as long
+  // as we can get rid of the infinite loop cases. These cases (e.g. `void foo() {while (true) {}}`)
+  // are the only ones that can have no return instruction and still not be an "always throwing
+  // method". Unfortunately, we need to construct the graph to know there's an infinite loop and
+  // therefore not worth the trouble.
   CodeItemDataAccessor accessor(method->DexInstructionData());
   if (!accessor.HasCodeItem() ||
       accessor.TriesSize() != 0 ||
@@ -775,9 +782,10 @@ HInliner::InlineCacheType HInliner::GetInlineCacheAOT(
   Thread* self = Thread::Current();
   for (const dex::TypeIndex& type_index : dex_pc_data.classes) {
     const DexFile* dex_file = caller_compilation_unit_.GetDexFile();
-    const char* descriptor = pci->GetTypeDescriptor(dex_file, type_index);
-    ObjPtr<mirror::Class> clazz =
-        class_linker->FindClass(self, descriptor, caller_compilation_unit_.GetClassLoader());
+    size_t descriptor_length;
+    const char* descriptor = pci->GetTypeDescriptor(dex_file, type_index, &descriptor_length);
+    ObjPtr<mirror::Class> clazz = class_linker->FindClass(
+        self, descriptor, descriptor_length, caller_compilation_unit_.GetClassLoader());
     if (clazz == nullptr) {
       self->ClearException();  // Clean up the exception left by type resolution.
       VLOG(compiler) << "Could not find class from inline cache in AOT mode "
@@ -919,7 +927,7 @@ void HInliner::AddCHAGuard(HInstruction* invoke_instruction,
   // requested we deoptimize before we execute any code and hence we shouldn't
   // see that case here.
   HInstruction* compare = new (graph_->GetAllocator()) HNotEqual(
-      deopt_flag, graph_->GetIntConstant(0, dex_pc));
+      deopt_flag, graph_->GetIntConstant(0));
   HInstruction* deopt = new (graph_->GetAllocator()) HDeoptimize(
       graph_->GetAllocator(), compare, DeoptimizationKind::kCHA, dex_pc);
 
@@ -1277,11 +1285,9 @@ bool HInliner::TryInlinePolymorphicCallToSameTarget(
 
   HConstant* constant;
   if (type == DataType::Type::kInt64) {
-    constant = graph_->GetLongConstant(
-        reinterpret_cast<intptr_t>(actual_method), invoke_instruction->GetDexPc());
+    constant = graph_->GetLongConstant(reinterpret_cast<intptr_t>(actual_method));
   } else {
-    constant = graph_->GetIntConstant(
-        reinterpret_cast<intptr_t>(actual_method), invoke_instruction->GetDexPc());
+    constant = graph_->GetIntConstant(reinterpret_cast<intptr_t>(actual_method));
   }
 
   HNotEqual* compare = new (graph_->GetAllocator()) HNotEqual(class_table_get, constant);
@@ -1336,13 +1342,6 @@ bool HInliner::TryDevirtualize(HInvoke* invoke_instruction,
     return false;
   }
 
-  // Don't try to devirtualize intrinsics as it breaks pattern matching from later phases.
-  // TODO(solanes): This `if` could be removed if we update optimizations like
-  // TryReplaceStringBuilderAppend.
-  if (invoke_instruction->IsIntrinsic()) {
-    return false;
-  }
-
   // Don't devirtualize to an intrinsic invalid after the builder phase. The ArtMethod might be an
   // intrinsic even when the HInvoke isn't e.g. java.lang.CharSequence.isEmpty (not an intrinsic)
   // can get devirtualized into java.lang.String.isEmpty (which is an intrinsic).
@@ -1385,6 +1384,7 @@ bool HInliner::TryDevirtualize(HInvoke* invoke_instruction,
   HInvokeStaticOrDirect* new_invoke = new (graph_->GetAllocator()) HInvokeStaticOrDirect(
       graph_->GetAllocator(),
       invoke_instruction->GetNumberOfArguments(),
+      invoke_instruction->GetNumberOfOutVRegs(),
       invoke_instruction->GetType(),
       invoke_instruction->GetDexPc(),
       MethodReference(invoke_instruction->GetMethodReference().dex_file, dex_method_index),
@@ -1604,6 +1604,7 @@ bool HInliner::TryBuildAndInline(HInvoke* invoke_instruction,
     HInvokeVirtual* new_invoke = new (graph_->GetAllocator()) HInvokeVirtual(
         graph_->GetAllocator(),
         invoke_instruction->GetNumberOfArguments(),
+        invoke_instruction->GetNumberOfOutVRegs(),
         invoke_instruction->GetType(),
         invoke_instruction->GetDexPc(),
         invoke_instruction->GetMethodReference(),  // Use existing invoke's method's reference.
@@ -1767,17 +1768,14 @@ bool HInliner::TryPatternSubstitution(HInvoke* invoke_instruction,
       uint16_t iput_args[] = { data.iput0_arg, data.iput1_arg, data.iput2_arg };
       static_assert(arraysize(iput_args) == arraysize(iput_field_indexes), "Size mismatch");
       // Count valid field indexes.
-      size_t number_of_iputs = 0u;
-      while (number_of_iputs != arraysize(iput_field_indexes) &&
-          iput_field_indexes[number_of_iputs] != DexFile::kDexNoIndex16) {
+      for (size_t i = 0, end = data.iput_count; i < end; i++) {
         // Check that there are no duplicate valid field indexes.
-        DCHECK_EQ(0, std::count(iput_field_indexes + number_of_iputs + 1,
-                                iput_field_indexes + arraysize(iput_field_indexes),
-                                iput_field_indexes[number_of_iputs]));
-        ++number_of_iputs;
+        DCHECK_EQ(0, std::count(iput_field_indexes + i + 1,
+                                iput_field_indexes + end,
+                                iput_field_indexes[i]));
       }
       // Check that there are no valid field indexes in the rest of the array.
-      DCHECK_EQ(0, std::count_if(iput_field_indexes + number_of_iputs,
+      DCHECK_EQ(0, std::count_if(iput_field_indexes + data.iput_count,
                                  iput_field_indexes + arraysize(iput_field_indexes),
                                  [](uint16_t index) { return index != DexFile::kDexNoIndex16; }));
 
@@ -1785,7 +1783,7 @@ bool HInliner::TryPatternSubstitution(HInvoke* invoke_instruction,
       HInstruction* obj = GetInvokeInputForArgVRegIndex(invoke_instruction,
                                                         /* arg_vreg_index= */ 0u);
       bool needs_constructor_barrier = false;
-      for (size_t i = 0; i != number_of_iputs; ++i) {
+      for (size_t i = 0, end = data.iput_count; i != end; ++i) {
         HInstruction* value = GetInvokeInputForArgVRegIndex(invoke_instruction, iput_args[i]);
         if (!IsZeroBitPattern(value)) {
           uint16_t field_index = iput_field_indexes[i];
@@ -1810,7 +1808,7 @@ bool HInliner::TryPatternSubstitution(HInvoke* invoke_instruction,
                                                                 invoke_instruction);
       }
       *return_replacement = nullptr;
-      number_of_instructions = number_of_iputs + (needs_constructor_barrier ? 1u : 0u);
+      number_of_instructions = data.iput_count + (needs_constructor_barrier ? 1u : 0u);
       break;
     }
   }
@@ -1995,11 +1993,13 @@ bool HInliner::CanInlineBody(const HGraph* callee_graph,
   }
 
   bool has_one_return = false;
+  bool has_try_catch = false;
   for (HBasicBlock* predecessor : exit_block->GetPredecessors()) {
     const HInstruction* last_instruction = predecessor->GetLastInstruction();
     // On inlinees, we can have Return/ReturnVoid/Throw -> TryBoundary -> Exit. To check for the
     // actual last instruction, we have to skip the TryBoundary instruction.
     if (last_instruction->IsTryBoundary()) {
+      has_try_catch = true;
       predecessor = predecessor->GetSinglePredecessor();
       last_instruction = predecessor->GetLastInstruction();
 
@@ -2041,7 +2041,9 @@ bool HInliner::CanInlineBody(const HGraph* callee_graph,
   }
 
   if (!has_one_return) {
-    if (!is_speculative) {
+    // If a method has a try catch, all throws are potentially caught. We are conservative and
+    // don't assume a method always throws unless we can guarantee that.
+    if (!is_speculative && !has_try_catch) {
       // If we know that the method always throws with the particular parameters, set it as such.
       // This is better than using the dex instructions as we have more information about this
       // particular call. We don't mark speculative inlines (e.g. the ones from the inline cache) as
@@ -2050,6 +2052,13 @@ bool HInliner::CanInlineBody(const HGraph* callee_graph,
       graph_->SetHasAlwaysThrowingInvokes(/* value= */ true);
     }
 
+    // Methods that contain infinite loops with try catches fall into this line too as we construct
+    // an Exit block for them. This will mean that the stat `kNotInlinedAlwaysThrows` might not be
+    // 100% correct but:
+    // 1) This is a very small fraction of methods, and
+    // 2) It is not easy to disambiguate between those.
+    // Since we want to avoid inlining methods with infinite loops anyway, we return false for these
+    // cases too.
     LOG_FAIL(stats_, MethodCompilationStat::kNotInlinedAlwaysThrows)
         << "Method " << resolved_method->PrettyMethod()
         << " could not be inlined because it always throws";
@@ -2436,7 +2445,7 @@ bool HInliner::ReturnTypeMoreSpecific(HInstruction* return_replacement,
       ReferenceTypeInfo invoke_rti = invoke_instruction->GetReferenceTypeInfo();
       if (IsReferenceTypeRefinement(invoke_rti.GetTypeHandle().Get(),
                                     invoke_rti.IsExact(),
-                                    /*declared_can_be_null=*/ true,
+                                    invoke_instruction->CanBeNull(),
                                     return_replacement)) {
         return true;
       } else if (return_replacement->IsInstanceFieldGet()) {
diff --git a/compiler/optimizing/instruction_builder.cc b/compiler/optimizing/instruction_builder.cc
index 55e3267427..c66fd3bb26 100644
--- a/compiler/optimizing/instruction_builder.cc
+++ b/compiler/optimizing/instruction_builder.cc
@@ -26,9 +26,10 @@
 #include "data_type-inl.h"
 #include "dex/bytecode_utils.h"
 #include "dex/dex_instruction-inl.h"
-#include "driver/dex_compilation_unit.h"
 #include "driver/compiler_options.h"
+#include "driver/dex_compilation_unit.h"
 #include "entrypoints/entrypoint_utils-inl.h"
+#include "handle_cache-inl.h"
 #include "imtable-inl.h"
 #include "intrinsics.h"
 #include "intrinsics_utils.h"
@@ -36,6 +37,7 @@
 #include "jit/profiling_info.h"
 #include "mirror/dex_cache.h"
 #include "oat/oat_file.h"
+#include "optimizing/data_type.h"
 #include "optimizing_compiler_stats.h"
 #include "reflective_handle_scope-inl.h"
 #include "scoped_thread_state_change-inl.h"
@@ -296,7 +298,7 @@ void HInstructionBuilder::InsertInstructionAtTop(HInstruction* instruction) {
 
 void HInstructionBuilder::InitializeInstruction(HInstruction* instruction) {
   if (instruction->NeedsEnvironment()) {
-    HEnvironment* environment = new (allocator_) HEnvironment(
+    HEnvironment* environment = HEnvironment::Create(
         allocator_,
         current_locals_->size(),
         graph_->GetArtMethod(),
@@ -501,6 +503,7 @@ void HInstructionBuilder::BuildIntrinsic(ArtMethod* method) {
     HInvokeStaticOrDirect* invoke = new (allocator_) HInvokeStaticOrDirect(
         allocator_,
         number_of_arguments,
+        /* number_of_out_vregs= */ in_vregs,
         return_type_,
         kNoDexPc,
         target_method,
@@ -674,7 +677,7 @@ void HInstructionBuilder::If_21_22t(const Instruction& instruction, uint32_t dex
       DataType::Type::kInt32);
   T* comparison = nullptr;
   if (kCompareWithZero) {
-    comparison = new (allocator_) T(value, graph_->GetIntConstant(0, dex_pc), dex_pc);
+    comparison = new (allocator_) T(value, graph_->GetIntConstant(0), dex_pc);
   } else {
     HInstruction* second = LoadLocal(instruction.VRegB_22t(), DataType::Type::kInt32);
     comparison = new (allocator_) T(value, second, dex_pc);
@@ -768,7 +771,7 @@ void HInstructionBuilder::Binop_12x(const Instruction& instruction,
 template<typename T>
 void HInstructionBuilder::Binop_22s(const Instruction& instruction, bool reverse, uint32_t dex_pc) {
   HInstruction* first = LoadLocal(instruction.VRegB_22s(), DataType::Type::kInt32);
-  HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22s(), dex_pc);
+  HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22s());
   if (reverse) {
     std::swap(first, second);
   }
@@ -779,7 +782,7 @@ void HInstructionBuilder::Binop_22s(const Instruction& instruction, bool reverse
 template<typename T>
 void HInstructionBuilder::Binop_22b(const Instruction& instruction, bool reverse, uint32_t dex_pc) {
   HInstruction* first = LoadLocal(instruction.VRegB_22b(), DataType::Type::kInt32);
-  HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22b(), dex_pc);
+  HInstruction* second = graph_->GetIntConstant(instruction.VRegC_22b());
   if (reverse) {
     std::swap(first, second);
   }
@@ -822,7 +825,7 @@ void HInstructionBuilder::BuildSwitch(const Instruction& instruction, uint32_t d
     AppendInstruction(new (allocator_) HGoto(dex_pc));
   } else if (table.ShouldBuildDecisionTree()) {
     for (DexSwitchTableIterator it(table); !it.Done(); it.Advance()) {
-      HInstruction* case_value = graph_->GetIntConstant(it.CurrentKey(), dex_pc);
+      HInstruction* case_value = graph_->GetIntConstant(it.CurrentKey());
       HEqual* comparison = new (allocator_) HEqual(value, case_value, dex_pc);
       AppendInstruction(comparison);
       AppendInstruction(new (allocator_) HIf(comparison, dex_pc));
@@ -934,13 +937,20 @@ static ArtMethod* ResolveMethod(uint16_t method_idx,
   ClassLinker* class_linker = dex_compilation_unit.GetClassLinker();
   Handle<mirror::ClassLoader> class_loader = dex_compilation_unit.GetClassLoader();
 
-  ArtMethod* resolved_method =
-      class_linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
+  ArtMethod* resolved_method = nullptr;
+  if (referrer == nullptr) {
+    // The referrer may be unresolved for AOT if we're compiling a class that cannot be
+    // resolved because, for example, we don't find a superclass in the classpath.
+    resolved_method = class_linker->ResolveMethodId(
+        method_idx, dex_compilation_unit.GetDexCache(), class_loader);
+  } else if (referrer->SkipAccessChecks()) {
+    resolved_method = class_linker->ResolveMethodId(method_idx, referrer);
+  } else {
+    resolved_method = class_linker->ResolveMethodWithChecks(
           method_idx,
-          dex_compilation_unit.GetDexCache(),
-          class_loader,
           referrer,
           *invoke_type);
+  }
 
   if (UNLIKELY(resolved_method == nullptr)) {
     // Clean up any exception left by type resolution.
@@ -949,9 +959,18 @@ static ArtMethod* ResolveMethod(uint16_t method_idx,
   }
   DCHECK(!soa.Self()->IsExceptionPending());
 
-  // The referrer may be unresolved for AOT if we're compiling a class that cannot be
-  // resolved because, for example, we don't find a superclass in the classpath.
   if (referrer == nullptr) {
+    ObjPtr<mirror::Class> referenced_class = class_linker->LookupResolvedType(
+        dex_compilation_unit.GetDexFile()->GetMethodId(method_idx).class_idx_,
+        dex_compilation_unit.GetDexCache().Get(),
+        class_loader.Get());
+    DCHECK(referenced_class != nullptr);  // Must have been resolved when resolving the method.
+    if (class_linker->ThrowIfInvokeClassMismatch(referenced_class,
+                                                 *dex_compilation_unit.GetDexFile(),
+                                                 *invoke_type)) {
+      soa.Self()->ClearException();
+      return nullptr;
+    }
     // The class linker cannot check access without a referrer, so we have to do it.
     // Check if the declaring class or referencing class is accessible.
     SamePackageCompare same_package(dex_compilation_unit);
@@ -960,11 +979,6 @@ static ArtMethod* ResolveMethod(uint16_t method_idx,
     if (!declaring_class_accessible) {
       // It is possible to access members from an inaccessible superclass
       // by referencing them through an accessible subclass.
-      ObjPtr<mirror::Class> referenced_class = class_linker->LookupResolvedType(
-          dex_compilation_unit.GetDexFile()->GetMethodId(method_idx).class_idx_,
-          dex_compilation_unit.GetDexCache().Get(),
-          class_loader.Get());
-      DCHECK(referenced_class != nullptr);  // Must have been resolved when resolving the method.
       if (!referenced_class->IsPublic() && !same_package(referenced_class)) {
         return nullptr;
       }
@@ -1066,6 +1080,7 @@ bool HInstructionBuilder::BuildInvoke(const Instruction& instruction,
                     MethodCompilationStat::kUnresolvedMethod);
     HInvoke* invoke = new (allocator_) HInvokeUnresolved(allocator_,
                                                          number_of_arguments,
+                                                         operands.GetNumberOfOperands(),
                                                          return_type,
                                                          dex_pc,
                                                          method_reference,
@@ -1086,6 +1101,7 @@ bool HInstructionBuilder::BuildInvoke(const Instruction& instruction,
     HInvoke* invoke = new (allocator_) HInvokeStaticOrDirect(
         allocator_,
         number_of_arguments - 1,
+        operands.GetNumberOfOperands() - 1,
         /* return_type= */ DataType::Type::kReference,
         dex_pc,
         method_reference,
@@ -1151,6 +1167,7 @@ bool HInstructionBuilder::BuildInvoke(const Instruction& instruction,
     }
     invoke = new (allocator_) HInvokeStaticOrDirect(allocator_,
                                                     number_of_arguments,
+                                                    operands.GetNumberOfOperands(),
                                                     return_type,
                                                     dex_pc,
                                                     method_reference,
@@ -1170,6 +1187,7 @@ bool HInstructionBuilder::BuildInvoke(const Instruction& instruction,
   } else if (invoke_type == kVirtual) {
     invoke = new (allocator_) HInvokeVirtual(allocator_,
                                              number_of_arguments,
+                                             operands.GetNumberOfOperands(),
                                              return_type,
                                              dex_pc,
                                              method_reference,
@@ -1191,6 +1209,7 @@ bool HInstructionBuilder::BuildInvoke(const Instruction& instruction,
             .method_load_kind;
     invoke = new (allocator_) HInvokeInterface(allocator_,
                                                number_of_arguments,
+                                               operands.GetNumberOfOperands(),
                                                return_type,
                                                dex_pc,
                                                method_reference,
@@ -1357,7 +1376,7 @@ static void DecideVarHandleIntrinsic(HInvoke* invoke) {
         optimizations.SetDoNotIntrinsify();
         return;
       }
-      if (value_type != return_type) {
+      if (value_type != return_type && return_type != DataType::Type::kVoid) {
         optimizations.SetDoNotIntrinsify();
         return;
       }
@@ -1394,19 +1413,15 @@ bool HInstructionBuilder::BuildInvokePolymorphic(uint32_t dex_pc,
   // MethodHandle.invokeExact intrinsic needs to check whether call-site matches with MethodHandle's
   // type. To do that, MethodType corresponding to the call-site is passed as an extra input.
   // Other invoke-polymorphic calls do not need it.
-  bool is_invoke_exact =
+  bool can_be_intrinsified =
       static_cast<Intrinsics>(resolved_method->GetIntrinsic()) ==
           Intrinsics::kMethodHandleInvokeExact;
-  // Currently intrinsic works for MethodHandle targeting invoke-virtual calls only.
-  bool can_be_virtual = number_of_arguments >= 2 &&
-      DataType::FromShorty(shorty[1]) == DataType::Type::kReference;
-
-  bool can_be_intrinsified = is_invoke_exact && can_be_virtual;
 
   uint32_t number_of_other_inputs = can_be_intrinsified ? 1u : 0u;
 
   HInvoke* invoke = new (allocator_) HInvokePolymorphic(allocator_,
                                                         number_of_arguments,
+                                                        operands.GetNumberOfOperands(),
                                                         number_of_other_inputs,
                                                         return_type,
                                                         dex_pc,
@@ -1418,7 +1433,7 @@ bool HInstructionBuilder::BuildInvokePolymorphic(uint32_t dex_pc,
     return false;
   }
 
-  DCHECK_EQ(invoke->AsInvokePolymorphic()->CanHaveFastPath(), can_be_intrinsified);
+  DCHECK_EQ(invoke->AsInvokePolymorphic()->IsMethodHandleInvokeExact(), can_be_intrinsified);
 
   if (invoke->GetIntrinsic() != Intrinsics::kNone &&
       invoke->GetIntrinsic() != Intrinsics::kMethodHandleInvoke &&
@@ -1451,6 +1466,7 @@ bool HInstructionBuilder::BuildInvokeCustom(uint32_t dex_pc,
   MethodReference method_reference(&graph_->GetDexFile(), dex::kDexNoIndex);
   HInvoke* invoke = new (allocator_) HInvokeCustom(allocator_,
                                                    number_of_arguments,
+                                                   operands.GetNumberOfOperands(),
                                                    call_site_idx,
                                                    return_type,
                                                    dex_pc,
@@ -1902,7 +1918,7 @@ bool HInstructionBuilder::SetupInvokeArguments(HInstruction* invoke,
 
     // MethodHandle.invokeExact intrinsic expects MethodType corresponding to the call-site as an
     // extra input to determine whether to throw WrongMethodTypeException or execute target method.
-    if (invoke_polymorphic->CanHaveFastPath()) {
+    if (invoke_polymorphic->IsMethodHandleInvokeExact()) {
       HLoadMethodType* load_method_type =
           new (allocator_) HLoadMethodType(graph_->GetCurrentMethod(),
                                            invoke_polymorphic->GetProtoIndex(),
@@ -2420,9 +2436,9 @@ void HInstructionBuilder::BuildCheckedDivRem(uint16_t out_vreg,
   HInstruction* second = nullptr;
   if (second_is_constant) {
     if (type == DataType::Type::kInt32) {
-      second = graph_->GetIntConstant(second_vreg_or_constant, dex_pc);
+      second = graph_->GetIntConstant(second_vreg_or_constant);
     } else {
-      second = graph_->GetLongConstant(second_vreg_or_constant, dex_pc);
+      second = graph_->GetLongConstant(second_vreg_or_constant);
     }
   } else {
     second = LoadLocal(second_vreg_or_constant, type);
@@ -2490,7 +2506,7 @@ HNewArray* HInstructionBuilder::BuildFilledNewArray(uint32_t dex_pc,
                                                     dex::TypeIndex type_index,
                                                     const InstructionOperands& operands) {
   const size_t number_of_operands = operands.GetNumberOfOperands();
-  HInstruction* length = graph_->GetIntConstant(number_of_operands, dex_pc);
+  HInstruction* length = graph_->GetIntConstant(number_of_operands);
 
   HNewArray* new_array = BuildNewArray(dex_pc, type_index, length);
   const char* descriptor = dex_file_->GetTypeDescriptor(type_index);
@@ -2504,7 +2520,7 @@ HNewArray* HInstructionBuilder::BuildFilledNewArray(uint32_t dex_pc,
 
   for (size_t i = 0; i < number_of_operands; ++i) {
     HInstruction* value = LoadLocal(operands.GetOperand(i), type);
-    HInstruction* index = graph_->GetIntConstant(i, dex_pc);
+    HInstruction* index = graph_->GetIntConstant(i);
     HArraySet* aset = new (allocator_) HArraySet(new_array, index, value, type, dex_pc);
     ssa_builder_->MaybeAddAmbiguousArraySet(aset);
     AppendInstruction(aset);
@@ -2521,8 +2537,8 @@ void HInstructionBuilder::BuildFillArrayData(HInstruction* object,
                                              DataType::Type anticipated_type,
                                              uint32_t dex_pc) {
   for (uint32_t i = 0; i < element_count; ++i) {
-    HInstruction* index = graph_->GetIntConstant(i, dex_pc);
-    HInstruction* value = graph_->GetIntConstant(data[i], dex_pc);
+    HInstruction* index = graph_->GetIntConstant(i);
+    HInstruction* value = graph_->GetIntConstant(data[i]);
     HArraySet* aset = new (allocator_) HArraySet(object, index, value, anticipated_type, dex_pc);
     ssa_builder_->MaybeAddAmbiguousArraySet(aset);
     AppendInstruction(aset);
@@ -2549,7 +2565,7 @@ void HInstructionBuilder::BuildFillArrayData(const Instruction& instruction, uin
 
   // Implementation of this DEX instruction seems to be that the bounds check is
   // done before doing any stores.
-  HInstruction* last_index = graph_->GetIntConstant(payload->element_count - 1, dex_pc);
+  HInstruction* last_index = graph_->GetIntConstant(payload->element_count - 1);
   AppendInstruction(new (allocator_) HBoundsCheck(last_index, length, dex_pc));
 
   switch (payload->element_width) {
@@ -2591,8 +2607,8 @@ void HInstructionBuilder::BuildFillWideArrayData(HInstruction* object,
                                                  uint32_t element_count,
                                                  uint32_t dex_pc) {
   for (uint32_t i = 0; i < element_count; ++i) {
-    HInstruction* index = graph_->GetIntConstant(i, dex_pc);
-    HInstruction* value = graph_->GetLongConstant(data[i], dex_pc);
+    HInstruction* index = graph_->GetIntConstant(i);
+    HInstruction* value = graph_->GetLongConstant(data[i]);
     HArraySet* aset =
         new (allocator_) HArraySet(object, index, value, DataType::Type::kInt64, dex_pc);
     ssa_builder_->MaybeAddAmbiguousArraySet(aset);
@@ -2775,13 +2791,13 @@ void HInstructionBuilder::BuildTypeCheck(bool is_instance_of,
   if (check_kind == TypeCheckKind::kBitstringCheck) {
     // TODO: Allow using the bitstring check also if we need an access check.
     DCHECK(!needs_access_check);
-    class_or_null = graph_->GetNullConstant(dex_pc);
+    class_or_null = graph_->GetNullConstant();
     MutexLock subtype_check_lock(Thread::Current(), *Locks::subtype_check_lock_);
     uint32_t path_to_root =
         SubtypeCheck<ObjPtr<mirror::Class>>::GetEncodedPathToRootForTarget(klass.Get());
     uint32_t mask = SubtypeCheck<ObjPtr<mirror::Class>>::GetEncodedPathToRootMask(klass.Get());
-    bitstring_path_to_root = graph_->GetIntConstant(static_cast<int32_t>(path_to_root), dex_pc);
-    bitstring_mask = graph_->GetIntConstant(static_cast<int32_t>(mask), dex_pc);
+    bitstring_path_to_root = graph_->GetIntConstant(static_cast<int32_t>(path_to_root));
+    bitstring_mask = graph_->GetIntConstant(static_cast<int32_t>(mask));
   } else {
     class_or_null = BuildLoadClass(type_index, dex_file, klass, dex_pc, needs_access_check);
   }
@@ -2835,28 +2851,28 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
   switch (instruction.Opcode()) {
     case Instruction::CONST_4: {
       int32_t register_index = instruction.VRegA_11n();
-      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_11n(), dex_pc);
+      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_11n());
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_16: {
       int32_t register_index = instruction.VRegA_21s();
-      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21s(), dex_pc);
+      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21s());
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST: {
       int32_t register_index = instruction.VRegA_31i();
-      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_31i(), dex_pc);
+      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_31i());
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_HIGH16: {
       int32_t register_index = instruction.VRegA_21h();
-      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21h() << 16, dex_pc);
+      HIntConstant* constant = graph_->GetIntConstant(instruction.VRegB_21h() << 16);
       UpdateLocal(register_index, constant);
       break;
     }
@@ -2867,7 +2883,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
       int64_t value = instruction.VRegB_21s();
       value <<= 48;
       value >>= 48;
-      HLongConstant* constant = graph_->GetLongConstant(value, dex_pc);
+      HLongConstant* constant = graph_->GetLongConstant(value);
       UpdateLocal(register_index, constant);
       break;
     }
@@ -2878,14 +2894,14 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
       int64_t value = instruction.VRegB_31i();
       value <<= 32;
       value >>= 32;
-      HLongConstant* constant = graph_->GetLongConstant(value, dex_pc);
+      HLongConstant* constant = graph_->GetLongConstant(value);
       UpdateLocal(register_index, constant);
       break;
     }
 
     case Instruction::CONST_WIDE: {
       int32_t register_index = instruction.VRegA_51l();
-      HLongConstant* constant = graph_->GetLongConstant(instruction.VRegB_51l(), dex_pc);
+      HLongConstant* constant = graph_->GetLongConstant(instruction.VRegB_51l());
       UpdateLocal(register_index, constant);
       break;
     }
@@ -2893,7 +2909,7 @@ bool HInstructionBuilder::ProcessDexInstruction(const Instruction& instruction,
     case Instruction::CONST_WIDE_HIGH16: {
       int32_t register_index = instruction.VRegA_21h();
       int64_t value = static_cast<int64_t>(instruction.VRegB_21h()) << 48;
-      HLongConstant* constant = graph_->GetLongConstant(value, dex_pc);
+      HLongConstant* constant = graph_->GetLongConstant(value);
       UpdateLocal(register_index, constant);
       break;
     }
diff --git a/compiler/optimizing/instruction_simplifier.cc b/compiler/optimizing/instruction_simplifier.cc
index a09a9f0ead..703f6c77e8 100644
--- a/compiler/optimizing/instruction_simplifier.cc
+++ b/compiler/optimizing/instruction_simplifier.cc
@@ -709,6 +709,9 @@ bool InstructionSimplifierVisitor::TryReplaceWithRotateRegisterSubPattern(HBinar
 
 void InstructionSimplifierVisitor::VisitNullCheck(HNullCheck* null_check) {
   HInstruction* obj = null_check->InputAt(0);
+  // Note we don't do `CanEnsureNotNullAt` here. If we do that, we may get rid of a NullCheck but
+  // what we should do instead is coalesce them. This is what GVN does, and so InstructionSimplifier
+  // doesn't do this.
   if (!obj->CanBeNull()) {
     null_check->ReplaceWith(obj);
     null_check->GetBlock()->RemoveInstruction(null_check);
@@ -911,7 +914,7 @@ HInstruction* InstructionSimplifierVisitor::InsertOppositeCondition(HInstruction
     HInstruction* lhs = cond->InputAt(0);
     HInstruction* rhs = cond->InputAt(1);
     HInstruction* replacement =
-        GetGraph()->CreateCondition(cond->AsCondition()->GetOppositeCondition(), lhs, rhs);
+        HCondition::Create(GetGraph(), cond->AsCondition()->GetOppositeCondition(), lhs, rhs);
     cursor->GetBlock()->InsertInstructionBefore(replacement, cursor);
     return replacement;
   } else if (cond->IsIntConstant()) {
@@ -1840,7 +1843,7 @@ static HInstruction* CreateUnsignedConditionReplacement(ArenaAllocator* allocato
       //   unsigned(-1) < 0 -> False
       //   0 < 0 -> False
       //   1 < 0 -> False
-      return block->GetGraph()->GetConstant(DataType::Type::kBool, 0, cond->GetDexPc());
+      return block->GetGraph()->GetConstant(DataType::Type::kBool, 0);
     case HInstruction::kBelowOrEqual:
       // BelowOrEqual(Compare(x, y), 0) transforms into Equal(x, y)
       //    unsigned(-1) <= 0 -> False
@@ -1858,7 +1861,7 @@ static HInstruction* CreateUnsignedConditionReplacement(ArenaAllocator* allocato
       //   unsigned(-1) >= 0 -> True
       //   0 >= 0 -> True
       //   1 >= 0 -> True
-      return block->GetGraph()->GetConstant(DataType::Type::kBool, 1, cond->GetDexPc());
+      return block->GetGraph()->GetConstant(DataType::Type::kBool, 1);
     default:
       LOG(FATAL) << "Unknown ConditionType " << cond->GetKind();
       UNREACHABLE();
@@ -1879,7 +1882,7 @@ void InstructionSimplifierVisitor::VisitCondition(HCondition* condition) {
   HInstruction* right = condition->GetRight();
   if (left->IsConstant() && !right->IsConstant()) {
     IfCondition new_cond = GetOppositeConditionForOperandSwap(condition->GetCondition());
-    HCondition* replacement = GetGraph()->CreateCondition(new_cond, right, left);
+    HCondition* replacement = HCondition::Create(GetGraph(), new_cond, right, left);
     block->ReplaceAndRemoveInstructionWith(condition, replacement);
     // If it is a FP condition, we must set the opposite bias.
     if (condition->IsLtBias()) {
@@ -1961,12 +1964,12 @@ static HInstruction* CheckSignedToUnsignedCompareConversion(HInstruction* operan
       HIntConstant* int_constant = constant->AsIntConstant();
       int32_t old_value = int_constant->GetValue();
       int32_t new_value = old_value - std::numeric_limits<int32_t>::min();
-      return operand->GetBlock()->GetGraph()->GetIntConstant(new_value, constant->GetDexPc());
+      return operand->GetBlock()->GetGraph()->GetIntConstant(new_value);
     } else if (constant->IsLongConstant()) {
       HLongConstant* long_constant = constant->AsLongConstant();
       int64_t old_value = long_constant->GetValue();
       int64_t new_value = old_value - std::numeric_limits<int64_t>::min();
-      return operand->GetBlock()->GetGraph()->GetLongConstant(new_value, constant->GetDexPc());
+      return operand->GetBlock()->GetGraph()->GetLongConstant(new_value);
     } else {
       return nullptr;
     }
@@ -2973,13 +2976,8 @@ void InstructionSimplifierVisitor::SimplifyReturnThis(HInvoke* invoke) {
 
 // Helper method for StringBuffer escape analysis.
 static bool NoEscapeForStringBufferReference(HInstruction* reference, HInstruction* user) {
-  if (user->IsInvokeStaticOrDirect()) {
-    // Any constructor on StringBuffer is okay.
-    return user->AsInvokeStaticOrDirect()->GetResolvedMethod() != nullptr &&
-           user->AsInvokeStaticOrDirect()->GetResolvedMethod()->IsConstructor() &&
-           user->InputAt(0) == reference;
-  } else if (user->IsInvokeVirtual()) {
-    switch (user->AsInvokeVirtual()->GetIntrinsic()) {
+  if (user->IsInvoke()) {
+    switch (user->AsInvoke()->GetIntrinsic()) {
       case Intrinsics::kStringBufferLength:
       case Intrinsics::kStringBufferToString:
         DCHECK_EQ(user->InputAt(0), reference);
@@ -2993,10 +2991,18 @@ static bool NoEscapeForStringBufferReference(HInstruction* reference, HInstructi
         break;
     }
   }
+
+  if (user->IsInvokeStaticOrDirect()) {
+    // Any constructor on StringBuffer is okay.
+    return user->AsInvokeStaticOrDirect()->GetResolvedMethod() != nullptr &&
+           user->AsInvokeStaticOrDirect()->GetResolvedMethod()->IsConstructor() &&
+           user->InputAt(0) == reference;
+  }
+
   return false;
 }
 
-static bool TryReplaceStringBuilderAppend(HInvoke* invoke) {
+static bool TryReplaceStringBuilderAppend(CodeGenerator* codegen, HInvoke* invoke) {
   DCHECK_EQ(invoke->GetIntrinsic(), Intrinsics::kStringBuilderToString);
   if (invoke->CanThrowIntoCatchBlock()) {
     return false;
@@ -3048,13 +3054,24 @@ static bool TryReplaceStringBuilderAppend(HInvoke* invoke) {
         return false;
       }
     }
-    // Then we should see the arguments.
-    if (user->IsInvokeVirtual()) {
-      HInvokeVirtual* as_invoke_virtual = user->AsInvokeVirtual();
+
+    // Pattern match seeing arguments, then constructor, then constructor fence.
+    if (user->IsInvokeStaticOrDirect() &&
+        user->AsInvokeStaticOrDirect()->GetResolvedMethod() != nullptr &&
+        user->AsInvokeStaticOrDirect()->GetResolvedMethod()->IsConstructor() &&
+        user->AsInvokeStaticOrDirect()->GetNumberOfArguments() == 1u) {
+      // After arguments, we should see the constructor.
+      // We accept only the constructor with no extra arguments.
+      DCHECK(!seen_constructor);
+      DCHECK(!seen_constructor_fence);
+      seen_constructor = true;
+    } else if (user->IsInvoke()) {
+      // The arguments.
+      HInvoke* as_invoke = user->AsInvoke();
       DCHECK(!seen_constructor);
       DCHECK(!seen_constructor_fence);
       StringBuilderAppend::Argument arg;
-      switch (as_invoke_virtual->GetIntrinsic()) {
+      switch (as_invoke->GetIntrinsic()) {
         case Intrinsics::kStringBuilderAppendObject:
           // TODO: Unimplemented, needs to call String.valueOf().
           return false;
@@ -3086,7 +3103,7 @@ static bool TryReplaceStringBuilderAppend(HInvoke* invoke) {
           has_fp_args = true;
           break;
         case Intrinsics::kStringBuilderAppendCharSequence: {
-          ReferenceTypeInfo rti = user->AsInvokeVirtual()->InputAt(1)->GetReferenceTypeInfo();
+          ReferenceTypeInfo rti = as_invoke->InputAt(1)->GetReferenceTypeInfo();
           if (!rti.IsValid()) {
             return false;
           }
@@ -3109,23 +3126,14 @@ static bool TryReplaceStringBuilderAppend(HInvoke* invoke) {
         }
       }
       // Uses of the append return value should have been replaced with the first input.
-      DCHECK(!as_invoke_virtual->HasUses());
-      DCHECK(!as_invoke_virtual->HasEnvironmentUses());
+      DCHECK(!as_invoke->HasUses());
+      DCHECK(!as_invoke->HasEnvironmentUses());
       if (num_args == StringBuilderAppend::kMaxArgs) {
         return false;
       }
       format = (format << StringBuilderAppend::kBitsPerArg) | static_cast<uint32_t>(arg);
-      args[num_args] = as_invoke_virtual->InputAt(1u);
+      args[num_args] = as_invoke->InputAt(1u);
       ++num_args;
-    } else if (user->IsInvokeStaticOrDirect() &&
-               user->AsInvokeStaticOrDirect()->GetResolvedMethod() != nullptr &&
-               user->AsInvokeStaticOrDirect()->GetResolvedMethod()->IsConstructor() &&
-               user->AsInvokeStaticOrDirect()->GetNumberOfArguments() == 1u) {
-      // After arguments, we should see the constructor.
-      // We accept only the constructor with no extra arguments.
-      DCHECK(!seen_constructor);
-      DCHECK(!seen_constructor_fence);
-      seen_constructor = true;
     } else if (user->IsConstructorFence()) {
       // The last use we see is the constructor fence.
       DCHECK(seen_constructor);
@@ -3153,11 +3161,25 @@ static bool TryReplaceStringBuilderAppend(HInvoke* invoke) {
     }
   }
 
+  // Calculate outgoing vregs, including padding for 64-bit arg alignment.
+  const PointerSize pointer_size = InstructionSetPointerSize(codegen->GetInstructionSet());
+  const size_t method_vregs = static_cast<size_t>(pointer_size) / kVRegSize;
+  uint32_t number_of_out_vregs = method_vregs;  // For correct alignment padding; subtracted below.
+  for (uint32_t f = format; f != 0u; f >>= StringBuilderAppend::kBitsPerArg) {
+    auto a = enum_cast<StringBuilderAppend::Argument>(f & StringBuilderAppend::kArgMask);
+    if (a == StringBuilderAppend::Argument::kLong || a == StringBuilderAppend::Argument::kDouble) {
+      number_of_out_vregs += /* alignment */ ((number_of_out_vregs) & 1u) + /* vregs */ 2u;
+    } else {
+      number_of_out_vregs += /* vregs */ 1u;
+    }
+  }
+  number_of_out_vregs -= method_vregs;
+
   // Create replacement instruction.
   HIntConstant* fmt = block->GetGraph()->GetIntConstant(static_cast<int32_t>(format));
   ArenaAllocator* allocator = block->GetGraph()->GetAllocator();
   HStringBuilderAppend* append = new (allocator) HStringBuilderAppend(
-      fmt, num_args, has_fp_args, allocator, invoke->GetDexPc());
+      fmt, num_args, number_of_out_vregs, has_fp_args, allocator, invoke->GetDexPc());
   append->SetReferenceTypeInfoIfValid(invoke->GetReferenceTypeInfo());
   for (size_t i = 0; i != num_args; ++i) {
     append->SetArgumentAt(i, args[num_args - 1u - i]);
@@ -3202,7 +3224,7 @@ void InstructionSimplifierVisitor::SimplifyAllocationIntrinsic(HInvoke* invoke)
       RecordSimplification();
     }
   } else if (invoke->GetIntrinsic() == Intrinsics::kStringBuilderToString &&
-             TryReplaceStringBuilderAppend(invoke)) {
+             TryReplaceStringBuilderAppend(codegen_, invoke)) {
     RecordSimplification();
   }
 }
diff --git a/compiler/optimizing/instruction_simplifier_shared.cc b/compiler/optimizing/instruction_simplifier_shared.cc
index 7f575c0348..2215b93414 100644
--- a/compiler/optimizing/instruction_simplifier_shared.cc
+++ b/compiler/optimizing/instruction_simplifier_shared.cc
@@ -320,18 +320,15 @@ void UnfoldRotateLeft(HRol* rol) {
   HBasicBlock* block = rol->GetBlock();
   HGraph* graph = block->GetGraph();
   ArenaAllocator* allocator = graph->GetAllocator();
-  HRor* ror;
-
+  HInstruction* neg;
   if (rol->GetRight()->IsConstant()) {
     int32_t value = rol->GetRight()->AsIntConstant()->GetValue();
-    HIntConstant* negated = graph->GetIntConstant(-value);
-    ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), negated);
+    neg = graph->GetIntConstant(-value);
   } else {
-    HNeg* neg = new (allocator) HNeg(DataType::Type::kInt32, rol->GetRight());
+    neg = new (allocator) HNeg(DataType::Type::kInt32, rol->GetRight());
     block->InsertInstructionBefore(neg, rol);
-    ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), neg);
   }
-
+  HInstruction* ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), neg);
   block->ReplaceAndRemoveInstructionWith(rol, ror);
 }
 
diff --git a/compiler/optimizing/instruction_simplifier_x86.cc b/compiler/optimizing/instruction_simplifier_x86.cc
index e1c783e5b8..9b5fb52509 100644
--- a/compiler/optimizing/instruction_simplifier_x86.cc
+++ b/compiler/optimizing/instruction_simplifier_x86.cc
@@ -48,7 +48,6 @@ class InstructionSimplifierX86Visitor final : public HGraphVisitor {
   }
 
   void VisitAnd(HAnd * instruction) override;
-  void VisitRol(HRol* instruction) override;
   void VisitXor(HXor* instruction) override;
 
  private:
@@ -71,21 +70,6 @@ void InstructionSimplifierX86Visitor::VisitAnd(HAnd* instruction) {
   }
 }
 
-void InstructionSimplifierX86Visitor::VisitRol(HRol* rol) {
-  if (rol->GetType() != DataType::Type::kInt64) {
-    return;
-  }
-
-  HBasicBlock* block = rol->GetBlock();
-  HGraph* graph = block->GetGraph();
-  ArenaAllocator* allocator = graph->GetAllocator();
-
-  HNeg* neg = new (allocator) HNeg(DataType::Type::kInt32, rol->GetRight());
-  block->InsertInstructionBefore(neg, rol);
-  HRor* ror = new (allocator) HRor(rol->GetType(), rol->GetLeft(), neg);
-  block->ReplaceAndRemoveInstructionWith(rol, ror);
-}
-
 void InstructionSimplifierX86Visitor::VisitXor(HXor* instruction) {
   if (!HasAVX2()) {
     return;
diff --git a/compiler/optimizing/intrinsics.cc b/compiler/optimizing/intrinsics.cc
index 06ea1c6ffb..b87f6f3975 100644
--- a/compiler/optimizing/intrinsics.cc
+++ b/compiler/optimizing/intrinsics.cc
@@ -254,6 +254,7 @@ void InsertFpToIntegralIntrinsic(HInvokeStaticOrDirect* invoke, size_t input_ind
   HInvokeStaticOrDirect* new_input = new (allocator) HInvokeStaticOrDirect(
       allocator,
       /*number_of_arguments=*/ 1u,
+      /*number_of_out_vregs=*/ is_double ? 2u : 1u,
       converted_type,
       invoke->GetDexPc(),
       /*method_reference=*/ MethodReference(nullptr, dex::kDexNoIndex),
diff --git a/compiler/optimizing/intrinsics_arm64.cc b/compiler/optimizing/intrinsics_arm64.cc
index 71ef84e1aa..1974d75c47 100644
--- a/compiler/optimizing/intrinsics_arm64.cc
+++ b/compiler/optimizing/intrinsics_arm64.cc
@@ -30,10 +30,12 @@
 #include "intrinsics_utils.h"
 #include "lock_word.h"
 #include "mirror/array-inl.h"
+#include "mirror/method_handle_impl.h"
 #include "mirror/object_array-inl.h"
 #include "mirror/reference.h"
 #include "mirror/string-inl.h"
 #include "mirror/var_handle.h"
+#include "optimizing/data_type.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 #include "utils/arm64/assembler_arm64.h"
@@ -160,6 +162,39 @@ class ReadBarrierSystemArrayCopySlowPathARM64 : public SlowPathCodeARM64 {
 
   DISALLOW_COPY_AND_ASSIGN(ReadBarrierSystemArrayCopySlowPathARM64);
 };
+
+// The MethodHandle.invokeExact intrinsic sets up arguments to match the target method call. If we
+// need to go to the slow path, we call art_quick_invoke_polymorphic_with_hidden_receiver, which
+// expects the MethodHandle object in w0 (in place of the actual ArtMethod).
+class InvokePolymorphicSlowPathARM64 : public SlowPathCodeARM64 {
+ public:
+  InvokePolymorphicSlowPathARM64(HInstruction* instruction, Register method_handle)
+      : SlowPathCodeARM64(instruction), method_handle_(method_handle) {
+    DCHECK(instruction->IsInvokePolymorphic());
+  }
+
+  void EmitNativeCode(CodeGenerator* codegen_in) override {
+    CodeGeneratorARM64* codegen = down_cast<CodeGeneratorARM64*>(codegen_in);
+    __ Bind(GetEntryLabel());
+
+    SaveLiveRegisters(codegen, instruction_->GetLocations());
+    // Passing `MethodHandle` object as hidden argument.
+    __ Mov(w0, method_handle_.W());
+    codegen->InvokeRuntime(QuickEntrypointEnum::kQuickInvokePolymorphicWithHiddenReceiver,
+                           instruction_,
+                           instruction_->GetDexPc());
+
+    RestoreLiveRegisters(codegen, instruction_->GetLocations());
+    __ B(GetExitLabel());
+  }
+
+  const char* GetDescription() const override { return "InvokePolymorphicSlowPathARM64"; }
+
+ private:
+  const Register method_handle_;
+  DISALLOW_COPY_AND_ASSIGN(InvokePolymorphicSlowPathARM64);
+};
+
 #undef __
 
 bool IntrinsicLocationsBuilderARM64::TryDispatch(HInvoke* invoke) {
@@ -706,7 +741,6 @@ static bool ReadBarrierNeedsTemp(bool is_volatile, HInvoke* invoke) {
       invoke->InputAt(2)->AsLongConstant()->GetValue() >= kReferenceLoadMinFarOffset;
 }
 
-
 static void GenUnsafeGet(HInvoke* invoke,
                          DataType::Type type,
                          bool is_volatile,
@@ -769,6 +803,26 @@ static void GenUnsafeGet(HInvoke* invoke,
   }
 }
 
+static void GenUnsafeGetAbsolute(HInvoke* invoke,
+                                 DataType::Type type,
+                                 bool is_volatile,
+                                 CodeGeneratorARM64* codegen) {
+  LocationSummary* locations = invoke->GetLocations();
+  DCHECK((type == DataType::Type::kInt8) ||
+         (type == DataType::Type::kInt32) ||
+         (type == DataType::Type::kInt64));
+  Location address_loc = locations->InAt(1);
+  MemOperand mem_op = MemOperand(XRegisterFrom(address_loc));
+  Location trg_loc = locations->Out();
+  Register trg = RegisterFrom(trg_loc, type);
+
+  if (is_volatile) {
+    codegen->LoadAcquire(invoke, type, trg, mem_op, /* needs_null_check= */ true);
+  } else {
+    codegen->Load(type, trg, mem_op);
+  }
+}
+
 static void CreateUnsafeGetLocations(ArenaAllocator* allocator,
                                      HInvoke* invoke,
                                      CodeGeneratorARM64* codegen,
@@ -795,9 +849,21 @@ static void CreateUnsafeGetLocations(ArenaAllocator* allocator,
                     (can_call ? Location::kOutputOverlap : Location::kNoOutputOverlap));
 }
 
+static void CreateUnsafeGetAbsoluteLocations(ArenaAllocator* allocator,
+                                             HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+}
+
 void IntrinsicLocationsBuilderARM64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicLocationsBuilderARM64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderARM64::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -816,10 +882,12 @@ void IntrinsicLocationsBuilderARM64::VisitUnsafeGetObjectVolatile(HInvoke* invok
 void IntrinsicLocationsBuilderARM64::VisitUnsafeGetByte(HInvoke* invoke) {
   VisitJdkUnsafeGetByte(invoke);
 }
-
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
+void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  CreateUnsafeGetAbsoluteLocations(allocator_, invoke);
+}
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_, /* is_volatile= */ true);
 }
@@ -851,6 +919,9 @@ void IntrinsicLocationsBuilderARM64::VisitJdkUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorARM64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicCodeGeneratorARM64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorARM64::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -873,6 +944,9 @@ void IntrinsicCodeGeneratorARM64::VisitUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorARM64::VisitJdkUnsafeGet(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
+void IntrinsicCodeGeneratorARM64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  GenUnsafeGetAbsolute(invoke, DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
+}
 void IntrinsicCodeGeneratorARM64::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ true, codegen_);
 }
@@ -921,9 +995,29 @@ static void CreateUnsafePutLocations(ArenaAllocator* allocator, HInvoke* invoke)
   }
 }
 
+static void CreateUnsafePutAbsoluteLocations(ArenaAllocator* allocator, HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  static constexpr int kAddressIndex = 1;
+  static constexpr int kValueIndex = 2;
+  // Unused receiver.
+  locations->SetInAt(0, Location::NoLocation());
+  // The address.
+  locations->SetInAt(kAddressIndex, Location::RequiresRegister());
+  // The value.
+  if (IsZeroBitPattern(invoke->InputAt(kValueIndex))) {
+    locations->SetInAt(kValueIndex, Location::ConstantLocation(invoke->InputAt(kValueIndex)));
+  } else {
+    locations->SetInAt(kValueIndex, Location::RequiresRegister());
+  }
+}
+
 void IntrinsicLocationsBuilderARM64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicLocationsBuilderARM64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderARM64::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -955,6 +1049,9 @@ void IntrinsicLocationsBuilderARM64::VisitUnsafePutByte(HInvoke* invoke) {
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafePut(HInvoke* invoke) {
   CreateUnsafePutLocations(allocator_, invoke);
 }
+void IntrinsicLocationsBuilderARM64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  CreateUnsafePutAbsoluteLocations(allocator_, invoke);
+}
 void IntrinsicLocationsBuilderARM64::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   CreateUnsafePutLocations(allocator_, invoke);
 }
@@ -1003,7 +1100,7 @@ static void GenUnsafePut(HInvoke* invoke,
   static constexpr int kOffsetIndex = 2;
   static constexpr int kValueIndex = 3;
   Register base = WRegisterFrom(locations->InAt(1));    // Object pointer.
-  Location offset = locations->InAt(kOffsetIndex);       // Long offset.
+  Location offset = locations->InAt(kOffsetIndex);      // Long offset.
   CPURegister value = InputCPURegisterOrZeroRegAt(invoke, kValueIndex);
   CPURegister source = value;
   MemOperand mem_op;
@@ -1041,9 +1138,32 @@ static void GenUnsafePut(HInvoke* invoke,
   }
 }
 
+static void GenUnsafePutAbsolute(HInvoke* invoke,
+                                 DataType::Type type,
+                                 bool is_volatile,
+                                 bool is_ordered,
+                                 CodeGeneratorARM64* codegen) {
+  LocationSummary* locations = invoke->GetLocations();
+
+  static constexpr int kAddressIndex = 1;
+  static constexpr int kValueIndex = 2;
+  Location address_loc = locations->InAt(kAddressIndex);
+  MemOperand mem_op = MemOperand(WRegisterFrom(address_loc).X());
+  CPURegister value = InputCPURegisterOrZeroRegAt(invoke, kValueIndex);
+
+  if (is_volatile || is_ordered) {
+    codegen->StoreRelease(invoke, type, value, mem_op, /* needs_null_check= */ false);
+  } else {
+    codegen->Store(type, value, mem_op);
+  }
+}
+
 void IntrinsicCodeGeneratorARM64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicCodeGeneratorARM64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorARM64::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -1079,6 +1199,13 @@ void IntrinsicCodeGeneratorARM64::VisitJdkUnsafePut(HInvoke* invoke) {
                /*is_ordered=*/ false,
                codegen_);
 }
+void IntrinsicCodeGeneratorARM64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  GenUnsafePutAbsolute(invoke,
+                       DataType::Type::kInt32,
+                       /*is_volatile=*/ false,
+                       /*is_ordered=*/ false,
+                       codegen_);
+}
 void IntrinsicCodeGeneratorARM64::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   GenUnsafePut(invoke,
                DataType::Type::kInt32,
@@ -1762,17 +1889,33 @@ static void CreateUnsafeGetAndUpdateLocations(ArenaAllocator* allocator,
   locations->SetInAt(3, Location::RequiresRegister());
   locations->AddTemp(Location::RequiresRegister());
 
-  locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+  // Request another temporary register for methods that don't return a value.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  if (is_void) {
+    locations->AddTemp(Location::RequiresRegister());
+  } else {
+    locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+  }
 }
 
 static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                                   DataType::Type type,
                                   CodeGeneratorARM64* codegen,
                                   GetAndUpdateOp get_and_update_op) {
+  // Currently only used for these GetAndUpdateOp. Might be fine for other ops but double check
+  // before using.
+  DCHECK(get_and_update_op == GetAndUpdateOp::kAdd || get_and_update_op == GetAndUpdateOp::kSet);
+
   MacroAssembler* masm = codegen->GetVIXLAssembler();
   LocationSummary* locations = invoke->GetLocations();
 
-  Register out = RegisterFrom(locations->Out(), type);            // Result.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  // We use a temporary for void methods, as we don't return the value.
+  Location out_or_temp_loc =
+      is_void ? locations->GetTemp(locations->GetTempCount() - 1u) : locations->Out();
+  Register out_or_temp = RegisterFrom(out_or_temp_loc, type);     // Result.
   Register base = WRegisterFrom(locations->InAt(1));              // Object pointer.
   Register offset = XRegisterFrom(locations->InAt(2));            // Long offset.
   Register arg = RegisterFrom(locations->InAt(3), type);          // New value or addend.
@@ -1793,20 +1936,19 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                        std::memory_order_seq_cst,
                        tmp_ptr,
                        arg,
-                       /*old_value=*/ out);
+                       /*old_value=*/ out_or_temp);
 
-  if (type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
+  if (!is_void && type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
     DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
     if (kUseBakerReadBarrier) {
-      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(out.W(), out.W());
+      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(out_or_temp.W(), out_or_temp.W());
     } else {
-      codegen->GenerateReadBarrierSlow(
-          invoke,
-          Location::RegisterLocation(out.GetCode()),
-          Location::RegisterLocation(out.GetCode()),
-          Location::RegisterLocation(base.GetCode()),
-          /*offset=*/ 0u,
-          /*index=*/ Location::RegisterLocation(offset.GetCode()));
+      codegen->GenerateReadBarrierSlow(invoke,
+                                       Location::RegisterLocation(out_or_temp.GetCode()),
+                                       Location::RegisterLocation(out_or_temp.GetCode()),
+                                       Location::RegisterLocation(base.GetCode()),
+                                       /*offset=*/ 0u,
+                                       /*index=*/ Location::RegisterLocation(offset.GetCode()));
     }
   }
 }
@@ -5420,7 +5562,10 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
     return;
   }
 
-  if (invoke->GetType() == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
+  // Get the type from the shorty as the invokes may not return a value.
+  uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
+  if (value_type == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
     // Unsupported for non-Baker read barrier because the artReadBarrierSlow() ignores
     // the passed reference and reloads it from the field, thus seeing the new value
     // that we have just stored. (And it also gets the memory visibility wrong.) b/173104084
@@ -5428,10 +5573,10 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
   }
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke, codegen);
-
   size_t old_temp_count = locations->GetTempCount();
+
   DCHECK_EQ(old_temp_count, (GetExpectedVarHandleCoordinatesCount(invoke) == 0) ? 2u : 1u);
-  if (DataType::IsFloatingPointType(invoke->GetType())) {
+  if (DataType::IsFloatingPointType(value_type)) {
     if (get_and_update_op == GetAndUpdateOp::kAdd) {
       // For ADD, do not use ZR for zero bit pattern (+0.0f or +0.0).
       locations->SetInAt(invoke->GetNumberOfArguments() - 1u, Location::RequiresFpuRegister());
@@ -5451,12 +5596,23 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
       (get_and_update_op != GetAndUpdateOp::kSet && get_and_update_op != GetAndUpdateOp::kAdd) &&
       GetExpectedVarHandleCoordinatesCount(invoke) == 2u &&
       !IsZeroBitPattern(invoke->InputAt(invoke->GetNumberOfArguments() - 1u))) {
-    DataType::Type value_type =
-        GetVarHandleExpectedValueType(invoke, /*expected_coordinates_count=*/ 2u);
     if (value_type != DataType::Type::kReference && DataType::Size(value_type) != 1u) {
       locations->AddTemp(Location::RequiresRegister());
     }
   }
+
+  // Request another temporary register for methods that don't return a value.
+  // For the non-void case, we already set `out` in `CreateVarHandleCommonLocations`.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  if (is_void) {
+    if (DataType::IsFloatingPointType(value_type)) {
+      locations->AddTemp(Location::RequiresFpuRegister());
+    } else {
+      locations->AddTemp(Location::RequiresRegister());
+    }
+  }
 }
 
 static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
@@ -5464,6 +5620,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
                                           GetAndUpdateOp get_and_update_op,
                                           std::memory_order order,
                                           bool byte_swap = false) {
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
   DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
   bool is_fp = DataType::IsFloatingPointType(value_type);
@@ -5473,7 +5630,13 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
   CPURegister arg = (is_fp && get_and_update_op == GetAndUpdateOp::kAdd)
       ? InputCPURegisterAt(invoke, arg_index)
       : InputCPURegisterOrZeroRegAt(invoke, arg_index);
-  CPURegister out = helpers::OutputCPURegister(invoke);
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  // We use a temporary for void methods, as we don't return the value.
+  CPURegister out_or_temp =
+      is_void ? CPURegisterFrom(locations->GetTemp(locations->GetTempCount() - 1u), value_type) :
+                helpers::OutputCPURegister(invoke);
 
   VarHandleTarget target = GetVarHandleTarget(invoke);
   VarHandleSlowPathARM64* slow_path = nullptr;
@@ -5516,7 +5679,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
   }
 
   // Prepare register for old value.
-  CPURegister old_value = out;
+  CPURegister old_value = out_or_temp;
   if (get_and_update_op == GetAndUpdateOp::kSet) {
     // For floating point GetAndSet, do the GenerateGetAndUpdate() with core registers,
     // rather than moving between core and FP registers in the loop.
@@ -5554,36 +5717,40 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
 
   GenerateGetAndUpdate(codegen, get_and_update_op, load_store_type, order, tmp_ptr, arg, old_value);
 
-  if (get_and_update_op == GetAndUpdateOp::kAddWithByteSwap) {
-    // The only adjustment needed is sign-extension for `kInt16`.
-    // Everything else has been done by the `GenerateGetAndUpdate()`.
-    DCHECK(byte_swap);
-    if (value_type == DataType::Type::kInt16) {
-      DCHECK_EQ(load_store_type, DataType::Type::kUint16);
-      __ Sxth(out.W(), old_value.W());
-    }
-  } else if (byte_swap) {
-    // Also handles moving to FP registers.
-    GenerateReverseBytes(masm, value_type, old_value, out);
-  } else if (get_and_update_op == GetAndUpdateOp::kSet && value_type == DataType::Type::kFloat64) {
-    __ Fmov(out.D(), old_value.X());
-  } else if (get_and_update_op == GetAndUpdateOp::kSet && value_type == DataType::Type::kFloat32) {
-    __ Fmov(out.S(), old_value.W());
-  } else if (value_type == DataType::Type::kInt8) {
-    __ Sxtb(out.W(), old_value.W());
-  } else if (value_type == DataType::Type::kInt16) {
-    __ Sxth(out.W(), old_value.W());
-  } else if (value_type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
-    if (kUseBakerReadBarrier) {
-      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(out.W(), old_value.W());
-    } else {
-      codegen->GenerateReadBarrierSlow(
-          invoke,
-          Location::RegisterLocation(out.GetCode()),
-          Location::RegisterLocation(old_value.GetCode()),
-          Location::RegisterLocation(target.object.GetCode()),
-          /*offset=*/ 0u,
-          /*index=*/ Location::RegisterLocation(target.offset.GetCode()));
+  if (!is_void) {
+    if (get_and_update_op == GetAndUpdateOp::kAddWithByteSwap) {
+      // The only adjustment needed is sign-extension for `kInt16`.
+      // Everything else has been done by the `GenerateGetAndUpdate()`.
+      DCHECK(byte_swap);
+      if (value_type == DataType::Type::kInt16) {
+        DCHECK_EQ(load_store_type, DataType::Type::kUint16);
+        __ Sxth(out_or_temp.W(), old_value.W());
+      }
+    } else if (byte_swap) {
+      // Also handles moving to FP registers.
+      GenerateReverseBytes(masm, value_type, old_value, out_or_temp);
+    } else if (get_and_update_op == GetAndUpdateOp::kSet &&
+               value_type == DataType::Type::kFloat64) {
+      __ Fmov(out_or_temp.D(), old_value.X());
+    } else if (get_and_update_op == GetAndUpdateOp::kSet &&
+               value_type == DataType::Type::kFloat32) {
+      __ Fmov(out_or_temp.S(), old_value.W());
+    } else if (value_type == DataType::Type::kInt8) {
+      __ Sxtb(out_or_temp.W(), old_value.W());
+    } else if (value_type == DataType::Type::kInt16) {
+      __ Sxth(out_or_temp.W(), old_value.W());
+    } else if (value_type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
+      if (kUseBakerReadBarrier) {
+        codegen->GenerateIntrinsicMoveWithBakerReadBarrier(out_or_temp.W(), old_value.W());
+      } else {
+        codegen->GenerateReadBarrierSlow(
+            invoke,
+            Location::RegisterLocation(out_or_temp.GetCode()),
+            Location::RegisterLocation(old_value.GetCode()),
+            Location::RegisterLocation(target.object.GetCode()),
+            /*offset=*/0u,
+            /*index=*/Location::RegisterLocation(target.offset.GetCode()));
+      }
     }
   }
 
@@ -5800,6 +5967,61 @@ void VarHandleSlowPathARM64::EmitByteArrayViewCode(CodeGenerator* codegen_in) {
   __ B(GetExitLabel());
 }
 
+void IntrinsicLocationsBuilderARM64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
+  ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  LocationSummary* locations = new (allocator)
+      LocationSummary(invoke, LocationSummary::kCallOnMainAndSlowPath, kIntrinsified);
+
+  InvokeDexCallingConventionVisitorARM64 calling_convention;
+  locations->SetOut(calling_convention.GetReturnLocation(invoke->GetType()));
+
+  locations->SetInAt(0, Location::RequiresRegister());
+
+  // Accomodating LocationSummary for underlying invoke-* call.
+  uint32_t number_of_args = invoke->GetNumberOfArguments();
+  for (uint32_t i = 1; i < number_of_args; ++i) {
+    locations->SetInAt(i, calling_convention.GetNextLocation(invoke->InputAt(i)->GetType()));
+  }
+
+  // The last input is MethodType object corresponding to the call-site.
+  locations->SetInAt(number_of_args, Location::RequiresRegister());
+
+  locations->AddTemp(Location::RequiresRegister());
+  locations->AddTemp(calling_convention.GetMethodLocation());
+}
+
+void IntrinsicCodeGeneratorARM64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
+  LocationSummary* locations = invoke->GetLocations();
+
+  Register method_handle = InputRegisterAt(invoke, 0);
+
+  SlowPathCodeARM64* slow_path =
+      new (codegen_->GetScopedAllocator()) InvokePolymorphicSlowPathARM64(invoke, method_handle);
+  codegen_->AddSlowPath(slow_path);
+  MacroAssembler* masm = codegen_->GetVIXLAssembler();
+
+  Register call_site_type = InputRegisterAt(invoke, invoke->GetNumberOfArguments());
+
+  // Call site should match with MethodHandle's type.
+  Register temp = WRegisterFrom(locations->GetTemp(0));
+  __ Ldr(temp, HeapOperand(method_handle.W(), mirror::MethodHandle::MethodTypeOffset()));
+  codegen_->GetAssembler()->MaybeUnpoisonHeapReference(temp);
+  __ Cmp(call_site_type, temp);
+  __ B(ne, slow_path->GetEntryLabel());
+
+  __ Ldr(temp, HeapOperand(method_handle.W(), mirror::MethodHandle::HandleKindOffset()));
+  __ Cmp(temp, Operand(mirror::MethodHandle::Kind::kInvokeStatic));
+  __ B(ne, slow_path->GetEntryLabel());
+
+  Register method = XRegisterFrom(locations->GetTemp(1));
+  __ Ldr(method, HeapOperand(method_handle.W(), mirror::MethodHandle::ArtFieldOrMethodOffset()));
+  Offset entry_point = ArtMethod::EntryPointFromQuickCompiledCodeOffset(kArm64PointerSize);
+  __ Ldr(lr, MemOperand(method, entry_point.SizeValue()));
+  __ Blr(lr);
+  codegen_->RecordPcInfo(invoke, invoke->GetDexPc(), slow_path);
+  __ Bind(slow_path->GetExitLabel());
+}
+
 #define MARK_UNIMPLEMENTED(Name) UNIMPLEMENTED_INTRINSIC(ARM64, Name)
 UNIMPLEMENTED_INTRINSIC_LIST_ARM64(MARK_UNIMPLEMENTED);
 #undef MARK_UNIMPLEMENTED
diff --git a/compiler/optimizing/intrinsics_arm_vixl.cc b/compiler/optimizing/intrinsics_arm_vixl.cc
index 1b1711b9de..2360ca6d29 100644
--- a/compiler/optimizing/intrinsics_arm_vixl.cc
+++ b/compiler/optimizing/intrinsics_arm_vixl.cc
@@ -16,6 +16,8 @@
 
 #include "intrinsics_arm_vixl.h"
 
+#include "aarch32/constants-aarch32.h"
+#include "aarch32/operands-aarch32.h"
 #include "arch/arm/callee_save_frame_arm.h"
 #include "arch/arm/instruction_set_features_arm.h"
 #include "art_method.h"
@@ -30,12 +32,11 @@
 #include "mirror/object_array-inl.h"
 #include "mirror/reference.h"
 #include "mirror/string-inl.h"
+#include "optimizing/data_type.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 #include "well_known_classes.h"
 
-#include "aarch32/constants-aarch32.h"
-
 namespace art HIDDEN {
 namespace arm {
 
@@ -2581,7 +2582,12 @@ static void GenerateIntrinsicGet(HInvoke* invoke,
   DCHECK(atomic || order == std::memory_order_relaxed);
 
   ArmVIXLAssembler* assembler = codegen->GetAssembler();
-  MemOperand address(base, offset);
+  MemOperand address(base);
+  if (offset.IsValid()) {
+    // If offset is valid then this is a get from a relative address.
+    address = MemOperand(base, offset);
+  }
+
   switch (type) {
     case DataType::Type::kBool:
       __ Ldrb(RegisterFrom(out), address);
@@ -2598,23 +2604,28 @@ static void GenerateIntrinsicGet(HInvoke* invoke,
     case DataType::Type::kInt32:
       __ Ldr(RegisterFrom(out), address);
       break;
-    case DataType::Type::kInt64:
+    case DataType::Type::kInt64: {
       if (Use64BitExclusiveLoadStore(atomic, codegen)) {
-        vixl32::Register strexd_tmp = RegisterFrom(maybe_temp);
         UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
-        const vixl32::Register temp_reg = temps.Acquire();
-        __ Add(temp_reg, base, offset);
+        if (offset.IsValid()) {
+          vixl32::Register temp_reg = temps.Acquire();
+          __ Add(temp_reg, base, offset);
+          address = MemOperand(temp_reg);
+        }
+
+        vixl32::Register strexd_tmp = RegisterFrom(maybe_temp);
         vixl32::Label loop;
         __ Bind(&loop);
-        __ Ldrexd(LowRegisterFrom(out), HighRegisterFrom(out), MemOperand(temp_reg));
-        __ Strexd(strexd_tmp, LowRegisterFrom(out), HighRegisterFrom(out), MemOperand(temp_reg));
+        __ Ldrexd(LowRegisterFrom(out), HighRegisterFrom(out), address);
+        __ Strexd(strexd_tmp, LowRegisterFrom(out), HighRegisterFrom(out), address);
         __ Cmp(strexd_tmp, 0);
         __ B(ne, &loop);
       } else {
         __ Ldrd(LowRegisterFrom(out), HighRegisterFrom(out), address);
       }
       break;
-    case DataType::Type::kReference:
+    }
+    case DataType::Type::kReference: {
       if (codegen->EmitBakerReadBarrier()) {
         // Piggy-back on the field load path using introspection for the Baker read barrier.
         vixl32::Register temp = RegisterFrom(maybe_temp);
@@ -2625,30 +2636,37 @@ static void GenerateIntrinsicGet(HInvoke* invoke,
         __ Ldr(RegisterFrom(out), address);
       }
       break;
+    }
     case DataType::Type::kFloat32: {
       UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
-      const vixl32::Register temp_reg = temps.Acquire();
-      __ Add(temp_reg, base, offset);
-      __ Vldr(SRegisterFrom(out), MemOperand(temp_reg));
+      if (offset.IsValid()) {
+        const vixl32::Register temp_reg = temps.Acquire();
+        __ Add(temp_reg, base, offset);
+        address = MemOperand(temp_reg);
+      }
+      __ Vldr(SRegisterFrom(out), address);
       break;
     }
     case DataType::Type::kFloat64: {
       UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
-      const vixl32::Register temp_reg = temps.Acquire();
-      __ Add(temp_reg, base, offset);
+      if (offset.IsValid()) {
+        const vixl32::Register temp_reg = temps.Acquire();
+        __ Add(temp_reg, base, offset);
+        address = MemOperand(temp_reg);
+      }
       if (Use64BitExclusiveLoadStore(atomic, codegen)) {
         vixl32::Register lo = RegisterFrom(maybe_temp);
         vixl32::Register hi = RegisterFrom(maybe_temp2);
         vixl32::Register strexd_tmp = RegisterFrom(maybe_temp3);
         vixl32::Label loop;
         __ Bind(&loop);
-        __ Ldrexd(lo, hi, MemOperand(temp_reg));
-        __ Strexd(strexd_tmp, lo, hi, MemOperand(temp_reg));
+        __ Ldrexd(lo, hi, address);
+        __ Strexd(strexd_tmp, lo, hi, address);
         __ Cmp(strexd_tmp, 0);
         __ B(ne, &loop);
         __ Vmov(DRegisterFrom(out), lo, hi);
       } else {
-        __ Vldr(DRegisterFrom(out), MemOperand(temp_reg));
+        __ Vldr(DRegisterFrom(out), address);
       }
       break;
     }
@@ -2696,6 +2714,17 @@ static void CreateUnsafeGetLocations(HInvoke* invoke,
   }
 }
 
+static void CreateUnsafeGetAbsoluteLocations(HInvoke* invoke) {
+  ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke,
+                                      LocationSummary::kNoCall,
+                                      kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+}
+
 static void GenUnsafeGet(HInvoke* invoke,
                          CodeGeneratorARMVIXL* codegen,
                          DataType::Type type,
@@ -2723,14 +2752,47 @@ static void GenUnsafeGet(HInvoke* invoke,
                        /*maybe_temp3=*/ Location::NoLocation());
 }
 
+static void GenUnsafeGetAbsolute(HInvoke* invoke,
+                                 CodeGeneratorARMVIXL* codegen,
+                                 DataType::Type type,
+                                 std::memory_order order,
+                                 bool atomic) {
+  LocationSummary* locations = invoke->GetLocations();
+  vixl32::Register address = LowRegisterFrom(locations->InAt(1));  // Long offset, lo part only.
+  Location out = locations->Out();
+  Location maybe_temp = Location::NoLocation();
+  if (type == DataType::Type::kInt64 && Use64BitExclusiveLoadStore(atomic, codegen)) {
+    maybe_temp = locations->GetTemp(0);
+  }
+  GenerateIntrinsicGet(invoke,
+                       codegen,
+                       type,
+                       order,
+                       atomic,
+                       address,
+                       NoReg,  // No offset.
+                       out,
+                       maybe_temp,
+                       /*maybe_temp2=*/ Location::NoLocation(),
+                       /*maybe_temp3=*/ Location::NoLocation());
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
 
+void IntrinsicLocationsBuilderARMVIXL::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
+
 void IntrinsicCodeGeneratorARMVIXL::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
 
+void IntrinsicCodeGeneratorARMVIXL::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -2783,11 +2845,20 @@ void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateUnsafeGetLocations(invoke, codegen_, DataType::Type::kInt32, /*atomic=*/ false);
 }
 
+void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  CreateUnsafeGetAbsoluteLocations(invoke);
+}
+
 void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafeGet(HInvoke* invoke) {
   GenUnsafeGet(
       invoke, codegen_, DataType::Type::kInt32, std::memory_order_relaxed, /*atomic=*/ false);
 }
 
+void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  GenUnsafeGetAbsolute(
+      invoke, codegen_, DataType::Type::kInt32, std::memory_order_relaxed, /*atomic=*/ false);
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   CreateUnsafeGetLocations(invoke, codegen_, DataType::Type::kInt32, /*atomic=*/ true);
 }
@@ -2869,38 +2940,16 @@ void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafeGetByte(HInvoke* invoke) {
       invoke, codegen_, DataType::Type::kInt8, std::memory_order_relaxed, /*atomic=*/ false);
 }
 
-static void GenerateIntrinsicSet(CodeGeneratorARMVIXL* codegen,
-                                 DataType::Type type,
-                                 std::memory_order order,
-                                 bool atomic,
-                                 vixl32::Register base,
-                                 vixl32::Register offset,
-                                 Location value,
-                                 Location maybe_temp,
-                                 Location maybe_temp2,
-                                 Location maybe_temp3) {
-  bool seq_cst_barrier = (order == std::memory_order_seq_cst);
-  bool release_barrier = seq_cst_barrier || (order == std::memory_order_release);
-  DCHECK(release_barrier || order == std::memory_order_relaxed);
-  DCHECK(atomic || order == std::memory_order_relaxed);
-
-  ArmVIXLAssembler* assembler = codegen->GetAssembler();
-  if (release_barrier) {
-    codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyStore);
-  }
-  UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
-  if (kPoisonHeapReferences && type == DataType::Type::kReference) {
-    vixl32::Register temp = temps.Acquire();
-    __ Mov(temp, RegisterFrom(value));
-    assembler->PoisonHeapReference(temp);
-    value = LocationFrom(temp);
-  }
-  MemOperand address = offset.IsValid() ? MemOperand(base, offset) : MemOperand(base);
-  if (offset.IsValid() && (DataType::Is64BitType(type) || type == DataType::Type::kFloat32)) {
-    const vixl32::Register temp_reg = temps.Acquire();
-    __ Add(temp_reg, base, offset);
-    address = MemOperand(temp_reg);
-  }
+static void GenerateIntrinsicSetStore(CodeGeneratorARMVIXL* codegen,
+                                      ArmVIXLAssembler* assembler,
+                                      DataType::Type type,
+                                      bool atomic,
+                                      vixl32::MemOperand address,
+                                      Location value,
+                                      bool seq_cst_barrier,
+                                      Location maybe_temp,
+                                      Location maybe_temp2,
+                                      Location maybe_temp3) {
   switch (type) {
     case DataType::Type::kBool:
     case DataType::Type::kInt8:
@@ -2951,11 +3000,103 @@ static void GenerateIntrinsicSet(CodeGeneratorARMVIXL* codegen,
       LOG(FATAL) << "Unexpected type " << type;
       UNREACHABLE();
   }
+
   if (seq_cst_barrier) {
     codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyAny);
   }
 }
 
+static void GenerateIntrinsicSet(CodeGeneratorARMVIXL* codegen,
+                                 DataType::Type type,
+                                 std::memory_order order,
+                                 bool atomic,
+                                 vixl32::Register address,
+                                 Location value,
+                                 Location maybe_temp,
+                                 Location maybe_temp2,
+                                 Location maybe_temp3) {
+  bool seq_cst_barrier = order == std::memory_order_seq_cst;
+  bool release_barrier = seq_cst_barrier || order == std::memory_order_release;
+  DCHECK(release_barrier || order == std::memory_order_relaxed);
+  DCHECK(atomic || order == std::memory_order_relaxed);
+
+  ArmVIXLAssembler* assembler = codegen->GetAssembler();
+  if (release_barrier) {
+    codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyStore);
+  }
+  UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
+  GenerateIntrinsicSetStore(codegen,
+                            assembler,
+                            type,
+                            atomic,
+                            MemOperand(address),
+                            value,
+                            seq_cst_barrier,
+                            maybe_temp,
+                            maybe_temp2,
+                            maybe_temp3);
+}
+
+static void GenerateIntrinsicSet(CodeGeneratorARMVIXL* codegen,
+                                 DataType::Type type,
+                                 std::memory_order order,
+                                 bool atomic,
+                                 vixl32::Register base,
+                                 vixl32::Register offset,
+                                 Location value,
+                                 Location maybe_temp,
+                                 Location maybe_temp2,
+                                 Location maybe_temp3) {
+  bool seq_cst_barrier = (order == std::memory_order_seq_cst);
+  bool release_barrier = seq_cst_barrier || (order == std::memory_order_release);
+  DCHECK(release_barrier || order == std::memory_order_relaxed);
+  DCHECK(atomic || order == std::memory_order_relaxed);
+
+  ArmVIXLAssembler* assembler = codegen->GetAssembler();
+  if (release_barrier) {
+    codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyStore);
+  }
+  UseScratchRegisterScope temps(assembler->GetVIXLAssembler());
+  if (kPoisonHeapReferences && type == DataType::Type::kReference) {
+    vixl32::Register temp = temps.Acquire();
+    __ Mov(temp, RegisterFrom(value));
+    assembler->PoisonHeapReference(temp);
+    value = LocationFrom(temp);
+  }
+  MemOperand address = offset.IsValid() ? MemOperand(base, offset) : MemOperand(base);
+  if (offset.IsValid() && (DataType::Is64BitType(type) || type == DataType::Type::kFloat32)) {
+    const vixl32::Register temp_reg = temps.Acquire();
+    __ Add(temp_reg, base, offset);
+    address = MemOperand(temp_reg);
+  }
+  GenerateIntrinsicSetStore(codegen,
+                            assembler,
+                            type,
+                            atomic,
+                            address,
+                            value,
+                            seq_cst_barrier,
+                            maybe_temp,
+                            maybe_temp2,
+                            maybe_temp3);
+}
+
+static void CreateUnsafePutTempLocations(CodeGeneratorARMVIXL* codegen,
+                                         DataType::Type type,
+                                         bool atomic,
+                                         LocationSummary* locations) {
+  if (type == DataType::Type::kInt64) {
+    // Potentially need temps for ldrexd-strexd loop.
+    if (Use64BitExclusiveLoadStore(atomic, codegen)) {
+      locations->AddTemp(Location::RequiresRegister());  // Temp_lo.
+      locations->AddTemp(Location::RequiresRegister());  // Temp_hi.
+    }
+  } else if (type == DataType::Type::kReference) {
+    // Temp for card-marking.
+    locations->AddTemp(Location::RequiresRegister());  // Temp.
+  }
+}
+
 static void CreateUnsafePutLocations(HInvoke* invoke,
                                      CodeGeneratorARMVIXL* codegen,
                                      DataType::Type type,
@@ -2967,17 +3108,20 @@ static void CreateUnsafePutLocations(HInvoke* invoke,
   locations->SetInAt(1, Location::RequiresRegister());
   locations->SetInAt(2, Location::RequiresRegister());
   locations->SetInAt(3, Location::RequiresRegister());
+  CreateUnsafePutTempLocations(codegen, type, atomic, locations);
+}
 
-  if (type == DataType::Type::kInt64) {
-    // Potentially need temps for ldrexd-strexd loop.
-    if (Use64BitExclusiveLoadStore(atomic, codegen)) {
-      locations->AddTemp(Location::RequiresRegister());  // Temp_lo.
-      locations->AddTemp(Location::RequiresRegister());  // Temp_hi.
-    }
-  } else if (type == DataType::Type::kReference) {
-    // Temp for card-marking.
-    locations->AddTemp(Location::RequiresRegister());  // Temp.
-  }
+static void CreateUnsafePutAbsoluteLocations(HInvoke* invoke,
+                                     CodeGeneratorARMVIXL* codegen,
+                                     DataType::Type type,
+                                     bool atomic) {
+  ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetInAt(2, Location::RequiresRegister());
+  CreateUnsafePutTempLocations(codegen, type, atomic, locations);
 }
 
 static void GenUnsafePut(HInvoke* invoke,
@@ -3018,14 +3162,48 @@ static void GenUnsafePut(HInvoke* invoke,
   }
 }
 
+static void GenUnsafePutAbsolute(HInvoke* invoke,
+                                 DataType::Type type,
+                                 std::memory_order order,
+                                 bool atomic,
+                                 CodeGeneratorARMVIXL* codegen) {
+  LocationSummary* locations = invoke->GetLocations();
+  vixl32::Register address = LowRegisterFrom(locations->InAt(1));  // Long offset, lo part only.
+  Location value = locations->InAt(2);
+  Location maybe_temp = Location::NoLocation();
+  Location maybe_temp2 = Location::NoLocation();
+  if (type == DataType::Type::kInt64 && Use64BitExclusiveLoadStore(atomic, codegen)) {
+    maybe_temp = locations->GetTemp(0);
+    maybe_temp2 = locations->GetTemp(1);
+  }
+
+  GenerateIntrinsicSet(codegen,
+                       type,
+                       order,
+                       atomic,
+                       address,
+                       value,
+                       maybe_temp,
+                       maybe_temp2,
+                       /*maybe_temp3=*/ Location::NoLocation());
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
 
+void IntrinsicLocationsBuilderARMVIXL::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
+
 void IntrinsicCodeGeneratorARMVIXL::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
 
+void IntrinsicCodeGeneratorARMVIXL::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -3101,6 +3279,10 @@ void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafePut(HInvoke* invoke) {
   CreateUnsafePutLocations(invoke, codegen_, DataType::Type::kInt32, /*atomic=*/ false);
 }
 
+void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  CreateUnsafePutAbsoluteLocations(invoke, codegen_, DataType::Type::kInt32, /*atomic=*/ false);
+}
+
 void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafePut(HInvoke* invoke) {
   GenUnsafePut(invoke,
                DataType::Type::kInt32,
@@ -3109,6 +3291,14 @@ void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafePut(HInvoke* invoke) {
                codegen_);
 }
 
+void IntrinsicCodeGeneratorARMVIXL::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  GenUnsafePutAbsolute(invoke,
+                       DataType::Type::kInt32,
+                       std::memory_order_relaxed,
+                       /*atomic=*/false,
+                       codegen_);
+}
+
 void IntrinsicLocationsBuilderARMVIXL::VisitJdkUnsafePutByte(HInvoke* invoke) {
   CreateUnsafePutLocations(invoke, codegen_, DataType::Type::kInt8, /*atomic=*/ false);
 }
@@ -3871,9 +4061,15 @@ static void CreateUnsafeGetAndUpdateLocations(HInvoke* invoke,
   locations->SetInAt(2, Location::RequiresRegister());
   locations->SetInAt(3, Location::RequiresRegister());
 
-  locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
-
+  // Request another temporary register for methods that don't return a value.
   size_t num_temps = 1u;  // We always need `tmp_ptr`.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
+  if (is_void) {
+    num_temps++;
+  } else {
+    locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+  }
+
   if (get_and_update_op == GetAndUpdateOp::kAdd) {
     // Add `maybe_temp` used for the new value in `GenerateGetAndUpdate()`.
     num_temps += (type == DataType::Type::kInt64) ? 2u : 1u;
@@ -3894,10 +4090,18 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                                   CodeGeneratorARMVIXL* codegen,
                                   DataType::Type type,
                                   GetAndUpdateOp get_and_update_op) {
+  // Currently only used for these GetAndUpdateOp. Might be fine for other ops but double check
+  // before using.
+  DCHECK(get_and_update_op == GetAndUpdateOp::kAdd || get_and_update_op == GetAndUpdateOp::kSet);
+
   ArmVIXLAssembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
 
-  Location out = locations->Out();                                  // Result.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
+
+  // We use a temporary for void methods, as we don't return the value.
+  Location out_or_temp =
+      is_void ? locations->GetTemp(locations->GetTempCount() - 1u) : locations->Out();
   vixl32::Register base = InputRegisterAt(invoke, 1);               // Object pointer.
   vixl32::Register offset = LowRegisterFrom(locations->InAt(2));    // Offset (discard high 4B).
   Location arg = locations->InAt(3);                                // New value or addend.
@@ -3930,24 +4134,24 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                        type,
                        tmp_ptr,
                        arg,
-                       /*old_value=*/ out,
+                       /*old_value=*/ out_or_temp,
                        /*store_result=*/ temp,
                        maybe_temp,
                        /*maybe_vreg_temp=*/ Location::NoLocation());
   codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyAny);
 
-  if (type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
+  if (!is_void && type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
     DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
     if (kUseBakerReadBarrier) {
-      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(RegisterFrom(out), RegisterFrom(out));
+      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(RegisterFrom(out_or_temp),
+                                                         RegisterFrom(out_or_temp));
     } else {
-      codegen->GenerateReadBarrierSlow(
-          invoke,
-          out,
-          out,
-          Location::RegisterLocation(base.GetCode()),
-          /*offset=*/ 0u,
-          /*index=*/ Location::RegisterLocation(offset.GetCode()));
+      codegen->GenerateReadBarrierSlow(invoke,
+                                       out_or_temp,
+                                       out_or_temp,
+                                       Location::RegisterLocation(base.GetCode()),
+                                       /*offset=*/ 0u,
+                                       /*index=*/ Location::RegisterLocation(offset.GetCode()));
     }
   }
 }
@@ -4656,6 +4860,7 @@ static void CreateVarHandleSetLocations(HInvoke* invoke,
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke, codegen);
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   DataType::Type value_type = GetDataTypeFromShorty(invoke, number_of_arguments - 1u);
   if (DataType::Is64BitType(value_type)) {
@@ -5163,7 +5368,10 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
     return;
   }
 
-  if (invoke->GetType() == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
+  // Get the type from the shorty as the invokes may not return a value.
+  uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
+  if (value_type == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
     // Unsupported for non-Baker read barrier because the artReadBarrierSlow() ignores
     // the passed reference and reloads it from the field, thus seeing the new value
     // that we have just stored. (And it also gets the memory visibility wrong.) b/173104084
@@ -5177,7 +5385,6 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
   DCHECK_EQ(locations->GetTempCount(),
             (GetExpectedVarHandleCoordinatesCount(invoke) == 0) ? 2u : 1u);
 
-  DataType::Type value_type = invoke->GetType();
   if (get_and_update_op == GetAndUpdateOp::kSet) {
     if (DataType::IsFloatingPointType(value_type)) {
       // Add temps needed to do the GenerateGetAndUpdate() with core registers.
@@ -5211,6 +5418,23 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
       locations->AddTemp(Location::RequiresFpuRegister());
     }
   }
+
+  // For the non-void case, we already set `out` in `CreateVarHandleCommonLocations`.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  if (is_void) {
+    if (DataType::IsFloatingPointType(value_type)) {
+      // Note: This shall allocate a D register. There is no way to request an S register.
+      locations->AddTemp(Location::RequiresFpuRegister());
+    } else if (DataType::Is64BitType(value_type)) {
+      // We need two for non-fpu 64 bit types.
+      locations->AddTemp(Location::RequiresRegister());
+      locations->AddTemp(Location::RequiresRegister());
+    } else {
+      locations->AddTemp(Location::RequiresRegister());
+    }
+  }
 }
 
 static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
@@ -5218,13 +5442,38 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
                                           GetAndUpdateOp get_and_update_op,
                                           std::memory_order order,
                                           bool byte_swap = false) {
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
   DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
 
   ArmVIXLAssembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
   Location arg = locations->InAt(arg_index);
-  Location out = locations->Out();
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+
+  size_t temps_that_mimic_out;
+  Location result;
+  const size_t temp_count = locations->GetTempCount();
+  if (is_void) {
+    if (value_type == DataType::Type::kFloat32) {
+      // Note: Since we allocated a D register, use the low part.
+      DCHECK(locations->GetTemp(temp_count - 1u).IsFpuRegisterPair());
+      temps_that_mimic_out = 1u;
+      result = locations->GetTemp(temp_count - 1u).ToLow();
+    } else if (!DataType::IsFloatingPointType(value_type) && DataType::Is64BitType(value_type)) {
+      temps_that_mimic_out = 2u;
+      result = LocationFrom(RegisterFrom(locations->GetTemp(temp_count - 2u)),
+                            RegisterFrom(locations->GetTemp(temp_count - 1u)));
+    } else {
+      temps_that_mimic_out = 1u;
+      result = locations->GetTemp(temp_count - 1u);
+    }
+  } else {
+    temps_that_mimic_out = 0u;
+    result = locations->Out();
+  }
 
   VarHandleTarget target = GetVarHandleTarget(invoke);
   VarHandleSlowPathARMVIXL* slow_path = nullptr;
@@ -5261,7 +5510,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
       : value_type;
 
   // Prepare register for old value and temporaries if any.
-  Location old_value = out;
+  Location old_value = result;
   Location maybe_temp = Location::NoLocation();
   Location maybe_vreg_temp = Location::NoLocation();
   if (get_and_update_op == GetAndUpdateOp::kSet) {
@@ -5269,7 +5518,9 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
     // rather than moving between core and FP registers in the loop.
     if (value_type == DataType::Type::kFloat64) {
       vixl32::DRegister arg_vreg = DRegisterFrom(arg);
-      DCHECK_EQ(locations->GetTempCount(), 5u);  // `store_result` and the four here.
+      // `store_result` and the four here, plus maybe an extra one for the temp that mimics the
+      // "out" register.
+      DCHECK_EQ(temp_count, 5u + temps_that_mimic_out);
       old_value =
           LocationFrom(RegisterFrom(locations->GetTemp(1)), RegisterFrom(locations->GetTemp(2)));
       arg = LocationFrom(RegisterFrom(locations->GetTemp(3)), RegisterFrom(locations->GetTemp(4)));
@@ -5281,7 +5532,9 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
       }
     } else if (value_type == DataType::Type::kFloat32) {
       vixl32::SRegister arg_vreg = SRegisterFrom(arg);
-      DCHECK_EQ(locations->GetTempCount(), 3u);  // `store_result` and the two here.
+      // `store_result` and the two here, plus maybe an extra one for the temp that mimics the
+      // "out" register.
+      DCHECK_EQ(temp_count, 3u + temps_that_mimic_out);
       old_value = locations->GetTemp(1);
       arg = locations->GetTemp(2);
       __ Vmov(RegisterFrom(arg), arg_vreg);
@@ -5293,7 +5546,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
         // Load the old value initially to a temporary register.
         // We shall move it to `out` later with a read barrier.
         old_value = LocationFrom(store_result);
-        store_result = RegisterFrom(out);  // Use the `out` for the exclusive store result.
+        store_result = RegisterFrom(result);  // Use `result` for the exclusive store result.
       } else {
         // The store_result is a separate temporary.
         DCHECK(!store_result.Is(target.object));
@@ -5305,7 +5558,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
       if (value_type == DataType::Type::kInt64) {
         arg = LocationFrom(RegisterFrom(arg), RegisterFrom(locations->GetTemp(2)));
         // Swap the high/low regs and reverse the bytes in each after the load.
-        old_value = LocationFrom(HighRegisterFrom(out), LowRegisterFrom(out));
+        old_value = LocationFrom(HighRegisterFrom(result), LowRegisterFrom(result));
       }
       GenerateReverseBytes(assembler, value_type, original_arg, arg);
     }
@@ -5315,7 +5568,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
         : locations->GetTemp(1);
     DCHECK(!maybe_temp.Contains(LocationFrom(store_result)));
     if (DataType::IsFloatingPointType(value_type)) {
-      maybe_vreg_temp = locations->GetTemp(locations->GetTempCount() - 1u);
+      maybe_vreg_temp = locations->GetTemp(temp_count - 1u - temps_that_mimic_out);
       DCHECK(maybe_vreg_temp.IsFpuRegisterPair());
     }
     if (byte_swap) {
@@ -5324,7 +5577,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
         get_and_update_op = GetAndUpdateOp::kAddWithByteSwap;
       } else if (value_type == DataType::Type::kInt64) {
         // Swap the high/low regs and reverse the bytes in each after the load.
-        old_value = LocationFrom(HighRegisterFrom(out), LowRegisterFrom(out));
+        old_value = LocationFrom(HighRegisterFrom(result), LowRegisterFrom(result));
         // Due to lack of registers, reverse bytes in `arg` and undo that later.
         GenerateReverseBytesInPlaceForEachWord(assembler, arg);
         arg = LocationFrom(HighRegisterFrom(arg), LowRegisterFrom(arg));
@@ -5353,36 +5606,38 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
         seq_cst_barrier ? MemBarrierKind::kAnyAny : MemBarrierKind::kLoadAny);
   }
 
-  if (byte_swap && get_and_update_op != GetAndUpdateOp::kAddWithByteSwap) {
-    if (value_type == DataType::Type::kInt64) {
-      GenerateReverseBytesInPlaceForEachWord(assembler, old_value);
-      if (get_and_update_op != GetAndUpdateOp::kSet) {
-        // Undo byte swapping in `arg`. We do not have the information
-        // whether the value in these registers shall be needed later.
-        GenerateReverseBytesInPlaceForEachWord(assembler, arg);
+  if (!is_void) {
+    if (byte_swap && get_and_update_op != GetAndUpdateOp::kAddWithByteSwap) {
+      if (value_type == DataType::Type::kInt64) {
+        GenerateReverseBytesInPlaceForEachWord(assembler, old_value);
+        if (get_and_update_op != GetAndUpdateOp::kSet) {
+          // Undo byte swapping in `arg`. We do not have the information
+          // whether the value in these registers shall be needed later.
+          GenerateReverseBytesInPlaceForEachWord(assembler, arg);
+        }
+      } else {
+        GenerateReverseBytes(assembler, value_type, old_value, result);
+      }
+    } else if (get_and_update_op == GetAndUpdateOp::kSet &&
+               DataType::IsFloatingPointType(value_type)) {
+      if (value_type == DataType::Type::kFloat64) {
+        __ Vmov(DRegisterFrom(result), LowRegisterFrom(old_value), HighRegisterFrom(old_value));
+      } else {
+        __ Vmov(SRegisterFrom(result), RegisterFrom(old_value));
+      }
+    } else if (value_type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
+      if (kUseBakerReadBarrier) {
+        codegen->GenerateIntrinsicMoveWithBakerReadBarrier(RegisterFrom(result),
+                                                           RegisterFrom(old_value));
+      } else {
+        codegen->GenerateReadBarrierSlow(
+            invoke,
+            Location::RegisterLocation(RegisterFrom(result).GetCode()),
+            Location::RegisterLocation(RegisterFrom(old_value).GetCode()),
+            Location::RegisterLocation(target.object.GetCode()),
+            /*offset=*/ 0u,
+            /*index=*/ Location::RegisterLocation(target.offset.GetCode()));
       }
-    } else {
-      GenerateReverseBytes(assembler, value_type, old_value, out);
-    }
-  } else if (get_and_update_op == GetAndUpdateOp::kSet &&
-             DataType::IsFloatingPointType(value_type)) {
-    if (value_type == DataType::Type::kFloat64) {
-      __ Vmov(DRegisterFrom(out), LowRegisterFrom(old_value), HighRegisterFrom(old_value));
-    } else {
-      __ Vmov(SRegisterFrom(out), RegisterFrom(old_value));
-    }
-  } else if (value_type == DataType::Type::kReference && codegen->EmitReadBarrier()) {
-    if (kUseBakerReadBarrier) {
-      codegen->GenerateIntrinsicMoveWithBakerReadBarrier(RegisterFrom(out),
-                                                         RegisterFrom(old_value));
-    } else {
-      codegen->GenerateReadBarrierSlow(
-          invoke,
-          Location::RegisterLocation(RegisterFrom(out).GetCode()),
-          Location::RegisterLocation(RegisterFrom(old_value).GetCode()),
-          Location::RegisterLocation(target.object.GetCode()),
-          /*offset=*/ 0u,
-          /*index=*/ Location::RegisterLocation(target.offset.GetCode()));
     }
   }
 
diff --git a/compiler/optimizing/intrinsics_riscv64.cc b/compiler/optimizing/intrinsics_riscv64.cc
index 2bc8cad71a..d2a0e97527 100644
--- a/compiler/optimizing/intrinsics_riscv64.cc
+++ b/compiler/optimizing/intrinsics_riscv64.cc
@@ -19,6 +19,7 @@
 #include "code_generator_riscv64.h"
 #include "intrinsic_objects.h"
 #include "intrinsics_utils.h"
+#include "optimizing/locations.h"
 #include "well_known_classes.h"
 
 namespace art HIDDEN {
@@ -160,11 +161,13 @@ static void CreateFpFpFpToFpNoOverlapLocations(ArenaAllocator* allocator, HInvok
   locations->SetOut(Location::RequiresFpuRegister(), Location::kNoOutputOverlap);
 }
 
-static void CreateFPToFPLocations(ArenaAllocator* allocator, HInvoke* invoke) {
+static void CreateFPToFPLocations(ArenaAllocator* allocator,
+                                  HInvoke* invoke,
+                                  Location::OutputOverlap overlaps = Location::kOutputOverlap) {
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
   locations->SetInAt(0, Location::RequiresFpuRegister());
-  locations->SetOut(Location::RequiresFpuRegister());
+  locations->SetOut(Location::RequiresFpuRegister(), overlaps);
 }
 
 void IntrinsicLocationsBuilderRISCV64::VisitDoubleDoubleToRawLongBits(HInvoke* invoke) {
@@ -1436,7 +1439,6 @@ class ReadBarrierCasSlowPathRISCV64 : public SlowPathCodeRISCV64 {
       DCHECK(update_old_value_slow_path_ != nullptr);
       __ Bind(&mark_old_value);
       if (kUseBakerReadBarrier) {
-        DCHECK(update_old_value_slow_path_ == nullptr);
         __ Mv(old_value_, old_value_temp_);
         riscv64_codegen->EmitBakerReadBarierMarkingCheck(update_old_value_slow_path_,
                                                          Location::RegisterLocation(old_value_),
@@ -2331,6 +2333,15 @@ static void CreateUnsafeGetLocations(ArenaAllocator* allocator,
                     (can_call ? Location::kOutputOverlap : Location::kNoOutputOverlap));
 }
 
+static void CreateUnsafeGetAbsoluteLocations(ArenaAllocator* allocator,
+                                             HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+}
+
 static void GenUnsafeGet(HInvoke* invoke,
                          CodeGeneratorRISCV64* codegen,
                          std::memory_order order,
@@ -2383,14 +2394,49 @@ static void GenUnsafeGet(HInvoke* invoke,
   }
 }
 
+static void GenUnsafeGetAbsolute(HInvoke* invoke,
+                                 CodeGeneratorRISCV64* codegen,
+                                 std::memory_order order,
+                                 DataType::Type type) {
+  DCHECK((type == DataType::Type::kInt8) ||
+         (type == DataType::Type::kInt32) ||
+         (type == DataType::Type::kInt64));
+  LocationSummary* locations = invoke->GetLocations();
+  Location address_loc = locations->InAt(1);
+  XRegister address = address_loc.AsRegister<XRegister>();
+  Location out_loc = locations->Out();
+
+  bool seq_cst_barrier = order == std::memory_order_seq_cst;
+  bool acquire_barrier = seq_cst_barrier || order == std::memory_order_acquire;
+  DCHECK(acquire_barrier || order == std::memory_order_relaxed);
+
+  if (seq_cst_barrier) {
+    codegen->GenerateMemoryBarrier(MemBarrierKind::kAnyAny);
+  }
+
+  codegen->GetInstructionVisitor()->Load(out_loc, address, /*offset=*/ 0, type);
+
+  if (acquire_barrier) {
+    codegen->GenerateMemoryBarrier(MemBarrierKind::kLoadAny);
+  }
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
 
+void IntrinsicLocationsBuilderRISCV64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
+
 void IntrinsicCodeGeneratorRISCV64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
 
+void IntrinsicCodeGeneratorRISCV64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -2443,10 +2489,18 @@ void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
 
+void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  CreateUnsafeGetAbsoluteLocations(allocator_, invoke);
+}
+
 void IntrinsicCodeGeneratorRISCV64::VisitJdkUnsafeGet(HInvoke* invoke) {
   GenUnsafeGet(invoke, codegen_, std::memory_order_relaxed, DataType::Type::kInt32);
 }
 
+void IntrinsicCodeGeneratorRISCV64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  GenUnsafeGetAbsolute(invoke, codegen_, std::memory_order_relaxed, DataType::Type::kInt32);
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafeGetAcquire(HInvoke* invoke) {
   CreateUnsafeGetLocations(allocator_, invoke, codegen_);
 }
@@ -2531,6 +2585,14 @@ static void CreateUnsafePutLocations(ArenaAllocator* allocator, HInvoke* invoke)
   }
 }
 
+static void CreateUnsafePutAbsoluteLocations(ArenaAllocator* allocator, HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetInAt(2, Location::RequiresRegister());
+}
+
 static void GenUnsafePut(HInvoke* invoke,
                          CodeGeneratorRISCV64* codegen,
                          std::memory_order order,
@@ -2559,14 +2621,33 @@ static void GenUnsafePut(HInvoke* invoke,
   }
 }
 
+static void GenUnsafePutAbsolute(HInvoke* invoke,
+                                 CodeGeneratorRISCV64* codegen,
+                                 std::memory_order order,
+                                 DataType::Type type) {
+  LocationSummary* locations = invoke->GetLocations();
+  XRegister address = locations->InAt(1).AsRegister<XRegister>();
+  Location value = locations->InAt(2);
+
+  GenerateSet(codegen, order, value, address, /*offset=*/ 0, type);
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
 
+void IntrinsicLocationsBuilderRISCV64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
+
 void IntrinsicCodeGeneratorRISCV64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
 
+void IntrinsicCodeGeneratorRISCV64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -2643,10 +2724,18 @@ void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafePut(HInvoke* invoke) {
   CreateUnsafePutLocations(allocator_, invoke);
 }
 
+void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  CreateUnsafePutAbsoluteLocations(allocator_, invoke);
+}
+
 void IntrinsicCodeGeneratorRISCV64::VisitJdkUnsafePut(HInvoke* invoke) {
   GenUnsafePut(invoke, codegen_, std::memory_order_relaxed, DataType::Type::kInt32);
 }
 
+void IntrinsicCodeGeneratorRISCV64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  GenUnsafePutAbsolute(invoke, codegen_, std::memory_order_relaxed, DataType::Type::kInt32);
+}
+
 void IntrinsicLocationsBuilderRISCV64::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   CreateUnsafePutLocations(allocator_, invoke);
 }
@@ -2955,20 +3044,35 @@ static void CreateUnsafeGetAndUpdateLocations(ArenaAllocator* allocator,
   locations->SetInAt(2, Location::RequiresRegister());
   locations->SetInAt(3, Location::RequiresRegister());
 
-  locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+  // Request another temporary register for methods that don't return a value.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  if (is_void) {
+    locations->AddTemp(Location::RequiresRegister());
+  } else {
+    locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+  }
 }
 
 static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                                   DataType::Type type,
                                   CodeGeneratorRISCV64* codegen,
                                   GetAndUpdateOp get_and_update_op) {
+  // Currently only used for these GetAndUpdateOp. Might be fine for other ops but double check
+  // before using.
+  DCHECK(get_and_update_op == GetAndUpdateOp::kAdd || get_and_update_op == GetAndUpdateOp::kSet);
+
   Riscv64Assembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
-  Location out_loc = locations->Out();
-  XRegister out = out_loc.AsRegister<XRegister>();                    // Result.
-  XRegister base = locations->InAt(1).AsRegister<XRegister>();        // Object pointer.
-  XRegister offset = locations->InAt(2).AsRegister<XRegister>();      // Long offset.
-  XRegister arg = locations->InAt(3).AsRegister<XRegister>();         // New value or addend.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  // We use a temporary for void methods, as we don't return the value.
+  Location out_or_temp_loc =
+      is_void ? locations->GetTemp(locations->GetTempCount() - 1u) : locations->Out();
+  XRegister out_or_temp = out_or_temp_loc.AsRegister<XRegister>();  // Result.
+  XRegister base = locations->InAt(1).AsRegister<XRegister>();      // Object pointer.
+  XRegister offset = locations->InAt(2).AsRegister<XRegister>();    // Long offset.
+  XRegister arg = locations->InAt(3).AsRegister<XRegister>();       // New value or addend.
 
   // This needs to be before the temp registers, as MarkGCCard also uses scratch registers.
   if (type == DataType::Type::kReference) {
@@ -2987,28 +3091,28 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
                        std::memory_order_seq_cst,
                        tmp_ptr,
                        arg,
-                       /*old_value=*/ out,
+                       /*old_value=*/ out_or_temp,
                        /*mask=*/ kNoXRegister,
                        /*temp=*/ kNoXRegister);
 
-  if (type == DataType::Type::kReference) {
-    __ ZextW(out, out);
+  if (!is_void && type == DataType::Type::kReference) {
+    __ ZextW(out_or_temp, out_or_temp);
     if (codegen->EmitReadBarrier()) {
       DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
       if (kUseBakerReadBarrier) {
         // Use RA as temp. It is clobbered in the slow path anyway.
         static constexpr Location kBakerReadBarrierTemp = Location::RegisterLocation(RA);
-        SlowPathCodeRISCV64* rb_slow_path =
-            codegen->AddGcRootBakerBarrierBarrierSlowPath(invoke, out_loc, kBakerReadBarrierTemp);
-        codegen->EmitBakerReadBarierMarkingCheck(rb_slow_path, out_loc, kBakerReadBarrierTemp);
+        SlowPathCodeRISCV64* rb_slow_path = codegen->AddGcRootBakerBarrierBarrierSlowPath(
+            invoke, out_or_temp_loc, kBakerReadBarrierTemp);
+        codegen->EmitBakerReadBarierMarkingCheck(
+            rb_slow_path, out_or_temp_loc, kBakerReadBarrierTemp);
       } else {
-        codegen->GenerateReadBarrierSlow(
-            invoke,
-            out_loc,
-            out_loc,
-            Location::RegisterLocation(base),
-            /*offset=*/ 0u,
-            /*index=*/ Location::RegisterLocation(offset));
+        codegen->GenerateReadBarrierSlow(invoke,
+                                         out_or_temp_loc,
+                                         out_or_temp_loc,
+                                         Location::RegisterLocation(base),
+                                         /*offset=*/ 0u,
+                                         /*index=*/ Location::RegisterLocation(offset));
       }
     }
   }
@@ -4450,7 +4554,11 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
     return;
   }
 
-  if (invoke->GetType() == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
+  // Get the type from the shorty as the invokes may not return a value.
+  uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
+  DCHECK_EQ(arg_index, 1u + GetExpectedVarHandleCoordinatesCount(invoke));
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
+  if (value_type == DataType::Type::kReference && codegen->EmitNonBakerReadBarrier()) {
     // Unsupported for non-Baker read barrier because the artReadBarrierSlow() ignores
     // the passed reference and reloads it from the field, thus seeing the new value
     // that we have just stored. (And it also gets the memory visibility wrong.) b/173104084
@@ -4458,15 +4566,11 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
   }
 
   // TODO(riscv64): Fix this intrinsic for heap poisoning configuration.
-  if (kPoisonHeapReferences && invoke->GetType() == DataType::Type::kReference) {
+  if (kPoisonHeapReferences && value_type == DataType::Type::kReference) {
     return;
   }
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke, codegen);
-  uint32_t arg_index = invoke->GetNumberOfArguments() - 1u;
-  DCHECK_EQ(arg_index, 1u + GetExpectedVarHandleCoordinatesCount(invoke));
-  DataType::Type value_type = invoke->GetType();
-  DCHECK_EQ(value_type, GetDataTypeFromShorty(invoke, arg_index));
   Location arg = locations->InAt(arg_index);
 
   bool is_fp = DataType::IsFloatingPointType(value_type);
@@ -4517,6 +4621,19 @@ static void CreateVarHandleGetAndUpdateLocations(HInvoke* invoke,
   if (temps_needed > old_temp_count + scratch_registers_available) {
     locations->AddRegisterTemps(temps_needed - (old_temp_count + scratch_registers_available));
   }
+
+  // Request another temporary register for methods that don't return a value.
+  // For the non-void case, we already set `out` in `CreateVarHandleCommonLocations`.
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  if (is_void) {
+    if (DataType::IsFloatingPointType(value_type)) {
+      locations->AddTemp(Location::RequiresFpuRegister());
+    } else {
+      locations->AddTemp(Location::RequiresRegister());
+    }
+  }
 }
 
 static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
@@ -4524,16 +4641,21 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
                                           GetAndUpdateOp get_and_update_op,
                                           std::memory_order order,
                                           bool byte_swap = false) {
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t arg_index = invoke->GetNumberOfArguments() - 1;
   DCHECK_EQ(arg_index, 1u + GetExpectedVarHandleCoordinatesCount(invoke));
-  DataType::Type value_type = invoke->GetType();
-  DCHECK_EQ(value_type, GetDataTypeFromShorty(invoke, arg_index));
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, arg_index);
 
   Riscv64Assembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
   Location arg = locations->InAt(arg_index);
   DCHECK_IMPLIES(arg.IsConstant(), arg.GetConstant()->IsZeroBitPattern());
-  Location out = locations->Out();
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  // We use a temporary for void methods, as we don't return the value.
+  Location out_or_temp =
+      is_void ? locations->GetTemp(locations->GetTempCount() - 1u) : locations->Out();
 
   VarHandleTarget target = GetVarHandleTarget(invoke);
   VarHandleSlowPathRISCV64* slow_path = nullptr;
@@ -4589,6 +4711,8 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
       available_scratch_registers -= 1u;
       return srs.AllocateXRegister();
     } else {
+      DCHECK_IMPLIES(is_void, next_temp != locations->GetTempCount() - 1u)
+          << "The last temp is special for the void case, as it represents the out register.";
       XRegister temp = locations->GetTemp(next_temp).AsRegister<XRegister>();
       next_temp += 1u;
       return temp;
@@ -4678,24 +4802,24 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
     codegen->GetInstructionVisitor()->Load(
         Location::RegisterLocation(old_value), tmp_ptr, /*offset=*/ 0, op_type);
     if (byte_swap) {
-      GenerateByteSwapAndExtract(codegen, out, old_value, shift, value_type);
+      GenerateByteSwapAndExtract(codegen, out_or_temp, old_value, shift, value_type);
     } else {
       DCHECK(is_fp);
-      codegen->MoveLocation(out, Location::RegisterLocation(old_value), value_type);
+      codegen->MoveLocation(out_or_temp, Location::RegisterLocation(old_value), value_type);
     }
     if (is_fp) {
       codegen->GetInstructionVisitor()->FAdd(
-          ftmp, out.AsFpuRegister<FRegister>(), arg.AsFpuRegister<FRegister>(), value_type);
+          ftmp, out_or_temp.AsFpuRegister<FRegister>(), arg.AsFpuRegister<FRegister>(), value_type);
       codegen->MoveLocation(
           Location::RegisterLocation(new_value), Location::FpuRegisterLocation(ftmp), op_type);
     } else if (arg.IsConstant()) {
       DCHECK(arg.GetConstant()->IsZeroBitPattern());
-      __ Mv(new_value, out.AsRegister<XRegister>());
+      __ Mv(new_value, out_or_temp.AsRegister<XRegister>());
     } else if (value_type == DataType::Type::kInt64) {
-      __ Add(new_value, out.AsRegister<XRegister>(), arg.AsRegister<XRegister>());
+      __ Add(new_value, out_or_temp.AsRegister<XRegister>(), arg.AsRegister<XRegister>());
     } else {
       DCHECK_EQ(op_type, DataType::Type::kInt32);
-      __ Addw(new_value, out.AsRegister<XRegister>(), arg.AsRegister<XRegister>());
+      __ Addw(new_value, out_or_temp.AsRegister<XRegister>(), arg.AsRegister<XRegister>());
     }
     if (byte_swap) {
       DataType::Type swap_type = op_type;
@@ -4706,7 +4830,7 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
         // To update the 16 bits, we can XOR the new value with the `out`, byte swap as Uint16
         // (extracting only the bits we want to update), shift and XOR with the old value.
         swap_type = DataType::Type::kUint16;
-        __ Xor(new_value, new_value, out.AsRegister<XRegister>());
+        __ Xor(new_value, new_value, out_or_temp.AsRegister<XRegister>());
       }
       GenerateReverseBytes(codegen, Location::RegisterLocation(new_value), new_value, swap_type);
       if (is_small) {
@@ -4727,15 +4851,15 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
                           store_result,
                           /*expected=*/ old_value);
   } else {
-    XRegister old_value = is_fp ? get_temp() : out.AsRegister<XRegister>();
+    XRegister old_value = is_fp ? get_temp() : out_or_temp.AsRegister<XRegister>();
     GenerateGetAndUpdate(
         codegen, get_and_update_op, op_type, order, tmp_ptr, arg_reg, old_value, mask, temp);
     if (byte_swap) {
-      DCHECK_IMPLIES(is_small, out.AsRegister<XRegister>() == old_value)
-          << " " << value_type << " " << out.AsRegister<XRegister>() << "!=" << old_value;
-      GenerateByteSwapAndExtract(codegen, out, old_value, shift, value_type);
+      DCHECK_IMPLIES(is_small, out_or_temp.AsRegister<XRegister>() == old_value)
+          << " " << value_type << " " << out_or_temp.AsRegister<XRegister>() << "!=" << old_value;
+      GenerateByteSwapAndExtract(codegen, out_or_temp, old_value, shift, value_type);
     } else if (is_fp) {
-      codegen->MoveLocation(out, Location::RegisterLocation(old_value), value_type);
+      codegen->MoveLocation(out_or_temp, Location::RegisterLocation(old_value), value_type);
     } else if (is_small) {
       __ Srlw(old_value, old_value, shift);
       DCHECK_NE(value_type, DataType::Type::kUint8);
@@ -4754,14 +4878,14 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
       if (codegen->EmitBakerReadBarrier()) {
         // Use RA as temp. It is clobbered in the slow path anyway.
         static constexpr Location kBakerReadBarrierTemp = Location::RegisterLocation(RA);
-        SlowPathCodeRISCV64* rb_slow_path =
-            codegen->AddGcRootBakerBarrierBarrierSlowPath(invoke, out, kBakerReadBarrierTemp);
-        codegen->EmitBakerReadBarierMarkingCheck(rb_slow_path, out, kBakerReadBarrierTemp);
+        SlowPathCodeRISCV64* rb_slow_path = codegen->AddGcRootBakerBarrierBarrierSlowPath(
+            invoke, out_or_temp, kBakerReadBarrierTemp);
+        codegen->EmitBakerReadBarierMarkingCheck(rb_slow_path, out_or_temp, kBakerReadBarrierTemp);
       } else if (codegen->EmitNonBakerReadBarrier()) {
         Location base_loc = Location::RegisterLocation(target.object);
         Location index = Location::RegisterLocation(target.offset);
         SlowPathCodeRISCV64* rb_slow_path = codegen->AddReadBarrierSlowPath(
-            invoke, out, out, base_loc, /*offset=*/ 0u, index);
+            invoke, out_or_temp, out_or_temp, base_loc, /*offset=*/ 0u, index);
         __ J(rb_slow_path->GetEntryLabel());
         __ Bind(rb_slow_path->GetExitLabel());
       }
@@ -4775,13 +4899,16 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
 
   // Check that we have allocated the right number of temps. We may need more registers
   // for byte swapped CAS in the slow path, so skip this check for the main path in that case.
+  // In the void case, we requested an extra register to mimic the `out` register.
+  const size_t extra_temp_registers = is_void ? 1u : 0u;
   bool has_byte_swap = (arg_index == 3u) && (!is_reference && data_size != 1u);
-  if ((!has_byte_swap || byte_swap) && next_temp != locations->GetTempCount()) {
+  if ((!has_byte_swap || byte_swap) &&
+      next_temp != locations->GetTempCount() - extra_temp_registers) {
     // We allocate a temporary register for the class object for a static field `VarHandle` but
     // we do not update the `next_temp` if it's otherwise unused after the address calculation.
     CHECK_EQ(arg_index, 1u);
     CHECK_EQ(next_temp, 1u);
-    CHECK_EQ(locations->GetTempCount(), 2u);
+    CHECK_EQ(locations->GetTempCount(), 2u + extra_temp_registers);
   }
 }
 
@@ -5204,7 +5331,7 @@ void IntrinsicCodeGeneratorRISCV64::VisitMathTanh(HInvoke* invoke) {
 }
 
 void IntrinsicLocationsBuilderRISCV64::VisitMathSqrt(HInvoke* invoke) {
-  CreateFPToFPLocations(allocator_, invoke);
+  CreateFPToFPLocations(allocator_, invoke, Location::kNoOutputOverlap);
 }
 
 void IntrinsicCodeGeneratorRISCV64::VisitMathSqrt(HInvoke* invoke) {
@@ -5327,7 +5454,7 @@ void IntrinsicLocationsBuilderRISCV64::VisitMathMultiplyHigh(HInvoke* invoke) {
       new (allocator_) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
   locations->SetInAt(0, Location::RequiresRegister());
   locations->SetInAt(1, Location::RequiresRegister());
-  locations->SetOut(Location::RequiresRegister());
+  locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
 }
 
 void IntrinsicCodeGeneratorRISCV64::VisitMathMultiplyHigh(HInvoke* invoke) {
diff --git a/compiler/optimizing/intrinsics_utils.h b/compiler/optimizing/intrinsics_utils.h
index 13d9bc4b68..6c08cea3f8 100644
--- a/compiler/optimizing/intrinsics_utils.h
+++ b/compiler/optimizing/intrinsics_utils.h
@@ -111,7 +111,7 @@ static inline size_t GetExpectedVarHandleCoordinatesCount(HInvoke *invoke) {
 }
 
 static inline DataType::Type GetDataTypeFromShorty(HInvoke* invoke, uint32_t index) {
-  DCHECK(invoke->IsInvokePolymorphic());
+  DCHECK(invoke->IsInvokePolymorphic()) << *invoke;
   const DexFile* dex_file = invoke->GetMethodReference().dex_file;
   const char* shorty = dex_file->GetShorty(invoke->AsInvokePolymorphic()->GetProtoIndex());
   DCHECK_LT(index, strlen(shorty));
diff --git a/compiler/optimizing/intrinsics_x86.cc b/compiler/optimizing/intrinsics_x86.cc
index 2b83ba8349..952fb855be 100644
--- a/compiler/optimizing/intrinsics_x86.cc
+++ b/compiler/optimizing/intrinsics_x86.cc
@@ -34,6 +34,7 @@
 #include "mirror/reference.h"
 #include "mirror/string.h"
 #include "mirror/var_handle.h"
+#include "optimizing/data_type.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 #include "utils/x86/assembler_x86.h"
@@ -309,7 +310,7 @@ static void CreateFPToFPLocations(ArenaAllocator* allocator, HInvoke* invoke) {
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
   locations->SetInAt(0, Location::RequiresFpuRegister());
-  locations->SetOut(Location::RequiresFpuRegister());
+  locations->SetOut(Location::RequiresFpuRegister(), Location::kNoOutputOverlap);
 }
 
 void IntrinsicLocationsBuilderX86::VisitMathSqrt(HInvoke* invoke) {
@@ -1730,6 +1731,74 @@ static void GenUnsafeGet(HInvoke* invoke,
   }
 }
 
+static void GenUnsafeGetAbsolute(HInvoke* invoke,
+                                 DataType::Type type,
+                                 bool is_volatile,
+                                 CodeGeneratorX86* codegen) {
+  X86Assembler* assembler = down_cast<X86Assembler*>(codegen->GetAssembler());
+  LocationSummary* locations = invoke->GetLocations();
+  Register address = locations->InAt(1).AsRegisterPairLow<Register>();
+  Address address_offset(address, 0);
+  Location output_loc = locations->Out();
+
+  switch (type) {
+    case DataType::Type::kInt8: {
+      Register output = output_loc.AsRegister<Register>();
+      __ movsxb(output, address_offset);
+      break;
+    }
+
+    case DataType::Type::kInt32: {
+      Register output = output_loc.AsRegister<Register>();
+      __ movl(output, address_offset);
+      break;
+    }
+
+    case DataType::Type::kInt64: {
+        Register output_lo = output_loc.AsRegisterPairLow<Register>();
+        Register output_hi = output_loc.AsRegisterPairHigh<Register>();
+        if (is_volatile) {
+          // Need to use a XMM to read atomically.
+          XmmRegister temp = locations->GetTemp(0).AsFpuRegister<XmmRegister>();
+          __ movsd(temp, address_offset);
+          __ movd(output_lo, temp);
+          __ psrlq(temp, Immediate(32));
+          __ movd(output_hi, temp);
+        } else {
+          Address address_hi(address, 4);
+          __ movl(output_lo, address_offset);
+          __ movl(output_hi, address_hi);
+        }
+      }
+      break;
+
+    default:
+      LOG(FATAL) << "Unsupported op size " << type;
+      UNREACHABLE();
+  }
+}
+
+static void CreateIntIntToIntLocations(ArenaAllocator* allocator,
+                                       HInvoke* invoke,
+                                       DataType::Type type,
+                                       bool is_volatile) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  if (type == DataType::Type::kInt64) {
+    if (is_volatile) {
+      // Need to use XMM to read volatile.
+      locations->AddTemp(Location::RequiresFpuRegister());
+      locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+    } else {
+      locations->SetOut(Location::RequiresRegister(), Location::kOutputOverlap);
+    }
+  } else {
+    locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+  }
+}
+
 static void CreateIntIntIntToIntLocations(ArenaAllocator* allocator,
                                           HInvoke* invoke,
                                           CodeGeneratorX86* codegen,
@@ -1765,6 +1834,9 @@ static void CreateIntIntIntToIntLocations(ArenaAllocator* allocator,
 void IntrinsicLocationsBuilderX86::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicLocationsBuilderX86::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderX86::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -1787,6 +1859,9 @@ void IntrinsicLocationsBuilderX86::VisitUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicCodeGeneratorX86::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorX86::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -1810,6 +1885,9 @@ void IntrinsicLocationsBuilderX86::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateIntIntIntToIntLocations(
       allocator_, invoke, codegen_, DataType::Type::kInt32, /*is_volatile=*/ false);
 }
+void IntrinsicLocationsBuilderX86::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  CreateIntIntToIntLocations(allocator_, invoke, DataType::Type::kInt32, /*is_volatile=*/false);
+}
 void IntrinsicLocationsBuilderX86::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   CreateIntIntIntToIntLocations(
       allocator_, invoke, codegen_, DataType::Type::kInt32, /*is_volatile=*/ true);
@@ -1850,6 +1928,9 @@ void IntrinsicLocationsBuilderX86::VisitJdkUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86::VisitJdkUnsafeGet(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
+void IntrinsicCodeGeneratorX86::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  GenUnsafeGetAbsolute(invoke, DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
+}
 void IntrinsicCodeGeneratorX86::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ true, codegen_);
 }
@@ -1878,6 +1959,26 @@ void IntrinsicCodeGeneratorX86::VisitJdkUnsafeGetByte(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt8, /*is_volatile=*/ false, codegen_);
 }
 
+static void CreateIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator,
+                                                    DataType::Type type,
+                                                    HInvoke* invoke,
+                                                    bool is_volatile) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  if (type == DataType::Type::kInt8 || type == DataType::Type::kUint8) {
+    // Ensure the value is in a byte register
+    locations->SetInAt(2, Location::ByteRegisterOrConstant(EAX, invoke->InputAt(3)));
+  } else {
+    locations->SetInAt(2, Location::RequiresRegister());
+  }
+  if (type == DataType::Type::kInt64 && is_volatile) {
+    locations->AddTemp(Location::RequiresFpuRegister());
+    locations->AddTemp(Location::RequiresFpuRegister());
+  }
+}
+
 static void CreateIntIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator,
                                                        DataType::Type type,
                                                        HInvoke* invoke,
@@ -1907,6 +2008,9 @@ static void CreateIntIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator
 void IntrinsicLocationsBuilderX86::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicLocationsBuilderX86::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderX86::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -1939,6 +2043,10 @@ void IntrinsicLocationsBuilderX86::VisitJdkUnsafePut(HInvoke* invoke) {
   CreateIntIntIntIntToVoidPlusTempsLocations(
       allocator_, DataType::Type::kInt32, invoke, /*is_volatile=*/ false);
 }
+void IntrinsicLocationsBuilderX86::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  CreateIntIntIntToVoidPlusTempsLocations(
+      allocator_, DataType::Type::kInt64, invoke, /*is_volatile=*/ false);
+}
 void IntrinsicLocationsBuilderX86::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   CreateIntIntIntIntToVoidPlusTempsLocations(
       allocator_, DataType::Type::kInt32, invoke, /*is_volatile=*/ false);
@@ -2044,9 +2152,54 @@ static void GenUnsafePut(LocationSummary* locations,
   }
 }
 
+// We don't care for ordered: it requires an AnyStore barrier, which is already given by the x86
+// memory model.
+static void GenUnsafePutAbsolute(LocationSummary* locations,
+                                 DataType::Type type,
+                                 bool is_volatile,
+                                 CodeGeneratorX86* codegen) {
+  X86Assembler* assembler = down_cast<X86Assembler*>(codegen->GetAssembler());
+  Register address = locations->InAt(1).AsRegisterPairLow<Register>();
+  Address address_offset(address, 0);
+  Location value_loc = locations->InAt(2);
+
+  if (type == DataType::Type::kInt64) {
+    Register value_lo = value_loc.AsRegisterPairLow<Register>();
+    Register value_hi = value_loc.AsRegisterPairHigh<Register>();
+    if (is_volatile) {
+      XmmRegister temp1 = locations->GetTemp(0).AsFpuRegister<XmmRegister>();
+      XmmRegister temp2 = locations->GetTemp(1).AsFpuRegister<XmmRegister>();
+      __ movd(temp1, value_lo);
+      __ movd(temp2, value_hi);
+      __ punpckldq(temp1, temp2);
+      __ movsd(address_offset, temp1);
+    } else {
+      __ movl(address_offset, value_lo);
+      __ movl(Address(address, 4), value_hi);
+    }
+  } else if (type == DataType::Type::kInt32) {
+    __ movl(address_offset, value_loc.AsRegister<Register>());
+  } else {
+    CHECK_EQ(type, DataType::Type::kInt8) << "Unimplemented GenUnsafePut data type";
+    if (value_loc.IsRegister()) {
+      __ movb(address_offset, value_loc.AsRegister<ByteRegister>());
+    } else {
+      __ movb(address_offset,
+              Immediate(CodeGenerator::GetInt8ValueOf(value_loc.GetConstant())));
+    }
+  }
+
+  if (is_volatile) {
+    codegen->MemoryFence();
+  }
+}
+
 void IntrinsicCodeGeneratorX86::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicCodeGeneratorX86::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorX86::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -2078,6 +2231,10 @@ void IntrinsicCodeGeneratorX86::VisitUnsafePutByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86::VisitJdkUnsafePut(HInvoke* invoke) {
   GenUnsafePut(invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
+void IntrinsicCodeGeneratorX86::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  GenUnsafePutAbsolute(
+      invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/false, codegen_);
+}
 void IntrinsicCodeGeneratorX86::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   GenUnsafePut(invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
@@ -2489,6 +2646,7 @@ void CreateUnsafeGetAndUpdateLocations(ArenaAllocator* allocator,
     locations->SetCustomSlowPathCallerSaves(RegisterSet::Empty());  // No caller-save registers.
   }
   locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
   if (type == DataType::Type::kInt64) {
     // Explicitly allocate all registers.
     locations->SetInAt(1, Location::RegisterLocation(EBP));
@@ -2502,14 +2660,25 @@ void CreateUnsafeGetAndUpdateLocations(ArenaAllocator* allocator,
       locations->SetInAt(2, Location::RegisterPairLocation(ESI, EDI));
       locations->SetInAt(3, Location::RegisterPairLocation(EBX, ECX));
     }
-    locations->SetOut(Location::RegisterPairLocation(EAX, EDX), Location::kOutputOverlap);
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(EAX));
+      locations->AddTemp(Location::RegisterLocation(EDX));
+    } else {
+      locations->SetOut(Location::RegisterPairLocation(EAX, EDX), Location::kOutputOverlap);
+    }
   } else {
     locations->SetInAt(1, Location::RequiresRegister());
     locations->SetInAt(2, Location::RequiresRegister());
     // Use the same register for both the output and the new value or addend
     // to take advantage of XCHG or XADD. Arbitrarily pick EAX.
     locations->SetInAt(3, Location::RegisterLocation(EAX));
-    locations->SetOut(Location::RegisterLocation(EAX));
+    // Only set the `out` register if it's needed. In the void case we can still use EAX in the
+    // same manner as it is marked as a temp register.
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(EAX));
+    } else {
+      locations->SetOut(Location::RegisterLocation(EAX));
+    }
   }
 }
 
@@ -2573,14 +2742,20 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
   X86Assembler* assembler = down_cast<X86Assembler*>(codegen->GetAssembler());
   LocationSummary* locations = invoke->GetLocations();
 
-  Location out = locations->Out();                            // Result.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
+  // We use requested specific registers to use as temps for void methods, as we don't return the
+  // value.
+  Location out_or_temp =
+      is_void ? (type == DataType::Type::kInt64 ? Location::RegisterPairLocation(EAX, EDX) :
+                                                  Location::RegisterLocation(EAX)) :
+                locations->Out();
   Register base = locations->InAt(1).AsRegister<Register>();  // Object pointer.
   Location offset = locations->InAt(2);                       // Long offset.
   Location arg = locations->InAt(3);                          // New value or addend.
 
   if (type == DataType::Type::kInt32) {
-    DCHECK(out.Equals(arg));
-    Register out_reg = out.AsRegister<Register>();
+    DCHECK(out_or_temp.Equals(arg));
+    Register out_reg = out_or_temp.AsRegister<Register>();
     Address field_address(base, offset.AsRegisterPairLow<Register>(), TIMES_1, 0);
     if (get_and_update_op == GetAndUpdateOp::kAdd) {
       __ LockXaddl(field_address, out_reg);
@@ -2621,7 +2796,7 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
   } else {
     DCHECK_EQ(type, DataType::Type::kReference);
     DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
-    Register out_reg = out.AsRegister<Register>();
+    Register out_reg = out_or_temp.AsRegister<Register>();
     Address field_address(base, offset.AsRegisterPairLow<Register>(), TIMES_1, 0);
     Register temp1 = locations->GetTemp(0).AsRegister<Register>();
     Register temp2 = locations->GetTemp(1).AsRegister<Register>();
@@ -2650,8 +2825,10 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
       __ movl(temp1, out_reg);
       __ PoisonHeapReference(temp1);
       __ xchgl(temp1, field_address);
-      __ UnpoisonHeapReference(temp1);
-      __ movl(out_reg, temp1);
+      if (!is_void) {
+        __ UnpoisonHeapReference(temp1);
+        __ movl(out_reg, temp1);
+      }
     } else {
       __ xchgl(out_reg, field_address);
     }
@@ -4237,9 +4414,13 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86*
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   uint32_t value_index = number_of_arguments - 1;
   DataType::Type value_type = GetDataTypeFromShorty(invoke, value_index);
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
 
   if (DataType::Is64BitType(value_type)) {
     // We avoid the case of an Int64/Float64 value because we would need to place it in a register
@@ -4266,10 +4447,19 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86*
   if (value_type == DataType::Type::kFloat32) {
     locations->AddTemp(Location::RegisterLocation(EAX));
     locations->SetInAt(value_index, Location::FpuRegisterOrConstant(invoke->InputAt(value_index)));
-    locations->SetOut(Location::RequiresFpuRegister());
+    // Only set the `out` register if it's needed. In the void case, we will not use `out`.
+    if (!is_void) {
+      locations->SetOut(Location::RequiresFpuRegister());
+    }
   } else {
     locations->SetInAt(value_index, Location::RegisterLocation(EAX));
-    locations->SetOut(Location::RegisterLocation(EAX));
+    // Only set the `out` register if it's needed. In the void case we can still use EAX in the
+    // same manner as it is marked as a temp register.
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(EAX));
+    } else {
+      locations->SetOut(Location::RegisterLocation(EAX));
+    }
   }
 }
 
@@ -4283,6 +4473,7 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke, CodeGeneratorX86* codege
   // The value we want to set is the last argument
   uint32_t value_index = invoke->GetNumberOfArguments() - 1;
   Location value = locations->InAt(value_index);
+  // Get the type from the shorty as the invokes may not return a value.
   DataType::Type value_type = GetDataTypeFromShorty(invoke, value_index);
   Register temp = locations->GetTemp(1).AsRegister<Register>();
   Register temp2 = locations->GetTemp(2).AsRegister<Register>();
@@ -4307,24 +4498,36 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke, CodeGeneratorX86* codege
   // fields the object is in a separate register, it is safe to use the first temporary register.
   temp = expected_coordinates_count == 1u ? temp : locations->GetTemp(3).AsRegister<Register>();
   // No need for a lock prefix. `xchg` has an implicit lock when it is used with an address.
+
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
   switch (value_type) {
     case DataType::Type::kBool:
       __ xchgb(value.AsRegister<ByteRegister>(), field_addr);
-      __ movzxb(locations->Out().AsRegister<Register>(),
-                locations->Out().AsRegister<ByteRegister>());
+      if (!is_void) {
+        __ movzxb(locations->Out().AsRegister<Register>(),
+                  locations->Out().AsRegister<ByteRegister>());
+      }
       break;
     case DataType::Type::kInt8:
       __ xchgb(value.AsRegister<ByteRegister>(), field_addr);
-      __ movsxb(locations->Out().AsRegister<Register>(),
-                locations->Out().AsRegister<ByteRegister>());
+      if (!is_void) {
+        __ movsxb(locations->Out().AsRegister<Register>(),
+                  locations->Out().AsRegister<ByteRegister>());
+      }
       break;
     case DataType::Type::kUint16:
       __ xchgw(value.AsRegister<Register>(), field_addr);
-      __ movzxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      if (!is_void) {
+        __ movzxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      }
       break;
     case DataType::Type::kInt16:
       __ xchgw(value.AsRegister<Register>(), field_addr);
-      __ movsxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      if (!is_void) {
+        __ movsxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      }
       break;
     case DataType::Type::kInt32:
       __ xchgl(value.AsRegister<Register>(), field_addr);
@@ -4332,7 +4535,9 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke, CodeGeneratorX86* codege
     case DataType::Type::kFloat32:
       codegen->Move32(Location::RegisterLocation(EAX), value);
       __ xchgl(EAX, field_addr);
-      __ movd(locations->Out().AsFpuRegister<XmmRegister>(), EAX);
+      if (!is_void) {
+        __ movd(locations->Out().AsFpuRegister<XmmRegister>(), EAX);
+      }
       break;
     case DataType::Type::kReference: {
       if (codegen->EmitBakerReadBarrier()) {
@@ -4353,10 +4558,13 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke, CodeGeneratorX86* codege
         __ movl(temp, value.AsRegister<Register>());
         __ PoisonHeapReference(temp);
         __ xchgl(temp, field_addr);
-        __ UnpoisonHeapReference(temp);
-        __ movl(locations->Out().AsRegister<Register>(), temp);
+        if (!is_void) {
+          __ UnpoisonHeapReference(temp);
+          __ movl(locations->Out().AsRegister<Register>(), temp);
+        }
       } else {
-        __ xchgl(locations->Out().AsRegister<Register>(), field_addr);
+        DCHECK_IMPLIES(!is_void, locations->Out().Equals(Location::RegisterLocation(EAX)));
+        __ xchgl(Location::RegisterLocation(EAX).AsRegister<Register>(), field_addr);
       }
       break;
     }
@@ -4590,6 +4798,7 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86*
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   // The last argument should be the value we intend to set.
   uint32_t value_index = invoke->GetNumberOfArguments() - 1;
   DataType::Type value_type = GetDataTypeFromShorty(invoke, value_index);
@@ -4615,15 +4824,28 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86*
     locations->AddTemp(Location::RequiresRegister());
   }
 
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+
   if (DataType::IsFloatingPointType(value_type)) {
     locations->AddTemp(Location::RequiresFpuRegister());
     locations->AddTemp(Location::RegisterLocation(EAX));
     locations->SetInAt(value_index, Location::RequiresFpuRegister());
-    locations->SetOut(Location::RequiresFpuRegister());
+    // Only set the `out` register if it's needed. In the void case, we do not use `out`.
+    if (!is_void) {
+      locations->SetOut(Location::RequiresFpuRegister());
+    }
   } else {
     // xadd updates the register argument with the old value. ByteRegister required for xaddb.
     locations->SetInAt(value_index, Location::RegisterLocation(EAX));
-    locations->SetOut(Location::RegisterLocation(EAX));
+    // Only set the `out` register if it's needed. In the void case we can still use EAX in the
+    // same manner as it is marked as a temp register.
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(EAX));
+    } else {
+      locations->SetOut(Location::RegisterLocation(EAX));
+    }
   }
 }
 
@@ -4636,8 +4858,11 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke, CodeGeneratorX86* codege
   LocationSummary* locations = invoke->GetLocations();
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   uint32_t value_index = number_of_arguments - 1;
+  // Get the type from the shorty as the invokes may not return a value.
   DataType::Type type = GetDataTypeFromShorty(invoke, value_index);
-  DCHECK_EQ(type, invoke->GetType());
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == type);
   Location value_loc = locations->InAt(value_index);
   Register temp = locations->GetTemp(0).AsRegister<Register>();
   SlowPathCode* slow_path = new (codegen->GetScopedAllocator()) IntrinsicSlowPathX86(invoke);
@@ -4659,16 +4884,22 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke, CodeGeneratorX86* codege
   switch (type) {
     case DataType::Type::kInt8:
       __ LockXaddb(field_addr, value_loc.AsRegister<ByteRegister>());
-      __ movsxb(locations->Out().AsRegister<Register>(),
-                locations->Out().AsRegister<ByteRegister>());
+      if (!is_void) {
+        __ movsxb(locations->Out().AsRegister<Register>(),
+                  locations->Out().AsRegister<ByteRegister>());
+      }
       break;
     case DataType::Type::kInt16:
       __ LockXaddw(field_addr, value_loc.AsRegister<Register>());
-      __ movsxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      if (!is_void) {
+        __ movsxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      }
       break;
     case DataType::Type::kUint16:
       __ LockXaddw(field_addr, value_loc.AsRegister<Register>());
-      __ movzxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      if (!is_void) {
+        __ movzxw(locations->Out().AsRegister<Register>(), locations->Out().AsRegister<Register>());
+      }
       break;
     case DataType::Type::kInt32:
       __ LockXaddl(field_addr, value_loc.AsRegister<Register>());
@@ -4693,8 +4924,10 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke, CodeGeneratorX86* codege
                                 temp);
       __ j(kNotZero, &try_again);
 
-      // The old value is present in EAX.
-      codegen->Move32(locations->Out(), eax);
+      if (!is_void) {
+        // The old value is present in EAX.
+        codegen->Move32(locations->Out(), eax);
+      }
       break;
     }
     default:
@@ -4740,9 +4973,11 @@ static void CreateVarHandleGetAndBitwiseOpLocations(HInvoke* invoke, CodeGenerat
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   // The last argument should be the value we intend to set.
   uint32_t value_index = invoke->GetNumberOfArguments() - 1;
-  if (DataType::Is64BitType(GetDataTypeFromShorty(invoke, value_index))) {
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, value_index);
+  if (DataType::Is64BitType(value_type)) {
     // We avoid the case of an Int64 value because we would need to place it in a register pair.
     // If the slow path is taken, the ParallelMove might fail to move the pair according to the
     // X86DexCallingConvention in case of an overlap (e.g., move the 64 bit value from
@@ -4767,7 +5002,18 @@ static void CreateVarHandleGetAndBitwiseOpLocations(HInvoke* invoke, CodeGenerat
   }
 
   locations->SetInAt(value_index, Location::RegisterOrConstant(invoke->InputAt(value_index)));
-  locations->SetOut(Location::RegisterLocation(EAX));
+
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
+  if (is_void) {
+    // Used as a temporary, even when we are not outputting it so reserve it. This has to be
+    // requested before the other temporary since there's variable number of temp registers and the
+    // other temp register is expected to be the last one.
+    locations->AddTemp(Location::RegisterLocation(EAX));
+  } else {
+    locations->SetOut(Location::RegisterLocation(EAX));
+  }
 }
 
 static void GenerateBitwiseOp(HInvoke* invoke,
@@ -4805,9 +5051,12 @@ static void GenerateVarHandleGetAndBitwiseOp(HInvoke* invoke, CodeGeneratorX86*
 
   X86Assembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t value_index = invoke->GetNumberOfArguments() - 1;
   DataType::Type type = GetDataTypeFromShorty(invoke, value_index);
-  DCHECK_EQ(type, invoke->GetType());
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == type);
   Register temp = locations->GetTemp(0).AsRegister<Register>();
   SlowPathCode* slow_path = new (codegen->GetScopedAllocator()) IntrinsicSlowPathX86(invoke);
   codegen->AddSlowPath(slow_path);
@@ -4826,8 +5075,9 @@ static void GenerateVarHandleGetAndBitwiseOp(HInvoke* invoke, CodeGeneratorX86*
   DCHECK_NE(temp, reference);
   Address field_addr(reference, offset, TIMES_1, 0);
 
-  Register out = locations->Out().AsRegister<Register>();
-  DCHECK_EQ(out, EAX);
+  Location eax_loc = Location::RegisterLocation(EAX);
+  Register eax = eax_loc.AsRegister<Register>();
+  DCHECK_IMPLIES(!is_void, locations->Out().Equals(eax_loc));
 
   if (invoke->GetIntrinsic() == Intrinsics::kVarHandleGetAndBitwiseOrRelease ||
       invoke->GetIntrinsic() == Intrinsics::kVarHandleGetAndBitwiseXorRelease ||
@@ -4838,12 +5088,12 @@ static void GenerateVarHandleGetAndBitwiseOp(HInvoke* invoke, CodeGeneratorX86*
   NearLabel try_again;
   __ Bind(&try_again);
   // Place the expected value in EAX for cmpxchg
-  codegen->LoadFromMemoryNoBarrier(type, locations->Out(), field_addr);
+  codegen->LoadFromMemoryNoBarrier(type, eax_loc, field_addr);
   codegen->Move32(locations->GetTemp(0), locations->InAt(value_index));
-  GenerateBitwiseOp(invoke, codegen, temp, out);
+  GenerateBitwiseOp(invoke, codegen, temp, eax);
   GenPrimitiveLockedCmpxchg(type,
                             codegen,
-                            /* expected_value= */ locations->Out(),
+                            /* expected_value= */ eax_loc,
                             /* new_value= */ locations->GetTemp(0),
                             reference,
                             offset);
diff --git a/compiler/optimizing/intrinsics_x86_64.cc b/compiler/optimizing/intrinsics_x86_64.cc
index bd6d6d1889..e5d4dc4cc2 100644
--- a/compiler/optimizing/intrinsics_x86_64.cc
+++ b/compiler/optimizing/intrinsics_x86_64.cc
@@ -27,8 +27,8 @@
 #include "entrypoints/quick/quick_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "heap_poisoning.h"
-#include "intrinsics.h"
 #include "intrinsic_objects.h"
+#include "intrinsics.h"
 #include "intrinsics_utils.h"
 #include "lock_word.h"
 #include "mirror/array-inl.h"
@@ -36,6 +36,8 @@
 #include "mirror/reference.h"
 #include "mirror/string.h"
 #include "optimizing/code_generator.h"
+#include "optimizing/data_type.h"
+#include "optimizing/locations.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 #include "utils/x86_64/assembler_x86_64.h"
@@ -162,7 +164,7 @@ class InvokePolymorphicSlowPathX86_64 : public SlowPathCode {
     SaveLiveRegisters(codegen, instruction_->GetLocations());
 
     // Passing `MethodHandle` object as hidden argument.
-    __ movq(CpuRegister(RDI), method_handle_);
+    __ movl(CpuRegister(RDI), method_handle_);
     x86_64_codegen->InvokeRuntime(QuickEntrypointEnum::kQuickInvokePolymorphicWithHiddenReceiver,
                                   instruction_,
                                   instruction_->GetDexPc());
@@ -328,7 +330,7 @@ static void CreateFPToFPLocations(ArenaAllocator* allocator, HInvoke* invoke) {
   LocationSummary* locations =
       new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
   locations->SetInAt(0, Location::RequiresFpuRegister());
-  locations->SetOut(Location::RequiresFpuRegister());
+  locations->SetOut(Location::RequiresFpuRegister(), Location::kNoOutputOverlap);
 }
 
 void IntrinsicLocationsBuilderX86_64::VisitMathSqrt(HInvoke* invoke) {
@@ -1888,6 +1890,43 @@ static void GenUnsafeGet(HInvoke* invoke,
   }
 }
 
+static void GenUnsafeGetAbsolute(HInvoke* invoke,
+                                 DataType::Type type,
+                                 CodeGeneratorX86_64* codegen) {
+  X86_64Assembler* assembler = down_cast<X86_64Assembler*>(codegen->GetAssembler());
+  LocationSummary* locations = invoke->GetLocations();
+  Location address_loc = locations->InAt(1);
+  Address address = Address(address_loc.AsRegister<CpuRegister>(), 0);
+  Location output_loc = locations->Out();
+  CpuRegister output = output_loc.AsRegister<CpuRegister>();
+
+  switch (type) {
+    case DataType::Type::kInt8:
+      __ movsxb(output, address);
+      break;
+
+    case DataType::Type::kInt32:
+      __ movl(output, address);
+      break;
+
+    case DataType::Type::kInt64:
+      __ movq(output, address);
+      break;
+
+    default:
+      LOG(FATAL) << "Unsupported op size " << type;
+      UNREACHABLE();
+  }
+}
+
+static void CreateIntIntToIntLocations(ArenaAllocator* allocator, HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetOut(Location::RequiresRegister(), Location::kNoOutputOverlap);
+}
+
 static void CreateIntIntIntToIntLocations(ArenaAllocator* allocator,
                                           HInvoke* invoke,
                                           CodeGeneratorX86_64* codegen) {
@@ -1911,6 +1950,9 @@ static void CreateIntIntIntToIntLocations(ArenaAllocator* allocator,
 void IntrinsicLocationsBuilderX86_64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicLocationsBuilderX86_64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderX86_64::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -1933,6 +1975,9 @@ void IntrinsicLocationsBuilderX86_64::VisitUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafeGet(HInvoke* invoke) {
   CreateIntIntIntToIntLocations(allocator_, invoke, codegen_);
 }
+void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  CreateIntIntToIntLocations(allocator_, invoke);
+}
 void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   CreateIntIntIntToIntLocations(allocator_, invoke, codegen_);
 }
@@ -1964,6 +2009,9 @@ void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86_64::VisitUnsafeGet(HInvoke* invoke) {
   VisitJdkUnsafeGet(invoke);
 }
+void IntrinsicCodeGeneratorX86_64::VisitUnsafeGetAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafeGetAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorX86_64::VisitUnsafeGetVolatile(HInvoke* invoke) {
   VisitJdkUnsafeGetVolatile(invoke);
 }
@@ -1986,6 +2034,9 @@ void IntrinsicCodeGeneratorX86_64::VisitUnsafeGetByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafeGet(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
+void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafeGetAbsolute(HInvoke* invoke) {
+  GenUnsafeGetAbsolute(invoke, DataType::Type::kInt32, codegen_);
+}
 void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafeGetVolatile(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt32, /*is_volatile=*/ true, codegen_);
 }
@@ -2014,6 +2065,16 @@ void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafeGetByte(HInvoke* invoke) {
   GenUnsafeGet(invoke, DataType::Type::kInt8, /*is_volatile=*/false, codegen_);
 }
 
+static void CreateIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator,
+                                                    [[maybe_unused]] DataType::Type type,
+                                                    HInvoke* invoke) {
+  LocationSummary* locations =
+      new (allocator) LocationSummary(invoke, LocationSummary::kNoCall, kIntrinsified);
+  locations->SetInAt(0, Location::NoLocation());        // Unused receiver.
+  locations->SetInAt(1, Location::RequiresRegister());
+  locations->SetInAt(2, Location::RequiresRegister());
+}
+
 static void CreateIntIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator,
                                                        DataType::Type type,
                                                        HInvoke* invoke) {
@@ -2033,6 +2094,9 @@ static void CreateIntIntIntIntToVoidPlusTempsLocations(ArenaAllocator* allocator
 void IntrinsicLocationsBuilderX86_64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicLocationsBuilderX86_64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicLocationsBuilderX86_64::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -2064,6 +2128,9 @@ void IntrinsicLocationsBuilderX86_64::VisitUnsafePutByte(HInvoke* invoke) {
 void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafePut(HInvoke* invoke) {
   CreateIntIntIntIntToVoidPlusTempsLocations(allocator_, DataType::Type::kInt32, invoke);
 }
+void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  CreateIntIntIntToVoidPlusTempsLocations(allocator_, DataType::Type::kInt32, invoke);
+}
 void IntrinsicLocationsBuilderX86_64::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   CreateIntIntIntIntToVoidPlusTempsLocations(allocator_, DataType::Type::kInt32, invoke);
 }
@@ -2138,9 +2205,37 @@ static void GenUnsafePut(LocationSummary* locations, DataType::Type type, bool i
   }
 }
 
+// We don't care for ordered: it requires an AnyStore barrier, which is already given by the x86
+// memory model.
+static void GenUnsafePutAbsolute(LocationSummary* locations,
+                                 DataType::Type type,
+                                 bool is_volatile,
+                                 CodeGeneratorX86_64* codegen) {
+  X86_64Assembler* assembler = down_cast<X86_64Assembler*>(codegen->GetAssembler());
+  CpuRegister address_reg = locations->InAt(1).AsRegister<CpuRegister>();
+  Address address = Address(address_reg, 0);
+  CpuRegister value = locations->InAt(2).AsRegister<CpuRegister>();
+
+  if (type == DataType::Type::kInt64) {
+    __ movq(address, value);
+  } else if (type == DataType::Type::kInt32) {
+    __ movl(address, value);
+  } else {
+    CHECK_EQ(type, DataType::Type::kInt8) << "Unimplemented GenUnsafePut data type";
+    __ movb(address, value);
+  }
+
+  if (is_volatile) {
+    codegen->MemoryFence();
+  }
+}
+
 void IntrinsicCodeGeneratorX86_64::VisitUnsafePut(HInvoke* invoke) {
   VisitJdkUnsafePut(invoke);
 }
+void IntrinsicCodeGeneratorX86_64::VisitUnsafePutAbsolute(HInvoke* invoke) {
+  VisitJdkUnsafePutAbsolute(invoke);
+}
 void IntrinsicCodeGeneratorX86_64::VisitUnsafePutOrdered(HInvoke* invoke) {
   VisitJdkUnsafePutOrdered(invoke);
 }
@@ -2172,6 +2267,10 @@ void IntrinsicCodeGeneratorX86_64::VisitUnsafePutByte(HInvoke* invoke) {
 void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafePut(HInvoke* invoke) {
   GenUnsafePut(invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
+void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafePutAbsolute(HInvoke* invoke) {
+  GenUnsafePutAbsolute(
+      invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/false, codegen_);
+}
 void IntrinsicCodeGeneratorX86_64::VisitJdkUnsafePutOrdered(HInvoke* invoke) {
   GenUnsafePut(invoke->GetLocations(), DataType::Type::kInt32, /*is_volatile=*/ false, codegen_);
 }
@@ -2633,7 +2732,13 @@ static void CreateUnsafeGetAndUpdateLocations(ArenaAllocator* allocator,
   // Use the same register for both the output and the new value or addend
   // to take advantage of XCHG or XADD. Arbitrarily pick RAX.
   locations->SetInAt(3, Location::RegisterLocation(RAX));
-  locations->SetOut(Location::RegisterLocation(RAX));
+  // Only set the `out` register if it's needed. In the void case we can still use RAX in the
+  // same manner as it is marked as a temp register.
+  if (invoke->GetType() == DataType::Type::kVoid) {
+    locations->AddTemp(Location::RegisterLocation(RAX));
+  } else {
+    locations->SetOut(Location::RegisterLocation(RAX));
+  }
 }
 
 void IntrinsicLocationsBuilderX86_64::VisitUnsafeGetAndAddInt(HInvoke* invoke) {
@@ -2697,32 +2802,43 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
   X86_64Assembler* assembler = down_cast<X86_64Assembler*>(codegen->GetAssembler());
   LocationSummary* locations = invoke->GetLocations();
 
-  CpuRegister out = locations->Out().AsRegister<CpuRegister>();       // Result.
-  CpuRegister base = locations->InAt(1).AsRegister<CpuRegister>();    // Object pointer.
-  CpuRegister offset = locations->InAt(2).AsRegister<CpuRegister>();  // Long offset.
-  DCHECK_EQ(out, locations->InAt(3).AsRegister<CpuRegister>());       // New value or addend.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
+  Location rax_loc = Location::RegisterLocation(RAX);
+  // We requested RAX to use as a temporary for void methods, as we don't return the value.
+  DCHECK_IMPLIES(!is_void, locations->Out().Equals(rax_loc));
+  CpuRegister out_or_temp = rax_loc.AsRegister<CpuRegister>();           // Result.
+  CpuRegister base = locations->InAt(1).AsRegister<CpuRegister>();       // Object pointer.
+  CpuRegister offset = locations->InAt(2).AsRegister<CpuRegister>();     // Long offset.
+  DCHECK_EQ(out_or_temp, locations->InAt(3).AsRegister<CpuRegister>());  // New value or addend.
   Address field_address(base, offset, TIMES_1, 0);
 
   if (type == DataType::Type::kInt32) {
     if (get_and_update_op == GetAndUpdateOp::kAdd) {
-      __ LockXaddl(field_address, out);
+      __ LockXaddl(field_address, out_or_temp);
     } else {
       DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
-      __ xchgl(out, field_address);
+      __ xchgl(out_or_temp, field_address);
     }
   } else if (type == DataType::Type::kInt64) {
     if (get_and_update_op == GetAndUpdateOp::kAdd) {
-      __ LockXaddq(field_address, out);
+      __ LockXaddq(field_address, out_or_temp);
     } else {
       DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
-      __ xchgq(out, field_address);
+      __ xchgq(out_or_temp, field_address);
     }
   } else {
     DCHECK_EQ(type, DataType::Type::kReference);
     DCHECK(get_and_update_op == GetAndUpdateOp::kSet);
-    CpuRegister temp1 = locations->GetTemp(0).AsRegister<CpuRegister>();
-    CpuRegister temp2 = locations->GetTemp(1).AsRegister<CpuRegister>();
-    CpuRegister temp3 = locations->GetTemp(2).AsRegister<CpuRegister>();
+
+    // In the void case, we have an extra temp register, which is used to signal the register
+    // allocator that we are clobering RAX.
+    const uint32_t extra_temp = is_void ? 1u : 0u;
+    DCHECK_EQ(locations->GetTempCount(), 3u + extra_temp);
+    DCHECK_IMPLIES(is_void, locations->GetTemp(0u).Equals(Location::RegisterLocation(RAX)));
+
+    CpuRegister temp1 = locations->GetTemp(0u + extra_temp).AsRegister<CpuRegister>();
+    CpuRegister temp2 = locations->GetTemp(1u + extra_temp).AsRegister<CpuRegister>();
+    CpuRegister temp3 = locations->GetTemp(2u + extra_temp).AsRegister<CpuRegister>();
 
     if (codegen->EmitReadBarrier()) {
       DCHECK(kUseBakerReadBarrier);
@@ -2740,18 +2856,20 @@ static void GenUnsafeGetAndUpdate(HInvoke* invoke,
 
     // Mark card for object as a new value shall be stored.
     bool new_value_can_be_null = true;  // TODO: Worth finding out this information?
-    codegen->MaybeMarkGCCard(temp1, temp2, base, /*value=*/out, new_value_can_be_null);
+    codegen->MaybeMarkGCCard(temp1, temp2, base, /*value=*/out_or_temp, new_value_can_be_null);
 
     if (kPoisonHeapReferences) {
       // Use a temp to avoid poisoning base of the field address, which might happen if `out`
       // is the same as `base` (for code like `unsafe.getAndSet(obj, offset, obj)`).
-      __ movl(temp1, out);
+      __ movl(temp1, out_or_temp);
       __ PoisonHeapReference(temp1);
       __ xchgl(temp1, field_address);
-      __ UnpoisonHeapReference(temp1);
-      __ movl(out, temp1);
+      if (!is_void) {
+        __ UnpoisonHeapReference(temp1);
+        __ movl(out_or_temp, temp1);
+      }
     } else {
-      __ xchgl(out, field_address);
+      __ xchgl(out_or_temp, field_address);
     }
   }
 }
@@ -4099,12 +4217,6 @@ static void GenerateVarHandleGet(HInvoke* invoke,
 }
 
 void IntrinsicLocationsBuilderX86_64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
-  // Don't emit intrinsic code for MethodHandle.invokeExact when it certainly does not target
-  // invoke-virtual: if invokeExact is called w/o arguments or if the first argument in that
-  // call is not a reference.
-  if (!invoke->AsInvokePolymorphic()->CanHaveFastPath()) {
-    return;
-  }
   ArenaAllocator* allocator = invoke->GetBlock()->GetGraph()->GetAllocator();
   LocationSummary* locations = new (allocator)
       LocationSummary(invoke, LocationSummary::kCallOnMainAndSlowPath, kIntrinsified);
@@ -4124,10 +4236,11 @@ void IntrinsicLocationsBuilderX86_64::VisitMethodHandleInvokeExact(HInvoke* invo
   locations->SetInAt(number_of_args, Location::RequiresRegister());
 
   locations->AddTemp(Location::RequiresRegister());
+  // Hidden arg for invoke-interface.
+  locations->AddTemp(Location::RegisterLocation(RAX));
 }
 
 void IntrinsicCodeGeneratorX86_64::VisitMethodHandleInvokeExact(HInvoke* invoke) {
-  DCHECK(invoke->AsInvokePolymorphic()->CanHaveFastPath());
   LocationSummary* locations = invoke->GetLocations();
 
   CpuRegister method_handle = locations->InAt(0).AsRegister<CpuRegister>();
@@ -4137,59 +4250,108 @@ void IntrinsicCodeGeneratorX86_64::VisitMethodHandleInvokeExact(HInvoke* invoke)
   codegen_->AddSlowPath(slow_path);
   X86_64Assembler* assembler = codegen_->GetAssembler();
 
-  Address method_handle_kind = Address(method_handle, mirror::MethodHandle::HandleKindOffset());
-
-  // If it is not InvokeVirtual then go to slow path.
-  // Even if MethodHandle's kind is kInvokeVirtual, the underlying method can still be an interface
-  // or a direct method (that's what current `MethodHandles$Lookup.findVirtual` is doing). We don't
-  // check whether `method` is an interface method explicitly: in that case the subtype check below
-  // will fail.
-  // TODO(b/297147201): check whether it can be more precise and what d8/r8 can produce.
-  __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeVirtual));
-  __ j(kNotEqual, slow_path->GetEntryLabel());
-
   CpuRegister call_site_type =
       locations->InAt(invoke->GetNumberOfArguments()).AsRegister<CpuRegister>();
 
   // Call site should match with MethodHandle's type.
+  __ MaybePoisonHeapReference(call_site_type);
   __ cmpl(call_site_type, Address(method_handle, mirror::MethodHandle::MethodTypeOffset()));
   __ j(kNotEqual, slow_path->GetEntryLabel());
 
   CpuRegister method = CpuRegister(kMethodRegisterArgument);
-
-  // Get method to call.
   __ movq(method, Address(method_handle, mirror::MethodHandle::ArtFieldOrMethodOffset()));
 
-  CpuRegister receiver = locations->InAt(1).AsRegister<CpuRegister>();
+  Label static_dispatch;
+  Label execute_target_method;
 
-  __ testl(receiver, receiver);
-  __ j(kEqual, slow_path->GetEntryLabel());
+  Address method_handle_kind = Address(method_handle, mirror::MethodHandle::HandleKindOffset());
+  if (invoke->AsInvokePolymorphic()->CanTargetInstanceMethod()) {
+    CpuRegister receiver = locations->InAt(1).AsRegister<CpuRegister>();
 
-  // Using vtable_index register as temporary in subtype check. It will be overridden later.
-  // If `method` is an interface method this check will fail.
-  CpuRegister vtable_index = locations->GetTemp(0).AsRegister<CpuRegister>();
-  // We deliberately avoid the read barrier, letting the slow path handle the false negatives.
-  GenerateSubTypeObjectCheckNoReadBarrier(codegen_,
-                                          slow_path,
-                                          receiver,
-                                          vtable_index,
-                                          Address(method, ArtMethod::DeclaringClassOffset()));
+    // Receiver shouldn't be null for all the following cases.
+    __ testl(receiver, receiver);
+    __ j(kEqual, slow_path->GetEntryLabel());
+
+    __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeDirect));
+    // No dispatch is needed for invoke-direct.
+    __ j(kEqual, &execute_target_method);
+
+    Label non_virtual_dispatch;
+    // Handle invoke-virtual case.
+    __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeVirtual));
+    __ j(kNotEqual, &non_virtual_dispatch);
+
+    // Skip virtual dispatch if `method` is private.
+    __ testl(Address(method, ArtMethod::AccessFlagsOffset()), Immediate(kAccPrivate));
+    __ j(kNotZero, &execute_target_method);
+
+    CpuRegister temp = locations->GetTemp(0).AsRegister<CpuRegister>();
+
+    __ movl(temp, Address(method, ArtMethod::DeclaringClassOffset()));
+    __ cmpl(temp, Address(receiver, mirror::Object::ClassOffset()));
+    // If method is defined in the receiver's class, execute it as it is.
+    __ j(kEqual, &execute_target_method);
+
+    // MethodIndex is uint16_t.
+    __ movzxw(temp, Address(method, ArtMethod::MethodIndexOffset()));
+
+    constexpr uint32_t class_offset = mirror::Object::ClassOffset().Int32Value();
+    // Re-using method register for receiver class.
+    __ movl(method, Address(receiver, class_offset));
+    __ MaybeUnpoisonHeapReference(method);
+
+    constexpr uint32_t vtable_offset =
+        mirror::Class::EmbeddedVTableOffset(art::PointerSize::k64).Int32Value();
+    __ movq(method, Address(method, temp, TIMES_8, vtable_offset));
+    __ Jump(&execute_target_method);
+
+    __ Bind(&non_virtual_dispatch);
+    __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeInterface));
+    __ j(kNotEqual, &static_dispatch);
+
+    __ movl(temp, Address(method, ArtMethod::AccessFlagsOffset()));
+
+    __ testl(temp, Immediate(kAccPrivate));
+    __ j(kNotZero, &execute_target_method);
 
-  NearLabel execute_target_method;
-  // Skip virtual dispatch if `method` is private.
-  __ testl(Address(method, ArtMethod::AccessFlagsOffset()), Immediate(kAccPrivate));
-  __ j(kNotZero, &execute_target_method);
+    CpuRegister hidden_arg = locations->GetTemp(1).AsRegister<CpuRegister>();
+    // Set the hidden argument.
+    DCHECK_EQ(RAX, hidden_arg.AsRegister());
+    __ movq(hidden_arg, method);
 
-  // MethodIndex is uint16_t.
-  __ movzxw(vtable_index, Address(method, ArtMethod::MethodIndexOffset()));
+    Label get_imt_index_from_method_index;
+    Label do_imt_dispatch;
 
-  constexpr uint32_t class_offset = mirror::Object::ClassOffset().Int32Value();
-  // Re-using method register for receiver class.
-  __ movl(method, Address(receiver, class_offset));
+    // Get IMT index.
+    // Not doing default conflict check as IMT index is set for all method which have
+    // kAccAbstract bit.
+    __ testl(temp, Immediate(kAccAbstract));
+    __ j(kZero, &get_imt_index_from_method_index);
 
-  constexpr uint32_t vtable_offset =
-      mirror::Class::EmbeddedVTableOffset(art::PointerSize::k64).Int32Value();
-  __ movq(method, Address(method, vtable_index, TIMES_8, vtable_offset));
+    // imt_index_ is uint16_t
+    __ movzxw(temp, Address(method, ArtMethod::ImtIndexOffset()));
+    __ Jump(&do_imt_dispatch);
+
+    // Default method, do method->GetMethodIndex() & (ImTable::kSizeTruncToPowerOfTwo - 1);
+    __ Bind(&get_imt_index_from_method_index);
+    __ movl(temp, Address(method, ArtMethod::MethodIndexOffset()));
+    __ andl(temp, Immediate(ImTable::kSizeTruncToPowerOfTwo - 1));
+
+    __ Bind(&do_imt_dispatch);
+    // Re-using `method` to store receiver class and ImTableEntry.
+    __ movl(method, Address(receiver, mirror::Object::ClassOffset()));
+    __ MaybeUnpoisonHeapReference(method);
+
+    __ movq(method, Address(method, mirror::Class::ImtPtrOffset(kX86_64PointerSize).Uint32Value()));
+    // method = receiver->GetClass()->embedded_imtable_->Get(method_offset);
+    __ movq(method, Address(method, temp, TIMES_8, /* disp= */ 0));
+
+    __ Jump(&execute_target_method);
+  }
+  __ Bind(&static_dispatch);
+  __ cmpl(method_handle_kind, Immediate(mirror::MethodHandle::Kind::kInvokeStatic));
+  __ j(kNotEqual, slow_path->GetEntryLabel());
+  // MH's kind is invoke-static. The method can be called directly, hence fall-through.
 
   __ Bind(&execute_target_method);
   __ call(Address(
@@ -4502,23 +4664,26 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86_
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   uint32_t new_value_index = number_of_arguments - 1;
-  DataType::Type type = invoke->GetType();
-  DCHECK_EQ(type, GetDataTypeFromShorty(invoke, new_value_index));
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, new_value_index);
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke);
 
-  if (DataType::IsFloatingPointType(type)) {
-    locations->SetOut(Location::RequiresFpuRegister());
+  if (DataType::IsFloatingPointType(value_type)) {
+    // Only set the `out` register if it's needed. In the void case we don't use `out`.
+    if (!is_void) {
+      locations->SetOut(Location::RequiresFpuRegister());
+    }
     // A temporary is needed to load the new floating-point value into a register for XCHG.
     locations->AddTemp(Location::RequiresRegister());
   } else {
-    // Use the same register for both the new value and output to take advantage of XCHG.
-    // It doesn't have to be RAX, but we need to choose some to make sure it's the same.
-    locations->SetOut(Location::RegisterLocation(RAX));
     locations->SetInAt(new_value_index, Location::RegisterLocation(RAX));
-    if (type == DataType::Type::kReference) {
+    if (value_type == DataType::Type::kReference) {
       // Need two temporaries for MarkGCCard.
       locations->AddRegisterTemps(2);
       if (codegen->EmitReadBarrier()) {
@@ -4527,6 +4692,15 @@ static void CreateVarHandleGetAndSetLocations(HInvoke* invoke, CodeGeneratorX86_
         locations->AddTemp(Location::RequiresRegister());
       }
     }
+    // Only set the `out` register if it's needed. In the void case we can still use RAX in the
+    // same manner as it is marked as a temp register.
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(RAX));
+    } else {
+      // Use the same register for both the new value and output to take advantage of XCHG.
+      // It doesn't have to be RAX, but we need to choose some to make sure it's the same.
+      locations->SetOut(Location::RegisterLocation(RAX));
+    }
   }
 }
 
@@ -4541,6 +4715,9 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke,
   LocationSummary* locations = invoke->GetLocations();
   Location out = locations->Out();
   uint32_t temp_count = locations->GetTempCount();
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == type);
 
   if (DataType::IsFloatingPointType(type)) {
     // `getAndSet` for floating-point types: move the new FP value into a register, atomically
@@ -4560,38 +4737,48 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke,
     if (byte_swap) {
       codegen->GetInstructionCodegen()->Bswap(temp, bswap_type);
     }
-    __ movd(out.AsFpuRegister<XmmRegister>(), temp.AsRegister<CpuRegister>(), is64bit);
+    if (!is_void) {
+      __ movd(out.AsFpuRegister<XmmRegister>(), temp.AsRegister<CpuRegister>(), is64bit);
+    }
   } else if (type == DataType::Type::kReference) {
     // `getAndSet` for references: load reference and atomically exchange it with the field.
     // Output register is the same as the one holding new value, so no need to move the result.
     DCHECK(!byte_swap);
 
-    CpuRegister temp1 = locations->GetTemp(temp_count - 1).AsRegister<CpuRegister>();
-    CpuRegister temp2 = locations->GetTemp(temp_count - 2).AsRegister<CpuRegister>();
+    // In the void case, we have an extra temp register, which is used to signal the register
+    // allocator that we are clobering RAX.
+    const uint32_t extra_temp = is_void ? 1u : 0u;
+    DCHECK_IMPLIES(is_void,
+                   locations->GetTemp(temp_count - 1u).Equals(Location::RegisterLocation(RAX)));
+
+    CpuRegister temp1 = locations->GetTemp(temp_count - extra_temp - 1u).AsRegister<CpuRegister>();
+    CpuRegister temp2 = locations->GetTemp(temp_count - extra_temp - 2u).AsRegister<CpuRegister>();
     CpuRegister valreg = value.AsRegister<CpuRegister>();
 
     if (codegen->EmitBakerReadBarrier()) {
       codegen->GenerateReferenceLoadWithBakerReadBarrier(
           invoke,
-          locations->GetTemp(temp_count - 3),
+          locations->GetTemp(temp_count - extra_temp - 3u),
           ref,
           field_addr,
-          /*needs_null_check=*/ false,
-          /*always_update_field=*/ true,
+          /*needs_null_check=*/false,
+          /*always_update_field=*/true,
           &temp1,
           &temp2);
     }
     codegen->MarkGCCard(temp1, temp2, ref);
 
-    DCHECK_EQ(valreg, out.AsRegister<CpuRegister>());
+    DCHECK_IMPLIES(!is_void, valreg == out.AsRegister<CpuRegister>());
     if (kPoisonHeapReferences) {
       // Use a temp to avoid poisoning base of the field address, which might happen if `valreg` is
       // the same as `target.object` (for code like `vh.getAndSet(obj, obj)`).
       __ movl(temp1, valreg);
       __ PoisonHeapReference(temp1);
       __ xchgl(temp1, field_addr);
-      __ UnpoisonHeapReference(temp1);
-      __ movl(valreg, temp1);
+      if (!is_void) {
+        __ UnpoisonHeapReference(temp1);
+        __ movl(valreg, temp1);
+      }
     } else {
       __ xchgl(valreg, field_addr);
     }
@@ -4602,24 +4789,32 @@ static void GenerateVarHandleGetAndSet(HInvoke* invoke,
       codegen->GetInstructionCodegen()->Bswap(value, type);
     }
     CpuRegister valreg = value.AsRegister<CpuRegister>();
-    DCHECK_EQ(valreg, out.AsRegister<CpuRegister>());
+    DCHECK_IMPLIES(!is_void, valreg == out.AsRegister<CpuRegister>());
     switch (type) {
       case DataType::Type::kBool:
       case DataType::Type::kUint8:
         __ xchgb(valreg, field_addr);
-        __ movzxb(valreg, valreg);
+        if (!is_void) {
+          __ movzxb(valreg, valreg);
+        }
         break;
       case DataType::Type::kInt8:
         __ xchgb(valreg, field_addr);
-        __ movsxb(valreg, valreg);
+        if (!is_void) {
+          __ movsxb(valreg, valreg);
+        }
         break;
       case DataType::Type::kUint16:
         __ xchgw(valreg, field_addr);
-        __ movzxw(valreg, valreg);
+        if (!is_void) {
+          __ movzxw(valreg, valreg);
+        }
         break;
       case DataType::Type::kInt16:
         __ xchgw(valreg, field_addr);
-        __ movsxw(valreg, valreg);
+        if (!is_void) {
+          __ movsxw(valreg, valreg);
+        }
         break;
       case DataType::Type::kInt32:
       case DataType::Type::kUint32:
@@ -4644,25 +4839,35 @@ static void CreateVarHandleGetAndBitwiseOpLocations(HInvoke* invoke, CodeGenerat
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   uint32_t new_value_index = number_of_arguments - 1;
-  DataType::Type type = invoke->GetType();
-  DCHECK_EQ(type, GetDataTypeFromShorty(invoke, new_value_index));
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, new_value_index);
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke);
 
-  DCHECK_NE(DataType::Type::kReference, type);
-  DCHECK(!DataType::IsFloatingPointType(type));
-
+  DCHECK_NE(DataType::Type::kReference, value_type);
+  DCHECK(!DataType::IsFloatingPointType(value_type));
   // A temporary to compute the bitwise operation on the old and the new values.
   locations->AddTemp(Location::RequiresRegister());
   // We need value to be either in a register, or a 32-bit constant (as there are no arithmetic
   // instructions that accept 64-bit immediate on x86_64).
-  locations->SetInAt(new_value_index, DataType::Is64BitType(type)
-      ? Location::RequiresRegister()
-      : Location::RegisterOrConstant(invoke->InputAt(new_value_index)));
-  // Output is in RAX to accommodate CMPXCHG. It is also used as a temporary.
-  locations->SetOut(Location::RegisterLocation(RAX));
+  locations->SetInAt(new_value_index,
+                     DataType::Is64BitType(value_type) ?
+                         Location::RequiresRegister() :
+                         Location::RegisterOrConstant(invoke->InputAt(new_value_index)));
+  if (is_void) {
+    // Used as a temporary, even when we are not outputting it so reserve it. This has to be
+    // requested before the other temporary since there's variable number of temp registers and the
+    // other temp register is expected to be the last one.
+    locations->AddTemp(Location::RegisterLocation(RAX));
+  } else {
+    // Output is in RAX to accommodate CMPXCHG. It is also used as a temporary.
+    locations->SetOut(Location::RegisterLocation(RAX));
+  }
 }
 
 static void GenerateVarHandleGetAndOp(HInvoke* invoke,
@@ -4674,18 +4879,24 @@ static void GenerateVarHandleGetAndOp(HInvoke* invoke,
                                       bool byte_swap) {
   X86_64Assembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
-  Location temp_loc = locations->GetTemp(locations->GetTempCount() - 1);
-  Location rax_loc = locations->Out();
+  // In the void case, we have an extra temp register, which is used to signal the register
+  // allocator that we are clobering RAX.
+  const bool is_void = invoke->GetType() == DataType::Type::kVoid;
+  const uint32_t extra_temp = is_void ? 1u : 0u;
+  const uint32_t temp_count = locations->GetTempCount();
+  DCHECK_IMPLIES(is_void,
+                 locations->GetTemp(temp_count - 1u).Equals(Location::RegisterLocation(RAX)));
+  Location temp_loc = locations->GetTemp(temp_count - extra_temp - 1u);
+  Location rax_loc = Location::RegisterLocation(RAX);
+  DCHECK_IMPLIES(!is_void, locations->Out().Equals(rax_loc));
   CpuRegister temp = temp_loc.AsRegister<CpuRegister>();
-  CpuRegister rax = rax_loc.AsRegister<CpuRegister>();
-  DCHECK_EQ(rax.AsRegister(), RAX);
   bool is64Bit = DataType::Is64BitType(type);
 
   NearLabel retry;
   __ Bind(&retry);
 
   // Load field value into RAX and copy it into a temporary register for the operation.
-  codegen->LoadFromMemoryNoReference(type, Location::RegisterLocation(RAX), field_addr);
+  codegen->LoadFromMemoryNoReference(type, rax_loc, field_addr);
   codegen->Move(temp_loc, rax_loc);
   if (byte_swap) {
     // Byte swap the temporary, since we need to perform operation in native endianness.
@@ -4783,15 +4994,21 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86_
     return;
   }
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   uint32_t new_value_index = number_of_arguments - 1;
-  DataType::Type type = invoke->GetType();
-  DCHECK_EQ(type, GetDataTypeFromShorty(invoke, new_value_index));
+  DataType::Type value_type = GetDataTypeFromShorty(invoke, new_value_index);
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == value_type);
 
   LocationSummary* locations = CreateVarHandleCommonLocations(invoke);
 
-  if (DataType::IsFloatingPointType(type)) {
-    locations->SetOut(Location::RequiresFpuRegister());
+  if (DataType::IsFloatingPointType(value_type)) {
+    // Only set the `out` register if it's needed. In the void case we don't use `out`
+    if (!is_void) {
+      locations->SetOut(Location::RequiresFpuRegister());
+    }
     // Require that the new FP value is in a register (and not a constant) for ADDSS/ADDSD.
     locations->SetInAt(new_value_index, Location::RequiresFpuRegister());
     // CMPXCHG clobbers RAX.
@@ -4801,11 +5018,7 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86_
     // A temporary to hold the new value for CMPXCHG.
     locations->AddTemp(Location::RequiresRegister());
   } else {
-    DCHECK_NE(type, DataType::Type::kReference);
-    // Use the same register for both the new value and output to take advantage of XADD.
-    // It should be RAX, because the byte-swapping path of GenerateVarHandleGetAndAdd falls
-    // back to GenerateVarHandleGetAndOp that expects out in RAX.
-    locations->SetOut(Location::RegisterLocation(RAX));
+    DCHECK_NE(value_type, DataType::Type::kReference);
     locations->SetInAt(new_value_index, Location::RegisterLocation(RAX));
     if (GetExpectedVarHandleCoordinatesCount(invoke) == 2) {
       // For byte array views with non-native endianness we need extra BSWAP operations, so we
@@ -4815,6 +5028,16 @@ static void CreateVarHandleGetAndAddLocations(HInvoke* invoke, CodeGeneratorX86_
       // cannot distinguish this case from arrays or native-endian byte array views.
       locations->AddRegisterTemps(2);
     }
+    // Only set the `out` register if it's needed. In the void case we can still use RAX in the
+    // same manner as it is marked as a temp register.
+    if (is_void) {
+      locations->AddTemp(Location::RegisterLocation(RAX));
+    } else {
+      // Use the same register for both the new value and output to take advantage of XADD.
+      // It should be RAX, because the byte-swapping path of GenerateVarHandleGetAndAdd falls
+      // back to GenerateVarHandleGetAndOp that expects out in RAX.
+      locations->SetOut(Location::RegisterLocation(RAX));
+    }
   }
 }
 
@@ -4829,6 +5052,10 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke,
   Location out = locations->Out();
   uint32_t temp_count = locations->GetTempCount();
 
+  DataType::Type return_type = invoke->GetType();
+  const bool is_void = return_type == DataType::Type::kVoid;
+  DCHECK_IMPLIES(!is_void, return_type == type);
+
   if (DataType::IsFloatingPointType(type)) {
     if (byte_swap) {
       // This code should never be executed: it is the case of a byte array view (since it requires
@@ -4891,7 +5118,9 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke,
     if (byte_swap) {
       codegen->GetInstructionCodegen()->Bswap(rax_loc, bswap_type);
     }
-    __ movd(out.AsFpuRegister<XmmRegister>(), CpuRegister(RAX), is64bit);
+    if (!is_void) {
+      __ movd(out.AsFpuRegister<XmmRegister>(), CpuRegister(RAX), is64bit);
+    }
   } else {
     if (byte_swap) {
       // We cannot use XADD since we need to byte-swap the old value when reading it from memory,
@@ -4899,7 +5128,12 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke,
       // implementation that is also used for bitwise operations.
       // Move value from RAX to a temporary register, as RAX may get clobbered by repeated CMPXCHG.
       DCHECK_EQ(GetExpectedVarHandleCoordinatesCount(invoke), 2u);
-      Location temp = locations->GetTemp(temp_count - 2);
+      // In the void case, we have an extra temp register, which is used to signal the register
+      // allocator that we are clobering RAX.
+      const uint32_t extra_temp = is_void ? 1u : 0u;
+      DCHECK_IMPLIES(is_void,
+                     locations->GetTemp(temp_count - 1u).Equals(Location::RegisterLocation(RAX)));
+      Location temp = locations->GetTemp(temp_count - extra_temp - 2u);
       codegen->Move(temp, value);
       GenerateVarHandleGetAndOp(
           invoke, codegen, temp, type, field_addr, GetAndUpdateOp::kAdd, byte_swap);
@@ -4908,24 +5142,32 @@ static void GenerateVarHandleGetAndAdd(HInvoke* invoke,
       // the old value to the field. Output register is the same as the one holding new value. Do
       // sign extend / zero extend as needed.
       CpuRegister valreg = value.AsRegister<CpuRegister>();
-      DCHECK_EQ(valreg, out.AsRegister<CpuRegister>());
+      DCHECK_IMPLIES(!is_void, valreg == out.AsRegister<CpuRegister>());
       switch (type) {
         case DataType::Type::kBool:
         case DataType::Type::kUint8:
           __ LockXaddb(field_addr, valreg);
-          __ movzxb(valreg, valreg);
+          if (!is_void) {
+            __ movzxb(valreg, valreg);
+          }
           break;
         case DataType::Type::kInt8:
           __ LockXaddb(field_addr, valreg);
-          __ movsxb(valreg, valreg);
+          if (!is_void) {
+            __ movsxb(valreg, valreg);
+          }
           break;
         case DataType::Type::kUint16:
           __ LockXaddw(field_addr, valreg);
-          __ movzxw(valreg, valreg);
+          if (!is_void) {
+            __ movzxw(valreg, valreg);
+          }
           break;
         case DataType::Type::kInt16:
           __ LockXaddw(field_addr, valreg);
-          __ movsxw(valreg, valreg);
+          if (!is_void) {
+            __ movsxw(valreg, valreg);
+          }
           break;
         case DataType::Type::kInt32:
         case DataType::Type::kUint32:
@@ -4954,9 +5196,10 @@ static void GenerateVarHandleGetAndUpdate(HInvoke* invoke,
   X86_64Assembler* assembler = codegen->GetAssembler();
   LocationSummary* locations = invoke->GetLocations();
 
+  // Get the type from the shorty as the invokes may not return a value.
   uint32_t number_of_arguments = invoke->GetNumberOfArguments();
   Location value = locations->InAt(number_of_arguments - 1);
-  DataType::Type type = invoke->GetType();
+  DataType::Type type = GetDataTypeFromShorty(invoke, number_of_arguments - 1);
 
   VarHandleSlowPathX86_64* slow_path = nullptr;
   VarHandleTarget target = GetVarHandleTarget(invoke);
@@ -5214,7 +5457,7 @@ void VarHandleSlowPathX86_64::EmitByteArrayViewCode(CodeGeneratorX86_64* codegen
   CpuRegister varhandle = locations->InAt(0).AsRegister<CpuRegister>();
   CpuRegister object = locations->InAt(1).AsRegister<CpuRegister>();
   CpuRegister index = locations->InAt(2).AsRegister<CpuRegister>();
-  CpuRegister temp = locations->GetTemp(locations->GetTempCount() - 1).AsRegister<CpuRegister>();
+  CpuRegister temp = locations->GetTemp(locations->GetTempCount() - 1u).AsRegister<CpuRegister>();
 
   MemberOffset class_offset = mirror::Object::ClassOffset();
   MemberOffset array_length_offset = mirror::Array::LengthOffset();
diff --git a/compiler/optimizing/jit_patches_arm64.cc b/compiler/optimizing/jit_patches_arm64.cc
index 76ba182acb..193e913945 100644
--- a/compiler/optimizing/jit_patches_arm64.cc
+++ b/compiler/optimizing/jit_patches_arm64.cc
@@ -67,6 +67,12 @@ void JitPatchesARM64::EmitJitRootPatches(
     uint64_t index_in_table = code_generation_data.GetJitClassRootIndex(type_reference);
     PatchJitRootUse(code, roots_data, table_entry_literal, index_in_table);
   }
+  for (const auto& entry : jit_method_type_patches_) {
+    const ProtoReference& proto_reference = entry.first;
+    vixl::aarch64::Literal<uint32_t>* table_entry_literal = entry.second;
+    uint64_t index_in_table = code_generation_data.GetJitMethodTypeRootIndex(proto_reference);
+    PatchJitRootUse(code, roots_data, table_entry_literal, index_in_table);
+  }
 }
 
 vixl::aarch64::Literal<uint32_t>* JitPatchesARM64::DeduplicateBootImageAddressLiteral(
@@ -100,5 +106,18 @@ vixl::aarch64::Literal<uint32_t>* JitPatchesARM64::DeduplicateJitClassLiteral(
       });
 }
 
+vixl::aarch64::Literal<uint32_t>* JitPatchesARM64::DeduplicateJitMethodTypeLiteral(
+    const DexFile& dex_file,
+    dex::ProtoIndex proto_index,
+    Handle<mirror::MethodType> handle,
+    CodeGenerationData* code_generation_data) {
+  code_generation_data->ReserveJitMethodTypeRoot(ProtoReference(&dex_file, proto_index), handle);
+  return jit_method_type_patches_.GetOrCreate(
+      ProtoReference(&dex_file, proto_index),
+      [this]() {
+        return GetVIXLAssembler()->CreateLiteralDestroyedWithPool<uint32_t>(/* value= */ 0u);
+      });
+}
+
 }  // namespace arm64
 }  // namespace art
diff --git a/compiler/optimizing/jit_patches_arm64.h b/compiler/optimizing/jit_patches_arm64.h
index f5d92804ac..e13060210a 100644
--- a/compiler/optimizing/jit_patches_arm64.h
+++ b/compiler/optimizing/jit_patches_arm64.h
@@ -20,10 +20,12 @@
 #include "base/arena_allocator.h"
 #include "base/arena_containers.h"
 #include "dex/dex_file.h"
+#include "dex/proto_reference.h"
 #include "dex/string_reference.h"
 #include "dex/type_reference.h"
 #include "handle.h"
 #include "mirror/class.h"
+#include "mirror/method_type.h"
 #include "mirror/string.h"
 #include "utils/arm64/assembler_arm64.h"
 
@@ -56,7 +58,9 @@ class JitPatchesARM64 {
       jit_string_patches_(StringReferenceValueComparator(),
                           allocator->Adapter(kArenaAllocCodeGenerator)),
       jit_class_patches_(TypeReferenceValueComparator(),
-                         allocator->Adapter(kArenaAllocCodeGenerator)) {
+                         allocator->Adapter(kArenaAllocCodeGenerator)),
+      jit_method_type_patches_(ProtoReferenceValueComparator(),
+                               allocator->Adapter(kArenaAllocCodeGenerator)) {
   }
 
   using Uint64ToLiteralMap = ArenaSafeMap<uint64_t, vixl::aarch64::Literal<uint64_t>*>;
@@ -67,6 +71,9 @@ class JitPatchesARM64 {
   using TypeToLiteralMap = ArenaSafeMap<TypeReference,
                                         vixl::aarch64::Literal<uint32_t>*,
                                         TypeReferenceValueComparator>;
+  using ProtoToLiteralMap = ArenaSafeMap<ProtoReference,
+                                         vixl::aarch64::Literal<uint32_t>*,
+                                         ProtoReferenceValueComparator>;
 
   vixl::aarch64::Literal<uint32_t>* DeduplicateUint32Literal(uint32_t value);
   vixl::aarch64::Literal<uint64_t>* DeduplicateUint64Literal(uint64_t value);
@@ -81,6 +88,11 @@ class JitPatchesARM64 {
       dex::TypeIndex type_index,
       Handle<mirror::Class> handle,
       CodeGenerationData* code_generation_data);
+  vixl::aarch64::Literal<uint32_t>* DeduplicateJitMethodTypeLiteral(
+      const DexFile& dex_file,
+      dex::ProtoIndex proto_index,
+      Handle<mirror::MethodType> handle,
+      CodeGenerationData* code_generation_data);
 
   void EmitJitRootPatches(uint8_t* code,
                           const uint8_t* roots_data,
@@ -99,6 +111,8 @@ class JitPatchesARM64 {
   StringToLiteralMap jit_string_patches_;
   // Patches for class literals in JIT compiled code.
   TypeToLiteralMap jit_class_patches_;
+  // Patches for MethodType literals in JIT compiled code.
+  ProtoToLiteralMap jit_method_type_patches_;
 };
 
 }  // namespace arm64
diff --git a/compiler/optimizing/load_store_analysis_test.cc b/compiler/optimizing/load_store_analysis_test.cc
index b6a7cd9c76..f15900fc3b 100644
--- a/compiler/optimizing/load_store_analysis_test.cc
+++ b/compiler/optimizing/load_store_analysis_test.cc
@@ -226,6 +226,9 @@ TEST_F(LoadStoreAnalysisTest, ArrayIndexAliasingTest) {
 }
 
 TEST_F(LoadStoreAnalysisTest, ArrayAliasingTest) {
+  constexpr size_t vlen1 = kDefaultTestVectorSizeInBytes;
+  constexpr size_t vlen2 = vlen1 / 2;
+
   HBasicBlock* main = InitEntryMainExitGraphWithReturnVoid();
 
   HInstruction* array = MakeParam(DataType::Type::kReference);
@@ -242,26 +245,32 @@ TEST_F(LoadStoreAnalysisTest, ArrayAliasingTest) {
   HVecOperation* v1 = new (GetAllocator()) HVecReplicateScalar(GetAllocator(),
                                                                c1,
                                                                DataType::Type::kInt32,
-                                                               4,
+                                                               vlen1,
                                                                kNoDexPc);
   AddOrInsertInstruction(main, v1);
   HVecOperation* v2 = new (GetAllocator()) HVecReplicateScalar(GetAllocator(),
                                                                c1,
                                                                DataType::Type::kInt32,
-                                                               2,
+                                                               vlen2,
                                                                kNoDexPc);
   AddOrInsertInstruction(main, v2);
   HInstruction* i_add6 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c6);
   HInstruction* i_add8 = MakeBinOp<HAdd>(main, DataType::Type::kInt32, index, c8);
 
-  HInstruction* vstore_0 = MakeVecStore(main, array, c0, v1, DataType::Type::kInt32);
-  HInstruction* vstore_1 = MakeVecStore(main, array, c1, v1, DataType::Type::kInt32);
-  HInstruction* vstore_8 = MakeVecStore(main, array, c8, v1, DataType::Type::kInt32);
-  HInstruction* vstore_i = MakeVecStore(main, array, index, v1, DataType::Type::kInt32);
-  HInstruction* vstore_i_add6 = MakeVecStore(main, array, i_add6, v1, DataType::Type::kInt32);
-  HInstruction* vstore_i_add8 = MakeVecStore(main, array, i_add8, v1, DataType::Type::kInt32);
+  HInstruction* vstore_0 =
+      MakeVecStore(main, array, c0, v1, DataType::Type::kInt32, vlen1);
+  HInstruction* vstore_1 =
+      MakeVecStore(main, array, c1, v1, DataType::Type::kInt32, vlen1);
+  HInstruction* vstore_8 =
+      MakeVecStore(main, array, c8, v1, DataType::Type::kInt32, vlen1);
+  HInstruction* vstore_i =
+      MakeVecStore(main, array, index, v1, DataType::Type::kInt32, vlen1);
+  HInstruction* vstore_i_add6 =
+      MakeVecStore(main, array, i_add6, v1, DataType::Type::kInt32, vlen1);
+  HInstruction* vstore_i_add8 =
+      MakeVecStore(main, array, i_add8, v1, DataType::Type::kInt32, vlen1);
   HInstruction* vstore_i_add6_vlen2 =
-      MakeVecStore(main, array, i_add6, v2, DataType::Type::kInt32, /*vector_lengt=*/ 2);
+      MakeVecStore(main, array, i_add6, v2, DataType::Type::kInt32, vlen2);
 
   graph_->BuildDominatorTree();
   ScopedArenaAllocator allocator(graph_->GetArenaStack());
diff --git a/compiler/optimizing/loop_optimization.cc b/compiler/optimizing/loop_optimization.cc
index 215986910b..2f1aea68aa 100644
--- a/compiler/optimizing/loop_optimization.cc
+++ b/compiler/optimizing/loop_optimization.cc
@@ -875,13 +875,6 @@ static HBasicBlock* GetInnerLoopFiniteSingleExit(HLoopInformation* loop_info) {
   return exit;
 }
 
-// Determines whether predicated loop vectorization should be tried for ALL loops.
-#ifdef ART_FORCE_TRY_PREDICATED_SIMD
-  static constexpr bool kForceTryPredicatedSIMD = true;
-#else
-  static constexpr bool kForceTryPredicatedSIMD = false;
-#endif
-
 bool HLoopOptimization::TryOptimizeInnerLoopFinite(LoopNode* node) {
   HBasicBlock* header = node->loop_info->GetHeader();
   HBasicBlock* preheader = node->loop_info->GetPreHeader();
@@ -2049,7 +2042,6 @@ bool HLoopOptimization::TrySetVectorType(DataType::Type type, uint64_t* restrict
     case InstructionSet::kArm64:
       if (IsInPredicatedVectorizationMode()) {
         // SVE vectorization.
-        CHECK(features->AsArm64InstructionSetFeatures()->HasSVE());
         size_t vector_length = simd_register_size_ / DataType::Size(type);
         DCHECK_EQ(simd_register_size_ % DataType::Size(type), 0u);
         switch (type) {
@@ -2396,6 +2388,13 @@ HInstruction* HLoopOptimization::ReduceAndExtractIfNeeded(HInstruction* instruct
   }                                                            \
   break;
 
+// Some instructions in the scalar loop body can only occur in loops with control flow; for such
+// loops we don't support clean ups loop (generated via kSequential); see TryVectorizePredicated.
+#define GENERATE_PRED_VEC(x)                              \
+  DCHECK_EQ(synthesis_mode_, LoopSynthesisMode::kVector); \
+  vector = (x);                                           \
+  break;
+
 HInstruction* HLoopOptimization::GenerateVecOp(HInstruction* org,
                                                HInstruction* opa,
                                                HInstruction* opb,
@@ -2469,13 +2468,46 @@ HInstruction* HLoopOptimization::GenerateVecOp(HInstruction* org,
       GENERATE_VEC(
         new (global_allocator_) HVecAbs(global_allocator_, opa, type, vector_length_, dex_pc),
         new (global_allocator_) HAbs(org_type, opa, dex_pc));
-    case HInstruction::kEqual: {
-        // Special case.
-        DCHECK_EQ(synthesis_mode_, LoopSynthesisMode::kVector);
-        vector = new (global_allocator_)
-            HVecCondition(global_allocator_, opa, opb, type, vector_length_, dex_pc);
-      }
-      break;
+    case HInstruction::kEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kNotEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecNotEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kLessThan:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecLessThan(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kLessThanOrEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecLessThanOrEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kGreaterThan:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecGreaterThan(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kGreaterThanOrEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecGreaterThanOrEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kBelow:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecBelow(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kBelowOrEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecBelowOrEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kAbove:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecAbove(global_allocator_, opa, opb, type, vector_length_, dex_pc));
+    case HInstruction::kAboveOrEqual:
+      GENERATE_PRED_VEC(
+        new (global_allocator_)
+          HVecAboveOrEqual(global_allocator_, opa, opb, type, vector_length_, dex_pc));
     default:
       break;
   }  // switch
@@ -2733,8 +2765,7 @@ bool HLoopOptimization::VectorizeIfCondition(LoopNode* node,
     return false;
   }
 
-  if (!if_input->IsEqual()) {
-    // TODO: Support other condition types.
+  if (!if_input->IsCondition()) {
     return false;
   }
 
diff --git a/compiler/optimizing/loop_optimization.h b/compiler/optimizing/loop_optimization.h
index 546d42b4fa..eaeb313dd5 100644
--- a/compiler/optimizing/loop_optimization.h
+++ b/compiler/optimizing/loop_optimization.h
@@ -31,6 +31,13 @@ namespace art HIDDEN {
 class CompilerOptions;
 class ArchNoOptsLoopHelper;
 
+// Determines whether predicated loop vectorization should be tried for ALL loops.
+#ifdef ART_FORCE_TRY_PREDICATED_SIMD
+  static constexpr bool kForceTryPredicatedSIMD = true;
+#else
+  static constexpr bool kForceTryPredicatedSIMD = false;
+#endif
+
 /**
  * Loop optimizations. Builds a loop hierarchy and applies optimizations to
  * the detected nested loops, such as removal of dead induction and empty loops
@@ -572,6 +579,7 @@ class HLoopOptimization : public HOptimization {
   ArchNoOptsLoopHelper* arch_loop_helper_;
 
   friend class LoopOptimizationTest;
+  friend class PredicatedSimdLoopOptimizationTest;
 
   DISALLOW_COPY_AND_ASSIGN(HLoopOptimization);
 };
diff --git a/compiler/optimizing/loop_optimization_test.cc b/compiler/optimizing/loop_optimization_test.cc
index 81867beb4b..c60b66b6d7 100644
--- a/compiler/optimizing/loop_optimization_test.cc
+++ b/compiler/optimizing/loop_optimization_test.cc
@@ -14,29 +14,29 @@
  * limitations under the License.
  */
 
+#include "android-base/logging.h"
 #include "base/macros.h"
 #include "code_generator.h"
 #include "driver/compiler_options.h"
 #include "loop_optimization.h"
+#include "optimizing/data_type.h"
+#include "optimizing/nodes.h"
 #include "optimizing_unit_test.h"
 
 namespace art HIDDEN {
 
-/**
- * Fixture class for the loop optimization tests. These unit tests focus
- * constructing the loop hierarchy. Actual optimizations are tested
- * through the checker tests.
- */
-class LoopOptimizationTest : public OptimizingUnitTest {
+// Base class for loop optimization tests.
+class LoopOptimizationTestBase : public OptimizingUnitTest {
  protected:
   void SetUp() override {
     OptimizingUnitTest::SetUp();
 
-    graph_ = CreateGraph();
     BuildGraph();
     iva_  = new (GetAllocator()) HInductionVarAnalysis(graph_);
-    compiler_options_ = CommonCompilerTest::CreateCompilerOptions(kRuntimeISA, "default");
-    DCHECK(compiler_options_ != nullptr);
+    if (compiler_options_ == nullptr) {
+      compiler_options_ = CommonCompilerTest::CreateCompilerOptions(kRuntimeISA, "default");
+      DCHECK(compiler_options_ != nullptr);
+    }
     codegen_ = CodeGenerator::Create(graph_, *compiler_options_);
     DCHECK(codegen_.get() != nullptr);
     loop_opt_ = new (GetAllocator()) HLoopOptimization(
@@ -51,24 +51,52 @@ class LoopOptimizationTest : public OptimizingUnitTest {
     OptimizingUnitTest::TearDown();
   }
 
+  virtual void BuildGraph() = 0;
+
+  // Run loop optimization and optionally check the graph.
+  void PerformAnalysis(bool run_checker) {
+    graph_->BuildDominatorTree();
+
+    // Check the graph is valid before loop optimization.
+    std::ostringstream oss;
+    if (run_checker) {
+      ASSERT_TRUE(CheckGraph(oss)) << oss.str();
+    }
+
+    iva_->Run();
+    loop_opt_->Run();
+
+    // Check the graph is valid after loop optimization.
+    if (run_checker) {
+      ASSERT_TRUE(CheckGraph(oss)) << oss.str();
+    }
+  }
+
+  // General building fields.
+  std::unique_ptr<CompilerOptions> compiler_options_;
+  std::unique_ptr<CodeGenerator> codegen_;
+  HInductionVarAnalysis* iva_;
+  HLoopOptimization* loop_opt_;
+
+  HBasicBlock* return_block_;
+
+  HInstruction* parameter_;
+};
+
+/**
+ * Fixture class for the loop optimization tests. These unit tests mostly focus
+ * on constructing the loop hierarchy. Checker tests are also used to test
+ * specific optimizations.
+ */
+class LoopOptimizationTest : public LoopOptimizationTestBase {
+ protected:
   virtual ~LoopOptimizationTest() {}
 
   /** Constructs bare minimum graph. */
-  void BuildGraph() {
+  void BuildGraph() override {
+    return_block_ = InitEntryMainExitGraph();
     graph_->SetNumberOfVRegs(1);
-    entry_block_ = new (GetAllocator()) HBasicBlock(graph_);
-    return_block_ = new (GetAllocator()) HBasicBlock(graph_);
-    exit_block_ = new (GetAllocator()) HBasicBlock(graph_);
-    graph_->AddBlock(entry_block_);
-    graph_->AddBlock(return_block_);
-    graph_->AddBlock(exit_block_);
-    graph_->SetEntryBlock(entry_block_);
-    graph_->SetExitBlock(exit_block_);
     parameter_ = MakeParam(DataType::Type::kInt32);
-    MakeReturnVoid(return_block_);
-    MakeExit(exit_block_);
-    entry_block_->AddSuccessor(return_block_);
-    return_block_->AddSuccessor(exit_block_);
   }
 
   /** Adds a loop nest at given position before successor. */
@@ -87,13 +115,6 @@ class LoopOptimizationTest : public OptimizingUnitTest {
     return header;
   }
 
-  /** Performs analysis. */
-  void PerformAnalysis() {
-    graph_->BuildDominatorTree();
-    iva_->Run();
-    loop_opt_->Run();
-  }
-
   /** Constructs string representation of computed loop hierarchy. */
   std::string LoopStructure() {
     return LoopStructureRecurse(loop_opt_->top_loop_);
@@ -109,34 +130,118 @@ class LoopOptimizationTest : public OptimizingUnitTest {
     }
     return s;
   }
+};
 
-  // General building fields.
-  HGraph* graph_;
+#ifdef ART_ENABLE_CODEGEN_arm64
+// Unit tests for predicated vectorization.
+class PredicatedSimdLoopOptimizationTest : public LoopOptimizationTestBase {
+ protected:
+  void SetUp() override {
+    // Predicated SIMD is only supported by SVE on Arm64.
+    compiler_options_ = CommonCompilerTest::CreateCompilerOptions(InstructionSet::kArm64,
+                                                                  "default",
+                                                                  "sve");
+    LoopOptimizationTestBase::SetUp();
+  }
 
-  std::unique_ptr<CompilerOptions> compiler_options_;
-  std::unique_ptr<CodeGenerator> codegen_;
-  HInductionVarAnalysis* iva_;
-  HLoopOptimization* loop_opt_;
+  virtual ~PredicatedSimdLoopOptimizationTest() {}
+
+  // Constructs a graph with a diamond loop which should be vectorizable with predicated
+  // vectorization. This graph includes a basic loop induction (consisting of Phi, Add, If and
+  // SuspendCheck instructions) to control the loop as well as an if comparison (consisting of
+  // Parameter, GreaterThanOrEqual and If instructions) to control the diamond loop.
+  //
+  //                       entry
+  //                         |
+  //                      preheader
+  //                         |
+  //  return <------------ header <----------------+
+  //     |                   |                     |
+  //   exit             diamond_top                |
+  //                       /   \                   |
+  //            diamond_true  diamond_false        |
+  //                       \   /                   |
+  //                     back_edge                 |
+  //                         |                     |
+  //                         +---------------------+
+  void BuildGraph() override {
+    return_block_ = InitEntryMainExitGraphWithReturnVoid();
+    HBasicBlock* back_edge;
+    std::tie(std::ignore, header_, back_edge) = CreateWhileLoop(return_block_);
+    std::tie(diamond_top_, diamond_true_, std::ignore) = CreateDiamondPattern(back_edge);
 
-  HBasicBlock* entry_block_;
-  HBasicBlock* return_block_;
-  HBasicBlock* exit_block_;
+    parameter_ = MakeParam(DataType::Type::kInt32);
+    std::tie(phi_, std::ignore) = MakeLinearLoopVar(header_, back_edge, 0, 1);
+    MakeSuspendCheck(header_);
+    HInstruction* trip = MakeCondition(header_,
+                                       kCondGE,
+                                       phi_,
+                                       graph_->GetIntConstant(kArm64DefaultSVEVectorLength));
+    MakeIf(header_, trip);
+    diamond_hif_ = MakeIf(diamond_top_, parameter_);
+  }
 
-  HInstruction* parameter_;
+  // Add an ArraySet to the loop which will be vectorized, thus setting the type of vector
+  // instructions in the graph to the given vector_type. This needs to be called to ensure the loop
+  // is not simplified by SimplifyInduction or SimplifyBlocks before vectorization.
+  void AddArraySetToLoop(DataType::Type vector_type) {
+    // Ensure the data type is a java type so it can be stored in a TypeField. The actual type does
+    // not matter as long as the size is the same so it can still be vectorized.
+    DataType::Type new_type = DataType::SignedIntegralTypeFromSize(DataType::Size(vector_type));
+
+    // Add an array set to prevent the loop from being optimized away before vectorization.
+    // Note: This uses an integer parameter and not an array reference to avoid the difficulties in
+    // allocating an array. The instruction is still treated as a valid ArraySet by loop
+    // optimization.
+    diamond_true_->AddInstruction(new (GetAllocator()) HArraySet(parameter_,
+                                                                 phi_,
+                                                                 graph_->GetIntConstant(1),
+                                                                 new_type,
+                                                                 /* dex_pc= */ 0));
+  }
+
+  // Replace the input of diamond_hif_ with a new condition of the given types.
+  void ReplaceIfCondition(DataType::Type l_type,
+                          DataType::Type r_type,
+                          HBasicBlock* condition_block,
+                          IfCondition cond) {
+    AddArraySetToLoop(l_type);
+    HInstruction* l_param = MakeParam(l_type);
+    HInstruction* r_param = MakeParam(r_type);
+    HCondition* condition = MakeCondition(condition_block, cond, l_param, r_param);
+    diamond_hif_->ReplaceInput(condition, 0);
+  }
+
+  // Is loop optimization able to vectorize predicated code?
+  bool IsPredicatedVectorizationSupported() {
+    // Mirror the check guarding TryVectorizePredicated in TryOptimizeInnerLoopFinite.
+    return kForceTryPredicatedSIMD && loop_opt_->IsInPredicatedVectorizationMode();
+  }
+
+  HBasicBlock* header_;
+  HBasicBlock* diamond_top_;
+  HBasicBlock* diamond_true_;
+
+  HPhi* phi_;
+  HIf* diamond_hif_;
 };
 
+#endif  // ART_ENABLE_CODEGEN_arm64
+
 //
 // The actual tests.
 //
 
+// Loop structure tests can't run the graph checker because they don't create valid graphs.
+
 TEST_F(LoopOptimizationTest, NoLoops) {
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("", LoopStructure());
 }
 
 TEST_F(LoopOptimizationTest, SingleLoop) {
   AddLoop(entry_block_, return_block_);
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("[]", LoopStructure());
 }
 
@@ -147,7 +252,7 @@ TEST_F(LoopOptimizationTest, LoopNest10) {
     s = AddLoop(b, s);
     b = s->GetSuccessors()[0];
   }
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("[[[[[[[[[[]]]]]]]]]]", LoopStructure());
 }
 
@@ -158,7 +263,7 @@ TEST_F(LoopOptimizationTest, LoopSequence10) {
     b = AddLoop(b, s);
     s = b->GetSuccessors()[1];
   }
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("[][][][][][][][][][]", LoopStructure());
 }
 
@@ -175,7 +280,7 @@ TEST_F(LoopOptimizationTest, LoopSequenceOfNests) {
       bi = si->GetSuccessors()[0];
     }
   }
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("[]"
             "[[]]"
             "[[[]]]"
@@ -202,7 +307,7 @@ TEST_F(LoopOptimizationTest, LoopNestWithSequence) {
     b = AddLoop(b, s);
     s = b->GetSuccessors()[1];
   }
-  PerformAnalysis();
+  PerformAnalysis(/*run_checker=*/ false);
   EXPECT_EQ("[[[[[[[[[[][][][][][][][][][]]]]]]]]]]", LoopStructure());
 }
 
@@ -326,4 +431,40 @@ TEST_F(LoopOptimizationTest, SimplifyLoopSinglePreheader) {
   EXPECT_EQ(header_phi->InputAt(1), body_add);
 }
 
+#ifdef ART_ENABLE_CODEGEN_arm64
+#define FOR_EACH_CONDITION_INSTRUCTION(M, CondType) \
+  M(EQ, CondType)                                   \
+  M(NE, CondType)                                   \
+  M(LT, CondType)                                   \
+  M(LE, CondType)                                   \
+  M(GT, CondType)                                   \
+  M(GE, CondType)                                   \
+  M(B, CondType)                                    \
+  M(BE, CondType)                                   \
+  M(A, CondType)                                    \
+  M(AE, CondType)
+
+// Define tests ensuring that all types of conditions can be handled in predicated vectorization
+// for diamond loops.
+#define DEFINE_CONDITION_TESTS(Name, CondType)                                                  \
+TEST_F(PredicatedSimdLoopOptimizationTest, VectorizeCondition##Name##CondType) {                \
+  if (!IsPredicatedVectorizationSupported()) {                                                  \
+    GTEST_SKIP() << "Predicated SIMD is not enabled.";                                          \
+  }                                                                                             \
+  ReplaceIfCondition(DataType::Type::k##CondType,                                               \
+                     DataType::Type::k##CondType,                                               \
+                     diamond_top_,                                                              \
+                     kCond##Name);                                                              \
+  PerformAnalysis(/*run_checker=*/ true);                                                       \
+  EXPECT_TRUE(graph_->HasPredicatedSIMD());                                                     \
+}
+FOR_EACH_CONDITION_INSTRUCTION(DEFINE_CONDITION_TESTS, Uint8)
+FOR_EACH_CONDITION_INSTRUCTION(DEFINE_CONDITION_TESTS, Int8)
+FOR_EACH_CONDITION_INSTRUCTION(DEFINE_CONDITION_TESTS, Uint16)
+FOR_EACH_CONDITION_INSTRUCTION(DEFINE_CONDITION_TESTS, Int16)
+FOR_EACH_CONDITION_INSTRUCTION(DEFINE_CONDITION_TESTS, Int32)
+#undef DEFINE_CONDITION_TESTS
+#undef FOR_EACH_CONDITION_INSTRUCTION
+#endif  // ART_ENABLE_CODEGEN_arm64
+
 }  // namespace art
diff --git a/compiler/optimizing/nodes.cc b/compiler/optimizing/nodes.cc
index 32ae89eeea..fc7d0a52ab 100644
--- a/compiler/optimizing/nodes.cc
+++ b/compiler/optimizing/nodes.cc
@@ -51,13 +51,6 @@ namespace art HIDDEN {
 // double).
 static constexpr bool kEnableFloatingPointStaticEvaluation = (FLT_EVAL_METHOD == 0);
 
-ReferenceTypeInfo::TypeHandle HandleCache::CreateRootHandle(VariableSizedHandleScope* handles,
-                                                            ClassRoot class_root) {
-  // Mutator lock is required for NewHandle and GetClassRoot().
-  ScopedObjectAccess soa(Thread::Current());
-  return handles->NewHandle(GetClassRoot(class_root));
-}
-
 void HGraph::AddBlock(HBasicBlock* block) {
   block->SetBlockId(blocks_.size());
   blocks_.push_back(block);
@@ -691,6 +684,26 @@ void HLoopInformation::Dump(std::ostream& os) {
   }
 }
 
+template <class InstructionType, typename ValueType>
+InstructionType* HGraph::CreateConstant(ValueType value,
+                                        ArenaSafeMap<ValueType, InstructionType*>* cache) {
+  // Try to find an existing constant of the given value.
+  InstructionType* constant = nullptr;
+  auto cached_constant = cache->find(value);
+  if (cached_constant != cache->end()) {
+    constant = cached_constant->second;
+  }
+
+  // If not found or previously deleted, create and cache a new instruction.
+  // Don't bother reviving a previously deleted instruction, for simplicity.
+  if (constant == nullptr || constant->GetBlock() == nullptr) {
+    constant = new (allocator_) InstructionType(value);
+    cache->Overwrite(value, constant);
+    InsertConstant(constant);
+  }
+  return constant;
+}
+
 void HGraph::InsertConstant(HConstant* constant) {
   // New constants are inserted before the SuspendCheck at the bottom of the
   // entry block. Note that this method can be called from the graph builder and
@@ -714,12 +727,12 @@ void HGraph::InsertConstant(HConstant* constant) {
   }
 }
 
-HNullConstant* HGraph::GetNullConstant(uint32_t dex_pc) {
+HNullConstant* HGraph::GetNullConstant() {
   // For simplicity, don't bother reviving the cached null constant if it is
   // not null and not in a block. Otherwise, we need to clear the instruction
   // id and/or any invariants the graph is assuming when adding new instructions.
   if ((cached_null_constant_ == nullptr) || (cached_null_constant_->GetBlock() == nullptr)) {
-    cached_null_constant_ = new (allocator_) HNullConstant(dex_pc);
+    cached_null_constant_ = new (allocator_) HNullConstant();
     cached_null_constant_->SetReferenceTypeInfo(GetInexactObjectRti());
     InsertConstant(cached_null_constant_);
   }
@@ -730,6 +743,22 @@ HNullConstant* HGraph::GetNullConstant(uint32_t dex_pc) {
   return cached_null_constant_;
 }
 
+HIntConstant* HGraph::GetIntConstant(int32_t value) {
+  return CreateConstant(value, &cached_int_constants_);
+}
+
+HLongConstant* HGraph::GetLongConstant(int64_t value) {
+  return CreateConstant(value, &cached_long_constants_);
+}
+
+HFloatConstant* HGraph::GetFloatConstant(float value) {
+  return CreateConstant(bit_cast<int32_t, float>(value), &cached_float_constants_);
+}
+
+HDoubleConstant* HGraph::GetDoubleConstant(double value) {
+  return CreateConstant(bit_cast<int64_t, double>(value), &cached_double_constants_);
+}
+
 HCurrentMethod* HGraph::GetCurrentMethod() {
   // For simplicity, don't bother reviving the cached current method if it is
   // not null and not in a block. Otherwise, we need to clear the instruction
@@ -757,7 +786,7 @@ std::string HGraph::PrettyMethod(bool with_signature) const {
   return dex_file_.PrettyMethod(method_idx_, with_signature);
 }
 
-HConstant* HGraph::GetConstant(DataType::Type type, int64_t value, uint32_t dex_pc) {
+HConstant* HGraph::GetConstant(DataType::Type type, int64_t value) {
   switch (type) {
     case DataType::Type::kBool:
       DCHECK(IsUint<1>(value));
@@ -768,10 +797,10 @@ HConstant* HGraph::GetConstant(DataType::Type type, int64_t value, uint32_t dex_
     case DataType::Type::kInt16:
     case DataType::Type::kInt32:
       DCHECK(IsInt(DataType::Size(type) * kBitsPerByte, value));
-      return GetIntConstant(static_cast<int32_t>(value), dex_pc);
+      return GetIntConstant(static_cast<int32_t>(value));
 
     case DataType::Type::kInt64:
-      return GetLongConstant(value, dex_pc);
+      return GetLongConstant(value);
 
     default:
       LOG(FATAL) << "Unsupported constant type";
@@ -1142,7 +1171,7 @@ void HEnvironment::CopyFrom(ArrayRef<HInstruction* const> locals) {
   }
 }
 
-void HEnvironment::CopyFrom(HEnvironment* env) {
+void HEnvironment::CopyFrom(const HEnvironment* env) {
   for (size_t i = 0; i < env->Size(); i++) {
     HInstruction* instruction = env->GetInstructionAt(i);
     SetRawEnvAt(i, instruction);
@@ -1174,7 +1203,7 @@ void HEnvironment::CopyFromWithLoopPhiAdjustment(HEnvironment* env,
 }
 
 void HEnvironment::RemoveAsUserOfInput(size_t index) const {
-  const HUserRecord<HEnvironment*>& env_use = vregs_[index];
+  const HUserRecord<HEnvironment*>& env_use = GetVRegs()[index];
   HInstruction* user = env_use.GetInstruction();
   auto before_env_use_node = env_use.GetBeforeUseNode();
   user->env_uses_.erase_after(before_env_use_node);
@@ -1182,7 +1211,7 @@ void HEnvironment::RemoveAsUserOfInput(size_t index) const {
 }
 
 void HEnvironment::ReplaceInput(HInstruction* replacement, size_t index) {
-  const HUserRecord<HEnvironment*>& env_use_record = vregs_[index];
+  const HUserRecord<HEnvironment*>& env_use_record = GetVRegs()[index];
   HInstruction* orig_instr = env_use_record.GetInstruction();
 
   DCHECK(orig_instr != replacement);
@@ -1714,19 +1743,19 @@ HConstant* HTypeConversion::TryStaticEvaluation(HInstruction* input) const {
     int32_t value = input->AsIntConstant()->GetValue();
     switch (GetResultType()) {
       case DataType::Type::kInt8:
-        return graph->GetIntConstant(static_cast<int8_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<int8_t>(value));
       case DataType::Type::kUint8:
-        return graph->GetIntConstant(static_cast<uint8_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<uint8_t>(value));
       case DataType::Type::kInt16:
-        return graph->GetIntConstant(static_cast<int16_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<int16_t>(value));
       case DataType::Type::kUint16:
-        return graph->GetIntConstant(static_cast<uint16_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<uint16_t>(value));
       case DataType::Type::kInt64:
-        return graph->GetLongConstant(static_cast<int64_t>(value), GetDexPc());
+        return graph->GetLongConstant(static_cast<int64_t>(value));
       case DataType::Type::kFloat32:
-        return graph->GetFloatConstant(static_cast<float>(value), GetDexPc());
+        return graph->GetFloatConstant(static_cast<float>(value));
       case DataType::Type::kFloat64:
-        return graph->GetDoubleConstant(static_cast<double>(value), GetDexPc());
+        return graph->GetDoubleConstant(static_cast<double>(value));
       default:
         return nullptr;
     }
@@ -1734,19 +1763,19 @@ HConstant* HTypeConversion::TryStaticEvaluation(HInstruction* input) const {
     int64_t value = input->AsLongConstant()->GetValue();
     switch (GetResultType()) {
       case DataType::Type::kInt8:
-        return graph->GetIntConstant(static_cast<int8_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<int8_t>(value));
       case DataType::Type::kUint8:
-        return graph->GetIntConstant(static_cast<uint8_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<uint8_t>(value));
       case DataType::Type::kInt16:
-        return graph->GetIntConstant(static_cast<int16_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<int16_t>(value));
       case DataType::Type::kUint16:
-        return graph->GetIntConstant(static_cast<uint16_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<uint16_t>(value));
       case DataType::Type::kInt32:
-        return graph->GetIntConstant(static_cast<int32_t>(value), GetDexPc());
+        return graph->GetIntConstant(static_cast<int32_t>(value));
       case DataType::Type::kFloat32:
-        return graph->GetFloatConstant(static_cast<float>(value), GetDexPc());
+        return graph->GetFloatConstant(static_cast<float>(value));
       case DataType::Type::kFloat64:
-        return graph->GetDoubleConstant(static_cast<double>(value), GetDexPc());
+        return graph->GetDoubleConstant(static_cast<double>(value));
       default:
         return nullptr;
     }
@@ -1755,22 +1784,22 @@ HConstant* HTypeConversion::TryStaticEvaluation(HInstruction* input) const {
     switch (GetResultType()) {
       case DataType::Type::kInt32:
         if (std::isnan(value))
-          return graph->GetIntConstant(0, GetDexPc());
+          return graph->GetIntConstant(0);
         if (value >= static_cast<float>(kPrimIntMax))
-          return graph->GetIntConstant(kPrimIntMax, GetDexPc());
+          return graph->GetIntConstant(kPrimIntMax);
         if (value <= kPrimIntMin)
-          return graph->GetIntConstant(kPrimIntMin, GetDexPc());
-        return graph->GetIntConstant(static_cast<int32_t>(value), GetDexPc());
+          return graph->GetIntConstant(kPrimIntMin);
+        return graph->GetIntConstant(static_cast<int32_t>(value));
       case DataType::Type::kInt64:
         if (std::isnan(value))
-          return graph->GetLongConstant(0, GetDexPc());
+          return graph->GetLongConstant(0);
         if (value >= static_cast<float>(kPrimLongMax))
-          return graph->GetLongConstant(kPrimLongMax, GetDexPc());
+          return graph->GetLongConstant(kPrimLongMax);
         if (value <= kPrimLongMin)
-          return graph->GetLongConstant(kPrimLongMin, GetDexPc());
-        return graph->GetLongConstant(static_cast<int64_t>(value), GetDexPc());
+          return graph->GetLongConstant(kPrimLongMin);
+        return graph->GetLongConstant(static_cast<int64_t>(value));
       case DataType::Type::kFloat64:
-        return graph->GetDoubleConstant(static_cast<double>(value), GetDexPc());
+        return graph->GetDoubleConstant(static_cast<double>(value));
       default:
         return nullptr;
     }
@@ -1779,22 +1808,22 @@ HConstant* HTypeConversion::TryStaticEvaluation(HInstruction* input) const {
     switch (GetResultType()) {
       case DataType::Type::kInt32:
         if (std::isnan(value))
-          return graph->GetIntConstant(0, GetDexPc());
+          return graph->GetIntConstant(0);
         if (value >= kPrimIntMax)
-          return graph->GetIntConstant(kPrimIntMax, GetDexPc());
+          return graph->GetIntConstant(kPrimIntMax);
         if (value <= kPrimLongMin)
-          return graph->GetIntConstant(kPrimIntMin, GetDexPc());
-        return graph->GetIntConstant(static_cast<int32_t>(value), GetDexPc());
+          return graph->GetIntConstant(kPrimIntMin);
+        return graph->GetIntConstant(static_cast<int32_t>(value));
       case DataType::Type::kInt64:
         if (std::isnan(value))
-          return graph->GetLongConstant(0, GetDexPc());
+          return graph->GetLongConstant(0);
         if (value >= static_cast<double>(kPrimLongMax))
-          return graph->GetLongConstant(kPrimLongMax, GetDexPc());
+          return graph->GetLongConstant(kPrimLongMax);
         if (value <= kPrimLongMin)
-          return graph->GetLongConstant(kPrimLongMin, GetDexPc());
-        return graph->GetLongConstant(static_cast<int64_t>(value), GetDexPc());
+          return graph->GetLongConstant(kPrimLongMin);
+        return graph->GetLongConstant(static_cast<int64_t>(value));
       case DataType::Type::kFloat32:
-        return graph->GetFloatConstant(static_cast<float>(value), GetDexPc());
+        return graph->GetFloatConstant(static_cast<float>(value));
       default:
         return nullptr;
     }
@@ -1883,6 +1912,29 @@ std::ostream& operator<<(std::ostream& os, ComparisonBias rhs) {
   }
 }
 
+HCondition* HCondition::Create(HGraph* graph,
+                               IfCondition cond,
+                               HInstruction* lhs,
+                               HInstruction* rhs,
+                               uint32_t dex_pc) {
+  ArenaAllocator* allocator = graph->GetAllocator();
+  switch (cond) {
+    case kCondEQ: return new (allocator) HEqual(lhs, rhs, dex_pc);
+    case kCondNE: return new (allocator) HNotEqual(lhs, rhs, dex_pc);
+    case kCondLT: return new (allocator) HLessThan(lhs, rhs, dex_pc);
+    case kCondLE: return new (allocator) HLessThanOrEqual(lhs, rhs, dex_pc);
+    case kCondGT: return new (allocator) HGreaterThan(lhs, rhs, dex_pc);
+    case kCondGE: return new (allocator) HGreaterThanOrEqual(lhs, rhs, dex_pc);
+    case kCondB:  return new (allocator) HBelow(lhs, rhs, dex_pc);
+    case kCondBE: return new (allocator) HBelowOrEqual(lhs, rhs, dex_pc);
+    case kCondA:  return new (allocator) HAbove(lhs, rhs, dex_pc);
+    case kCondAE: return new (allocator) HAboveOrEqual(lhs, rhs, dex_pc);
+    default:
+      LOG(FATAL) << "Unexpected condition " << cond;
+      UNREACHABLE();
+  }
+}
+
 bool HCondition::IsBeforeWhenDisregardMoves(HInstruction* instruction) const {
   return this == instruction->GetPreviousDisregardingMoves();
 }
@@ -2424,7 +2476,6 @@ void HBasicBlock::DisconnectAndDelete() {
 
   // (7) Delete from the graph, update reverse post order.
   graph_->DeleteDeadEmptyBlock(this);
-  SetGraph(nullptr);
 }
 
 void HBasicBlock::DisconnectFromSuccessors(const ArenaBitVector* visited) {
@@ -2541,7 +2592,6 @@ void HBasicBlock::MergeWith(HBasicBlock* other) {
 
   // Delete `other` from the graph. The function updates reverse post order.
   graph_->DeleteDeadEmptyBlock(other);
-  other->SetGraph(nullptr);
 }
 
 void HBasicBlock::MergeWithInlined(HBasicBlock* other) {
@@ -2673,7 +2723,6 @@ HInstruction* HGraph::InlineInto(HGraph* outer_graph, HInvoke* invoke) {
       }
     }
   }
-  outer_graph->UpdateMaximumNumberOfOutVRegs(GetMaximumNumberOfOutVRegs());
 
   if (HasBoundsChecks()) {
     outer_graph->SetHasBoundsChecks(true);
@@ -2906,19 +2955,15 @@ HInstruction* HGraph::InlineInto(HGraph* outer_graph, HInvoke* invoke) {
     HInstruction* current = it.Current();
     HInstruction* replacement = nullptr;
     if (current->IsNullConstant()) {
-      replacement = outer_graph->GetNullConstant(current->GetDexPc());
+      replacement = outer_graph->GetNullConstant();
     } else if (current->IsIntConstant()) {
-      replacement = outer_graph->GetIntConstant(
-          current->AsIntConstant()->GetValue(), current->GetDexPc());
+      replacement = outer_graph->GetIntConstant(current->AsIntConstant()->GetValue());
     } else if (current->IsLongConstant()) {
-      replacement = outer_graph->GetLongConstant(
-          current->AsLongConstant()->GetValue(), current->GetDexPc());
+      replacement = outer_graph->GetLongConstant(current->AsLongConstant()->GetValue());
     } else if (current->IsFloatConstant()) {
-      replacement = outer_graph->GetFloatConstant(
-          current->AsFloatConstant()->GetValue(), current->GetDexPc());
+      replacement = outer_graph->GetFloatConstant(current->AsFloatConstant()->GetValue());
     } else if (current->IsDoubleConstant()) {
-      replacement = outer_graph->GetDoubleConstant(
-          current->AsDoubleConstant()->GetValue(), current->GetDexPc());
+      replacement = outer_graph->GetDoubleConstant(current->AsDoubleConstant()->GetValue());
     } else if (current->IsParameterValue()) {
       if (kIsDebugBuild &&
           invoke->IsInvokeStaticOrDirect() &&
@@ -3084,9 +3129,9 @@ HBasicBlock* HGraph::TransformLoopForVectorization(HBasicBlock* header,
   return new_pre_header;
 }
 
-static void CheckAgainstUpperBound(ReferenceTypeInfo rti, ReferenceTypeInfo upper_bound_rti)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
+static void CheckAgainstUpperBound(ReferenceTypeInfo rti, ReferenceTypeInfo upper_bound_rti) {
   if (rti.IsValid()) {
+    ScopedObjectAccess soa(Thread::Current());
     DCHECK(upper_bound_rti.IsSupertypeOf(rti))
         << " upper_bound_rti: " << upper_bound_rti
         << " rti: " << rti;
@@ -3099,7 +3144,6 @@ static void CheckAgainstUpperBound(ReferenceTypeInfo rti, ReferenceTypeInfo uppe
 void HInstruction::SetReferenceTypeInfo(ReferenceTypeInfo rti) {
   if (kIsDebugBuild) {
     DCHECK_EQ(GetType(), DataType::Type::kReference);
-    ScopedObjectAccess soa(Thread::Current());
     DCHECK(rti.IsValid()) << "Invalid RTI for " << DebugName();
     if (IsBoundType()) {
       // Having the test here spares us from making the method virtual just for
@@ -3127,7 +3171,6 @@ bool HBoundType::InstructionDataEquals(const HInstruction* other) const {
 
 void HBoundType::SetUpperBound(const ReferenceTypeInfo& upper_bound, bool can_be_null) {
   if (kIsDebugBuild) {
-    ScopedObjectAccess soa(Thread::Current());
     DCHECK(upper_bound.IsValid());
     DCHECK(!upper_bound_.IsValid()) << "Upper bound should only be set once.";
     CheckAgainstUpperBound(GetReferenceTypeInfo(), upper_bound);
@@ -3136,28 +3179,6 @@ void HBoundType::SetUpperBound(const ReferenceTypeInfo& upper_bound, bool can_be
   SetPackedFlag<kFlagUpperCanBeNull>(can_be_null);
 }
 
-ReferenceTypeInfo ReferenceTypeInfo::Create(TypeHandle type_handle, bool is_exact) {
-  if (kIsDebugBuild) {
-    ScopedObjectAccess soa(Thread::Current());
-    DCHECK(IsValidHandle(type_handle));
-    if (!is_exact) {
-      DCHECK(!type_handle->CannotBeAssignedFromOtherTypes())
-          << "Callers of ReferenceTypeInfo::Create should ensure is_exact is properly computed";
-    }
-  }
-  return ReferenceTypeInfo(type_handle, is_exact);
-}
-
-std::ostream& operator<<(std::ostream& os, const ReferenceTypeInfo& rhs) {
-  ScopedObjectAccess soa(Thread::Current());
-  os << "["
-     << " is_valid=" << rhs.IsValid()
-     << " type=" << (!rhs.IsValid() ? "?" : mirror::Class::PrettyClass(rhs.GetTypeHandle().Get()))
-     << " is_exact=" << rhs.IsExact()
-     << " ]";
-  return os;
-}
-
 bool HInstruction::HasAnyEnvironmentUseBefore(HInstruction* other) {
   // For now, assume that instructions in different blocks may use the
   // environment.
@@ -3240,17 +3261,35 @@ std::ostream& operator<<(std::ostream& os, HInvokeStaticOrDirect::ClinitCheckReq
 }
 
 bool HInvokeStaticOrDirect::CanBeNull() const {
-  if (GetType() != DataType::Type::kReference || IsStringInit()) {
+  if (IsStringInit()) {
     return false;
   }
+  return HInvoke::CanBeNull();
+}
+
+bool HInvoke::CanBeNull() const {
   switch (GetIntrinsic()) {
+    case Intrinsics::kThreadCurrentThread:
+    case Intrinsics::kStringBufferAppend:
+    case Intrinsics::kStringBufferToString:
+    case Intrinsics::kStringBuilderAppendObject:
+    case Intrinsics::kStringBuilderAppendString:
+    case Intrinsics::kStringBuilderAppendCharSequence:
+    case Intrinsics::kStringBuilderAppendCharArray:
+    case Intrinsics::kStringBuilderAppendBoolean:
+    case Intrinsics::kStringBuilderAppendChar:
+    case Intrinsics::kStringBuilderAppendInt:
+    case Intrinsics::kStringBuilderAppendLong:
+    case Intrinsics::kStringBuilderAppendFloat:
+    case Intrinsics::kStringBuilderAppendDouble:
+    case Intrinsics::kStringBuilderToString:
 #define DEFINE_BOXED_CASE(name, unused1, unused2, unused3, unused4) \
-    case Intrinsics::k##name##ValueOf: \
-      return false;
+    case Intrinsics::k##name##ValueOf:
     BOXED_TYPES(DEFINE_BOXED_CASE)
 #undef DEFINE_BOXED_CASE
+      return false;
     default:
-      return true;
+      return GetType() == DataType::Type::kReference;
   }
 }
 
@@ -3340,28 +3379,6 @@ HInstruction* ReplaceInstrOrPhiByClone(HInstruction* instr) {
   return clone;
 }
 
-HCondition* HGraph::CreateCondition(IfCondition cond,
-                                    HInstruction* lhs,
-                                    HInstruction* rhs,
-                                    uint32_t dex_pc) {
-  ArenaAllocator* allocator = GetAllocator();
-  switch (cond) {
-    case kCondEQ: return new (allocator) HEqual(lhs, rhs, dex_pc);
-    case kCondNE: return new (allocator) HNotEqual(lhs, rhs, dex_pc);
-    case kCondLT: return new (allocator) HLessThan(lhs, rhs, dex_pc);
-    case kCondLE: return new (allocator) HLessThanOrEqual(lhs, rhs, dex_pc);
-    case kCondGT: return new (allocator) HGreaterThan(lhs, rhs, dex_pc);
-    case kCondGE: return new (allocator) HGreaterThanOrEqual(lhs, rhs, dex_pc);
-    case kCondB:  return new (allocator) HBelow(lhs, rhs, dex_pc);
-    case kCondBE: return new (allocator) HBelowOrEqual(lhs, rhs, dex_pc);
-    case kCondA:  return new (allocator) HAbove(lhs, rhs, dex_pc);
-    case kCondAE: return new (allocator) HAboveOrEqual(lhs, rhs, dex_pc);
-    default:
-      LOG(FATAL) << "Unexpected condition " << cond;
-      UNREACHABLE();
-  }
-}
-
 std::ostream& operator<<(std::ostream& os, const MoveOperands& rhs) {
   os << "["
      << " source=" << rhs.GetSource()
diff --git a/compiler/optimizing/nodes.h b/compiler/optimizing/nodes.h
index 2477c9fe51..e0913c821c 100644
--- a/compiler/optimizing/nodes.h
+++ b/compiler/optimizing/nodes.h
@@ -45,12 +45,13 @@
 #include "dex/method_reference.h"
 #include "entrypoints/quick/quick_entrypoints_enum.h"
 #include "handle.h"
-#include "handle_scope.h"
+#include "handle_cache.h"
 #include "intrinsics_enum.h"
 #include "locations.h"
 #include "mirror/class.h"
 #include "mirror/method_type.h"
 #include "offsets.h"
+#include "reference_type_info.h"
 
 namespace art HIDDEN {
 
@@ -75,6 +76,7 @@ class HParameterValue;
 class HPhi;
 class HSuspendCheck;
 class HTryBoundary;
+class HVecCondition;
 class FieldInfo;
 class LiveInterval;
 class LocationSummary;
@@ -198,184 +200,6 @@ class HInstructionList : public ValueObject {
   DISALLOW_COPY_AND_ASSIGN(HInstructionList);
 };
 
-class ReferenceTypeInfo : ValueObject {
- public:
-  using TypeHandle = Handle<mirror::Class>;
-
-  static ReferenceTypeInfo Create(TypeHandle type_handle, bool is_exact);
-
-  static ReferenceTypeInfo Create(TypeHandle type_handle) REQUIRES_SHARED(Locks::mutator_lock_) {
-    return Create(type_handle, type_handle->CannotBeAssignedFromOtherTypes());
-  }
-
-  static ReferenceTypeInfo CreateUnchecked(TypeHandle type_handle, bool is_exact) {
-    return ReferenceTypeInfo(type_handle, is_exact);
-  }
-
-  static ReferenceTypeInfo CreateInvalid() { return ReferenceTypeInfo(); }
-
-  static bool IsValidHandle(TypeHandle handle) {
-    return handle.GetReference() != nullptr;
-  }
-
-  bool IsValid() const {
-    return IsValidHandle(type_handle_);
-  }
-
-  bool IsExact() const { return is_exact_; }
-
-  bool IsObjectClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return GetTypeHandle()->IsObjectClass();
-  }
-
-  bool IsStringClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return GetTypeHandle()->IsStringClass();
-  }
-
-  bool IsObjectArray() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return IsArrayClass() && GetTypeHandle()->GetComponentType()->IsObjectClass();
-  }
-
-  bool IsInterface() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return GetTypeHandle()->IsInterface();
-  }
-
-  bool IsArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return GetTypeHandle()->IsArrayClass();
-  }
-
-  bool IsPrimitiveArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return GetTypeHandle()->IsPrimitiveArray();
-  }
-
-  bool IsNonPrimitiveArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    return IsArrayClass() && !GetTypeHandle()->IsPrimitiveArray();
-  }
-
-  bool CanArrayHold(ReferenceTypeInfo rti)  const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    if (!IsExact()) return false;
-    if (!IsArrayClass()) return false;
-    return GetTypeHandle()->GetComponentType()->IsAssignableFrom(rti.GetTypeHandle().Get());
-  }
-
-  bool CanArrayHoldValuesOf(ReferenceTypeInfo rti)  const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    if (!IsExact()) return false;
-    if (!IsArrayClass()) return false;
-    if (!rti.IsArrayClass()) return false;
-    return GetTypeHandle()->GetComponentType()->IsAssignableFrom(
-        rti.GetTypeHandle()->GetComponentType());
-  }
-
-  Handle<mirror::Class> GetTypeHandle() const { return type_handle_; }
-
-  bool IsSupertypeOf(ReferenceTypeInfo rti) const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(IsValid());
-    DCHECK(rti.IsValid());
-    return GetTypeHandle()->IsAssignableFrom(rti.GetTypeHandle().Get());
-  }
-
-  // Returns true if the type information provide the same amount of details.
-  // Note that it does not mean that the instructions have the same actual type
-  // (because the type can be the result of a merge).
-  bool IsEqual(ReferenceTypeInfo rti) const REQUIRES_SHARED(Locks::mutator_lock_) {
-    if (!IsValid() && !rti.IsValid()) {
-      // Invalid types are equal.
-      return true;
-    }
-    if (!IsValid() || !rti.IsValid()) {
-      // One is valid, the other not.
-      return false;
-    }
-    return IsExact() == rti.IsExact()
-        && GetTypeHandle().Get() == rti.GetTypeHandle().Get();
-  }
-
- private:
-  ReferenceTypeInfo() : type_handle_(TypeHandle()), is_exact_(false) {}
-  ReferenceTypeInfo(TypeHandle type_handle, bool is_exact)
-      : type_handle_(type_handle), is_exact_(is_exact) { }
-
-  // The class of the object.
-  TypeHandle type_handle_;
-  // Whether or not the type is exact or a superclass of the actual type.
-  // Whether or not we have any information about this type.
-  bool is_exact_;
-};
-
-std::ostream& operator<<(std::ostream& os, const ReferenceTypeInfo& rhs);
-
-class HandleCache {
- public:
-  explicit HandleCache(VariableSizedHandleScope* handles) : handles_(handles) { }
-
-  VariableSizedHandleScope* GetHandles() { return handles_; }
-
-  template <typename T>
-  MutableHandle<T> NewHandle(T* object) REQUIRES_SHARED(Locks::mutator_lock_) {
-    return handles_->NewHandle(object);
-  }
-
-  template <typename T>
-  MutableHandle<T> NewHandle(ObjPtr<T> object) REQUIRES_SHARED(Locks::mutator_lock_) {
-    return handles_->NewHandle(object);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetObjectClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangObject, &object_class_handle_);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetClassClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangClass, &class_class_handle_);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetMethodHandleClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangInvokeMethodHandleImpl, &method_handle_class_handle_);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetMethodTypeClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangInvokeMethodType, &method_type_class_handle_);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetStringClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangString, &string_class_handle_);
-  }
-
-  ReferenceTypeInfo::TypeHandle GetThrowableClassHandle() {
-    return GetRootHandle(ClassRoot::kJavaLangThrowable, &throwable_class_handle_);
-  }
-
-
- private:
-  inline ReferenceTypeInfo::TypeHandle GetRootHandle(ClassRoot class_root,
-                                                     ReferenceTypeInfo::TypeHandle* cache) {
-    if (UNLIKELY(!ReferenceTypeInfo::IsValidHandle(*cache))) {
-      *cache = CreateRootHandle(handles_, class_root);
-    }
-    return *cache;
-  }
-
-  static ReferenceTypeInfo::TypeHandle CreateRootHandle(VariableSizedHandleScope* handles,
-                                                        ClassRoot class_root);
-
-  VariableSizedHandleScope* handles_;
-
-  ReferenceTypeInfo::TypeHandle object_class_handle_;
-  ReferenceTypeInfo::TypeHandle class_class_handle_;
-  ReferenceTypeInfo::TypeHandle method_handle_class_handle_;
-  ReferenceTypeInfo::TypeHandle method_type_class_handle_;
-  ReferenceTypeInfo::TypeHandle string_class_handle_;
-  ReferenceTypeInfo::TypeHandle throwable_class_handle_;
-};
-
 // Control-flow graph of a method. Contains a list of basic blocks.
 class HGraph : public ArenaObject<kArenaAllocGraph> {
  public:
@@ -398,7 +222,6 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
         linear_order_(allocator->Adapter(kArenaAllocLinearOrder)),
         entry_block_(nullptr),
         exit_block_(nullptr),
-        maximum_number_of_out_vregs_(0),
         number_of_vregs_(0),
         number_of_in_vregs_(0),
         temporaries_vreg_slots_(0),
@@ -550,18 +373,6 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
     current_instruction_id_ = id;
   }
 
-  uint16_t GetMaximumNumberOfOutVRegs() const {
-    return maximum_number_of_out_vregs_;
-  }
-
-  void SetMaximumNumberOfOutVRegs(uint16_t new_value) {
-    maximum_number_of_out_vregs_ = new_value;
-  }
-
-  void UpdateMaximumNumberOfOutVRegs(uint16_t other_value) {
-    maximum_number_of_out_vregs_ = std::max(maximum_number_of_out_vregs_, other_value);
-  }
-
   void UpdateTemporariesVRegSlots(size_t slots) {
     temporaries_vreg_slots_ = std::max(slots, temporaries_vreg_slots_);
   }
@@ -632,25 +443,17 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
   // Returns a constant of the given type and value. If it does not exist
   // already, it is created and inserted into the graph. This method is only for
   // integral types.
-  HConstant* GetConstant(DataType::Type type, int64_t value, uint32_t dex_pc = kNoDexPc);
+  HConstant* GetConstant(DataType::Type type, int64_t value);
 
   // TODO: This is problematic for the consistency of reference type propagation
   // because it can be created anytime after the pass and thus it will be left
   // with an invalid type.
-  HNullConstant* GetNullConstant(uint32_t dex_pc = kNoDexPc);
+  HNullConstant* GetNullConstant();
 
-  HIntConstant* GetIntConstant(int32_t value, uint32_t dex_pc = kNoDexPc) {
-    return CreateConstant(value, &cached_int_constants_, dex_pc);
-  }
-  HLongConstant* GetLongConstant(int64_t value, uint32_t dex_pc = kNoDexPc) {
-    return CreateConstant(value, &cached_long_constants_, dex_pc);
-  }
-  HFloatConstant* GetFloatConstant(float value, uint32_t dex_pc = kNoDexPc) {
-    return CreateConstant(bit_cast<int32_t, float>(value), &cached_float_constants_, dex_pc);
-  }
-  HDoubleConstant* GetDoubleConstant(double value, uint32_t dex_pc = kNoDexPc) {
-    return CreateConstant(bit_cast<int64_t, double>(value), &cached_double_constants_, dex_pc);
-  }
+  HIntConstant* GetIntConstant(int32_t value);
+  HLongConstant* GetLongConstant(int64_t value);
+  HFloatConstant* GetFloatConstant(float value);
+  HDoubleConstant* GetDoubleConstant(double value);
 
   HCurrentMethod* GetCurrentMethod();
 
@@ -733,11 +536,6 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
   void SetProfilingInfo(ProfilingInfo* info) { profiling_info_ = info; }
   ProfilingInfo* GetProfilingInfo() const { return profiling_info_; }
 
-  HCondition* CreateCondition(IfCondition cond,
-                              HInstruction* lhs,
-                              HInstruction* rhs,
-                              uint32_t dex_pc = kNoDexPc);
-
   ReferenceTypeInfo GetInexactObjectRti() {
     return ReferenceTypeInfo::Create(handle_cache_.GetObjectClassHandle(), /* is_exact= */ false);
   }
@@ -755,24 +553,7 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
 
   template <class InstructionType, typename ValueType>
   InstructionType* CreateConstant(ValueType value,
-                                  ArenaSafeMap<ValueType, InstructionType*>* cache,
-                                  uint32_t dex_pc = kNoDexPc) {
-    // Try to find an existing constant of the given value.
-    InstructionType* constant = nullptr;
-    auto cached_constant = cache->find(value);
-    if (cached_constant != cache->end()) {
-      constant = cached_constant->second;
-    }
-
-    // If not found or previously deleted, create and cache a new instruction.
-    // Don't bother reviving a previously deleted instruction, for simplicity.
-    if (constant == nullptr || constant->GetBlock() == nullptr) {
-      constant = new (allocator_) InstructionType(value, dex_pc);
-      cache->Overwrite(value, constant);
-      InsertConstant(constant);
-    }
-    return constant;
-  }
+                                  ArenaSafeMap<ValueType, InstructionType*>* cache);
 
   void InsertConstant(HConstant* instruction);
 
@@ -801,9 +582,6 @@ class HGraph : public ArenaObject<kArenaAllocGraph> {
   HBasicBlock* entry_block_;
   HBasicBlock* exit_block_;
 
-  // The maximum number of virtual registers arguments passed to a HInvoke in this graph.
-  uint16_t maximum_number_of_out_vregs_;
-
   // The number of virtual registers in this method. Contains the parameters.
   uint16_t number_of_vregs_;
 
@@ -1646,8 +1424,17 @@ class HLoopInformationOutwardIterator : public ValueObject {
   M(VecPredSetAll, VecPredSetOperation)                                 \
   M(VecPredWhile, VecPredSetOperation)                                  \
   M(VecPredToBoolean, VecOperation)                                     \
-  M(VecCondition, VecPredSetOperation)                                  \
-  M(VecPredNot, VecPredSetOperation)                                    \
+  M(VecEqual, VecCondition)                                             \
+  M(VecNotEqual, VecCondition)                                          \
+  M(VecLessThan, VecCondition)                                          \
+  M(VecLessThanOrEqual, VecCondition)                                   \
+  M(VecGreaterThan, VecCondition)                                       \
+  M(VecGreaterThanOrEqual, VecCondition)                                \
+  M(VecBelow, VecCondition)                                             \
+  M(VecBelowOrEqual, VecCondition)                                      \
+  M(VecAbove, VecCondition)                                             \
+  M(VecAboveOrEqual, VecCondition)                                      \
+  M(VecPredNot, VecPredSetOperation)
 
 #define FOR_EACH_CONCRETE_INSTRUCTION_COMMON(M)                         \
   FOR_EACH_CONCRETE_INSTRUCTION_SCALAR_COMMON(M)                        \
@@ -1715,7 +1502,8 @@ class HLoopInformationOutwardIterator : public ValueObject {
   M(VecUnaryOperation, VecOperation)                                    \
   M(VecBinaryOperation, VecOperation)                                   \
   M(VecMemoryOperation, VecOperation)                                   \
-  M(VecPredSetOperation, VecOperation)
+  M(VecPredSetOperation, VecOperation)                                  \
+  M(VecCondition, VecPredSetOperation)
 
 #define FOR_EACH_INSTRUCTION(M)                                         \
   FOR_EACH_CONCRETE_INSTRUCTION(M)                                      \
@@ -2074,38 +1862,37 @@ class SideEffects : public ValueObject {
 // A HEnvironment object contains the values of virtual registers at a given location.
 class HEnvironment : public ArenaObject<kArenaAllocEnvironment> {
  public:
-  ALWAYS_INLINE HEnvironment(ArenaAllocator* allocator,
-                             size_t number_of_vregs,
-                             ArtMethod* method,
-                             uint32_t dex_pc,
-                             HInstruction* holder)
-      : vregs_(number_of_vregs, allocator->Adapter(kArenaAllocEnvironmentVRegs)),
-        locations_(allocator->Adapter(kArenaAllocEnvironmentLocations)),
-        parent_(nullptr),
-        method_(method),
-        dex_pc_(dex_pc),
-        holder_(holder) {
-  }
-
-  ALWAYS_INLINE HEnvironment(ArenaAllocator* allocator,
-                             const HEnvironment& to_copy,
-                             HInstruction* holder)
-      : HEnvironment(allocator,
-                     to_copy.Size(),
-                     to_copy.GetMethod(),
-                     to_copy.GetDexPc(),
-                     holder) {}
-
-  void AllocateLocations() {
-    DCHECK(locations_.empty());
-    locations_.resize(vregs_.size());
+  static HEnvironment* Create(ArenaAllocator* allocator,
+                              size_t number_of_vregs,
+                              ArtMethod* method,
+                              uint32_t dex_pc,
+                              HInstruction* holder) {
+    // The storage for vreg records is allocated right after the `HEnvironment` itself.
+    static_assert(IsAligned<alignof(HUserRecord<HEnvironment*>)>(sizeof(HEnvironment)));
+    static_assert(IsAligned<alignof(HUserRecord<HEnvironment*>)>(ArenaAllocator::kAlignment));
+    size_t alloc_size = sizeof(HEnvironment) + number_of_vregs * sizeof(HUserRecord<HEnvironment*>);
+    void* storage = allocator->Alloc(alloc_size, kArenaAllocEnvironment);
+    return new (storage) HEnvironment(number_of_vregs, method, dex_pc, holder);
+  }
+
+  static HEnvironment* Create(ArenaAllocator* allocator,
+                              const HEnvironment& to_copy,
+                              HInstruction* holder) {
+    return Create(allocator, to_copy.Size(), to_copy.GetMethod(), to_copy.GetDexPc(), holder);
+  }
+
+  void AllocateLocations(ArenaAllocator* allocator) {
+    DCHECK(locations_ == nullptr);
+    if (Size() != 0u) {
+      locations_ = allocator->AllocArray<Location>(Size(), kArenaAllocEnvironmentLocations);
+    }
   }
 
   void SetAndCopyParentChain(ArenaAllocator* allocator, HEnvironment* parent) {
     if (parent_ != nullptr) {
       parent_->SetAndCopyParentChain(allocator, parent);
     } else {
-      parent_ = new (allocator) HEnvironment(allocator, *parent, holder_);
+      parent_ = Create(allocator, *parent, holder_);
       parent_->CopyFrom(parent);
       if (parent->GetParent() != nullptr) {
         parent_->SetAndCopyParentChain(allocator, parent->GetParent());
@@ -2114,7 +1901,7 @@ class HEnvironment : public ArenaObject<kArenaAllocEnvironment> {
   }
 
   void CopyFrom(ArrayRef<HInstruction* const> locals);
-  void CopyFrom(HEnvironment* environment);
+  void CopyFrom(const HEnvironment* environment);
 
   // Copy from `env`. If it's a loop phi for `loop_header`, copy the first
   // input to the loop phi instead. This is for inserting instructions that
@@ -2122,11 +1909,11 @@ class HEnvironment : public ArenaObject<kArenaAllocEnvironment> {
   void CopyFromWithLoopPhiAdjustment(HEnvironment* env, HBasicBlock* loop_header);
 
   void SetRawEnvAt(size_t index, HInstruction* instruction) {
-    vregs_[index] = HUserRecord<HEnvironment*>(instruction);
+    GetVRegs()[index] = HUserRecord<HEnvironment*>(instruction);
   }
 
   HInstruction* GetInstructionAt(size_t index) const {
-    return vregs_[index].GetInstruction();
+    return GetVRegs()[index].GetInstruction();
   }
 
   void RemoveAsUserOfInput(size_t index) const;
@@ -2136,15 +1923,19 @@ class HEnvironment : public ArenaObject<kArenaAllocEnvironment> {
   // HInstruction::ReplaceInput.
   void ReplaceInput(HInstruction* replacement, size_t index);
 
-  size_t Size() const { return vregs_.size(); }
+  size_t Size() const { return number_of_vregs_; }
 
   HEnvironment* GetParent() const { return parent_; }
 
   void SetLocationAt(size_t index, Location location) {
+    DCHECK_LT(index, number_of_vregs_);
+    DCHECK(locations_ != nullptr);
     locations_[index] = location;
   }
 
   Location GetLocationAt(size_t index) const {
+    DCHECK_LT(index, number_of_vregs_);
+    DCHECK(locations_ != nullptr);
     return locations_[index];
   }
 
@@ -2183,15 +1974,43 @@ class HEnvironment : public ArenaObject<kArenaAllocEnvironment> {
   }
 
  private:
-  ArenaVector<HUserRecord<HEnvironment*>> vregs_;
-  ArenaVector<Location> locations_;
-  HEnvironment* parent_;
-  ArtMethod* method_;
+  ALWAYS_INLINE HEnvironment(size_t number_of_vregs,
+                             ArtMethod* method,
+                             uint32_t dex_pc,
+                             HInstruction* holder)
+      : number_of_vregs_(dchecked_integral_cast<uint32_t>(number_of_vregs)),
+        dex_pc_(dex_pc),
+        holder_(holder),
+        parent_(nullptr),
+        method_(method),
+        locations_(nullptr) {
+  }
+
+  ArrayRef<HUserRecord<HEnvironment*>> GetVRegs() {
+    auto* vregs = reinterpret_cast<HUserRecord<HEnvironment*>*>(this + 1);
+    return ArrayRef<HUserRecord<HEnvironment*>>(vregs, number_of_vregs_);
+  }
+
+  ArrayRef<const HUserRecord<HEnvironment*>> GetVRegs() const {
+    auto* vregs = reinterpret_cast<const HUserRecord<HEnvironment*>*>(this + 1);
+    return ArrayRef<const HUserRecord<HEnvironment*>>(vregs, number_of_vregs_);
+  }
+
+  const uint32_t number_of_vregs_;
   const uint32_t dex_pc_;
 
   // The instruction that holds this environment.
   HInstruction* const holder_;
 
+  // The parent environment for inlined code.
+  HEnvironment* parent_;
+
+  // The environment's method, if resolved.
+  ArtMethod* method_;
+
+  // Locations assigned by the register allocator.
+  Location* locations_;
+
   friend class HInstruction;
 
   DISALLOW_COPY_AND_ASSIGN(HEnvironment);
@@ -2523,7 +2342,7 @@ class HInstruction : public ArenaObject<kArenaAllocInstruction> {
   void CopyEnvironmentFrom(HEnvironment* environment) {
     DCHECK(environment_ == nullptr);
     ArenaAllocator* allocator = GetBlock()->GetGraph()->GetAllocator();
-    environment_ = new (allocator) HEnvironment(allocator, *environment, this);
+    environment_ = HEnvironment::Create(allocator, *environment, this);
     environment_->CopyFrom(environment);
     if (environment->GetParent() != nullptr) {
       environment_->SetAndCopyParentChain(allocator, environment->GetParent());
@@ -2534,7 +2353,7 @@ class HInstruction : public ArenaObject<kArenaAllocInstruction> {
                                                 HBasicBlock* block) {
     DCHECK(environment_ == nullptr);
     ArenaAllocator* allocator = GetBlock()->GetGraph()->GetAllocator();
-    environment_ = new (allocator) HEnvironment(allocator, *environment, this);
+    environment_ = HEnvironment::Create(allocator, *environment, this);
     environment_->CopyFromWithLoopPhiAdjustment(environment, block);
     if (environment->GetParent() != nullptr) {
       environment_->SetAndCopyParentChain(allocator, environment->GetParent());
@@ -2786,7 +2605,7 @@ class HInstruction : public ArenaObject<kArenaAllocInstruction> {
     for (auto env_use_node = env_uses_.begin(); env_use_node != env_fixup_end; ++env_use_node) {
       HEnvironment* user = env_use_node->GetUser();
       size_t input_index = env_use_node->GetIndex();
-      user->vregs_[input_index] = HUserRecord<HEnvironment*>(this, before_env_use_node);
+      user->GetVRegs()[input_index] = HUserRecord<HEnvironment*>(this, before_env_use_node);
       before_env_use_node = env_use_node;
     }
   }
@@ -2796,8 +2615,8 @@ class HInstruction : public ArenaObject<kArenaAllocInstruction> {
     if (next != env_uses_.end()) {
       HEnvironment* next_user = next->GetUser();
       size_t next_index = next->GetIndex();
-      DCHECK(next_user->vregs_[next_index].GetInstruction() == this);
-      next_user->vregs_[next_index] = HUserRecord<HEnvironment*>(this, before_env_use_node);
+      DCHECK(next_user->GetVRegs()[next_index].GetInstruction() == this);
+      next_user->GetVRegs()[next_index] = HUserRecord<HEnvironment*>(this, before_env_use_node);
     }
   }
 
@@ -3284,8 +3103,8 @@ class HGoto final : public HExpression<0> {
 
 class HConstant : public HExpression<0> {
  public:
-  explicit HConstant(InstructionKind kind, DataType::Type type, uint32_t dex_pc = kNoDexPc)
-      : HExpression(kind, type, SideEffects::None(), dex_pc) {
+  explicit HConstant(InstructionKind kind, DataType::Type type)
+      : HExpression(kind, type, SideEffects::None(), kNoDexPc) {
   }
 
   bool CanBeMoved() const override { return true; }
@@ -3326,8 +3145,8 @@ class HNullConstant final : public HConstant {
   DEFAULT_COPY_CONSTRUCTOR(NullConstant);
 
  private:
-  explicit HNullConstant(uint32_t dex_pc = kNoDexPc)
-      : HConstant(kNullConstant, DataType::Type::kReference, dex_pc) {
+  explicit HNullConstant()
+      : HConstant(kNullConstant, DataType::Type::kReference) {
   }
 
   friend class HGraph;
@@ -3366,11 +3185,11 @@ class HIntConstant final : public HConstant {
   DEFAULT_COPY_CONSTRUCTOR(IntConstant);
 
  private:
-  explicit HIntConstant(int32_t value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kIntConstant, DataType::Type::kInt32, dex_pc), value_(value) {
+  explicit HIntConstant(int32_t value)
+      : HConstant(kIntConstant, DataType::Type::kInt32), value_(value) {
   }
-  explicit HIntConstant(bool value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kIntConstant, DataType::Type::kInt32, dex_pc),
+  explicit HIntConstant(bool value)
+      : HConstant(kIntConstant, DataType::Type::kInt32),
         value_(value ? 1 : 0) {
   }
 
@@ -3405,8 +3224,8 @@ class HLongConstant final : public HConstant {
   DEFAULT_COPY_CONSTRUCTOR(LongConstant);
 
  private:
-  explicit HLongConstant(int64_t value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kLongConstant, DataType::Type::kInt64, dex_pc),
+  explicit HLongConstant(int64_t value)
+      : HConstant(kLongConstant, DataType::Type::kInt64),
         value_(value) {
   }
 
@@ -3458,12 +3277,12 @@ class HFloatConstant final : public HConstant {
   DEFAULT_COPY_CONSTRUCTOR(FloatConstant);
 
  private:
-  explicit HFloatConstant(float value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kFloatConstant, DataType::Type::kFloat32, dex_pc),
+  explicit HFloatConstant(float value)
+      : HConstant(kFloatConstant, DataType::Type::kFloat32),
         value_(value) {
   }
-  explicit HFloatConstant(int32_t value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kFloatConstant, DataType::Type::kFloat32, dex_pc),
+  explicit HFloatConstant(int32_t value)
+      : HConstant(kFloatConstant, DataType::Type::kFloat32),
         value_(bit_cast<float, int32_t>(value)) {
   }
 
@@ -3515,12 +3334,12 @@ class HDoubleConstant final : public HConstant {
   DEFAULT_COPY_CONSTRUCTOR(DoubleConstant);
 
  private:
-  explicit HDoubleConstant(double value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kDoubleConstant, DataType::Type::kFloat64, dex_pc),
+  explicit HDoubleConstant(double value)
+      : HConstant(kDoubleConstant, DataType::Type::kFloat64),
         value_(value) {
   }
-  explicit HDoubleConstant(int64_t value, uint32_t dex_pc = kNoDexPc)
-      : HConstant(kDoubleConstant, DataType::Type::kFloat64, dex_pc),
+  explicit HDoubleConstant(int64_t value)
+      : HConstant(kDoubleConstant, DataType::Type::kFloat64),
         value_(bit_cast<double, int64_t>(value)) {
   }
 
@@ -4054,6 +3873,12 @@ class HCondition : public HBinaryOperation {
     SetPackedField<ComparisonBiasField>(ComparisonBias::kNoBias);
   }
 
+  static HCondition* Create(HGraph* graph,
+                            IfCondition cond,
+                            HInstruction* lhs,
+                            HInstruction* rhs,
+                            uint32_t dex_pc = kNoDexPc);
+
   // For code generation purposes, returns whether this instruction is just before
   // `instruction`, and disregard moves in between.
   bool IsBeforeWhenDisregardMoves(HInstruction* instruction) const;
@@ -4119,8 +3944,8 @@ class HCondition : public HBinaryOperation {
   }
 
   // Return an integer constant containing the result of a condition evaluated at compile time.
-  HIntConstant* MakeConstantCondition(bool value, uint32_t dex_pc) const {
-    return GetBlock()->GetGraph()->GetIntConstant(value, dex_pc);
+  HIntConstant* MakeConstantCondition(bool value) const {
+    return GetBlock()->GetGraph()->GetIntConstant(value);
   }
 
   DEFAULT_COPY_CONSTRUCTOR(Condition);
@@ -4137,23 +3962,22 @@ class HEqual final : public HCondition {
 
   HConstant* Evaluate([[maybe_unused]] HNullConstant* x,
                       [[maybe_unused]] HNullConstant* y) const override {
-    return MakeConstantCondition(true, GetDexPc());
+    return MakeConstantCondition(true);
   }
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HEqual instruction; evaluate it as
   // `Compare(x, y) == 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0),
-                                 GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(Equal);
@@ -4175,8 +3999,7 @@ class HEqual final : public HCondition {
 
 class HNotEqual final : public HCondition {
  public:
-  HNotEqual(HInstruction* first, HInstruction* second,
-            uint32_t dex_pc = kNoDexPc)
+  HNotEqual(HInstruction* first, HInstruction* second, uint32_t dex_pc = kNoDexPc)
       : HCondition(kNotEqual, first, second, dex_pc) {
   }
 
@@ -4184,22 +4007,22 @@ class HNotEqual final : public HCondition {
 
   HConstant* Evaluate([[maybe_unused]] HNullConstant* x,
                       [[maybe_unused]] HNullConstant* y) const override {
-    return MakeConstantCondition(false, GetDexPc());
+    return MakeConstantCondition(false);
   }
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HNotEqual instruction; evaluate it as
   // `Compare(x, y) != 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(NotEqual);
@@ -4221,25 +4044,24 @@ class HNotEqual final : public HCondition {
 
 class HLessThan final : public HCondition {
  public:
-  HLessThan(HInstruction* first, HInstruction* second,
-            uint32_t dex_pc = kNoDexPc)
+  HLessThan(HInstruction* first, HInstruction* second, uint32_t dex_pc = kNoDexPc)
       : HCondition(kLessThan, first, second, dex_pc) {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HLessThan instruction; evaluate it as
   // `Compare(x, y) < 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(LessThan);
@@ -4261,25 +4083,24 @@ class HLessThan final : public HCondition {
 
 class HLessThanOrEqual final : public HCondition {
  public:
-  HLessThanOrEqual(HInstruction* first, HInstruction* second,
-                   uint32_t dex_pc = kNoDexPc)
+  HLessThanOrEqual(HInstruction* first, HInstruction* second, uint32_t dex_pc = kNoDexPc)
       : HCondition(kLessThanOrEqual, first, second, dex_pc) {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HLessThanOrEqual instruction; evaluate it as
   // `Compare(x, y) <= 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(LessThanOrEqual);
@@ -4306,19 +4127,19 @@ class HGreaterThan final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HGreaterThan instruction; evaluate it as
   // `Compare(x, y) > 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(GreaterThan);
@@ -4345,19 +4166,19 @@ class HGreaterThanOrEqual final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   // In the following Evaluate methods, a HCompare instruction has
   // been merged into this HGreaterThanOrEqual instruction; evaluate it as
   // `Compare(x, y) >= 0`.
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(Compare(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0), GetDexPc());
+    return MakeConstantCondition(Compute(CompareFP(x->GetValue(), y->GetValue()), 0));
   }
 
   DECLARE_INSTRUCTION(GreaterThanOrEqual);
@@ -4384,10 +4205,10 @@ class HBelow final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Below);
@@ -4416,10 +4237,10 @@ class HBelowOrEqual final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(BelowOrEqual);
@@ -4448,10 +4269,10 @@ class HAbove final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Above);
@@ -4480,10 +4301,10 @@ class HAboveOrEqual final : public HCondition {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantCondition(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(AboveOrEqual);
@@ -4547,19 +4368,19 @@ class HCompare final : public HBinaryOperation {
     const int32_t value = DataType::IsUnsignedType(GetComparisonType()) ?
         Compute(x->GetValueAsUint64(), y->GetValueAsUint64()) :
         Compute(x->GetValue(), y->GetValue());
-    return MakeConstantComparison(value, GetDexPc());
+    return MakeConstantComparison(value);
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
     const int32_t value = DataType::IsUnsignedType(GetComparisonType()) ?
         Compute(x->GetValueAsUint64(), y->GetValueAsUint64()) :
         Compute(x->GetValue(), y->GetValue());
-    return MakeConstantComparison(value, GetDexPc());
+    return MakeConstantComparison(value);
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return MakeConstantComparison(ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantComparison(ComputeFP(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return MakeConstantComparison(ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return MakeConstantComparison(ComputeFP(x->GetValue(), y->GetValue()));
   }
 
   bool InstructionDataEquals(const HInstruction* other) const override {
@@ -4602,9 +4423,9 @@ class HCompare final : public HBinaryOperation {
       BitField<DataType::Type, kFieldComparisonType, kFieldComparisonTypeSize>;
 
   // Return an integer constant containing the result of a comparison evaluated at compile time.
-  HIntConstant* MakeConstantComparison(int32_t value, uint32_t dex_pc) const {
+  HIntConstant* MakeConstantComparison(int32_t value) const {
     DCHECK(value == -1 || value == 0 || value == 1) << value;
-    return GetBlock()->GetGraph()->GetIntConstant(value, dex_pc);
+    return GetBlock()->GetGraph()->GetIntConstant(value);
   }
 
   DEFAULT_COPY_CONSTRUCTOR(Compare);
@@ -4727,6 +4548,10 @@ enum class MethodLoadKind {
   // Used for app->boot calls with relocatable image.
   kBootImageRelRo,
 
+  // Load from an app image entry in the .data.img.rel.ro using a PC-relative load.
+  // Used for app image methods referenced by apps in AOT-compiled code.
+  kAppImageRelRo,
+
   // Load from an entry in the .bss section using a PC-relative load.
   // Used for methods outside boot image referenced by AOT-compiled app and boot image code.
   kBssEntry,
@@ -4759,6 +4584,7 @@ enum class CodePtrLocation {
 static inline bool IsPcRelativeMethodLoadKind(MethodLoadKind load_kind) {
   return load_kind == MethodLoadKind::kBootImageLinkTimePcRelative ||
          load_kind == MethodLoadKind::kBootImageRelRo ||
+         load_kind == MethodLoadKind::kAppImageRelRo ||
          load_kind == MethodLoadKind::kBssEntry;
 }
 
@@ -4776,6 +4602,9 @@ class HInvoke : public HVariableInputSizeInstruction {
   // inputs at the end of their list of inputs.
   uint32_t GetNumberOfArguments() const { return number_of_arguments_; }
 
+  // Return the number of outgoing vregs.
+  uint32_t GetNumberOfOutVRegs() const { return number_of_out_vregs_; }
+
   InvokeType GetInvokeType() const {
     return GetPackedField<InvokeTypeField>();
   }
@@ -4803,6 +4632,8 @@ class HInvoke : public HVariableInputSizeInstruction {
 
   bool CanBeMoved() const override { return IsIntrinsic() && !DoesAnyWrite(); }
 
+  bool CanBeNull() const override;
+
   bool InstructionDataEquals(const HInstruction* other) const override {
     return intrinsic_ != Intrinsics::kNone && intrinsic_ == other->AsInvoke()->intrinsic_;
   }
@@ -4841,6 +4672,7 @@ class HInvoke : public HVariableInputSizeInstruction {
   HInvoke(InstructionKind kind,
           ArenaAllocator* allocator,
           uint32_t number_of_arguments,
+          uint32_t number_of_out_vregs,
           uint32_t number_of_other_inputs,
           DataType::Type return_type,
           uint32_t dex_pc,
@@ -4857,9 +4689,10 @@ class HInvoke : public HVariableInputSizeInstruction {
           allocator,
           number_of_arguments + number_of_other_inputs,
           kArenaAllocInvokeInputs),
-      number_of_arguments_(number_of_arguments),
       method_reference_(method_reference),
       resolved_method_reference_(resolved_method_reference),
+      number_of_arguments_(dchecked_integral_cast<uint16_t>(number_of_arguments)),
+      number_of_out_vregs_(dchecked_integral_cast<uint16_t>(number_of_out_vregs)),
       intrinsic_(Intrinsics::kNone),
       intrinsic_optimizations_(0) {
     SetPackedField<InvokeTypeField>(invoke_type);
@@ -4869,11 +4702,14 @@ class HInvoke : public HVariableInputSizeInstruction {
 
   DEFAULT_COPY_CONSTRUCTOR(Invoke);
 
-  uint32_t number_of_arguments_;
   ArtMethod* resolved_method_;
   const MethodReference method_reference_;
   // Cached values of the resolved method, to avoid needing the mutator lock.
   const MethodReference resolved_method_reference_;
+
+  uint16_t number_of_arguments_;
+  uint16_t number_of_out_vregs_;
+
   Intrinsics intrinsic_;
 
   // A magic word holding optimizations for intrinsics. See intrinsics.h.
@@ -4884,6 +4720,7 @@ class HInvokeUnresolved final : public HInvoke {
  public:
   HInvokeUnresolved(ArenaAllocator* allocator,
                     uint32_t number_of_arguments,
+                    uint32_t number_of_out_vregs,
                     DataType::Type return_type,
                     uint32_t dex_pc,
                     MethodReference method_reference,
@@ -4891,6 +4728,7 @@ class HInvokeUnresolved final : public HInvoke {
       : HInvoke(kInvokeUnresolved,
                 allocator,
                 number_of_arguments,
+                number_of_out_vregs,
                 /* number_of_other_inputs= */ 0u,
                 return_type,
                 dex_pc,
@@ -4913,6 +4751,7 @@ class HInvokePolymorphic final : public HInvoke {
  public:
   HInvokePolymorphic(ArenaAllocator* allocator,
                      uint32_t number_of_arguments,
+                     uint32_t number_of_out_vregs,
                      uint32_t number_of_other_inputs,
                      DataType::Type return_type,
                      uint32_t dex_pc,
@@ -4926,6 +4765,7 @@ class HInvokePolymorphic final : public HInvoke {
       : HInvoke(kInvokePolymorphic,
                 allocator,
                 number_of_arguments,
+                number_of_out_vregs,
                 number_of_other_inputs,
                 return_type,
                 dex_pc,
@@ -4940,10 +4780,13 @@ class HInvokePolymorphic final : public HInvoke {
 
   dex::ProtoIndex GetProtoIndex() { return proto_idx_; }
 
-  // Whether we can do direct invocation of the method handle.
-  bool CanHaveFastPath() const {
-    return GetIntrinsic() == Intrinsics::kMethodHandleInvokeExact &&
-        GetNumberOfArguments() >= 2 &&
+  bool IsMethodHandleInvokeExact() const {
+    return GetIntrinsic() == Intrinsics::kMethodHandleInvokeExact;
+  }
+
+  bool CanTargetInstanceMethod() const {
+    DCHECK(IsMethodHandleInvokeExact());
+    return GetNumberOfArguments() >= 2 &&
         InputAt(1)->GetType() == DataType::Type::kReference;
   }
 
@@ -4958,6 +4801,7 @@ class HInvokeCustom final : public HInvoke {
  public:
   HInvokeCustom(ArenaAllocator* allocator,
                 uint32_t number_of_arguments,
+                uint32_t number_of_out_vregs,
                 uint32_t call_site_index,
                 DataType::Type return_type,
                 uint32_t dex_pc,
@@ -4966,6 +4810,7 @@ class HInvokeCustom final : public HInvoke {
       : HInvoke(kInvokeCustom,
                 allocator,
                 number_of_arguments,
+                number_of_out_vregs,
                 /* number_of_other_inputs= */ 0u,
                 return_type,
                 dex_pc,
@@ -5013,6 +4858,7 @@ class HInvokeStaticOrDirect final : public HInvoke {
 
   HInvokeStaticOrDirect(ArenaAllocator* allocator,
                         uint32_t number_of_arguments,
+                        uint32_t number_of_out_vregs,
                         DataType::Type return_type,
                         uint32_t dex_pc,
                         MethodReference method_reference,
@@ -5025,6 +4871,7 @@ class HInvokeStaticOrDirect final : public HInvoke {
       : HInvoke(kInvokeStaticOrDirect,
                 allocator,
                 number_of_arguments,
+                number_of_out_vregs,
                 // There is potentially one extra argument for the HCurrentMethod input,
                 // and one other if the clinit check is explicit. These can be removed later.
                 (NeedsCurrentMethodInput(dispatch_info) ? 1u : 0u) +
@@ -5240,6 +5087,7 @@ class HInvokeVirtual final : public HInvoke {
  public:
   HInvokeVirtual(ArenaAllocator* allocator,
                  uint32_t number_of_arguments,
+                 uint32_t number_of_out_vregs,
                  DataType::Type return_type,
                  uint32_t dex_pc,
                  MethodReference method_reference,
@@ -5250,6 +5098,7 @@ class HInvokeVirtual final : public HInvoke {
       : HInvoke(kInvokeVirtual,
                 allocator,
                 number_of_arguments,
+                number_of_out_vregs,
                 0u,
                 return_type,
                 dex_pc,
@@ -5263,28 +5112,6 @@ class HInvokeVirtual final : public HInvoke {
 
   bool IsClonable() const override { return true; }
 
-  bool CanBeNull() const override {
-    switch (GetIntrinsic()) {
-      case Intrinsics::kThreadCurrentThread:
-      case Intrinsics::kStringBufferAppend:
-      case Intrinsics::kStringBufferToString:
-      case Intrinsics::kStringBuilderAppendObject:
-      case Intrinsics::kStringBuilderAppendString:
-      case Intrinsics::kStringBuilderAppendCharSequence:
-      case Intrinsics::kStringBuilderAppendCharArray:
-      case Intrinsics::kStringBuilderAppendBoolean:
-      case Intrinsics::kStringBuilderAppendChar:
-      case Intrinsics::kStringBuilderAppendInt:
-      case Intrinsics::kStringBuilderAppendLong:
-      case Intrinsics::kStringBuilderAppendFloat:
-      case Intrinsics::kStringBuilderAppendDouble:
-      case Intrinsics::kStringBuilderToString:
-        return false;
-      default:
-        return HInvoke::CanBeNull();
-    }
-  }
-
   bool CanDoImplicitNullCheckOn(HInstruction* obj) const override;
 
   uint32_t GetVTableIndex() const { return vtable_index_; }
@@ -5303,6 +5130,7 @@ class HInvokeInterface final : public HInvoke {
  public:
   HInvokeInterface(ArenaAllocator* allocator,
                    uint32_t number_of_arguments,
+                   uint32_t number_of_out_vregs,
                    DataType::Type return_type,
                    uint32_t dex_pc,
                    MethodReference method_reference,
@@ -5314,6 +5142,7 @@ class HInvokeInterface final : public HInvoke {
       : HInvoke(kInvokeInterface,
                 allocator,
                 number_of_arguments + (NeedsCurrentMethod(load_kind) ? 1 : 0),
+                number_of_out_vregs,
                 0u,
                 return_type,
                 dex_pc,
@@ -5374,16 +5203,16 @@ class HNeg final : public HUnaryOperation {
   template <typename T> static T Compute(T x) { return -x; }
 
   HConstant* Evaluate(HIntConstant* x) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(Compute(x->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(Compute(x->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Neg);
@@ -5453,20 +5282,16 @@ class HAdd final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x + y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Add);
@@ -5487,20 +5312,16 @@ class HSub final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x - y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Sub);
@@ -5523,20 +5344,16 @@ class HMul final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x * y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Mul);
@@ -5571,20 +5388,16 @@ class HDiv final : public HBinaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(ComputeFP(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(ComputeFP(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Div);
@@ -5619,20 +5432,16 @@ class HRem final : public HBinaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x, HFloatConstant* y) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(ComputeFP(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x, HDoubleConstant* y) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        ComputeFP(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(ComputeFP(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Rem);
@@ -5657,12 +5466,10 @@ class HMin final : public HBinaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   // TODO: Evaluation for floating-point values.
   HConstant* Evaluate([[maybe_unused]] HFloatConstant* x,
@@ -5696,12 +5503,10 @@ class HMax final : public HBinaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        ComputeIntegral(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue(), y->GetValue()));
   }
   // TODO: Evaluation for floating-point values.
   HConstant* Evaluate([[maybe_unused]] HFloatConstant* x,
@@ -5740,18 +5545,16 @@ class HAbs final : public HUnaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(ComputeIntegral(x->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(ComputeIntegral(x->GetValue()));
   }
   HConstant* Evaluate(HFloatConstant* x) const override {
-    return GetBlock()->GetGraph()->GetFloatConstant(
-        ComputeFP<float, int32_t>(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetFloatConstant(ComputeFP<float, int32_t>(x->GetValue()));
   }
   HConstant* Evaluate(HDoubleConstant* x) const override {
-    return GetBlock()->GetGraph()->GetDoubleConstant(
-        ComputeFP<double, int64_t>(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetDoubleConstant(ComputeFP<double, int64_t>(x->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Abs);
@@ -5804,11 +5607,11 @@ class HShl final : public HBinaryOperation {
 
   HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance));
   }
   HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance));
   }
 
   DECLARE_INSTRUCTION(Shl);
@@ -5835,11 +5638,11 @@ class HShr final : public HBinaryOperation {
 
   HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance));
   }
   HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance));
   }
 
   DECLARE_INSTRUCTION(Shr);
@@ -5868,11 +5671,11 @@ class HUShr final : public HBinaryOperation {
 
   HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance));
   }
   HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance));
   }
 
   DECLARE_INSTRUCTION(UShr);
@@ -5895,12 +5698,10 @@ class HAnd final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x & y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(And);
@@ -5923,12 +5724,10 @@ class HOr final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x | y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Or);
@@ -5951,12 +5750,10 @@ class HXor final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return x ^ y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Xor);
@@ -5986,11 +5783,11 @@ class HRor final : public HBinaryOperation {
 
   HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance));
   }
   HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance));
   }
 
   DECLARE_INSTRUCTION(Ror);
@@ -6011,11 +5808,11 @@ class HRol final : public HBinaryOperation {
 
   HConstant* Evaluate(HIntConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxIntShiftDistance));
   }
   HConstant* Evaluate(HLongConstant* value, HIntConstant* distance) const override {
     return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance), GetDexPc());
+        Compute(value->GetValue(), distance->GetValue(), kMaxLongShiftDistance));
   }
 
   DECLARE_INSTRUCTION(Rol);
@@ -6083,10 +5880,10 @@ class HNot final : public HUnaryOperation {
   template <typename T> static T Compute(T x) { return ~x; }
 
   HConstant* Evaluate(HIntConstant* x) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()));
   }
 
   DECLARE_INSTRUCTION(Not);
@@ -6112,7 +5909,7 @@ class HBooleanNot final : public HUnaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()));
   }
 
   DECLARE_INSTRUCTION(BooleanNot);
@@ -7527,6 +7324,7 @@ class HStringBuilderAppend final : public HVariableInputSizeInstruction {
  public:
   HStringBuilderAppend(HIntConstant* format,
                        uint32_t number_of_arguments,
+                       uint32_t number_of_out_vregs,
                        bool has_fp_args,
                        ArenaAllocator* allocator,
                        uint32_t dex_pc)
@@ -7541,7 +7339,8 @@ class HStringBuilderAppend final : public HVariableInputSizeInstruction {
             dex_pc,
             allocator,
             number_of_arguments + /* format */ 1u,
-            kArenaAllocInvokeInputs) {
+            kArenaAllocInvokeInputs),
+        number_of_out_vregs_(number_of_out_vregs) {
     DCHECK_GE(number_of_arguments, 1u);  // There must be something to append.
     SetRawInputAt(FormatIndex(), format);
   }
@@ -7557,6 +7356,9 @@ class HStringBuilderAppend final : public HVariableInputSizeInstruction {
     return InputCount() - 1u;
   }
 
+  // Return the number of outgoing vregs.
+  uint32_t GetNumberOfOutVRegs() const { return number_of_out_vregs_; }
+
   size_t FormatIndex() const {
     return GetNumberOfArguments();
   }
@@ -7575,6 +7377,9 @@ class HStringBuilderAppend final : public HVariableInputSizeInstruction {
 
  protected:
   DEFAULT_COPY_CONSTRUCTOR(StringBuilderAppend);
+
+ private:
+  uint32_t number_of_out_vregs_;
 };
 
 class HUnresolvedInstanceFieldGet final : public HExpression<1> {
@@ -8485,13 +8290,11 @@ class HBitwiseNegatedRight final : public HBinaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()),
-                                                  GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()),
-                                                   GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   InstructionKind GetOpKind() const { return op_kind_; }
diff --git a/compiler/optimizing/nodes_riscv64.h b/compiler/optimizing/nodes_riscv64.h
index 4916e57944..51e8f7a1d1 100644
--- a/compiler/optimizing/nodes_riscv64.h
+++ b/compiler/optimizing/nodes_riscv64.h
@@ -42,7 +42,7 @@ class HRiscv64ShiftAdd final : public HBinaryOperation {
 
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
     const int64_t value = y->GetValue() + (x->GetValue() << GetDistance());
-    return GetBlock()->GetGraph()->GetLongConstant(value, GetDexPc());
+    return GetBlock()->GetGraph()->GetLongConstant(value);
   }
 
   DECLARE_INSTRUCTION(Riscv64ShiftAdd);
diff --git a/compiler/optimizing/nodes_test.cc b/compiler/optimizing/nodes_test.cc
index 1a1d9ac7da..0302298b9c 100644
--- a/compiler/optimizing/nodes_test.cc
+++ b/compiler/optimizing/nodes_test.cc
@@ -212,14 +212,22 @@ TEST_F(NodeTest, ParentEnvironment) {
   ASSERT_TRUE(parameter1->HasEnvironmentUses());
   ASSERT_TRUE(parameter1->GetEnvUses().HasExactlyOneElement());
 
-  HEnvironment* parent1 = new (GetAllocator()) HEnvironment(
-      GetAllocator(), 1, graph->GetArtMethod(), 0, nullptr);
+  HEnvironment* parent1 = HEnvironment::Create(
+      GetAllocator(),
+      /*number_of_vregs=*/ 1,
+      graph->GetArtMethod(),
+      /*dex_pc=*/ 0,
+      /*holder=*/ nullptr);
   parent1->CopyFrom(ArrayRef<HInstruction* const>(&parameter1, 1u));
 
   ASSERT_EQ(parameter1->GetEnvUses().SizeSlow(), 2u);
 
-  HEnvironment* parent2 = new (GetAllocator()) HEnvironment(
-      GetAllocator(), 1, graph->GetArtMethod(), 0, nullptr);
+  HEnvironment* parent2 = HEnvironment::Create(
+      GetAllocator(),
+      /*number_of_vregs=*/ 1,
+      graph->GetArtMethod(),
+      /*dex_pc=*/ 0,
+      /*holder=*/ nullptr);
   parent2->CopyFrom(ArrayRef<HInstruction* const>(&parameter1, 1u));
   parent1->SetAndCopyParentChain(GetAllocator(), parent2);
 
diff --git a/compiler/optimizing/nodes_vector.cc b/compiler/optimizing/nodes_vector.cc
new file mode 100644
index 0000000000..b1a3cb877f
--- /dev/null
+++ b/compiler/optimizing/nodes_vector.cc
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nodes.h"
+
+namespace art HIDDEN {
+
+HVecCondition* HVecCondition::Create(HGraph* graph,
+                                     IfCondition cond,
+                                     HInstruction* lhs,
+                                     HInstruction* rhs,
+                                     DataType::Type packed_type,
+                                     size_t vector_length,
+                                     uint32_t dex_pc) {
+  ArenaAllocator* allocator = graph->GetAllocator();
+  switch (cond) {
+    case kCondEQ: return new (allocator) HVecEqual(allocator,
+                                                   lhs,
+                                                   rhs,
+                                                   packed_type,
+                                                   vector_length,
+                                                   dex_pc);
+    case kCondNE: return new (allocator) HVecNotEqual(allocator,
+                                                      lhs,
+                                                      rhs,
+                                                      packed_type,
+                                                      vector_length,
+                                                      dex_pc);
+    case kCondLT: return new (allocator) HVecLessThan(allocator,
+                                                      lhs,
+                                                      rhs,
+                                                      packed_type,
+                                                      vector_length,
+                                                      dex_pc);
+    case kCondLE: return new (allocator) HVecLessThanOrEqual(allocator,
+                                                             lhs,
+                                                             rhs,
+                                                             packed_type,
+                                                             vector_length,
+                                                             dex_pc);
+    case kCondGT: return new (allocator) HVecGreaterThan(allocator,
+                                                         lhs,
+                                                         rhs,
+                                                         packed_type,
+                                                         vector_length,
+                                                         dex_pc);
+    case kCondGE: return new (allocator) HVecGreaterThanOrEqual(allocator,
+                                                                lhs,
+                                                                rhs,
+                                                                packed_type,
+                                                                vector_length,
+                                                                dex_pc);
+    case kCondB:  return new (allocator) HVecBelow(allocator,
+                                                   lhs,
+                                                   rhs,
+                                                   packed_type,
+                                                   vector_length,
+                                                   dex_pc);
+    case kCondBE: return new (allocator) HVecBelowOrEqual(allocator,
+                                                          lhs,
+                                                          rhs,
+                                                          packed_type,
+                                                          vector_length,
+                                                          dex_pc);
+    case kCondA:  return new (allocator) HVecAbove(allocator,
+                                                   lhs,
+                                                   rhs,
+                                                   packed_type,
+                                                   vector_length,
+                                                   dex_pc);
+    case kCondAE: return new (allocator) HVecAboveOrEqual(allocator,
+                                                          lhs,
+                                                          rhs,
+                                                          packed_type,
+                                                          vector_length,
+                                                          dex_pc);
+  }
+  LOG(FATAL) << "Unexpected condition " << cond;
+  UNREACHABLE();
+}
+
+}  // namespace art
diff --git a/compiler/optimizing/nodes_vector.h b/compiler/optimizing/nodes_vector.h
index 6a60d6be01..a4c22f7017 100644
--- a/compiler/optimizing/nodes_vector.h
+++ b/compiler/optimizing/nodes_vector.h
@@ -1467,19 +1467,16 @@ class HVecPredToBoolean final : public HVecOperation {
 //
 // viz. [ p1, .. , pn ]  = [ x1 OP y1 , x2 OP y2, .. , xn OP yn] where OP is CondKind
 // condition.
-//
-// Currently only kEqual is supported by this vector instruction - we don't even define
-// the kCondType here.
-// TODO: support other condition ops.
-class HVecCondition final : public HVecPredSetOperation {
+class HVecCondition : public HVecPredSetOperation {
  public:
-  HVecCondition(ArenaAllocator* allocator,
+  HVecCondition(InstructionKind kind,
+                ArenaAllocator* allocator,
                 HInstruction* left,
                 HInstruction* right,
                 DataType::Type packed_type,
                 size_t vector_length,
-                uint32_t dex_pc) :
-      HVecPredSetOperation(kVecCondition,
+                uint32_t dex_pc = kNoDexPc) :
+      HVecPredSetOperation(kind,
                            allocator,
                            packed_type,
                            SideEffects::None(),
@@ -1494,22 +1491,276 @@ class HVecCondition final : public HVecPredSetOperation {
     SetRawInputAt(1, right);
   }
 
-  DECLARE_INSTRUCTION(VecCondition);
+  DECLARE_ABSTRACT_INSTRUCTION(VecCondition);
+
+  virtual IfCondition GetCondition() const = 0;
+
+  static HVecCondition* Create(HGraph* graph,
+                               IfCondition cond,
+                               HInstruction* lhs,
+                               HInstruction* rhs,
+                               DataType::Type packed_type,
+                               size_t vector_length,
+                               uint32_t dex_pc = kNoDexPc);
 
  protected:
   DEFAULT_COPY_CONSTRUCTOR(VecCondition);
 };
 
+// Instruction to check if two vector inputs are equal to each other.
+class HVecEqual final : public HVecCondition {
+ public:
+  HVecEqual(ArenaAllocator* allocator,
+            HInstruction* left,
+            HInstruction* right,
+            DataType::Type packed_type,
+            size_t vector_length,
+            uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecEqual, allocator, left, right, packed_type, vector_length, dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondEQ;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecEqual);
+};
+
+// Instruction to check if two vector inputs are not equal to each other.
+class HVecNotEqual final : public HVecCondition {
+ public:
+  HVecNotEqual(ArenaAllocator* allocator,
+               HInstruction* left,
+               HInstruction* right,
+               DataType::Type packed_type,
+               size_t vector_length,
+               uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecNotEqual, allocator, left, right, packed_type, vector_length, dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecNotEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondNE;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecNotEqual);
+};
+
+// Instruction to check if one vector input is less than the other.
+class HVecLessThan final : public HVecCondition {
+ public:
+  HVecLessThan(ArenaAllocator* allocator,
+               HInstruction* left,
+               HInstruction* right,
+               DataType::Type packed_type,
+               size_t vector_length,
+               uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecLessThan, allocator, left, right, packed_type, vector_length, dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecLessThan);
+
+  IfCondition GetCondition() const override {
+    return kCondLT;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecLessThan);
+};
+
+// Instruction to check if one vector input is less than or equal to the other.
+class HVecLessThanOrEqual final : public HVecCondition {
+ public:
+  HVecLessThanOrEqual(ArenaAllocator* allocator,
+                      HInstruction* left,
+                      HInstruction* right,
+                      DataType::Type packed_type,
+                      size_t vector_length,
+                      uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecLessThanOrEqual,
+                      allocator,
+                      left,
+                      right,
+                      packed_type,
+                      vector_length,
+                      dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecLessThanOrEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondLE;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecLessThanOrEqual);
+};
+
+// Instruction to check if one vector input is greater than the other.
+class HVecGreaterThan final : public HVecCondition {
+ public:
+  HVecGreaterThan(ArenaAllocator* allocator,
+                  HInstruction* left,
+                  HInstruction* right,
+                  DataType::Type packed_type,
+                  size_t vector_length,
+                  uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecGreaterThan,
+                      allocator,
+                      left,
+                      right,
+                      packed_type,
+                      vector_length,
+                      dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecGreaterThan);
+
+  IfCondition GetCondition() const override {
+    return kCondGT;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecGreaterThan);
+};
+
+// Instruction to check if one vector input is greater than or equal to the other.
+class HVecGreaterThanOrEqual final : public HVecCondition {
+ public:
+  HVecGreaterThanOrEqual(ArenaAllocator* allocator,
+                         HInstruction* left,
+                         HInstruction* right,
+                         DataType::Type packed_type,
+                         size_t vector_length,
+                         uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecGreaterThanOrEqual,
+                      allocator,
+                      left,
+                      right,
+                      packed_type,
+                      vector_length,
+                      dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecGreaterThanOrEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondGE;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecGreaterThanOrEqual);
+};
+
+// Instruction to check if one unsigned vector input is less than the other, using unsigned
+// comparison.
+class HVecBelow final : public HVecCondition {
+ public:
+  HVecBelow(ArenaAllocator* allocator,
+            HInstruction* left,
+            HInstruction* right,
+            DataType::Type packed_type,
+            size_t vector_length,
+            uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecBelow, allocator, left, right, packed_type, vector_length, dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecBelow);
+
+  IfCondition GetCondition() const override {
+    return kCondB;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecBelow);
+};
+
+// Instruction to check if one unsigned vector input is less than or equal to the other, using
+// unsigned comparison.
+class HVecBelowOrEqual final : public HVecCondition {
+ public:
+  HVecBelowOrEqual(ArenaAllocator* allocator,
+                   HInstruction* left,
+                   HInstruction* right,
+                   DataType::Type packed_type,
+                   size_t vector_length,
+                   uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecBelowOrEqual,
+                      allocator,
+                      left,
+                      right,
+                      packed_type,
+                      vector_length,
+                      dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecBelowOrEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondBE;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecBelowOrEqual);
+};
+
+// Instruction to check if one unsigned vector input is greater than the other, using unsigned
+// comparison.
+class HVecAbove final : public HVecCondition {
+ public:
+  HVecAbove(ArenaAllocator* allocator,
+            HInstruction* left,
+            HInstruction* right,
+            DataType::Type packed_type,
+            size_t vector_length,
+            uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecAbove, allocator, left, right, packed_type, vector_length, dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecAbove);
+
+  IfCondition GetCondition() const override {
+    return kCondA;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecAbove);
+};
+
+// Instruction to check if one unsigned vector input is greater than or equal to the other, using
+// unsigned comparison.
+class HVecAboveOrEqual final : public HVecCondition {
+ public:
+  HVecAboveOrEqual(ArenaAllocator* allocator,
+                   HInstruction* left,
+                   HInstruction* right,
+                   DataType::Type packed_type,
+                   size_t vector_length,
+                   uint32_t dex_pc = kNoDexPc)
+      : HVecCondition(kVecAboveOrEqual,
+                      allocator,
+                      left,
+                      right,
+                      packed_type,
+                      vector_length,
+                      dex_pc) {}
+
+  DECLARE_INSTRUCTION(VecAboveOrEqual);
+
+  IfCondition GetCondition() const override {
+    return kCondAE;
+  }
+
+ protected:
+  DEFAULT_COPY_CONSTRUCTOR(VecAboveOrEqual);
+};
+
 // Inverts every component in the predicate vector.
 //
 // viz. [ p1, .. , pn ]  = [ !px1 , !px2 , .. , !pxn ].
 class HVecPredNot final : public HVecPredSetOperation {
  public:
   HVecPredNot(ArenaAllocator* allocator,
-                HInstruction* input,
-                DataType::Type packed_type,
-                size_t vector_length,
-                uint32_t dex_pc) :
+              HInstruction* input,
+              DataType::Type packed_type,
+              size_t vector_length,
+              uint32_t dex_pc) :
       HVecPredSetOperation(kVecPredNot,
                            allocator,
                            packed_type,
@@ -1529,6 +1780,11 @@ class HVecPredNot final : public HVecPredSetOperation {
   DEFAULT_COPY_CONSTRUCTOR(VecPredNot);
 };
 
+// Return the number of elements of the given type that will fit into a vector of given size.
+inline size_t GetNumberOfElementsInVector(size_t vector_size_in_bytes, DataType::Type type) {
+  return vector_size_in_bytes / DataType::Size(type);
+}
+
 }  // namespace art
 
 #endif  // ART_COMPILER_OPTIMIZING_NODES_VECTOR_H_
diff --git a/compiler/optimizing/nodes_x86.h b/compiler/optimizing/nodes_x86.h
index 14d9823355..71c4f7aeeb 100644
--- a/compiler/optimizing/nodes_x86.h
+++ b/compiler/optimizing/nodes_x86.h
@@ -142,22 +142,10 @@ class HX86AndNot final : public HBinaryOperation {
   template <typename T> static T Compute(T x, T y) { return ~x & y; }
 
   HConstant* Evaluate(HIntConstant* x, HIntConstant* y) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue(), y->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x, HLongConstant* y) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(
-        Compute(x->GetValue(), y->GetValue()), GetDexPc());
-  }
-  HConstant* Evaluate([[maybe_unused]] HFloatConstant* x,
-                      [[maybe_unused]] HFloatConstant* y) const override {
-    LOG(FATAL) << DebugName() << " is not defined for float values";
-    UNREACHABLE();
-  }
-  HConstant* Evaluate([[maybe_unused]] HDoubleConstant* x,
-                      [[maybe_unused]] HDoubleConstant* y) const override {
-    LOG(FATAL) << DebugName() << " is not defined for double values";
-    UNREACHABLE();
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue(), y->GetValue()));
   }
 
   DECLARE_INSTRUCTION(X86AndNot);
@@ -191,19 +179,12 @@ class HX86MaskOrResetLeastSetBit final : public HUnaryOperation {
   }
 
   HConstant* Evaluate(HIntConstant* x) const override {
-    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()), GetDexPc());
+    return GetBlock()->GetGraph()->GetIntConstant(Compute(x->GetValue()));
   }
   HConstant* Evaluate(HLongConstant* x) const override {
-    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()), GetDexPc());
-  }
-  HConstant* Evaluate([[maybe_unused]] HFloatConstant* x) const override {
-    LOG(FATAL) << DebugName() << "is not defined for float values";
-    UNREACHABLE();
-  }
-  HConstant* Evaluate([[maybe_unused]] HDoubleConstant* x) const override {
-    LOG(FATAL) << DebugName() << "is not defined for double values";
-    UNREACHABLE();
+    return GetBlock()->GetGraph()->GetLongConstant(Compute(x->GetValue()));
   }
+
   InstructionKind GetOpKind() const { return op_kind_; }
 
   DECLARE_INSTRUCTION(X86MaskOrResetLeastSetBit);
diff --git a/compiler/optimizing/optimization.cc b/compiler/optimizing/optimization.cc
index ef1f36ab08..bd8fbdf1d2 100644
--- a/compiler/optimizing/optimization.cc
+++ b/compiler/optimizing/optimization.cc
@@ -55,6 +55,7 @@
 #include "licm.h"
 #include "load_store_elimination.h"
 #include "loop_optimization.h"
+#include "reference_type_propagation.h"
 #include "scheduler.h"
 #include "select_generator.h"
 #include "sharpening.h"
@@ -98,6 +99,8 @@ const char* OptimizationPassName(OptimizationPass pass) {
       return CodeSinking::kCodeSinkingPassName;
     case OptimizationPass::kConstructorFenceRedundancyElimination:
       return ConstructorFenceRedundancyElimination::kCFREPassName;
+    case OptimizationPass::kReferenceTypePropagation:
+      return ReferenceTypePropagation::kReferenceTypePropagationPassName;
     case OptimizationPass::kScheduling:
       return HInstructionScheduling::kInstructionSchedulingPassName;
     case OptimizationPass::kWriteBarrierElimination:
@@ -154,6 +157,7 @@ OptimizationPass OptimizationPassByName(const std::string& pass_name) {
   X(OptimizationPass::kInvariantCodeMotion);
   X(OptimizationPass::kLoadStoreElimination);
   X(OptimizationPass::kLoopOptimization);
+  X(OptimizationPass::kReferenceTypePropagation);
   X(OptimizationPass::kScheduling);
   X(OptimizationPass::kSelectGenerator);
   X(OptimizationPass::kSideEffectsAnalysis);
@@ -287,6 +291,10 @@ ArenaVector<HOptimization*> ConstructOptimizations(
       case OptimizationPass::kLoadStoreElimination:
         opt = new (allocator) LoadStoreElimination(graph, stats, pass_name);
         break;
+      case OptimizationPass::kReferenceTypePropagation:
+        opt = new (allocator) ReferenceTypePropagation(
+            graph, dex_compilation_unit.GetDexCache(), /* is_first_run= */ false, pass_name);
+        break;
       case OptimizationPass::kWriteBarrierElimination:
         opt = new (allocator) WriteBarrierElimination(graph, stats, pass_name);
         break;
diff --git a/compiler/optimizing/optimization.h b/compiler/optimizing/optimization.h
index 8bc9da49fc..abc4361b44 100644
--- a/compiler/optimizing/optimization.h
+++ b/compiler/optimizing/optimization.h
@@ -81,6 +81,7 @@ enum class OptimizationPass {
   kInvariantCodeMotion,
   kLoadStoreElimination,
   kLoopOptimization,
+  kReferenceTypePropagation,
   kScheduling,
   kSelectGenerator,
   kSideEffectsAnalysis,
diff --git a/compiler/optimizing/optimizing_compiler.cc b/compiler/optimizing/optimizing_compiler.cc
index 89edbed54d..cb9933c9c0 100644
--- a/compiler/optimizing/optimizing_compiler.cc
+++ b/compiler/optimizing/optimizing_compiler.cc
@@ -256,7 +256,6 @@ class OptimizingCompiler final : public Compiler {
 
   CompiledMethod* Compile(const dex::CodeItem* code_item,
                           uint32_t access_flags,
-                          InvokeType invoke_type,
                           uint16_t class_def_idx,
                           uint32_t method_idx,
                           Handle<mirror::ClassLoader> class_loader,
@@ -665,6 +664,9 @@ void OptimizingCompiler::RunOptimizations(HGraph* graph,
       OptDef(OptimizationPass::kSideEffectsAnalysis,
              "side_effects$before_gvn"),
       OptDef(OptimizationPass::kGlobalValueNumbering),
+      OptDef(OptimizationPass::kReferenceTypePropagation,
+             "reference_type_propagation$after_gvn",
+             OptimizationPass::kGlobalValueNumbering),
       // Simplification (TODO: only if GVN occurred).
       OptDef(OptimizationPass::kSelectGenerator),
       OptDef(OptimizationPass::kConstantFolding,
@@ -1065,7 +1067,6 @@ CodeGenerator* OptimizingCompiler::TryCompileIntrinsic(
 
 CompiledMethod* OptimizingCompiler::Compile(const dex::CodeItem* code_item,
                                             uint32_t access_flags,
-                                            InvokeType invoke_type,
                                             uint16_t class_def_idx,
                                             uint32_t method_idx,
                                             Handle<mirror::ClassLoader> jclass_loader,
@@ -1083,9 +1084,7 @@ CompiledMethod* OptimizingCompiler::Compile(const dex::CodeItem* code_item,
   {
     ScopedObjectAccess soa(Thread::Current());
     ArtMethod* method =
-        runtime->GetClassLinker()->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-            method_idx, dex_cache, jclass_loader, /*referrer=*/ nullptr, invoke_type);
-    DCHECK_EQ(method == nullptr, soa.Self()->IsExceptionPending());
+        runtime->GetClassLinker()->ResolveMethodId(method_idx, dex_cache, jclass_loader);
     soa.Self()->ClearException();  // Suppress exception if any.
     VariableSizedHandleScope handles(soa.Self());
     Handle<mirror::Class> compiling_class =
diff --git a/compiler/optimizing/optimizing_unit_test.h b/compiler/optimizing/optimizing_unit_test.h
index 2fe11299fc..018ffce196 100644
--- a/compiler/optimizing/optimizing_unit_test.h
+++ b/compiler/optimizing/optimizing_unit_test.h
@@ -382,7 +382,7 @@ class OptimizingUnitTestHelper {
 
     pre_header->AddSuccessor(loop);
     loop->AddSuccessor(loop_exit);  // true successor
-    loop->AddSuccessor(loop);  // fakse successor
+    loop->AddSuccessor(loop);  // false successor
 
     MakeGoto(pre_header);
 
@@ -404,8 +404,8 @@ class OptimizingUnitTestHelper {
 
   HEnvironment* ManuallyBuildEnvFor(HInstruction* instruction,
                                     ArenaVector<HInstruction*>* current_locals) {
-    HEnvironment* environment = new (GetAllocator()) HEnvironment(
-        (GetAllocator()),
+    HEnvironment* environment = HEnvironment::Create(
+        GetAllocator(),
         current_locals->size(),
         graph_->GetArtMethod(),
         instruction->GetDexPc(),
@@ -632,24 +632,97 @@ class OptimizingUnitTestHelper {
                           HInstruction* index,
                           HInstruction* value,
                           DataType::Type packed_type,
-                          size_t vector_length = 4,
+                          size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
                           uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
     SideEffects side_effects = SideEffects::ArrayWriteOfType(packed_type);
     HVecStore* vec_store = new (GetAllocator()) HVecStore(
-        GetAllocator(), base, index, value, packed_type, side_effects, vector_length, dex_pc);
+        GetAllocator(), base, index, value, packed_type, side_effects, num_of_elements, dex_pc);
     AddOrInsertInstruction(block, vec_store);
     return vec_store;
   }
 
+  HVecPredSetAll* MakeVecPredSetAll(HBasicBlock* block,
+                                    HInstruction* input,
+                                    DataType::Type packed_type,
+                                    size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
+                                    uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
+    HVecPredSetAll* predicate = new (GetAllocator()) HVecPredSetAll(
+        GetAllocator(), input, packed_type, num_of_elements, dex_pc);
+    AddOrInsertInstruction(block, predicate);
+    return predicate;
+  }
+
+  HVecReplicateScalar* MakeVecReplicateScalar(
+      HBasicBlock* block,
+      HInstruction* scalar,
+      DataType::Type packed_type,
+      size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
+      HVecPredSetOperation* predicate = nullptr,
+      uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
+    HVecReplicateScalar* vec_replicate_scalar = new (GetAllocator()) HVecReplicateScalar(
+        GetAllocator(), scalar, packed_type, num_of_elements, dex_pc);
+    AddOrInsertInstruction(block, vec_replicate_scalar);
+    if (predicate != nullptr) {
+      vec_replicate_scalar->SetMergingGoverningPredicate(predicate);
+    }
+    return vec_replicate_scalar;
+  }
+
+  HVecPredToBoolean* MakeVecPredToBoolean(
+      HBasicBlock* block,
+      HInstruction* input,
+      HVecPredToBoolean::PCondKind pred_cond,
+      DataType::Type packed_type,
+      size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
+      uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
+    HVecPredToBoolean* vec_pred_to_boolean = new (GetAllocator()) HVecPredToBoolean(
+        GetAllocator(),
+        input,
+        pred_cond,
+        packed_type,
+        num_of_elements,
+        dex_pc);
+    AddOrInsertInstruction(block, vec_pred_to_boolean);
+    return vec_pred_to_boolean;
+  }
+
+  HVecPredWhile* MakeVecPredWhile(HBasicBlock* block,
+                                  HInstruction* left,
+                                  HInstruction* right,
+                                  HVecPredWhile::CondKind cond,
+                                  DataType::Type packed_type,
+                                  size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
+                                  uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
+    HVecPredWhile* vec_pred_while = new (GetAllocator()) HVecPredWhile(
+        GetAllocator(),
+        left,
+        right,
+        cond,
+        packed_type,
+        num_of_elements,
+        dex_pc);
+    AddOrInsertInstruction(block, vec_pred_while);
+    return vec_pred_while;
+  }
+
   HInvokeStaticOrDirect* MakeInvokeStatic(HBasicBlock* block,
                                           DataType::Type return_type,
                                           const std::vector<HInstruction*>& args,
                                           std::initializer_list<HInstruction*> env = {},
                                           uint32_t dex_pc = kNoDexPc) {
     MethodReference method_reference{/* file= */ &graph_->GetDexFile(), /* index= */ method_idx_++};
+    size_t num_64bit_args = std::count_if(args.begin(), args.end(), [](HInstruction* insn) {
+      return DataType::Is64BitType(insn->GetType());
+    });
     HInvokeStaticOrDirect* invoke = new (GetAllocator())
         HInvokeStaticOrDirect(GetAllocator(),
                               args.size(),
+                              /* number_of_out_vregs= */ args.size() + num_64bit_args,
                               return_type,
                               dex_pc,
                               method_reference,
@@ -684,11 +757,34 @@ class OptimizingUnitTestHelper {
                             HInstruction* first,
                             HInstruction* second,
                             uint32_t dex_pc = kNoDexPc) {
-    HCondition* condition = graph_->CreateCondition(cond, first, second, dex_pc);
+    HCondition* condition = HCondition::Create(graph_, cond, first, second, dex_pc);
     AddOrInsertInstruction(block, condition);
     return condition;
   }
 
+  HVecCondition* MakeVecCondition(HBasicBlock* block,
+                                  IfCondition cond,
+                                  HInstruction* first,
+                                  HInstruction* second,
+                                  DataType::Type packed_type,
+                                  size_t vector_size_in_bytes = kDefaultTestVectorSizeInBytes,
+                                  HVecPredSetOperation* predicate = nullptr,
+                                  uint32_t dex_pc = kNoDexPc) {
+    size_t num_of_elements = GetNumberOfElementsInVector(vector_size_in_bytes, packed_type);
+    HVecCondition* condition = HVecCondition::Create(graph_,
+                                                     cond,
+                                                     first,
+                                                     second,
+                                                     packed_type,
+                                                     num_of_elements,
+                                                     dex_pc);
+    AddOrInsertInstruction(block, condition);
+    if (predicate != nullptr) {
+      condition->SetMergingGoverningPredicate(predicate);
+    }
+    return condition;
+  }
+
   HSelect* MakeSelect(HBasicBlock* block,
                       HInstruction* condition,
                       HInstruction* true_value,
@@ -832,6 +928,10 @@ class OptimizingUnitTestHelper {
   size_t class_idx_ = 42;
   uint32_t method_idx_ = 100;
 
+  // The default size of vectors to use for tests, in bytes. 16 bytes (128 bits) is used as it is
+  // commonly the smallest size of vector used in vector extensions.
+  static constexpr size_t kDefaultTestVectorSizeInBytes = 16;
+
   ScopedNullHandle<mirror::Class> null_klass_;
 };
 
diff --git a/compiler/optimizing/prepare_for_register_allocation.cc b/compiler/optimizing/prepare_for_register_allocation.cc
index 1e99732d03..1eb340a9b4 100644
--- a/compiler/optimizing/prepare_for_register_allocation.cc
+++ b/compiler/optimizing/prepare_for_register_allocation.cc
@@ -19,37 +19,69 @@
 #include "dex/dex_file_types.h"
 #include "driver/compiler_options.h"
 #include "jni/jni_internal.h"
+#include "nodes.h"
 #include "optimizing_compiler_stats.h"
 #include "well_known_classes.h"
 
 namespace art HIDDEN {
 
-void PrepareForRegisterAllocation::Run() {
+class PrepareForRegisterAllocationVisitor final : public HGraphDelegateVisitor {
+ public:
+  PrepareForRegisterAllocationVisitor(HGraph* graph,
+                                      const CompilerOptions& compiler_options,
+                                      OptimizingCompilerStats* stats)
+      : HGraphDelegateVisitor(graph, stats),
+        compiler_options_(compiler_options) {}
+
+ private:
+  void VisitCheckCast(HCheckCast* check_cast) override;
+  void VisitInstanceOf(HInstanceOf* instance_of) override;
+  void VisitNullCheck(HNullCheck* check) override;
+  void VisitDivZeroCheck(HDivZeroCheck* check) override;
+  void VisitBoundsCheck(HBoundsCheck* check) override;
+  void VisitBoundType(HBoundType* bound_type) override;
+  void VisitArraySet(HArraySet* instruction) override;
+  void VisitClinitCheck(HClinitCheck* check) override;
+  void VisitCondition(HCondition* condition) override;
+  void VisitConstructorFence(HConstructorFence* constructor_fence) override;
+  void VisitInvokeStaticOrDirect(HInvokeStaticOrDirect* invoke) override;
+  void VisitDeoptimize(HDeoptimize* deoptimize) override;
+  void VisitTypeConversion(HTypeConversion* instruction) override;
+
+  bool CanMoveClinitCheck(HInstruction* input, HInstruction* user) const;
+  bool CanEmitConditionAt(HCondition* condition, HInstruction* user) const;
+
+  const CompilerOptions& compiler_options_;
+};
+
+bool PrepareForRegisterAllocation::Run() {
+  PrepareForRegisterAllocationVisitor visitor(graph_, compiler_options_, stats_);
   // Order does not matter.
-  for (HBasicBlock* block : GetGraph()->GetReversePostOrder()) {
+  for (HBasicBlock* block : graph_->GetReversePostOrder()) {
     // No need to visit the phis.
     for (HInstructionIteratorHandleChanges inst_it(block->GetInstructions()); !inst_it.Done();
          inst_it.Advance()) {
-      inst_it.Current()->Accept(this);
+      inst_it.Current()->Accept(&visitor);
     }
   }
+  return true;
 }
 
-void PrepareForRegisterAllocation::VisitCheckCast(HCheckCast* check_cast) {
+void PrepareForRegisterAllocationVisitor::VisitCheckCast(HCheckCast* check_cast) {
   // Record only those bitstring type checks that make it to the codegen stage.
   if (check_cast->GetTypeCheckKind() == TypeCheckKind::kBitstringCheck) {
     MaybeRecordStat(stats_, MethodCompilationStat::kBitstringTypeCheck);
   }
 }
 
-void PrepareForRegisterAllocation::VisitInstanceOf(HInstanceOf* instance_of) {
+void PrepareForRegisterAllocationVisitor::VisitInstanceOf(HInstanceOf* instance_of) {
   // Record only those bitstring type checks that make it to the codegen stage.
   if (instance_of->GetTypeCheckKind() == TypeCheckKind::kBitstringCheck) {
     MaybeRecordStat(stats_, MethodCompilationStat::kBitstringTypeCheck);
   }
 }
 
-void PrepareForRegisterAllocation::VisitNullCheck(HNullCheck* check) {
+void PrepareForRegisterAllocationVisitor::VisitNullCheck(HNullCheck* check) {
   check->ReplaceWith(check->InputAt(0));
   if (compiler_options_.GetImplicitNullChecks()) {
     HInstruction* next = check->GetNext();
@@ -66,11 +98,11 @@ void PrepareForRegisterAllocation::VisitNullCheck(HNullCheck* check) {
   }
 }
 
-void PrepareForRegisterAllocation::VisitDivZeroCheck(HDivZeroCheck* check) {
+void PrepareForRegisterAllocationVisitor::VisitDivZeroCheck(HDivZeroCheck* check) {
   check->ReplaceWith(check->InputAt(0));
 }
 
-void PrepareForRegisterAllocation::VisitDeoptimize(HDeoptimize* deoptimize) {
+void PrepareForRegisterAllocationVisitor::VisitDeoptimize(HDeoptimize* deoptimize) {
   if (deoptimize->GuardsAnInput()) {
     // Replace the uses with the actual guarded instruction.
     deoptimize->ReplaceWith(deoptimize->GuardedInput());
@@ -78,7 +110,7 @@ void PrepareForRegisterAllocation::VisitDeoptimize(HDeoptimize* deoptimize) {
   }
 }
 
-void PrepareForRegisterAllocation::VisitBoundsCheck(HBoundsCheck* check) {
+void PrepareForRegisterAllocationVisitor::VisitBoundsCheck(HBoundsCheck* check) {
   check->ReplaceWith(check->InputAt(0));
   if (check->IsStringCharAt()) {
     // Add a fake environment for String.charAt() inline info as we want the exception
@@ -86,24 +118,24 @@ void PrepareForRegisterAllocation::VisitBoundsCheck(HBoundsCheck* check) {
     ArtMethod* char_at_method = WellKnownClasses::java_lang_String_charAt;
     if (GetGraph()->GetArtMethod() != char_at_method) {
       ArenaAllocator* allocator = GetGraph()->GetAllocator();
-      HEnvironment* environment = new (allocator) HEnvironment(allocator,
-                                                               /* number_of_vregs= */ 0u,
-                                                               char_at_method,
-                                                               /* dex_pc= */ dex::kDexNoIndex,
-                                                               check);
+      HEnvironment* environment = HEnvironment::Create(allocator,
+                                                       /* number_of_vregs= */ 0u,
+                                                       char_at_method,
+                                                       /* dex_pc= */ dex::kDexNoIndex,
+                                                       check);
       check->InsertRawEnvironment(environment);
     }
   }
 }
 
-void PrepareForRegisterAllocation::VisitBoundType(HBoundType* bound_type) {
+void PrepareForRegisterAllocationVisitor::VisitBoundType(HBoundType* bound_type) {
   bound_type->ReplaceWith(bound_type->InputAt(0));
   bound_type->GetBlock()->RemoveInstruction(bound_type);
 }
 
-void PrepareForRegisterAllocation::VisitArraySet(HArraySet* instruction) {
+void PrepareForRegisterAllocationVisitor::VisitArraySet(HArraySet* instruction) {
   HInstruction* value = instruction->GetValue();
-  // PrepareForRegisterAllocation::VisitBoundType may have replaced a
+  // PrepareForRegisterAllocationVisitor::VisitBoundType may have replaced a
   // BoundType (as value input of this ArraySet) with a NullConstant.
   // If so, this ArraySet no longer needs a type check.
   if (value->IsNullConstant()) {
@@ -114,7 +146,7 @@ void PrepareForRegisterAllocation::VisitArraySet(HArraySet* instruction) {
   }
 }
 
-void PrepareForRegisterAllocation::VisitClinitCheck(HClinitCheck* check) {
+void PrepareForRegisterAllocationVisitor::VisitClinitCheck(HClinitCheck* check) {
   // Try to find a static invoke or a new-instance from which this check originated.
   HInstruction* implicit_clinit = nullptr;
   for (const HUseListNode<HInstruction*>& use : check->GetUses()) {
@@ -174,8 +206,8 @@ void PrepareForRegisterAllocation::VisitClinitCheck(HClinitCheck* check) {
   }
 }
 
-bool PrepareForRegisterAllocation::CanEmitConditionAt(HCondition* condition,
-                                                      HInstruction* user) const {
+bool PrepareForRegisterAllocationVisitor::CanEmitConditionAt(HCondition* condition,
+                                                             HInstruction* user) const {
   if (condition->GetNext() != user) {
     return false;
   }
@@ -196,7 +228,7 @@ bool PrepareForRegisterAllocation::CanEmitConditionAt(HCondition* condition,
   return false;
 }
 
-void PrepareForRegisterAllocation::VisitCondition(HCondition* condition) {
+void PrepareForRegisterAllocationVisitor::VisitCondition(HCondition* condition) {
   if (condition->HasOnlyOneNonEnvironmentUse()) {
     HInstruction* user = condition->GetUses().front().GetUser();
     if (CanEmitConditionAt(condition, user)) {
@@ -205,7 +237,8 @@ void PrepareForRegisterAllocation::VisitCondition(HCondition* condition) {
   }
 }
 
-void PrepareForRegisterAllocation::VisitConstructorFence(HConstructorFence* constructor_fence) {
+void PrepareForRegisterAllocationVisitor::VisitConstructorFence(
+    HConstructorFence* constructor_fence) {
   // Trivially remove redundant HConstructorFence when it immediately follows an HNewInstance
   // to an uninitialized class. In this special case, the art_quick_alloc_object_resolved
   // will already have the 'dmb' which is strictly stronger than an HConstructorFence.
@@ -245,7 +278,8 @@ void PrepareForRegisterAllocation::VisitConstructorFence(HConstructorFence* cons
   constructor_fence->RemoveAllInputs();
 }
 
-void PrepareForRegisterAllocation::VisitInvokeStaticOrDirect(HInvokeStaticOrDirect* invoke) {
+void PrepareForRegisterAllocationVisitor::VisitInvokeStaticOrDirect(
+    HInvokeStaticOrDirect* invoke) {
   if (invoke->IsStaticWithExplicitClinitCheck()) {
     HInstruction* last_input = invoke->GetInputs().back();
     DCHECK(last_input->IsLoadClass())
@@ -261,8 +295,8 @@ void PrepareForRegisterAllocation::VisitInvokeStaticOrDirect(HInvokeStaticOrDire
   }
 }
 
-bool PrepareForRegisterAllocation::CanMoveClinitCheck(HInstruction* input,
-                                                      HInstruction* user) const {
+bool PrepareForRegisterAllocationVisitor::CanMoveClinitCheck(HInstruction* input,
+                                                             HInstruction* user) const {
   // Determine if input and user come from the same dex instruction, so that we can move
   // the clinit check responsibility from one to the other, i.e. from HClinitCheck (user)
   // to HLoadClass (input), or from HClinitCheck (input) to HInvokeStaticOrDirect (user),
@@ -313,7 +347,7 @@ bool PrepareForRegisterAllocation::CanMoveClinitCheck(HInstruction* input,
   return true;
 }
 
-void PrepareForRegisterAllocation::VisitTypeConversion(HTypeConversion* instruction) {
+void PrepareForRegisterAllocationVisitor::VisitTypeConversion(HTypeConversion* instruction) {
   // For simplicity, our code generators don't handle implicit type conversion, so ensure
   // there are none before hitting codegen.
   if (instruction->IsImplicitConversion()) {
diff --git a/compiler/optimizing/prepare_for_register_allocation.h b/compiler/optimizing/prepare_for_register_allocation.h
index f53c8a1285..1c312a3e9c 100644
--- a/compiler/optimizing/prepare_for_register_allocation.h
+++ b/compiler/optimizing/prepare_for_register_allocation.h
@@ -18,7 +18,7 @@
 #define ART_COMPILER_OPTIMIZING_PREPARE_FOR_REGISTER_ALLOCATION_H_
 
 #include "base/macros.h"
-#include "nodes.h"
+#include "optimization.h"
 
 namespace art HIDDEN {
 
@@ -30,37 +30,20 @@ class OptimizingCompilerStats;
  * For example it changes uses of null checks and bounds checks to the original
  * objects, to avoid creating a live range for these checks.
  */
-class PrepareForRegisterAllocation final : public HGraphDelegateVisitor {
+class PrepareForRegisterAllocation final : public HOptimization {
  public:
   PrepareForRegisterAllocation(HGraph* graph,
                                const CompilerOptions& compiler_options,
                                OptimizingCompilerStats* stats = nullptr)
-      : HGraphDelegateVisitor(graph, stats),
+      : HOptimization(graph, kPrepareForRegisterAllocationPassName, stats),
         compiler_options_(compiler_options) {}
 
-  void Run();
+  bool Run() override;
 
   static constexpr const char* kPrepareForRegisterAllocationPassName =
       "prepare_for_register_allocation";
 
  private:
-  void VisitCheckCast(HCheckCast* check_cast) override;
-  void VisitInstanceOf(HInstanceOf* instance_of) override;
-  void VisitNullCheck(HNullCheck* check) override;
-  void VisitDivZeroCheck(HDivZeroCheck* check) override;
-  void VisitBoundsCheck(HBoundsCheck* check) override;
-  void VisitBoundType(HBoundType* bound_type) override;
-  void VisitArraySet(HArraySet* instruction) override;
-  void VisitClinitCheck(HClinitCheck* check) override;
-  void VisitCondition(HCondition* condition) override;
-  void VisitConstructorFence(HConstructorFence* constructor_fence) override;
-  void VisitInvokeStaticOrDirect(HInvokeStaticOrDirect* invoke) override;
-  void VisitDeoptimize(HDeoptimize* deoptimize) override;
-  void VisitTypeConversion(HTypeConversion* instruction) override;
-
-  bool CanMoveClinitCheck(HInstruction* input, HInstruction* user) const;
-  bool CanEmitConditionAt(HCondition* condition, HInstruction* user) const;
-
   const CompilerOptions& compiler_options_;
 
   DISALLOW_COPY_AND_ASSIGN(PrepareForRegisterAllocation);
diff --git a/compiler/optimizing/reference_type_info.cc b/compiler/optimizing/reference_type_info.cc
new file mode 100644
index 0000000000..767384482c
--- /dev/null
+++ b/compiler/optimizing/reference_type_info.cc
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "reference_type_info.h"
+
+#include "scoped_thread_state_change-inl.h"
+#include "thread-current-inl.h"
+
+namespace art HIDDEN {
+
+void ReferenceTypeInfo::DCheckValidTypeInfo(TypeHandle type_handle, bool is_exact) {
+  if (kIsDebugBuild) {
+    ScopedObjectAccess soa(Thread::Current());
+    CHECK(IsValidHandle(type_handle));
+    if (!is_exact) {
+      CHECK(!type_handle->CannotBeAssignedFromOtherTypes())
+          << "Callers of ReferenceTypeInfo::Create should ensure is_exact is properly computed";
+    }
+  }
+}
+
+std::ostream& operator<<(std::ostream& os, const ReferenceTypeInfo& rhs) {
+  ScopedObjectAccess soa(Thread::Current());
+  os << "["
+     << " is_valid=" << rhs.IsValid()
+     << " type=" << (!rhs.IsValid() ? "?" : mirror::Class::PrettyClass(rhs.GetTypeHandle().Get()))
+     << " is_exact=" << rhs.IsExact()
+     << " ]";
+  return os;
+}
+
+}  // namespace art
diff --git a/compiler/optimizing/reference_type_info.h b/compiler/optimizing/reference_type_info.h
new file mode 100644
index 0000000000..b7d534bdcd
--- /dev/null
+++ b/compiler/optimizing/reference_type_info.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_COMPILER_OPTIMIZING_REFERENCE_TYPE_INFO_H_
+#define ART_COMPILER_OPTIMIZING_REFERENCE_TYPE_INFO_H_
+
+#include <iosfwd>
+
+#include "base/globals.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/value_object.h"
+#include "handle.h"
+#include "mirror/class-inl.h"
+
+namespace art HIDDEN {
+
+class ReferenceTypeInfo : ValueObject {
+ public:
+  using TypeHandle = Handle<mirror::Class>;
+
+  static ReferenceTypeInfo Create(TypeHandle type_handle, bool is_exact) {
+    if (kIsDebugBuild) {
+      DCheckValidTypeInfo(type_handle, is_exact);
+    }
+    return ReferenceTypeInfo(type_handle, is_exact);
+  }
+
+  static ReferenceTypeInfo Create(TypeHandle type_handle) REQUIRES_SHARED(Locks::mutator_lock_) {
+    return Create(type_handle, type_handle->CannotBeAssignedFromOtherTypes());
+  }
+
+  static ReferenceTypeInfo CreateUnchecked(TypeHandle type_handle, bool is_exact) {
+    return ReferenceTypeInfo(type_handle, is_exact);
+  }
+
+  static ReferenceTypeInfo CreateInvalid() { return ReferenceTypeInfo(); }
+
+  static bool IsValidHandle(TypeHandle handle) {
+    return handle.GetReference() != nullptr;
+  }
+
+  bool IsValid() const {
+    return IsValidHandle(type_handle_);
+  }
+
+  bool IsExact() const { return is_exact_; }
+
+  bool IsObjectClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return GetTypeHandle()->IsObjectClass();
+  }
+
+  bool IsStringClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return GetTypeHandle()->IsStringClass();
+  }
+
+  bool IsObjectArray() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return IsArrayClass() && GetTypeHandle()->GetComponentType()->IsObjectClass();
+  }
+
+  bool IsInterface() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return GetTypeHandle()->IsInterface();
+  }
+
+  bool IsArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return GetTypeHandle()->IsArrayClass();
+  }
+
+  bool IsPrimitiveArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return GetTypeHandle()->IsPrimitiveArray();
+  }
+
+  bool IsNonPrimitiveArrayClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    return IsArrayClass() && !GetTypeHandle()->IsPrimitiveArray();
+  }
+
+  bool CanArrayHold(ReferenceTypeInfo rti)  const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    if (!IsExact()) return false;
+    if (!IsArrayClass()) return false;
+    return GetTypeHandle()->GetComponentType()->IsAssignableFrom(rti.GetTypeHandle().Get());
+  }
+
+  bool CanArrayHoldValuesOf(ReferenceTypeInfo rti)  const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    if (!IsExact()) return false;
+    if (!IsArrayClass()) return false;
+    if (!rti.IsArrayClass()) return false;
+    return GetTypeHandle()->GetComponentType()->IsAssignableFrom(
+        rti.GetTypeHandle()->GetComponentType());
+  }
+
+  Handle<mirror::Class> GetTypeHandle() const { return type_handle_; }
+
+  bool IsSupertypeOf(ReferenceTypeInfo rti) const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(IsValid());
+    DCHECK(rti.IsValid());
+    return GetTypeHandle()->IsAssignableFrom(rti.GetTypeHandle().Get());
+  }
+
+  // Returns true if the type information provide the same amount of details.
+  // Note that it does not mean that the instructions have the same actual type
+  // (because the type can be the result of a merge).
+  bool IsEqual(ReferenceTypeInfo rti) const REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (!IsValid() && !rti.IsValid()) {
+      // Invalid types are equal.
+      return true;
+    }
+    if (!IsValid() || !rti.IsValid()) {
+      // One is valid, the other not.
+      return false;
+    }
+    return IsExact() == rti.IsExact() && GetTypeHandle().Get() == rti.GetTypeHandle().Get();
+  }
+
+ private:
+  ReferenceTypeInfo() : type_handle_(TypeHandle()), is_exact_(false) {}
+  ReferenceTypeInfo(TypeHandle type_handle, bool is_exact)
+      : type_handle_(type_handle), is_exact_(is_exact) { }
+
+  static void DCheckValidTypeInfo(TypeHandle type_handle, bool is_exact);
+
+  // The class of the object.
+  TypeHandle type_handle_;
+  // Whether or not the type is exact or a superclass of the actual type.
+  // Whether or not we have any information about this type.
+  bool is_exact_;
+};
+
+std::ostream& operator<<(std::ostream& os, const ReferenceTypeInfo& rhs);
+
+}  // namespace art
+
+#endif  // ART_COMPILER_OPTIMIZING_REFERENCE_TYPE_INFO_H_
diff --git a/compiler/optimizing/reference_type_propagation.cc b/compiler/optimizing/reference_type_propagation.cc
index 14017088c2..1eef0ce6d5 100644
--- a/compiler/optimizing/reference_type_propagation.cc
+++ b/compiler/optimizing/reference_type_propagation.cc
@@ -24,6 +24,7 @@
 #include "base/scoped_arena_containers.h"
 #include "class_linker-inl.h"
 #include "class_root-inl.h"
+#include "handle_cache-inl.h"
 #include "handle_scope-inl.h"
 #include "mirror/class-inl.h"
 #include "mirror/dex_cache.h"
@@ -501,8 +502,7 @@ void ReferenceTypePropagation::RTPVisitor::SetClassAsTypeInfo(HInstruction* inst
           hs.NewHandle(FindDexCacheWithHint(self, dex_file, hint_dex_cache_)));
       // Use a null loader, the target method is in a boot classpath dex file.
       Handle<mirror::ClassLoader> loader(hs.NewHandle<mirror::ClassLoader>(nullptr));
-      ArtMethod* method = cl->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(
-          dex_method_index, dex_cache, loader, /* referrer= */ nullptr, kDirect);
+      ArtMethod* method = cl->ResolveMethodId(dex_method_index, dex_cache, loader);
       DCHECK(method != nullptr);
       ObjPtr<mirror::Class> declaring_class = method->GetDeclaringClass();
       DCHECK(declaring_class != nullptr);
@@ -749,17 +749,12 @@ void ReferenceTypePropagation::RTPVisitor::VisitPhi(HPhi* phi) {
   }
 }
 
-void ReferenceTypePropagation::FixUpInstructionType(HInstruction* instruction,
-                                                    HandleCache* handle_cache) {
-  if (instruction->IsSelect()) {
-    ScopedObjectAccess soa(Thread::Current());
-    HSelect* select = instruction->AsSelect();
-    ReferenceTypeInfo false_rti = select->GetFalseValue()->GetReferenceTypeInfo();
-    ReferenceTypeInfo true_rti = select->GetTrueValue()->GetReferenceTypeInfo();
-    select->SetReferenceTypeInfo(MergeTypes(false_rti, true_rti, handle_cache));
-  } else {
-    LOG(FATAL) << "Invalid instruction in FixUpInstructionType";
-  }
+void ReferenceTypePropagation::FixUpSelectType(HSelect* select, HandleCache* handle_cache) {
+  ReferenceTypeInfo false_rti = select->GetFalseValue()->GetReferenceTypeInfo();
+  ReferenceTypeInfo true_rti = select->GetTrueValue()->GetReferenceTypeInfo();
+  ReferenceTypeInfo rti = ReferenceTypeInfo::CreateInvalid();
+  ScopedObjectAccess soa(Thread::Current());
+  select->SetReferenceTypeInfo(MergeTypes(false_rti, true_rti, handle_cache));
 }
 
 ReferenceTypeInfo ReferenceTypePropagation::MergeTypes(const ReferenceTypeInfo& a,
diff --git a/compiler/optimizing/reference_type_propagation.h b/compiler/optimizing/reference_type_propagation.h
index 655f62b3da..773f603db1 100644
--- a/compiler/optimizing/reference_type_propagation.h
+++ b/compiler/optimizing/reference_type_propagation.h
@@ -26,6 +26,8 @@
 
 namespace art HIDDEN {
 
+class HandleCache;
+
 /**
  * Propagates reference types to instructions.
  */
@@ -58,10 +60,10 @@ class ReferenceTypePropagation : public HOptimization {
 
   static constexpr const char* kReferenceTypePropagationPassName = "reference_type_propagation";
 
-  // Fix the reference type for an instruction whose inputs have changed.
-  // For a select instruction, the reference types of the inputs are merged
-  // and the resulting reference type is set on the select instruction.
-  static void FixUpInstructionType(HInstruction* instruction, HandleCache* handle_cache);
+  // Fix the reference type for an HSelect instruction whose inputs have changed. The reference
+  // types of the inputs are merged and the resulting reference type is set on the HSelect
+  // instruction.
+  static void FixUpSelectType(HSelect* select, HandleCache* handle_cache);
 
  private:
   class RTPVisitor;
diff --git a/compiler/optimizing/register_allocator_linear_scan.cc b/compiler/optimizing/register_allocator_linear_scan.cc
index 458d1a740e..35a0ab404e 100644
--- a/compiler/optimizing/register_allocator_linear_scan.cc
+++ b/compiler/optimizing/register_allocator_linear_scan.cc
@@ -79,11 +79,6 @@ RegisterAllocatorLinearScan::RegisterAllocatorLinearScan(ScopedArenaAllocator* a
   codegen->SetupBlockedRegisters();
   physical_core_register_intervals_.resize(codegen->GetNumberOfCoreRegisters(), nullptr);
   physical_fp_register_intervals_.resize(codegen->GetNumberOfFloatingPointRegisters(), nullptr);
-  // Always reserve for the current method and the graph's max out registers.
-  // TODO: compute it instead.
-  // ArtMethod* takes 2 vregs for 64 bits.
-  size_t ptr_size = static_cast<size_t>(InstructionSetPointerSize(codegen->GetInstructionSet()));
-  reserved_out_slots_ = ptr_size / kVRegSize + codegen->GetGraph()->GetMaximumNumberOfOutVRegs();
 }
 
 RegisterAllocatorLinearScan::~RegisterAllocatorLinearScan() {}
@@ -181,6 +176,10 @@ void RegisterAllocatorLinearScan::AllocateRegistersInternal() {
     }
   }
 
+  // Add the current method to the `reserved_out_slots_`. ArtMethod* takes 2 vregs for 64 bits.
+  PointerSize pointer_size = InstructionSetPointerSize(codegen_->GetInstructionSet());
+  reserved_out_slots_ += static_cast<size_t>(pointer_size) / kVRegSize;
+
   number_of_registers_ = codegen_->GetNumberOfCoreRegisters();
   registers_array_ = allocator_->AllocArray<size_t>(number_of_registers_,
                                                     kArenaAllocRegisterAllocator);
@@ -247,6 +246,17 @@ void RegisterAllocatorLinearScan::ProcessInstruction(HInstruction* instruction)
     return;
   }
 
+  if (locations->CanCall()) {
+    // Update the `reserved_out_slots_` for invokes that make a call, including intrinsics
+    // that make the call only on the slow-path. Same for the `HStringBuilderAppend`.
+    if (instruction->IsInvoke()) {
+      reserved_out_slots_ = std::max<size_t>(
+          reserved_out_slots_, instruction->AsInvoke()->GetNumberOfOutVRegs());
+    } else if (instruction->IsStringBuilderAppend()) {
+      reserved_out_slots_ = std::max<size_t>(
+          reserved_out_slots_, instruction->AsStringBuilderAppend()->GetNumberOfOutVRegs());
+    }
+  }
   bool will_call = locations->WillCall();
   if (will_call) {
     // If a call will happen, add the range to a fixed interval that represents all the
diff --git a/compiler/optimizing/scheduler_test.cc b/compiler/optimizing/scheduler_test.cc
index f613e0a9e2..7003bd2715 100644
--- a/compiler/optimizing/scheduler_test.cc
+++ b/compiler/optimizing/scheduler_test.cc
@@ -58,7 +58,7 @@ static ::std::vector<CodegenTargetConfig> GetTargetConfigs() {
   };
 
   for (const CodegenTargetConfig& test_config : test_config_candidates) {
-    if (CanExecute(test_config.GetInstructionSet())) {
+    if (CanExecuteISA(test_config.GetInstructionSet())) {
       v.push_back(test_config);
     }
   }
@@ -111,11 +111,11 @@ class SchedulerTest : public CommonCompilerTest, public OptimizingUnitTestHelper
 
     DCHECK(div_check->CanThrow());
 
-    HEnvironment* environment = new (GetAllocator()) HEnvironment(GetAllocator(),
-                                                                  2,
-                                                                  graph_->GetArtMethod(),
-                                                                  0,
-                                                                  div_check);
+    HEnvironment* environment = HEnvironment::Create(GetAllocator(),
+                                                     /*number_of_vregs=*/ 2,
+                                                     graph_->GetArtMethod(),
+                                                     /*dex_pc=*/ 0,
+                                                     div_check);
     div_check->SetRawEnvironment(environment);
     environment->SetRawEnvAt(0, add2);
     add2->AddEnvUseAt(div_check->GetEnvironment(), 0);
diff --git a/compiler/optimizing/select_generator.cc b/compiler/optimizing/select_generator.cc
index 07065efbb7..d5781c8d38 100644
--- a/compiler/optimizing/select_generator.cc
+++ b/compiler/optimizing/select_generator.cc
@@ -156,7 +156,7 @@ bool HSelectGenerator::TryGenerateSelectSimpleDiamondPattern(
   if (both_successors_return) {
     if (true_value->GetType() == DataType::Type::kReference) {
       DCHECK(false_value->GetType() == DataType::Type::kReference);
-      ReferenceTypePropagation::FixUpInstructionType(select, graph_->GetHandleCache());
+      ReferenceTypePropagation::FixUpSelectType(select, graph_->GetHandleCache());
     }
   } else if (phi->GetType() == DataType::Type::kReference) {
     select->SetReferenceTypeInfoIfValid(phi->GetReferenceTypeInfo());
diff --git a/compiler/optimizing/sharpening.cc b/compiler/optimizing/sharpening.cc
index 1b6a9fb601..75efb19722 100644
--- a/compiler/optimizing/sharpening.cc
+++ b/compiler/optimizing/sharpening.cc
@@ -48,8 +48,10 @@ static bool IsInBootImage(ArtMethod* method) {
   return heap->IsBootImageAddress(method);
 }
 
-static bool BootImageAOTCanEmbedMethod(ArtMethod* method, const CompilerOptions& compiler_options) {
-  DCHECK(compiler_options.IsBootImage() || compiler_options.IsBootImageExtension());
+static bool ImageAOTCanEmbedMethod(ArtMethod* method, const CompilerOptions& compiler_options) {
+  DCHECK(compiler_options.IsBootImage() ||
+         compiler_options.IsBootImageExtension() ||
+         compiler_options.IsAppImage());
   ScopedObjectAccess soa(Thread::Current());
   ObjPtr<mirror::Class> klass = method->GetDeclaringClass();
   DCHECK(klass != nullptr);
@@ -103,7 +105,7 @@ HInvokeStaticOrDirect::DispatchInfo HSharpening::SharpenLoadMethod(
     } else if (IsInBootImage(callee)) {
       DCHECK(compiler_options.IsBootImageExtension());
       method_load_kind = MethodLoadKind::kBootImageRelRo;
-    } else if (BootImageAOTCanEmbedMethod(callee, compiler_options)) {
+    } else if (ImageAOTCanEmbedMethod(callee, compiler_options)) {
       method_load_kind = MethodLoadKind::kBootImageLinkTimePcRelative;
     } else if (!has_method_id) {
       method_load_kind = MethodLoadKind::kRuntimeCall;
@@ -135,8 +137,13 @@ HInvokeStaticOrDirect::DispatchInfo HSharpening::SharpenLoadMethod(
     code_ptr_location = CodePtrLocation::kCallArtMethod;
   } else {
     DCHECK(!callee->IsCopied());
-    // Use PC-relative access to the .bss methods array.
-    method_load_kind = MethodLoadKind::kBssEntry;
+    if (compiler_options.IsAppImage() && ImageAOTCanEmbedMethod(callee, compiler_options)) {
+      // Use PC-relative access to the .data.img.rel.ro app image methods array.
+      method_load_kind = MethodLoadKind::kAppImageRelRo;
+    } else {
+      // Use PC-relative access to the .bss methods array.
+      method_load_kind = MethodLoadKind::kBssEntry;
+    }
     code_ptr_location = CodePtrLocation::kCallArtMethod;
   }
 
diff --git a/compiler/optimizing/superblock_cloner.cc b/compiler/optimizing/superblock_cloner.cc
index e14f7347fb..276d2246cb 100644
--- a/compiler/optimizing/superblock_cloner.cc
+++ b/compiler/optimizing/superblock_cloner.cc
@@ -134,7 +134,7 @@ void SuperblockCloner::DeepCloneEnvironmentWithRemapping(HInstruction* copy_inst
   if (orig_env->GetParent() != nullptr) {
     DeepCloneEnvironmentWithRemapping(copy_instr, orig_env->GetParent());
   }
-  HEnvironment* copy_env = new (arena_) HEnvironment(arena_, *orig_env, copy_instr);
+  HEnvironment* copy_env = HEnvironment::Create(arena_, *orig_env, copy_instr);
 
   for (size_t i = 0; i < orig_env->Size(); i++) {
     HInstruction* env_input = orig_env->GetInstructionAt(i);
@@ -882,6 +882,18 @@ bool SuperblockCloner::IsSubgraphClonable() const {
     return false;
   }
 
+  // The values in live_outs should be defined in a block that dominates exit_block.
+  for (const auto& live_out : live_outs) {
+    DCHECK_EQ(exits.size(), 1u);
+    HInstruction* value = live_out.first;
+    if (!value->GetBlock()->Dominates(exits[0])) {
+      // This case can only happen when `value` is used in a catch phi, so the graph must contain a
+      // catch block.
+      DCHECK(graph_->HasTryCatch());
+      return false;
+    }
+  }
+
   return true;
 }
 
@@ -959,7 +971,8 @@ void SuperblockCloner::Run() {
     DumpInputSets();
   }
 
-  CollectLiveOutsAndCheckClonable(&live_outs_);
+  bool result = CollectLiveOutsAndCheckClonable(&live_outs_);
+  DCHECK(result);
   // Find an area in the graph for which control flow information should be adjusted.
   FindAndSetLocalAreaForAdjustments();
   ConstructSubgraphClosedSSA();
@@ -997,21 +1010,13 @@ void SuperblockCloner::CleanUp() {
   // transformation it could happen that there is such block with a phi with a single input.
   // As this is needed to be processed we also simplify phis with multiple same inputs here.
   for (auto entry : *bb_map_) {
-    HBasicBlock* orig_block = entry.first;
-    for (HInstructionIterator inst_it(orig_block->GetPhis()); !inst_it.Done(); inst_it.Advance()) {
-      HPhi* phi = inst_it.Current()->AsPhi();
-      if (ArePhiInputsTheSame(phi)) {
-        phi->ReplaceWith(phi->InputAt(0));
-        orig_block->RemovePhi(phi);
-      }
-    }
-
-    HBasicBlock* copy_block = GetBlockCopy(orig_block);
-    for (HInstructionIterator inst_it(copy_block->GetPhis()); !inst_it.Done(); inst_it.Advance()) {
-      HPhi* phi = inst_it.Current()->AsPhi();
-      if (ArePhiInputsTheSame(phi)) {
-        phi->ReplaceWith(phi->InputAt(0));
-        copy_block->RemovePhi(phi);
+    for (HBasicBlock* block : {entry.first, entry.second}) {
+      for (HInstructionIterator inst_it(block->GetPhis()); !inst_it.Done(); inst_it.Advance()) {
+        HPhi* phi = inst_it.Current()->AsPhi();
+        if (ArePhiInputsTheSame(phi)) {
+          phi->ReplaceWith(phi->InputAt(0));
+          block->RemovePhi(phi);
+        }
       }
     }
   }
diff --git a/compiler/optimizing/superblock_cloner.h b/compiler/optimizing/superblock_cloner.h
index 421701fb19..c327867342 100644
--- a/compiler/optimizing/superblock_cloner.h
+++ b/compiler/optimizing/superblock_cloner.h
@@ -132,7 +132,7 @@ inline bool IsEdgeValid(HEdge edge, HGraph* graph) {
 //        (X, Y_1)).
 // 3. Adjust control flow structures and relations (dominance, reverse post order, loops, etc).
 // 4. Fix/resolve data flow.
-// 5. Do cleanups (DCE, critical edges splitting, etc).
+// 5. Do cleanups e.g. critical edges splitting.
 //
 class SuperblockCloner : public ValueObject {
  public:
diff --git a/compiler/utils/x86_64/assembler_x86_64.cc b/compiler/utils/x86_64/assembler_x86_64.cc
index 89a1d0923a..91bc4fe6e3 100644
--- a/compiler/utils/x86_64/assembler_x86_64.cc
+++ b/compiler/utils/x86_64/assembler_x86_64.cc
@@ -4265,6 +4265,7 @@ void X86_64Assembler::andl(CpuRegister reg, const Address& address) {
 
 void X86_64Assembler::andl(CpuRegister dst, const Immediate& imm) {
   AssemblerBuffer::EnsureCapacity ensured(&buffer_);
+  CHECK(imm.is_int32());  // andl only supports 32b immediate.
   EmitOptionalRex32(dst);
   EmitComplex(4, Operand(dst), imm);
 }
diff --git a/dalvikvm/Android.bp b/dalvikvm/Android.bp
index 233a2891f9..1ab408c484 100644
--- a/dalvikvm/Android.bp
+++ b/dalvikvm/Android.bp
@@ -33,7 +33,7 @@ art_cc_binary {
     srcs: ["dalvikvm.cc"],
     shared_libs: [
         "liblog",
-        "libnativehelper",
+        "libnativehelper#impl",
     ],
     header_libs: [
         "art_libartbase_headers", // For base/fast_exit.h
diff --git a/dex2oat/Android.bp b/dex2oat/Android.bp
index ab68831890..76620b8429 100644
--- a/dex2oat/Android.bp
+++ b/dex2oat/Android.bp
@@ -261,7 +261,7 @@ art_cc_binary {
             shared_libs: [
                 "libart",
                 "libartbase",
-                "libdexfile",
+                "libdexfile#impl",
                 "libprofile",
             ],
             static_libs: [
@@ -327,7 +327,7 @@ art_cc_binary {
             shared_libs: [
                 "libartbased",
                 "libartd",
-                "libdexfiled",
+                "libdexfiled#impl",
                 "libprofiled",
             ],
             static_libs: [
@@ -426,7 +426,7 @@ art_cc_library_static {
 
 art_cc_defaults {
     name: "art_dex2oat_tests_defaults",
-    data: [
+    device_common_data: [
         ":art-gtest-jars-AbstractMethod",
         ":art-gtest-jars-ArrayClassWithUnresolvedComponent",
         ":art-gtest-jars-DefaultMethods",
@@ -483,7 +483,10 @@ art_cc_defaults {
     ],
     target: {
         host: {
-            required: ["dex2oatd"],
+            required: [
+                "dex2oatd",
+                "art_boot_images",
+            ],
         },
     },
 
diff --git a/dex2oat/dex2oat.cc b/dex2oat/dex2oat.cc
index 06d3770abd..a8d3d9346c 100644
--- a/dex2oat/dex2oat.cc
+++ b/dex2oat/dex2oat.cc
@@ -1276,9 +1276,9 @@ class Dex2Oat final {
         }
 
         DCHECK_EQ(output_vdex_fd_, -1);
-        std::string vdex_filename = output_vdex_.empty()
-            ? ReplaceFileExtension(oat_filename, "vdex")
-            : output_vdex_;
+        std::string vdex_filename = output_vdex_.empty() ?
+                                        ReplaceFileExtension(oat_filename, kVdexExtension) :
+                                        output_vdex_;
         if (vdex_filename == input_vdex_ && output_vdex_.empty()) {
           use_existing_vdex_ = true;
           std::unique_ptr<File> vdex_file(OS::OpenFileForReading(vdex_filename.c_str()));
@@ -1333,7 +1333,7 @@ class Dex2Oat final {
       }
 
       DCHECK_NE(output_vdex_fd_, -1);
-      std::string vdex_location = ReplaceFileExtension(oat_location_, "vdex");
+      std::string vdex_location = ReplaceFileExtension(oat_location_, kVdexExtension);
       if (input_vdex_file_ != nullptr && output_vdex_fd_ == input_vdex_fd_) {
         use_existing_vdex_ = true;
       }
@@ -2100,7 +2100,8 @@ class Dex2Oat final {
     for (size_t i = 0, size = oat_files_.size(); i != size; ++i) {
       std::unique_ptr<linker::OatWriter>& oat_writer = oat_writers_[i];
       std::vector<const DexFile*>& dex_files = dex_files_per_oat_file_[i];
-      oat_writer->Initialize(driver_.get(), image_writer_.get(), dex_files);
+      oat_writer->Initialize(
+          driver_.get(), verification_results_.get(), image_writer_.get(), dex_files);
     }
 
     if (!use_existing_vdex_) {
@@ -2153,7 +2154,10 @@ class Dex2Oat final {
         // We need to mirror the layout of the ELF file in the compressed debug-info.
         // Therefore PrepareDebugInfo() relies on the SetLoadedSectionSizes() call further above.
         debug::DebugInfo debug_info = oat_writer->GetDebugInfo();  // Keep the variable alive.
-        elf_writer->PrepareDebugInfo(debug_info);  // Processes the data on background thread.
+        // This will perform the compression on background thread while we do other I/O below.
+        // If we hit any ERROR path below, the destructor of this variable will wait for the
+        // task to finish (since it accesses the 'debug_info' above and other 'Dex2Oat' data).
+        std::unique_ptr<ThreadPool> compression_job = elf_writer->PrepareDebugInfo(debug_info);
 
         OutputStream* rodata = rodata_[i];
         DCHECK(rodata != nullptr);
@@ -2648,7 +2652,6 @@ class Dex2Oat final {
       bool do_oat_writer_layout = DoOatLayoutOptimizations();
       oat_writers_.emplace_back(new linker::OatWriter(
           *compiler_options_,
-          verification_results_.get(),
           timings_,
           do_oat_writer_layout ? profile_compilation_info_.get() : nullptr));
     }
diff --git a/dex2oat/dex2oat_image_test.cc b/dex2oat/dex2oat_image_test.cc
index 34ca3e4d84..c7378a2438 100644
--- a/dex2oat/dex2oat_image_test.cc
+++ b/dex2oat/dex2oat_image_test.cc
@@ -271,6 +271,11 @@ TEST_F(Dex2oatImageTest, TestModesAndFilters) {
 }
 
 TEST_F(Dex2oatImageTest, TestExtension) {
+  // TODO(b/376621099): investigate LUCI failures (timeouts?) and re-enable this test.
+  // This is probably not related to riscv64 arch, but a combination of riscv64 and running
+  // on VM, but we don't use TEST_DISABLED_ON_VM to keep running it on other VM builders.
+  TEST_DISABLED_FOR_RISCV64();
+
   std::string error_msg;
   MemMap reservation = ReserveCoreImageAddressSpace(&error_msg);
   ASSERT_TRUE(reservation.IsValid()) << error_msg;
diff --git a/dex2oat/dex2oat_test.cc b/dex2oat/dex2oat_test.cc
index 26216fd719..f81345b345 100644
--- a/dex2oat/dex2oat_test.cc
+++ b/dex2oat/dex2oat_test.cc
@@ -68,6 +68,8 @@ using ::testing::Not;
 
 class Dex2oatTest : public Dex2oatEnvironmentTest {
  public:
+  enum class Status { kFailCompile, kFailOpenOat, kSuccess };
+
   void TearDown() override {
     Dex2oatEnvironmentTest::TearDown();
 
@@ -122,14 +124,14 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
                                       const std::string& odex_location,
                                       CompilerFilter::Filter filter,
                                       const std::vector<std::string>& extra_args = {},
-                                      bool expect_success = true,
+                                      Status expect_status = Status::kSuccess,
                                       bool use_fd = false,
                                       bool use_zip_fd = false) WARN_UNUSED {
     return GenerateOdexForTest(dex_location,
                                odex_location,
                                filter,
                                extra_args,
-                               expect_success,
+                               expect_status,
                                use_fd,
                                use_zip_fd,
                                [](const OatFile&) {});
@@ -142,7 +144,7 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
                                       const std::string& odex_location,
                                       CompilerFilter::Filter filter,
                                       const std::vector<std::string>& extra_args,
-                                      bool expect_success,
+                                      Status expect_status,
                                       bool use_fd,
                                       bool use_zip_fd,
                                       T check_oat) WARN_UNUSED {
@@ -163,7 +165,7 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
         GenerateOdexForTestWithStatus(dex_locations, odex_location, filter, extra_args, use_fd);
 
     bool success = status.ok() && status.value() == 0;
-    if (expect_success) {
+    if (expect_status != Status::kFailCompile) {
       if (!success) {
         return AssertionFailure() << "Failed to compile odex ("
                                   << (status.ok() ? StringPrintf("status=%d", status.value()) :
@@ -180,6 +182,13 @@ class Dex2oatTest : public Dex2oatEnvironmentTest {
                                                        /*low_4gb=*/false,
                                                        dex_location,
                                                        &error_msg));
+
+      if (expect_status == Status::kFailOpenOat) {
+        return (odex_file == nullptr) ?
+                   AssertionSuccess() :
+                   AssertionFailure() << "Unexpectedly was able to open odex file";
+      }
+
       if (odex_file == nullptr) {
         return AssertionFailure() << "Could not open odex file: " << error_msg;
       }
@@ -649,7 +658,7 @@ class Dex2oatLayoutTest : public Dex2oatTest {
                           bool use_fd,
                           const std::vector<std::string>& profile_locations,
                           const std::vector<std::string>& extra_args = {},
-                          bool expect_success = true) {
+                          Status expect_status = Status::kSuccess) {
     std::vector<std::string> copy(extra_args);
     for (const std::string& profile_location : profile_locations) {
       copy.push_back("--profile-file=" + profile_location);
@@ -664,7 +673,7 @@ class Dex2oatLayoutTest : public Dex2oatTest {
       }
     }
     ASSERT_TRUE(GenerateOdexForTest(
-        dex_location, odex_location, CompilerFilter::kSpeedProfile, copy, expect_success, use_fd));
+        dex_location, odex_location, CompilerFilter::kSpeedProfile, copy, expect_status, use_fd));
     if (app_image_file != nullptr) {
       ASSERT_EQ(app_image_file->FlushCloseOrErase(), 0) << "Could not flush and close art file";
     }
@@ -678,7 +687,7 @@ class Dex2oatLayoutTest : public Dex2oatTest {
                           bool use_fd,
                           size_t num_profile_classes,
                           const std::vector<std::string>& extra_args = {},
-                          bool expect_success = true) {
+                          Status expect_status = Status::kSuccess) {
     const std::string profile_location = GetScratchDir() + "/primary.prof";
     GenerateProfile(profile_location, dex_location, num_profile_classes);
     CompileProfileOdex(dex_location,
@@ -687,7 +696,7 @@ class Dex2oatLayoutTest : public Dex2oatTest {
                        use_fd,
                        {profile_location},
                        extra_args,
-                       expect_success);
+                       expect_status);
   }
 
   uint32_t GetImageObjectSectionSize(const std::string& image_file_name) {
@@ -784,7 +793,7 @@ class Dex2oatLayoutTest : public Dex2oatTest {
                          /*use_fd=*/true,
                          /*num_profile_classes=*/1,
                          {input_vdex, output_vdex},
-                         /*expect_success=*/true);
+                         /*expect_status=*/Status::kSuccess);
       EXPECT_GT(vdex_file2.GetFile()->GetLength(), 0u);
     }
     ASSERT_EQ(vdex_file1->FlushCloseOrErase(), 0) << "Could not flush and close vdex file";
@@ -877,7 +886,7 @@ TEST_F(Dex2oatLayoutTest, TestLayoutAppImageMissingBootImage) {
                      /*use_fd=*/false,
                      /*num_profile_classes=*/1,
                      /*extra_args=*/{"--boot-image=/nonx/boot.art"},
-                     /*expect_success=*/true);
+                     /*expect_status=*/Status::kSuccess);
 
   // Verify the odex file does not require an image.
   std::string error_msg;
@@ -987,7 +996,7 @@ TEST_F(Dex2oatLayoutTest, TestVdexLayout) { RunTestVDex(); }
 
 class Dex2oatWatchdogTest : public Dex2oatTest {
  protected:
-  void RunTest(bool expect_success, const std::vector<std::string>& extra_args = {}) {
+  void RunTest(Status expect_status, const std::vector<std::string>& extra_args = {}) {
     std::string dex_location = GetScratchDir() + "/Dex2OatSwapTest.jar";
     std::string odex_location = GetOdexDir() + "/Dex2OatSwapTest.odex";
 
@@ -999,7 +1008,7 @@ class Dex2oatWatchdogTest : public Dex2oatTest {
     copy.push_back("--swap-file=" + swap_location);
     copy.push_back("-j512");  // Excessive idle threads just slow down dex2oat.
     ASSERT_TRUE(GenerateOdexForTest(
-        dex_location, odex_location, CompilerFilter::kSpeed, copy, expect_success));
+        dex_location, odex_location, CompilerFilter::kSpeed, copy, expect_status));
   }
 
   std::string GetTestDexFileName() { return GetDexSrc1(); }
@@ -1007,10 +1016,10 @@ class Dex2oatWatchdogTest : public Dex2oatTest {
 
 TEST_F(Dex2oatWatchdogTest, TestWatchdogOK) {
   // Check with default.
-  RunTest(/*expect_success=*/true);
+  RunTest(/*expect_status=*/Status::kSuccess);
 
   // Check with ten minutes.
-  RunTest(/*expect_success=*/true, {"--watchdog-timeout=600000"});
+  RunTest(/*expect_status=*/Status::kSuccess, {"--watchdog-timeout=600000"});
 }
 
 TEST_F(Dex2oatWatchdogTest, TestWatchdogTrigger) {
@@ -1024,14 +1033,14 @@ TEST_F(Dex2oatWatchdogTest, TestWatchdogTrigger) {
   test_accepts_odex_file_on_failure = true;
 
   // Check with ten milliseconds.
-  RunTest(/*expect_success=*/false, {"--watchdog-timeout=10"});
+  RunTest(/*expect_status=*/Status::kFailCompile, {"--watchdog-timeout=10"});
 }
 
 class Dex2oatClassLoaderContextTest : public Dex2oatTest {
  protected:
   void RunTest(const char* class_loader_context,
                const char* expected_classpath_key,
-               bool expect_success,
+               Status expect_status,
                bool use_second_source = false,
                bool generate_image = false) {
     std::string dex_location = GetUsedDexLocation();
@@ -1057,7 +1066,7 @@ class Dex2oatClassLoaderContextTest : public Dex2oatTest {
                                     odex_location,
                                     CompilerFilter::kVerify,
                                     extra_args,
-                                    expect_success,
+                                    expect_status,
                                     /*use_fd=*/false,
                                     /*use_zip_fd=*/false,
                                     check_oat));
@@ -1073,16 +1082,16 @@ class Dex2oatClassLoaderContextTest : public Dex2oatTest {
 };
 
 TEST_F(Dex2oatClassLoaderContextTest, InvalidContext) {
-  RunTest("Invalid[]", /*expected_classpath_key=*/nullptr, /*expect_success=*/false);
+  RunTest("Invalid[]", /*expected_classpath_key=*/nullptr, /*expect_status=*/Status::kFailCompile);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, EmptyContext) {
-  RunTest("PCL[]", kEmptyClassPathKey, /*expect_success=*/true);
+  RunTest("PCL[]", kEmptyClassPathKey, /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithTheSourceDexFiles) {
   std::string context = "PCL[" + GetUsedDexLocation() + "]";
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithOtherDexFiles) {
@@ -1093,7 +1102,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithOtherDexFiles) {
   std::string context = "PCL[" + dex_files[0]->GetLocation() + "]";
   std::string expected_classpath_key =
       "PCL[" + dex_files[0]->GetLocation() + "*" + std::to_string(expected_checksum) + "]";
-  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithResourceOnlyDexFiles) {
@@ -1102,13 +1111,13 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithResourceOnlyDexFiles) {
 
   std::string context = "PCL[" + resource_only_classpath + "]";
   // Expect an empty context because resource only dex files cannot be open.
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithNotExistentDexFiles) {
   std::string context = "PCL[does_not_exists.dex]";
   // Expect an empty context because stripped dex files cannot be open.
-  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_success=*/true);
+  RunTest(context.c_str(), kEmptyClassPathKey, /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ChainContext) {
@@ -1120,7 +1129,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ChainContext) {
   std::string expected_classpath_key = "PCL[" + CreateClassPathWithChecksums(dex_files1) + "];" +
                                        "DLC[" + CreateClassPathWithChecksums(dex_files2) + "]";
 
-  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrary) {
@@ -1131,7 +1140,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrary) {
       "PCL[" + GetTestDexFileName("Nested") + "]" + "{PCL[" + GetTestDexFileName("MultiDex") + "]}";
   std::string expected_classpath_key = "PCL[" + CreateClassPathWithChecksums(dex_files1) + "]" +
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
-  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_success=*/true);
+  RunTest(context.c_str(), expected_classpath_key.c_str(), /*expect_status=*/Status::kSuccess);
 }
 
 TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibraryAndImage) {
@@ -1144,7 +1153,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibraryAndImage) {
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expect_success=*/true,
+          /*expect_status=*/Status::kSuccess,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1161,7 +1170,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSameSharedLibrariesAndImage) {
                                        "#PCL[" + CreateClassPathWithChecksums(dex_files2) + "]}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expect_success=*/true,
+          /*expect_status=*/Status::kSuccess,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1178,7 +1187,7 @@ TEST_F(Dex2oatClassLoaderContextTest, ContextWithSharedLibrariesDependenciesAndI
                                        "{PCL[" + CreateClassPathWithChecksums(dex_files1) + "]}}";
   RunTest(context.c_str(),
           expected_classpath_key.c_str(),
-          /*expect_success=*/true,
+          /*expect_status=*/Status::kSuccess,
           /*use_second_source=*/false,
           /*generate_image=*/true);
 }
@@ -1270,7 +1279,7 @@ TEST_F(Dex2oatDedupeCode, DedupeTest) {
                           base_oat_name,
                           CompilerFilter::Filter::kSpeed,
                           {"--deduplicate-code=false"},
-                          /*expect_success=*/true,
+                          /*expect_status=*/Status::kSuccess,
                           /*use_fd=*/false,
                           /*use_zip_fd=*/false,
                           [&no_dedupe_size](const OatFile& o) { no_dedupe_size = o.Size(); }));
@@ -1280,7 +1289,7 @@ TEST_F(Dex2oatDedupeCode, DedupeTest) {
                                   base_oat_name,
                                   CompilerFilter::Filter::kSpeed,
                                   {"--deduplicate-code=true"},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [&dedupe_size](const OatFile& o) { dedupe_size = o.Size(); }));
@@ -1296,7 +1305,7 @@ TEST_F(Dex2oatTest, UncompressedTest) {
                                   base_oat_name,
                                   CompilerFilter::Filter::kVerify,
                                   {},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile& o) { CHECK(!o.ContainsDexCode()); }));
@@ -1349,7 +1358,7 @@ TEST_F(Dex2oatTest, StderrLoggerOutput) {
                                   odex_location,
                                   CompilerFilter::kVerify,
                                   {"--runtime-arg", "-Xuse-stderr-logger"},
-                                  /*expect_success=*/true));
+                                  /*expect_status=*/Status::kSuccess));
   // Look for some random part of dex2oat logging. With the stderr logger this should be captured,
   // even on device.
   EXPECT_NE(std::string::npos, output_.find("dex2oat took"));
@@ -1366,7 +1375,7 @@ TEST_F(Dex2oatTest, VerifyCompilationReason) {
                                   odex_location,
                                   CompilerFilter::kVerify,
                                   {"--compilation-reason=install"},
-                                  /*expect_success=*/true));
+                                  /*expect_status=*/Status::kSuccess));
   std::string error_msg;
   std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                    odex_location,
@@ -1390,7 +1399,7 @@ TEST_F(Dex2oatTest, VerifyNoCompilationReason) {
                                   odex_location,
                                   CompilerFilter::kVerify,
                                   /*extra_args=*/{},
-                                  /*expect_success=*/true));
+                                  /*expect_status=*/Status::kSuccess));
   std::string error_msg;
   std::unique_ptr<OatFile> odex_file(OatFile::Open(/*zip_fd=*/-1,
                                                    odex_location,
@@ -1414,7 +1423,7 @@ TEST_F(Dex2oatTest, DontExtract) {
                                   odex_location,
                                   CompilerFilter::Filter::kVerify,
                                   {"--copy-dex-files=false"},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile&) {}));
@@ -1475,7 +1484,7 @@ TEST_F(Dex2oatTest, DontExtract) {
                                      // target.
                                      "--runtime-arg",
                                      "-Xuse-stderr-logger"},
-                                    /*expect_success=*/true,
+                                    /*expect_status=*/Status::kSuccess,
                                     /*use_fd=*/false,
                                     /*use_zip_fd=*/false,
                                     [](const OatFile& o) { CHECK(o.ContainsDexCode()); }));
@@ -1591,7 +1600,7 @@ TEST_F(Dex2oatWithExpectedFilterTest, AppImageNoProfile) {
                                   odex_location,
                                   CompilerFilter::Filter::kSpeedProfile,
                                   {"--app-image-fd=" + std::to_string(app_image_file.GetFd())},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile&) {}));
@@ -1627,7 +1636,7 @@ TEST_F(Dex2oatTest, ZipFd) {
                                   base_oat_name,
                                   CompilerFilter::Filter::kVerify,
                                   extra_args,
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/true));
 }
@@ -1685,7 +1694,7 @@ TEST_F(Dex2oatWithExpectedFilterTest, AppImageEmptyDex) {
                                   {"--app-image-file=" + app_image_location,
                                    "--resolve-startup-const-strings=true",
                                    "--profile-file=" + profile_file.GetFilename()},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile&) {}));
@@ -1700,6 +1709,20 @@ TEST_F(Dex2oatWithExpectedFilterTest, AppImageEmptyDex) {
   ASSERT_TRUE(odex_file != nullptr);
 }
 
+TEST_F(Dex2oatWithExpectedFilterTest, AppImageNonexistentDex) {
+  const std::string out_dir = GetScratchDir();
+  // Test that dex2oat does not crash trying to compile app image with zero DEX files.
+  ASSERT_TRUE(GenerateOdexForTest(
+      out_dir + "/base.apk",
+      out_dir + "/base.odex",
+      CompilerFilter::Filter::kSpeedProfile,
+      {"--dex-file=nonexistent.apk", "--app-image-file=" + out_dir + "/base.art"},
+      /*expect_status=*/Status::kFailOpenOat,
+      /*use_fd=*/false,
+      /*use_zip_fd=*/false,
+      [](const OatFile&) {}));
+}
+
 TEST_F(Dex2oatTest, DexFileFd) {
   std::string error_msg;
   std::string zip_location = GetTestDexFileName("Main");
@@ -1730,7 +1753,7 @@ TEST_F(Dex2oatTest, DexFileFd) {
                                   base_oat_name,
                                   CompilerFilter::Filter::kVerify,
                                   extra_args,
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/true));
 }
@@ -1746,7 +1769,7 @@ TEST_F(Dex2oatTest, DontCopyPlainDex) {
                                   odex_location,
                                   CompilerFilter::Filter::kVerify,
                                   /*extra_args=*/{},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile&) {}));
@@ -1831,7 +1854,7 @@ TEST_F(Dex2oatTest, AppImageResolveStrings) {
                                   {"--app-image-file=" + app_image_location,
                                    "--resolve-startup-const-strings=true",
                                    "--profile-file=" + profile_file.GetFilename()},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [](const OatFile&) {}));
@@ -1846,10 +1869,10 @@ TEST_F(Dex2oatTest, AppImageResolveStrings) {
   ASSERT_TRUE(odex_file != nullptr);
   // Check the strings in the app image intern table only contain the "startup" strigs.
   {
-    ScopedObjectAccess soa(Thread::Current());
     std::unique_ptr<gc::space::ImageSpace> space = gc::space::ImageSpace::CreateFromAppImage(
         app_image_location.c_str(), odex_file.get(), &error_msg);
     ASSERT_TRUE(space != nullptr) << error_msg;
+    ScopedObjectAccess soa(Thread::Current());
     std::set<std::string> seen;
     InternTable intern_table;
     intern_table.AddImageStringsToTable(
@@ -1906,7 +1929,7 @@ TEST_F(Dex2oatClassLoaderContextTest, StoredClassLoaderContext) {
                                   odex_location,
                                   CompilerFilter::Filter::kVerify,
                                   {"--class-loader-context=" + stored_context},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false,
                                   [&](const OatFile& oat_file) {
@@ -1922,7 +1945,7 @@ TEST_F(Dex2oatClassLoaderContextTest, StoredClassLoaderContext) {
       CompilerFilter::Filter::kVerify,
       {"--class-loader-context=" + valid_context,
        "--stored-class-loader-context=" + stored_context},
-      /*expect_success=*/true,
+      /*expect_status=*/Status::kSuccess,
       /*use_fd=*/false,
       /*use_zip_fd=*/false,
       [&](const OatFile& oat_file) {
@@ -1990,7 +2013,7 @@ TEST_F(Dex2oatTest, LoadOutOfDateOatFile) {
                                   base_oat_name,
                                   CompilerFilter::Filter::kSpeed,
                                   {"--deduplicate-code=false"},
-                                  /*expect_success=*/true,
+                                  /*expect_status=*/Status::kSuccess,
                                   /*use_fd=*/false,
                                   /*use_zip_fd=*/false));
 
diff --git a/dex2oat/driver/compiler_driver.cc b/dex2oat/driver/compiler_driver.cc
index 5399f1cd7e..bbb70e4ef1 100644
--- a/dex2oat/driver/compiler_driver.cc
+++ b/dex2oat/driver/compiler_driver.cc
@@ -370,7 +370,6 @@ static void CompileMethodHarness(
     CompilerDriver* driver,
     const dex::CodeItem* code_item,
     uint32_t access_flags,
-    InvokeType invoke_type,
     uint16_t class_def_idx,
     uint32_t method_idx,
     Handle<mirror::ClassLoader> class_loader,
@@ -386,7 +385,6 @@ static void CompileMethodHarness(
                                driver,
                                code_item,
                                access_flags,
-                               invoke_type,
                                class_def_idx,
                                method_idx,
                                class_loader,
@@ -456,7 +454,6 @@ static void CompileMethodQuick(
     CompilerDriver* driver,
     const dex::CodeItem* code_item,
     uint32_t access_flags,
-    InvokeType invoke_type,
     uint16_t class_def_idx,
     uint32_t method_idx,
     Handle<mirror::ClassLoader> class_loader,
@@ -467,7 +464,6 @@ static void CompileMethodQuick(
                                   CompilerDriver* driver,
                                   const dex::CodeItem* code_item,
                                   uint32_t access_flags,
-                                  InvokeType invoke_type,
                                   uint16_t class_def_idx,
                                   uint32_t method_idx,
                                   Handle<mirror::ClassLoader> class_loader,
@@ -523,7 +519,6 @@ static void CompileMethodQuick(
         // NOTE: if compiler declines to compile this method, it will return null.
         compiled_method = driver->GetCompiler()->Compile(code_item,
                                                          access_flags,
-                                                         invoke_type,
                                                          class_def_idx,
                                                          method_idx,
                                                          class_loader,
@@ -559,7 +554,6 @@ static void CompileMethodQuick(
                        driver,
                        code_item,
                        access_flags,
-                       invoke_type,
                        class_def_idx,
                        method_idx,
                        class_loader,
@@ -756,7 +750,8 @@ static void EnsureVerifiedOrVerifyAtRuntime(jobject jclass_loader,
 
   for (const DexFile* dex_file : dex_files) {
     for (ClassAccessor accessor : dex_file->GetClasses()) {
-      cls.Assign(class_linker->FindClass(soa.Self(), accessor.GetDescriptor(), class_loader));
+      cls.Assign(
+          class_linker->FindClass(soa.Self(), *dex_file, accessor.GetClassIdx(), class_loader));
       if (cls == nullptr) {
         soa.Self()->ClearException();
       } else if (&cls->GetDexFile() == dex_file) {
@@ -1259,7 +1254,8 @@ void CompilerDriver::LoadImageClasses(TimingLogger* timings,
   CHECK(image_classes != nullptr);
   for (auto it = image_classes->begin(), end = image_classes->end(); it != end;) {
     const std::string& descriptor(*it);
-    ObjPtr<mirror::Class> klass = class_linker->FindClass(self, descriptor.c_str(), loader);
+    ObjPtr<mirror::Class> klass =
+        class_linker->FindClass(self, descriptor.c_str(), descriptor.length(), loader);
     if (klass == nullptr) {
       VLOG(compiler) << "Failed to find class " << descriptor;
       it = image_classes->erase(it);  // May cause some descriptors to be revisited.
@@ -1745,9 +1741,7 @@ class ResolveTypeVisitor : public CompilationVisitor {
         }
         // Check that the current class is not a subclass of java.lang.ClassLoader.
         if (!hklass->IsInterface() &&
-            hklass->IsSubClass(class_linker->FindClass(soa.Self(),
-                                                       "Ljava/lang/ClassLoader;",
-                                                       defining_class_loader))) {
+            hklass->IsSubClass(GetClassRoot<mirror::ClassLoader>(class_linker))) {
           // Subclassing of java.lang.ClassLoader.
           // This OptStat stuff is to enable logging from the APK scanner.
           if (is_fatal) {
@@ -1812,16 +1806,15 @@ static void LoadAndUpdateStatus(const ClassAccessor& accessor,
                                 Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   StackHandleScope<1> hs(self);
-  const char* descriptor = accessor.GetDescriptor();
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
   Handle<mirror::Class> cls(hs.NewHandle<mirror::Class>(
-      class_linker->FindClass(self, descriptor, class_loader)));
+      class_linker->FindClass(self, accessor.GetDexFile(), accessor.GetClassIdx(), class_loader)));
   if (cls != nullptr) {
     // Check that the class is resolved with the current dex file. We might get
     // a boot image class, or a class in a different dex file for multidex, and
     // we should not update the status in that case.
     if (&cls->GetDexFile() == &accessor.GetDexFile()) {
-      VLOG(compiler) << "Updating class status of " << std::string(descriptor) << " to " << status;
+      VLOG(compiler) << "Updating class status of " << accessor.GetDescriptor() << " to " << status;
       ObjectLock<mirror::Class> lock(self, cls);
       mirror::Class::SetStatus(cls, status, self);
     }
@@ -1977,14 +1970,13 @@ class VerifyClassVisitor : public CompilationVisitor {
     ScopedObjectAccess soa(Thread::Current());
     const DexFile& dex_file = *manager_->GetDexFile();
     const dex::ClassDef& class_def = dex_file.GetClassDef(class_def_index);
-    const char* descriptor = dex_file.GetClassDescriptor(class_def);
     ClassLinker* class_linker = manager_->GetClassLinker();
     jobject jclass_loader = manager_->GetClassLoader();
     StackHandleScope<3> hs(soa.Self());
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
-    Handle<mirror::Class> klass(
-        hs.NewHandle(class_linker->FindClass(soa.Self(), descriptor, class_loader)));
+    Handle<mirror::Class> klass = hs.NewHandle(
+        class_linker->FindClass(soa.Self(), dex_file, class_def.class_idx_, class_loader));
     ClassReference ref(manager_->GetDexFile(), class_def_index);
     verifier::FailureKind failure_kind;
     if (klass == nullptr) {
@@ -2141,14 +2133,13 @@ class SetVerifiedClassVisitor : public CompilationVisitor {
     ScopedObjectAccess soa(Thread::Current());
     const DexFile& dex_file = *manager_->GetDexFile();
     const dex::ClassDef& class_def = dex_file.GetClassDef(class_def_index);
-    const char* descriptor = dex_file.GetClassDescriptor(class_def);
     ClassLinker* class_linker = manager_->GetClassLinker();
     jobject jclass_loader = manager_->GetClassLoader();
     StackHandleScope<3> hs(soa.Self());
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
-    Handle<mirror::Class> klass(
-        hs.NewHandle(class_linker->FindClass(soa.Self(), descriptor, class_loader)));
+    Handle<mirror::Class> klass = hs.NewHandle(
+        class_linker->FindClass(soa.Self(), dex_file, class_def.class_idx_, class_loader));
     // Class might have failed resolution. Then don't set it to verified.
     if (klass != nullptr) {
       // Only do this if the class is resolved. If even resolution fails, quickening will go very,
@@ -2203,15 +2194,13 @@ class InitializeClassVisitor : public CompilationVisitor {
     jobject jclass_loader = manager_->GetClassLoader();
     const DexFile& dex_file = *manager_->GetDexFile();
     const dex::ClassDef& class_def = dex_file.GetClassDef(class_def_index);
-    const dex::TypeId& class_type_id = dex_file.GetTypeId(class_def.class_idx_);
-    const char* descriptor = dex_file.GetStringData(class_type_id.descriptor_idx_);
 
     ScopedObjectAccess soa(Thread::Current());
     StackHandleScope<3> hs(soa.Self());
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
-    Handle<mirror::Class> klass(
-        hs.NewHandle(manager_->GetClassLinker()->FindClass(soa.Self(), descriptor, class_loader)));
+    Handle<mirror::Class> klass = hs.NewHandle(manager_->GetClassLinker()->FindClass(
+        soa.Self(), dex_file, class_def.class_idx_, class_loader));
 
     if (klass != nullptr) {
       if (!SkipClass(manager_->GetClassLoader(), dex_file, klass.Get())) {
@@ -2335,8 +2324,8 @@ class InitializeClassVisitor : public CompilationVisitor {
             // the transaction aborts and cannot resolve the type.
             // TransactionAbortError is not initialized ant not in boot image, needed only by
             // compiler and will be pruned by ImageWriter.
-            Handle<mirror::Class> exception_class = hs.NewHandle(
-                class_linker->FindClass(self, kTransactionAbortErrorDescriptor, class_loader));
+            Handle<mirror::Class> exception_class =
+                hs.NewHandle(class_linker->FindSystemClass(self, kTransactionAbortErrorDescriptor));
             bool exception_initialized =
                 class_linker->EnsureInitialized(self, exception_class, true, true);
             DCHECK(exception_initialized);
@@ -2701,8 +2690,8 @@ static void CompileDexFile(CompilerDriver* driver,
     StackHandleScope<3> hs(soa.Self());
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
-    Handle<mirror::Class> klass(
-        hs.NewHandle(class_linker->FindClass(soa.Self(), accessor.GetDescriptor(), class_loader)));
+    Handle<mirror::Class> klass = hs.NewHandle(
+        class_linker->FindClass(soa.Self(), dex_file, class_def.class_idx_, class_loader));
     Handle<mirror::DexCache> dex_cache;
     if (klass == nullptr) {
       soa.Self()->AssertPendingException();
@@ -2737,7 +2726,6 @@ static void CompileDexFile(CompilerDriver* driver,
                  driver,
                  method.GetCodeItem(),
                  method.GetAccessFlags(),
-                 method.GetInvokeType(class_def.access_flags_),
                  class_def_index,
                  method_idx,
                  class_loader,
diff --git a/dex2oat/driver/compiler_driver_test.cc b/dex2oat/driver/compiler_driver_test.cc
index 759426a1d3..7d4c32b25c 100644
--- a/dex2oat/driver/compiler_driver_test.cc
+++ b/dex2oat/driver/compiler_driver_test.cc
@@ -105,7 +105,7 @@ class CompilerDriverTest : public CommonCompilerDriverTest {
       StackHandleScope<1> hs(soa.Self());
       Handle<mirror::ClassLoader> loader(
           hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-      ObjPtr<mirror::Class> c = class_linker->FindClass(soa.Self(), descriptor, loader);
+      ObjPtr<mirror::Class> c = FindClass(descriptor, loader);
       CHECK(c != nullptr);
       const auto pointer_size = class_linker->GetImagePointerSize();
       for (auto& m : c->GetMethods(pointer_size)) {
@@ -237,7 +237,7 @@ class CompilerDriverProfileTest : public CompilerDriverTest {
     StackHandleScope<1> hs(self);
     Handle<mirror::ClassLoader> h_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-    ObjPtr<mirror::Class> klass = class_linker->FindClass(self, clazz.c_str(), h_loader);
+    ObjPtr<mirror::Class> klass = FindClass(clazz.c_str(), h_loader);
     ASSERT_NE(klass, nullptr);
 
     const auto pointer_size = class_linker->GetImagePointerSize();
@@ -298,7 +298,7 @@ class CompilerDriverVerifyTest : public CompilerDriverTest {
     StackHandleScope<1> hs(self);
     Handle<mirror::ClassLoader> h_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-    ObjPtr<mirror::Class> klass = class_linker->FindClass(self, clazz.c_str(), h_loader);
+    ObjPtr<mirror::Class> klass = FindClass(clazz.c_str(), h_loader);
     ASSERT_NE(klass, nullptr);
     EXPECT_TRUE(klass->IsVerified());
 
diff --git a/dex2oat/interpreter/interpreter_switch_impl1.cc b/dex2oat/interpreter/interpreter_switch_impl1.cc
index c7e2ed1ad3..00fd15ecce 100644
--- a/dex2oat/interpreter/interpreter_switch_impl1.cc
+++ b/dex2oat/interpreter/interpreter_switch_impl1.cc
@@ -186,6 +186,15 @@ class InactiveInstrumentationHandler {
     UNREACHABLE();
   }
 
+  static bool ExceptionHandledEvent(
+      [[maybe_unused]] Thread* self,
+      [[maybe_unused]] bool is_move_exception,
+      [[maybe_unused]] const instrumentation::Instrumentation* instrumentation)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    LOG(FATAL) << "UNREACHABLE";
+    UNREACHABLE();
+  }
+
   static bool DoDexPcMoveEvent(
       [[maybe_unused]] Thread* self,
       [[maybe_unused]] const CodeItemDataAccessor& accessor,
diff --git a/dex2oat/interpreter/unstarted_runtime_transaction_test.cc b/dex2oat/interpreter/unstarted_runtime_transaction_test.cc
index ec308c2c18..a60da0657f 100644
--- a/dex2oat/interpreter/unstarted_runtime_transaction_test.cc
+++ b/dex2oat/interpreter/unstarted_runtime_transaction_test.cc
@@ -32,10 +32,8 @@ class UnstartedRuntimeTransactionTest : public CommonTransactionTestBase<Unstart
   // Prepare for aborts. Aborts assume that the exception class is already resolved, as the
   // loading code doesn't work under transactions.
   void PrepareForAborts() REQUIRES_SHARED(Locks::mutator_lock_) {
-    ObjPtr<mirror::Object> result = Runtime::Current()->GetClassLinker()->FindClass(
-        Thread::Current(),
-        kTransactionAbortErrorDescriptor,
-        ScopedNullHandle<mirror::ClassLoader>());
+    ObjPtr<mirror::Object> result =
+        FindClass(kTransactionAbortErrorDescriptor, ScopedNullHandle<mirror::ClassLoader>());
     CHECK(result != nullptr);
   }
 };
@@ -152,9 +150,7 @@ class UnstartedClassForNameTransactionTest : public UnstartedRuntimeTransactionT
     // For transaction mode, we cannot load any classes, as the pre-fence initialization of
     // classes isn't transactional. Load them ahead of time.
     for (const char* name : kTestCases) {
-      class_linker_->FindClass(self,
-                               DotToDescriptor(name).c_str(),
-                               ScopedNullHandle<mirror::ClassLoader>());
+      FindClass(DotToDescriptor(name).c_str(), ScopedNullHandle<mirror::ClassLoader>());
       CHECK(!self->IsExceptionPending()) << self->GetException()->Dump();
     }
 
diff --git a/dex2oat/linker/arm64/relative_patcher_arm64.cc b/dex2oat/linker/arm64/relative_patcher_arm64.cc
index 2956285545..79fcd18b00 100644
--- a/dex2oat/linker/arm64/relative_patcher_arm64.cc
+++ b/dex2oat/linker/arm64/relative_patcher_arm64.cc
@@ -63,6 +63,7 @@ inline bool IsAdrpPatch(const LinkerPatch& patch) {
     case LinkerPatch::Type::kIntrinsicReference:
     case LinkerPatch::Type::kBootImageRelRo:
     case LinkerPatch::Type::kMethodRelative:
+    case LinkerPatch::Type::kMethodAppImageRelRo:
     case LinkerPatch::Type::kMethodBssEntry:
     case LinkerPatch::Type::kJniEntrypointRelative:
     case LinkerPatch::Type::kTypeRelative:
@@ -273,13 +274,15 @@ void Arm64RelativePatcher::PatchPcRelativeReference(std::vector<uint8_t>* code,
     } else {
       // LDR/STR 32-bit or 64-bit with imm12 == 0 (unset).
       DCHECK(patch.GetType() == LinkerPatch::Type::kBootImageRelRo ||
+             patch.GetType() == LinkerPatch::Type::kMethodAppImageRelRo ||
              patch.GetType() == LinkerPatch::Type::kMethodBssEntry ||
              patch.GetType() == LinkerPatch::Type::kJniEntrypointRelative ||
              patch.GetType() == LinkerPatch::Type::kTypeAppImageRelRo ||
              patch.GetType() == LinkerPatch::Type::kTypeBssEntry ||
              patch.GetType() == LinkerPatch::Type::kPublicTypeBssEntry ||
              patch.GetType() == LinkerPatch::Type::kPackageTypeBssEntry ||
-             patch.GetType() == LinkerPatch::Type::kStringBssEntry) << patch.GetType();
+             patch.GetType() == LinkerPatch::Type::kStringBssEntry ||
+             patch.GetType() == LinkerPatch::Type::kMethodTypeBssEntry) << patch.GetType();
       DCHECK_EQ(insn & 0xbfbffc00, 0xb9000000) << std::hex << insn;
     }
     if (kIsDebugBuild) {
diff --git a/dex2oat/linker/elf_writer.h b/dex2oat/linker/elf_writer.h
index 35e3565592..d27d4fa92c 100644
--- a/dex2oat/linker/elf_writer.h
+++ b/dex2oat/linker/elf_writer.h
@@ -18,6 +18,7 @@
 #define ART_DEX2OAT_LINKER_ELF_WRITER_H_
 
 #include <stdint.h>
+
 #include <cstddef>
 #include <string>
 #include <vector>
@@ -27,6 +28,7 @@
 #include "base/mutex.h"
 #include "base/os.h"
 #include "debug/debug_info.h"
+#include "thread_pool.h"
 
 namespace art {
 
@@ -66,7 +68,7 @@ class ElfWriter {
                                      size_t bss_methods_offset,
                                      size_t bss_roots_offset,
                                      size_t dex_section_size) = 0;
-  virtual void PrepareDebugInfo(const debug::DebugInfo& debug_info) = 0;
+  virtual std::unique_ptr<ThreadPool> PrepareDebugInfo(const debug::DebugInfo& debug_info) = 0;
   virtual OutputStream* StartRoData() = 0;
   virtual void EndRoData(OutputStream* rodata) = 0;
   virtual OutputStream* StartText() = 0;
diff --git a/dex2oat/linker/elf_writer_quick.cc b/dex2oat/linker/elf_writer_quick.cc
index f87ca6d81e..425f9bd554 100644
--- a/dex2oat/linker/elf_writer_quick.cc
+++ b/dex2oat/linker/elf_writer_quick.cc
@@ -40,21 +40,22 @@ namespace linker {
 
 class DebugInfoTask : public Task {
  public:
-  DebugInfoTask(InstructionSet isa,
+  DebugInfoTask(ThreadPool* owner,
+                InstructionSet isa,
                 const InstructionSetFeatures* features,
                 uint64_t text_section_address,
                 size_t text_section_size,
                 uint64_t dex_section_address,
                 size_t dex_section_size,
                 const debug::DebugInfo& debug_info)
-      : isa_(isa),
+      : owner_(owner),
+        isa_(isa),
         instruction_set_features_(features),
         text_section_address_(text_section_address),
         text_section_size_(text_section_size),
         dex_section_address_(dex_section_address),
         dex_section_size_(dex_section_size),
-        debug_info_(debug_info) {
-  }
+        debug_info_(debug_info) {}
 
   void Run(Thread*) override {
     result_ = debug::MakeMiniDebugInfo(isa_,
@@ -66,11 +67,13 @@ class DebugInfoTask : public Task {
                                        debug_info_);
   }
 
-  std::vector<uint8_t>* GetResult() {
+  std::vector<uint8_t>* WaitAndGetMiniDebugInfo() {
+    owner_->Wait(Thread::Current(), true, false);
     return &result_;
   }
 
  private:
+  ThreadPool* owner_;
   InstructionSet isa_;
   const InstructionSetFeatures* instruction_set_features_;
   uint64_t text_section_address_;
@@ -97,7 +100,7 @@ class ElfWriterQuick final : public ElfWriter {
                              size_t bss_methods_offset,
                              size_t bss_roots_offset,
                              size_t dex_section_size) override;
-  void PrepareDebugInfo(const debug::DebugInfo& debug_info) override;
+  std::unique_ptr<ThreadPool> PrepareDebugInfo(const debug::DebugInfo& debug_info) override;
   OutputStream* StartRoData() override;
   void EndRoData(OutputStream* rodata) override;
   OutputStream* StartText() override;
@@ -127,7 +130,6 @@ class ElfWriterQuick final : public ElfWriter {
   std::unique_ptr<BufferedOutputStream> output_stream_;
   std::unique_ptr<ElfBuilder<ElfTypes>> builder_;
   std::unique_ptr<DebugInfoTask> debug_info_task_;
-  std::unique_ptr<ThreadPool> debug_info_thread_pool_;
 
   void ComputeFileBuildId(uint8_t (*build_id)[ElfBuilder<ElfTypes>::kBuildIdLen]);
 
@@ -245,11 +247,15 @@ void ElfWriterQuick<ElfTypes>::WriteDynamicSection() {
 }
 
 template <typename ElfTypes>
-void ElfWriterQuick<ElfTypes>::PrepareDebugInfo(const debug::DebugInfo& debug_info) {
+std::unique_ptr<ThreadPool> ElfWriterQuick<ElfTypes>::PrepareDebugInfo(
+    const debug::DebugInfo& debug_info) {
+  std::unique_ptr<ThreadPool> thread_pool;
   if (compiler_options_.GetGenerateMiniDebugInfo()) {
+    thread_pool.reset(ThreadPool::Create("Mini-debug-info writer", 1));
     // Prepare the mini-debug-info in background while we do other I/O.
     Thread* self = Thread::Current();
     debug_info_task_ = std::make_unique<DebugInfoTask>(
+        thread_pool.get(),
         builder_->GetIsa(),
         compiler_options_.GetInstructionSetFeatures(),
         builder_->GetText()->GetAddress(),
@@ -257,24 +263,21 @@ void ElfWriterQuick<ElfTypes>::PrepareDebugInfo(const debug::DebugInfo& debug_in
         builder_->GetDex()->Exists() ? builder_->GetDex()->GetAddress() : 0,
         dex_section_size_,
         debug_info);
-    debug_info_thread_pool_.reset(ThreadPool::Create("Mini-debug-info writer", 1));
-    debug_info_thread_pool_->AddTask(self, debug_info_task_.get());
-    debug_info_thread_pool_->StartWorkers(self);
+    thread_pool->AddTask(self, debug_info_task_.get());
+    thread_pool->StartWorkers(self);
   }
+  return thread_pool;
 }
 
 template <typename ElfTypes>
 void ElfWriterQuick<ElfTypes>::WriteDebugInfo(const debug::DebugInfo& debug_info) {
+  std::unique_ptr<ThreadPool> thread_pool;
   if (compiler_options_.GetGenerateMiniDebugInfo()) {
     // If mini-debug-info wasn't explicitly created so far, create it now (happens in tests).
     if (debug_info_task_ == nullptr) {
-      PrepareDebugInfo(debug_info);
+      thread_pool = PrepareDebugInfo(debug_info);
     }
-    // Wait for the mini-debug-info generation to finish and write it to disk.
-    Thread* self = Thread::Current();
-    DCHECK(debug_info_thread_pool_ != nullptr);
-    debug_info_thread_pool_->Wait(self, true, false);
-    builder_->WriteSection(".gnu_debugdata", debug_info_task_->GetResult());
+    builder_->WriteSection(".gnu_debugdata", debug_info_task_->WaitAndGetMiniDebugInfo());
   }
   // The Strip method expects debug info to be last (mini-debug-info is not stripped).
   if (!debug_info.Empty() && compiler_options_.GetGenerateDebugInfo()) {
diff --git a/dex2oat/linker/image_test.cc b/dex2oat/linker/image_test.cc
index 38f33fa923..c156a3817d 100644
--- a/dex2oat/linker/image_test.cc
+++ b/dex2oat/linker/image_test.cc
@@ -110,6 +110,11 @@ TEST_F(ImageTest, ImageHeaderIsValid) {
 // only if the copied method and the origin method are located in the
 // same oat file.
 TEST_F(ImageTest, TestDefaultMethods) {
+  // TODO(b/376621099): investigate LUCI failures (timeouts?) and re-enable this test.
+  // This is probably not related to riscv64 arch, but a combination of riscv64 and running
+  // on VM, but we don't use TEST_DISABLED_ON_VM to keep running it on other VM builders.
+  TEST_DISABLED_FOR_RISCV64();
+
   // Use this test to compile managed code to catch crashes when compiling the boot class path.
   // This test already needs to compile some managed methods and by compiling with "speed" we
   // avoid the need to create a specialized profile for the "speed-profile" compilation.
diff --git a/dex2oat/linker/image_test.h b/dex2oat/linker/image_test.h
index 71e7f4de19..3706b685fa 100644
--- a/dex2oat/linker/image_test.h
+++ b/dex2oat/linker/image_test.h
@@ -245,7 +245,6 @@ inline void ImageTest::DoCompile(ImageHeader::StorageMode storage_mode,
         elf_writers.emplace_back(CreateElfWriterQuick(*compiler_options_, oat_file.GetFile()));
         elf_writers.back()->Start();
         oat_writers.emplace_back(new OatWriter(*compiler_options_,
-                                               verification_results_.get(),
                                                &timings,
                                                /*profile_compilation_info*/nullptr));
       }
@@ -300,7 +299,7 @@ inline void ImageTest::DoCompile(ImageHeader::StorageMode storage_mode,
                                                        rodata[i],
                                                        (i == 0u) ? &key_value_store : nullptr);
         ASSERT_TRUE(start_rodata_ok);
-        oat_writer->Initialize(driver, writer.get(), cur_dex_files);
+        oat_writer->Initialize(driver, verification_results_.get(), writer.get(), cur_dex_files);
 
         oat_writer->FinishVdexFile(out_helper.vdex_files[i].GetFile(), /*verifier_deps=*/ nullptr);
 
diff --git a/dex2oat/linker/image_writer.cc b/dex2oat/linker/image_writer.cc
index 41cf1edaf8..179a0bb4f7 100644
--- a/dex2oat/linker/image_writer.cc
+++ b/dex2oat/linker/image_writer.cc
@@ -1715,20 +1715,22 @@ class ImageWriter::LayoutHelper::CollectClassesVisitor {
       auto app_class_loader = DecodeGlobalWithoutRB<mirror::ClassLoader>(
           vm, image_writer->app_class_loader_);
       ClassTable* app_class_table = app_class_loader->GetClassTable();
-      ReaderMutexLock lock(self, app_class_table->lock_);
-      DCHECK_EQ(app_class_table->classes_.size(), 1u);
-      const ClassTable::ClassSet& app_class_set = app_class_table->classes_[0];
-      DCHECK_GE(app_class_set.size(), image_info.class_table_size_);
-      boot_image_classes.reserve(app_class_set.size() - image_info.class_table_size_);
-      for (const ClassTable::TableSlot& slot : app_class_set) {
-        mirror::Class* klass = slot.Read<kWithoutReadBarrier>().Ptr();
-        if (image_writer->IsInBootImage(klass)) {
-          boot_image_classes.push_back(klass);
+      if (app_class_table != nullptr) {
+        ReaderMutexLock lock(self, app_class_table->lock_);
+        DCHECK_EQ(app_class_table->classes_.size(), 1u);
+        const ClassTable::ClassSet& app_class_set = app_class_table->classes_[0];
+        DCHECK_GE(app_class_set.size(), image_info.class_table_size_);
+        boot_image_classes.reserve(app_class_set.size() - image_info.class_table_size_);
+        for (const ClassTable::TableSlot& slot : app_class_set) {
+          mirror::Class* klass = slot.Read<kWithoutReadBarrier>().Ptr();
+          if (image_writer->IsInBootImage(klass)) {
+            boot_image_classes.push_back(klass);
+          }
         }
+        DCHECK_EQ(app_class_set.size() - image_info.class_table_size_, boot_image_classes.size());
+        // Increase the app class table size to include referenced boot image classes.
+        image_info.class_table_size_ = app_class_set.size();
       }
-      DCHECK_EQ(app_class_set.size() - image_info.class_table_size_, boot_image_classes.size());
-      // Increase the app class table size to include referenced boot image classes.
-      image_info.class_table_size_ = app_class_set.size();
     }
     for (ImageInfo& image_info : image_writer->image_infos_) {
       if (image_info.class_table_size_ != 0u) {
@@ -2871,7 +2873,7 @@ void ImageWriter::CreateHeader(size_t oat_index, size_t component_count) {
       target_ptr_size_);
 }
 
-ArtMethod* ImageWriter::GetImageMethodAddress(ArtMethod* method) {
+ArtMethod* ImageWriter::GetImageMethodAddress(ArtMethod* method) const {
   NativeObjectRelocation relocation = GetNativeRelocation(method);
   const ImageInfo& image_info = GetImageInfo(relocation.oat_index);
   CHECK_GE(relocation.offset, image_info.image_end_) << "ArtMethods should be after Objects";
@@ -3297,7 +3299,7 @@ class ImageWriter::FixupClassVisitor final : public FixupVisitor {
   }
 };
 
-ImageWriter::NativeObjectRelocation ImageWriter::GetNativeRelocation(void* obj) {
+ImageWriter::NativeObjectRelocation ImageWriter::GetNativeRelocation(void* obj) const {
   DCHECK(obj != nullptr);
   DCHECK(!IsInBootImage(obj));
   auto it = native_object_relocations_.find(obj);
diff --git a/dex2oat/linker/image_writer.h b/dex2oat/linker/image_writer.h
index efe8fa2304..9364e09521 100644
--- a/dex2oat/linker/image_writer.h
+++ b/dex2oat/linker/image_writer.h
@@ -128,6 +128,10 @@ class ImageWriter final {
     }
   }
 
+  uint32_t GetGlobalImageOffset(ArtMethod* method) const REQUIRES_SHARED(Locks::mutator_lock_) {
+    return reinterpret_cast<uint8_t*>(GetImageMethodAddress(method)) - global_image_begin_;
+  }
+
   uint32_t GetGlobalImageOffset(mirror::Object* object) const REQUIRES_SHARED(Locks::mutator_lock_) {
     DCHECK(object != nullptr);
     DCHECK(!IsInBootImage(object));
@@ -137,7 +141,7 @@ class ImageWriter final {
         image_info.image_begin_ + GetImageOffset(object, oat_index) - global_image_begin_);
   }
 
-  ArtMethod* GetImageMethodAddress(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_);
+  ArtMethod* GetImageMethodAddress(ArtMethod* method) const REQUIRES_SHARED(Locks::mutator_lock_);
   const void* GetIntrinsicReferenceAddress(uint32_t intrinsic_data)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -552,7 +556,7 @@ class ImageWriter final {
     uintptr_t offset;
   };
 
-  NativeObjectRelocation GetNativeRelocation(void* obj) REQUIRES_SHARED(Locks::mutator_lock_);
+  NativeObjectRelocation GetNativeRelocation(void* obj) const REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Location of where the object will be when the image is loaded at runtime.
   template <typename T>
diff --git a/dex2oat/linker/oat_writer.cc b/dex2oat/linker/oat_writer.cc
index 0ea446a0a2..a2500bd38a 100644
--- a/dex2oat/linker/oat_writer.cc
+++ b/dex2oat/linker/oat_writer.cc
@@ -105,7 +105,7 @@ const UnalignedDexFileHeader* AsUnalignedDexFileHeader(const uint8_t* raw_data)
 inline uint32_t CodeAlignmentSize(uint32_t header_offset, const CompiledMethod& compiled_method) {
   // We want to align the code rather than the preheader.
   uint32_t unaligned_code_offset = header_offset + sizeof(OatQuickMethodHeader);
-  uint32_t aligned_code_offset =  compiled_method.AlignCode(unaligned_code_offset);
+  uint32_t aligned_code_offset = compiled_method.AlignCode(unaligned_code_offset);
   return aligned_code_offset - unaligned_code_offset;
 }
 
@@ -344,14 +344,13 @@ class OatWriter::OatDexFile {
     << "file_offset=" << file_offset << " offset_=" << offset_
 
 OatWriter::OatWriter(const CompilerOptions& compiler_options,
-                     const VerificationResults* verification_results,
                      TimingLogger* timings,
                      ProfileCompilationInfo* info)
     : write_state_(WriteState::kAddingDexFileSources),
       timings_(timings),
       compiler_driver_(nullptr),
       compiler_options_(compiler_options),
-      verification_results_(verification_results),
+      verification_results_(nullptr),
       image_writer_(nullptr),
       extract_dex_files_into_vdex_(true),
       vdex_begin_(nullptr),
@@ -373,6 +372,12 @@ OatWriter::OatWriter(const CompilerOptions& compiler_options,
       bss_roots_offset_(0u),
       boot_image_rel_ro_entries_(),
       bss_method_entry_references_(),
+      bss_type_entry_references_(),
+      bss_public_type_entry_references_(),
+      bss_package_type_entry_references_(),
+      bss_string_entry_references_(),
+      bss_method_type_entry_references_(),
+      app_image_rel_ro_method_entries_(),
       bss_method_entries_(),
       app_image_rel_ro_type_entries_(),
       bss_type_entries_(),
@@ -573,10 +578,12 @@ bool OatWriter::StartRoData(const std::vector<const DexFile*>& dex_files,
 
 // Initialize the writer with the given parameters.
 void OatWriter::Initialize(const CompilerDriver* compiler_driver,
+                           const VerificationResults* verification_results,
                            ImageWriter* image_writer,
                            const std::vector<const DexFile*>& dex_files) {
   CHECK(write_state_ == WriteState::kInitialize);
   compiler_driver_ = compiler_driver;
+  verification_results_ = verification_results;
   image_writer_ = image_writer;
   dex_files_ = &dex_files;
   write_state_ = WriteState::kPrepareLayout;
@@ -738,6 +745,9 @@ class OatWriter::InitBssLayoutMethodVisitor : public DexMethodVisitor {
         if (patch.GetType() == LinkerPatch::Type::kBootImageRelRo) {
           writer_->boot_image_rel_ro_entries_.Overwrite(patch.BootImageOffset(),
                                                         /* placeholder */ 0u);
+        } else if (patch.GetType() == LinkerPatch::Type::kMethodAppImageRelRo) {
+          MethodReference target_method = patch.TargetMethod();
+          writer_->app_image_rel_ro_method_entries_.Overwrite(target_method, /* placeholder */ 0u);
         } else if (patch.GetType() == LinkerPatch::Type::kMethodBssEntry) {
           MethodReference target_method = patch.TargetMethod();
           AddBssReference(target_method,
@@ -913,14 +923,14 @@ struct OatWriter::OrderedMethodData {
   // Bin each method according to the profile flags.
   //
   // Groups by e.g.
-  //  -- not hot at all
-  //  -- hot
-  //  -- hot and startup
-  //  -- hot and post-startup
-  //  -- hot and startup and poststartup
-  //  -- startup
+  //  -- startup and hot and poststartup
+  //  -- startup and hot
   //  -- startup and post-startup
+  //  -- startup
+  //  -- hot and post-startup
+  //  -- hot
   //  -- post-startup
+  //  -- not hot at all
   //
   // (See MethodHotness enum definition for up-to-date binning order.)
   bool operator<(const OrderedMethodData& other) const {
@@ -932,8 +942,9 @@ struct OatWriter::OrderedMethodData {
       return name < other_name;
     }
 
-    // Use the profile's method hotness to determine sort order.
-    if (hotness_bits < other.hotness_bits) {
+    // Use the profile's method hotness to determine sort order, with startup
+    // methods appearing first.
+    if (hotness_bits > other.hotness_bits) {
       return true;
     }
 
@@ -1059,9 +1070,9 @@ class OatWriter::LayoutCodeMethodVisitor final : public OatDexMethodVisitor {
         // Note: Bin-to-bin order does not matter. If the kernel does or does not read-ahead
         // any memory, it only goes into the buffer cache and does not grow the PSS until the
         // first time that memory is referenced in the process.
-        constexpr uint32_t kHotBit = 1u;
-        constexpr uint32_t kStartupBit = 2u;
-        constexpr uint32_t kPostStartupBit = 4u;
+        constexpr uint32_t kStartupBit = 4u;
+        constexpr uint32_t kHotBit = 2u;
+        constexpr uint32_t kPostStartupBit = 1u;
         hotness_bits =
             (pci->IsHotMethod(profile_index_, method_index) ? kHotBit : 0u) |
             (pci->IsStartupMethod(profile_index_, method_index) ? kStartupBit : 0u) |
@@ -1686,6 +1697,16 @@ class OatWriter::WriteCodeMethodVisitor : public OrderedMethodVisitor {
                                                                    target_offset);
               break;
             }
+            case LinkerPatch::Type::kMethodAppImageRelRo: {
+              uint32_t target_offset =
+                  writer_->data_img_rel_ro_start_ +
+                  writer_->app_image_rel_ro_method_entries_.Get(patch.TargetMethod());
+              writer_->relative_patcher_->PatchPcRelativeReference(&patched_code_,
+                                                                   patch,
+                                                                   offset_ + literal_offset,
+                                                                   target_offset);
+              break;
+            }
             case LinkerPatch::Type::kMethodTypeBssEntry: {
               uint32_t target_offset =
                   writer_->bss_start_ + writer_->bss_method_type_entries_.Get(patch.TargetProto());
@@ -2366,7 +2387,9 @@ size_t OatWriter::InitOatCodeDexFiles(size_t offset) {
 
 size_t OatWriter::InitDataImgRelRoLayout(size_t offset) {
   DCHECK_EQ(data_img_rel_ro_size_, 0u);
-  if (boot_image_rel_ro_entries_.empty() && app_image_rel_ro_type_entries_.empty()) {
+  if (boot_image_rel_ro_entries_.empty() &&
+      app_image_rel_ro_method_entries_.empty() &&
+      app_image_rel_ro_type_entries_.empty()) {
     // Nothing to put to the .data.img.rel.ro section.
     return offset;
   }
@@ -2381,6 +2404,12 @@ size_t OatWriter::InitDataImgRelRoLayout(size_t offset) {
 
   data_img_rel_ro_app_image_offset_ = data_img_rel_ro_size_;
 
+  for (auto& entry : app_image_rel_ro_method_entries_) {
+    size_t& entry_offset = entry.second;
+    entry_offset = data_img_rel_ro_size_;
+    data_img_rel_ro_size_ += sizeof(uint32_t);
+  }
+
   for (auto& entry : app_image_rel_ro_type_entries_) {
     size_t& entry_offset = entry.second;
     entry_offset = data_img_rel_ro_size_;
@@ -3187,31 +3216,46 @@ size_t OatWriter::WriteCodeDexFiles(OutputStream* out,
 size_t OatWriter::WriteDataImgRelRo(OutputStream* out,
                                     size_t file_offset,
                                     size_t relative_offset) {
-  if (boot_image_rel_ro_entries_.empty() && app_image_rel_ro_type_entries_.empty()) {
+  size_t size = boot_image_rel_ro_entries_.size() +
+                app_image_rel_ro_method_entries_.size() +
+                app_image_rel_ro_type_entries_.size();
+  if (size == 0u) {
     return relative_offset;
   }
 
   // Write the entire .data.img.rel.ro with a single WriteFully().
   std::vector<uint32_t> data;
-  data.reserve(boot_image_rel_ro_entries_.size() + app_image_rel_ro_type_entries_.size());
+  data.reserve(size);
   for (const auto& entry : boot_image_rel_ro_entries_) {
     uint32_t boot_image_offset = entry.first;
     data.push_back(boot_image_offset);
   }
-  if (!app_image_rel_ro_type_entries_.empty()) {
+  if (!app_image_rel_ro_method_entries_.empty() || !app_image_rel_ro_type_entries_.empty()) {
     DCHECK(GetCompilerOptions().IsAppImage());
     ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
     ScopedObjectAccess soa(Thread::Current());
     const DexFile* last_dex_file = nullptr;
     ObjPtr<mirror::DexCache> dex_cache = nullptr;
     ObjPtr<mirror::ClassLoader> class_loader = nullptr;
-    for (const auto& entry : app_image_rel_ro_type_entries_) {
-      TypeReference target_type = entry.first;
-      if (target_type.dex_file != last_dex_file) {
-        dex_cache =  class_linker->FindDexCache(soa.Self(), *target_type.dex_file);
+    auto update_for_dex_file = [&](const DexFile* dex_file) REQUIRES_SHARED(Locks::mutator_lock_) {
+      if (dex_file != last_dex_file) {
+        dex_cache = class_linker->FindDexCache(soa.Self(), *dex_file);
         class_loader = dex_cache->GetClassLoader();
-        last_dex_file = target_type.dex_file;
+        last_dex_file = dex_file;
       }
+    };
+    for (const auto& entry : app_image_rel_ro_method_entries_) {
+      MethodReference target_method = entry.first;
+      update_for_dex_file(target_method.dex_file);
+      ArtMethod* method =
+          class_linker->LookupResolvedMethod(target_method.index, dex_cache, class_loader);
+      CHECK(method != nullptr);
+      uint32_t app_image_offset = image_writer_->GetGlobalImageOffset(method);
+      data.push_back(app_image_offset);
+    }
+    for (const auto& entry : app_image_rel_ro_type_entries_) {
+      TypeReference target_type = entry.first;
+      update_for_dex_file(target_type.dex_file);
       ObjPtr<mirror::Class> type =
           class_linker->LookupResolvedType(target_type.TypeIndex(), dex_cache, class_loader);
       CHECK(type != nullptr);
@@ -3219,7 +3263,7 @@ size_t OatWriter::WriteDataImgRelRo(OutputStream* out,
       data.push_back(app_image_offset);
     }
   }
-  DCHECK_EQ(data.size(), boot_image_rel_ro_entries_.size() + app_image_rel_ro_type_entries_.size());
+  DCHECK_EQ(data.size(), size);
   DCHECK_OFFSET();
   if (!out->WriteFully(data.data(), data.size() * sizeof(data[0]))) {
     PLOG(ERROR) << "Failed to write .data.img.rel.ro in " << out->GetLocation();
diff --git a/dex2oat/linker/oat_writer.h b/dex2oat/linker/oat_writer.h
index f2b239252c..c985812f94 100644
--- a/dex2oat/linker/oat_writer.h
+++ b/dex2oat/linker/oat_writer.h
@@ -115,7 +115,6 @@ enum class CopyOption {
 class OatWriter {
  public:
   OatWriter(const CompilerOptions& compiler_options,
-            const VerificationResults* verification_results,
             TimingLogger* timings,
             ProfileCompilationInfo* info);
 
@@ -171,6 +170,7 @@ class OatWriter {
                    SafeMap<std::string, std::string>* key_value_store);
   // Initialize the writer with the given parameters.
   void Initialize(const CompilerDriver* compiler_driver,
+                  const VerificationResults* verification_results,
                   ImageWriter* image_writer,
                   const std::vector<const DexFile*>& dex_files);
   bool FinishVdexFile(File* vdex_file, verifier::VerifierDeps* verifier_deps);
@@ -376,7 +376,7 @@ class OatWriter {
 
   const CompilerDriver* compiler_driver_;
   const CompilerOptions& compiler_options_;
-  const VerificationResults* const verification_results_;
+  const VerificationResults* verification_results_;
   ImageWriter* image_writer_;
   // Whether the dex files being compiled are going to be extracted to the vdex.
   bool extract_dex_files_into_vdex_;
@@ -457,6 +457,12 @@ class OatWriter {
   // Map for recording references to GcRoot<mirror::MethodType> entries in .bss.
   SafeMap<const DexFile*, BitVector> bss_method_type_entry_references_;
 
+  // Map for allocating app image ArtMethod entries in .data.img.rel.ro. Indexed by MethodReference
+  // for the target method in the dex file with the "method reference value comparator" for
+  // deduplication. The value is the target offset for patching, starting at
+  // `data_img_rel_ro_start_`.
+  SafeMap<MethodReference, size_t, MethodReferenceValueComparator> app_image_rel_ro_method_entries_;
+
   // Map for allocating ArtMethod entries in .bss. Indexed by MethodReference for the target
   // method in the dex file with the "method reference value comparator" for deduplication.
   // The value is the target offset for patching, starting at `bss_start_ + bss_methods_offset_`.
diff --git a/dex2oat/linker/oat_writer_test.cc b/dex2oat/linker/oat_writer_test.cc
index 8486bff0d3..0a585edb53 100644
--- a/dex2oat/linker/oat_writer_test.cc
+++ b/dex2oat/linker/oat_writer_test.cc
@@ -106,10 +106,7 @@ class OatTest : public CommonCompilerDriverTest {
                 bool verify) {
     TimingLogger timings("WriteElf", false, false);
     ClearBootImageOption();
-    OatWriter oat_writer(*compiler_options_,
-                         verification_results_.get(),
-                         &timings,
-                         /*profile_compilation_info*/nullptr);
+    OatWriter oat_writer(*compiler_options_, &timings, /*profile_compilation_info*/nullptr);
     for (const DexFile* dex_file : dex_files) {
       if (!oat_writer.AddRawDexFileSource(dex_file->GetContainer(),
                                           dex_file->Begin(),
@@ -131,10 +128,7 @@ class OatTest : public CommonCompilerDriverTest {
                 ProfileCompilationInfo* profile_compilation_info) {
     TimingLogger timings("WriteElf", false, false);
     ClearBootImageOption();
-    OatWriter oat_writer(*compiler_options_,
-                         verification_results_.get(),
-                         &timings,
-                         profile_compilation_info);
+    OatWriter oat_writer(*compiler_options_, &timings, profile_compilation_info);
     for (const char* dex_filename : dex_filenames) {
       if (!oat_writer.AddDexFileSource(dex_filename, dex_filename)) {
         return false;
@@ -153,10 +147,7 @@ class OatTest : public CommonCompilerDriverTest {
                 ProfileCompilationInfo* profile_compilation_info = nullptr) {
     TimingLogger timings("WriteElf", false, false);
     ClearBootImageOption();
-    OatWriter oat_writer(*compiler_options_,
-                         verification_results_.get(),
-                         &timings,
-                         profile_compilation_info);
+    OatWriter oat_writer(*compiler_options_, &timings, profile_compilation_info);
     if (!oat_writer.AddDexFileSource(std::move(dex_file_fd), location)) {
       return false;
     }
@@ -200,7 +191,8 @@ class OatTest : public CommonCompilerDriverTest {
     if (!oat_writer.StartRoData(dex_files, oat_rodata, &key_value_store)) {
       return false;
     }
-    oat_writer.Initialize(compiler_driver_.get(), /*image_writer=*/ nullptr, dex_files);
+    oat_writer.Initialize(
+        compiler_driver_.get(), verification_results_.get(), /*image_writer=*/ nullptr, dex_files);
     if (!oat_writer.FinishVdexFile(vdex_file, /*verifier_deps=*/ nullptr)) {
       return false;
     }
@@ -468,9 +460,7 @@ TEST_F(OatTest, WriteRead) {
     size_t num_virtual_methods = accessor.NumVirtualMethods();
 
     const char* descriptor = accessor.GetDescriptor();
-    ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(),
-                                                          descriptor,
-                                                          ScopedNullHandle<mirror::ClassLoader>());
+    ObjPtr<mirror::Class> klass = FindClass(descriptor, ScopedNullHandle<mirror::ClassLoader>());
 
     const OatFile::OatClass oat_class = oat_dex_file->GetOatClass(accessor.GetClassDefIndex());
     CHECK_EQ(ClassStatus::kNotReady, oat_class.GetStatus()) << descriptor;
diff --git a/dex2oat/transaction_test.cc b/dex2oat/transaction_test.cc
index 17a78ad6af..03ee7e98fa 100644
--- a/dex2oat/transaction_test.cc
+++ b/dex2oat/transaction_test.cc
@@ -59,14 +59,13 @@ class TransactionTest : public CommonTransactionTest {
     ASSERT_TRUE(h_klass->IsInitialized());
 
     // Load and verify utility class.
-    h_klass.Assign(class_linker_->FindClass(soa.Self(), "LTransaction$AbortHelperClass;",
-                                            class_loader));
+    h_klass.Assign(FindClass("LTransaction$AbortHelperClass;", class_loader));
     ASSERT_TRUE(h_klass != nullptr);
     class_linker_->VerifyClass(soa.Self(), /* verifier_deps= */ nullptr, h_klass);
     ASSERT_TRUE(h_klass->IsVerified());
 
     // Load and verify tested class.
-    h_klass.Assign(class_linker_->FindClass(soa.Self(), tested_class_signature, class_loader));
+    h_klass.Assign(FindClass(tested_class_signature, class_loader));
     ASSERT_TRUE(h_klass != nullptr);
     class_linker_->VerifyClass(soa.Self(), /* verifier_deps= */ nullptr, h_klass);
     ASSERT_TRUE(h_klass->IsVerified());
@@ -171,8 +170,7 @@ TEST_F(TransactionTest, StaticFieldsTest) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStaticFieldsTest;", class_loader)));
+  Handle<mirror::Class> h_klass = hs.NewHandle(FindClass("LStaticFieldsTest;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
   bool success = class_linker_->EnsureInitialized(soa.Self(), h_klass, true, true);
   ASSERT_TRUE(success);
@@ -267,8 +265,7 @@ TEST_F(TransactionTest, InstanceFieldsTest) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInstanceFieldsTest;", class_loader)));
+  Handle<mirror::Class> h_klass = hs.NewHandle(FindClass("LInstanceFieldsTest;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
   bool success = class_linker_->EnsureInitialized(soa.Self(), h_klass, true, true);
   ASSERT_TRUE(success);
@@ -419,8 +416,7 @@ TEST_F(TransactionTest, StaticArrayFieldsTest) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStaticArrayFieldsTest;", class_loader)));
+  Handle<mirror::Class> h_klass = hs.NewHandle(FindClass("LStaticArrayFieldsTest;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
   bool success = class_linker_->EnsureInitialized(soa.Self(), h_klass, true, true);
   ASSERT_TRUE(success);
@@ -542,9 +538,8 @@ TEST_F(TransactionTest, ResolveString) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LTransaction$ResolveString;",
-                                            class_loader)));
+  Handle<mirror::Class> h_klass =
+      hs.NewHandle(FindClass("LTransaction$ResolveString;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
 
   Handle<mirror::DexCache> h_dex_cache(hs.NewHandle(h_klass->GetDexCache()));
@@ -608,7 +603,7 @@ TEST_F(MethodTypeTransactionTest, ResolveMethodType) {
   class_linker_->EnsureInitialized(soa.Self(), h_klass, true, true);
   ASSERT_TRUE(h_klass->IsInitialized());
 
-  h_klass.Assign(class_linker_->FindClass(soa.Self(), "LTransaction;", class_loader));
+  h_klass.Assign(FindClass("LTransaction;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
 
   Handle<mirror::DexCache> h_dex_cache(hs.NewHandle(h_klass->GetDexCache()));
@@ -640,9 +635,8 @@ TEST_F(TransactionTest, EmptyClass) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LTransaction$EmptyStatic;",
-                                            class_loader)));
+  Handle<mirror::Class> h_klass =
+      hs.NewHandle(FindClass("LTransaction$EmptyStatic;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
   class_linker_->VerifyClass(soa.Self(), /* verifier_deps= */ nullptr, h_klass);
   ASSERT_TRUE(h_klass->IsVerified());
@@ -663,9 +657,8 @@ TEST_F(TransactionTest, StaticFieldClass) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
   ASSERT_TRUE(class_loader != nullptr);
 
-  Handle<mirror::Class> h_klass(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LTransaction$StaticFieldClass;",
-                                            class_loader)));
+  Handle<mirror::Class> h_klass =
+      hs.NewHandle(FindClass("LTransaction$StaticFieldClass;", class_loader));
   ASSERT_TRUE(h_klass != nullptr);
   class_linker_->VerifyClass(soa.Self(), /* verifier_deps= */ nullptr, h_klass);
   ASSERT_TRUE(h_klass->IsVerified());
@@ -724,8 +717,8 @@ TEST_F(TransactionTest, Constraints) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Transaction"))));
 
   gc::Heap* heap = Runtime::Current()->GetHeap();
-  Handle<mirror::Class> boolean_class = hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "Ljava/lang/Boolean;", class_loader));
+  Handle<mirror::Class> boolean_class =
+      hs.NewHandle(FindClass("Ljava/lang/Boolean;", class_loader));
   ASSERT_TRUE(boolean_class != nullptr);
   ASSERT_TRUE(heap->ObjectIsInBootImageSpace(boolean_class.Get()));
   ArtField* true_field = boolean_class->FindDeclaredStaticField("TRUE", "Ljava/lang/Boolean;");
@@ -738,23 +731,23 @@ TEST_F(TransactionTest, Constraints) {
   ASSERT_TRUE(value_field != nullptr);
   ASSERT_FALSE(value_field->IsStatic());
 
-  Handle<mirror::Class> static_field_class(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LTransaction$StaticFieldClass;", class_loader)));
+  Handle<mirror::Class> static_field_class =
+      hs.NewHandle(FindClass("LTransaction$StaticFieldClass;", class_loader));
   ASSERT_TRUE(static_field_class != nullptr);
   ASSERT_FALSE(heap->ObjectIsInBootImageSpace(static_field_class.Get()));
   ArtField* int_field = static_field_class->FindDeclaredStaticField("intField", "I");
   ASSERT_TRUE(int_field != nullptr);
 
-  Handle<mirror::Class> static_fields_test_class(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LStaticFieldsTest;", class_loader)));
+  Handle<mirror::Class> static_fields_test_class =
+      hs.NewHandle(FindClass("LStaticFieldsTest;", class_loader));
   ASSERT_TRUE(static_fields_test_class != nullptr);
   ASSERT_FALSE(heap->ObjectIsInBootImageSpace(static_fields_test_class.Get()));
   ArtField* static_fields_test_int_field =
       static_fields_test_class->FindDeclaredStaticField("intField", "I");
   ASSERT_TRUE(static_fields_test_int_field != nullptr);
 
-  Handle<mirror::Class> instance_fields_test_class(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LInstanceFieldsTest;", class_loader)));
+  Handle<mirror::Class> instance_fields_test_class =
+      hs.NewHandle(FindClass("LInstanceFieldsTest;", class_loader));
   ASSERT_TRUE(instance_fields_test_class != nullptr);
   ASSERT_FALSE(heap->ObjectIsInBootImageSpace(instance_fields_test_class.Get()));
   ArtField* instance_fields_test_int_field =
@@ -768,8 +761,7 @@ TEST_F(TransactionTest, Constraints) {
   // The `long[].class` should be in the boot image but `long[][][].class` should not.
   // (We have seen `long[][].class` both present and missing from the boot image,
   // depending on the libcore code, so we do not use it for this test.)
-  Handle<mirror::Class> long_array_dim3_class = hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "[[[J", class_loader));
+  Handle<mirror::Class> long_array_dim3_class = hs.NewHandle(FindClass("[[[J", class_loader));
   ASSERT_TRUE(long_array_dim3_class != nullptr);
   ASSERT_FALSE(heap->ObjectIsInBootImageSpace(long_array_dim3_class.Get()));
   ASSERT_TRUE(heap->ObjectIsInBootImageSpace(
diff --git a/dex2oat/verifier_deps_test.cc b/dex2oat/verifier_deps_test.cc
index 2cddcedcfa..828691d3e2 100644
--- a/dex2oat/verifier_deps_test.cc
+++ b/dex2oat/verifier_deps_test.cc
@@ -37,6 +37,7 @@
 #include "thread.h"
 #include "utils/atomic_dex_ref_map-inl.h"
 #include "verifier/method_verifier-inl.h"
+#include "verifier/reg_type_cache.h"
 
 namespace art {
 namespace verifier {
@@ -79,7 +80,7 @@ class VerifierDepsTest : public CommonCompilerDriverTest {
     Handle<mirror::ClassLoader> class_loader_handle(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader_)));
     ObjPtr<mirror::Class> klass =
-        class_linker_->FindClass(soa.Self(), name.c_str(), class_loader_handle);
+        class_linker_->FindClass(soa.Self(), name.c_str(), name.length(), class_loader_handle);
     if (klass == nullptr) {
       DCHECK(soa.Self()->IsExceptionPending());
       soa.Self()->ClearException();
@@ -153,27 +154,25 @@ class VerifierDepsTest : public CommonCompilerDriverTest {
 
     for (const ClassAccessor::Method& method : accessor.GetMethods()) {
       ArtMethod* resolved_method =
-          class_linker_->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(
+          class_linker_->ResolveMethodId(
               method.GetIndex(),
               dex_cache_handle,
-              class_loader_handle,
-              /* referrer= */ nullptr,
-              method.GetInvokeType(class_def->access_flags_));
+              class_loader_handle);
       CHECK(resolved_method != nullptr);
       if (method_name == resolved_method->GetName()) {
+        ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
+        RegTypeCache reg_types(
+            soa.Self(), class_linker_, arena_pool, class_loader_handle, primary_dex_file_);
         std::unique_ptr<MethodVerifier> verifier(
             MethodVerifier::CreateVerifier(soa.Self(),
+                                           &reg_types,
                                            callbacks_->GetVerifierDeps(),
-                                           primary_dex_file_,
                                            dex_cache_handle,
-                                           class_loader_handle,
                                            *class_def,
                                            method.GetCodeItem(),
                                            method.GetIndex(),
                                            method.GetAccessFlags(),
-                                           /* can_load_classes= */ true,
-                                           /* verify to dump */ false,
-                                           /* allow_thread_suspension= */ true,
+                                           /* verify_to_dump= */ false,
                                            /* api_level= */ 0));
         verifier->Verify();
         soa.Self()->SetVerifierDeps(nullptr);
@@ -221,9 +220,8 @@ class VerifierDepsTest : public CommonCompilerDriverTest {
       const std::vector<bool>& verified_classes = deps.GetVerifiedClasses(*dex_file);
       ASSERT_EQ(verified_classes.size(), dex_file->NumClassDefs());
       for (uint32_t i = 0; i < dex_file->NumClassDefs(); ++i) {
-        const dex::ClassDef& class_def = dex_file->GetClassDef(i);
-        const char* descriptor = dex_file->GetClassDescriptor(class_def);
-        cls.Assign(class_linker_->FindClass(soa.Self(), descriptor, class_loader_handle));
+        cls.Assign(class_linker_->FindClass(
+            soa.Self(), *dex_file, dex_file->GetClassDef(i).class_idx_, class_loader_handle));
         if (cls == nullptr) {
           CHECK(soa.Self()->IsExceptionPending());
           soa.Self()->ClearException();
@@ -274,8 +272,9 @@ class VerifierDepsTest : public CommonCompilerDriverTest {
       for (auto& set : storage) {
         for (auto& entry : set) {
           std::string actual_destination =
-              verifier_deps_->GetStringFromId(dex_file, entry.GetDestination());
-          std::string actual_source = verifier_deps_->GetStringFromId(dex_file, entry.GetSource());
+              verifier_deps_->GetStringFromIndex(dex_file, entry.GetDestination());
+          std::string actual_source =
+              verifier_deps_->GetStringFromIndex(dex_file, entry.GetSource());
           if ((expected_destination == actual_destination) && (expected_source == actual_source)) {
             return true;
           }
@@ -352,19 +351,19 @@ TEST_F(VerifierDepsTest, StringToId) {
 
   dex::StringIndex id_Main1 = verifier_deps_->GetIdFromString(*primary_dex_file_, "LMain;");
   ASSERT_LT(id_Main1.index_, primary_dex_file_->NumStringIds());
-  ASSERT_EQ("LMain;", verifier_deps_->GetStringFromId(*primary_dex_file_, id_Main1));
+  ASSERT_STREQ("LMain;", verifier_deps_->GetStringFromIndex(*primary_dex_file_, id_Main1));
 
   dex::StringIndex id_Main2 = verifier_deps_->GetIdFromString(*primary_dex_file_, "LMain;");
   ASSERT_LT(id_Main2.index_, primary_dex_file_->NumStringIds());
-  ASSERT_EQ("LMain;", verifier_deps_->GetStringFromId(*primary_dex_file_, id_Main2));
+  ASSERT_STREQ("LMain;", verifier_deps_->GetStringFromIndex(*primary_dex_file_, id_Main2));
 
   dex::StringIndex id_Lorem1 = verifier_deps_->GetIdFromString(*primary_dex_file_, "Lorem ipsum");
   ASSERT_GE(id_Lorem1.index_, primary_dex_file_->NumStringIds());
-  ASSERT_EQ("Lorem ipsum", verifier_deps_->GetStringFromId(*primary_dex_file_, id_Lorem1));
+  ASSERT_STREQ("Lorem ipsum", verifier_deps_->GetStringFromIndex(*primary_dex_file_, id_Lorem1));
 
   dex::StringIndex id_Lorem2 = verifier_deps_->GetIdFromString(*primary_dex_file_, "Lorem ipsum");
   ASSERT_GE(id_Lorem2.index_, primary_dex_file_->NumStringIds());
-  ASSERT_EQ("Lorem ipsum", verifier_deps_->GetStringFromId(*primary_dex_file_, id_Lorem2));
+  ASSERT_STREQ("Lorem ipsum", verifier_deps_->GetStringFromIndex(*primary_dex_file_, id_Lorem2));
 
   ASSERT_EQ(id_Main1, id_Main2);
   ASSERT_EQ(id_Lorem1, id_Lorem2);
diff --git a/dexdump/Android.bp b/dexdump/Android.bp
index 9b8989bf09..952bd27ac9 100644
--- a/dexdump/Android.bp
+++ b/dexdump/Android.bp
@@ -43,7 +43,7 @@ art_cc_binary {
     target: {
         android: {
             shared_libs: [
-                "libdexfile",
+                "libdexfile#impl",
                 "libartbase",
                 "libbase",
             ],
diff --git a/dexdump/dexdump.cc b/dexdump/dexdump.cc
index ce0eb130fb..43ed224b01 100644
--- a/dexdump/dexdump.cc
+++ b/dexdump/dexdump.cc
@@ -968,13 +968,6 @@ static std::unique_ptr<char[]> indexString(const DexFile* pDexFile,
         outSize = snprintf(buf.get(), bufSize, "<field?> // field@%0*x", width, index);
       }
       break;
-    case Instruction::kIndexVtableOffset:
-      outSize = snprintf(buf.get(), bufSize, "[%0*x] // vtable #%0*x",
-                         width, index, width, index);
-      break;
-    case Instruction::kIndexFieldOffset:
-      outSize = snprintf(buf.get(), bufSize, "[obj+%0*x]", width, index);
-      break;
     case Instruction::kIndexMethodAndProtoRef: {
       std::string method("<method?>");
       std::string proto("<proto?>");
diff --git a/dexlist/Android.bp b/dexlist/Android.bp
index 86683520f2..3a232a778b 100644
--- a/dexlist/Android.bp
+++ b/dexlist/Android.bp
@@ -28,7 +28,7 @@ art_cc_binary {
     host_supported: true,
     srcs: ["dexlist.cc"],
     shared_libs: [
-        "libdexfile",
+        "libdexfile#impl",
         "libartbase",
         "libbase",
     ],
diff --git a/dexopt_chroot_setup/Android.bp b/dexopt_chroot_setup/Android.bp
index 0b4ce9669d..e51dfc0393 100644
--- a/dexopt_chroot_setup/Android.bp
+++ b/dexopt_chroot_setup/Android.bp
@@ -84,7 +84,6 @@ art_cc_test {
         "libarttools",
         "libbase",
         "libgmock",
-        "libselinux",
     ],
     test_config_template: "art_standalone_dexopt_chroot_setup_tests.xml",
 }
diff --git a/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml b/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
index e4ba301579..3ec1692abd 100644
--- a/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
+++ b/dexopt_chroot_setup/art_standalone_dexopt_chroot_setup_tests.xml
@@ -43,7 +43,6 @@
         <option name="mainline-module-package-name" value="com.android.art" />
     </object>
 
-    <!-- Only run tests if the device under test is SDK version 34 (Android 14) or above. -->
-    <!-- TODO(jiakaiz): Change it to 35 once the SDK version is bumped. -->
-    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk34ModuleController" />
+    <!-- Only run tests if the device under test is SDK version 35 (Android 15) or above. -->
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk35ModuleController" />
 </configuration>
diff --git a/dexopt_chroot_setup/dexopt_chroot_setup.cc b/dexopt_chroot_setup/dexopt_chroot_setup.cc
index 7a1467a149..a88195d443 100644
--- a/dexopt_chroot_setup/dexopt_chroot_setup.cc
+++ b/dexopt_chroot_setup/dexopt_chroot_setup.cc
@@ -46,6 +46,7 @@
 #include "android-base/result.h"
 #include "android-base/scopeguard.h"
 #include "android-base/strings.h"
+#include "android-base/unique_fd.h"
 #include "android/binder_auto_utils.h"
 #include "android/binder_manager.h"
 #include "android/binder_process.h"
@@ -72,10 +73,12 @@ using ::android::base::Join;
 using ::android::base::make_scope_guard;
 using ::android::base::NoDestructor;
 using ::android::base::ReadFileToString;
+using ::android::base::Readlink;
 using ::android::base::Result;
 using ::android::base::SetProperty;
 using ::android::base::Split;
 using ::android::base::Tokenize;
+using ::android::base::unique_fd;
 using ::android::base::WaitForProperty;
 using ::android::base::WriteStringToFile;
 using ::android::fs_mgr::FstabEntry;
@@ -134,6 +137,29 @@ Result<void> CreateDir(const std::string& path) {
   return {};
 }
 
+Result<bool> IsSymlink(const std::string& path) {
+  std::error_code ec;
+  bool res = std::filesystem::is_symlink(path, ec);
+  if (ec) {
+    return Errorf("Failed to create dir '{}': {}", path, ec.message());
+  }
+  return res;
+}
+
+Result<bool> IsSelfOrParentSymlink(const std::string& path) {
+  // We don't use `Realpath` because it does a `stat(2)` call which requires the SELinux "getattr"
+  // permission. which we don't have on all mount points.
+  unique_fd fd(open(path.c_str(), O_PATH | O_CLOEXEC));
+  if (fd.get() < 0) {
+    return ErrnoErrorf("Failed to open '{}' to resolve real path", path);
+  }
+  std::string real_path;
+  if (!Readlink(ART_FORMAT("/proc/self/fd/{}", fd.get()), &real_path)) {
+    return ErrnoErrorf("Failed to resolve real path for '{}'", path);
+  }
+  return path != real_path;
+}
+
 Result<void> Unmount(const std::string& target, bool logging = true) {
   if (umount2(target.c_str(), UMOUNT_NOFOLLOW) == 0) {
     LOG_IF(INFO, logging) << ART_FORMAT("Unmounted '{}'", target);
@@ -154,6 +180,8 @@ Result<void> Unmount(const std::string& target, bool logging = true) {
 // `BindMountDirect` is safe to use only if there is no child mount points under `target`. DO NOT
 // mount or unmount under `target` because mount events propagate to `source`.
 Result<void> BindMountDirect(const std::string& source, const std::string& target) {
+  // Don't follow symlinks.
+  CHECK(!OR_RETURN(IsSelfOrParentSymlink(target))) << target;
   if (mount(source.c_str(),
             target.c_str(),
             /*fs_type=*/nullptr,
@@ -169,6 +197,8 @@ Result<void> BindMountDirect(const std::string& source, const std::string& targe
 Result<void> BindMount(const std::string& source, const std::string& target) {
   // Don't bind-mount repeatedly.
   CHECK(!PathStartsWith(source, DexoptChrootSetup::CHROOT_DIR));
+  // Don't follow symlinks.
+  CHECK(!OR_RETURN(IsSelfOrParentSymlink(target))) << target;
   // system_server has a different mount namespace from init, and it uses slave mounts. E.g:
   //
   //    a: init mount ns: shared(1):          /foo
@@ -284,7 +314,21 @@ Result<void> BindMountRecursive(const std::string& source, const std::string& ta
       // `source` itself. Already mounted.
       continue;
     }
-    OR_RETURN(BindMount(entry.mount_point, std::string(target).append(sub_dir)));
+    if (Result<void> result = BindMount(entry.mount_point, std::string(target).append(sub_dir));
+        !result.ok()) {
+      // Match paths for the "u:object_r:apk_tmp_file:s0" file context in
+      // system/sepolicy/private/file_contexts.
+      std::regex apk_tmp_file_re(R"re((/data|/mnt/expand/[^/]+)/app/vmdl[^/]+\.tmp(/.*)?)re");
+      std::smatch match;
+      if (std::regex_match(entry.mount_point, match, apk_tmp_file_re)) {
+        // Don't bother. The mount point is a temporary directory created by Package Manager during
+        // app install. We won't be able to dexopt the app there anyway because it's not in the
+        // Package Manager's snapshot.
+        LOG(INFO) << ART_FORMAT("Skipped temporary mount point '{}'", entry.mount_point);
+        continue;
+      }
+      return result;
+    }
   }
   return {};
 }
@@ -559,10 +603,11 @@ Result<void> DexoptChrootSetup::SetUpChroot(const std::optional<std::string>& ot
     // partitions are not remounted, bind-mounting "/system" doesn't hurt.
     OR_RETURN(BindMount("/system", PathInChroot("/system")));
     for (const auto& [partition, mount_point] : additional_system_partitions) {
-      // Some additional partitions are optional, but that's okay. The root filesystem (mounted at
-      // `/`) has empty directories for additional partitions. If additional partitions don't exist,
-      // we'll just be bind-mounting empty directories.
-      OR_RETURN(BindMount(mount_point, PathInChroot(mount_point)));
+      // Some additional partitions are optional. On a device where an additional partition doesn't
+      // exist, the mount point of the partition is a symlink to a directory inside /system.
+      if (!OR_RETURN(IsSymlink(mount_point))) {
+        OR_RETURN(BindMount(mount_point, PathInChroot(mount_point)));
+      }
     }
   } else {
     CHECK(ota_slot.value() == "_a" || ota_slot.value() == "_b");
diff --git a/dexopt_chroot_setup/dexopt_chroot_setup_test.cc b/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
index bbe0da352c..aa0eb5e604 100644
--- a/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
+++ b/dexopt_chroot_setup/dexopt_chroot_setup_test.cc
@@ -35,7 +35,6 @@
 #include "exec_utils.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "selinux/selinux.h"
 #include "tools/binder_utils.h"
 #include "tools/cmdline_builder.h"
 
@@ -58,24 +57,6 @@ class DexoptChrootSetupTest : public CommonArtTest {
     CommonArtTest::SetUp();
     dexopt_chroot_setup_ = ndk::SharedRefBase::make<DexoptChrootSetup>();
 
-    // TODO(jiakaiz): Delete this one the SDK version is bumped to 35.
-    char* con;
-    if (getfilecon(DexoptChrootSetup::PRE_REBOOT_DEXOPT_DIR, &con) < 0) {
-      ASSERT_EQ(errno, ENOENT) << ART_FORMAT("Failed to getfilecon '{}': {}",
-                                             DexoptChrootSetup::PRE_REBOOT_DEXOPT_DIR,
-                                             strerror(errno));
-      GTEST_SKIP() << ART_FORMAT("This platform is too old and doesn't have directory '{}'",
-                                 DexoptChrootSetup::PRE_REBOOT_DEXOPT_DIR);
-    }
-    {
-      auto cleanup = ScopeGuard([&]() { freecon(con); });
-      constexpr std::string_view kExpectedCon = "u:object_r:pre_reboot_dexopt_file:s0";
-      if (con != kExpectedCon) {
-        GTEST_SKIP() << ART_FORMAT("This platform is too old and doesn't have SELinux context '{}'",
-                                   kExpectedCon);
-      }
-    }
-
     // Note that if a real Pre-reboot Dexopt is kicked off after this check, the test will still
     // fail, but that should be very rare.
     if (std::filesystem::exists(DexoptChrootSetup::CHROOT_DIR)) {
diff --git a/dexoptanalyzer/Android.bp b/dexoptanalyzer/Android.bp
index 06ccfba5ea..76d879f1cf 100644
--- a/dexoptanalyzer/Android.bp
+++ b/dexoptanalyzer/Android.bp
@@ -87,7 +87,7 @@ art_cc_defaults {
     defaults: [
         "art_libunwindstack_static_defaults", // Must be statically linked in standalone tests
     ],
-    data: [
+    device_common_data: [
         ":art-gtest-jars-LinkageTest",
         ":art-gtest-jars-Main",
         ":art-gtest-jars-MainStripped",
@@ -104,6 +104,7 @@ art_cc_defaults {
             required: [
                 "dex2oatd",
                 "dexoptanalyzerd",
+                "art_boot_images",
             ],
         },
     },
diff --git a/disassembler/disassembler_riscv64.cc b/disassembler/disassembler_riscv64.cc
index c0c5986160..5d2b5b4d73 100644
--- a/disassembler/disassembler_riscv64.cc
+++ b/disassembler/disassembler_riscv64.cc
@@ -779,13 +779,13 @@ void DisassemblerRiscv64::Printer::Print32BinOp(uint32_t insn32) {
   DCHECK_EQ(insn32 & 0x77u, 0x33u);  // Note: Bit 0x8 selects narrow binop.
   bool narrow = (insn32 & 0x8u) != 0u;
   uint32_t funct3 = (insn32 >> 12) & 7u;
+  uint32_t funct7 = (insn32 >> 25) & 0x7Fu;
   uint32_t rd = GetRd(insn32);
   uint32_t rs1 = GetRs1(insn32);
   uint32_t rs2 = GetRs2(insn32);
-  uint32_t high_bits = insn32 & 0xfe000000u;
 
   // Print shorter macro instruction notation if available.
-  if (high_bits == 0x40000000u && funct3 == /*SUB*/ 0u && rs1 == Zero) {
+  if (funct7 == 0x20u && funct3 == /*SUB*/ 0u && rs1 == Zero) {
     os_ << (narrow ? "negw " : "neg ") << XRegName(rd) << ", " << XRegName(rs2);
   } else if (!narrow && funct3 == /*SLT*/ 2u && rs2 == Zero) {
     os_ << "sltz " << XRegName(rd) << ", " << XRegName(rs1);
@@ -793,47 +793,47 @@ void DisassemblerRiscv64::Printer::Print32BinOp(uint32_t insn32) {
     os_ << "sgtz " << XRegName(rd) << ", " << XRegName(rs2);
   } else if (!narrow && funct3 == /*SLTU*/ 3u && rs1 == Zero) {
     os_ << "snez " << XRegName(rd) << ", " << XRegName(rs2);
-  } else if (narrow && high_bits == 0x08000000u && funct3 == /*ADD.UW*/ 0u && rs2 == Zero) {
+  } else if (narrow && funct7 == 4u && funct3 == /*ADD.UW*/ 0u && rs2 == Zero) {
     os_ << "zext.w " << XRegName(rd) << ", " << XRegName(rs1);
-  } else if (!narrow && high_bits == 0x48000000u &&
+  } else if (!narrow && funct7 == 0x24u &&
              (funct3 == /*BCLR*/ 1u || funct3 == /*BEXT*/ 5u)) {
     os_ << ((funct3 == /*BCLR*/ 1u) ? "bclr" : "bext");
-  } else if (!narrow && high_bits == 0x68000000u && funct3 == /*BINV*/ 1u) {
+  } else if (!narrow && funct7 == 0x34u && funct3 == /*BINV*/ 1u) {
     os_ << "binv";
-  } else if (!narrow && high_bits == 0x28000000u && funct3 == /*BSET*/ 1u) {
+  } else if (!narrow && funct7 == 0x14u && funct3 == /*BSET*/ 1u) {
     os_ << "bset";
   } else {
     bool bad_high_bits = false;
-    if (high_bits == 0x40000000u && (funct3 == /*SUB*/ 0u || funct3 == /*SRA*/ 5u)) {
+    if (funct7 == 0x20u && (funct3 == /*SUB*/ 0u || funct3 == /*SRA*/ 5u)) {
       os_ << ((funct3 == /*SUB*/ 0u) ? "sub" : "sra");
-    } else if (high_bits == 0x02000000u &&
+    } else if (funct7 == 1u &&
                (!narrow || (funct3 == /*MUL*/ 0u || funct3 >= /*DIV/DIVU/REM/REMU*/ 4u))) {
       static const char* const kOpcodes[] = {
           "mul", "mulh", "mulhsu", "mulhu", "div", "divu", "rem", "remu"
       };
       os_ << kOpcodes[funct3];
-    } else if (high_bits == 0x08000000u && narrow && funct3 == /*ADD.UW*/ 0u) {
+    } else if (funct7 == 4u && narrow && funct3 == /*ADD.UW*/ 0u) {
       os_ << "add.u";  // "w" is added below.
-    } else if (high_bits == 0x20000000u && (funct3 & 1u) == 0u && funct3 != 0u) {
+    } else if (funct7 == 0x10u && (funct3 & 1u) == 0u && funct3 != 0u) {
       static const char* const kZbaOpcodes[] = { nullptr, "sh1add", "sh2add", "sh3add" };
       DCHECK(kZbaOpcodes[funct3 >> 1] != nullptr);
       os_ << kZbaOpcodes[funct3 >> 1] << (narrow ? ".u" /* "w" is added below. */ : "");
-    } else if (high_bits == 0x40000000u && !narrow && funct3 >= 4u && funct3 != 5u) {
+    } else if (funct7 == 0x20u && !narrow && funct3 >= 4u && funct3 != 5u) {
       static const char* const kZbbNegOpcodes[] = { "xnor", nullptr, "orn", "andn" };
       DCHECK(kZbbNegOpcodes[funct3 - 4u] != nullptr);
       os_ << kZbbNegOpcodes[funct3 - 4u];
-    } else if (high_bits == 0x0a000000u && !narrow && funct3 >= 4u) {
+    } else if (funct7 == 0x5u && !narrow && funct3 >= 4u) {
       static const char* const kZbbMinMaxOpcodes[] = { "min", "minu", "max", "maxu" };
       DCHECK(kZbbMinMaxOpcodes[funct3 - 4u] != nullptr);
       os_ << kZbbMinMaxOpcodes[funct3 - 4u];
-    } else if (high_bits == 0x60000000u && (funct3 == /*ROL*/ 1u || funct3 == /*ROL*/ 5u)) {
+    } else if (funct7 == 0x30u && (funct3 == /*ROL*/ 1u || funct3 == /*ROL*/ 5u)) {
       os_ << (funct3 == /*ROL*/ 1u ? "rol" : "ror");
     } else if (!narrow || (funct3 == /*ADD*/ 0u || funct3 == /*SLL*/ 1u || funct3 == /*SRL*/ 5u)) {
       static const char* const kOpcodes[] = {
           "add", "sll", "slt", "sltu", "xor", "srl", "or", "and"
       };
       os_ << kOpcodes[funct3];
-      bad_high_bits = (high_bits != 0u);
+      bad_high_bits = funct7 != 0u;
     } else {
       DCHECK(narrow);
       os_ << "<unknown32>";  // Some of the above instructions do not have a narrow version.
diff --git a/dt_fd_forward/Android.bp b/dt_fd_forward/Android.bp
index 08f52c7775..9236fd1fe4 100644
--- a/dt_fd_forward/Android.bp
+++ b/dt_fd_forward/Android.bp
@@ -47,8 +47,8 @@ license {
     ],
 }
 
-cc_defaults {
-    name: "dt_fd_forward-defaults",
+art_cc_library {
+    name: "libdt_fd_forward",
     host_supported: true,
     srcs: ["dt_fd_forward.cc"],
     defaults: ["art_defaults"],
@@ -74,21 +74,9 @@ cc_defaults {
         "dt_fd_forward_export",
         "art_libartbase_headers", // For strlcpy emulation.
     ],
-}
 
-art_cc_library {
-    name: "libdt_fd_forward",
-    defaults: ["dt_fd_forward-defaults"],
     apex_available: [
         "com.android.art",
         "com.android.art.debug",
     ],
 }
-
-art_cc_library {
-    name: "libdt_fd_forwardd",
-    defaults: [
-        "art_debug_defaults",
-        "dt_fd_forward-defaults",
-    ],
-}
diff --git a/imgdiag/Android.bp b/imgdiag/Android.bp
index 2890cc07dd..cb4efa8c49 100644
--- a/imgdiag/Android.bp
+++ b/imgdiag/Android.bp
@@ -101,7 +101,10 @@ art_cc_test {
     srcs: ["imgdiag_test.cc"],
     target: {
         host: {
-            required: ["imgdiagd"],
+            required: [
+                "imgdiagd",
+                "art_boot_images",
+            ],
         },
     },
 }
diff --git a/imgdiag/imgdiag_test.cc b/imgdiag/imgdiag_test.cc
index 9dd7953a24..e523022803 100644
--- a/imgdiag/imgdiag_test.cc
+++ b/imgdiag/imgdiag_test.cc
@@ -119,6 +119,9 @@ TEST_F(ImgDiagTest, DISABLED_ImageDiffPidSelf) {
   // This should succeed because we have a runtime and so it should
   // be able to map in the boot.art and do a diff for it.
 
+  // Not allowed to read /proc/kpagestats on VM (in the same way as on host).
+  TEST_DISABLED_ON_VM();
+
   // Run imgdiag --image-diff-pid=$(self pid) and wait until it's done with a 0 exit code.
   std::string error_msg;
   ASSERT_TRUE(ExecDefaultBootImage(getpid(), &error_msg)) << "Failed to execute -- because: "
diff --git a/libartbase/arch/instruction_set.h b/libartbase/arch/instruction_set.h
index 69b01dbfee..8b90aa5a9d 100644
--- a/libartbase/arch/instruction_set.h
+++ b/libartbase/arch/instruction_set.h
@@ -38,6 +38,8 @@ enum class InstructionSet {
 };
 std::ostream& operator<<(std::ostream& os, InstructionSet rhs);
 
+// kRuntimeISA must match the ISA of the machine that ART will be run on. This ISA will be used for
+// the native context, native stack frame and native ABI.
 #if defined(__arm__)
 static constexpr InstructionSet kRuntimeISA = InstructionSet::kArm;
 #elif defined(__aarch64__)
@@ -52,6 +54,12 @@ static constexpr InstructionSet kRuntimeISA = InstructionSet::kX86_64;
 static constexpr InstructionSet kRuntimeISA = InstructionSet::kNone;
 #endif
 
+// The ISA that ART will generate quick code for, i.e.: that java code will be compiled to. This
+// ISA will be used for the quick context, quick stack frame and quick ABI. This may differ from
+// kRuntimeISA if the simulator is in use where, for example, the native runtime is x86-64 but the
+// quick code generated by the compiler is Arm64.
+static constexpr InstructionSet kRuntimeQuickCodeISA = kRuntimeISA;
+
 // Architecture-specific pointer sizes
 static constexpr PointerSize kArmPointerSize = PointerSize::k32;
 static constexpr PointerSize kArm64PointerSize = PointerSize::k64;
diff --git a/libartbase/base/arena_allocator.cc b/libartbase/base/arena_allocator.cc
index 0bbc816272..a44d1ba0b2 100644
--- a/libartbase/base/arena_allocator.cc
+++ b/libartbase/base/arena_allocator.cc
@@ -57,7 +57,6 @@ const char* const ArenaAllocatorStatsImpl<kCount>::kAllocNames[] = {
   "TryCatchInf  ",
   "UseListNode  ",
   "Environment  ",
-  "EnvVRegs     ",
   "EnvLocations ",
   "LocSummary   ",
   "SsaBuilder   ",
diff --git a/libartbase/base/arena_allocator.h b/libartbase/base/arena_allocator.h
index 10f7f3183d..f7cda26f43 100644
--- a/libartbase/base/arena_allocator.h
+++ b/libartbase/base/arena_allocator.h
@@ -68,7 +68,6 @@ enum ArenaAllocKind {
   kArenaAllocTryCatchInfo,
   kArenaAllocUseListNode,
   kArenaAllocEnvironment,
-  kArenaAllocEnvironmentVRegs,
   kArenaAllocEnvironmentLocations,
   kArenaAllocLocationSummary,
   kArenaAllocSsaBuilder,
diff --git a/libartbase/base/arena_containers.h b/libartbase/base/arena_containers.h
index 80a3791383..e93c8d7bd0 100644
--- a/libartbase/base/arena_containers.h
+++ b/libartbase/base/arena_containers.h
@@ -243,6 +243,51 @@ inline ArenaAllocatorAdapter<void> ArenaAllocator::Adapter(ArenaAllocKind kind)
   return ArenaAllocatorAdapter<void>(this, kind);
 }
 
+// Special deleter that only calls the destructor. Also checks for double free errors.
+template <typename T>
+class ArenaDelete {
+  static constexpr uint8_t kMagicFill = 0xCE;
+
+ protected:
+  // Used for variable sized objects such as RegisterLine.
+  ALWAYS_INLINE void ProtectMemory(T* ptr, size_t size) const {
+    if (kRunningOnMemoryTool) {
+      memset(ptr, kMagicFill, size);
+      MEMORY_TOOL_MAKE_NOACCESS(ptr, size);
+    } else if (kIsDebugBuild) {
+      // Write a magic value to try and catch use after free errors.
+      memset(ptr, kMagicFill, size);
+    }
+  }
+
+ public:
+  void operator()(T* ptr) const {
+    if (ptr != nullptr) {
+      ptr->~T();
+      ProtectMemory(ptr, sizeof(T));
+    }
+  }
+};
+
+// In general we lack support for arrays. We would need to call the destructor on each element,
+// which requires access to the array size. Support for that is future work.
+//
+// However, we can support trivially destructible component types, as then a destructor doesn't
+// need to be called.
+template <typename T>
+class ArenaDelete<T[]> {
+ public:
+  void operator()([[maybe_unused]] T* ptr) const {
+    static_assert(std::is_trivially_destructible_v<T>,
+                  "ArenaUniquePtr does not support non-trivially-destructible arrays.");
+    // TODO: Implement debug checks, and MEMORY_TOOL support.
+  }
+};
+
+// Arena unique ptr that only calls the destructor of the element.
+template <typename T>
+using ArenaUniquePtr = std::unique_ptr<T, ArenaDelete<T>>;
+
 }  // namespace art
 
 #endif  // ART_LIBARTBASE_BASE_ARENA_CONTAINERS_H_
diff --git a/libartbase/base/atomic.h b/libartbase/base/atomic.h
index 91f1982720..e68b277a05 100644
--- a/libartbase/base/atomic.h
+++ b/libartbase/base/atomic.h
@@ -105,6 +105,19 @@ class PACKED(sizeof(T)) Atomic : public std::atomic<T> {
     return this->compare_exchange_weak(expected_value, desired_value, std::memory_order_release);
   }
 
+  // Atomically replace the value with desired_value if it matches the expected_value.
+  // Participates in total ordering of atomic operations.
+  // Returns the existing value before the exchange. In other words, if the returned value is the
+  // same as expected_value, as passed to this method, the exchange has completed successfully.
+  // Otherwise the value was left unchanged.
+  T CompareAndExchangeStrongSequentiallyConsistent(T expected_value, T desired_value) {
+    // compare_exchange_strong() modifies expected_value if the actual value found is different from
+    // what was expected. In other words expected_value is changed if compare_exchange_strong
+    // returns false.
+    this->compare_exchange_strong(expected_value, desired_value, std::memory_order_seq_cst);
+    return expected_value;
+  }
+
   bool CompareAndSet(T expected_value,
                      T desired_value,
                      CASMode mode,
diff --git a/libartbase/base/common_art_test.h b/libartbase/base/common_art_test.h
index ef26e70c7b..1a0b910ced 100644
--- a/libartbase/base/common_art_test.h
+++ b/libartbase/base/common_art_test.h
@@ -35,7 +35,6 @@
 #include "base/unix_file/fd_file.h"
 #include "dex/art_dex_file_loader.h"
 #include "dex/compact_dex_file.h"
-#include "dex/compact_dex_level.h"
 #include "gtest/gtest.h"
 
 namespace art {
diff --git a/libartbase/base/file_utils.cc b/libartbase/base/file_utils.cc
index 1be8327b13..0b3811e5e4 100644
--- a/libartbase/base/file_utils.cc
+++ b/libartbase/base/file_utils.cc
@@ -72,6 +72,7 @@
 
 namespace art {
 
+using android::base::ConsumePrefix;
 using android::base::GetBoolProperty;
 using android::base::GetProperty;
 using android::base::StringPrintf;
@@ -374,7 +375,7 @@ static bool MaybeAppendBootImageMainlineExtension(const std::string& android_roo
                                                   bool deny_art_apex_data_files,
                                                   /*inout*/ std::string* location,
                                                   /*out*/ std::string* error_msg) {
-  if (!kIsTargetAndroid) {
+  if (!kIsTargetAndroid || RunningOnVM()) {
     return true;
   }
   // Due to how the runtime determines the mapping between boot images and bootclasspath jars, the
@@ -382,9 +383,6 @@ static bool MaybeAppendBootImageMainlineExtension(const std::string& android_roo
   // `<primary-boot-image-stem>-<first-library-name>.art`.
   std::string library_name = GetFirstMainlineFrameworkLibraryName(error_msg);
   if (library_name.empty()) {
-    if (kRuntimeISA == InstructionSet::kRiscv64) {
-      return true;
-    }
     return false;
   }
 
@@ -427,8 +425,8 @@ std::string GetDefaultBootImageLocationSafe(const std::string& android_root,
   // If an update for the ART module has been been installed, a single boot image for the entire
   // bootclasspath is in the ART APEX data directory.
   if (kIsTargetBuild && !deny_art_apex_data_files) {
-    const std::string boot_image =
-        GetApexDataDalvikCacheDirectory(InstructionSet::kNone) + "/" + kBootImageStem + ".art";
+    const std::string boot_image = GetApexDataDalvikCacheDirectory(InstructionSet::kNone) + "/" +
+                                   kBootImageStem + kArtExtension;
     const std::string boot_image_filename = GetSystemImageFilename(boot_image.c_str(), kRuntimeISA);
     if (OS::FileExists(boot_image_filename.c_str(), /*check_file_type=*/true)) {
       // Boot image consists of two parts:
@@ -461,7 +459,7 @@ std::string GetDefaultBootImageLocationSafe(const std::string& android_root,
     // ART module, when it fails to generate a single boot image for the entire bootclasspath (i.e.,
     // full boot image). Use it if it exists.
     const std::string minimal_boot_image = GetApexDataDalvikCacheDirectory(InstructionSet::kNone) +
-                                           "/" + kMinimalBootImageStem + ".art";
+                                           "/" + kMinimalBootImageStem + kArtExtension;
     const std::string minimal_boot_image_filename =
         GetSystemImageFilename(minimal_boot_image.c_str(), kRuntimeISA);
     if (OS::FileExists(minimal_boot_image_filename.c_str(), /*check_file_type=*/true)) {
@@ -634,7 +632,8 @@ static bool GetLocationEncodedFilename(std::string_view location,
   *filename += location;  // Including the leading slash.
   size_t replace_start = cache_location.length() + /* skip the leading slash from `location` */ 1u;
   std::replace(filename->begin() + replace_start, filename->end(), '/', '@');
-  if (!location.ends_with(".dex") && !location.ends_with(".art") && !location.ends_with(".oat")) {
+  if (!location.ends_with(".dex") && !location.ends_with(kArtExtension) &&
+      !location.ends_with(kOatExtension)) {
     *filename += "@";
     *filename += kClassesDex;
   }
@@ -683,26 +682,23 @@ static std::string GetApexDataDalvikCacheFilename(std::string_view dex_location,
 }
 
 std::string GetApexDataOatFilename(std::string_view location, InstructionSet isa) {
-  return GetApexDataDalvikCacheFilename(location, isa, /*is_boot_classpath_location=*/true, "oat");
+  return GetApexDataDalvikCacheFilename(
+      location, isa, /*is_boot_classpath_location=*/true, kOatExtension);
 }
 
 std::string GetApexDataOdexFilename(std::string_view location, InstructionSet isa) {
   return GetApexDataDalvikCacheFilename(
-      location, isa, /*is_boot_classpath_location=*/false, "odex");
+      location, isa, /*is_boot_classpath_location=*/false, kOdexExtension);
 }
 
 std::string GetApexDataBootImage(std::string_view dex_location) {
-  return GetApexDataDalvikCacheFilename(dex_location,
-                                        InstructionSet::kNone,
-                                        /*is_boot_classpath_location=*/true,
-                                        kArtImageExtension);
+  return GetApexDataDalvikCacheFilename(
+      dex_location, InstructionSet::kNone, /*is_boot_classpath_location=*/true, kArtExtension);
 }
 
 std::string GetApexDataImage(std::string_view dex_location) {
-  return GetApexDataDalvikCacheFilename(dex_location,
-                                        InstructionSet::kNone,
-                                        /*is_boot_classpath_location=*/false,
-                                        kArtImageExtension);
+  return GetApexDataDalvikCacheFilename(
+      dex_location, InstructionSet::kNone, /*is_boot_classpath_location=*/false, kArtExtension);
 }
 
 std::string GetApexDataDalvikCacheFilename(std::string_view dex_location,
@@ -713,13 +709,14 @@ std::string GetApexDataDalvikCacheFilename(std::string_view dex_location,
 }
 
 std::string GetVdexFilename(const std::string& oat_location) {
-  return ReplaceFileExtension(oat_location, "vdex");
+  return ReplaceFileExtension(oat_location, kVdexExtension);
 }
 
 std::string GetDmFilename(const std::string& dex_location) {
-  return ReplaceFileExtension(dex_location, "dm");
+  return ReplaceFileExtension(dex_location, kDmExtension);
 }
 
+// check for the file in /system, followed by /system_ext
 std::string GetSystemOdexFilenameForApex(std::string_view location, InstructionSet isa) {
   DCHECK(LocationIsOnApex(location));
   std::string dir = GetAndroidRoot() + "/framework/oat/" + GetInstructionSetString(isa);
@@ -728,7 +725,17 @@ std::string GetSystemOdexFilenameForApex(std::string_view location, InstructionS
   // This should never fail. The function fails only if the location is not absolute, and a location
   // on /apex is always absolute.
   DCHECK(ret) << error_msg;
-  return ReplaceFileExtension(result, "odex");
+  std::string path = ReplaceFileExtension(result, kOdexExtension);
+  if (OS::FileExists(path.c_str(), /*check_file_type=*/true)) {
+    return path;
+  }
+  // check in /system_ext
+  dir = GetSystemExtRoot() + "/framework/oat/" + GetInstructionSetString(isa);
+  ret = GetLocationEncodedFilename(location, dir, &result, &error_msg);
+  // This should never fail. The function fails only if the location is not absolute, and a location
+  // on /apex is always absolute.
+  DCHECK(ret) << error_msg;
+  return ReplaceFileExtension(result, kOdexExtension);
 }
 
 static void InsertIsaDirectory(const InstructionSet isa, std::string* filename) {
@@ -749,6 +756,7 @@ std::string GetSystemImageFilename(const char* location, const InstructionSet is
 }
 
 std::string ReplaceFileExtension(std::string_view filename, std::string_view new_extension) {
+  ConsumePrefix(&new_extension, ".");
   const size_t last_ext = filename.find_last_of("./");
   std::string result;
   if (last_ext == std::string::npos || filename[last_ext] != '.') {
diff --git a/libartbase/base/file_utils.h b/libartbase/base/file_utils.h
index 205cc6115d..7f52d03497 100644
--- a/libartbase/base/file_utils.h
+++ b/libartbase/base/file_utils.h
@@ -33,7 +33,12 @@ static constexpr const char kArtApexDataDefaultPath[] = "/data/misc/apexdata/com
 static constexpr const char kAndroidConscryptApexDefaultPath[] = "/apex/com.android.conscrypt";
 static constexpr const char kAndroidI18nApexDefaultPath[] = "/apex/com.android.i18n";
 
-static constexpr const char kArtImageExtension[] = "art";
+static constexpr const char* kOatExtension = ".oat";
+static constexpr const char* kOdexExtension = ".odex";
+static constexpr const char* kVdexExtension = ".vdex";
+static constexpr const char* kArtExtension = ".art";
+static constexpr const char* kDmExtension = ".dm";
+static constexpr const char* kSdmExtension = ".sdm";
 
 // These methods return the Android Root, which is the historical location of
 // the Android "system" directory, containing the built Android artifacts. On
@@ -176,8 +181,11 @@ std::string GetSystemOdexFilenameForApex(std::string_view location, InstructionS
 // Returns `filename` with the text after the last occurrence of '.' replaced with
 // `extension`. If `filename` does not contain a period, returns a string containing `filename`,
 // a period, and `new_extension`.
+// A leading period in `new_extension`, if exists, is ignored.
 // Example: ReplaceFileExtension("foo.bar", "abc") == "foo.abc"
 //          ReplaceFileExtension("foo", "abc") == "foo.abc"
+//          ReplaceFileExtension("foo.bar", ".abc") == "foo.abc"
+//          ReplaceFileExtension("foo", ".abc") == "foo.abc"
 std::string ReplaceFileExtension(std::string_view filename, std::string_view new_extension);
 
 // Return whether the location is on /apex/com.android.art
diff --git a/libartbase/base/file_utils_test.cc b/libartbase/base/file_utils_test.cc
index e660f35d94..ff833cf770 100644
--- a/libartbase/base/file_utils_test.cc
+++ b/libartbase/base/file_utils_test.cc
@@ -175,6 +175,8 @@ TEST_F(FileUtilsTest, ReplaceFileExtension) {
   EXPECT_EQ("/.directory/file.vdex", ReplaceFileExtension("/.directory/file.oat", "vdex"));
   EXPECT_EQ("/directory/file.vdex", ReplaceFileExtension("/directory/file", "vdex"));
   EXPECT_EQ("/.directory/file.vdex", ReplaceFileExtension("/.directory/file", "vdex"));
+  EXPECT_EQ("/directory/file.vdex", ReplaceFileExtension("/directory/file.oat", ".vdex"));
+  EXPECT_EQ("/directory/file.vdex", ReplaceFileExtension("/directory/file", ".vdex"));
 }
 
 TEST_F(FileUtilsTest, ArtApexDataPath) {
@@ -323,7 +325,7 @@ TEST_F(FileUtilsTest, GetSystemOdexFilenameForApex) {
 
   const std::string apex_jar = std::string {kAndroidArtApexDefaultPath} + "/javalib/some.jar";
   EXPECT_EQ(
-      GetAndroidRoot() + "/framework/oat/arm/apex@com.android.art@javalib@some.jar@classes.odex",
+      GetSystemExtRoot() + "/framework/oat/arm/apex@com.android.art@javalib@some.jar@classes.odex",
       GetSystemOdexFilenameForApex(apex_jar, InstructionSet::kArm));
 }
 
diff --git a/libartbase/base/globals.h b/libartbase/base/globals.h
index cab7fab63d..7348444e1c 100644
--- a/libartbase/base/globals.h
+++ b/libartbase/base/globals.h
@@ -53,7 +53,9 @@ static constexpr size_t kMaxPageSize = kMinPageSize;
 // to be able to generate OAT (ELF) and other image files with alignment other than the host page
 // size. kElfSegmentAlignment needs to be equal to the largest page size supported. Effectively,
 // this is the value to be used in images files for aligning contents to page size.
-static constexpr size_t kElfSegmentAlignment = kMaxPageSize;
+// However, it's temporarily set to 4096 now, to prevent dex2oat from creating sparse files.
+// TODO(b/378794327): Fix this.
+static constexpr size_t kElfSegmentAlignment = kMinPageSize;
 
 // Clion, clang analyzer, etc can falsely believe that "if (kIsDebugBuild)" always
 // returns the same value. By wrapping into a call to another constexpr function, we force it
diff --git a/libartbase/base/malloc_arena_pool.cc b/libartbase/base/malloc_arena_pool.cc
index 4de34b5707..a3a53f7b5a 100644
--- a/libartbase/base/malloc_arena_pool.cc
+++ b/libartbase/base/malloc_arena_pool.cc
@@ -106,9 +106,25 @@ Arena* MallocArenaPool::AllocArena(size_t size) {
   Arena* ret = nullptr;
   {
     std::lock_guard<std::mutex> lock(lock_);
+    // We used to check only the first free arena but we're now checking two.
+    //
+    // FIXME: This is a workaround for `oatdump` running out of memory because of an allocation
+    // pattern where we would allocate a large arena (more than the default size) and then a
+    // normal one (default size) and then return them to the pool together, with the normal one
+    // passed as `first` to `FreeArenaChain()`, thus becoming the first in the `free_arenas_`
+    // list. Since we checked only the first arena, doing this repeatedly would never reuse the
+    // existing freed larger arenas and they would just accumulate in the free arena list until
+    // running out of memory. This workaround allows reusing the second arena in the list, thus
+    // fixing the problem for this specific allocation pattern. Similar allocation patterns
+    // with three or more arenas can still result in out of memory issues.
     if (free_arenas_ != nullptr && LIKELY(free_arenas_->Size() >= size)) {
       ret = free_arenas_;
       free_arenas_ = free_arenas_->next_;
+    } else if (free_arenas_ != nullptr &&
+               free_arenas_->next_ != nullptr &&
+               free_arenas_->next_->Size() >= size) {
+      ret = free_arenas_->next_;
+      free_arenas_->next_ = free_arenas_->next_->next_;
     }
   }
   if (ret == nullptr) {
diff --git a/libartbase/base/mem_map.cc b/libartbase/base/mem_map.cc
index 08d452b5ff..5c785618ba 100644
--- a/libartbase/base/mem_map.cc
+++ b/libartbase/base/mem_map.cc
@@ -531,10 +531,9 @@ MemMap MemMap::MapFileAtAddress(uint8_t* expected_ptr,
 
   // Note that we do not allow MAP_FIXED unless reuse == true or we have an existing
   // reservation, i.e we expect this mapping to be contained within an existing map.
-  if (reuse) {
+  if (reuse && expected_ptr != nullptr) {
     // reuse means it is okay that it overlaps an existing page mapping.
     // Only use this if you actually made the page reservation yourself.
-    CHECK(expected_ptr != nullptr);
     DCHECK(reservation == nullptr);
     DCHECK(error_msg != nullptr);
     DCHECK(ContainedWithinExistingMap(expected_ptr, byte_count, error_msg))
diff --git a/libartbase/base/mem_map.h b/libartbase/base/mem_map.h
index a3af44fadb..4b4a56a23f 100644
--- a/libartbase/base/mem_map.h
+++ b/libartbase/base/mem_map.h
@@ -220,6 +220,28 @@ class MemMap {
                             error_msg);
   }
 
+  static MemMap MapFile(size_t byte_count,
+                        int prot,
+                        int flags,
+                        int fd,
+                        off_t start,
+                        bool low_4gb,
+                        const char* filename,
+                        bool reuse,
+                        std::string* error_msg) {
+    return MapFileAtAddress(nullptr,
+                            byte_count,
+                            prot,
+                            flags,
+                            fd,
+                            start,
+                            /*low_4gb=*/ low_4gb,
+                            filename,
+                            reuse,
+                            /*reservation=*/ nullptr,
+                            error_msg);
+  }
+
   // Map part of a file, taking care of non-page aligned offsets. The "start" offset is absolute,
   // not relative. This version allows requesting a specific address for the base of the mapping.
   //
@@ -425,8 +447,8 @@ class MemMap {
   size_t base_size_ = 0u;       // Length of mapping. May be changed by RemapAtEnd (ie Zygote).
   int prot_ = 0;                // Protection of the map.
 
-  // When reuse_ is true, this is just a view of an existing mapping
-  // and we do not take ownership and are not responsible for
+  // When reuse_ is true, this is a view of a mapping on which
+  // we do not take ownership and are not responsible for
   // unmapping.
   bool reuse_ = false;
 
diff --git a/libartbase/base/scoped_arena_containers.h b/libartbase/base/scoped_arena_containers.h
index d0ff7f535d..ee9a7461f8 100644
--- a/libartbase/base/scoped_arena_containers.h
+++ b/libartbase/base/scoped_arena_containers.h
@@ -234,56 +234,6 @@ inline ScopedArenaAllocatorAdapter<void> ScopedArenaAllocator::Adapter(ArenaAllo
   return ScopedArenaAllocatorAdapter<void>(this, kind);
 }
 
-// Special deleter that only calls the destructor. Also checks for double free errors.
-template <typename T>
-class ArenaDelete {
-  static constexpr uint8_t kMagicFill = 0xCE;
-
- protected:
-  // Used for variable sized objects such as RegisterLine.
-  ALWAYS_INLINE void ProtectMemory(T* ptr, size_t size) const {
-    if (kRunningOnMemoryTool) {
-      // Writing to the memory will fail ift we already destroyed the pointer with
-      // DestroyOnlyDelete since we make it no access.
-      memset(ptr, kMagicFill, size);
-      MEMORY_TOOL_MAKE_NOACCESS(ptr, size);
-    } else if (kIsDebugBuild) {
-      CHECK(ArenaStack::ArenaTagForAllocation(reinterpret_cast<void*>(ptr)) == ArenaFreeTag::kUsed)
-          << "Freeing invalid object " << ptr;
-      ArenaStack::ArenaTagForAllocation(reinterpret_cast<void*>(ptr)) = ArenaFreeTag::kFree;
-      // Write a magic value to try and catch use after free error.
-      memset(ptr, kMagicFill, size);
-    }
-  }
-
- public:
-  void operator()(T* ptr) const {
-    if (ptr != nullptr) {
-      ptr->~T();
-      ProtectMemory(ptr, sizeof(T));
-    }
-  }
-};
-
-// In general we lack support for arrays. We would need to call the destructor on each element,
-// which requires access to the array size. Support for that is future work.
-//
-// However, we can support trivially destructible component types, as then a destructor doesn't
-// need to be called.
-template <typename T>
-class ArenaDelete<T[]> {
- public:
-  void operator()([[maybe_unused]] T* ptr) const {
-    static_assert(std::is_trivially_destructible_v<T>,
-                  "ArenaUniquePtr does not support non-trivially-destructible arrays.");
-    // TODO: Implement debug checks, and MEMORY_TOOL support.
-  }
-};
-
-// Arena unique ptr that only calls the destructor of the element.
-template <typename T>
-using ArenaUniquePtr = std::unique_ptr<T, ArenaDelete<T>>;
-
 }  // namespace art
 
 #endif  // ART_LIBARTBASE_BASE_SCOPED_ARENA_CONTAINERS_H_
diff --git a/libartbase/base/systrace.h b/libartbase/base/systrace.h
index 6e5e0e013a..c42fe86737 100644
--- a/libartbase/base/systrace.h
+++ b/libartbase/base/systrace.h
@@ -95,9 +95,12 @@ class ScopedTraceNoStart {
   };
 };
 
+// Avoid the name clash with the one in gtest/gtest.h.
+#ifndef SCOPED_TRACE
 #define SCOPED_TRACE \
   ::art::ScopedTraceNoStart APPEND_TOKENS_AFTER_EVAL(trace, __LINE__) ; \
   (ATraceEnabled()) && ::art::ScopedTraceNoStart::ScopedTraceMessageHelper().stream()
+#endif  // SCOPED_TRACE
 
 }  // namespace art
 
diff --git a/libartbase/base/unix_file/fd_file.h b/libartbase/base/unix_file/fd_file.h
index 58fc3ee525..a46ef81586 100644
--- a/libartbase/base/unix_file/fd_file.h
+++ b/libartbase/base/unix_file/fd_file.h
@@ -74,6 +74,7 @@ class FdFile : public RandomAccessFile {
   int64_t Write(const char* buf, int64_t byte_count, int64_t offset) override WARN_UNUSED;
 
   int Flush() override WARN_UNUSED { return Flush(/*flush_metadata=*/false); }
+  int Flush(bool flush_metadata) WARN_UNUSED;
 
   // Short for SetLength(0); Flush(); Close();
   // If the file was opened with a path name and unlink = true, also calls Unlink() on the path.
@@ -175,8 +176,6 @@ class FdFile : public RandomAccessFile {
   template <bool kUseOffset>
   bool WriteFullyGeneric(const void* buffer, size_t byte_count, size_t offset);
 
-  int Flush(bool flush_metadata) WARN_UNUSED;
-
   // The file path we hold for the file descriptor may be invalid, or may not even exist (e.g. if
   // the FdFile wasn't initialised with a path). This helper function checks if calling open() on
   // the file path (if it is set) returns the expected up-to-date file descriptor. This is still
diff --git a/libartbase/base/utils.cc b/libartbase/base/utils.cc
index da53d0b99f..2c95986809 100644
--- a/libartbase/base/utils.cc
+++ b/libartbase/base/utils.cc
@@ -19,6 +19,7 @@
 #include <dirent.h>
 #include <inttypes.h>
 #include <pthread.h>
+#include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -190,6 +191,11 @@ bool CacheOperationsMaySegFault() {
 #endif
 }
 
+bool RunningOnVM() {
+  const char* on_vm = getenv("ART_TEST_ON_VM");
+  return on_vm != nullptr && std::strcmp("true", on_vm) == 0;
+}
+
 uint32_t GetTid() {
 #if defined(__APPLE__)
   uint64_t owner;
diff --git a/libartbase/base/utils.h b/libartbase/base/utils.h
index 32f8b87204..4b86651f95 100644
--- a/libartbase/base/utils.h
+++ b/libartbase/base/utils.h
@@ -129,6 +129,9 @@ bool IsKernelVersionAtLeast(int reqd_major, int reqd_minor);
 // On some old kernels, a cache operation may segfault.
 WARN_UNUSED bool CacheOperationsMaySegFault();
 
+// Is the execution environment on a virtual machine? See ART_TEST_ON_VM.
+WARN_UNUSED bool RunningOnVM();
+
 template <typename Func, typename... Args>
 static inline void CheckedCall(const Func& function, const char* what, Args... args) {
   int rc = function(args...);
diff --git a/libartservice/service/Android.bp b/libartservice/service/Android.bp
index 62bdda9edd..9df3d4ef7b 100644
--- a/libartservice/service/Android.bp
+++ b/libartservice/service/Android.bp
@@ -101,6 +101,7 @@ java_defaults {
         "sdk_module-lib_current_framework-connectivity",
     ],
     static_libs: [
+        "android.content.pm.flags-aconfig-java-export",
         "art-statslog-art-java",
         "artd-aidl-java",
         "dexopt_chroot_setup-aidl-java",
diff --git a/libartservice/service/README.md b/libartservice/service/README.md
index 04cd83dbe8..b7363ee184 100644
--- a/libartservice/service/README.md
+++ b/libartservice/service/README.md
@@ -108,6 +108,9 @@ At a high level, ART Service dexopts apps in the following scenarios:
     `inactive`)
 -   requested through commandline (Compilation reason: `cmdline`)
 
+Warning: The execution or scheduling of dexopt operations by ART Service is
+**not** triggered by an app's running or launch status.
+
 Warning: The sections below describe the default behavior in each scenario. Note
 that the list of apps to dexopt and the compiler filter, as well as other
 options, can be customized by partners through system properties, APIs, etc.
@@ -176,9 +179,9 @@ Note: There is no secondary dex file present during installation.
 ### When the device is idle and charging
 
 ART Service has a job called *background dexopt job* managed by Job Scheduler.
-It is triggered when the device is idle and charging. During the job execution,
-it dexopts primary dex files and secondary dex files of all apps with the
-"speed-profile" compiler filter.
+It is triggered daily when the device is idle and charging. During the job
+execution, it dexopts primary dex files and secondary dex files of all apps with
+the "speed-profile" compiler filter.
 
 If `pm.dexopt.downgrade_after_inactive_days` is set, ART Service only dexopts
 apps used within the last given number of days, and it downgrades other apps
diff --git a/libartservice/service/api/system-server-current.txt b/libartservice/service/api/system-server-current.txt
index 05163ebc70..b7a3739370 100644
--- a/libartservice/service/api/system-server-current.txt
+++ b/libartservice/service/api/system-server-current.txt
@@ -1,6 +1,12 @@
 // Signature format: 2.0
 package com.android.server.art {
 
+  @FlaggedApi("com.android.art.flags.art_service_v3") public final class ArtManagedInstallFileHelper {
+    method @FlaggedApi("com.android.art.flags.art_service_v3") @NonNull public static java.util.List<java.lang.String> filterPathsForApk(@NonNull java.util.List<java.lang.String>, @NonNull String);
+    method @FlaggedApi("com.android.art.flags.art_service_v3") @NonNull public static String getTargetPathForApk(@NonNull String, @NonNull String);
+    method @FlaggedApi("com.android.art.flags.art_service_v3") public static boolean isArtManaged(@NonNull String);
+  }
+
   public final class ArtManagerLocal {
     ctor @Deprecated public ArtManagerLocal();
     ctor public ArtManagerLocal(@NonNull android.content.Context);
@@ -76,6 +82,7 @@ package com.android.server.art {
     field public static final String REASON_INSTALL_BULK_SECONDARY = "install-bulk-secondary";
     field public static final String REASON_INSTALL_BULK_SECONDARY_DOWNGRADED = "install-bulk-secondary-downgraded";
     field public static final String REASON_INSTALL_FAST = "install-fast";
+    field @FlaggedApi("com.android.art.flags.art_service_v3") public static final String REASON_PRE_REBOOT_DEXOPT = "ab-ota";
   }
 
 }
diff --git a/libartservice/service/jarjar-rules.txt b/libartservice/service/jarjar-rules.txt
index 54ff0a13d2..014ff22579 100644
--- a/libartservice/service/jarjar-rules.txt
+++ b/libartservice/service/jarjar-rules.txt
@@ -1,3 +1,8 @@
 # Repackages static libraries to make them private to ART Services.
+rule android.content.pm.CustomFeatureFlags com.android.server.art.jarjar.@0
+rule android.content.pm.FakeFeatureFlagsImpl com.android.server.art.jarjar.@0
+rule android.content.pm.FeatureFlags com.android.server.art.jarjar.@0
+rule android.content.pm.FeatureFlagsImpl com.android.server.art.jarjar.@0
+rule android.content.pm.Flags com.android.server.art.jarjar.@0
 rule com.android.modules.utils.** com.android.server.art.jarjar.@0
 rule com.google.protobuf.** com.android.server.art.jarjar.@0
diff --git a/libartservice/service/java/com/android/server/art/ArtManagedInstallFileHelper.java b/libartservice/service/java/com/android/server/art/ArtManagedInstallFileHelper.java
new file mode 100644
index 0000000000..dd040165e3
--- /dev/null
+++ b/libartservice/service/java/com/android/server/art/ArtManagedInstallFileHelper.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.art;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.SystemApi;
+import android.os.Build;
+
+import androidx.annotation.RequiresApi;
+
+import com.android.art.flags.Flags;
+
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Helper class for <i>ART-managed install files</i> (files installed by Package Manager
+ * and managed by ART).
+ *
+ * @hide
+ */
+@FlaggedApi(Flags.FLAG_ART_SERVICE_V3)
+@SystemApi(client = SystemApi.Client.SYSTEM_SERVER)
+@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+public final class ArtManagedInstallFileHelper {
+    private static final List<String> FILE_TYPES = List.of(ArtConstants.DEX_METADATA_FILE_EXT,
+            ArtConstants.PROFILE_FILE_EXT, ArtConstants.SECURE_DEX_METADATA_FILE_EXT);
+
+    private ArtManagedInstallFileHelper() {}
+
+    /**
+     * Returns whether the file at the given path is an <i>ART-managed install file</i>. This
+     * is a pure string operation on the input and does not involve any I/O.
+     */
+    @FlaggedApi(Flags.FLAG_ART_SERVICE_V3)
+    public static boolean isArtManaged(@NonNull String path) {
+        return FILE_TYPES.stream().anyMatch(ext -> path.endsWith(ext));
+    }
+
+    /**
+     * Returns the subset of the given paths that are paths to the <i>ART-managed install files</i>
+     * corresponding to the given APK path. This is a pure string operation on the inputs and does
+     * not involve any I/O.
+     *
+     * Note that the files in different directories than the APK are not considered corresponding to
+     * the APK.
+     */
+    @FlaggedApi(Flags.FLAG_ART_SERVICE_V3)
+    public static @NonNull List<String> filterPathsForApk(
+            @NonNull List<String> paths, @NonNull String apkPath) {
+        Set<String> candidates = FILE_TYPES.stream()
+                                         .map(ext -> Utils.replaceFileExtension(apkPath, ext))
+                                         .collect(Collectors.toSet());
+        return paths.stream().filter(path -> candidates.contains(path)).toList();
+    }
+
+    /**
+     * Rewrites the path to the <i>ART-managed install file</i> so that it corresponds to the given
+     * APK path. This is a pure string operation on the inputs and does not involve any I/O.
+     *
+     * Note that the result path is always in the same directory as the APK, in order to correspond
+     * to the APK.
+     *
+     * @throws IllegalArgumentException if {@code originalPath} does not represent an <i>ART-managed
+     *         install file</i>
+     */
+    @FlaggedApi(Flags.FLAG_ART_SERVICE_V3)
+    public static @NonNull String getTargetPathForApk(
+            @NonNull String originalPath, @NonNull String apkPath) {
+        for (String ext : FILE_TYPES) {
+            if (originalPath.endsWith(ext)) {
+                return Utils.replaceFileExtension(apkPath, ext);
+            }
+        }
+        throw new IllegalArgumentException(
+                "Illegal ART managed install file path '" + originalPath + "'");
+    }
+}
diff --git a/libartservice/service/java/com/android/server/art/ArtManagerLocal.java b/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
index 8436fd1095..0afdf03d9c 100644
--- a/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
+++ b/libartservice/service/java/com/android/server/art/ArtManagerLocal.java
@@ -471,6 +471,17 @@ public final class ArtManagerLocal {
             @NonNull CancellationSignal cancellationSignal,
             @Nullable @CallbackExecutor Executor progressCallbackExecutor,
             @Nullable Map<Integer, Consumer<OperationProgress>> progressCallbacks) {
+        return dexoptPackagesWithParams(snapshot, reason, cancellationSignal,
+                progressCallbackExecutor, progressCallbacks, null /* params */);
+    }
+
+    /** @hide */
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @NonNull
+    public BatchDexoptParams getBatchDexoptParams(
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @NonNull @BatchDexoptReason String reason,
+            @NonNull CancellationSignal cancellationSignal) {
         List<String> defaultPackages =
                 Collections.unmodifiableList(getDefaultPackages(snapshot, reason));
         DexoptParams defaultDexoptParams = new DexoptParams.Builder(reason).build();
@@ -484,8 +495,30 @@ public final class ArtManagerLocal {
             });
         }
         BatchDexoptParams params = builder.build();
-        Utils.check(params.getDexoptParams().getReason().equals(reason));
+        DexoptParams dexoptParams = params.getDexoptParams();
+        Utils.check(dexoptParams.getReason().equals(reason));
+        if (dexoptParams.getSplitName() != null) {
+            AsLog.w("`setSplitName` is not supported in `BatchDexoptStartCallback`. The value is "
+                    + "ignored");
+            params = builder.setDexoptParams(dexoptParams.toBuilder().setSplitName(null).build())
+                             .build();
+        }
+        return params;
+    }
 
+    /** @hide */
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @NonNull
+    public Map<Integer, DexoptResult> dexoptPackagesWithParams(
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @NonNull @BatchDexoptReason String reason,
+            @NonNull CancellationSignal cancellationSignal,
+            @Nullable @CallbackExecutor Executor progressCallbackExecutor,
+            @Nullable Map<Integer, Consumer<OperationProgress>> progressCallbacks,
+            @Nullable BatchDexoptParams params) {
+        if (params == null) {
+            params = getBatchDexoptParams(snapshot, reason, cancellationSignal);
+        }
         ExecutorService dexoptExecutor =
                 Executors.newFixedThreadPool(ReasonMapping.getConcurrencyForReason(reason));
         Map<Integer, DexoptResult> dexoptResults = new HashMap<>();
@@ -881,6 +914,7 @@ public final class ArtManagerLocal {
     public void onBoot(@NonNull @BootReason String bootReason,
             @Nullable @CallbackExecutor Executor progressCallbackExecutor,
             @Nullable Consumer<OperationProgress> progressCallback) {
+        AsLog.d("onBoot: reason=" + bootReason);
         try (var snapshot = mInjector.getPackageManagerLocal().withFilteredSnapshot()) {
             if ((bootReason.equals(ReasonMapping.REASON_BOOT_AFTER_OTA)
                         || bootReason.equals(ReasonMapping.REASON_BOOT_AFTER_MAINLINE_UPDATE))
@@ -910,10 +944,13 @@ public final class ArtManagerLocal {
      */
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     void systemReady() {
+        AsLog.d("systemReady: mShouldCommitPreRebootStagedFiles="
+                + mShouldCommitPreRebootStagedFiles);
         if (mShouldCommitPreRebootStagedFiles) {
             mInjector.getContext().registerReceiver(new BroadcastReceiver() {
                 @Override
                 public void onReceive(Context context, Intent intent) {
+                    AsLog.d("systemReady.onReceive");
                     context.unregisterReceiver(this);
                     if (!SdkLevel.isAtLeastV()) {
                         throw new IllegalStateException("Broadcast receiver unexpectedly called");
@@ -923,6 +960,8 @@ public final class ArtManagerLocal {
                     }
                     mStatsAfterRebootSession.reportAsync();
                     mStatsAfterRebootSession = null;
+                    // OtaPreRebootDexoptTest looks for this log message.
+                    AsLog.d("Pre-reboot staged files committed");
                 }
             }, new IntentFilter(Intent.ACTION_BOOT_COMPLETED));
         }
@@ -942,6 +981,7 @@ public final class ArtManagerLocal {
      */
     @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
     public void onApexStaged(@NonNull String[] stagedApexModuleNames) {
+        AsLog.d("onApexStaged");
         mInjector.getPreRebootDexoptJob().onUpdateReady(null /* otaSlot */);
     }
 
@@ -956,8 +996,19 @@ public final class ArtManagerLocal {
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     public void dump(
             @NonNull PrintWriter pw, @NonNull PackageManagerLocal.FilteredSnapshot snapshot) {
+        dump(pw, snapshot, false /* verifySdmSignatures */);
+    }
+
+    /**
+     * Same as above, but allows to specify options.
+     *
+     * @hide
+     */
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    public void dump(@NonNull PrintWriter pw,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot, boolean verifySdmSignatures) {
         try (var pin = mInjector.createArtdPin()) {
-            new DumpHelper(this).dump(pw, snapshot);
+            new DumpHelper(this).dump(pw, snapshot, verifySdmSignatures);
         }
     }
 
@@ -973,9 +1024,21 @@ public final class ArtManagerLocal {
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     public void dumpPackage(@NonNull PrintWriter pw,
             @NonNull PackageManagerLocal.FilteredSnapshot snapshot, @NonNull String packageName) {
+        dumpPackage(pw, snapshot, packageName, false /* verifySdmSignatures */);
+    }
+
+    /**
+     * Same as above, but allows to specify options.
+     *
+     * @hide
+     */
+    @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    public void dumpPackage(@NonNull PrintWriter pw,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot, @NonNull String packageName,
+            boolean verifySdmSignatures) {
         try (var pin = mInjector.createArtdPin()) {
-            new DumpHelper(this).dumpPackage(
-                    pw, snapshot, Utils.getPackageStateOrThrow(snapshot, packageName));
+            new DumpHelper(this).dumpPackage(pw, snapshot,
+                    Utils.getPackageStateOrThrow(snapshot, packageName), verifySdmSignatures);
         }
     }
 
@@ -1126,6 +1189,10 @@ public final class ArtManagerLocal {
                 if (!Utils.canDexoptPackage(pkgState, null /* appHibernationManager */)) {
                     continue;
                 }
+
+                AsLog.d("commitPreRebootStagedFiles " + (forSecondary ? "secondary" : "primary")
+                        + " for " + pkgState.getPackageName());
+
                 AndroidPackage pkg = Utils.getPackageOrThrow(pkgState);
                 var options = ArtFileManager.Options.builder()
                                       .setForPrimaryDex(!forSecondary)
@@ -1635,7 +1702,7 @@ public final class ArtManagerLocal {
         @NonNull
         public synchronized PreRebootDexoptJob getPreRebootDexoptJob() {
             if (mPrDexoptJob == null) {
-                mPrDexoptJob = new PreRebootDexoptJob(mContext);
+                mPrDexoptJob = new PreRebootDexoptJob(mContext, mArtManagerLocal);
             }
             return mPrDexoptJob;
         }
diff --git a/libartservice/service/java/com/android/server/art/ArtShellCommand.java b/libartservice/service/java/com/android/server/art/ArtShellCommand.java
index f7d26cb36f..1c19dad9c4 100644
--- a/libartservice/service/java/com/android/server/art/ArtShellCommand.java
+++ b/libartservice/service/java/com/android/server/art/ArtShellCommand.java
@@ -171,11 +171,22 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
                 return 0;
             }
             case "dump": {
+                boolean verifySdmSignatures = false;
+
+                String opt;
+                while ((opt = getNextOption()) != null) {
+                    switch (opt) {
+                        case "--verify-sdm-signatures":
+                            verifySdmSignatures = true;
+                            break;
+                    }
+                }
+
                 String packageName = getNextArg();
                 if (packageName != null) {
-                    mArtManagerLocal.dumpPackage(pw, snapshot, packageName);
+                    mArtManagerLocal.dumpPackage(pw, snapshot, packageName, verifySdmSignatures);
                 } else {
-                    mArtManagerLocal.dump(pw, snapshot);
+                    mArtManagerLocal.dump(pw, snapshot, verifySdmSignatures);
                 }
                 return 0;
             }
@@ -193,6 +204,9 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
             case "pr-dexopt-job": {
                 return handlePrDexoptJob(pw);
             }
+            case "configure-batch-dexopt": {
+                return handleConfigureBatchDexopt(pw);
+            }
             default:
                 pw.printf("Error: Unknown 'art' sub-command '%s'\n", subcmd);
                 pw.println("See 'pm help' for help");
@@ -841,6 +855,39 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
         return 0;
     }
 
+    private int handleConfigureBatchDexopt(@NonNull PrintWriter pw) {
+        String inputReason = null;
+        List<String> packages = new ArrayList<>();
+
+        String opt;
+        while ((opt = getNextOption()) != null) {
+            switch (opt) {
+                case "-r":
+                    inputReason = getNextArgRequired();
+                    break;
+                case "--package":
+                    packages.add(getNextArgRequired());
+                    break;
+                default:
+                    pw.println("Error: Unknown option: " + opt);
+                    return 1;
+            }
+        }
+
+        // Variables used in lambda needs to be effectively final.
+        String finalInputReason = inputReason;
+        mArtManagerLocal.setBatchDexoptStartCallback(
+                Runnable::run, (snapshot, reason, defaultPackages, builder, cancellationSignal) -> {
+                    if (reason.equals(finalInputReason)) {
+                        if (!packages.isEmpty()) {
+                            builder.setPackages(packages);
+                        }
+                    }
+                });
+
+        return 0;
+    }
+
     @Override
     public void onHelp() {
         // No one should call this. The help text should be printed by the `onHelp` handler of `cmd
@@ -978,10 +1025,13 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
         pw.println("    Cleanup obsolete files, such as dexopt artifacts that are outdated or");
         pw.println("    correspond to dex container files that no longer exist.");
         pw.println();
-        pw.println("  dump [PACKAGE_NAME]");
-        pw.println("    Dumps the dexopt state in text format to stdout.");
+        pw.println("  dump [--verify-sdm-signatures] [PACKAGE_NAME]");
+        pw.println("    Dump the dexopt state in text format to stdout.");
         pw.println("    If PACKAGE_NAME is empty, the command is for all packages. Otherwise, it");
         pw.println("    is for the given package.");
+        pw.println("    Options:");
+        pw.println("      --verify-sdm-signatures Also verify SDM file signatures and include");
+        pw.println("        their statuses.");
         pw.println();
         pw.println("  dexopt-packages -r REASON");
         pw.println("    Run batch dexopt for the given reason.");
@@ -1029,6 +1079,20 @@ public final class ArtShellCommand extends BasicShellCommandHandler {
         pw.println("    Options:");
         pw.println("      --slot SLOT The slot that contains the OTA update, '_a' or '_b'. If not");
         pw.println("        specified, the job is for a Mainline update");
+        pw.println();
+        pw.println("  configure-batch-dexopt -r REASON [--package PACKAGE_NAME]...");
+        pw.println("    Configure batch dexopt parameters to be applied when the given reason is");
+        pw.println("    used.");
+        pw.println("    Once called, this command overwrites any configuration done through");
+        pw.println("    'ArtManagerLocal.setBatchDexoptStartCallback' or through this command for");
+        pw.println("    all reasons. In other words, configurations for other reasons are reset");
+        pw.println("    to the default.");
+        pw.println("    Valid values for REASON: 'first-boot', 'boot-after-ota',");
+        pw.println("    'boot-after-mainline-update', 'bg-dexopt', 'ab-ota'");
+        pw.println("    Options:");
+        pw.println("      --package PACKAGE_NAME The package name to dexopt. This flag can be");
+        pw.println("        passed multiple times, to specify multiple packages. If not");
+        pw.println("        specified, the default package list will be used.");
     }
 
     private void enforceRootOrShell() {
diff --git a/libartservice/service/java/com/android/server/art/BackgroundDexoptJob.java b/libartservice/service/java/com/android/server/art/BackgroundDexoptJob.java
index 526a08eb48..330940f9d5 100644
--- a/libartservice/service/java/com/android/server/art/BackgroundDexoptJob.java
+++ b/libartservice/service/java/com/android/server/art/BackgroundDexoptJob.java
@@ -234,14 +234,19 @@ public class BackgroundDexoptJob implements ArtServiceJobInterface {
             dexoptResultByPass = mInjector.getArtManagerLocal().dexoptPackages(snapshot,
                     ReasonMapping.REASON_BG_DEXOPT, cancellationSignal, Runnable::run,
                     progressCallbacks);
+        }
 
-            // For simplicity, we don't support cancelling the following operation in the middle.
-            // This is fine because it typically takes only a few seconds.
-            if (!cancellationSignal.isCanceled()) {
-                // We do the cleanup after dexopt so that it doesn't affect the `getSizeBeforeBytes`
-                // field in the result that we send to callbacks. Admittedly, this will cause us to
-                // lose some chance to dexopt when the storage is very low, but it's fine because we
-                // can still dexopt in the next run.
+        // For simplicity, we don't support cancelling the following operation in the middle.
+        // This is fine because it typically takes only a few seconds.
+        if (!cancellationSignal.isCanceled()) {
+            // We do the cleanup after dexopt so that it doesn't affect the `getSizeBeforeBytes`
+            // field in the result that we send to callbacks. Admittedly, this will cause us to
+            // lose some chance to dexopt when the storage is very low, but it's fine because we
+            // can still dexopt in the next run.
+            //
+            // Take a new snapshot since the one used for dexoptPackages above is old by now and
+            // new packages may have been installed.
+            try (var snapshot = mInjector.getPackageManagerLocal().withFilteredSnapshot()) {
                 long freedBytes = mInjector.getArtManagerLocal().cleanup(snapshot);
                 AsLog.i(String.format("Freed %d bytes", freedBytes));
             }
diff --git a/libartservice/service/java/com/android/server/art/DexMetadataHelper.java b/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
index 237bb1878e..9742c5f40e 100644
--- a/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
+++ b/libartservice/service/java/com/android/server/art/DexMetadataHelper.java
@@ -45,9 +45,6 @@ import java.util.zip.ZipFile;
 public class DexMetadataHelper {
     @NonNull private final Injector mInjector;
 
-    private static final String PROFILE_DEX_METADATA = "primary.prof";
-    private static final String VDEX_DEX_METADATA = "primary.vdex";
-
     public DexMetadataHelper() {
         this(new Injector());
     }
@@ -89,14 +86,12 @@ public class DexMetadataHelper {
 
     @NonNull
     public static String getDmPath(@NonNull DexMetadataPath dmPath) {
-        String dexPath = dmPath.dexPath;
-        int pos = dexPath.lastIndexOf(".");
-        return (pos != -1 ? dexPath.substring(0, pos) : dexPath) + ".dm";
+        return Utils.replaceFileExtension(dmPath.dexPath, ArtConstants.DEX_METADATA_FILE_EXT);
     }
 
     private static @DexMetadata.Type int getType(@NonNull ZipFile zipFile) {
-        var profile = zipFile.getEntry(PROFILE_DEX_METADATA);
-        var vdex = zipFile.getEntry(VDEX_DEX_METADATA);
+        var profile = zipFile.getEntry(ArtConstants.DEX_METADATA_PROFILE_ENTRY);
+        var vdex = zipFile.getEntry(ArtConstants.DEX_METADATA_VDEX_ENTRY);
 
         if (profile != null && vdex != null) {
             return DexMetadata.TYPE_PROFILE_AND_VDEX;
diff --git a/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java b/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
index 7eb5a69165..51b63ca758 100644
--- a/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
+++ b/libartservice/service/java/com/android/server/art/DexUseManagerLocal.java
@@ -413,7 +413,7 @@ public class DexUseManagerLocal {
 
         // TODO(jiakaiz): Investigate whether it should also be considered as isolated process if
         // `Process.isSdkSandboxUid` returns true.
-        boolean isolatedProcess = Process.isIsolatedUid(Binder.getCallingUid());
+        boolean isolatedProcess = Process.isIsolatedUid(mInjector.getCallingUid());
         long lastUsedAtMs = mInjector.getCurrentTimeMillis();
 
         for (var entry : classLoaderContextByDexContainerFile.entrySet()) {
@@ -588,7 +588,7 @@ public class DexUseManagerLocal {
     @GuardedBy("mLock")
     private boolean isOwningPackageForSecondaryDexLocked(
             @NonNull PackageState pkgState, @NonNull String dexPath) {
-        UserHandle userHandle = Binder.getCallingUserHandle();
+        UserHandle userHandle = mInjector.getCallingUserHandle();
         List<String> locations = mSecondaryDexLocationManager.getLocations(pkgState, userHandle);
         for (int i = 0; i < locations.size(); i++) {
             if (Utils.pathStartsWith(dexPath, locations.get(i))) {
@@ -663,7 +663,7 @@ public class DexUseManagerLocal {
                             .computeIfAbsent(owningPackageName, k -> new PackageDexUse())
                             .mSecondaryDexUseByDexFile.computeIfAbsent(
                                     dexPath, k -> new SecondaryDexUse());
-            secondaryDexUse.mUserHandle = Binder.getCallingUserHandle();
+            secondaryDexUse.mUserHandle = mInjector.getCallingUserHandle();
             SecondaryDexUseRecord record = secondaryDexUse.mRecordByLoader.computeIfAbsent(
                     DexLoader.create(loadingPackageName, isolatedProcess),
                     k -> new SecondaryDexUseRecord());
@@ -1391,5 +1391,14 @@ public class DexUseManagerLocal {
         public ArtManagerLocal getArtManagerLocal() {
             return Objects.requireNonNull(LocalManagerRegistry.getManager(ArtManagerLocal.class));
         }
+
+        @NonNull
+        public UserHandle getCallingUserHandle() {
+            return Binder.getCallingUserHandle();
+        }
+
+        public int getCallingUid() {
+            return Binder.getCallingUid();
+        }
     }
 }
diff --git a/libartservice/service/java/com/android/server/art/DumpHelper.java b/libartservice/service/java/com/android/server/art/DumpHelper.java
index 709c742231..419c55f077 100644
--- a/libartservice/service/java/com/android/server/art/DumpHelper.java
+++ b/libartservice/service/java/com/android/server/art/DumpHelper.java
@@ -20,7 +20,12 @@ import static com.android.server.art.DexUseManagerLocal.CheckedSecondaryDexInfo;
 import static com.android.server.art.DexUseManagerLocal.DexLoader;
 import static com.android.server.art.model.DexoptStatus.DexContainerFileDexoptStatus;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+import android.content.pm.PackageManager;
+import android.content.pm.SigningInfo;
+import android.content.pm.SigningInfoException;
 import android.os.Build;
 import android.os.RemoteException;
 import android.os.ServiceSpecificException;
@@ -34,6 +39,7 @@ import com.android.server.pm.pkg.PackageState;
 
 import dalvik.system.VMRuntime;
 
+import java.io.File;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Comparator;
@@ -65,13 +71,13 @@ public class DumpHelper {
     }
 
     /** Handles {@link ArtManagerLocal#dump(PrintWriter, PackageManagerLocal.FilteredSnapshot)}. */
-    public void dump(
-            @NonNull PrintWriter pw, @NonNull PackageManagerLocal.FilteredSnapshot snapshot) {
+    public void dump(@NonNull PrintWriter pw,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot, boolean verifySdmSignatures) {
         snapshot.getPackageStates()
                 .values()
                 .stream()
                 .sorted(Comparator.comparing(PackageState::getPackageName))
-                .forEach(pkgState -> dumpPackage(pw, snapshot, pkgState));
+                .forEach(pkgState -> dumpPackage(pw, snapshot, pkgState, verifySdmSignatures));
         pw.printf("\nCurrent GC: %s\n", ArtJni.getGarbageCollector());
     }
 
@@ -80,8 +86,8 @@ public class DumpHelper {
      * ArtManagerLocal#dumpPackage(PrintWriter, PackageManagerLocal.FilteredSnapshot, String)}.
      */
     public void dumpPackage(@NonNull PrintWriter pw,
-            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
-            @NonNull PackageState pkgState) {
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot, @NonNull PackageState pkgState,
+            boolean verifySdmSignatures) {
         if (pkgState.isApex() || pkgState.getAndroidPackage() == null) {
             return;
         }
@@ -124,7 +130,7 @@ public class DumpHelper {
 
         ipw.increaseIndent();
         for (List<DexContainerFileDexoptStatus> fileStatuses : primaryStatusesByDexPath.values()) {
-            dumpPrimaryDex(ipw, snapshot, fileStatuses, packageName);
+            dumpPrimaryDex(ipw, snapshot, fileStatuses, packageName, verifySdmSignatures);
         }
         if (!secondaryStatusesByDexPath.isEmpty()) {
             ipw.println("known secondary dex files:");
@@ -141,7 +147,8 @@ public class DumpHelper {
 
     private void dumpPrimaryDex(@NonNull IndentingPrintWriter ipw,
             @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
-            List<DexContainerFileDexoptStatus> fileStatuses, @NonNull String packageName) {
+            List<DexContainerFileDexoptStatus> fileStatuses, @NonNull String packageName,
+            boolean verifySdmSignatures) {
         String dexPath = fileStatuses.get(0).getDexContainerFile();
         ipw.printf("path: %s\n", dexPath);
         ipw.increaseIndent();
@@ -149,6 +156,7 @@ public class DumpHelper {
         dumpUsedByOtherApps(ipw, snapshot,
                 mInjector.getDexUseManager().getPrimaryDexLoaders(packageName, dexPath),
                 packageName);
+        dumpSdmStatus(ipw, dexPath, verifySdmSignatures);
         ipw.decreaseIndent();
     }
 
@@ -217,6 +225,68 @@ public class DumpHelper {
         }
     }
 
+    private void dumpSdmStatus(@NonNull IndentingPrintWriter ipw, @NonNull String dexPath,
+            boolean verifySdmSignatures) {
+        if (!android.content.pm.Flags.cloudCompilationPm()) {
+            return;
+        }
+
+        String sdmPath = getSdmPath(dexPath);
+        String status = "";
+        String signature = "skipped";
+        if (mInjector.fileExists(sdmPath)) {
+            // "Pending" means yet to be picked up by dexopt. For now, "pending" is the only status
+            // because SDM files are not supported yet.
+            status = "pending";
+            // This operation is expensive, so hide it behind a flag.
+            if (verifySdmSignatures) {
+                signature = getSdmSignatureStatus(dexPath, sdmPath);
+            }
+        }
+        if (!status.isEmpty()) {
+            ipw.printf("sdm: [sdm-status=%s] [sdm-signature=%s]\n", status, signature);
+        }
+    }
+
+    // The new API usage is safe because it's guarded by a flag. The "NewApi" lint is wrong because
+    // it's meaningless (b/380891026). We have to work around the lint error because there is no
+    // `isAtLeastB` to check yet.
+    // TODO(jiakaiz): Remove this workaround, change @FlaggedApi to @RequiresApi here, and check
+    // `isAtLeastB` at the call site after B SDK is finalized.
+    @FlaggedApi(android.content.pm.Flags.FLAG_CLOUD_COMPILATION_PM)
+    @SuppressLint("NewApi")
+    @NonNull
+    private String getSdmSignatureStatus(@NonNull String dexPath, @NonNull String sdmPath) {
+        SigningInfo sdmSigningInfo;
+        try {
+            sdmSigningInfo =
+                    mInjector.getVerifiedSigningInfo(sdmPath, SigningInfo.VERSION_SIGNING_BLOCK_V3);
+        } catch (SigningInfoException e) {
+            AsLog.w("Failed to verify SDM signature", e);
+            return "invalid-sdm-signature";
+        }
+
+        SigningInfo apkSigningInfo;
+        try {
+            apkSigningInfo =
+                    mInjector.getVerifiedSigningInfo(dexPath, SigningInfo.VERSION_SIGNING_BLOCK_V3);
+        } catch (SigningInfoException e) {
+            AsLog.w("Failed to verify SDM signature", e);
+            return "invalid-apk-signature";
+        }
+
+        if (!sdmSigningInfo.signersMatchExactly(apkSigningInfo)) {
+            return "mismatched-signers";
+        }
+
+        return "verified";
+    }
+
+    @NonNull
+    private static String getSdmPath(@NonNull String dexPath) {
+        return Utils.replaceFileExtension(dexPath, ArtConstants.SECURE_DEX_METADATA_FILE_EXT);
+    }
+
     @NonNull
     private String getLoaderState(
             @NonNull PackageManagerLocal.FilteredSnapshot snapshot, @NonNull DexLoader loader) {
@@ -252,5 +322,18 @@ public class DumpHelper {
         public DexUseManagerLocal getDexUseManager() {
             return GlobalInjector.getInstance().getDexUseManager();
         }
+
+        public boolean fileExists(@NonNull String path) {
+            return new File(path).exists();
+        }
+
+        // TODO(jiakaiz): See another comment about "NewApi" above.
+        @FlaggedApi(android.content.pm.Flags.FLAG_CLOUD_COMPILATION_PM)
+        @SuppressLint("NewApi")
+        @NonNull
+        public SigningInfo getVerifiedSigningInfo(
+                @NonNull String path, int minAppSigningSchemeVersion) throws SigningInfoException {
+            return PackageManager.getVerifiedSigningInfo(path, minAppSigningSchemeVersion);
+        }
     }
 }
diff --git a/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java b/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
index 65062612a3..b7f47543fc 100644
--- a/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
+++ b/libartservice/service/java/com/android/server/art/PreRebootDexoptJob.java
@@ -113,8 +113,8 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     // stats, should only be done when there is no job running and the `this` lock is held, or by
     // the job itself.
 
-    public PreRebootDexoptJob(@NonNull Context context) {
-        this(new Injector(context));
+    public PreRebootDexoptJob(@NonNull Context context, @NonNull ArtManagerLocal artManagerLocal) {
+        this(new Injector(context, artManagerLocal));
     }
 
     @VisibleForTesting
@@ -514,9 +514,11 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
     @VisibleForTesting
     public static class Injector {
         @NonNull private final Context mContext;
+        @NonNull private final ArtManagerLocal mArtManagerLocal;
 
-        Injector(@NonNull Context context) {
+        Injector(@NonNull Context context, @NonNull ArtManagerLocal artManagerLocal) {
             mContext = context;
+            mArtManagerLocal = artManagerLocal;
         }
 
         @NonNull
@@ -526,7 +528,7 @@ public class PreRebootDexoptJob implements ArtServiceJobInterface {
 
         @NonNull
         public PreRebootDriver getPreRebootDriver() {
-            return new PreRebootDriver(mContext);
+            return new PreRebootDriver(mContext, mArtManagerLocal);
         }
 
         @NonNull
diff --git a/libartservice/service/java/com/android/server/art/ReasonMapping.java b/libartservice/service/java/com/android/server/art/ReasonMapping.java
index 9571ca20d6..e6296e02de 100644
--- a/libartservice/service/java/com/android/server/art/ReasonMapping.java
+++ b/libartservice/service/java/com/android/server/art/ReasonMapping.java
@@ -18,6 +18,7 @@ package com.android.server.art;
 
 import static com.android.server.art.model.ArtFlags.PriorityClassApi;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.StringDef;
 import android.annotation.SystemApi;
@@ -27,6 +28,7 @@ import android.text.TextUtils;
 
 import androidx.annotation.RequiresApi;
 
+import com.android.art.flags.Flags;
 import com.android.server.art.model.ArtFlags;
 import com.android.server.pm.PackageManagerLocal;
 
@@ -62,7 +64,11 @@ public class ReasonMapping {
     public static final String REASON_CMDLINE = "cmdline";
     /** Downgrading the compiler filter when an app is not used for a long time. */
     public static final String REASON_INACTIVE = "inactive";
-    /** @hide */
+    /**
+     * Dexopting apps before the reboot for an OTA or a mainline update, known as Pre-reboot
+     * Dexopt.
+     */
+    @FlaggedApi(Flags.FLAG_ART_SERVICE_V3)
     public static final String REASON_PRE_REBOOT_DEXOPT = "ab-ota";
 
     // Reasons for Play Install Hints (go/install-hints).
diff --git a/libartservice/service/java/com/android/server/art/Utils.java b/libartservice/service/java/com/android/server/art/Utils.java
index 600671fcb2..e042c3e106 100644
--- a/libartservice/service/java/com/android/server/art/Utils.java
+++ b/libartservice/service/java/com/android/server/art/Utils.java
@@ -501,6 +501,19 @@ public final class Utils {
         return path.length() == prefixLen || path.charAt(prefixLen) == '/';
     }
 
+    /**
+     * Replaces the file extension of the given path with the given new extension.
+     *
+     * @param path the path to replace the extension for
+     * @param newExtension the new extension, including the leading dot
+     */
+    @NonNull
+    public static String replaceFileExtension(@NonNull String path, @NonNull String newExtension) {
+        int pos = path.lastIndexOf('.');
+        int slashPos = path.indexOf('/', pos);
+        return ((pos != -1 && slashPos == -1) ? path.substring(0, pos) : path) + newExtension;
+    }
+
     @AutoValue
     public abstract static class Abi {
         static @NonNull Abi create(
diff --git a/libartservice/service/java/com/android/server/art/model/ArtFlags.java b/libartservice/service/java/com/android/server/art/model/ArtFlags.java
index 0a79d74089..98b12e4030 100644
--- a/libartservice/service/java/com/android/server/art/model/ArtFlags.java
+++ b/libartservice/service/java/com/android/server/art/model/ArtFlags.java
@@ -172,6 +172,7 @@ public class ArtFlags {
             case ReasonMapping.REASON_BOOT_AFTER_MAINLINE_UPDATE:
                 return FLAG_FOR_PRIMARY_DEX | FLAG_SHOULD_INCLUDE_DEPENDENCIES;
             case ReasonMapping.REASON_BG_DEXOPT:
+            case ReasonMapping.REASON_PRE_REBOOT_DEXOPT:
                 return FLAG_FOR_PRIMARY_DEX | FLAG_FOR_SECONDARY_DEX
                         | FLAG_SHOULD_INCLUDE_DEPENDENCIES | FLAG_SKIP_IF_STORAGE_LOW;
             case ReasonMapping.REASON_CMDLINE:
diff --git a/libartservice/service/java/com/android/server/art/model/BatchDexoptParams.java b/libartservice/service/java/com/android/server/art/model/BatchDexoptParams.java
index ffe5500b81..18ce4f8d54 100644
--- a/libartservice/service/java/com/android/server/art/model/BatchDexoptParams.java
+++ b/libartservice/service/java/com/android/server/art/model/BatchDexoptParams.java
@@ -18,8 +18,12 @@ package com.android.server.art.model;
 
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
+import android.os.Build;
+
+import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.Immutable;
+import com.android.server.art.proto.BatchDexoptParamsProto;
 
 import com.google.auto.value.AutoValue;
 
@@ -29,6 +33,7 @@ import java.util.List;
 
 /** @hide */
 @SystemApi(client = SystemApi.Client.SYSTEM_SERVER)
+@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
 @Immutable
 @AutoValue
 public abstract class BatchDexoptParams {
@@ -84,4 +89,19 @@ public abstract class BatchDexoptParams {
 
     /** The params for dexopting each package. */
     public abstract @NonNull DexoptParams getDexoptParams();
+
+    /** @hide */
+    public static @NonNull BatchDexoptParams fromProto(@NonNull BatchDexoptParamsProto proto) {
+        return new BatchDexoptParams
+                .Builder(proto.getPackageList(), DexoptParams.fromProto(proto.getDexoptParams()))
+                .build();
+    }
+
+    /** @hide */
+    public @NonNull BatchDexoptParamsProto toProto() {
+        return BatchDexoptParamsProto.newBuilder()
+                .addAllPackage(getPackages())
+                .setDexoptParams(getDexoptParams().toProto())
+                .build();
+    }
 }
diff --git a/libartservice/service/java/com/android/server/art/model/DexoptParams.java b/libartservice/service/java/com/android/server/art/model/DexoptParams.java
index 455d4cdead..0c264d8266 100644
--- a/libartservice/service/java/com/android/server/art/model/DexoptParams.java
+++ b/libartservice/service/java/com/android/server/art/model/DexoptParams.java
@@ -30,6 +30,7 @@ import com.android.internal.annotations.Immutable;
 import com.android.server.art.ArtConstants;
 import com.android.server.art.ReasonMapping;
 import com.android.server.art.Utils;
+import com.android.server.art.proto.DexoptParamsProto;
 
 /** @hide */
 @SystemApi(client = SystemApi.Client.SYSTEM_SERVER)
@@ -231,4 +232,26 @@ public class DexoptParams {
                 .setPriorityClass(mPriorityClass)
                 .setSplitName(mSplitName);
     }
+
+    /** @hide */
+    public static @NonNull DexoptParams fromProto(@NonNull DexoptParamsProto proto) {
+        return new DexoptParams.Builder(proto.getReason(), proto.getFlags())
+                .setCompilerFilter(proto.getCompilerFilter())
+                .setPriorityClass(proto.getPriorityClass())
+                .build();
+    }
+
+    /** @hide */
+    public @NonNull DexoptParamsProto toProto() {
+        // The split name is intentionally omitted from the proto because it's for batch dexopt
+        // only. Extend the proto when it's used for other purposes.
+        Utils.check(getSplitName() == null);
+
+        return DexoptParamsProto.newBuilder()
+                .setFlags(getFlags())
+                .setCompilerFilter(getCompilerFilter())
+                .setPriorityClass(getPriorityClass())
+                .setReason(getReason())
+                .build();
+    }
 }
diff --git a/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java b/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
index abcaa488f1..7c1a1c55fa 100644
--- a/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
+++ b/libartservice/service/java/com/android/server/art/prereboot/PreRebootDriver.java
@@ -34,6 +34,7 @@ import android.system.Os;
 import androidx.annotation.RequiresApi;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.LocalManagerRegistry;
 import com.android.server.art.ArtJni;
 import com.android.server.art.ArtManagerLocal;
 import com.android.server.art.ArtModuleServiceInitializer;
@@ -43,7 +44,10 @@ import com.android.server.art.GlobalInjector;
 import com.android.server.art.IArtd;
 import com.android.server.art.IDexoptChrootSetup;
 import com.android.server.art.PreRebootDexoptJob;
+import com.android.server.art.ReasonMapping;
 import com.android.server.art.Utils;
+import com.android.server.art.model.BatchDexoptParams;
+import com.android.server.pm.PackageManagerLocal;
 
 import dalvik.system.DelegateLastClassLoader;
 
@@ -57,6 +61,7 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.file.Files;
 import java.nio.file.Paths;
+import java.util.Objects;
 
 /**
  * Drives Pre-reboot Dexopt, through reflection.
@@ -71,8 +76,8 @@ import java.nio.file.Paths;
 public class PreRebootDriver {
     @NonNull private final Injector mInjector;
 
-    public PreRebootDriver(@NonNull Context context) {
-        this(new Injector(context));
+    public PreRebootDriver(@NonNull Context context, @NonNull ArtManagerLocal artManagerLocal) {
+        this(new Injector(context, artManagerLocal));
     }
 
     @VisibleForTesting
@@ -95,8 +100,14 @@ public class PreRebootDriver {
         boolean systemRequirementCheckFailed = false;
         try {
             statsReporter.recordJobStarted();
-            setUp(otaSlot, mapSnapshotsForOta);
-            runFromChroot(cancellationSignal);
+            try (var snapshot = mInjector.getPackageManagerLocal().withFilteredSnapshot()) {
+                BatchDexoptParams params = mInjector.getArtManagerLocal().getBatchDexoptParams(
+                        snapshot, ReasonMapping.REASON_PRE_REBOOT_DEXOPT, cancellationSignal);
+                if (!cancellationSignal.isCanceled()) {
+                    setUp(otaSlot, mapSnapshotsForOta);
+                    runFromChroot(cancellationSignal, snapshot, params);
+                }
+            }
             success = true;
             return true;
         } catch (RemoteException e) {
@@ -201,8 +212,19 @@ public class PreRebootDriver {
         mInjector.getDexoptChrootSetup().tearDown(false /* allowConcurrent */);
     }
 
-    private void runFromChroot(@NonNull CancellationSignal cancellationSignal)
+    private void runFromChroot(@NonNull CancellationSignal cancellationSignal,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @NonNull BatchDexoptParams params)
             throws ReflectiveOperationException, IOException, ErrnoException {
+        // Load the new `service-art.jar` on top of the current classloader, which has the old
+        // system server, framework, and Libcore.
+        // Note that the current classloader also includes the old `service-art.jar`, so this load
+        // inevitably introduces duplicate classes. We use `DelegateLastClassLoader` so that the
+        // classes in the new `service-art.jar` shadow the old ones, to make sure only new classes
+        // are used. Be careful not to pass an instance of a class between the old `service-art.jar`
+        // and the new `service-art.jar` (across the API boundary in `PreRebootManagerInterface`,
+        // either as a parameter or a return value).
+        // For this reason, a serialized protobuf is used for passing `BatchDexoptParams`.
         String chrootArtDir = CHROOT_DIR + "/apex/com.android.art";
         String dexPath = chrootArtDir + "/javalib/service-art.jar";
 
@@ -227,9 +249,11 @@ public class PreRebootDriver {
         Object preRebootManager = preRebootManagerClass.getConstructor().newInstance();
         preRebootManagerClass
                 .getMethod("run", ArtModuleServiceManager.class, Context.class,
-                        CancellationSignal.class)
+                        CancellationSignal.class, PackageManagerLocal.FilteredSnapshot.class,
+                        byte[].class)
                 .invoke(preRebootManager, ArtModuleServiceInitializer.getArtModuleServiceManager(),
-                        mInjector.getContext(), cancellationSignal);
+                        mInjector.getContext(), cancellationSignal, snapshot,
+                        params.toProto().toByteArray());
     }
 
     /**
@@ -240,9 +264,11 @@ public class PreRebootDriver {
     @VisibleForTesting
     public static class Injector {
         @NonNull private final Context mContext;
+        @NonNull private final ArtManagerLocal mArtManagerLocal;
 
-        Injector(@NonNull Context context) {
+        Injector(@NonNull Context context, @NonNull ArtManagerLocal artManagerLocal) {
             mContext = context;
+            mArtManagerLocal = artManagerLocal;
         }
 
         @NonNull
@@ -259,5 +285,16 @@ public class PreRebootDriver {
         public IArtd getArtd() {
             return ArtdRefCache.getInstance().getArtd();
         }
+
+        @NonNull
+        public ArtManagerLocal getArtManagerLocal() {
+            return mArtManagerLocal;
+        }
+
+        @NonNull
+        public PackageManagerLocal getPackageManagerLocal() {
+            return Objects.requireNonNull(
+                    LocalManagerRegistry.getManager(PackageManagerLocal.class));
+        }
     }
 }
diff --git a/libartservice/service/java/com/android/server/art/prereboot/PreRebootManager.java b/libartservice/service/java/com/android/server/art/prereboot/PreRebootManager.java
index d4c4e570e2..5ffb2e0a0a 100644
--- a/libartservice/service/java/com/android/server/art/prereboot/PreRebootManager.java
+++ b/libartservice/service/java/com/android/server/art/prereboot/PreRebootManager.java
@@ -20,6 +20,7 @@ import static com.android.server.art.model.DexoptResult.PackageDexoptResult;
 import static com.android.server.art.proto.PreRebootStats.Status;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.content.Context;
 import android.os.ArtModuleServiceManager;
 import android.os.Build;
@@ -34,10 +35,14 @@ import com.android.server.art.AsLog;
 import com.android.server.art.ReasonMapping;
 import com.android.server.art.Utils;
 import com.android.server.art.model.ArtFlags;
+import com.android.server.art.model.BatchDexoptParams;
 import com.android.server.art.model.DexoptResult;
 import com.android.server.art.model.OperationProgress;
+import com.android.server.art.proto.BatchDexoptParamsProto;
 import com.android.server.pm.PackageManagerLocal;
 
+import com.google.protobuf.InvalidProtocolBufferException;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -61,6 +66,18 @@ import java.util.function.Consumer;
 public class PreRebootManager implements PreRebootManagerInterface {
     public void run(@NonNull ArtModuleServiceManager artModuleServiceManager,
             @NonNull Context context, @NonNull CancellationSignal cancellationSignal) {
+        PackageManagerLocal packageManagerLocal =
+                Objects.requireNonNull(LocalManagerRegistry.getManager(PackageManagerLocal.class));
+        try (var snapshot = packageManagerLocal.withFilteredSnapshot()) {
+            run(artModuleServiceManager, context, cancellationSignal, snapshot,
+                    null /* batchDexoptParamsProto */);
+        }
+    }
+
+    public void run(@NonNull ArtModuleServiceManager artModuleServiceManager,
+            @NonNull Context context, @NonNull CancellationSignal cancellationSignal,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @Nullable byte[] batchDexoptParamsProto) {
         ExecutorService callbackExecutor = Executors.newSingleThreadExecutor();
         try {
             if (!PreRebootGlobalInjector.init(
@@ -68,8 +85,6 @@ public class PreRebootManager implements PreRebootManagerInterface {
                 return;
             }
             ArtManagerLocal artManagerLocal = new ArtManagerLocal(context);
-            PackageManagerLocal packageManagerLocal = Objects.requireNonNull(
-                    LocalManagerRegistry.getManager(PackageManagerLocal.class));
 
             var progressSession = new PreRebootStatsReporter().new ProgressSession();
 
@@ -109,11 +124,19 @@ public class PreRebootManager implements PreRebootManagerInterface {
                         progress.getTotal(), values.get(3));
             };
 
-            try (var snapshot = packageManagerLocal.withFilteredSnapshot()) {
-                artManagerLocal.dexoptPackages(snapshot, ReasonMapping.REASON_PRE_REBOOT_DEXOPT,
-                        cancellationSignal, callbackExecutor,
-                        Map.of(ArtFlags.PASS_MAIN, progressCallback));
+            BatchDexoptParams params;
+            try {
+                params = batchDexoptParamsProto != null
+                        ? BatchDexoptParams.fromProto(
+                                  BatchDexoptParamsProto.parseFrom(batchDexoptParamsProto))
+                        : null;
+            } catch (InvalidProtocolBufferException e) {
+                throw new IllegalArgumentException(e);
             }
+
+            artManagerLocal.dexoptPackagesWithParams(snapshot,
+                    ReasonMapping.REASON_PRE_REBOOT_DEXOPT, cancellationSignal, callbackExecutor,
+                    Map.of(ArtFlags.PASS_MAIN, progressCallback), params);
         } finally {
             ArtdRefCache.getInstance().reset();
             callbackExecutor.shutdown();
diff --git a/libartservice/service/java/com/android/server/art/prereboot/PreRebootManagerInterface.java b/libartservice/service/java/com/android/server/art/prereboot/PreRebootManagerInterface.java
index 85f8b3f931..340e9a7d42 100644
--- a/libartservice/service/java/com/android/server/art/prereboot/PreRebootManagerInterface.java
+++ b/libartservice/service/java/com/android/server/art/prereboot/PreRebootManagerInterface.java
@@ -17,6 +17,7 @@
 package com.android.server.art.prereboot;
 
 import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.content.Context;
 import android.os.ArtModuleServiceManager;
 import android.os.Build;
@@ -24,6 +25,9 @@ import android.os.CancellationSignal;
 
 import androidx.annotation.RequiresApi;
 
+import com.android.server.art.proto.BatchDexoptParamsProto;
+import com.android.server.pm.PackageManagerLocal;
+
 /**
  * The interface for the entry point of Pre-reboot Dexopt, called through reflection from an old
  * version of the ART module. This interface must be kept stable from one version of the ART module
@@ -37,13 +41,28 @@ import androidx.annotation.RequiresApi;
  *
  * During Pre-reboot Dexopt, the new version of this code is run.
  *
+ * Methods in this interface must not take an instance of a class defined in `service-art.jar`. See
+ * comments in {@link PreRebootDriver#runFromChroot} for the reason.
+ *
  * @hide
  */
 @RequiresApi(Build.VERSION_CODES.VANILLA_ICE_CREAM)
 public interface PreRebootManagerInterface {
+    /** Since Android V. For backward compatibility only. */
     void run(@NonNull ArtModuleServiceManager artModuleServiceManager, @NonNull Context context,
             @NonNull CancellationSignal cancellationSignal) throws SystemRequirementException;
 
+    /**
+     * Since Android B. The current API.
+     *
+     * @param snapshot The snapshot that {@code batchDexoptParamsProto} is created with.
+     * @param batchDexoptParamsProto {@link BatchDexoptParamsProto}, in binary format.
+     */
+    void run(@NonNull ArtModuleServiceManager artModuleServiceManager, @NonNull Context context,
+            @NonNull CancellationSignal cancellationSignal,
+            @NonNull PackageManagerLocal.FilteredSnapshot snapshot,
+            @Nullable byte[] batchDexoptParamsProto) throws SystemRequirementException;
+
     public static class SystemRequirementException extends Exception {
         public SystemRequirementException(@NonNull String message) {
             super(message);
diff --git a/libartservice/service/javatests/com/android/server/art/ArtManagedInstallFileHelperTest.java b/libartservice/service/javatests/com/android/server/art/ArtManagedInstallFileHelperTest.java
new file mode 100644
index 0000000000..4b13716eaa
--- /dev/null
+++ b/libartservice/service/javatests/com/android/server/art/ArtManagedInstallFileHelperTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.server.art;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.List;
+
+@SmallTest
+@RunWith(AndroidJUnit4.class)
+public class ArtManagedInstallFileHelperTest {
+    @Test
+    public void testIsArtManaged() throws Exception {
+        assertThat(ArtManagedInstallFileHelper.isArtManaged("/foo/bar.dm")).isTrue();
+        assertThat(ArtManagedInstallFileHelper.isArtManaged("/foo/bar.prof")).isTrue();
+        assertThat(ArtManagedInstallFileHelper.isArtManaged("/foo/bar.sdm")).isTrue();
+        assertThat(ArtManagedInstallFileHelper.isArtManaged("/foo/bar.abc")).isFalse();
+    }
+
+    @Test
+    public void testFilterPathsForApk() throws Exception {
+        assertThat(ArtManagedInstallFileHelper.filterPathsForApk(
+                           List.of("/foo/bar.dm", "/foo/bar.prof", "/foo/bar.sdm", "/foo/bar.abc",
+                                   "/foo/baz.dm"),
+                           "/foo/bar.apk"))
+                .containsExactly("/foo/bar.dm", "/foo/bar.prof", "/foo/bar.sdm");
+
+        // Filenames don't match.
+        assertThat(ArtManagedInstallFileHelper.filterPathsForApk(
+                           List.of("/foo/bar.dm", "/foo/bar.prof", "/foo/bar.sdm", "/foo/bar.abc",
+                                   "/foo/baz.dm"),
+                           "/foo/qux.apk"))
+                .isEmpty();
+
+        // Directories don't match.
+        assertThat(ArtManagedInstallFileHelper.filterPathsForApk(
+                           List.of("/foo/bar.dm", "/foo/bar.prof", "/foo/bar.sdm", "/foo/bar.abc",
+                                   "/foo/baz.dm"),
+                           "/quz/bar.apk"))
+                .isEmpty();
+    }
+
+    @Test
+    public void testGetTargetPathForApk() throws Exception {
+        assertThat(ArtManagedInstallFileHelper.getTargetPathForApk(
+                           "/foo/bar.dm", "/somewhere/base.apk"))
+                .isEqualTo("/somewhere/base.dm");
+        assertThat(ArtManagedInstallFileHelper.getTargetPathForApk(
+                           "/foo/bar.prof", "/somewhere/base.apk"))
+                .isEqualTo("/somewhere/base.prof");
+        assertThat(ArtManagedInstallFileHelper.getTargetPathForApk(
+                           "/foo/bar.sdm", "/somewhere/base.apk"))
+                .isEqualTo("/somewhere/base.sdm");
+
+        assertThrows(IllegalArgumentException.class, () -> {
+            ArtManagedInstallFileHelper.getTargetPathForApk("/foo/bar.abc", "/somewhere/base.apk");
+        });
+    }
+}
diff --git a/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java b/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
index 9deb3f1055..8841de7fed 100644
--- a/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
+++ b/libartservice/service/javatests/com/android/server/art/ArtManagerLocalTest.java
@@ -64,6 +64,7 @@ import androidx.test.filters.SmallTest;
 import com.android.modules.utils.pm.PackageStateModulesUtils;
 import com.android.server.art.model.ArtFlags;
 import com.android.server.art.model.ArtManagedFileStats;
+import com.android.server.art.model.BatchDexoptParams;
 import com.android.server.art.model.Config;
 import com.android.server.art.model.DeleteResult;
 import com.android.server.art.model.DexoptParams;
@@ -874,6 +875,32 @@ public class ArtManagerLocalTest {
                 null /* processCallbackExecutor */, null /* processCallback */);
     }
 
+    @Test
+    public void testDexoptPackagesWithParams() throws Exception {
+        var dexoptResult = DexoptResult.create();
+        var cancellationSignal = new CancellationSignal();
+
+        // It should only dexopt PKG_NAME_1 with "speed" as specified by the params.
+        doReturn(dexoptResult)
+                .when(mDexoptHelper)
+                .dexopt(any(), deepEq(List.of(PKG_NAME_1)),
+                        argThat(params
+                                -> params.getReason().equals("ab-ota")
+                                        && params.getCompilerFilter().equals("speed")),
+                        same(cancellationSignal), any(), any(), any());
+
+        BatchDexoptParams params = new BatchDexoptParams
+                                           .Builder(List.of(PKG_NAME_1),
+                                                   new DexoptParams.Builder("ab-ota")
+                                                           .setCompilerFilter("speed")
+                                                           .build())
+                                           .build();
+        assertThat(
+                mArtManagerLocal.dexoptPackagesWithParams(mSnapshot, "ab-ota", cancellationSignal,
+                        null /* processCallbackExecutor */, null /* processCallback */, params))
+                .isEqualTo(Map.of(ArtFlags.PASS_MAIN, dexoptResult));
+    }
+
     @Test
     public void testSnapshotAppProfile() throws Exception {
         var options = new MergeProfileOptions();
diff --git a/libartservice/service/javatests/com/android/server/art/BackgroundDexoptJobTest.java b/libartservice/service/javatests/com/android/server/art/BackgroundDexoptJobTest.java
index 85ae079c77..93c2aed7eb 100644
--- a/libartservice/service/javatests/com/android/server/art/BackgroundDexoptJobTest.java
+++ b/libartservice/service/javatests/com/android/server/art/BackgroundDexoptJobTest.java
@@ -79,7 +79,7 @@ public class BackgroundDexoptJobTest {
     @Mock private BackgroundDexoptJob.Injector mInjector;
     @Mock private ArtManagerLocal mArtManagerLocal;
     @Mock private PackageManagerLocal mPackageManagerLocal;
-    @Mock private PackageManagerLocal.FilteredSnapshot mSnapshot;
+    @Mock private PackageManagerLocal.FilteredSnapshot mSnapshot1, mSnapshot2;
     @Mock private JobScheduler mJobScheduler;
     @Mock private BackgroundDexoptJobService mJobService;
     @Mock private JobParameters mJobParameters;
@@ -94,8 +94,6 @@ public class BackgroundDexoptJobTest {
                 .when(SystemProperties.getBoolean(eq("pm.dexopt.disable_bg_dexopt"), anyBoolean()))
                 .thenReturn(false);
 
-        lenient().when(mPackageManagerLocal.withFilteredSnapshot()).thenReturn(mSnapshot);
-
         mConfig = new Config();
 
         lenient().when(mInjector.getArtManagerLocal()).thenReturn(mArtManagerLocal);
@@ -123,15 +121,19 @@ public class BackgroundDexoptJobTest {
 
     @Test
     public void testStart() {
+        when(mPackageManagerLocal.withFilteredSnapshot())
+                .thenReturn(mSnapshot1)
+                .thenReturn(mSnapshot2);
+
         when(mArtManagerLocal.dexoptPackages(
-                     same(mSnapshot), eq(ReasonMapping.REASON_BG_DEXOPT), any(), any(), any()))
+                     same(mSnapshot1), eq(ReasonMapping.REASON_BG_DEXOPT), any(), any(), any()))
                 .thenReturn(mDexoptResultByPass);
 
         Result result = Utils.getFuture(mBackgroundDexoptJob.start());
         assertThat(result).isInstanceOf(CompletedResult.class);
         assertThat(((CompletedResult) result).dexoptResultByPass()).isEqualTo(mDexoptResultByPass);
 
-        verify(mArtManagerLocal).cleanup(same(mSnapshot));
+        verify(mArtManagerLocal).cleanup(same(mSnapshot2));
     }
 
     @Test
diff --git a/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java b/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
index 95d111774d..3ea3509b82 100644
--- a/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
+++ b/libartservice/service/javatests/com/android/server/art/DexUseManagerTest.java
@@ -90,7 +90,7 @@ public class DexUseManagerTest {
     public StaticMockitoRule mockitoRule = new StaticMockitoRule(
             SystemProperties.class, Constants.class, Process.class, ArtJni.class);
 
-    private final UserHandle mUserHandle = Binder.getCallingUserHandle();
+    private final UserHandle mUserHandle = UserHandle.of(1);
 
     /**
      * The default value of `fileVisibility` returned by `getSecondaryDexInfo`. The value doesn't
@@ -155,12 +155,12 @@ public class DexUseManagerTest {
                 .thenReturn(mock(Intent.class));
 
         mCeDir = Environment
-                         .getDataCePackageDirectoryForUser(StorageManager.UUID_DEFAULT,
-                                 Binder.getCallingUserHandle(), OWNING_PKG_NAME)
+                         .getDataCePackageDirectoryForUser(
+                                 StorageManager.UUID_DEFAULT, mUserHandle, OWNING_PKG_NAME)
                          .toString();
         mDeDir = Environment
-                         .getDataDePackageDirectoryForUser(StorageManager.UUID_DEFAULT,
-                                 Binder.getCallingUserHandle(), OWNING_PKG_NAME)
+                         .getDataDePackageDirectoryForUser(
+                                 StorageManager.UUID_DEFAULT, mUserHandle, OWNING_PKG_NAME)
                          .toString();
         mMockClock = new MockClock();
 
@@ -185,6 +185,8 @@ public class DexUseManagerTest {
         lenient().when(mInjector.isPreReboot()).thenReturn(false);
         lenient().when(mInjector.getArtManagerLocal()).thenReturn(mArtManagerLocal);
         lenient().when(mInjector.getPackageManagerLocal()).thenReturn(mPackageManagerLocal);
+        lenient().when(mInjector.getCallingUserHandle()).thenReturn(mUserHandle);
+        lenient().when(mInjector.getCallingUid()).thenReturn(110001);
 
         mDexUseManager = new DexUseManagerLocal(mInjector);
         mDexUseManager.systemReady();
@@ -793,7 +795,7 @@ public class DexUseManagerTest {
         assertThat(textproto).isEqualTo("package_dex_use {\n"
                 + "  owning_package_name: \"com.example.owningpackage\"\n"
                 + "  secondary_dex_use {\n"
-                + "    dex_file: \"/data/user/0/com.example.owningpackage/bar.apk\"\n"
+                + "    dex_file: \"/data/user/1/com.example.owningpackage/bar.apk\"\n"
                 + "    record {\n"
                 + "      abi_name: \"arm64-v8a\"\n"
                 + "      class_loader_context: \"CLC\"\n"
@@ -801,6 +803,7 @@ public class DexUseManagerTest {
                 + "      loading_package_name: \"com.example.owningpackage\"\n"
                 + "    }\n"
                 + "    user_id {\n"
+                + "      value: 1\n"
                 + "    }\n"
                 + "  }\n"
                 + "}");
diff --git a/libartservice/service/javatests/com/android/server/art/DumpHelperTest.java b/libartservice/service/javatests/com/android/server/art/DumpHelperTest.java
index 45a7010d09..c063260f86 100644
--- a/libartservice/service/javatests/com/android/server/art/DumpHelperTest.java
+++ b/libartservice/service/javatests/com/android/server/art/DumpHelperTest.java
@@ -24,12 +24,19 @@ import static com.android.server.art.model.DexoptStatus.DexContainerFileDexoptSt
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyInt;
 import static org.mockito.Mockito.argThat;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.eq;
 import static org.mockito.Mockito.lenient;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+import android.content.pm.SigningInfo;
+import android.content.pm.SigningInfoException;
 import android.os.SystemProperties;
 
 import androidx.test.filters.SmallTest;
@@ -70,6 +77,8 @@ public class DumpHelperTest {
     @Mock private ArtManagerLocal mArtManagerLocal;
     @Mock private DexUseManagerLocal mDexUseManagerLocal;
     @Mock private PackageManagerLocal.FilteredSnapshot mSnapshot;
+    @Mock private SigningInfo mSigningInfoA;
+    @Mock private SigningInfo mSigningInfoB;
 
     private DumpHelper mDumpHelper;
 
@@ -99,6 +108,11 @@ public class DumpHelperTest {
         setUpForBar();
         setUpForSdk();
 
+        lenient().when(mSigningInfoA.signersMatchExactly(mSigningInfoA)).thenReturn(true);
+        lenient().when(mSigningInfoA.signersMatchExactly(mSigningInfoB)).thenReturn(false);
+        lenient().when(mSigningInfoB.signersMatchExactly(mSigningInfoB)).thenReturn(true);
+        lenient().when(mSigningInfoB.signersMatchExactly(mSigningInfoA)).thenReturn(false);
+
         mDumpHelper = new DumpHelper(mInjector);
     }
 
@@ -123,7 +137,8 @@ public class DumpHelperTest {
                 + "      class loader context: =VaryingClassLoaderContexts=\n"
                 + "        com.example1.foo (isolated): CLC1\n"
                 + "        com.example3.baz: CLC2\n"
-                + "      used by other apps: [com.example1.foo (isolated) (isa=arm64), com.example3.baz (removed)]\n"
+                + "      used by other apps: [com.example1.foo (isolated) (isa=arm64), "
+                  + "com.example3.baz (removed)]\n"
                 + "    /data/user_de/0/foo/2.apk (public)\n"
                 + "      arm64: [status=speed-profile] [reason=bg-dexopt] [primary-abi]\n"
                 + "        [location is /data/user_de/0/foo/oat/arm64/2.odex]\n"
@@ -146,10 +161,84 @@ public class DumpHelperTest {
                 + "Current GC: CollectorTypeCMC\n";
 
         var stringWriter = new StringWriter();
-        mDumpHelper.dump(new PrintWriter(stringWriter), mSnapshot);
+        mDumpHelper.dump(new PrintWriter(stringWriter), mSnapshot, false /* verifySdmSignatures */);
         assertThat(stringWriter.toString()).isEqualTo(expected);
     }
 
+    @Test
+    public void testDumpSdmStatusNotFound() throws Exception {
+        when(mInjector.fileExists(any())).thenReturn(false);
+
+        var stringWriter = new StringWriter();
+        mDumpHelper.dumpPackage(new PrintWriter(stringWriter), mSnapshot,
+                getPackageState(PKG_NAME_BAR), true /* verifySdmSignatures */);
+        assertThat(stringWriter.toString()).doesNotContain("sdm:");
+    }
+
+    @Test
+    public void testDumpSdmStatusInvalidSdmSignature() throws Exception {
+        when(mInjector.fileExists("/somewhere/app/bar/base.sdm")).thenReturn(true);
+        when(mInjector.getVerifiedSigningInfo(eq("/somewhere/app/bar/base.sdm"), anyInt()))
+                .thenThrow(SigningInfoException.class);
+
+        var stringWriter = new StringWriter();
+        mDumpHelper.dumpPackage(new PrintWriter(stringWriter), mSnapshot,
+                getPackageState(PKG_NAME_BAR), true /* verifySdmSignatures */);
+        assertThat(stringWriter.toString())
+                .contains("sdm: [sdm-status=pending] [sdm-signature=invalid-sdm-signature]");
+    }
+
+    @Test
+    public void testDumpSdmStatusInvalidApkSignature() throws Exception {
+        when(mInjector.fileExists("/somewhere/app/bar/base.sdm")).thenReturn(true);
+        doReturn(mSigningInfoA)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.sdm"), anyInt());
+        doThrow(SigningInfoException.class)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.apk"), anyInt());
+
+        var stringWriter = new StringWriter();
+        mDumpHelper.dumpPackage(new PrintWriter(stringWriter), mSnapshot,
+                getPackageState(PKG_NAME_BAR), true /* verifySdmSignatures */);
+        assertThat(stringWriter.toString())
+                .contains("sdm: [sdm-status=pending] [sdm-signature=invalid-apk-signature]");
+    }
+
+    @Test
+    public void testDumpSdmStatusSignersNotMatch() throws Exception {
+        when(mInjector.fileExists("/somewhere/app/bar/base.sdm")).thenReturn(true);
+        doReturn(mSigningInfoA)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.sdm"), anyInt());
+        doReturn(mSigningInfoB)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.apk"), anyInt());
+
+        var stringWriter = new StringWriter();
+        mDumpHelper.dumpPackage(new PrintWriter(stringWriter), mSnapshot,
+                getPackageState(PKG_NAME_BAR), true /* verifySdmSignatures */);
+        assertThat(stringWriter.toString())
+                .contains("sdm: [sdm-status=pending] [sdm-signature=mismatched-signers]");
+    }
+
+    @Test
+    public void testDumpSdmStatusVerified() throws Exception {
+        when(mInjector.fileExists("/somewhere/app/bar/base.sdm")).thenReturn(true);
+        doReturn(mSigningInfoA)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.sdm"), anyInt());
+        doReturn(mSigningInfoA)
+                .when(mInjector)
+                .getVerifiedSigningInfo(eq("/somewhere/app/bar/base.apk"), anyInt());
+
+        var stringWriter = new StringWriter();
+        mDumpHelper.dumpPackage(new PrintWriter(stringWriter), mSnapshot,
+                getPackageState(PKG_NAME_BAR), true /* verifySdmSignatures */);
+        assertThat(stringWriter.toString())
+                .contains("sdm: [sdm-status=pending] [sdm-signature=verified]");
+    }
+
     private PackageState createPackageState(@NonNull String packageName, int appId, boolean isApex,
             boolean hasPackage, @NonNull String primaryAbi, @NonNull String secondaryAbi) {
         var pkgState = mock(PackageState.class);
@@ -317,4 +406,9 @@ public class DumpHelperTest {
                         PKG_NAME_SDK, "/somewhere/app/sdk/base.apk"))
                 .thenReturn(Set.of());
     }
+
+    @SuppressLint("DirectInvocationOnMock")
+    private PackageState getPackageState(String packageName) {
+        return mSnapshot.getPackageState(packageName);
+    }
 }
diff --git a/libartservice/service/javatests/com/android/server/art/UtilsTest.java b/libartservice/service/javatests/com/android/server/art/UtilsTest.java
index b3220ffdff..5dd484e021 100644
--- a/libartservice/service/javatests/com/android/server/art/UtilsTest.java
+++ b/libartservice/service/javatests/com/android/server/art/UtilsTest.java
@@ -220,4 +220,19 @@ public class UtilsTest {
         assertThat(Utils.pathStartsWith("/", "/")).isTrue();
         assertThat(Utils.pathStartsWith("/", "/a")).isFalse();
     }
+
+    @Test
+    public void testReplaceFileExtension() {
+        assertThat(Utils.replaceFileExtension("/directory/file.apk", ".dm"))
+                .isEqualTo("/directory/file.dm");
+        assertThat(Utils.replaceFileExtension("/directory/file", ".dm"))
+                .isEqualTo("/directory/file.dm");
+        assertThat(Utils.replaceFileExtension("/.directory/file.apk", ".dm"))
+                .isEqualTo("/.directory/file.dm");
+        assertThat(Utils.replaceFileExtension("/.directory/file", ".dm"))
+                .isEqualTo("/.directory/file.dm");
+        assertThat(Utils.replaceFileExtension("/directory/file.apk", ""))
+                .isEqualTo("/directory/file");
+        assertThat(Utils.replaceFileExtension("", ".dm")).isEqualTo(".dm");
+    }
 }
diff --git a/libartservice/service/javatests/com/android/server/art/model/BatchDexoptParamsTest.java b/libartservice/service/javatests/com/android/server/art/model/BatchDexoptParamsTest.java
new file mode 100644
index 0000000000..32e4cd92d1
--- /dev/null
+++ b/libartservice/service/javatests/com/android/server/art/model/BatchDexoptParamsTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.android.server.art.model;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import androidx.test.filters.SmallTest;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.server.art.proto.BatchDexoptParamsProto;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@SmallTest
+@RunWith(AndroidJUnit4.class)
+public class BatchDexoptParamsTest {
+    @Test
+    public void testToProto() {
+        // Update this test with new fields if this assertion fails.
+        checkFieldCoverage();
+
+        BatchDexoptParams params = new BatchDexoptParams
+                                           .Builder(List.of("package_a", "package_b"),
+                                                   new DexoptParams.Builder("install").build())
+                                           .build();
+
+        BatchDexoptParamsProto proto = params.toProto();
+
+        assertThat(proto.getPackageList())
+                .containsExactlyElementsIn(params.getPackages())
+                .inOrder();
+        assertThat(proto.getDexoptParams().getReason())
+                .isEqualTo(params.getDexoptParams().getReason());
+    }
+
+    @Test
+    public void testFromProto() {
+        // Update this test with new fields if this assertion fails.
+        checkFieldCoverage();
+
+        BatchDexoptParamsProto proto =
+                BatchDexoptParamsProto.newBuilder()
+                        .addAllPackage(List.of("package_a", "package_b"))
+                        .setDexoptParams(new DexoptParams.Builder("install").build().toProto())
+                        .build();
+
+        BatchDexoptParams params = BatchDexoptParams.fromProto(proto);
+
+        assertThat(params.getPackages())
+                .containsExactlyElementsIn(proto.getPackageList())
+                .inOrder();
+        assertThat(params.getDexoptParams().getReason())
+                .isEqualTo(proto.getDexoptParams().getReason());
+    }
+
+    private void checkFieldCoverage() {
+        assertThat(Arrays.stream(BatchDexoptParams.class.getDeclaredMethods())
+                           .filter(method -> Modifier.isAbstract(method.getModifiers()))
+                           .map(Method::getName)
+                           .collect(Collectors.toList()))
+                .containsExactly("getPackages", "getDexoptParams");
+    }
+}
diff --git a/libartservice/service/javatests/com/android/server/art/model/DexoptParamsTest.java b/libartservice/service/javatests/com/android/server/art/model/DexoptParamsTest.java
index d98340ee17..beadb314cf 100644
--- a/libartservice/service/javatests/com/android/server/art/model/DexoptParamsTest.java
+++ b/libartservice/service/javatests/com/android/server/art/model/DexoptParamsTest.java
@@ -21,6 +21,8 @@ import static com.google.common.truth.Truth.assertThat;
 import androidx.test.filters.SmallTest;
 import androidx.test.runner.AndroidJUnit4;
 
+import com.android.server.art.proto.DexoptParamsProto;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -117,12 +119,7 @@ public class DexoptParamsTest {
     @Test
     public void testToBuilder() {
         // Update this test with new fields if this assertion fails.
-        assertThat(Arrays.stream(DexoptParams.class.getDeclaredFields())
-                           .filter(field -> !Modifier.isStatic(field.getModifiers()))
-                           .map(Field::getName)
-                           .collect(Collectors.toList()))
-                .containsExactly(
-                        "mFlags", "mCompilerFilter", "mPriorityClass", "mReason", "mSplitName");
+        checkFieldCoverage();
 
         DexoptParams params1 =
                 new DexoptParams.Builder("install")
@@ -140,4 +137,53 @@ public class DexoptParamsTest {
         assertThat(params1.getReason()).isEqualTo(params2.getReason());
         assertThat(params1.getSplitName()).isEqualTo(params2.getSplitName());
     }
+
+    @Test
+    public void testToProto() {
+        // Update this test with new fields if this assertion fails.
+        checkFieldCoverage();
+
+        DexoptParams params = new DexoptParams.Builder("install")
+                                      .setFlags(ArtFlags.FLAG_FOR_PRIMARY_DEX)
+                                      .setCompilerFilter("speed")
+                                      .setPriorityClass(90)
+                                      .build();
+
+        DexoptParamsProto proto = params.toProto();
+
+        assertThat(proto.getFlags()).isEqualTo(params.getFlags());
+        assertThat(proto.getCompilerFilter()).isEqualTo(params.getCompilerFilter());
+        assertThat(proto.getPriorityClass()).isEqualTo(params.getPriorityClass());
+        assertThat(proto.getReason()).isEqualTo(params.getReason());
+    }
+
+    @Test
+    public void testFromProto() {
+        // Update this test with new fields if this assertion fails.
+        checkFieldCoverage();
+
+        DexoptParamsProto proto = DexoptParamsProto.newBuilder()
+                                          .setFlags(ArtFlags.FLAG_FOR_PRIMARY_DEX)
+                                          .setCompilerFilter("speed")
+                                          .setPriorityClass(90)
+                                          .setReason("install")
+                                          .build();
+
+        DexoptParams params = DexoptParams.fromProto(proto);
+
+        assertThat(params.getFlags()).isEqualTo(proto.getFlags());
+        assertThat(params.getCompilerFilter()).isEqualTo(proto.getCompilerFilter());
+        assertThat(params.getPriorityClass()).isEqualTo(proto.getPriorityClass());
+        assertThat(params.getReason()).isEqualTo(proto.getReason());
+        assertThat(params.getSplitName()).isNull();
+    }
+
+    private void checkFieldCoverage() {
+        assertThat(Arrays.stream(DexoptParams.class.getDeclaredFields())
+                           .filter(field -> !Modifier.isStatic(field.getModifiers()))
+                           .map(Field::getName)
+                           .collect(Collectors.toList()))
+                .containsExactly(
+                        "mFlags", "mCompilerFilter", "mPriorityClass", "mReason", "mSplitName");
+    }
 }
diff --git a/libartservice/service/proto/batch_dexopt_params.proto b/libartservice/service/proto/batch_dexopt_params.proto
new file mode 100644
index 0000000000..0cf9088728
--- /dev/null
+++ b/libartservice/service/proto/batch_dexopt_params.proto
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+syntax = "proto2";
+
+package com.android.server.art.proto;
+option java_multiple_files = true;
+
+// These protobufs are currently used as an ART-internal API for pre-reboot
+// dexopt to pass parameters from a version of the ART module to a potentially
+// more recent version in an OTA package. It's a 1:1 mapping to the
+// BatchDexoptParams API used for (normal) batch dexopt. That approach does not
+// add any extra compatibility constraints, because: a) We need to keep the
+// BatchDexoptParams API for all SDK levels the ART module gets pushed to, and
+// b) we only allow pre-reboot dexopt from SDK level N to N+1. Since (a) always
+// has a longer support window than (b), we cannot end up in a situation where
+// these protobufs forces us to keep support for a feature we wouldn't need to
+// keep anyway for batch dexopt.
+
+// The protobuf representation of `BatchDexoptParams`. See classes in
+// java/com/android/server/art/model/BatchDexoptParams.java and
+// java/com/android/server/art/model/DexoptParams.java for details.
+// Fields added to classes after Android B must be optional in the protos.
+message BatchDexoptParamsProto {
+    // Required.
+    repeated string package = 1;
+    // Required.
+    optional DexoptParamsProto dexopt_params = 2;
+}
+
+// The protobuf representation of `DexoptParams`.
+// Note that this is only for batch dexopt. Particularly, it doesn't have a field for the split
+// name.
+message DexoptParamsProto {
+    // Required.
+    optional int32 flags = 1;
+    // Required.
+    optional string compiler_filter = 2;
+    // Required.
+    optional int32 priority_class = 3;
+    // Required.
+    optional string reason = 4;
+}
diff --git a/libarttools/Android.bp b/libarttools/Android.bp
index e82ce0c403..73ad09aee5 100644
--- a/libarttools/Android.bp
+++ b/libarttools/Android.bp
@@ -72,6 +72,17 @@ cc_library_headers {
     ],
 }
 
+cc_library_headers {
+    name: "libarttools_testing",
+    defaults: ["art_defaults"],
+    host_supported: true,
+    export_include_dirs: ["include_testing"],
+    apex_available: [
+        "com.android.art",
+        "com.android.art.debug",
+    ],
+}
+
 art_cc_defaults {
     name: "art_libarttools_tests_defaults",
     srcs: [
@@ -80,6 +91,9 @@ art_cc_defaults {
         "system_properties_test.cc",
         "tools_test.cc",
     ],
+    header_libs: [
+        "libarttools_testing",
+    ],
     shared_libs: [
         "liblog", // libbase dependency
     ],
diff --git a/libarttools/art_exec_test.cc b/libarttools/art_exec_test.cc
index c1f15dc187..d6e0ba4802 100644
--- a/libarttools/art_exec_test.cc
+++ b/libarttools/art_exec_test.cc
@@ -32,7 +32,7 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "system/thread_defs.h"
-#include "testing.h"
+#include "tools/testing.h"
 
 #ifdef ART_TARGET_ANDROID
 #include "android-modules-utils/sdk_level.h"
diff --git a/libarttools/testing.h b/libarttools/include_testing/tools/testing.h
similarity index 69%
rename from libarttools/testing.h
rename to libarttools/include_testing/tools/testing.h
index eaa8523a1b..765fe91dd8 100644
--- a/libarttools/testing.h
+++ b/libarttools/include_testing/tools/testing.h
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#ifndef ART_LIBARTTOOLS_TESTING_H_
-#define ART_LIBARTTOOLS_TESTING_H_
+#ifndef ART_LIBARTTOOLS_INCLUDE_TESTING_TOOLS_TESTING_H_
+#define ART_LIBARTTOOLS_INCLUDE_TESTING_TOOLS_TESTING_H_
 
 #include <signal.h>
 #include <stdio.h>
@@ -24,12 +24,14 @@
 #include <unistd.h>
 
 #include <functional>
+#include <memory>
 #include <string>
 #include <utility>
 #include <vector>
 
 #include "android-base/logging.h"
 #include "android-base/scopeguard.h"
+#include "android-base/strings.h"
 #include "base/file_utils.h"
 #include "base/globals.h"
 #include "base/macros.h"
@@ -39,6 +41,7 @@ namespace tools {
 
 using ::android::base::make_scope_guard;
 using ::android::base::ScopeGuard;
+using ::android::base::Split;
 
 [[maybe_unused]] static std::string GetArtBin(const std::string& name) {
   CHECK(kIsTargetAndroid);
@@ -46,15 +49,20 @@ using ::android::base::ScopeGuard;
 }
 
 [[maybe_unused]] static std::string GetBin(const std::string& name) {
-  CHECK(kIsTargetAndroid);
-  return ART_FORMAT("{}/bin/{}", GetAndroidRoot(), name);
+  for (const std::string& path : Split(getenv("PATH"), ":")) {
+    if (std::filesystem::exists(path + "/" + name)) {
+      return path + "/" + name;
+    }
+  }
+  LOG(FATAL) << ART_FORMAT("Binary '{}' not found", name);
+  UNREACHABLE();
 }
 
-// Executes the command. If the `wait` is true, waits for the process to finish and keeps it in a
+// Executes the command. If `wait` is true, waits for the process to finish and keeps it in a
 // waitable state; otherwise, returns immediately after fork. When the current scope exits, destroys
 // the process.
-[[maybe_unused]] static std::pair<pid_t, ScopeGuard<std::function<void()>>> ScopedExec(
-    std::vector<std::string>& args, bool wait) {
+[[maybe_unused]] static std::pair<pid_t, std::unique_ptr<ScopeGuard<std::function<void()>>>>
+ScopedExec(std::vector<std::string>& args, bool wait) {
   std::vector<char*> execv_args;
   execv_args.reserve(args.size() + 1);
   for (std::string& arg : args) {
@@ -65,6 +73,7 @@ using ::android::base::ScopeGuard;
   pid_t pid = fork();
   if (pid == 0) {
     execv(execv_args[0], execv_args.data());
+    PLOG(FATAL) << "Failed to call execv";
     UNREACHABLE();
   } else if (pid > 0) {
     if (wait) {
@@ -80,9 +89,11 @@ using ::android::base::ScopeGuard;
       }
       CHECK_EQ(TEMP_FAILURE_RETRY(waitid(P_PID, pid, &info, WEXITED)), 0);
     });
-    return std::make_pair(pid, make_scope_guard(std::move(cleanup)));
+    return std::make_pair(
+        pid,
+        std::make_unique<ScopeGuard<std::function<void()>>>(make_scope_guard(std::move(cleanup))));
   } else {
-    LOG(FATAL) << "Failed to call fork";
+    PLOG(FATAL) << "Failed to call fork";
     UNREACHABLE();
   }
 }
@@ -90,4 +101,4 @@ using ::android::base::ScopeGuard;
 }  // namespace tools
 }  // namespace art
 
-#endif  // ART_LIBARTTOOLS_TESTING_H_
+#endif  // ART_LIBARTTOOLS_INCLUDE_TESTING_TOOLS_TESTING_H_
diff --git a/libarttools/tools_test.cc b/libarttools/tools_test.cc
index 6853b47a2b..ad1a6a333c 100644
--- a/libarttools/tools_test.cc
+++ b/libarttools/tools_test.cc
@@ -30,7 +30,7 @@
 #include "base/time_utils.h"
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
-#include "testing.h"
+#include "tools/testing.h"
 
 namespace art {
 namespace tools {
diff --git a/libdexfile/Android.bp b/libdexfile/Android.bp
index b9320b7dae..69d51b6c01 100644
--- a/libdexfile/Android.bp
+++ b/libdexfile/Android.bp
@@ -270,11 +270,6 @@ art_cc_library {
     },
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into the following APEXes, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and libartd and libprofiled depend on this.
-        "com.android.art",
-        "test_broken_com.android.art",
     ],
 
     // libdexfiled.so implements the libdexfile.so API in com.android.art.debug.
@@ -309,7 +304,7 @@ art_cc_defaults {
         "dex/type_lookup_table_test.cc",
         "dex/utf_test.cc",
     ],
-    data: [
+    device_common_data: [
         ":art-gtest-jars-GetMethodSignature",
         ":art-gtest-jars-Lookup",
         ":art-gtest-jars-Main",
@@ -418,7 +413,6 @@ art_cc_test {
     // For backed-by API coverage.
     test_suites: [
         "cts",
-        "mcts-art",
     ],
 }
 
diff --git a/libdexfile/dex/descriptors_names.cc b/libdexfile/dex/descriptors_names.cc
index 2b68b27506..f382641d72 100644
--- a/libdexfile/dex/descriptors_names.cc
+++ b/libdexfile/dex/descriptors_names.cc
@@ -38,57 +38,53 @@ void AppendPrettyDescriptor(const char* descriptor, std::string* result) {
   }
 
   // Reference or primitive?
-  bool primitive = false;
   if (*c == 'L') {
     // "[[La/b/C;" -> "a.b.C[][]".
-    c++;  // Skip the 'L'.
+    std::string_view stripped = std::string_view(c + 1);  // Skip the 'L'...
+    if (stripped.ends_with(';')) {
+      stripped.remove_suffix(1u);  // ...and remove the semicolon.
+    }
+    // At this point, `stripped` is of the form "fully/qualified/Type".
+    // Append it to the `*result` and replace all '/'s with '.' in place.
+    size_t old_size = result->size();
+    *result += stripped;
+    std::replace(result->begin() + old_size, result->end(), '/', '.');
   } else {
-    primitive = true;
     // "[[B" -> "byte[][]".
+    std::string_view pretty_primitive;
     switch (*c) {
       case 'B':
-        c = "byte";
+        pretty_primitive = "byte";
         break;
       case 'C':
-        c = "char";
+        pretty_primitive = "char";
         break;
       case 'D':
-        c = "double";
+        pretty_primitive = "double";
         break;
       case 'F':
-        c = "float";
+        pretty_primitive = "float";
         break;
       case 'I':
-        c = "int";
+        pretty_primitive = "int";
         break;
       case 'J':
-        c = "long";
+        pretty_primitive = "long";
         break;
       case 'S':
-        c = "short";
+        pretty_primitive = "short";
         break;
       case 'Z':
-        c = "boolean";
+        pretty_primitive = "boolean";
         break;
       case 'V':
-        c = "void";
+        pretty_primitive = "void";
         break;  // Used when decoding return types.
       default: result->append(descriptor); return;
     }
+    result->append(pretty_primitive);
   }
 
-  // At this point, 'c' is a string of the form "fully/qualified/Type;" or
-  // "primitive". In the former case, rewrite the type with '.' instead of '/':
-  std::string temp(c);
-  if (!primitive) {
-    std::replace(temp.begin(), temp.end(), '/', '.');
-    // ...and remove the semicolon:
-    if (temp.back() == ';') {
-      temp.pop_back();
-    }
-  }
-  result->append(temp);
-
   // Finally, add 'dim' "[]" pairs:
   for (size_t i = 0; i < dim; ++i) {
     result->append("[]");
diff --git a/libdexfile/dex/dex_file-inl.h b/libdexfile/dex/dex_file-inl.h
index ad6c8c31ba..a6ea97d705 100644
--- a/libdexfile/dex/dex_file-inl.h
+++ b/libdexfile/dex/dex_file-inl.h
@@ -46,12 +46,15 @@ inline int DexFile::CompareMemberNames(std::string_view lhs, std::string_view rh
   return lhs.compare(rhs);
 }
 
+inline size_t DexFile::Utf8Length(const char* utf8_data, size_t utf16_length) {
+  return LIKELY(utf8_data[utf16_length] == 0)  // Is ASCII?
+             ? utf16_length
+             : utf16_length + strlen(utf8_data + utf16_length);
+}
+
 inline std::string_view DexFile::StringViewFromUtf16Length(const char* utf8_data,
                                                            size_t utf16_length) {
-  size_t utf8_length = LIKELY(utf8_data[utf16_length] == 0)  // Is ASCII?
-                           ? utf16_length
-                           : utf16_length + strlen(utf8_data + utf16_length);
-  return std::string_view(utf8_data, utf8_length);
+  return std::string_view(utf8_data, Utf8Length(utf8_data, utf16_length));
 }
 
 ALWAYS_INLINE
diff --git a/libdexfile/dex/dex_file.cc b/libdexfile/dex/dex_file.cc
index 2b68cfad0d..f30d39f30a 100644
--- a/libdexfile/dex/dex_file.cc
+++ b/libdexfile/dex/dex_file.cc
@@ -692,7 +692,7 @@ std::string DexFile::PrettyField(uint32_t field_idx, bool with_type) const {
   const FieldId& field_id = GetFieldId(field_idx);
   std::string result;
   if (with_type) {
-    result += GetFieldTypeDescriptor(field_id);
+    AppendPrettyDescriptor(GetFieldTypeDescriptor(field_id), &result);
     result += ' ';
   }
   AppendPrettyDescriptor(GetFieldDeclaringClassDescriptor(field_id), &result);
diff --git a/libdexfile/dex/dex_file.h b/libdexfile/dex/dex_file.h
index 6c41849616..619ee0d4f5 100644
--- a/libdexfile/dex/dex_file.h
+++ b/libdexfile/dex/dex_file.h
@@ -911,6 +911,7 @@ class DexFile {
   static int CompareDescriptors(std::string_view lhs, std::string_view rhs);
   static int CompareMemberNames(std::string_view lhs, std::string_view rhs);
 
+  static size_t Utf8Length(const char* utf8_data, size_t utf16_length);
   static std::string_view StringViewFromUtf16Length(const char* utf8_data, size_t utf16_length);
 
  protected:
diff --git a/libdexfile/dex/dex_instruction-inl.h b/libdexfile/dex/dex_instruction-inl.h
index a1e72677d8..5613ec5626 100644
--- a/libdexfile/dex/dex_instruction-inl.h
+++ b/libdexfile/dex/dex_instruction-inl.h
@@ -532,7 +532,12 @@ inline bool Instruction::HasVRegH() const {
 }
 
 inline int32_t Instruction::VRegH() const {
-  switch (FormatOf(Opcode())) {
+  return VRegH(FormatOf(Opcode()));
+}
+
+inline int32_t Instruction::VRegH(Format format) const {
+  DCHECK_EQ(format, FormatOf(Opcode()));
+  switch (format) {
     case k45cc: return VRegH_45cc();
     case k4rcc: return VRegH_4rcc();
     default :
diff --git a/libdexfile/dex/dex_instruction.cc b/libdexfile/dex/dex_instruction.cc
index c1bc34b602..67147bba11 100644
--- a/libdexfile/dex/dex_instruction.cc
+++ b/libdexfile/dex/dex_instruction.cc
@@ -24,6 +24,7 @@
 #include "android-base/stringprintf.h"
 
 #include "dex_file-inl.h"
+#include "dex_instruction_list.h"
 #include "utf.h"
 
 namespace art {
@@ -32,47 +33,12 @@ using android::base::StringPrintf;
 
 const char* const Instruction::kInstructionNames[] = {
 #define INSTRUCTION_NAME(o, c, pname, f, i, a, e, v) pname,
-#include "dex_instruction_list.h"
   DEX_INSTRUCTION_LIST(INSTRUCTION_NAME)
-#undef DEX_INSTRUCTION_LIST
 #undef INSTRUCTION_NAME
 };
 
 static_assert(sizeof(Instruction::InstructionDescriptor) == 8u, "Unexpected descriptor size");
 
-static constexpr int8_t InstructionSizeInCodeUnitsByOpcode(Instruction::Code opcode,
-                                                           Instruction::Format format) {
-  if (opcode == Instruction::Code::NOP) {
-    return -1;
-  } else if ((format >= Instruction::Format::k10x) && (format <= Instruction::Format::k10t)) {
-    return 1;
-  } else if ((format >= Instruction::Format::k20t) && (format <= Instruction::Format::k22c)) {
-    return 2;
-  } else if ((format >= Instruction::Format::k32x) && (format <= Instruction::Format::k3rc)) {
-    return 3;
-  } else if ((format >= Instruction::Format::k45cc) && (format <= Instruction::Format::k4rcc)) {
-    return 4;
-  } else if (format == Instruction::Format::k51l) {
-    return 5;
-  } else {
-    return -1;
-  }
-}
-
-Instruction::InstructionDescriptor const Instruction::kInstructionDescriptors[] = {
-#define INSTRUCTION_DESCR(opcode, c, p, format, index, flags, eflags, vflags) \
-    { vflags, \
-      format, \
-      index, \
-      flags, \
-      InstructionSizeInCodeUnitsByOpcode((c), (format)), \
-    },
-#include "dex_instruction_list.h"
-  DEX_INSTRUCTION_LIST(INSTRUCTION_DESCR)
-#undef DEX_INSTRUCTION_LIST
-#undef INSTRUCTION_DESCR
-};
-
 int32_t Instruction::GetTargetOffset() const {
   switch (FormatOf(Opcode())) {
     // Cases for conditional branches follow.
@@ -490,26 +456,20 @@ struct InstructionStaticAsserts : private Instruction {
     static_assert(IMPLIES((f) == k35c || (f) == k45cc, \
                           ((v) & (kVerifyVarArg | kVerifyVarArgNonZero)) != 0), \
                   "Missing var-arg verification");
-  #include "dex_instruction_list.h"
     DEX_INSTRUCTION_LIST(VAR_ARGS_CHECK)
-  #undef DEX_INSTRUCTION_LIST
   #undef VAR_ARGS_CHECK
 
   #define VAR_ARGS_RANGE_CHECK(o, c, pname, f, i, a, e, v) \
     static_assert(IMPLIES((f) == k3rc || (f) == k4rcc, \
                           ((v) & (kVerifyVarArgRange | kVerifyVarArgRangeNonZero)) != 0), \
                   "Missing var-arg verification");
-  #include "dex_instruction_list.h"
     DEX_INSTRUCTION_LIST(VAR_ARGS_RANGE_CHECK)
-  #undef DEX_INSTRUCTION_LIST
   #undef VAR_ARGS_RANGE_CHECK
 
   #define EXPERIMENTAL_CHECK(o, c, pname, f, i, a, e, v) \
     static_assert(kHaveExperimentalInstructions || (((a) & kExperimental) == 0), \
                   "Unexpected experimental instruction.");
-    #include "dex_instruction_list.h"
   DEX_INSTRUCTION_LIST(EXPERIMENTAL_CHECK)
-  #undef DEX_INSTRUCTION_LIST
   #undef EXPERIMENTAL_CHECK
 };
 
diff --git a/libdexfile/dex/dex_instruction.h b/libdexfile/dex/dex_instruction.h
index ff6fcf7bd4..0f12f45acd 100644
--- a/libdexfile/dex/dex_instruction.h
+++ b/libdexfile/dex/dex_instruction.h
@@ -21,6 +21,7 @@
 
 #include "base/globals.h"
 #include "base/macros.h"
+#include "dex_instruction_list.h"
 
 using uint4_t = uint8_t;
 using int4_t = int8_t;
@@ -29,9 +30,8 @@ namespace art {
 
 class DexFile;
 
-enum {
-  kNumPackedOpcodes = 0x100
-};
+// The number of Dalvik opcodes.
+static constexpr size_t kNumPackedOpcodes = 0x100;
 
 class Instruction {
  public:
@@ -82,9 +82,7 @@ class Instruction {
 
   enum Code {  // private marker to avoid generate-operator-out.py from processing.
 #define INSTRUCTION_ENUM(opcode, cname, p, f, i, a, e, v) cname = (opcode),
-#include "dex_instruction_list.h"
     DEX_INSTRUCTION_LIST(INSTRUCTION_ENUM)
-#undef DEX_INSTRUCTION_LIST
 #undef INSTRUCTION_ENUM
     RSUB_INT_LIT16 = RSUB_INT,
   };
@@ -133,8 +131,6 @@ class Instruction {
     kIndexStringRef,          // string reference index
     kIndexMethodRef,          // method reference index
     kIndexFieldRef,           // field reference index
-    kIndexFieldOffset,        // field offset (for static linked fields)
-    kIndexVtableOffset,       // vtable offset (for static linked methods)
     kIndexMethodAndProtoRef,  // method and a proto reference index (for invoke-polymorphic)
     kIndexCallSiteRef,        // call site reference index
     kIndexMethodHandleRef,    // constant method handle reference index
@@ -196,12 +192,11 @@ class Instruction {
     kVerifyVarArgNonZero      = 0x0040000,
     kVerifyVarArgRange        = 0x0080000,
     kVerifyVarArgRangeNonZero = 0x0100000,
-    kVerifyRuntimeOnly        = 0x0200000,
-    kVerifyError              = 0x0400000,
-    kVerifyRegHPrototype      = 0x0800000,
-    kVerifyRegBCallSite       = 0x1000000,
-    kVerifyRegBMethodHandle   = 0x2000000,
-    kVerifyRegBPrototype      = 0x4000000,
+    kVerifyError              = 0x0200000,
+    kVerifyRegHPrototype      = 0x0400000,
+    kVerifyRegBCallSite       = 0x0800000,
+    kVerifyRegBMethodHandle   = 0x1000000,
+    kVerifyRegBPrototype      = 0x2000000,
   };
 
   // Collect the enums in a struct for better locality.
@@ -219,7 +214,7 @@ class Instruction {
 
   // Returns the size (in 2 byte code units) of this instruction.
   size_t SizeInCodeUnits() const {
-    int8_t result = kInstructionDescriptors[Opcode()].size_in_code_units;
+    int8_t result = InstructionDescriptorOf(Opcode()).size_in_code_units;
     if (UNLIKELY(result < 0)) {
       return SizeInCodeUnitsComplexOpcode();
     } else {
@@ -232,7 +227,7 @@ class Instruction {
 
   // Code units required to calculate the size of the instruction.
   size_t CodeUnitsRequiredForSizeComputation() const {
-    const int8_t result = kInstructionDescriptors[Opcode()].size_in_code_units;
+    const int8_t result = InstructionDescriptorOf(Opcode()).size_in_code_units;
     return UNLIKELY(result < 0) ? CodeUnitsRequiredForSizeOfComplexOpcode() : 1;
   }
 
@@ -464,6 +459,7 @@ class Instruction {
   // VRegH
   bool HasVRegH() const;
   int32_t VRegH() const;
+  ALWAYS_INLINE int32_t VRegH(Format format) const;
   uint16_t VRegH_45cc() const;
   uint16_t VRegH_4rcc() const;
 
@@ -529,33 +525,33 @@ class Instruction {
   }
 
   // Returns the format of the given opcode.
-  static Format FormatOf(Code opcode) {
-    return kInstructionDescriptors[opcode].format;
+  static constexpr Format FormatOf(Code opcode) {
+    return InstructionDescriptorOf(opcode).format;
   }
 
   // Returns the index type of the given opcode.
-  static IndexType IndexTypeOf(Code opcode) {
-    return kInstructionDescriptors[opcode].index_type;
+  static constexpr IndexType IndexTypeOf(Code opcode) {
+    return InstructionDescriptorOf(opcode).index_type;
   }
 
   // Returns the flags for the given opcode.
-  static uint8_t FlagsOf(Code opcode) {
-    return kInstructionDescriptors[opcode].flags;
+  static constexpr uint8_t FlagsOf(Code opcode) {
+    return InstructionDescriptorOf(opcode).flags;
   }
 
   // Return the verify flags for the given opcode.
-  static uint32_t VerifyFlagsOf(Code opcode) {
-    return kInstructionDescriptors[opcode].verify_flags;
+  static constexpr uint32_t VerifyFlagsOf(Code opcode) {
+    return InstructionDescriptorOf(opcode).verify_flags;
   }
 
   // Returns true if this instruction is a branch.
   bool IsBranch() const {
-    return (kInstructionDescriptors[Opcode()].flags & kBranch) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kBranch) != 0;
   }
 
   // Returns true if this instruction is a unconditional branch.
   bool IsUnconditional() const {
-    return (kInstructionDescriptors[Opcode()].flags & kUnconditional) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kUnconditional) != 0;
   }
 
   // Returns the branch offset if this instruction is a branch.
@@ -564,25 +560,22 @@ class Instruction {
   // Returns true if the instruction allows control flow to go to the following instruction.
   bool CanFlowThrough() const;
 
-  // Returns true if the instruction is a quickened instruction.
-  bool IsQuickened() const {
-    return (kInstructionDescriptors[Opcode()].index_type == kIndexFieldOffset) ||
-        (kInstructionDescriptors[Opcode()].index_type == kIndexVtableOffset);
-  }
-
   // Returns true if this instruction is a switch.
   bool IsSwitch() const {
-    return (kInstructionDescriptors[Opcode()].flags & kSwitch) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kSwitch) != 0;
   }
 
   // Returns true if this instruction can throw.
   bool IsThrow() const {
-    return (kInstructionDescriptors[Opcode()].flags & kThrow) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kThrow) != 0;
   }
 
   // Determine if the instruction is any of 'return' instructions.
+  static constexpr bool IsReturn(Code opcode) {
+    return (InstructionDescriptorOf(opcode).flags & kReturn) != 0;
+  }
   bool IsReturn() const {
-    return (kInstructionDescriptors[Opcode()].flags & kReturn) != 0;
+    return IsReturn(Opcode());
   }
 
   // Determine if this instruction ends execution of its basic block.
@@ -592,41 +585,73 @@ class Instruction {
 
   // Determine if this instruction is an invoke.
   bool IsInvoke() const {
-    return (kInstructionDescriptors[Opcode()].flags & kInvoke) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kInvoke) != 0;
   }
 
   // Determine if this instruction is experimental.
   bool IsExperimental() const {
-    return (kInstructionDescriptors[Opcode()].flags & kExperimental) != 0;
+    return (InstructionDescriptorOf(Opcode()).flags & kExperimental) != 0;
+  }
+
+  static constexpr uint32_t GetVerifyTypeArgumentAOf(Code opcode) {
+    constexpr uint32_t kMask = kVerifyRegA | kVerifyRegAWide;
+    return VerifyFlagsOf(opcode) & kMask;
+  }
+
+  uint32_t GetVerifyTypeArgumentA() const {
+    return GetVerifyTypeArgumentAOf(Opcode());
+  }
+
+  static constexpr uint32_t GetVerifyTypeArgumentBOf(Code opcode) {
+    constexpr uint32_t kMask =
+        kVerifyRegB |
+        kVerifyRegBField |
+        kVerifyRegBMethod |
+        kVerifyRegBNewInstance |
+        kVerifyRegBString |
+        kVerifyRegBType |
+        kVerifyRegBWide;
+    return VerifyFlagsOf(opcode) & kMask;
+  }
+
+  uint32_t GetVerifyTypeArgumentB() const {
+    return GetVerifyTypeArgumentBOf(Opcode());
   }
 
-  int GetVerifyTypeArgumentA() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & (kVerifyRegA | kVerifyRegAWide));
+  static constexpr uint32_t GetVerifyTypeArgumentCOf(Code opcode) {
+    constexpr uint32_t kMask =
+        kVerifyRegC | kVerifyRegCField | kVerifyRegCNewArray | kVerifyRegCType | kVerifyRegCWide;
+    return VerifyFlagsOf(opcode) & kMask;
   }
 
-  int GetVerifyTypeArgumentB() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & (kVerifyRegB | kVerifyRegBField |
-        kVerifyRegBMethod | kVerifyRegBNewInstance | kVerifyRegBString | kVerifyRegBType |
-        kVerifyRegBWide));
+  uint32_t GetVerifyTypeArgumentC() const {
+    return GetVerifyTypeArgumentCOf(Opcode());
   }
 
-  int GetVerifyTypeArgumentC() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & (kVerifyRegC | kVerifyRegCField |
-        kVerifyRegCNewArray | kVerifyRegCType | kVerifyRegCWide));
+  static constexpr uint32_t GetVerifyTypeArgumentHOf(Code opcode) {
+    constexpr uint32_t kMask = kVerifyRegHPrototype;
+    return VerifyFlagsOf(opcode) & kMask;
   }
 
-  int GetVerifyTypeArgumentH() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & kVerifyRegHPrototype);
+  uint32_t GetVerifyTypeArgumentH() const {
+    return GetVerifyTypeArgumentHOf(Opcode());
   }
 
-  int GetVerifyExtraFlags() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & (kVerifyArrayData |
-        kVerifyBranchTarget | kVerifySwitchTargets | kVerifyVarArg | kVerifyVarArgNonZero |
-        kVerifyVarArgRange | kVerifyVarArgRangeNonZero | kVerifyError));
+  static constexpr uint32_t GetVerifyExtraFlagsOf(Code opcode) {
+    constexpr uint32_t kMask =
+        kVerifyArrayData |
+        kVerifyBranchTarget |
+        kVerifySwitchTargets |
+        kVerifyVarArg |
+        kVerifyVarArgNonZero |
+        kVerifyVarArgRange |
+        kVerifyVarArgRangeNonZero |
+        kVerifyError;
+    return VerifyFlagsOf(opcode) & kMask;
   }
 
-  bool GetVerifyIsRuntimeOnly() const {
-    return (kInstructionDescriptors[Opcode()].verify_flags & kVerifyRuntimeOnly) != 0;
+  uint32_t GetVerifyExtraFlags() const {
+    return GetVerifyExtraFlagsOf(Opcode());
   }
 
   // Get the dex PC of this instruction as a offset in code units from the beginning of insns.
@@ -649,9 +674,13 @@ class Instruction {
     return insns[offset];
   }
 
- private:
   size_t SizeInCodeUnitsComplexOpcode() const;
 
+ private:
+  static constexpr const InstructionDescriptor& InstructionDescriptorOf(Code opcode) {
+    return kInstructionDescriptors[opcode];
+  }
+
   // Return how many code unit words are required to compute the size of the opcode.
   size_t CodeUnitsRequiredForSizeOfComplexOpcode() const;
 
@@ -688,7 +717,39 @@ class Instruction {
 
   static const char* const kInstructionNames[];
 
-  static const InstructionDescriptor kInstructionDescriptors[];
+  static constexpr std::array<InstructionDescriptor, 256> kInstructionDescriptors = []() constexpr {
+    auto InstructionSizeInCodeUnitsByOpcode = [](Instruction::Code opcode,
+                                                 Instruction::Format format) constexpr -> int8_t {
+      if (opcode == Instruction::Code::NOP) {
+        return -1;
+      } else if ((format >= Instruction::Format::k10x) && (format <= Instruction::Format::k10t)) {
+        return 1;
+      } else if ((format >= Instruction::Format::k20t) && (format <= Instruction::Format::k22c)) {
+        return 2;
+      } else if ((format >= Instruction::Format::k32x) && (format <= Instruction::Format::k3rc)) {
+        return 3;
+      } else if ((format >= Instruction::Format::k45cc) && (format <= Instruction::Format::k4rcc)) {
+        return 4;
+      } else if (format == Instruction::Format::k51l) {
+        return 5;
+      } else {
+        return -1;
+      }
+    };
+
+    std::array<InstructionDescriptor, 256> result;
+#define INSTRUCTION_DESCR(opcode, c, p, format, index, flags, eflags, vflags) \
+    result[opcode] = {                                                        \
+        vflags,                                                               \
+        format,                                                               \
+        index,                                                                \
+        flags,                                                                \
+        InstructionSizeInCodeUnitsByOpcode((c), (format)),                    \
+    };
+    DEX_INSTRUCTION_LIST(INSTRUCTION_DESCR)
+#undef INSTRUCTION_DESCR
+    return result;
+  }();
 
   DISALLOW_IMPLICIT_CONSTRUCTORS(Instruction);
 };
diff --git a/libdexfile/dex/dex_instruction_list.h b/libdexfile/dex/dex_instruction_list.h
index 9a01bfe5d3..0fd2a6b5bb 100644
--- a/libdexfile/dex/dex_instruction_list.h
+++ b/libdexfile/dex/dex_instruction_list.h
@@ -305,4 +305,3 @@
   V(k51l)
 
 #endif  // ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_
-#undef ART_LIBDEXFILE_DEX_DEX_INSTRUCTION_LIST_H_  // the guard in this file is just for cpplint
diff --git a/libdexfile/dex/modifiers.h b/libdexfile/dex/modifiers.h
index def4ce2b44..94e25e8e6e 100644
--- a/libdexfile/dex/modifiers.h
+++ b/libdexfile/dex/modifiers.h
@@ -74,7 +74,8 @@ static constexpr uint32_t kAccCopied =                0x01000000;  // method (ru
 static constexpr uint32_t kAccDefault =               0x00400000;  // method (runtime)
 // Native method flags are set when linking the methods based on the presence of the
 // @dalvik.annotation.optimization.{Fast,Critical}Native annotations with build visibility.
-// Reuse the values of kAccSkipAccessChecks and kAccMiranda which are not used for native methods.
+// Reuse the values of kAccSkipAccessChecks and kAccNterpEntryPointFastPathFlag which are not used
+// for native methods.
 static constexpr uint32_t kAccFastNative =            0x00080000;  // method (runtime; native only)
 static constexpr uint32_t kAccCriticalNative =        0x00100000;  // method (runtime; native only)
 
@@ -128,7 +129,7 @@ static constexpr uint32_t kAccHiddenapiBits = kAccPublicApi | kAccCorePlatformAp
 // which overlap are not valid when kAccIntrinsic is set.
 static constexpr uint32_t kAccIntrinsicBits = kAccHiddenapiBits |
     kAccSingleImplementation | kAccMustCountLocks | kAccCompileDontBother | kAccCopied |
-    kAccPreviouslyWarm | kAccMemorySharedMethod;
+    kAccPreviouslyWarm | kAccMemorySharedMethod | kAccDefault;
 
 // Valid (meaningful) bits for a field.
 static constexpr uint32_t kAccValidFieldFlags = kAccPublic | kAccPrivate | kAccProtected |
diff --git a/libdexfile/dex/test_dex_file_builder_test.cc b/libdexfile/dex/test_dex_file_builder_test.cc
index 9aeaded1ab..82f1b5d46b 100644
--- a/libdexfile/dex/test_dex_file_builder_test.cc
+++ b/libdexfile/dex/test_dex_file_builder_test.cc
@@ -67,7 +67,7 @@ TEST(TestDexFileBuilderTest, SimpleTest) {
   }
 
   ASSERT_EQ(1u, dex_file->NumFieldIds());
-  EXPECT_STREQ("[I TestClass.intField", dex_file->PrettyField(0u).c_str());
+  EXPECT_STREQ("int[] TestClass.intField", dex_file->PrettyField(0u).c_str());
 
   ASSERT_EQ(2u, dex_file->NumProtoIds());
   ASSERT_EQ(2u, dex_file->NumMethodIds());
diff --git a/libnativeloader/Android.bp b/libnativeloader/Android.bp
index 3718f1e3ed..69a45a1935 100644
--- a/libnativeloader/Android.bp
+++ b/libnativeloader/Android.bp
@@ -46,7 +46,7 @@ cc_defaults {
     ],
     export_header_lib_headers: ["libnativeloader-headers"],
     shared_libs: [
-        "libnativebridge",
+        "libnativebridge#impl",
     ],
     target: {
         android: {
@@ -159,10 +159,6 @@ art_cc_test {
         "native_loader_test.cpp",
     ],
 
-    test_for: [
-        "com.android.art",
-        "com.android.art.debug",
-    ],
     test_suites: [
         "general-tests",
         "mts-art",
diff --git a/libnativeloader/library_namespaces.cpp b/libnativeloader/library_namespaces.cpp
index 7aa14080ce..b27b268d16 100644
--- a/libnativeloader/library_namespaces.cpp
+++ b/libnativeloader/library_namespaces.cpp
@@ -432,10 +432,10 @@ Result<NativeLoaderNamespace*> LibraryNamespaces::Create(JNIEnv* env,
   const std::string product_libs =
       filter_public_libraries(target_sdk_version, uses_libraries, product_public_libraries());
   if (!product_libs.empty()) {
-    Result<NativeLoaderNamespace> target_ns = system_ns;
-    if (is_product_treblelized()) {
-      target_ns = NativeLoaderNamespace::GetExportedNamespace(kProductNamespaceName, is_bridged);
-    }
+    Result<NativeLoaderNamespace> target_ns =
+        is_product_treblelized()
+            ? NativeLoaderNamespace::GetExportedNamespace(kProductNamespaceName, is_bridged)
+            : system_ns;
     if (target_ns.ok()) {
       linked = app_ns->Link(&target_ns.value(), product_libs);
       if (!linked.ok()) {
diff --git a/libnativeloader/native_loader.cpp b/libnativeloader/native_loader.cpp
index 3d24c3da14..f37f661a3e 100644
--- a/libnativeloader/native_loader.cpp
+++ b/libnativeloader/native_loader.cpp
@@ -414,52 +414,46 @@ void* OpenNativeLibrary(JNIEnv* env,
     }
   }
 
-  std::lock_guard<std::mutex> guard(g_namespaces_mutex);
-
+  NativeLoaderNamespace* ns;
+  const char* ns_descr;
   {
-    NativeLoaderNamespace* ns = g_namespaces->FindNamespaceByClassLoader(env, class_loader);
-    if (ns != nullptr) {
-      *needs_native_bridge = ns->IsBridged();
-      Result<void*> handle = ns->Load(path);
-      ALOGD("Load %s using ns %s from class loader (caller=%s): %s",
-            path,
-            ns->name().c_str(),
-            caller_location == nullptr ? "<unknown>" : caller_location,
-            handle.ok() ? "ok" : handle.error().message().c_str());
-      if (!handle.ok()) {
-        *error_msg = strdup(handle.error().message().c_str());
+    std::lock_guard<std::mutex> guard(g_namespaces_mutex);
+
+    ns = g_namespaces->FindNamespaceByClassLoader(env, class_loader);
+    ns_descr = "class loader";
+
+    if (ns == nullptr) {
+      // This is the case where the classloader was not created by ApplicationLoaders
+      // In this case we create an isolated not-shared namespace for it.
+      const std::string empty_dex_path;
+      Result<NativeLoaderNamespace*> res =
+          CreateClassLoaderNamespaceLocked(env,
+                                           target_sdk_version,
+                                           class_loader,
+                                           nativeloader::API_DOMAIN_DEFAULT,
+                                           /*is_shared=*/false,
+                                           empty_dex_path,
+                                           library_path_j,
+                                           /*permitted_path_j=*/nullptr,
+                                           /*uses_library_list_j=*/nullptr);
+      if (!res.ok()) {
+        ALOGD("Failed to create isolated ns for %s (caller=%s)",
+              path,
+              caller_location == nullptr ? "<unknown>" : caller_location);
+        *error_msg = strdup(res.error().message().c_str());
         return nullptr;
       }
-      return handle.value();
+      ns = res.value();
+      ns_descr = "isolated";
     }
   }
 
-  // This is the case where the classloader was not created by ApplicationLoaders
-  // In this case we create an isolated not-shared namespace for it.
-  const std::string empty_dex_path;
-  Result<NativeLoaderNamespace*> isolated_ns =
-      CreateClassLoaderNamespaceLocked(env,
-                                       target_sdk_version,
-                                       class_loader,
-                                       nativeloader::API_DOMAIN_DEFAULT,
-                                       /*is_shared=*/false,
-                                       empty_dex_path,
-                                       library_path_j,
-                                       /*permitted_path_j=*/nullptr,
-                                       /*uses_library_list_j=*/nullptr);
-  if (!isolated_ns.ok()) {
-    ALOGD("Failed to create isolated ns for %s (caller=%s)",
-          path,
-          caller_location == nullptr ? "<unknown>" : caller_location);
-    *error_msg = strdup(isolated_ns.error().message().c_str());
-    return nullptr;
-  }
-
-  *needs_native_bridge = isolated_ns.value()->IsBridged();
-  Result<void*> handle = isolated_ns.value()->Load(path);
-  ALOGD("Load %s using isolated ns %s (caller=%s): %s",
+  *needs_native_bridge = ns->IsBridged();
+  Result<void*> handle = ns->Load(path);
+  ALOGD("Load %s using %s ns %s (caller=%s): %s",
         path,
-        isolated_ns.value()->name().c_str(),
+        ns_descr,
+        ns->name().c_str(),
         caller_location == nullptr ? "<unknown>" : caller_location,
         handle.ok() ? "ok" : handle.error().message().c_str());
   if (!handle.ok()) {
diff --git a/libnativeloader/native_loader_namespace.cpp b/libnativeloader/native_loader_namespace.cpp
index cfb84b7d9e..98236064d0 100644
--- a/libnativeloader/native_loader_namespace.cpp
+++ b/libnativeloader/native_loader_namespace.cpp
@@ -69,10 +69,14 @@ Result<NativeLoaderNamespace> NativeLoaderNamespace::GetExportedNamespace(const
 // "system" for those in the Runtime APEX. Try "system" first since
 // "default" always exists.
 Result<NativeLoaderNamespace> NativeLoaderNamespace::GetSystemNamespace(bool is_bridged) {
-  Result<NativeLoaderNamespace> ns = GetExportedNamespace(kSystemNamespaceName, is_bridged);
-  if (ns.ok()) return ns;
-  ns = GetExportedNamespace(kDefaultNamespaceName, is_bridged);
-  if (ns.ok()) return ns;
+  if (Result<NativeLoaderNamespace> ns = GetExportedNamespace(kSystemNamespaceName, is_bridged);
+      ns.ok()) {
+    return ns;
+  }
+  if (Result<NativeLoaderNamespace> ns = GetExportedNamespace(kDefaultNamespaceName, is_bridged);
+      ns.ok()) {
+    return ns;
+  }
 
   // If nothing is found, return NativeLoaderNamespace constructed from nullptr.
   // nullptr also means default namespace to the linker.
diff --git a/libnativeloader/native_loader_namespace.h b/libnativeloader/native_loader_namespace.h
index 9a5aeac203..4d9ce36434 100644
--- a/libnativeloader/native_loader_namespace.h
+++ b/libnativeloader/native_loader_namespace.h
@@ -47,7 +47,6 @@ struct NativeLoaderNamespace {
 
   NativeLoaderNamespace(NativeLoaderNamespace&&) = default;
   NativeLoaderNamespace(const NativeLoaderNamespace&) = default;
-  NativeLoaderNamespace& operator=(const NativeLoaderNamespace&) = default;
 
   android_namespace_t* ToRawAndroidNamespace() const { return std::get<0>(raw_); }
   native_bridge_namespace_t* ToRawNativeBridgeNamespace() const { return std::get<1>(raw_); }
@@ -72,8 +71,8 @@ struct NativeLoaderNamespace {
   explicit NativeLoaderNamespace(const std::string& name, native_bridge_namespace_t* ns)
       : name_(name), raw_(ns) {}
 
-  std::string name_;
-  std::variant<android_namespace_t*, native_bridge_namespace_t*> raw_;
+  const std::string name_;
+  const std::variant<android_namespace_t*, native_bridge_namespace_t*> raw_;
 };
 
 }  // namespace android
diff --git a/libnativeloader/test/Android.bp b/libnativeloader/test/Android.bp
index 4396917a57..c656fd7477 100644
--- a/libnativeloader/test/Android.bp
+++ b/libnativeloader/test/Android.bp
@@ -191,7 +191,7 @@ java_test_host {
         "compatibility-tradefed",
         "tradefed",
     ],
-    data: [
+    device_common_data: [
         ":library_container_app",
         ":libnativeloader_system_shared_lib",
         ":libnativeloader_system_ext_shared_lib",
diff --git a/libnativeloader/test/src/android/test/hostside/LibnativeloaderTest.java b/libnativeloader/test/src/android/test/hostside/LibnativeloaderTest.java
index bcb4528ffe..e7207aedd7 100644
--- a/libnativeloader/test/src/android/test/hostside/LibnativeloaderTest.java
+++ b/libnativeloader/test/src/android/test/hostside/LibnativeloaderTest.java
@@ -359,6 +359,7 @@ public class LibnativeloaderTest extends BaseHostJUnit4Test {
             try (InputStream inStream = libApk.getInputStream(entry)) {
                 libraryTempFile = writeStreamToTempFile(libName, inStream);
             }
+            libraryTempFile.setReadOnly();
 
             destPath = destPath.replace("${LIB}", libDirName());
 
diff --git a/libprofile/Android.bp b/libprofile/Android.bp
index ced2166957..91c5cbc9fd 100644
--- a/libprofile/Android.bp
+++ b/libprofile/Android.bp
@@ -45,6 +45,7 @@ cc_defaults {
                 "libziparchive",
             ],
             export_shared_lib_headers: ["libbase"], // ART's macros.h depends on libbase's macros.h.
+            export_static_lib_headers: ["libmodules-utils-build"],
         },
         not_windows: {
             shared_libs: [
@@ -112,7 +113,7 @@ art_cc_library {
         android: {
             shared_libs: [
                 "libartbase",
-                "libdexfile",
+                "libdexfile#impl",
             ],
         },
         not_windows: {
@@ -149,7 +150,7 @@ art_cc_library {
         android: {
             shared_libs: [
                 "libartbased",
-                "libdexfiled",
+                "libdexfiled#impl",
             ],
         },
         not_windows: {
@@ -167,11 +168,6 @@ art_cc_library {
     },
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into com.android.art, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and libartd depends on this.
-        "com.android.art",
-        "test_broken_com.android.art",
     ],
 }
 
@@ -180,7 +176,7 @@ art_cc_library {
 // TODO: Remove CommonRuntimeTest dependency from these tests.
 art_cc_defaults {
     name: "art_libprofile_tests_defaults",
-    data: [
+    device_common_data: [
         ":art-gtest-jars-ManyMethods",
         ":art-gtest-jars-MultiDex",
         ":art-gtest-jars-ProfileTestMultiDex",
diff --git a/libprofile/profile/profile_compilation_info.cc b/libprofile/profile/profile_compilation_info.cc
index 799ad86919..160e27e15e 100644
--- a/libprofile/profile/profile_compilation_info.cc
+++ b/libprofile/profile/profile_compilation_info.cc
@@ -823,11 +823,13 @@ bool ProfileCompilationInfo::Load(const std::string& filename, bool clear_if_inv
   return false;
 }
 
-bool ProfileCompilationInfo::Save(const std::string& filename, uint64_t* bytes_written) {
+bool ProfileCompilationInfo::Save(const std::string& filename,
+                                  uint64_t* bytes_written,
+                                  bool flush) {
   ScopedTrace trace(__PRETTY_FUNCTION__);
 
 #ifndef ART_TARGET_ANDROID
-  return SaveFallback(filename, bytes_written);
+  return SaveFallback(filename, bytes_written, flush);
 #else
   // Prior to U, SELinux policy doesn't allow apps to create profile files.
   // Additionally, when installd is being used for dexopt, it acquires a flock when working on a
@@ -836,7 +838,7 @@ bool ProfileCompilationInfo::Save(const std::string& filename, uint64_t* bytes_w
   // partners. Therefore, we fall back to using a flock as well just to be safe.
   if (!android::modules::sdklevel::IsAtLeastU() ||
       !android::base::GetBoolProperty("dalvik.vm.useartservice", /*default_value=*/false)) {
-    return SaveFallback(filename, bytes_written);
+    return SaveFallback(filename, bytes_written, flush);
   }
 
   std::string tmp_filename = filename + ".XXXXXX.tmp";
@@ -855,7 +857,7 @@ bool ProfileCompilationInfo::Save(const std::string& filename, uint64_t* bytes_w
     }
   });
 
-  bool result = Save(fd.get());
+  bool result = Save(fd.get(), flush);
   if (!result) {
     VLOG(profiler) << "Failed to save profile info to temp profile file " << tmp_filename;
     return false;
@@ -871,6 +873,14 @@ bool ProfileCompilationInfo::Save(const std::string& filename, uint64_t* bytes_w
 
   remove_tmp_file.Disable();
 
+  if (flush) {
+    std::string dirname = android::base::Dirname(filename);
+    std::unique_ptr<File> dir(OS::OpenFileForReading(dirname.c_str()));
+    if (dir == nullptr || dir->Flush(/*flush_metadata=*/true) != 0) {
+      PLOG(WARNING) << "Failed to flush directory " << dirname;
+    }
+  }
+
   int64_t size = OS::GetFileSizeBytes(filename.c_str());
   if (size != -1) {
     VLOG(profiler) << "Successfully saved profile info to " << filename << " Size: " << size;
@@ -886,7 +896,9 @@ bool ProfileCompilationInfo::Save(const std::string& filename, uint64_t* bytes_w
 #endif
 }
 
-bool ProfileCompilationInfo::SaveFallback(const std::string& filename, uint64_t* bytes_written) {
+bool ProfileCompilationInfo::SaveFallback(const std::string& filename,
+                                          uint64_t* bytes_written,
+                                          bool flush) {
   std::string error;
 #ifdef _WIN32
   int flags = O_WRONLY | O_CREAT;
@@ -913,7 +925,16 @@ bool ProfileCompilationInfo::SaveFallback(const std::string& filename, uint64_t*
 
   // This doesn't need locking because we are trying to lock the file for exclusive
   // access and fail immediately if we can't.
-  bool result = Save(fd);
+  bool result = Save(fd, flush);
+
+  if (flush) {
+    std::string dirname = android::base::Dirname(filename);
+    std::unique_ptr<File> dir(OS::OpenFileForReading(dirname.c_str()));
+    if (dir == nullptr || dir->Flush(/*flush_metadata=*/true) != 0) {
+      PLOG(WARNING) << "Failed to flush directory " << dirname;
+    }
+  }
+
   if (result) {
     int64_t size = OS::GetFileSizeBytes(filename.c_str());
     if (size != -1) {
@@ -1002,7 +1023,7 @@ static bool WriteBuffer(int fd, const void* buffer, size_t byte_count) {
  * where `M` stands for special encodings indicating missing types (kIsMissingTypesEncoding)
  * or memamorphic call (kIsMegamorphicEncoding) which both imply `dex_map_size == 0`.
  **/
-bool ProfileCompilationInfo::Save(int fd) {
+bool ProfileCompilationInfo::Save(int fd, bool flush) {
   uint64_t start = NanoTime();
   ScopedTrace trace(__PRETTY_FUNCTION__);
   DCHECK_GE(fd, 0);
@@ -1180,6 +1201,16 @@ bool ProfileCompilationInfo::Save(int fd) {
     return false;
   }
 
+  if (flush) {
+    // We do not flush for non-Linux because `flush` is only used by the runtime and the runtime
+    // only supports Linux.
+#ifdef __linux__
+    if (fsync(fd) != 0) {
+      PLOG(WARNING) << "Failed to flush profile data";
+    }
+#endif
+  }
+
   uint64_t total_time = NanoTime() - start;
   VLOG(profiler) << "Compressed from "
                  << std::to_string(total_uncompressed_size)
diff --git a/libprofile/profile/profile_compilation_info.h b/libprofile/profile/profile_compilation_info.h
index f6b0105ff6..5df8c1b575 100644
--- a/libprofile/profile/profile_compilation_info.h
+++ b/libprofile/profile/profile_compilation_info.h
@@ -33,7 +33,7 @@
 #include "base/malloc_arena_pool.h"
 #include "base/mem_map.h"
 #include "base/safe_map.h"
-#include "dex/dex_file.h"
+#include "dex/dex_file-inl.h"
 #include "dex/dex_file_types.h"
 #include "dex/method_reference.h"
 #include "dex/type_reference.h"
@@ -474,13 +474,13 @@ class ProfileCompilationInfo {
   bool MergeWith(const std::string& filename);
 
   // Save the profile data to the given file descriptor.
-  bool Save(int fd);
+  bool Save(int fd, bool flush = false);
 
   // Save the current profile into the given file. Overwrites any existing data.
-  bool Save(const std::string& filename, uint64_t* bytes_written);
+  bool Save(const std::string& filename, uint64_t* bytes_written, bool flush = false);
 
   // A fallback implementation of `Save` that uses a flock.
-  bool SaveFallback(const std::string& filename, uint64_t* bytes_written);
+  bool SaveFallback(const std::string& filename, uint64_t* bytes_written, bool flush = false);
 
   // Return the number of dex files referenced in the profile.
   size_t GetNumberOfDexFiles() const {
@@ -674,13 +674,25 @@ class ProfileCompilationInfo {
   // Get type descriptor for a valid type index, whether a normal type index
   // referencing a `dex::TypeId` in the dex file, or an artificial type index
   // referencing an "extra descriptor".
-  const char* GetTypeDescriptor(const DexFile* dex_file, dex::TypeIndex type_index) const {
+  const char* GetTypeDescriptor(const DexFile* dex_file,
+                                dex::TypeIndex type_index,
+                                /*out*/ size_t* utf8_length = nullptr) const {
     DCHECK(type_index.IsValid());
     uint32_t num_type_ids = dex_file->NumTypeIds();
     if (type_index.index_ < num_type_ids) {
-      return dex_file->GetTypeDescriptor(type_index);
+      uint32_t utf16_length;
+      const char* descriptor = dex_file->GetStringDataAndUtf16Length(
+          dex_file->GetTypeId(type_index).descriptor_idx_, &utf16_length);
+      if (utf8_length != nullptr) {
+        *utf8_length = DexFile::Utf8Length(descriptor, utf16_length);
+      }
+      return descriptor;
     } else {
-      return extra_descriptors_[type_index.index_ - num_type_ids].c_str();
+      const std::string& descriptor = extra_descriptors_[type_index.index_ - num_type_ids];
+      if (utf8_length != nullptr) {
+        *utf8_length = descriptor.length();
+      }
+      return descriptor.c_str();
     }
   }
 
diff --git a/oatdump/Android.bp b/oatdump/Android.bp
index ea224bf49f..066ad1b17b 100644
--- a/oatdump/Android.bp
+++ b/oatdump/Android.bp
@@ -64,7 +64,7 @@ art_cc_binary {
                 "libart-disassembler",
                 "libartbase",
                 "libbase",
-                "libdexfile",
+                "libdexfile#impl",
                 "libprofile",
             ],
             static_libs: [
@@ -118,7 +118,7 @@ art_cc_binary {
                 "libartd",
                 "libartd-disassembler",
                 "libbase",
-                "libdexfiled",
+                "libdexfiled#impl",
                 "libprofiled",
             ],
             static_libs: [
@@ -193,7 +193,7 @@ art_cc_binary {
 
 art_cc_defaults {
     name: "art_oatdump_tests_defaults",
-    data: [
+    device_common_data: [
         ":art-gtest-jars-ProfileTestMultiDex",
     ],
     srcs: [
@@ -207,6 +207,7 @@ art_cc_defaults {
                 "dex2oatd",
                 "dex2oatds",
                 "dexdump",
+                "art_boot_images",
                 "oatdumpd",
                 "oatdumpds",
             ],
diff --git a/oatdump/oatdump.cc b/oatdump/oatdump.cc
index 150bdae416..feba70ff3a 100644
--- a/oatdump/oatdump.cc
+++ b/oatdump/oatdump.cc
@@ -1180,14 +1180,14 @@ class OatDumper {
       hs.reset(new StackHandleScope<1>(Thread::Current()));
       vios->Stream() << "VERIFIER TYPE ANALYSIS:\n";
       ScopedIndentation indent2(vios);
-      verifier.reset(DumpVerifier(vios,
-                                  soa,
-                                  hs.get(),
-                                  dex_method_idx,
-                                  &dex_file,
-                                  class_def,
-                                  code_item,
-                                  method_access_flags));
+      DumpVerifier(vios,
+                   soa,
+                   hs.get(),
+                   dex_method_idx,
+                   &dex_file,
+                   class_def,
+                   code_item,
+                   method_access_flags);
     }
     {
       vios->Stream() << "OatMethodOffsets ";
@@ -1493,14 +1493,14 @@ class OatDumper {
            code_item_accessor.HasCodeItem();
   }
 
-  verifier::MethodVerifier* DumpVerifier(VariableIndentationOutputStream* vios,
-                                         ScopedObjectAccess& soa,
-                                         StackHandleScope<1>* hs,
-                                         uint32_t dex_method_idx,
-                                         const DexFile* dex_file,
-                                         const dex::ClassDef& class_def,
-                                         const dex::CodeItem* code_item,
-                                         uint32_t method_access_flags)
+  void DumpVerifier(VariableIndentationOutputStream* vios,
+                    ScopedObjectAccess& soa,
+                    StackHandleScope<1>* hs,
+                    uint32_t dex_method_idx,
+                    const DexFile* dex_file,
+                    const dex::ClassDef& class_def,
+                    const dex::CodeItem* code_item,
+                    uint32_t method_access_flags)
       REQUIRES_SHARED(Locks::mutator_lock_) {
     if ((method_access_flags & kAccNative) == 0) {
       Runtime* const runtime = Runtime::Current();
@@ -1508,13 +1508,13 @@ class OatDumper {
       Handle<mirror::DexCache> dex_cache = hs->NewHandle(
           runtime->GetClassLinker()->RegisterDexFile(*dex_file, options_.class_loader_->Get()));
       CHECK(dex_cache != nullptr);
-      ArtMethod* method = runtime->GetClassLinker()->ResolveMethodWithoutInvokeType(
+      ArtMethod* method = runtime->GetClassLinker()->ResolveMethodId(
           dex_method_idx, dex_cache, *options_.class_loader_);
       if (method == nullptr) {
         soa.Self()->ClearException();
-        return nullptr;
+        return;
       }
-      return verifier::MethodVerifier::VerifyMethodAndDump(
+      verifier::MethodVerifier::VerifyMethodAndDump(
           soa.Self(),
           vios,
           dex_method_idx,
@@ -1526,8 +1526,6 @@ class OatDumper {
           method_access_flags,
           /* api_level= */ 0);
     }
-
-    return nullptr;
   }
 
   void DumpCode(VariableIndentationOutputStream* vios,
@@ -2544,7 +2542,6 @@ static int DumpImages(Runtime* runtime, OatDumperOptions* options, std::ostream*
   ScopedNullHandle<mirror::ClassLoader> null_class_loader;
   options->class_loader_ = &null_class_loader;
 
-  ScopedObjectAccess soa(Thread::Current());
   if (options->app_image_ != nullptr) {
     if (!options->oat_filename_.has_value()) {
       LOG(ERROR) << "Can not dump app image without app oat file";
@@ -2569,6 +2566,7 @@ static int DumpImages(Runtime* runtime, OatDumperOptions* options, std::ostream*
       return EXIT_FAILURE;
     }
     // Open dex files for the image.
+    ScopedObjectAccess soa(Thread::Current());
     std::vector<std::unique_ptr<const DexFile>> dex_files;
     if (!runtime->GetClassLinker()->OpenImageDexFiles(space.get(), &dex_files, &error_msg)) {
       LOG(ERROR) << "Failed to open app image dex files " << options->app_image_ << " with error "
@@ -2584,6 +2582,7 @@ static int DumpImages(Runtime* runtime, OatDumperOptions* options, std::ostream*
     LOG(ERROR) << "No image spaces";
     return EXIT_FAILURE;
   }
+  ScopedObjectAccess soa(Thread::Current());
   for (gc::space::ImageSpace* image_space : heap->GetBootImageSpaces()) {
     int result = DumpImage(image_space, options, os);
     if (result != EXIT_SUCCESS) {
@@ -2804,10 +2803,11 @@ class IMTDumper {
            class_def_index != dex_file->NumClassDefs();
            ++class_def_index) {
         const dex::ClassDef& class_def = dex_file->GetClassDef(class_def_index);
-        const char* descriptor = dex_file->GetClassDescriptor(class_def);
-        h_klass.Assign(class_linker->FindClass(self, descriptor, h_class_loader));
+        h_klass.Assign(
+            class_linker->FindClass(self, *dex_file, class_def.class_idx_, h_class_loader));
         if (h_klass == nullptr) {
-          std::cerr << "Warning: could not load " << descriptor << std::endl;
+          std::cerr << "Warning: could not load "
+                    << dex_file->GetTypeDescriptor(class_def.class_idx_) << std::endl;
           continue;
         }
 
@@ -2930,8 +2930,8 @@ class IMTDumper {
       descriptor = DotToDescriptor(class_name.c_str());
     }
 
-    ObjPtr<mirror::Class> klass =
-        runtime->GetClassLinker()->FindClass(self, descriptor.c_str(), h_loader);
+    ObjPtr<mirror::Class> klass = runtime->GetClassLinker()->FindClass(
+        self, descriptor.c_str(), descriptor.length(), h_loader);
 
     if (klass == nullptr) {
       self->ClearException();
diff --git a/odrefresh/Android.bp b/odrefresh/Android.bp
index 53e5f90fa6..530a714dec 100644
--- a/odrefresh/Android.bp
+++ b/odrefresh/Android.bp
@@ -74,7 +74,7 @@ cc_defaults {
     shared_libs: [
         "libarttools",
         "libbase",
-        "libdexfile",
+        "libdexfile#impl",
         "libselinux",
     ],
 }
@@ -169,11 +169,6 @@ art_cc_binary {
     ],
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This binary doesn't go into com.android.art, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and this depends on libartd.
-        "com.android.art",
-        "test_broken_com.android.art",
     ],
 }
 
diff --git a/odrefresh/odr_artifacts.h b/odrefresh/odr_artifacts.h
index 9b2e9731e7..1bed631f3b 100644
--- a/odrefresh/odr_artifacts.h
+++ b/odrefresh/odr_artifacts.h
@@ -20,7 +20,7 @@
 #include <iosfwd>
 #include <string>
 
-#include <base/file_utils.h>
+#include "base/file_utils.h"
 
 namespace art {
 namespace odrefresh {
@@ -29,11 +29,11 @@ namespace odrefresh {
 class OdrArtifacts {
  public:
   static OdrArtifacts ForBootImage(const std::string& image_path) {
-    return OdrArtifacts(image_path, /*image_kind=*/"image", /*aot_extension=*/"oat");
+    return OdrArtifacts(image_path, /*image_kind=*/"image", /*aot_extension=*/kOatExtension);
   }
 
   static OdrArtifacts ForSystemServer(const std::string& image_path) {
-    return OdrArtifacts(image_path, /*image_kind=*/"app-image", /*aot_extension=*/"odex");
+    return OdrArtifacts(image_path, /*image_kind=*/"app-image", /*aot_extension=*/kOdexExtension);
   }
 
   const std::string& ImagePath() const { return image_path_; }
@@ -46,7 +46,7 @@ class OdrArtifacts {
       : image_path_{image_path},
         image_kind_{image_kind},
         oat_path_{ReplaceFileExtension(image_path, aot_extension)},
-        vdex_path_{ReplaceFileExtension(image_path, "vdex")} {}
+        vdex_path_{ReplaceFileExtension(image_path, kVdexExtension)} {}
 
   OdrArtifacts() = delete;
   OdrArtifacts(const OdrArtifacts&) = delete;
diff --git a/odrefresh/odrefresh.cc b/odrefresh/odrefresh.cc
index f0b8b44d23..bf3d62d0d0 100644
--- a/odrefresh/odrefresh.cc
+++ b/odrefresh/odrefresh.cc
@@ -526,7 +526,7 @@ std::string GetBootImageComponentBasename(const std::string& jar_path, bool is_f
     return kFirstBootImageBasename;
   }
   std::string jar_name = Basename(jar_path);
-  return "boot-" + ReplaceFileExtension(jar_name, "art");
+  return "boot-" + ReplaceFileExtension(jar_name, kArtExtension);
 }
 
 Result<void> AddCompiledBootClasspathFdsIfAny(
@@ -566,7 +566,7 @@ Result<void> AddCompiledBootClasspathFdsIfAny(
       return ErrnoErrorf("Failed to open boot image file '{}'", image_path);
     }
 
-    std::string oat_path = ReplaceFileExtension(image_path, "oat");
+    std::string oat_path = ReplaceFileExtension(image_path, kOatExtension);
     std::unique_ptr<File> oat_file(OS::OpenFileForReading(oat_path.c_str()));
     if (oat_file != nullptr) {
       bcp_oat_fds.push_back(std::to_string(oat_file->Fd()));
@@ -578,7 +578,7 @@ Result<void> AddCompiledBootClasspathFdsIfAny(
       return ErrnoErrorf("Failed to open boot image file '{}'", oat_path);
     }
 
-    std::string vdex_path = ReplaceFileExtension(image_path, "vdex");
+    std::string vdex_path = ReplaceFileExtension(image_path, kVdexExtension);
     std::unique_ptr<File> vdex_file(OS::OpenFileForReading(vdex_path.c_str()));
     if (vdex_file != nullptr) {
       bcp_vdex_fds.push_back(std::to_string(vdex_file->Fd()));
@@ -1017,7 +1017,7 @@ std::string OnDeviceRefresh::GetSystemServerImagePath(bool on_system,
       return GetSystemOdexFilenameForApex(jar_path, config_.GetSystemServerIsa());
     }
     std::string jar_name = Basename(jar_path);
-    std::string image_name = ReplaceFileExtension(jar_name, "art");
+    std::string image_name = ReplaceFileExtension(jar_name, kArtExtension);
     const char* isa_str = GetInstructionSetString(config_.GetSystemServerIsa());
     // Typically "/system/framework/oat/<isa>/services.art".
     return ART_FORMAT("{}/oat/{}/{}", Dirname(jar_path), isa_str, image_name);
diff --git a/openjdkjvmti/Android.bp b/openjdkjvmti/Android.bp
index a5ca0e14c4..3e9b1798a0 100644
--- a/openjdkjvmti/Android.bp
+++ b/openjdkjvmti/Android.bp
@@ -111,7 +111,7 @@ art_cc_library {
     defaults: ["libopenjdkjvmti_defaults"],
     shared_libs: [
         "libart",
-        "libdexfile",
+        "libdexfile#impl",
         "libartbase",
     ],
     apex_available: [
@@ -129,7 +129,7 @@ art_cc_library {
     ],
     shared_libs: [
         "libartd",
-        "libdexfiled",
+        "libdexfiled#impl",
         "libartbased",
     ],
     apex_available: [
diff --git a/openjdkjvmti/ti_method.cc b/openjdkjvmti/ti_method.cc
index 0557234a46..f9f043dbe5 100644
--- a/openjdkjvmti/ti_method.cc
+++ b/openjdkjvmti/ti_method.cc
@@ -79,6 +79,7 @@
 #include "ti_phase.h"
 #include "verifier/register_line-inl.h"
 #include "verifier/reg_type-inl.h"
+#include "verifier/reg_type_cache.h"
 #include "verifier/method_verifier-inl.h"
 
 namespace openjdkjvmti {
@@ -637,12 +638,23 @@ class CommonLocalVariableClosure : public art::Closure {
     art::StackHandleScope<2> hs(art::Thread::Current());
     art::Handle<art::mirror::DexCache> dex_cache(hs.NewHandle(method->GetDexCache()));
     art::Handle<art::mirror::ClassLoader> class_loader(hs.NewHandle(method->GetClassLoader()));
+    art::Thread* self = art::Thread::Current();
+    art::Runtime* runtime = art::Runtime::Current();
+    art::ClassLinker* class_linker = runtime->GetClassLinker();
+    art::ArenaPool* arena_pool = runtime->GetArenaPool();
+    art::verifier::RegTypeCache reg_types(self,
+                                          class_linker,
+                                          arena_pool,
+                                          class_loader,
+                                          dex_cache->GetDexFile(),
+                                          /* can_load_classes= */ false,
+                                          /* can_suspend= */ false);
     std::unique_ptr<art::verifier::MethodVerifier> verifier(
         art::verifier::MethodVerifier::CalculateVerificationInfo(
-            art::Thread::Current(),
+            self,
+            &reg_types,
             method,
             dex_cache,
-            class_loader,
             dex_pc));
     if (verifier == nullptr) {
       JVMTI_LOG(WARNING, jvmti_) << "Unable to extract verification information from "
@@ -1054,8 +1066,7 @@ class SetLocalVariableClosure : public CommonLocalVariableClosure {
           art::ObjPtr<art::mirror::Class> set_class = caller_->DecodeJObject(val_.l)->GetClass();
           art::ObjPtr<art::mirror::ClassLoader> loader =
               method->GetDeclaringClass()->GetClassLoader();
-          art::ObjPtr<art::mirror::Class> slot_class =
-              cl->LookupClass(caller_, descriptor.c_str(), loader);
+          art::ObjPtr<art::mirror::Class> slot_class = cl->LookupClass(caller_, descriptor, loader);
           DCHECK(!slot_class.IsNull()) << descriptor << " slot: " << slot_type;
           return slot_class->IsAssignableFrom(set_class) ? OK : ERR(TYPE_MISMATCH);
         }
diff --git a/openjdkjvmti/ti_redefine.cc b/openjdkjvmti/ti_redefine.cc
index 0ba528a0a7..8e11d592e5 100644
--- a/openjdkjvmti/ti_redefine.cc
+++ b/openjdkjvmti/ti_redefine.cc
@@ -343,23 +343,7 @@ namespace {
 // We need to make sure we only have one redefinition in progress. Redefining involves
 // re-verification and potentially new allocations among other things. So we only allow one
 // redefinition at a time.
-static art::Mutex redefinition_lock("JVMTI Redefinition lock", art::LockLevel::kGenericBottomLock);
-static bool redefinition_in_progress GUARDED_BY(redefinition_lock) = false;
-
-bool canHandleRedefinition(art::Thread* self) {
-  art::MutexLock mu(self, redefinition_lock);
-  if (redefinition_in_progress) {
-    return false;
-  }
-  redefinition_in_progress = true;
-  return true;
-}
-
-void finishRedefinition(art::Thread* self) {
-  art::MutexLock mu(self, redefinition_lock);
-  DCHECK_EQ(redefinition_in_progress, true);
-  redefinition_in_progress = false;
-}
+static std::mutex redefinition_lock;
 }  // namespace
 
 template <RedefinitionType kType>
@@ -660,15 +644,34 @@ jvmtiError Redefiner::RedefineClassesDirect(ArtJvmTiEnv* env,
     // We don't actually need to do anything. Just return OK.
     return OK;
   }
+
+  // Take a lock to avoid any concurrent redefinitions.
+  // TODO(mythria): It is hard to reason that it is safe to hold locks here. It is probably okay,
+  // since the thread is suspended and we know the thread isn't in the middle of allocations. The
+  // current implementation of redefinition is prone to deadlocks. For example, we pause allocations
+  // and then allocate new objects which could trigger a GC. This is unsafe. See b/359829378 for
+  // more details. Ideally we should rework the code so that:
+  // 1. Estimate the size required for the new allocations
+  // 2. Ensure we have the required space
+  // 3. Acquire any locks required (this would also include the lock to prevent
+  // concurrent redefinitions)
+  // 3. SuspendAll the threads
+  // 4. If the estimated size is no longer sufficient - retry from 1.
+  // 5. Finish redefinition.
+  //
+  // Step 4 is required because there might be allocations after we have estimated and before we
+  // suspend all threads. This isn't expected to be frequent so we shouldn't usually need to retry
+  // multiple times.
+  // Using a lock here is a short-term fix to block on concurrent redefinitions (instead of
+  // returning an error) while we rework the redefinition code.
+  // art::MutexLock lg(self, redefinition_lock);
+  std::lock_guard<std::mutex> lg(redefinition_lock);
+
   // We need to fiddle with the verification class flags. To do this we need to make sure there are
   // no concurrent redefinitions of the same class at the same time. For simplicity and because
   // this is not expected to be a common occurrence we will just wrap the whole thing in a TOP-level
   // lock.
   Redefiner r(env, runtime, self, type, error_msg);
-  if (!canHandleRedefinition(self)) {
-    r.RecordFailure(ERR(INTERNAL), "Another redefinition is in progress");
-    return r.result_;
-  }
 
   // Stop JIT for the duration of this redefine since the JIT might concurrently compile a method we
   // are going to redefine.
@@ -681,13 +684,11 @@ jvmtiError Redefiner::RedefineClassesDirect(ArtJvmTiEnv* env,
     if (def.IsModified()) {
       jvmtiError res = r.AddRedefinition(env, def);
       if (res != OK) {
-        finishRedefinition(self);
         return res;
       }
     }
   }
   jvmtiError res = r.Run();
-  finishRedefinition(self);
   return res;
 }
 
@@ -1095,14 +1096,13 @@ bool Redefiner::ClassRedefinition::CheckClass() {
   // Check class name.
   // These should have been checked by the dexfile verifier on load.
   DCHECK_NE(def.class_idx_, art::dex::TypeIndex::Invalid()) << "Invalid type index";
-  const char* descriptor = dex_file_->GetTypeDescriptor(def.class_idx_);
-  DCHECK(descriptor != nullptr) << "Invalid dex file structure!";
+  const std::string_view descriptor = dex_file_->GetTypeDescriptorView(def.class_idx_);
   if (!current_class->DescriptorEquals(descriptor)) {
     std::string storage;
     RecordFailure(ERR(NAMES_DONT_MATCH),
                   StringPrintf("expected file to contain class called '%s' but found '%s'!",
                                current_class->GetDescriptor(&storage),
-                               descriptor));
+                               std::string(descriptor).c_str()));
     return false;
   }
   if (current_class->IsObjectClass()) {
@@ -1111,8 +1111,7 @@ bool Redefiner::ClassRedefinition::CheckClass() {
       return false;
     }
   } else {
-    const char* super_descriptor = dex_file_->GetTypeDescriptor(def.superclass_idx_);
-    DCHECK(descriptor != nullptr) << "Invalid dex file structure!";
+    const std::string_view super_descriptor = dex_file_->GetTypeDescriptorView(def.superclass_idx_);
     if (!current_class->GetSuperClass()->DescriptorEquals(super_descriptor)) {
       RecordFailure(ERR(UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED), "Superclass changed");
       return false;
@@ -1136,9 +1135,8 @@ bool Redefiner::ClassRedefinition::CheckClass() {
     // The order of interfaces is (barely) meaningful so we error if it changes.
     const art::DexFile& orig_dex_file = current_class->GetDexFile();
     for (uint32_t i = 0; i < interfaces->Size(); i++) {
-      if (strcmp(
-            dex_file_->GetTypeDescriptor(interfaces->GetTypeItem(i).type_idx_),
-            orig_dex_file.GetTypeDescriptor(current_interfaces->GetTypeItem(i).type_idx_)) != 0) {
+      if (dex_file_->GetTypeDescriptorView(interfaces->GetTypeItem(i).type_idx_) !=
+          orig_dex_file.GetTypeDescriptorView(current_interfaces->GetTypeItem(i).type_idx_)) {
         RecordFailure(ERR(UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED),
                       "Interfaces changed or re-ordered");
         return false;
diff --git a/perfetto_hprof/Android.bp b/perfetto_hprof/Android.bp
index bca3bf5925..2ee95bc609 100644
--- a/perfetto_hprof/Android.bp
+++ b/perfetto_hprof/Android.bp
@@ -84,7 +84,7 @@ art_cc_library {
     shared_libs: [
         "libart",
         "libartbase",
-        "libdexfile",
+        "libdexfile#impl",
     ],
     apex_available: [
         "com.android.art",
@@ -102,7 +102,7 @@ art_cc_library {
     shared_libs: [
         "libartd",
         "libartbased",
-        "libdexfiled",
+        "libdexfiled#impl",
     ],
     apex_available: [
         "com.android.art.debug",
diff --git a/perfetto_hprof/perfetto_hprof.cc b/perfetto_hprof/perfetto_hprof.cc
index 07eb4c60f4..7379fd66c9 100644
--- a/perfetto_hprof/perfetto_hprof.cc
+++ b/perfetto_hprof/perfetto_hprof.cc
@@ -129,21 +129,18 @@ void ArmWatchdogOrDie() {
   }
 }
 
-bool StartsWith(const std::string& str, const std::string& prefix) {
-  return str.compare(0, prefix.length(), prefix) == 0;
-}
-
 // Sample entries that match one of the following
 // start with /system/
 // start with /vendor/
 // start with /data/app/
 // contains "extracted in memory from Y", where Y matches any of the above
 bool ShouldSampleSmapsEntry(const perfetto::profiling::SmapsEntry& e) {
-  if (StartsWith(e.pathname, "/system/") || StartsWith(e.pathname, "/vendor/") ||
-      StartsWith(e.pathname, "/data/app/")) {
+  if (e.pathname.starts_with("/system/") ||
+      e.pathname.starts_with("/vendor/") ||
+      e.pathname.starts_with("/data/app/")) {
     return true;
   }
-  if (StartsWith(e.pathname, "[anon:")) {
+  if (e.pathname.starts_with("[anon:")) {
     if (e.pathname.find("extracted in memory from /system/") != std::string::npos) {
       return true;
     }
@@ -318,7 +315,6 @@ void SetupDataSource(const std::string& ds_name, bool is_oome_heap) {
   dsd.set_name(ds_name);
   dsd.set_will_notify_on_stop(true);
   JavaHprofDataSource::Register(dsd, is_oome_heap);
-  LOG(INFO) << "registered data source " << ds_name;
 }
 
 // Waits for the data source OnStart
@@ -758,6 +754,26 @@ class HeapGraphDumper {
       object_proto->set_self_size(obj->SizeOf());
     }
 
+    const art::gc::Heap* heap = art::Runtime::Current()->GetHeap();
+    const auto* space = heap->FindContinuousSpaceFromObject(obj, /*fail_ok=*/true);
+    auto heap_type = perfetto::protos::pbzero::HeapGraphObject::HEAP_TYPE_APP;
+    if (space != nullptr) {
+      if (space->IsZygoteSpace()) {
+        heap_type = perfetto::protos::pbzero::HeapGraphObject::HEAP_TYPE_ZYGOTE;
+      } else if (space->IsImageSpace() && heap->ObjectIsInBootImageSpace(obj)) {
+        heap_type = perfetto::protos::pbzero::HeapGraphObject::HEAP_TYPE_BOOT_IMAGE;
+      }
+    } else {
+      const auto* los = heap->GetLargeObjectsSpace();
+      if (los->Contains(obj) && los->IsZygoteLargeObject(art::Thread::Current(), obj)) {
+        heap_type = perfetto::protos::pbzero::HeapGraphObject::HEAP_TYPE_ZYGOTE;
+      }
+    }
+    if (heap_type != prev_heap_type_) {
+      object_proto->set_heap_type_delta(heap_type);
+      prev_heap_type_ = heap_type;
+    }
+
     FillReferences(obj, klass, object_proto);
 
     FillFieldValues(obj, klass, object_proto);
@@ -922,6 +938,9 @@ class HeapGraphDumper {
 
   // Id of the previous object that was dumped. Used for delta encoding.
   uint64_t prev_object_id_ = 0;
+  // Heap type of the previous object that was dumped. Used for delta encoding.
+  perfetto::protos::pbzero::HeapGraphObject::HeapType prev_heap_type_ =
+      perfetto::protos::pbzero::HeapGraphObject::HEAP_TYPE_UNKNOWN;
 };
 
 // waitpid with a timeout implemented by ~busy-waiting
@@ -957,6 +976,11 @@ enum class ResumeParentPolicy {
   DEFERRED
 };
 
+pid_t ForkUnderThreadListLock(art::Thread* self) {
+  art::MutexLock lk(self, *art::Locks::thread_list_lock_);
+  return fork();
+}
+
 void ForkAndRun(art::Thread* self,
                 ResumeParentPolicy resume_parent_policy,
                 const std::function<void(pid_t child)>& parent_runnable,
@@ -970,6 +994,8 @@ void ForkAndRun(art::Thread* self,
   // We need to do this before the fork, because otherwise it can deadlock
   // waiting for the GC, as all other threads get terminated by the clone, but
   // their locks are not released.
+  // We must also avoid any logd logging actions on the forked process; art LogdLoggerLocked
+  // serializes logging from different threads via a mutex.
   // This does not perfectly solve all fork-related issues, as there could still be threads that
   // are unaffected by ScopedSuspendAll and in a non-fork-friendly situation
   // (e.g. inside a malloc holding a lock). This situation is quite rare, and in that case we will
@@ -979,7 +1005,8 @@ void ForkAndRun(art::Thread* self,
 
   std::optional<art::ScopedSuspendAll> ssa(std::in_place, __FUNCTION__, /* long_suspend=*/ true);
 
-  pid_t pid = fork();
+  // Optimistically get the thread_list_lock_ to avoid the child process deadlocking
+  pid_t pid = ForkUnderThreadListLock(self);
   if (pid == -1) {
     // Fork error.
     PLOG(ERROR) << "fork";
@@ -1032,7 +1059,7 @@ void WriteHeapPackets(pid_t parent_pid, uint64_t timestamp) {
               dump_smaps = ds->dump_smaps();
               ignored_types = ds->ignored_types();
             }
-            LOG(INFO) << "dumping heap for " << parent_pid;
+            art::ScopedTrace trace("ART heap dump for " + std::to_string(parent_pid));
             if (dump_smaps) {
               DumpSmaps(&ctx);
             }
diff --git a/profman/Android.bp b/profman/Android.bp
index 948b6fd23d..b3dcb6d490 100644
--- a/profman/Android.bp
+++ b/profman/Android.bp
@@ -97,7 +97,7 @@ art_cc_binary {
         android: {
             shared_libs: [
                 "libartbase",
-                "libdexfile",
+                "libdexfile#impl",
                 "libprofile",
             ],
         },
@@ -126,7 +126,7 @@ art_cc_binary {
         android: {
             shared_libs: [
                 "libartbased",
-                "libdexfiled",
+                "libdexfiled#impl",
                 "libprofiled",
             ],
         },
@@ -185,7 +185,7 @@ cc_library_headers {
 
 art_cc_defaults {
     name: "art_profman_tests_defaults",
-    data: [
+    device_common_data: [
         ":art-gtest-jars-ProfileTestMultiDex",
     ],
     header_libs: ["profman_headers"],
diff --git a/profman/profile_assistant_test.cc b/profman/profile_assistant_test.cc
index 1e056f119d..8699a021f6 100644
--- a/profman/profile_assistant_test.cc
+++ b/profman/profile_assistant_test.cc
@@ -285,7 +285,7 @@ class ProfileAssistantTest : public CommonRuntimeTest, public ProfileTestHelper
     StackHandleScope<1> hs(soa.Self());
     Handle<mirror::ClassLoader> h_loader(hs.NewHandle(
         ObjPtr<mirror::ClassLoader>::DownCast(soa.Self()->DecodeJObject(class_loader))));
-    return class_linker->FindClass(soa.Self(), clazz.c_str(), h_loader);
+    return FindClass(clazz.c_str(), h_loader);
   }
 
   ArtMethod* GetVirtualMethod(jobject class_loader,
diff --git a/runtime/Android.bp b/runtime/Android.bp
index 0d9009924a..1c7e9fbcb3 100644
--- a/runtime/Android.bp
+++ b/runtime/Android.bp
@@ -151,9 +151,9 @@ cc_defaults {
         "liblog",
         "liblz4",
         "liblzma", // libelffile(d) dependency; must be repeated here since it's a static lib.
-        "libnativebridge",
-        "libnativeloader",
-        "libsigchain",
+        "libnativebridge#impl",
+        "libnativeloader#impl",
+        "libsigchain#impl",
         "libunwindstack",
     ],
     static_libs: ["libodrstatslog"],
@@ -167,11 +167,11 @@ cc_defaults {
     ],
     shared_libs: [
         "libartbase",
-        "libdexfile",
+        "libdexfile#impl",
         "libprofile",
     ],
     export_shared_lib_headers: [
-        "libdexfile",
+        "libdexfile#impl",
     ],
 }
 
@@ -183,11 +183,11 @@ cc_defaults {
     ],
     shared_libs: [
         "libartbased",
-        "libdexfiled",
+        "libdexfiled#impl",
         "libprofiled",
     ],
     export_shared_lib_headers: [
-        "libdexfiled",
+        "libdexfiled#impl",
     ],
 }
 
@@ -216,8 +216,17 @@ cc_defaults {
     },
     runtime_libs: [
         // Libraries loaded at runtime. Exceptions:
-        // - libart(d)-compiler.so and libopenjdk(d).so cannot be listed here
-        //   due to cyclic dependency.
+        //
+        // - Libraries that cannot be listed here due to cyclic dependency:
+        //   - libopenjdk(d)
+        //   - libadbconnection(d)
+        //   - libopenjdkjvmti(d)
+        //     - This one is not loaded programmatically with dlopen, but the
+        //       user needs to specify it with -Xplugin.
+        //   - libperfetto_hprof(d)
+        //   All libraries above needs to be explicitly added to the ART APEX
+        //   (cf. art/build/apex/Android.bp).
+        //
         // - libicu_jni.so is only loaded to handle dependency order in VM
         //   startup (see Runtime::InitNativeMethods), but its API is internal
         //   to com.android.i18n and not used by ART/libcore. Therefore it's not
@@ -470,6 +479,7 @@ cc_defaults {
                 "arch/arm/jni_entrypoints_arm.S",
                 "arch/arm/memcmp16_arm.S",
                 "arch/arm/quick_entrypoints_arm.S",
+                "arch/arm/native_entrypoints_arm.S",
                 "arch/arm/quick_entrypoints_cc_arm.cc",
                 "arch/arm/thread_arm.cc",
                 "arch/arm/fault_handler_arm.cc",
@@ -484,6 +494,7 @@ cc_defaults {
                 "arch/arm64/jni_entrypoints_arm64.S",
                 "arch/arm64/memcmp16_arm64.S",
                 "arch/arm64/quick_entrypoints_arm64.S",
+                "arch/arm64/native_entrypoints_arm64.S",
                 "arch/arm64/thread_arm64.cc",
                 "monitor_pool.cc",
                 "arch/arm64/fault_handler_arm64.cc",
@@ -497,6 +508,7 @@ cc_defaults {
                 "arch/riscv64/fault_handler_riscv64.cc",
                 "arch/riscv64/jni_entrypoints_riscv64.S",
                 "arch/riscv64/quick_entrypoints_riscv64.S",
+                "arch/riscv64/native_entrypoints_riscv64.S",
                 "arch/riscv64/thread_riscv64.cc",
                 "interpreter/mterp/nterp.cc",
                 "monitor_pool.cc",
@@ -511,6 +523,7 @@ cc_defaults {
                 "arch/x86/jni_entrypoints_x86.S",
                 "arch/x86/memcmp16_x86.S",
                 "arch/x86/quick_entrypoints_x86.S",
+                "arch/x86/native_entrypoints_x86.S",
                 "arch/x86/thread_x86.cc",
                 "arch/x86/fault_handler_x86.cc",
             ],
@@ -532,6 +545,7 @@ cc_defaults {
                 "arch/x86_64/jni_entrypoints_x86_64.S",
                 "arch/x86_64/memcmp16_x86_64.S",
                 "arch/x86_64/quick_entrypoints_x86_64.S",
+                "arch/x86_64/native_entrypoints_x86_64.S",
                 "arch/x86_64/thread_x86_64.cc",
                 "monitor_pool.cc",
                 "arch/x86/fault_handler_x86.cc",
@@ -829,10 +843,6 @@ art_cc_library_static {
     defaults: ["libartd-runtime_defaults"],
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into com.android.art, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and this depends on libsigchain.
-        "com.android.art",
     ],
 }
 
@@ -919,11 +929,6 @@ art_cc_library {
     ],
     apex_available: [
         "com.android.art.debug",
-        // TODO(b/183882457): This lib doesn't go into com.android.art, but
-        // apex_available lists need to be the same for internal libs to avoid
-        // stubs, and this depends on libsigchain.
-        "com.android.art",
-        "test_broken_com.android.art",
     ],
 }
 
@@ -981,7 +986,7 @@ art_cc_defaults {
             ],
         },
     },
-    data: [
+    device_common_data: [
         ":art-gtest-jars-AllFields",
         ":art-gtest-jars-DexVerificationFuzzerFolder",
         ":art-gtest-jars-ClassVerificationFuzzerFolder",
@@ -1120,6 +1125,7 @@ art_cc_defaults {
         "vdex_file_test.cc",
         "verifier/method_verifier_test.cc",
         "verifier/reg_type_test.cc",
+        "verifier/register_line_test.cc",
     ],
     static_libs: [
         "libgmock",
@@ -1139,7 +1145,10 @@ art_cc_test {
     ],
     target: {
         host: {
-            required: ["dex2oatd"],
+            required: [
+                "dex2oatd",
+                "art_boot_images",
+            ],
         },
     },
 }
diff --git a/runtime/app_info.cc b/runtime/app_info.cc
index 50772b1dbf..943b9dee1f 100644
--- a/runtime/app_info.cc
+++ b/runtime/app_info.cc
@@ -28,11 +28,11 @@ static constexpr const char* kUnknownValue = "unknown";
 AppInfo::AppInfo()
     : update_mutex_("app_info_update_mutex", LockLevel::kGenericBottomLock) {}
 
-// Converts VMRuntime.java constansts to a CodeType.
+// Converts VMRuntime.java constants to a CodeType.
 AppInfo::CodeType AppInfo::FromVMRuntimeConstants(uint32_t code_type) {
   switch (code_type) {
     case kVMRuntimePrimaryApk : return CodeType::kPrimaryApk;
-    case kVMRuntimeSplitApk : return CodeType::kPrimaryApk;
+    case kVMRuntimeSplitApk : return CodeType::kSplitApk;
     case kVMRuntimeSecondaryDex : return CodeType::kSecondaryDex;
     default:
       LOG(WARNING) << "Unknown code type: " << code_type;
diff --git a/runtime/arch/arm/context_arm.cc b/runtime/arch/arm/context_arm.cc
index 50aec3331b..09756f68b6 100644
--- a/runtime/arch/arm/context_arm.cc
+++ b/runtime/arch/arm/context_arm.cc
@@ -39,20 +39,21 @@ void ArmContext::Reset() {
 }
 
 void ArmContext::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& frame_info) {
+  const size_t frame_size = frame_info.FrameSizeInBytes();
   int spill_pos = 0;
 
   // Core registers come first, from the highest down to the lowest.
   uint32_t core_regs = frame_info.CoreSpillMask();
   DCHECK_EQ(0u, core_regs & (static_cast<uint32_t>(-1) << kNumberOfCoreRegisters));
   for (uint32_t core_reg : HighToLowBits(core_regs)) {
-    gprs_[core_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    gprs_[core_reg] = CalleeSaveAddress<InstructionSet::kArm>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()));
 
   // FP registers come second, from the highest down to the lowest.
   for (uint32_t fp_reg : HighToLowBits(frame_info.FpSpillMask())) {
-    fprs_[fp_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    fprs_[fp_reg] = CalleeSaveAddress<InstructionSet::kArm>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()) + POPCOUNT(frame_info.FpSpillMask()));
diff --git a/runtime/arch/arm/entrypoints_init_arm.cc b/runtime/arch/arm/entrypoints_init_arm.cc
index 156a107c99..4fb4774a6d 100644
--- a/runtime/arch/arm/entrypoints_init_arm.cc
+++ b/runtime/arch/arm/entrypoints_init_arm.cc
@@ -21,19 +21,16 @@
 #include "base/bit_utils.h"
 #include "entrypoints/entrypoint_utils.h"
 #include "entrypoints/jni/jni_entrypoints.h"
-#include "entrypoints/math_entrypoints.h"
 #include "entrypoints/quick/quick_alloc_entrypoints.h"
 #include "entrypoints/quick/quick_default_externs.h"
 #include "entrypoints/quick/quick_default_init_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
 namespace art HIDDEN {
 
-// Cast entrypoints.
-extern "C" size_t artInstanceOfFromCode(mirror::Object* obj, mirror::Class* ref_class);
-
 // Read barrier entrypoints.
 // art_quick_read_barrier_mark_regX uses an non-standard calling
 // convention: it expects its input in register X and returns its
@@ -199,4 +196,9 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetReadBarrierForRootSlow(artReadBarrierForRootSlow);
 }
 
+void UpdateLowOverheadTraceEntrypoints([[maybe_unused]] QuickEntryPoints* qpoints,
+                                       [[maybe_unused]] bool enable) {
+  // This is a nop on this architecture. Low overhead tracing is only implemented for ARM64.
+}
+
 }  // namespace art
diff --git a/runtime/arch/arm/jni_entrypoints_arm.S b/runtime/arch/arm/jni_entrypoints_arm.S
index 8c80c338dd..8b57983832 100644
--- a/runtime/arch/arm/jni_entrypoints_arm.S
+++ b/runtime/arch/arm/jni_entrypoints_arm.S
@@ -83,47 +83,6 @@ ENTRY \name
 END \name
 .endm
 
-    /*
-     * Jni dlsym lookup stub.
-     */
-    .extern artFindNativeMethod
-    .extern artFindNativeMethodRunnable
-ENTRY art_jni_dlsym_lookup_stub
-    push   {r0, r1, r2, r3, lr}           @ spill regs
-    .cfi_adjust_cfa_offset 20
-    .cfi_rel_offset lr, 16
-    sub    sp, #12                        @ pad stack pointer to align frame
-    .cfi_adjust_cfa_offset 12
-
-    mov    r0, rSELF                      @ pass Thread::Current()
-    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
-    // for @FastNative or @CriticalNative.
-    ldr    ip, [r0, #THREAD_TOP_QUICK_FRAME_OFFSET]   // uintptr_t tagged_quick_frame
-    bic    ip, #TAGGED_JNI_SP_MASK                    // ArtMethod** sp
-    ldr    ip, [ip]                                   // ArtMethod* method
-    ldr    ip, [ip, #ART_METHOD_ACCESS_FLAGS_OFFSET]  // uint32_t access_flags
-    tst    ip, #(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
-    bne    .Llookup_stub_fast_or_critical_native
-    blx    artFindNativeMethod
-    b      .Llookup_stub_continue
-.Llookup_stub_fast_or_critical_native:
-    blx    artFindNativeMethodRunnable
-.Llookup_stub_continue:
-    mov    r12, r0                        @ save result in r12
-
-    add    sp, #12                        @ restore stack pointer
-    .cfi_adjust_cfa_offset -12
-    CFI_REMEMBER_STATE
-    cbz    r0, 1f                         @ is method code null?
-    pop    {r0, r1, r2, r3, lr}           @ restore regs
-    .cfi_adjust_cfa_offset -20
-    .cfi_restore lr
-    bx     r12                            @ if non-null, tail call to method's code
-1:
-    CFI_RESTORE_STATE_AND_DEF_CFA sp, 20
-    pop    {r0, r1, r2, r3, pc}           @ restore regs and return to caller to handle exception
-END art_jni_dlsym_lookup_stub
-
     /*
      * Jni dlsym lookup stub for @CriticalNative.
      */
diff --git a/runtime/arch/arm/native_entrypoints_arm.S b/runtime/arch/arm/native_entrypoints_arm.S
new file mode 100644
index 0000000000..1666dc8d4b
--- /dev/null
+++ b/runtime/arch/arm/native_entrypoints_arm.S
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "asm_support_arm.S"
+#include "interpreter/cfi_asm_support.h"
+
+/*
+ * This file contains all native entrypoints that are called using the native ABI and do not
+ * transition to the quick ABI. For example: the switch interpreter (using the native ABI) directly
+ * calls ExecuteSwitchImplAsm and this code will always return back to the switch interpreter,
+ * again using the native ABI. Because of this behaviour ExecuteSwitchImplAsm should be included in
+ * this file. This is done so these native entrypoints can be compiled independently to quick
+ * entrypoints for cases when the kRuntimeISA and kRuntimeQuickCodeISA do not match.
+ *
+ * See comment on StackType (thread.h) for definitions and examples of quick ABI/code and
+ * native ABI/code.
+ */
+
+// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
+//  Argument 0: r0: The context pointer for ExecuteSwitchImpl.
+//  Argument 1: r1: Pointer to the templated ExecuteSwitchImpl to call.
+//  Argument 2: r2: The value of DEX PC (memory address of the methods bytecode).
+ENTRY ExecuteSwitchImplAsm
+    push {r4, lr}                                 // 2 words of callee saves.
+    .cfi_adjust_cfa_offset 8
+    .cfi_rel_offset r4, 0
+    .cfi_rel_offset lr, 4
+    mov r4, r2                                    // r4 = DEX PC
+    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* r0 */, 4 /* r4 */, 0)
+    blx r1                                        // Call the wrapped method.
+    pop {r4, pc}
+END ExecuteSwitchImplAsm
+
+    /*
+     * Jni dlsym lookup stub.
+     */
+    .extern artFindNativeMethod
+    .extern artFindNativeMethodRunnable
+ENTRY art_jni_dlsym_lookup_stub
+    push   {r0, r1, r2, r3, lr}           @ spill regs
+    .cfi_adjust_cfa_offset 20
+    .cfi_rel_offset lr, 16
+    sub    sp, #12                        @ pad stack pointer to align frame
+    .cfi_adjust_cfa_offset 12
+
+    mov    r0, rSELF                      @ pass Thread::Current()
+    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
+    // for @FastNative or @CriticalNative.
+    ldr    ip, [r0, #THREAD_TOP_QUICK_FRAME_OFFSET]   // uintptr_t tagged_quick_frame
+    bic    ip, #TAGGED_JNI_SP_MASK                    // ArtMethod** sp
+    ldr    ip, [ip]                                   // ArtMethod* method
+    ldr    ip, [ip, #ART_METHOD_ACCESS_FLAGS_OFFSET]  // uint32_t access_flags
+    tst    ip, #(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
+    bne    .Llookup_stub_fast_or_critical_native
+    blx    artFindNativeMethod
+    b      .Llookup_stub_continue
+.Llookup_stub_fast_or_critical_native:
+    blx    artFindNativeMethodRunnable
+.Llookup_stub_continue:
+    mov    r12, r0                        @ save result in r12
+
+    add    sp, #12                        @ restore stack pointer
+    .cfi_adjust_cfa_offset -12
+    CFI_REMEMBER_STATE
+    cbz    r0, 1f                         @ is method code null?
+    pop    {r0, r1, r2, r3, lr}           @ restore regs
+    .cfi_adjust_cfa_offset -20
+    .cfi_restore lr
+    bx     r12                            @ if non-null, tail call to method's code
+1:
+    CFI_RESTORE_STATE_AND_DEF_CFA sp, 20
+    pop    {r0, r1, r2, r3, pc}           @ restore regs and return to caller to handle exception
+END art_jni_dlsym_lookup_stub
+
diff --git a/runtime/arch/arm/quick_entrypoints_arm.S b/runtime/arch/arm/quick_entrypoints_arm.S
index 2621918d09..ddfe70dc51 100644
--- a/runtime/arch/arm/quick_entrypoints_arm.S
+++ b/runtime/arch/arm/quick_entrypoints_arm.S
@@ -2354,21 +2354,6 @@ ENTRY art_quick_invoke_custom
     RETURN_OR_DELIVER_PENDING_EXCEPTION_REG r2
 END art_quick_invoke_custom
 
-// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
-//  Argument 0: r0: The context pointer for ExecuteSwitchImpl.
-//  Argument 1: r1: Pointer to the templated ExecuteSwitchImpl to call.
-//  Argument 2: r2: The value of DEX PC (memory address of the methods bytecode).
-ENTRY ExecuteSwitchImplAsm
-    push {r4, lr}                                 // 2 words of callee saves.
-    .cfi_adjust_cfa_offset 8
-    .cfi_rel_offset r4, 0
-    .cfi_rel_offset lr, 4
-    mov r4, r2                                    // r4 = DEX PC
-    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* r0 */, 4 /* r4 */, 0)
-    blx r1                                        // Call the wrapped method.
-    pop {r4, pc}
-END ExecuteSwitchImplAsm
-
 // r0 contains the class, r4 contains the inline cache. We can use ip as temporary.
 ENTRY art_quick_update_inline_cache
 #if (INLINE_CACHE_SIZE != 5)
diff --git a/runtime/arch/arm64/asm_support_arm64.S b/runtime/arch/arm64/asm_support_arm64.S
index 56ce037b1a..ae965303b9 100644
--- a/runtime/arch/arm64/asm_support_arm64.S
+++ b/runtime/arch/arm64/asm_support_arm64.S
@@ -152,6 +152,13 @@
     SAVE_TWO_REGS_BASE sp, \reg1, \reg2, \offset
 .endm
 
+.macro SAVE_TWO_REGS_INCREASE_FRAME reg1, reg2, frame_adjustment
+    stp \reg1, \reg2, [sp, #-(\frame_adjustment)]!
+    .cfi_adjust_cfa_offset (\frame_adjustment)
+    .cfi_rel_offset \reg1, 0
+    .cfi_rel_offset \reg2, 8
+.endm
+
 .macro RESTORE_TWO_REGS_BASE base, reg1, reg2, offset
     ldp \reg1, \reg2, [\base, #(\offset)]
     .cfi_restore \reg1
@@ -162,6 +169,40 @@
     RESTORE_TWO_REGS_BASE sp, \reg1, \reg2, \offset
 .endm
 
+.macro RESTORE_TWO_REGS_DECREASE_FRAME reg1, reg2, frame_adjustment
+    ldp \reg1, \reg2, [sp], #(\frame_adjustment)
+    .cfi_restore \reg1
+    .cfi_restore \reg2
+    .cfi_adjust_cfa_offset -(\frame_adjustment)
+.endm
+
+#define ALL_ARGS_SIZE (/*x0-x7*/ 8 * 8 + /*d0-d7*/ 8 * 8)
+
+.macro SAVE_ALL_ARGS_INCREASE_FRAME extra_space
+    // Save register args x0-x7, d0-d7 and return address.
+    stp    x0, x1, [sp, #-(ALL_ARGS_SIZE + \extra_space)]!
+    .cfi_adjust_cfa_offset (ALL_ARGS_SIZE + \extra_space)
+    stp    x2, x3, [sp, #16]
+    stp    x4, x5, [sp, #32]
+    stp    x6, x7, [sp, #48]
+    stp    d0, d1, [sp, #64]
+    stp    d2, d3, [sp, #80]
+    stp    d4, d5, [sp, #96]
+    stp    d6, d7, [sp, #112]
+.endm
+
+.macro RESTORE_ALL_ARGS_DECREASE_FRAME extra_space
+    ldp    x2, x3, [sp, #16]
+    ldp    x4, x5, [sp, #32]
+    ldp    x6, x7, [sp, #48]
+    ldp    d0, d1, [sp, #64]
+    ldp    d2, d3, [sp, #80]
+    ldp    d4, d5, [sp, #96]
+    ldp    d6, d7, [sp, #112]
+    ldp    x0, x1, [sp], #(ALL_ARGS_SIZE + \extra_space)
+    .cfi_adjust_cfa_offset -(ALL_ARGS_SIZE + \extra_space)
+.endm
+
 .macro LOAD_RUNTIME_INSTANCE reg
 #if __has_feature(hwaddress_sanitizer)
     adrp \reg, :pg_hi21_nc:_ZN3art7Runtime9instance_E
diff --git a/runtime/arch/arm64/context_arm64.cc b/runtime/arch/arm64/context_arm64.cc
index 77009e4932..9b5afb55d2 100644
--- a/runtime/arch/arm64/context_arm64.cc
+++ b/runtime/arch/arm64/context_arm64.cc
@@ -48,18 +48,19 @@ void Arm64Context::Reset() {
 }
 
 void Arm64Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& frame_info) {
+  const size_t frame_size = frame_info.FrameSizeInBytes();
   int spill_pos = 0;
 
   // Core registers come first, from the highest down to the lowest.
   for (uint32_t core_reg : HighToLowBits(frame_info.CoreSpillMask())) {
-    gprs_[core_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    gprs_[core_reg] = CalleeSaveAddress<InstructionSet::kArm64>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()));
 
   // FP registers come second, from the highest down to the lowest.
   for (uint32_t fp_reg : HighToLowBits(frame_info.FpSpillMask())) {
-    fprs_[fp_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    fprs_[fp_reg] = CalleeSaveAddress<InstructionSet::kArm64>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()) + POPCOUNT(frame_info.FpSpillMask()));
diff --git a/runtime/arch/arm64/entrypoints_init_arm64.cc b/runtime/arch/arm64/entrypoints_init_arm64.cc
index 51cdacbb47..3360708a4c 100644
--- a/runtime/arch/arm64/entrypoints_init_arm64.cc
+++ b/runtime/arch/arm64/entrypoints_init_arm64.cc
@@ -22,11 +22,11 @@
 #include "com_android_art_flags.h"
 #include "entrypoints/entrypoint_utils.h"
 #include "entrypoints/jni/jni_entrypoints.h"
-#include "entrypoints/math_entrypoints.h"
 #include "entrypoints/quick/quick_alloc_entrypoints.h"
 #include "entrypoints/quick/quick_default_externs.h"
 #include "entrypoints/quick/quick_default_init_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
@@ -34,9 +34,6 @@ namespace art_flags = com::android::art::flags;
 
 namespace art HIDDEN {
 
-// Cast entrypoints.
-extern "C" size_t artInstanceOfFromCode(mirror::Object* obj, mirror::Class* ref_class);
-
 // Read barrier entrypoints.
 // art_quick_read_barrier_mark_regX uses an non-standard calling
 // convention: it expects its input in register X and returns its
@@ -82,6 +79,14 @@ extern "C" mirror::Object* art_quick_read_barrier_mark_introspection_gc_roots(mi
 extern "C" void art_quick_record_entry_trace_event();
 extern "C" void art_quick_record_exit_trace_event();
 
+extern "C" void art_quick_nop_record_entry_trace_event() {
+  return;
+}
+
+extern "C" void art_quick_nop_record_exit_trace_event() {
+  return;
+}
+
 void UpdateReadBarrierEntrypoints(QuickEntryPoints* qpoints, bool is_active) {
   // ARM64 is the architecture with the largest number of core
   // registers (32) that supports the read barrier configuration.
@@ -190,6 +195,11 @@ void InitEntryPoints(JniEntryPoints* jpoints,
 
   // Intrinsics
   qpoints->SetIndexOf(art_quick_indexof);
+
+  // Invoke.
+  qpoints->SetInvokePolymorphicWithHiddenReceiver(
+      art_quick_invoke_polymorphic_with_hidden_receiver);
+
   // The ARM64 StringCompareTo intrinsic does not call the runtime.
   qpoints->SetStringCompareTo(nullptr);
   qpoints->SetMemcpy(memcpy);
@@ -208,4 +218,14 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   }
 }
 
+void UpdateLowOverheadTraceEntrypoints(QuickEntryPoints* qpoints, bool enable) {
+  if (enable) {
+    qpoints->SetRecordEntryTraceEvent(art_quick_record_entry_trace_event);
+    qpoints->SetRecordExitTraceEvent(art_quick_record_exit_trace_event);
+  } else {
+    qpoints->SetRecordEntryTraceEvent(art_quick_nop_record_entry_trace_event);
+    qpoints->SetRecordExitTraceEvent(art_quick_nop_record_exit_trace_event);
+  }
+}
+
 }  // namespace art
diff --git a/runtime/arch/arm64/jni_entrypoints_arm64.S b/runtime/arch/arm64/jni_entrypoints_arm64.S
index 2bfb02d062..2b0a214b4f 100644
--- a/runtime/arch/arm64/jni_entrypoints_arm64.S
+++ b/runtime/arch/arm64/jni_entrypoints_arm64.S
@@ -16,33 +16,6 @@
 
 #include "asm_support_arm64.S"
 
-#define ALL_ARGS_SIZE (/*x0-x7*/ 8 * 8 + /*d0-d7*/ 8 * 8)
-
-.macro SAVE_ALL_ARGS_INCREASE_FRAME extra_space
-    // Save register args x0-x7, d0-d7 and return address.
-    stp    x0, x1, [sp, #-(ALL_ARGS_SIZE + \extra_space)]!
-    .cfi_adjust_cfa_offset (ALL_ARGS_SIZE + \extra_space)
-    stp    x2, x3, [sp, #16]
-    stp    x4, x5, [sp, #32]
-    stp    x6, x7, [sp, #48]
-    stp    d0, d1, [sp, #64]
-    stp    d2, d3, [sp, #80]
-    stp    d4, d5, [sp, #96]
-    stp    d6, d7, [sp, #112]
-.endm
-
-.macro RESTORE_ALL_ARGS_DECREASE_FRAME extra_space
-    ldp    x2, x3, [sp, #16]
-    ldp    x4, x5, [sp, #32]
-    ldp    x6, x7, [sp, #48]
-    ldp    d0, d1, [sp, #64]
-    ldp    d2, d3, [sp, #80]
-    ldp    d4, d5, [sp, #96]
-    ldp    d6, d7, [sp, #112]
-    ldp    x0, x1, [sp], #(ALL_ARGS_SIZE + \extra_space)
-    .cfi_adjust_cfa_offset -(ALL_ARGS_SIZE + \extra_space)
-.endm
-
 .macro JNI_SAVE_MANAGED_ARGS_TRAMPOLINE name, cxx_name, arg1 = "none"
     .extern \cxx_name
 ENTRY \name
@@ -86,57 +59,18 @@ ENTRY \name
 END \name
 .endm
 
-    /*
-     * Jni dlsym lookup stub.
-     */
-    .extern artFindNativeMethod
-    .extern artFindNativeMethodRunnable
-ENTRY art_jni_dlsym_lookup_stub
-    // spill regs.
-    SAVE_ALL_ARGS_INCREASE_FRAME 2 * 8
-    stp   x29, x30, [sp, ALL_ARGS_SIZE]
-    .cfi_rel_offset x29, ALL_ARGS_SIZE
-    .cfi_rel_offset x30, ALL_ARGS_SIZE + 8
-    add   x29, sp, ALL_ARGS_SIZE
-
-    mov x0, xSELF   // pass Thread::Current()
-    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
-    // for @FastNative or @CriticalNative.
-    ldr   xIP0, [x0, #THREAD_TOP_QUICK_FRAME_OFFSET]      // uintptr_t tagged_quick_frame
-    bic   xIP0, xIP0, #TAGGED_JNI_SP_MASK                 // ArtMethod** sp
-    ldr   xIP0, [xIP0]                                    // ArtMethod* method
-    ldr   xIP0, [xIP0, #ART_METHOD_ACCESS_FLAGS_OFFSET]   // uint32_t access_flags
-    mov   xIP1, #(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
-    tst   xIP0, xIP1
-    b.ne  .Llookup_stub_fast_or_critical_native
-    bl    artFindNativeMethod
-    b     .Llookup_stub_continue
-    .Llookup_stub_fast_or_critical_native:
-    bl    artFindNativeMethodRunnable
-.Llookup_stub_continue:
-    mov   x17, x0    // store result in scratch reg.
-
-    // load spill regs.
-    ldp   x29, x30, [sp, #ALL_ARGS_SIZE]
-    .cfi_restore x29
-    .cfi_restore x30
-    RESTORE_ALL_ARGS_DECREASE_FRAME 2 * 8
-
-    cbz   x17, 1f   // is method code null ?
-    br    x17       // if non-null, tail call to method's code.
-
-1:
-    ret             // restore regs and return to caller to handle exception.
-END art_jni_dlsym_lookup_stub
-
     /*
      * Jni dlsym lookup stub for @CriticalNative.
      */
 ENTRY art_jni_dlsym_lookup_critical_stub
     // The hidden arg holding the tagged method (bit 0 set means GenericJNI) is x15.
     // For Generic JNI we already have a managed frame, so we reuse the art_jni_dlsym_lookup_stub.
-    tbnz  x15, #0, art_jni_dlsym_lookup_stub
+    // Note: 'tbnz' doesn't always have enough range (+/-32KB) to reach art_jni_dlsym_lookup_stub
+    // so 'b' (+/-128MB) is used instead.
+    tbz  x15, #0, .Lcritical_not_generic_jni
+    b art_jni_dlsym_lookup_stub
 
+.Lcritical_not_generic_jni:
     // Save args, the hidden arg and caller PC. No CFI needed for args and the hidden arg.
     SAVE_ALL_ARGS_INCREASE_FRAME 2 * 8
     stp   x15, lr, [sp, #ALL_ARGS_SIZE]
diff --git a/runtime/arch/arm64/native_entrypoints_arm64.S b/runtime/arch/arm64/native_entrypoints_arm64.S
new file mode 100644
index 0000000000..747e572c97
--- /dev/null
+++ b/runtime/arch/arm64/native_entrypoints_arm64.S
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "asm_support_arm64.S"
+#include "interpreter/cfi_asm_support.h"
+
+/*
+ * This file contains all native entrypoints that are called using the native ABI and do not
+ * transition to the quick ABI. For example: the switch interpreter (using the native ABI) directly
+ * calls ExecuteSwitchImplAsm and this code will always return back to the switch interpreter,
+ * again using the native ABI. Because of this behaviour ExecuteSwitchImplAsm should be included in
+ * this file. This is done so these native entrypoints can be compiled independently to quick
+ * entrypoints for cases when the kRuntimeISA and kRuntimeQuickCodeISA do not match.
+ *
+ * See comment on StackType (thread.h) for definitions and examples of quick ABI/code and
+ * native ABI/code.
+ */
+
+// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
+//  Argument 0: x0: The context pointer for ExecuteSwitchImpl.
+//  Argument 1: x1: Pointer to the templated ExecuteSwitchImpl to call.
+//  Argument 2: x2: The value of DEX PC (memory address of the methods bytecode).
+ENTRY ExecuteSwitchImplAsm
+    SAVE_TWO_REGS_INCREASE_FRAME x19, xLR, 16
+    mov x19, x2                                   // x19 = DEX PC
+    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* x0 */, 19 /* x19 */, 0)
+    blr x1                                        // Call the wrapped method.
+    RESTORE_TWO_REGS_DECREASE_FRAME x19, xLR, 16
+    ret
+END ExecuteSwitchImplAsm
+
+    /*
+     * Jni dlsym lookup stub.
+     */
+    .extern artFindNativeMethod
+    .extern artFindNativeMethodRunnable
+ENTRY art_jni_dlsym_lookup_stub
+    // spill regs.
+    SAVE_ALL_ARGS_INCREASE_FRAME 2 * 8
+    stp   x29, x30, [sp, ALL_ARGS_SIZE]
+    .cfi_rel_offset x29, ALL_ARGS_SIZE
+    .cfi_rel_offset x30, ALL_ARGS_SIZE + 8
+    add   x29, sp, ALL_ARGS_SIZE
+
+    mov x0, xSELF   // pass Thread::Current()
+    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
+    // for @FastNative or @CriticalNative.
+    ldr   xIP0, [x0, #THREAD_TOP_QUICK_FRAME_OFFSET]      // uintptr_t tagged_quick_frame
+    bic   xIP0, xIP0, #TAGGED_JNI_SP_MASK                 // ArtMethod** sp
+    ldr   xIP0, [xIP0]                                    // ArtMethod* method
+    ldr   xIP0, [xIP0, #ART_METHOD_ACCESS_FLAGS_OFFSET]   // uint32_t access_flags
+    mov   xIP1, #(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
+    tst   xIP0, xIP1
+    b.ne  .Llookup_stub_fast_or_critical_native
+    bl    artFindNativeMethod
+    b     .Llookup_stub_continue
+    .Llookup_stub_fast_or_critical_native:
+    bl    artFindNativeMethodRunnable
+.Llookup_stub_continue:
+    mov   x17, x0    // store result in scratch reg.
+
+    // load spill regs.
+    ldp   x29, x30, [sp, #ALL_ARGS_SIZE]
+    .cfi_restore x29
+    .cfi_restore x30
+    RESTORE_ALL_ARGS_DECREASE_FRAME 2 * 8
+
+    cbz   x17, 1f   // is method code null ?
+    br    x17       // if non-null, tail call to method's code.
+
+1:
+    ret             // restore regs and return to caller to handle exception.
+END art_jni_dlsym_lookup_stub
diff --git a/runtime/arch/arm64/quick_entrypoints_arm64.S b/runtime/arch/arm64/quick_entrypoints_arm64.S
index 3bb3b693d9..1302b5b036 100644
--- a/runtime/arch/arm64/quick_entrypoints_arm64.S
+++ b/runtime/arch/arm64/quick_entrypoints_arm64.S
@@ -32,20 +32,6 @@
     .cfi_adjust_cfa_offset -(\frame_adjustment)
 .endm
 
-.macro SAVE_TWO_REGS_INCREASE_FRAME reg1, reg2, frame_adjustment
-    stp \reg1, \reg2, [sp, #-(\frame_adjustment)]!
-    .cfi_adjust_cfa_offset (\frame_adjustment)
-    .cfi_rel_offset \reg1, 0
-    .cfi_rel_offset \reg2, 8
-.endm
-
-.macro RESTORE_TWO_REGS_DECREASE_FRAME reg1, reg2, frame_adjustment
-    ldp \reg1, \reg2, [sp], #(\frame_adjustment)
-    .cfi_restore \reg1
-    .cfi_restore \reg2
-    .cfi_adjust_cfa_offset -(\frame_adjustment)
-.endm
-
 .macro POP_SAVE_REFS_ONLY_FRAME
     DECREASE_FRAME 96
 .endm
@@ -2452,7 +2438,27 @@ ENTRY art_quick_invoke_polymorphic
     REFRESH_MARKING_REGISTER
     fmov    d0, x0                      // Result is in x0. Copy to floating return register.
     RETURN_OR_DELIVER_PENDING_EXCEPTION
-END  art_quick_invoke_polymorphic
+END art_quick_invoke_polymorphic
+
+    /*
+     * Slow path for MethodHandle.invokeExact intrinsic.
+     * That intrinsic has a custom calling convention: the argument allocation doesn't start from
+     * the receiver (MethodHandle) object, but from the argument following it. That's done to match
+     * expectation of the underlying method when MethodHandle targets a method. That also affects
+     * the way arguments are spilled onto the stack.
+     */
+.extern artInvokePolymorphicWithHiddenReceiver
+ENTRY art_quick_invoke_polymorphic_with_hidden_receiver
+                                        // On entry: w0 := receiver
+    SETUP_SAVE_REFS_AND_ARGS_FRAME      // Save callee saves in case allocation triggers GC.
+    mov     x1, xSELF                   // x1 := Thread::Current()
+    mov     x2, sp                      // x2 := SP
+    bl      artInvokePolymorphicWithHiddenReceiver // invoke with (receiver, thread, save_area)
+    RESTORE_SAVE_REFS_AND_ARGS_FRAME
+    REFRESH_MARKING_REGISTER
+    fmov    d0, x0                      // Result is in x0. Copy to floating return register.
+    RETURN_OR_DELIVER_PENDING_EXCEPTION
+END art_quick_invoke_polymorphic_with_hidden_receiver
 
 .extern artInvokeCustom
 ENTRY art_quick_invoke_custom
@@ -2467,19 +2473,6 @@ ENTRY art_quick_invoke_custom
     RETURN_OR_DELIVER_PENDING_EXCEPTION
 END  art_quick_invoke_custom
 
-// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
-//  Argument 0: x0: The context pointer for ExecuteSwitchImpl.
-//  Argument 1: x1: Pointer to the templated ExecuteSwitchImpl to call.
-//  Argument 2: x2: The value of DEX PC (memory address of the methods bytecode).
-ENTRY ExecuteSwitchImplAsm
-    SAVE_TWO_REGS_INCREASE_FRAME x19, xLR, 16
-    mov x19, x2                                   // x19 = DEX PC
-    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* x0 */, 19 /* x19 */, 0)
-    blr x1                                        // Call the wrapped method.
-    RESTORE_TWO_REGS_DECREASE_FRAME x19, xLR, 16
-    ret
-END ExecuteSwitchImplAsm
-
 // x0 contains the class, x8 contains the inline cache. x9-x15 can be used.
 ENTRY art_quick_update_inline_cache
 #if (INLINE_CACHE_SIZE != 5)
diff --git a/runtime/arch/context-inl.h b/runtime/arch/context-inl.h
index fd81ae28fb..087075ea38 100644
--- a/runtime/arch/context-inl.h
+++ b/runtime/arch/context-inl.h
@@ -17,36 +17,42 @@
 // This file is special-purpose for cases where you want a stack context. Most users should use
 // Context::Create().
 
+#include "arch/instruction_set.h"
 #include "context.h"
 
 #ifndef ART_RUNTIME_ARCH_CONTEXT_INL_H_
 #define ART_RUNTIME_ARCH_CONTEXT_INL_H_
 
-#if defined(__arm__)
 #include "arm/context_arm.h"
-#define RUNTIME_CONTEXT_TYPE arm::ArmContext
-#elif defined(__aarch64__)
 #include "arm64/context_arm64.h"
-#define RUNTIME_CONTEXT_TYPE arm64::Arm64Context
-#elif defined(__riscv)
 #include "riscv64/context_riscv64.h"
-#define RUNTIME_CONTEXT_TYPE riscv64::Riscv64Context
-#elif defined(__i386__)
 #include "x86/context_x86.h"
-#define RUNTIME_CONTEXT_TYPE x86::X86Context
-#elif defined(__x86_64__)
 #include "x86_64/context_x86_64.h"
-#define RUNTIME_CONTEXT_TYPE x86_64::X86_64Context
-#else
-#error unimplemented
-#endif
 
 namespace art HIDDEN {
 
-using RuntimeContextType = RUNTIME_CONTEXT_TYPE;
+namespace detail {
 
-}  // namespace art
+template <InstructionSet>
+struct ContextSelector;
+
+template <>
+struct ContextSelector<InstructionSet::kArm> { using type = arm::ArmContext; };
+template <>
+struct ContextSelector<InstructionSet::kArm64> { using type = arm64::Arm64Context; };
+template <>
+struct ContextSelector<InstructionSet::kRiscv64> { using type = riscv64::Riscv64Context; };
+template <>
+struct ContextSelector<InstructionSet::kX86> { using type = x86::X86Context; };
+template <>
+struct ContextSelector<InstructionSet::kX86_64> { using type = x86_64::X86_64Context; };
+
+}  // namespace detail
 
-#undef RUNTIME_CONTEXT_TYPE
+template <InstructionSet Isa>
+using RuntimeContextTypeArch = typename detail::ContextSelector<Isa>::type;
+using RuntimeContextType = RuntimeContextTypeArch<kRuntimeQuickCodeISA>;
+
+}  // namespace art
 
 #endif  // ART_RUNTIME_ARCH_CONTEXT_INL_H_
diff --git a/runtime/arch/context.cc b/runtime/arch/context.cc
index 1d69691619..f09b8eff17 100644
--- a/runtime/arch/context.cc
+++ b/runtime/arch/context.cc
@@ -22,6 +22,8 @@ Context* Context::Create() {
   return new RuntimeContextType;
 }
 
+// Copy the GPRs and FPRs from the given thread's context to the given buffers. This function
+// expects that a long jump (art_quick_do_long_jump) is called afterwards.
 extern "C" void artContextCopyForLongJump(Context* context, uintptr_t* gprs, uintptr_t* fprs) {
   context->CopyContextTo(gprs, fprs);
   // Once the context has been copied, it is no longer needed.
diff --git a/runtime/arch/context.h b/runtime/arch/context.h
index 1a82aa8553..55988d0a6e 100644
--- a/runtime/arch/context.h
+++ b/runtime/arch/context.h
@@ -20,7 +20,9 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "arch/instruction_set.h"
 #include "base/macros.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 
 namespace art HIDDEN {
 
@@ -38,12 +40,14 @@ class Context {
   // Re-initializes the registers for context re-use.
   virtual void Reset() = 0;
 
+  template <InstructionSet kIsa>
   static uintptr_t* CalleeSaveAddress(uint8_t* frame, int num, size_t frame_size) {
+    static constexpr size_t kPointerSize = static_cast<size_t>(GetInstructionSetPointerSize(kIsa));
     // Callee saves are held at the top of the frame
-    uint8_t* save_addr = frame + frame_size - ((num + 1) * sizeof(void*));
-#if defined(__i386__) || defined(__x86_64__)
-    save_addr -= sizeof(void*);  // account for return address
-#endif
+    uint8_t* save_addr = frame + frame_size - ((num + 1) * kPointerSize);
+    if (kIsa == InstructionSet::kX86 || kIsa == InstructionSet::kX86_64) {
+      save_addr -= kPointerSize;  // account for return address
+    }
     return reinterpret_cast<uintptr_t*>(save_addr);
   }
 
@@ -102,9 +106,6 @@ class Context {
   };
 };
 
-// Copy the GPRs and FPRs from the context to the given buffers.
-extern "C" void artContextCopyForLongJump(Context* context, uintptr_t* gprs, uintptr_t* fprs);
-
 }  // namespace art
 
 #endif  // ART_RUNTIME_ARCH_CONTEXT_H_
diff --git a/runtime/arch/riscv64/asm_support_riscv64.S b/runtime/arch/riscv64/asm_support_riscv64.S
index f8e3b488b5..accdb0510a 100644
--- a/runtime/arch/riscv64/asm_support_riscv64.S
+++ b/runtime/arch/riscv64/asm_support_riscv64.S
@@ -161,6 +161,61 @@
 .endm
 
 
+// 8 argument GPRS: a0 - a7 and 8 argument FPRs: fa0 - fa7
+#define ALL_ARGS_SIZE (8 * (8 + 8))
+
+
+.macro SAVE_ALL_ARGS_INCREASE_FRAME extra_space
+    // Reserve space for all argument registers, plus the extra space.
+    INCREASE_FRAME (ALL_ARGS_SIZE + \extra_space)
+
+    // Argument GPRs a0 - a7.
+    sd    a0, (8*0)(sp)
+    sd    a1, (8*1)(sp)
+    sd    a2, (8*2)(sp)
+    sd    a3, (8*3)(sp)
+    sd    a4, (8*4)(sp)
+    sd    a5, (8*5)(sp)
+    sd    a6, (8*6)(sp)
+    sd    a7, (8*7)(sp)
+
+    // Argument FPRs fa0 - fa7.
+    fsd   fa0, (8*8)(sp)
+    fsd   fa1, (8*9)(sp)
+    fsd   fa2, (8*10)(sp)
+    fsd   fa3, (8*11)(sp)
+    fsd   fa4, (8*12)(sp)
+    fsd   fa5, (8*13)(sp)
+    fsd   fa6, (8*14)(sp)
+    fsd   fa7, (8*15)(sp)
+.endm
+
+
+.macro RESTORE_ALL_ARGS_DECREASE_FRAME extra_space
+    // Argument GPRs a0 - a7.
+    ld    a0, (8*0)(sp)
+    ld    a1, (8*1)(sp)
+    ld    a2, (8*2)(sp)
+    ld    a3, (8*3)(sp)
+    ld    a4, (8*4)(sp)
+    ld    a5, (8*5)(sp)
+    ld    a6, (8*6)(sp)
+    ld    a7, (8*7)(sp)
+
+    // Argument FPRs fa0 - fa7.
+    fld   fa0, (8*8)(sp)
+    fld   fa1, (8*9)(sp)
+    fld   fa2, (8*10)(sp)
+    fld   fa3, (8*11)(sp)
+    fld   fa4, (8*12)(sp)
+    fld   fa5, (8*13)(sp)
+    fld   fa6, (8*14)(sp)
+    fld   fa7, (8*15)(sp)
+
+    DECREASE_FRAME (ALL_ARGS_SIZE + \extra_space)
+.endm
+
+
 .macro LOAD_RUNTIME_INSTANCE reg
 #if __has_feature(hwaddress_sanitizer)
 #error "ART does not support HWASAN on RISC-V yet"
diff --git a/runtime/arch/riscv64/context_riscv64.cc b/runtime/arch/riscv64/context_riscv64.cc
index dceebe1e1f..779bb17e08 100644
--- a/runtime/arch/riscv64/context_riscv64.cc
+++ b/runtime/arch/riscv64/context_riscv64.cc
@@ -45,19 +45,20 @@ void Riscv64Context::Reset() {
 void Riscv64Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& frame_info) {
   // RA is at top of the frame
   DCHECK_NE(frame_info.CoreSpillMask() & (1u << RA), 0u);
-  gprs_[RA] = CalleeSaveAddress(frame, 0, frame_info.FrameSizeInBytes());
+  const size_t frame_size = frame_info.FrameSizeInBytes();
+  gprs_[RA] = CalleeSaveAddress<InstructionSet::kRiscv64>(frame, 0, frame_size);
 
   // Core registers come first, from the highest down to the lowest, with the exception of RA/X1.
   int spill_pos = 1;
   for (uint32_t core_reg : HighToLowBits(frame_info.CoreSpillMask() & ~(1u << RA))) {
-    gprs_[core_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    gprs_[core_reg] = CalleeSaveAddress<InstructionSet::kRiscv64>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()));
 
   // FP registers come second, from the highest down to the lowest.
   for (uint32_t fp_reg : HighToLowBits(frame_info.FpSpillMask())) {
-    fprs_[fp_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    fprs_[fp_reg] = CalleeSaveAddress<InstructionSet::kRiscv64>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()) + POPCOUNT(frame_info.FpSpillMask()));
diff --git a/runtime/arch/riscv64/entrypoints_init_riscv64.cc b/runtime/arch/riscv64/entrypoints_init_riscv64.cc
index d75a873c61..d8424cc3ee 100644
--- a/runtime/arch/riscv64/entrypoints_init_riscv64.cc
+++ b/runtime/arch/riscv64/entrypoints_init_riscv64.cc
@@ -18,12 +18,10 @@
 
 #include "entrypoints/quick/quick_default_init_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 
 namespace art HIDDEN {
 
-// Cast entrypoints.
-extern "C" size_t artInstanceOfFromCode(mirror::Object* obj, mirror::Class* ref_class);
-
 // Read barrier entrypoints.
 // art_quick_read_barrier_mark_regX uses an non-standard calling convention: it
 // expects its input in register X and returns its result in that same register,
@@ -152,4 +150,9 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetReadBarrierForRootSlow(artReadBarrierForRootSlow);
 }
 
+void UpdateLowOverheadTraceEntrypoints([[maybe_unused]] QuickEntryPoints* qpoints,
+                                       [[maybe_unused]] bool enable) {
+  // This is a nop on this architecture. Low overhead tracing is only implemented for ARM64.
+}
+
 }  // namespace art
diff --git a/runtime/arch/riscv64/jni_entrypoints_riscv64.S b/runtime/arch/riscv64/jni_entrypoints_riscv64.S
index c1f855b4bf..2cec0b44a0 100644
--- a/runtime/arch/riscv64/jni_entrypoints_riscv64.S
+++ b/runtime/arch/riscv64/jni_entrypoints_riscv64.S
@@ -17,61 +17,6 @@
 #include "asm_support_riscv64.S"
 
 
-// 8 argument GPRS: a0 - a7 and 8 argument FPRs: fa0 - fa7
-#define ALL_ARGS_SIZE (8 * (8 + 8))
-
-
-.macro SAVE_ALL_ARGS_INCREASE_FRAME extra_space
-    // Reserve space for all argument registers, plus the extra space.
-    INCREASE_FRAME (ALL_ARGS_SIZE + \extra_space)
-
-    // Argument GPRs a0 - a7.
-    sd    a0, (8*0)(sp)
-    sd    a1, (8*1)(sp)
-    sd    a2, (8*2)(sp)
-    sd    a3, (8*3)(sp)
-    sd    a4, (8*4)(sp)
-    sd    a5, (8*5)(sp)
-    sd    a6, (8*6)(sp)
-    sd    a7, (8*7)(sp)
-
-    // Argument FPRs fa0 - fa7.
-    fsd   fa0, (8*8)(sp)
-    fsd   fa1, (8*9)(sp)
-    fsd   fa2, (8*10)(sp)
-    fsd   fa3, (8*11)(sp)
-    fsd   fa4, (8*12)(sp)
-    fsd   fa5, (8*13)(sp)
-    fsd   fa6, (8*14)(sp)
-    fsd   fa7, (8*15)(sp)
-.endm
-
-
-.macro RESTORE_ALL_ARGS_DECREASE_FRAME extra_space
-    // Argument GPRs a0 - a7.
-    ld    a0, (8*0)(sp)
-    ld    a1, (8*1)(sp)
-    ld    a2, (8*2)(sp)
-    ld    a3, (8*3)(sp)
-    ld    a4, (8*4)(sp)
-    ld    a5, (8*5)(sp)
-    ld    a6, (8*6)(sp)
-    ld    a7, (8*7)(sp)
-
-    // Argument FPRs fa0 - fa7.
-    fld   fa0, (8*8)(sp)
-    fld   fa1, (8*9)(sp)
-    fld   fa2, (8*10)(sp)
-    fld   fa3, (8*11)(sp)
-    fld   fa4, (8*12)(sp)
-    fld   fa5, (8*13)(sp)
-    fld   fa6, (8*14)(sp)
-    fld   fa7, (8*15)(sp)
-
-    DECREASE_FRAME (ALL_ARGS_SIZE + \extra_space)
-.endm
-
-
 .macro JNI_SAVE_MANAGED_ARGS_TRAMPOLINE name, cxx_name, arg1 = "none"
     .extern \cxx_name
 ENTRY \name
@@ -115,53 +60,18 @@ END \name
 .endm
 
 
-// JNI dlsym lookup stub.
-.extern artFindNativeMethod
-.extern artFindNativeMethodRunnable
-ENTRY art_jni_dlsym_lookup_stub
-    SAVE_ALL_ARGS_INCREASE_FRAME 2*8
-    SAVE_GPR fp, (ALL_ARGS_SIZE + 0)
-    SAVE_GPR ra, (ALL_ARGS_SIZE + 8)
-    add  fp, sp, ALL_ARGS_SIZE
-
-    // Call artFindNativeMethod for normal native.
-    // Call artFindNativeMethodRunnable for @FastNative or @CriticalNative.
-    // Both functions have a single argument: Thread::Current() in a0.
-    mv   a0, xSELF
-    ld   t0, THREAD_TOP_QUICK_FRAME_OFFSET(a0)   // uintptr_t tagged_quick_frame
-    andi t0, t0, ~TAGGED_JNI_SP_MASK             // ArtMethod** sp
-    ld   t0, (t0)                                // ArtMethod* method
-    lw   t0, ART_METHOD_ACCESS_FLAGS_OFFSET(t0)  // uint32_t access_flags
-    li   t1, (ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
-    and  t0, t0, t1
-    bnez t0, .Llookup_stub_fast_or_critical_native
-    call artFindNativeMethod
-    j    .Llookup_stub_continue
-
-.Llookup_stub_fast_or_critical_native:
-    call  artFindNativeMethodRunnable
-
-.Llookup_stub_continue:
-    mv    t0, a0  // store result in a temp reg.
-    RESTORE_GPR fp, (ALL_ARGS_SIZE + 0)
-    RESTORE_GPR ra, (ALL_ARGS_SIZE + 8)
-    RESTORE_ALL_ARGS_DECREASE_FRAME 2*8
-
-    beqz  t0, 1f  // is method code null?
-    jr    t0      // if non-null, tail call to method code.
-1:
-    ret           // restore regs and return to caller to handle exception.
-END art_jni_dlsym_lookup_stub
-
-
 // JNI dlsym lookup stub for @CriticalNative.
 ENTRY art_jni_dlsym_lookup_critical_stub
     // The hidden arg holding the tagged method is t0 (loaded by compiled JNI stub, compiled
     // managed code, or `art_quick_generic_jni_trampoline`). Bit 0 set means generic JNI.
     // For generic JNI we already have a managed frame, so we reuse the art_jni_dlsym_lookup_stub.
+    // Note: 'bnez' doesn't always have enough range (+/-4KB) to reach art_jni_dlsym_lookup_stub so
+    // 'tail' is used instead.
     andi  t6, t0, 1
-    bnez  t6, art_jni_dlsym_lookup_stub
+    beqz  t6, .Lcritical_not_generic_jni
+    tail  art_jni_dlsym_lookup_stub
 
+.Lcritical_not_generic_jni:
     // Save args, the hidden arg and caller PC. No CFI needed for args and the hidden arg.
     SAVE_ALL_ARGS_INCREASE_FRAME 2*8
     SAVE_GPR t0, (ALL_ARGS_SIZE + 0)
diff --git a/runtime/arch/riscv64/native_entrypoints_riscv64.S b/runtime/arch/riscv64/native_entrypoints_riscv64.S
new file mode 100644
index 0000000000..24c8205c0f
--- /dev/null
+++ b/runtime/arch/riscv64/native_entrypoints_riscv64.S
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "asm_support_riscv64.S"
+#include "interpreter/cfi_asm_support.h"
+
+/*
+ * This file contains all native entrypoints that are called using the native ABI and do not
+ * transition to the quick ABI. For example: the switch interpreter (using the native ABI) directly
+ * calls ExecuteSwitchImplAsm and this code will always return back to the switch interpreter,
+ * again using the native ABI. Because of this behaviour ExecuteSwitchImplAsm should be included in
+ * this file. This is done so these native entrypoints can be compiled independently to quick
+ * entrypoints for cases when the kRuntimeISA and kRuntimeQuickCodeISA do not match.
+ *
+ * See comment on StackType (thread.h) for definitions and examples of quick ABI/code and
+ * native ABI/code.
+ */
+
+// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
+//  Argument 0: a0: The context pointer for ExecuteSwitchImpl.
+//  Argument 1: a1: Pointer to the templated ExecuteSwitchImpl to call.
+//  Argument 2: a2: The value of DEX PC (memory address of the methods bytecode).
+ENTRY ExecuteSwitchImplAsm
+    INCREASE_FRAME 16
+    SAVE_GPR s1, 0
+    SAVE_GPR ra, 8
+
+    mv s1, a2   // s1 = DEX PC
+    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* a0 */, 9 /* s1, a.k.a. x9 */, 0)
+    jalr a1     // Call the wrapped method.
+
+    RESTORE_GPR s1, 0
+    RESTORE_GPR ra, 8
+    DECREASE_FRAME 16
+    ret
+END ExecuteSwitchImplAsm
+
+// JNI dlsym lookup stub.
+.extern artFindNativeMethod
+.extern artFindNativeMethodRunnable
+ENTRY art_jni_dlsym_lookup_stub
+    SAVE_ALL_ARGS_INCREASE_FRAME 2*8
+    SAVE_GPR fp, (ALL_ARGS_SIZE + 0)
+    SAVE_GPR ra, (ALL_ARGS_SIZE + 8)
+    add  fp, sp, ALL_ARGS_SIZE
+
+    // Call artFindNativeMethod for normal native.
+    // Call artFindNativeMethodRunnable for @FastNative or @CriticalNative.
+    // Both functions have a single argument: Thread::Current() in a0.
+    mv   a0, xSELF
+    ld   t0, THREAD_TOP_QUICK_FRAME_OFFSET(a0)   // uintptr_t tagged_quick_frame
+    andi t0, t0, ~TAGGED_JNI_SP_MASK             // ArtMethod** sp
+    ld   t0, (t0)                                // ArtMethod* method
+    lw   t0, ART_METHOD_ACCESS_FLAGS_OFFSET(t0)  // uint32_t access_flags
+    li   t1, (ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE)
+    and  t0, t0, t1
+    bnez t0, .Llookup_stub_fast_or_critical_native
+    call artFindNativeMethod
+    j    .Llookup_stub_continue
+
+.Llookup_stub_fast_or_critical_native:
+    call  artFindNativeMethodRunnable
+
+.Llookup_stub_continue:
+    mv    t0, a0  // store result in a temp reg.
+    RESTORE_GPR fp, (ALL_ARGS_SIZE + 0)
+    RESTORE_GPR ra, (ALL_ARGS_SIZE + 8)
+    RESTORE_ALL_ARGS_DECREASE_FRAME 2*8
+
+    beqz  t0, 1f  // is method code null?
+    jr    t0      // if non-null, tail call to method code.
+1:
+    ret           // restore regs and return to caller to handle exception.
+END art_jni_dlsym_lookup_stub
diff --git a/runtime/arch/riscv64/quick_entrypoints_riscv64.S b/runtime/arch/riscv64/quick_entrypoints_riscv64.S
index 06b9e9b7bb..49de49fa8c 100644
--- a/runtime/arch/riscv64/quick_entrypoints_riscv64.S
+++ b/runtime/arch/riscv64/quick_entrypoints_riscv64.S
@@ -21,26 +21,6 @@
 #include "arch/quick_field_entrypoints.S"
 
 
-// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
-//  Argument 0: a0: The context pointer for ExecuteSwitchImpl.
-//  Argument 1: a1: Pointer to the templated ExecuteSwitchImpl to call.
-//  Argument 2: a2: The value of DEX PC (memory address of the methods bytecode).
-ENTRY ExecuteSwitchImplAsm
-    INCREASE_FRAME 16
-    SAVE_GPR s1, 0
-    SAVE_GPR ra, 8
-
-    mv s1, a2   // s1 = DEX PC
-    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* a0 */, 9 /* s1, a.k.a. x9 */, 0)
-    jalr a1     // Call the wrapped method.
-
-    RESTORE_GPR s1, 0
-    RESTORE_GPR ra, 8
-    DECREASE_FRAME 16
-    ret
-END ExecuteSwitchImplAsm
-
-
 .macro INVOKE_STUB_CREATE_FRAME
     // Save RA, FP, xSELF (current thread), A4, A5 (they will be needed in the invoke stub return).
     INCREASE_FRAME 48
diff --git a/runtime/arch/x86/context_x86.cc b/runtime/arch/x86/context_x86.cc
index 40f1a4aa8d..cb915b190e 100644
--- a/runtime/arch/x86/context_x86.cc
+++ b/runtime/arch/x86/context_x86.cc
@@ -38,6 +38,7 @@ void X86Context::Reset() {
 }
 
 void X86Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& frame_info) {
+  const size_t frame_size = frame_info.FrameSizeInBytes();
   int spill_pos = 0;
 
   // Core registers come first, from the highest down to the lowest.
@@ -45,7 +46,7 @@ void X86Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& fra
       frame_info.CoreSpillMask() & ~(static_cast<uint32_t>(-1) << kNumberOfCpuRegisters);
   DCHECK_EQ(1, POPCOUNT(frame_info.CoreSpillMask() & ~core_regs));  // Return address spill.
   for (uint32_t core_reg : HighToLowBits(core_regs)) {
-    gprs_[core_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    gprs_[core_reg] = CalleeSaveAddress<InstructionSet::kX86>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()) - 1);
@@ -56,9 +57,9 @@ void X86Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& fra
   for (uint32_t fp_reg : HighToLowBits(fp_regs)) {
     // Two void* per XMM register.
     fprs_[2 * fp_reg] = reinterpret_cast<uint32_t*>(
-        CalleeSaveAddress(frame, spill_pos + 1, frame_info.FrameSizeInBytes()));
+        CalleeSaveAddress<InstructionSet::kX86>(frame, spill_pos + 1, frame_size));
     fprs_[2 * fp_reg + 1] = reinterpret_cast<uint32_t*>(
-        CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes()));
+        CalleeSaveAddress<InstructionSet::kX86>(frame, spill_pos, frame_size));
     spill_pos += 2;
   }
   DCHECK_EQ(spill_pos,
diff --git a/runtime/arch/x86/entrypoints_init_x86.cc b/runtime/arch/x86/entrypoints_init_x86.cc
index 032e9b84a4..237a55ce9d 100644
--- a/runtime/arch/x86/entrypoints_init_x86.cc
+++ b/runtime/arch/x86/entrypoints_init_x86.cc
@@ -128,4 +128,9 @@ void InitEntryPoints(JniEntryPoints* jpoints,
   qpoints->SetReadBarrierForRootSlow(art_quick_read_barrier_for_root_slow);
 }
 
+void UpdateLowOverheadTraceEntrypoints([[maybe_unused]] QuickEntryPoints* qpoints,
+                                       [[maybe_unused]] bool enable) {
+  // This is a nop on this architecture. Low overhead tracing is only implemented for ARM64.
+}
+
 }  // namespace art
diff --git a/runtime/arch/x86/instruction_set_features_x86.cc b/runtime/arch/x86/instruction_set_features_x86.cc
index 3f9978d942..2764d1ea26 100644
--- a/runtime/arch/x86/instruction_set_features_x86.cc
+++ b/runtime/arch/x86/instruction_set_features_x86.cc
@@ -49,6 +49,7 @@ static constexpr const char* x86_known_variants[] = {
     "goldmont-without-sha-xsaves",
     "tremont",
     "kabylake",
+    "alderlake",
     "default",
 };
 
@@ -60,6 +61,7 @@ static constexpr const char* x86_variants_with_ssse3[] = {
     "goldmont-plus",
     "goldmont-without-sha-xsaves",
     "tremont",
+    "alderlake",
     "kabylake",
 };
 
@@ -70,6 +72,7 @@ static constexpr const char* x86_variants_with_sse4_1[] = {
     "goldmont-plus",
     "goldmont-without-sha-xsaves",
     "tremont",
+    "alderlake",
     "kabylake",
 };
 
@@ -80,6 +83,7 @@ static constexpr const char* x86_variants_with_sse4_2[] = {
     "goldmont-plus",
     "goldmont-without-sha-xsaves",
     "tremont",
+    "alderlake",
     "kabylake",
 };
 
@@ -90,14 +94,17 @@ static constexpr const char* x86_variants_with_popcnt[] = {
     "goldmont-plus",
     "goldmont-without-sha-xsaves",
     "tremont",
+    "alderlake",
     "kabylake",
 };
 static constexpr const char* x86_variants_with_avx[] = {
     "kabylake",
+    "alderlake",
 };
 
 static constexpr const char* x86_variants_with_avx2[] = {
     "kabylake",
+    "alderlake",
 };
 
 X86FeaturesUniquePtr X86InstructionSetFeatures::Create(bool x86_64,
diff --git a/runtime/arch/x86/instruction_set_features_x86_test.cc b/runtime/arch/x86/instruction_set_features_x86_test.cc
index ddfec9a81e..e6d096cdd3 100644
--- a/runtime/arch/x86/instruction_set_features_x86_test.cc
+++ b/runtime/arch/x86/instruction_set_features_x86_test.cc
@@ -209,4 +209,27 @@ TEST(X86InstructionSetFeaturesTest, X86FeaturesFromKabylakeVariant) {
 
   EXPECT_FALSE(x86_64_features->Equals(x86_features.get()));
 }
+
+TEST(X86InstructionSetFeaturesTest, X86FeaturesFromAlderlakeVariant) {
+  // Build features for a 32-bit alderlake x86 processor.
+  std::string error_msg;
+  std::unique_ptr<const InstructionSetFeatures> x86_features(
+      InstructionSetFeatures::FromVariant(InstructionSet::kX86, "alderlake", &error_msg));
+  ASSERT_TRUE(x86_features.get() != nullptr) << error_msg;
+  EXPECT_EQ(x86_features->GetInstructionSet(), InstructionSet::kX86);
+  EXPECT_TRUE(x86_features->Equals(x86_features.get()));
+  EXPECT_STREQ("ssse3,sse4.1,sse4.2,avx,avx2,popcnt", x86_features->GetFeatureString().c_str());
+  EXPECT_EQ(x86_features->AsBitmap(), 63U);
+
+  // Build features for a 64-bit x86-64 alderlake processor.
+  std::unique_ptr<const InstructionSetFeatures> x86_64_features(
+      InstructionSetFeatures::FromVariant(InstructionSet::kX86_64, "alderlake", &error_msg));
+  ASSERT_TRUE(x86_64_features.get() != nullptr) << error_msg;
+  EXPECT_EQ(x86_64_features->GetInstructionSet(), InstructionSet::kX86_64);
+  EXPECT_TRUE(x86_64_features->Equals(x86_64_features.get()));
+  EXPECT_STREQ("ssse3,sse4.1,sse4.2,avx,avx2,popcnt", x86_64_features->GetFeatureString().c_str());
+  EXPECT_EQ(x86_64_features->AsBitmap(), 63U);
+
+  EXPECT_FALSE(x86_64_features->Equals(x86_features.get()));
+}
 }  // namespace art
diff --git a/runtime/arch/x86/jni_entrypoints_x86.S b/runtime/arch/x86/jni_entrypoints_x86.S
index 09b4d5a0f5..531f3c7d97 100644
--- a/runtime/arch/x86/jni_entrypoints_x86.S
+++ b/runtime/arch/x86/jni_entrypoints_x86.S
@@ -87,35 +87,6 @@ DEFINE_FUNCTION \name
 END_FUNCTION \name
 END_MACRO
 
-    /*
-     * Jni dlsym lookup stub.
-     */
-DEFINE_FUNCTION art_jni_dlsym_lookup_stub
-    INCREASE_FRAME 8              // Align stack.
-    pushl %fs:THREAD_SELF_OFFSET  // Pass Thread::Current().
-    CFI_ADJUST_CFA_OFFSET(4)
-    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
-    // for @FastNative or @CriticalNative.
-    movl (%esp), %eax                                // Thread* self
-    movl THREAD_TOP_QUICK_FRAME_OFFSET(%eax), %eax   // uintptr_t tagged_quick_frame
-    andl LITERAL(TAGGED_JNI_SP_MASK_TOGGLED32), %eax // ArtMethod** sp
-    movl (%eax), %eax                                // ArtMethod* method
-    testl LITERAL(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE), \
-          ART_METHOD_ACCESS_FLAGS_OFFSET(%eax)
-    jne .Llookup_stub_fast_or_critical_native
-    call SYMBOL(artFindNativeMethod)  // (Thread*)
-    jmp .Llookup_stub_continue
-.Llookup_stub_fast_or_critical_native:
-    call SYMBOL(artFindNativeMethodRunnable)  // (Thread*)
-.Llookup_stub_continue:
-    DECREASE_FRAME 12             // Remove argument & padding.
-    testl %eax, %eax              // Check if returned method code is null.
-    jz .Lno_native_code_found     // If null, jump to return to handle.
-    jmp *%eax                     // Otherwise, tail call to intended method.
-.Lno_native_code_found:
-    ret
-END_FUNCTION art_jni_dlsym_lookup_stub
-
     /*
      * Jni dlsym lookup stub for @CriticalNative.
      */
diff --git a/runtime/arch/x86/native_entrypoints_x86.S b/runtime/arch/x86/native_entrypoints_x86.S
new file mode 100644
index 0000000000..9d1c41a069
--- /dev/null
+++ b/runtime/arch/x86/native_entrypoints_x86.S
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "asm_support_x86.S"
+#include "interpreter/cfi_asm_support.h"
+
+/*
+ * This file contains all native entrypoints that are called using the native ABI and do not
+ * transition to the quick ABI. For example: the switch interpreter (using the native ABI) directly
+ * calls ExecuteSwitchImplAsm and this code will always return back to the switch interpreter,
+ * again using the native ABI. Because of this behaviour ExecuteSwitchImplAsm should be included in
+ * this file. This is done so these native entrypoints can be compiled independently to quick
+ * entrypoints for cases when the kRuntimeISA and kRuntimeQuickCodeISA do not match.
+ *
+ * See comment on StackType (thread.h) for definitions and examples of quick ABI/code and
+ * native ABI/code.
+ */
+
+// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
+//  Argument 0: ESP+4: The context pointer for ExecuteSwitchImpl.
+//  Argument 1: ESP+8: Pointer to the templated ExecuteSwitchImpl to call.
+//  Argument 2: ESP+12: The value of DEX PC (memory address of the methods bytecode).
+DEFINE_FUNCTION ExecuteSwitchImplAsm
+    PUSH ebx                 // Spill EBX; Increments ESP, so arg0 is at ESP+8 now.
+    mov 12(%esp), %eax       // EAX = C++ templated interpreter function
+    mov 16(%esp), %ebx       // EBX = DEX PC (callee save register)
+    mov 8(%esp), %ecx        // ECX = Context argument for the function
+    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* EAX */, 3 /* EBX */, 0)
+
+    sub LITERAL(4), %esp     // Alignment padding
+    CFI_ADJUST_CFA_OFFSET(4)
+    push %ecx                // Push argument
+    CFI_ADJUST_CFA_OFFSET(4)
+    call *%eax               // Call the wrapped function
+    addl LITERAL(8), %esp
+    CFI_ADJUST_CFA_OFFSET(-8)
+
+    POP ebx                  // Restore EBX
+    ret
+END_FUNCTION ExecuteSwitchImplAsm
+
+    /*
+     * Jni dlsym lookup stub.
+     */
+DEFINE_FUNCTION art_jni_dlsym_lookup_stub
+    INCREASE_FRAME 8              // Align stack.
+    pushl %fs:THREAD_SELF_OFFSET  // Pass Thread::Current().
+    CFI_ADJUST_CFA_OFFSET(4)
+    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
+    // for @FastNative or @CriticalNative.
+    movl (%esp), %eax                                // Thread* self
+    movl THREAD_TOP_QUICK_FRAME_OFFSET(%eax), %eax   // uintptr_t tagged_quick_frame
+    andl LITERAL(TAGGED_JNI_SP_MASK_TOGGLED32), %eax // ArtMethod** sp
+    movl (%eax), %eax                                // ArtMethod* method
+    testl LITERAL(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE), \
+          ART_METHOD_ACCESS_FLAGS_OFFSET(%eax)
+    jne .Llookup_stub_fast_or_critical_native
+    call SYMBOL(artFindNativeMethod)  // (Thread*)
+    jmp .Llookup_stub_continue
+.Llookup_stub_fast_or_critical_native:
+    call SYMBOL(artFindNativeMethodRunnable)  // (Thread*)
+.Llookup_stub_continue:
+    DECREASE_FRAME 12             // Remove argument & padding.
+    testl %eax, %eax              // Check if returned method code is null.
+    jz .Lno_native_code_found     // If null, jump to return to handle.
+    jmp *%eax                     // Otherwise, tail call to intended method.
+.Lno_native_code_found:
+    ret
+END_FUNCTION art_jni_dlsym_lookup_stub
diff --git a/runtime/arch/x86/quick_entrypoints_x86.S b/runtime/arch/x86/quick_entrypoints_x86.S
index d5c186e1ad..1078480c8c 100644
--- a/runtime/arch/x86/quick_entrypoints_x86.S
+++ b/runtime/arch/x86/quick_entrypoints_x86.S
@@ -2132,29 +2132,6 @@ DEFINE_FUNCTION art_quick_invoke_custom
     RETURN_OR_DELIVER_PENDING_EXCEPTION
 END_FUNCTION art_quick_invoke_custom
 
-// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
-//  Argument 0: ESP+4: The context pointer for ExecuteSwitchImpl.
-//  Argument 1: ESP+8: Pointer to the templated ExecuteSwitchImpl to call.
-//  Argument 2: ESP+12: The value of DEX PC (memory address of the methods bytecode).
-DEFINE_FUNCTION ExecuteSwitchImplAsm
-    PUSH ebx                 // Spill EBX; Increments ESP, so arg0 is at ESP+8 now.
-    mov 12(%esp), %eax       // EAX = C++ templated interpreter function
-    mov 16(%esp), %ebx       // EBX = DEX PC (callee save register)
-    mov 8(%esp), %ecx        // ECX = Context argument for the function
-    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* EAX */, 3 /* EBX */, 0)
-
-    sub LITERAL(4), %esp     // Alignment padding
-    CFI_ADJUST_CFA_OFFSET(4)
-    push %ecx                // Push argument
-    CFI_ADJUST_CFA_OFFSET(4)
-    call *%eax               // Call the wrapped function
-    addl LITERAL(8), %esp
-    CFI_ADJUST_CFA_OFFSET(-8)
-
-    POP ebx                  // Restore EBX
-    ret
-END_FUNCTION ExecuteSwitchImplAsm
-
 // On entry: eax is the class, ebp is the inline cache.
 DEFINE_FUNCTION art_quick_update_inline_cache
 #if (INLINE_CACHE_SIZE != 5)
diff --git a/runtime/arch/x86_64/context_x86_64.cc b/runtime/arch/x86_64/context_x86_64.cc
index d40395bc8b..f6a3720d55 100644
--- a/runtime/arch/x86_64/context_x86_64.cc
+++ b/runtime/arch/x86_64/context_x86_64.cc
@@ -37,6 +37,7 @@ void X86_64Context::Reset() {
 }
 
 void X86_64Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo& frame_info) {
+  const size_t frame_size = frame_info.FrameSizeInBytes();
   int spill_pos = 0;
 
   // Core registers come first, from the highest down to the lowest.
@@ -44,7 +45,7 @@ void X86_64Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo&
       frame_info.CoreSpillMask() & ~(static_cast<uint32_t>(-1) << kNumberOfCpuRegisters);
   DCHECK_EQ(1, POPCOUNT(frame_info.CoreSpillMask() & ~core_regs));  // Return address spill.
   for (uint32_t core_reg : HighToLowBits(core_regs)) {
-    gprs_[core_reg] = CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes());
+    gprs_[core_reg] = CalleeSaveAddress<InstructionSet::kX86_64>(frame, spill_pos, frame_size);
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos, POPCOUNT(frame_info.CoreSpillMask()) - 1);
@@ -54,7 +55,7 @@ void X86_64Context::FillCalleeSaves(uint8_t* frame, const QuickMethodFrameInfo&
   DCHECK_EQ(0u, fp_regs & (static_cast<uint32_t>(-1) << kNumberOfFloatRegisters));
   for (uint32_t fp_reg : HighToLowBits(fp_regs)) {
     fprs_[fp_reg] = reinterpret_cast<uint64_t*>(
-        CalleeSaveAddress(frame, spill_pos, frame_info.FrameSizeInBytes()));
+        CalleeSaveAddress<InstructionSet::kX86_64>(frame, spill_pos, frame_size));
     ++spill_pos;
   }
   DCHECK_EQ(spill_pos,
diff --git a/runtime/arch/x86_64/entrypoints_init_x86_64.cc b/runtime/arch/x86_64/entrypoints_init_x86_64.cc
index 9652f43c7f..c00ecbd203 100644
--- a/runtime/arch/x86_64/entrypoints_init_x86_64.cc
+++ b/runtime/arch/x86_64/entrypoints_init_x86_64.cc
@@ -17,13 +17,13 @@
 #include <math.h>
 
 #include "entrypoints/jni/jni_entrypoints.h"
-#include "entrypoints/math_entrypoints.h"
 #include "entrypoints/quick/quick_alloc_entrypoints.h"
 #include "entrypoints/quick/quick_default_externs.h"
 #if !defined(__APPLE__)
 #include "entrypoints/quick/quick_default_init_entrypoints.h"
 #endif
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "interpreter/interpreter.h"
 
@@ -147,4 +147,9 @@ void InitEntryPoints(JniEntryPoints* jpoints,
 #endif  // __APPLE__
 }
 
+void UpdateLowOverheadTraceEntrypoints([[maybe_unused]] QuickEntryPoints* qpoints,
+                                       [[maybe_unused]] bool enable) {
+  // This is a nop on this architecture. Low overhead tracing is only implemented for ARM64.
+}
+
 }  // namespace art
diff --git a/runtime/arch/x86_64/jni_entrypoints_x86_64.S b/runtime/arch/x86_64/jni_entrypoints_x86_64.S
index a635de8c28..49b59bfa80 100644
--- a/runtime/arch/x86_64/jni_entrypoints_x86_64.S
+++ b/runtime/arch/x86_64/jni_entrypoints_x86_64.S
@@ -91,66 +91,6 @@ DEFINE_FUNCTION \name
 END_FUNCTION \name
 END_MACRO
 
-    /*
-     * Jni dlsym lookup stub.
-     */
-DEFINE_FUNCTION art_jni_dlsym_lookup_stub
-    // Save callee and GPR args.
-    PUSH_ARG r9   // Arg.
-    PUSH_ARG r8   // Arg.
-    PUSH_ARG rdi  // Arg. (JniEnv for normal and @FastNative)
-    PUSH_ARG rsi  // Arg.
-    PUSH_ARG rdx  // Arg.
-    PUSH_ARG rcx  // Arg.
-    // Create space for FPR args, plus padding for alignment
-    INCREASE_FRAME 72
-    // Save FPRs.
-    movq %xmm0, 0(%rsp)
-    movq %xmm1, 8(%rsp)
-    movq %xmm2, 16(%rsp)
-    movq %xmm3, 24(%rsp)
-    movq %xmm4, 32(%rsp)
-    movq %xmm5, 40(%rsp)
-    movq %xmm6, 48(%rsp)
-    movq %xmm7, 56(%rsp)
-    // prepare call
-    movq %gs:THREAD_SELF_OFFSET, %rdi      // RDI := Thread::Current()
-    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
-    // for @FastNative or @CriticalNative.
-    movq THREAD_TOP_QUICK_FRAME_OFFSET(%rdi), %rax   // uintptr_t tagged_quick_frame
-    andq LITERAL(TAGGED_JNI_SP_MASK_TOGGLED64), %rax // ArtMethod** sp
-    movq (%rax), %rax                                // ArtMethod* method
-    testl LITERAL(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE), \
-          ART_METHOD_ACCESS_FLAGS_OFFSET(%rax)
-    jne .Llookup_stub_fast_or_critical_native
-    call SYMBOL(artFindNativeMethod)  // (Thread*)
-    jmp .Llookup_stub_continue
-.Llookup_stub_fast_or_critical_native:
-    call SYMBOL(artFindNativeMethodRunnable)  // (Thread*)
-.Llookup_stub_continue:
-    // restore arguments
-    movq 0(%rsp), %xmm0
-    movq 8(%rsp), %xmm1
-    movq 16(%rsp), %xmm2
-    movq 24(%rsp), %xmm3
-    movq 32(%rsp), %xmm4
-    movq 40(%rsp), %xmm5
-    movq 48(%rsp), %xmm6
-    movq 56(%rsp), %xmm7
-    DECREASE_FRAME 72
-    POP_ARG rcx  // Arg.
-    POP_ARG rdx  // Arg.
-    POP_ARG rsi  // Arg.
-    POP_ARG rdi  // Arg. (JniEnv for normal and @FastNative)
-    POP_ARG r8   // Arg.
-    POP_ARG r9   // Arg.
-    testq %rax, %rax              // check if returned method code is null
-    jz .Lno_native_code_found     // if null, jump to return to handle
-    jmp *%rax                     // otherwise, tail call to intended method
-.Lno_native_code_found:
-    ret
-END_FUNCTION art_jni_dlsym_lookup_stub
-
     /*
      * Jni dlsym lookup stub for @CriticalNative.
      */
diff --git a/runtime/arch/x86_64/native_entrypoints_x86_64.S b/runtime/arch/x86_64/native_entrypoints_x86_64.S
new file mode 100644
index 0000000000..12194ef97c
--- /dev/null
+++ b/runtime/arch/x86_64/native_entrypoints_x86_64.S
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "asm_support_x86_64.S"
+#include "interpreter/cfi_asm_support.h"
+
+/*
+ * This file contains all native entrypoints that are called using the native ABI and do not
+ * transition to the quick ABI. For example: the switch interpreter (using the native ABI) directly
+ * calls ExecuteSwitchImplAsm and this code will always return back to the switch interpreter,
+ * again using the native ABI. Because of this behaviour ExecuteSwitchImplAsm should be included in
+ * this file. This is done so these native entrypoints can be compiled independently to quick
+ * entrypoints for cases when the kRuntimeISA and kRuntimeQuickCodeISA do not match.
+ *
+ * See comment on StackType (thread.h) for definitions and examples of quick ABI/code and
+ * native ABI/code.
+ */
+
+// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
+//  Argument 0: RDI: The context pointer for ExecuteSwitchImpl.
+//  Argument 1: RSI: Pointer to the templated ExecuteSwitchImpl to call.
+//  Argument 2: RDX: The value of DEX PC (memory address of the methods bytecode).
+DEFINE_FUNCTION ExecuteSwitchImplAsm
+    PUSH rbx                 // Spill RBX
+    movq %rdx, %rbx          // RBX = DEX PC (callee save register)
+    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* RAX */, 3 /* RBX */, 0)
+
+    call *%rsi               // Call the wrapped function
+
+    POP rbx                  // Restore RBX
+    ret
+END_FUNCTION ExecuteSwitchImplAsm
+
+    /*
+     * Jni dlsym lookup stub.
+     */
+DEFINE_FUNCTION art_jni_dlsym_lookup_stub
+    // Save callee and GPR args.
+    PUSH_ARG r9   // Arg.
+    PUSH_ARG r8   // Arg.
+    PUSH_ARG rdi  // Arg. (JniEnv for normal and @FastNative)
+    PUSH_ARG rsi  // Arg.
+    PUSH_ARG rdx  // Arg.
+    PUSH_ARG rcx  // Arg.
+    // Create space for FPR args, plus padding for alignment
+    INCREASE_FRAME 72
+    // Save FPRs.
+    movq %xmm0, 0(%rsp)
+    movq %xmm1, 8(%rsp)
+    movq %xmm2, 16(%rsp)
+    movq %xmm3, 24(%rsp)
+    movq %xmm4, 32(%rsp)
+    movq %xmm5, 40(%rsp)
+    movq %xmm6, 48(%rsp)
+    movq %xmm7, 56(%rsp)
+    // prepare call
+    movq %gs:THREAD_SELF_OFFSET, %rdi      // RDI := Thread::Current()
+    // Call artFindNativeMethod() for normal native and artFindNativeMethodRunnable()
+    // for @FastNative or @CriticalNative.
+    movq THREAD_TOP_QUICK_FRAME_OFFSET(%rdi), %rax   // uintptr_t tagged_quick_frame
+    andq LITERAL(TAGGED_JNI_SP_MASK_TOGGLED64), %rax // ArtMethod** sp
+    movq (%rax), %rax                                // ArtMethod* method
+    testl LITERAL(ACCESS_FLAGS_METHOD_IS_FAST_NATIVE | ACCESS_FLAGS_METHOD_IS_CRITICAL_NATIVE), \
+          ART_METHOD_ACCESS_FLAGS_OFFSET(%rax)
+    jne .Llookup_stub_fast_or_critical_native
+    call SYMBOL(artFindNativeMethod)  // (Thread*)
+    jmp .Llookup_stub_continue
+.Llookup_stub_fast_or_critical_native:
+    call SYMBOL(artFindNativeMethodRunnable)  // (Thread*)
+.Llookup_stub_continue:
+    // restore arguments
+    movq 0(%rsp), %xmm0
+    movq 8(%rsp), %xmm1
+    movq 16(%rsp), %xmm2
+    movq 24(%rsp), %xmm3
+    movq 32(%rsp), %xmm4
+    movq 40(%rsp), %xmm5
+    movq 48(%rsp), %xmm6
+    movq 56(%rsp), %xmm7
+    DECREASE_FRAME 72
+    POP_ARG rcx  // Arg.
+    POP_ARG rdx  // Arg.
+    POP_ARG rsi  // Arg.
+    POP_ARG rdi  // Arg. (JniEnv for normal and @FastNative)
+    POP_ARG r8   // Arg.
+    POP_ARG r9   // Arg.
+    testq %rax, %rax              // check if returned method code is null
+    jz .Lno_native_code_found     // if null, jump to return to handle
+    jmp *%rax                     // otherwise, tail call to intended method
+.Lno_native_code_found:
+    ret
+END_FUNCTION art_jni_dlsym_lookup_stub
diff --git a/runtime/arch/x86_64/quick_entrypoints_x86_64.S b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
index b72890d444..4d00022ff8 100644
--- a/runtime/arch/x86_64/quick_entrypoints_x86_64.S
+++ b/runtime/arch/x86_64/quick_entrypoints_x86_64.S
@@ -2000,21 +2000,6 @@ DEFINE_FUNCTION art_quick_invoke_custom
     RETURN_OR_DELIVER_PENDING_EXCEPTION
 END_FUNCTION art_quick_invoke_custom
 
-// Wrap ExecuteSwitchImpl in assembly method which specifies DEX PC for unwinding.
-//  Argument 0: RDI: The context pointer for ExecuteSwitchImpl.
-//  Argument 1: RSI: Pointer to the templated ExecuteSwitchImpl to call.
-//  Argument 2: RDX: The value of DEX PC (memory address of the methods bytecode).
-DEFINE_FUNCTION ExecuteSwitchImplAsm
-    PUSH rbx                 // Spill RBX
-    movq %rdx, %rbx          // RBX = DEX PC (callee save register)
-    CFI_DEFINE_DEX_PC_WITH_OFFSET(0 /* RAX */, 3 /* RBX */, 0)
-
-    call *%rsi               // Call the wrapped function
-
-    POP rbx                  // Restore RBX
-    ret
-END_FUNCTION ExecuteSwitchImplAsm
-
 // On entry: edi is the class, r11 is the inline cache. r10 and rax are available.
 DEFINE_FUNCTION art_quick_update_inline_cache
 #if (INLINE_CACHE_SIZE != 5)
diff --git a/runtime/art_field-inl.h b/runtime/art_field-inl.h
index cbe38db80e..dd86e68164 100644
--- a/runtime/art_field-inl.h
+++ b/runtime/art_field-inl.h
@@ -371,7 +371,7 @@ inline bool ArtField::IsPrimitiveType() {
 inline ObjPtr<mirror::Class> ArtField::LookupResolvedType() {
   ScopedAssertNoThreadSuspension ants(__FUNCTION__);
   if (UNLIKELY(IsProxyField())) {
-    return ProxyFindSystemClass(GetTypeDescriptor());
+    return ProxyFindSystemClass(GetTypeDescriptorView());
   }
   ObjPtr<mirror::Class> type = Runtime::Current()->GetClassLinker()->LookupResolvedType(
       GetDexFile()->GetFieldId(GetDexFieldIndex()).type_idx_, this);
@@ -381,7 +381,7 @@ inline ObjPtr<mirror::Class> ArtField::LookupResolvedType() {
 
 inline ObjPtr<mirror::Class> ArtField::ResolveType() {
   if (UNLIKELY(IsProxyField())) {
-    return ProxyFindSystemClass(GetTypeDescriptor());
+    return ProxyFindSystemClass(GetTypeDescriptorView());
   }
   ObjPtr<mirror::Class> type = Runtime::Current()->GetClassLinker()->ResolveType(
       GetDexFile()->GetFieldId(GetDexFieldIndex()).type_idx_, this);
diff --git a/runtime/art_field.cc b/runtime/art_field.cc
index 70d6d2ba94..b7b2a779fe 100644
--- a/runtime/art_field.cc
+++ b/runtime/art_field.cc
@@ -39,7 +39,7 @@ void ArtField::SetOffset(MemberOffset num_bytes) {
   offset_ = num_bytes.Uint32Value();
 }
 
-ObjPtr<mirror::Class> ArtField::ProxyFindSystemClass(const char* descriptor) {
+ObjPtr<mirror::Class> ArtField::ProxyFindSystemClass(std::string_view descriptor) {
   DCHECK(IsProxyField());
   ObjPtr<mirror::Class> klass = Runtime::Current()->GetClassLinker()->LookupClass(
       Thread::Current(), descriptor, /* class_loader= */ nullptr);
diff --git a/runtime/art_field.h b/runtime/art_field.h
index 141de5650d..fd991cd53a 100644
--- a/runtime/art_field.h
+++ b/runtime/art_field.h
@@ -256,7 +256,7 @@ class EXPORT ArtField final {
  private:
   bool IsProxyField() REQUIRES_SHARED(Locks::mutator_lock_);
 
-  ObjPtr<mirror::Class> ProxyFindSystemClass(const char* descriptor)
+  ObjPtr<mirror::Class> ProxyFindSystemClass(std::string_view descriptor)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   GcRoot<mirror::Class> declaring_class_;
diff --git a/runtime/art_method-inl.h b/runtime/art_method-inl.h
index 2b88b733f7..05d819577b 100644
--- a/runtime/art_method-inl.h
+++ b/runtime/art_method-inl.h
@@ -150,18 +150,14 @@ constexpr size_t NumberOfVRegs() {
   return sum;
 }
 
-template <char... ArgType>
-inline ALWAYS_INLINE void FillVRegs([[maybe_unused]] uint32_t* vregs,
-                                    [[maybe_unused]] typename ShortyTraits<ArgType>::Type... args)
-    REQUIRES_SHARED(Locks::mutator_lock_) {}
-
 template <char FirstArgType, char... ArgType>
 inline ALWAYS_INLINE void FillVRegs(uint32_t* vregs,
                                     typename ShortyTraits<FirstArgType>::Type first_arg,
                                     typename ShortyTraits<ArgType>::Type... args)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ShortyTraits<FirstArgType>::Set(vregs, first_arg);
-  FillVRegs<ArgType...>(vregs + ShortyTraits<FirstArgType>::kVRegCount, args...);
+  if constexpr (sizeof...(args) > 0)
+    FillVRegs<ArgType...>(vregs + ShortyTraits<FirstArgType>::kVRegCount, args...);
 }
 
 template <char... ArgType>
@@ -169,7 +165,8 @@ inline ALWAYS_INLINE auto MaterializeVRegs(typename ShortyTraits<ArgType>::Type.
     REQUIRES_SHARED(Locks::mutator_lock_) {
   constexpr size_t kNumVRegs = NumberOfVRegs<ArgType...>();
   std::array<uint32_t, kNumVRegs> vregs;
-  FillVRegs<ArgType...>(vregs.data(), args...);
+  if constexpr (sizeof...(args) > 0)
+    FillVRegs<ArgType...>(vregs.data(), args...);
   return vregs;
 }
 
diff --git a/runtime/art_method.cc b/runtime/art_method.cc
index d4bed097ec..a03df5cc2f 100644
--- a/runtime/art_method.cc
+++ b/runtime/art_method.cc
@@ -364,8 +364,8 @@ uint32_t ArtMethod::FindCatchBlock(Handle<mirror::Class> exception_type,
 NO_STACK_PROTECTOR
 void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,
                        const char* shorty) {
-  if (UNLIKELY(__builtin_frame_address(0) < self->GetStackEnd())) {
-    ThrowStackOverflowError(self);
+  if (UNLIKELY(__builtin_frame_address(0) < self->GetStackEnd<kNativeStackType>())) {
+    ThrowStackOverflowError<kNativeStackType>(self);
     return;
   }
 
@@ -723,49 +723,55 @@ void ArtMethod::SetIntrinsic(Intrinsics intrinsic) {
   // classes. We don't set kHasSingleImplementation for those methods.
   DCHECK(IsStatic() || IsFinal() || GetDeclaringClass()->IsFinal()) <<
       "Potential conflict with kAccSingleImplementation";
-  static const int kAccFlagsShift = CTZ(kAccIntrinsicBits);
+  static constexpr int kAccFlagsShift = CTZ(kAccIntrinsicBits);
   uint32_t intrinsic_u32 = enum_cast<uint32_t>(intrinsic);
   DCHECK_LE(intrinsic_u32, kAccIntrinsicBits >> kAccFlagsShift);
   uint32_t intrinsic_bits = intrinsic_u32 << kAccFlagsShift;
   uint32_t new_value = (GetAccessFlags() & ~kAccIntrinsicBits) | kAccIntrinsic | intrinsic_bits;
-  if (kIsDebugBuild) {
-    uint32_t java_flags = (GetAccessFlags() & kAccJavaFlagsMask);
-    bool is_constructor = IsConstructor();
-    bool is_synchronized = IsSynchronized();
-    bool skip_access_checks = SkipAccessChecks();
-    bool is_fast_native = IsFastNative();
-    bool is_critical_native = IsCriticalNative();
-    bool is_copied = IsCopied();
-    bool is_miranda = IsMiranda();
-    bool is_default = IsDefault();
-    bool is_default_conflict = IsDefaultConflicting();
-    bool is_compilable = IsCompilable();
-    bool must_count_locks = MustCountLocks();
-    // Recompute flags instead of getting them from the current access flags because
-    // access flags may have been changed to deduplicate warning messages (b/129063331).
-    uint32_t hiddenapi_flags = hiddenapi::CreateRuntimeFlags(this);
-    SetAccessFlags(new_value);
-    DCHECK_EQ(java_flags, (GetAccessFlags() & kAccJavaFlagsMask));
-    DCHECK_EQ(is_constructor, IsConstructor());
-    DCHECK_EQ(is_synchronized, IsSynchronized());
-    DCHECK_EQ(skip_access_checks, SkipAccessChecks());
-    DCHECK_EQ(is_fast_native, IsFastNative());
-    DCHECK_EQ(is_critical_native, IsCriticalNative());
-    DCHECK_EQ(is_copied, IsCopied());
-    DCHECK_EQ(is_miranda, IsMiranda());
-    DCHECK_EQ(is_default, IsDefault());
-    DCHECK_EQ(is_default_conflict, IsDefaultConflicting());
-    DCHECK_EQ(is_compilable, IsCompilable());
-    DCHECK_EQ(must_count_locks, MustCountLocks());
-    // Only DCHECK that we have preserved the hidden API access flags if the
-    // original method was not in the SDK list. This is because the core image
-    // does not have the access flags set (b/77733081).
-    if ((hiddenapi_flags & kAccHiddenapiBits) != kAccPublicApi) {
-      DCHECK_EQ(hiddenapi_flags, hiddenapi::GetRuntimeFlags(this)) << PrettyMethod();
-    }
-  } else {
-    SetAccessFlags(new_value);
-  }
+
+  // These flags shouldn't be overridden by setting the intrinsic.
+  uint32_t java_flags = (GetAccessFlags() & kAccJavaFlagsMask);
+  bool is_constructor = IsConstructor();
+  bool is_synchronized = IsSynchronized();
+  bool skip_access_checks = SkipAccessChecks();
+  bool is_fast_native = IsFastNative();
+  bool is_critical_native = IsCriticalNative();
+  bool is_copied = IsCopied();
+  bool is_miranda = IsMiranda();
+  bool is_default = IsDefault();
+  bool is_default_conflict = IsDefaultConflicting();
+  bool is_compilable = IsCompilable();
+  bool must_count_locks = MustCountLocks();
+
+#ifdef ART_TARGET_ANDROID
+  // Recompute flags instead of getting them from the current access flags because
+  // access flags may have been changed to deduplicate warning messages (b/129063331).
+  // For host builds, the flags from the api list (i.e. hiddenapi::CreateRuntimeFlags) might not
+  // have the right value.
+  uint32_t hiddenapi_flags = hiddenapi::CreateRuntimeFlags(this);
+#endif
+
+  SetAccessFlags(new_value);
+  // Intrinsics are considered hot from the first call.
+  SetHotCounter();
+
+  // DCHECK that the flags weren't overridden.
+  DCHECK_EQ(java_flags, (GetAccessFlags() & kAccJavaFlagsMask));
+  DCHECK_EQ(is_constructor, IsConstructor());
+  DCHECK_EQ(is_synchronized, IsSynchronized());
+  DCHECK_EQ(skip_access_checks, SkipAccessChecks());
+  DCHECK_EQ(is_fast_native, IsFastNative());
+  DCHECK_EQ(is_critical_native, IsCriticalNative());
+  DCHECK_EQ(is_copied, IsCopied());
+  DCHECK_EQ(is_miranda, IsMiranda());
+  DCHECK_EQ(is_default, IsDefault());
+  DCHECK_EQ(is_default_conflict, IsDefaultConflicting());
+  DCHECK_EQ(is_compilable, IsCompilable());
+  DCHECK_EQ(must_count_locks, MustCountLocks());
+
+#ifdef ART_TARGET_ANDROID
+  DCHECK_EQ(hiddenapi_flags, hiddenapi::GetRuntimeFlags(this)) << PrettyMethod();
+#endif
 }
 
 void ArtMethod::SetNotIntrinsic() {
diff --git a/runtime/art_method.h b/runtime/art_method.h
index 30dc09f67f..ee11328385 100644
--- a/runtime/art_method.h
+++ b/runtime/art_method.h
@@ -356,6 +356,14 @@ class EXPORT ArtMethod final {
   }
 
   static bool IsMemorySharedMethod(uint32_t access_flags) {
+    // There's an overlap with `kAccMemorySharedMethod` and `kAccIntrinsicBits` but that's OK as
+    // intrinsics are always in the boot image and therefore memory shared.
+    static_assert((kAccMemorySharedMethod & kAccIntrinsicBits) != 0,
+                  "kAccMemorySharedMethod deliberately overlaps intrinsic bits");
+    if (IsIntrinsic(access_flags)) {
+      return true;
+    }
+
     return (access_flags & kAccMemorySharedMethod) != 0;
   }
 
@@ -413,9 +421,13 @@ class EXPORT ArtMethod final {
   }
 
   static bool IsDefault(uint32_t access_flags) {
-    static_assert((kAccDefault & (kAccIntrinsic | kAccIntrinsicBits)) == 0,
-                  "kAccDefault conflicts with intrinsic modifier");
-    return (access_flags & kAccDefault) != 0;
+    // The intrinsic bits use `kAccDefault`. However, we don't generate intrinsics for default
+    // methods. Therefore, we check that both `kAccDefault` is set and `kAccIntrinsic` unset.
+    static_assert((kAccDefault & kAccIntrinsicBits) != 0,
+                  "kAccDefault deliberately overlaps intrinsic bits");
+    static constexpr uint32_t kMask = kAccIntrinsic | kAccDefault;
+    static constexpr uint32_t kValue = kAccDefault;
+    return (access_flags & kMask) == kValue;
   }
 
   // Returns true if the method is obsolete.
diff --git a/runtime/base/mutex.cc b/runtime/base/mutex.cc
index 0abe9667f8..26a665bd41 100644
--- a/runtime/base/mutex.cc
+++ b/runtime/base/mutex.cc
@@ -463,6 +463,7 @@ void Mutex::ExclusiveLock(Thread* self) {
         done = state_and_contenders_.CompareAndSetWeakAcquire(cur_state, cur_state | kHeldMask);
       } else {
         // Failed to acquire, hang up.
+        // We don't hold the mutex: GetExclusiveOwnerTid() is usually, but not always, correct.
         ScopedContentionRecorder scr(this, SafeGetTid(self), GetExclusiveOwnerTid());
         // Empirically, it appears important to spin again each time through the loop; if we
         // bother to go to sleep and wake up, we should be fairly persistent in trying for the
diff --git a/runtime/base/mutex.h b/runtime/base/mutex.h
index e3d89e7449..9185f79ab7 100644
--- a/runtime/base/mutex.h
+++ b/runtime/base/mutex.h
@@ -394,7 +394,7 @@ class EXPORT SHARED_LOCKABLE ReaderWriterMutex : public BaseMutex {
 
   // Id associated with exclusive owner. No memory ordering semantics if called from a thread other
   // than the owner. Returns 0 if the lock is not held. Returns either 0 or -1 if it is held by
-  // one or more readers.
+  // one or more readers. Not reliable unless the mutex is held.
   pid_t GetExclusiveOwnerTid() const;
 
   void Dump(std::ostream& os) const override;
diff --git a/runtime/class_linker-inl.h b/runtime/class_linker-inl.h
index 6461f54f5f..056b26b2d2 100644
--- a/runtime/class_linker-inl.h
+++ b/runtime/class_linker-inl.h
@@ -25,7 +25,7 @@
 #include "base/mutex.h"
 #include "class_linker.h"
 #include "class_table-inl.h"
-#include "dex/dex_file.h"
+#include "dex/dex_file-inl.h"
 #include "dex/dex_file_structs.h"
 #include "gc_root-inl.h"
 #include "handle_scope-inl.h"
@@ -54,7 +54,8 @@ inline ObjPtr<mirror::Class> ClassLinker::FindArrayClass(Thread* self,
   descriptor += element_class->GetDescriptor(&temp);
   StackHandleScope<1> hs(Thread::Current());
   Handle<mirror::ClassLoader> class_loader(hs.NewHandle(element_class->GetClassLoader()));
-  ObjPtr<mirror::Class> array_class = FindClass(self, descriptor.c_str(), class_loader);
+  ObjPtr<mirror::Class> array_class =
+      FindClass(self, descriptor.c_str(), descriptor.length(), class_loader);
   if (array_class != nullptr) {
     // Benign races in storing array class and incrementing index.
     size_t victim_index = find_array_class_cache_next_victim_;
@@ -205,73 +206,6 @@ inline ObjPtr<mirror::Class> ClassLinker::LookupResolvedType(
   return type;
 }
 
-template <bool kThrowOnError, typename ClassGetter>
-inline bool ClassLinker::CheckInvokeClassMismatch(ObjPtr<mirror::DexCache> dex_cache,
-                                                  InvokeType type,
-                                                  ClassGetter class_getter) {
-  switch (type) {
-    case kStatic:
-    case kSuper:
-    case kPolymorphic:
-      break;
-    case kInterface: {
-      // We have to check whether the method id really belongs to an interface (dex static bytecode
-      // constraints A15, A16). Otherwise you must not invoke-interface on it.
-      ObjPtr<mirror::Class> klass = class_getter();
-      if (UNLIKELY(!klass->IsInterface())) {
-        if (kThrowOnError) {
-          ThrowIncompatibleClassChangeError(klass,
-                                            "Found class %s, but interface was expected",
-                                            klass->PrettyDescriptor().c_str());
-        }
-        return true;
-      }
-      break;
-    }
-    case kDirect:
-      if (dex_cache->GetDexFile()->SupportsDefaultMethods()) {
-        break;
-      }
-      FALLTHROUGH_INTENDED;
-    case kVirtual: {
-      // Similarly, invoke-virtual (and invoke-direct without default methods) must reference
-      // a non-interface class (dex static bytecode constraint A24, A25).
-      ObjPtr<mirror::Class> klass = class_getter();
-      if (UNLIKELY(klass->IsInterface())) {
-        if (kThrowOnError) {
-          ThrowIncompatibleClassChangeError(klass,
-                                            "Found interface %s, but class was expected",
-                                            klass->PrettyDescriptor().c_str());
-        }
-        return true;
-      }
-      break;
-    }
-    default:
-      LOG(FATAL) << "Unreachable - invocation type: " << type;
-      UNREACHABLE();
-  }
-  return false;
-}
-
-template <bool kThrow>
-inline bool ClassLinker::CheckInvokeClassMismatch(ObjPtr<mirror::DexCache> dex_cache,
-                                                  InvokeType type,
-                                                  uint32_t method_idx,
-                                                  ObjPtr<mirror::ClassLoader> class_loader) {
-  DCHECK(dex_cache->GetClassLoader().Ptr() == class_loader.Ptr());
-  return CheckInvokeClassMismatch<kThrow>(
-      dex_cache,
-      type,
-      [this, dex_cache, method_idx, class_loader]() REQUIRES_SHARED(Locks::mutator_lock_) {
-        const dex::MethodId& method_id = dex_cache->GetDexFile()->GetMethodId(method_idx);
-        ObjPtr<mirror::Class> klass =
-            LookupResolvedType(method_id.class_idx_, dex_cache, class_loader);
-        DCHECK(klass != nullptr) << dex_cache->GetDexFile()->PrettyMethod(method_idx);
-        return klass;
-      });
-}
-
 inline ArtMethod* ClassLinker::LookupResolvedMethod(uint32_t method_idx,
                                                     ObjPtr<mirror::DexCache> dex_cache,
                                                     ObjPtr<mirror::ClassLoader> class_loader) {
@@ -288,102 +222,88 @@ inline ArtMethod* ClassLinker::LookupResolvedMethod(uint32_t method_idx,
   return resolved;
 }
 
-template <ClassLinker::ResolveMode kResolveMode>
-inline ArtMethod* ClassLinker::ResolveMethod(Thread* self,
-                                             uint32_t method_idx,
-                                             ArtMethod* referrer,
-                                             InvokeType type) {
-  DCHECK(referrer != nullptr);
-  DCHECK_IMPLIES(referrer->IsProxyMethod(), referrer->IsConstructor());
-
-  Thread::PoisonObjectPointersIfDebug();
-  // Fast path: no checks and in the dex cache.
-  if (kResolveMode == ResolveMode::kNoChecks) {
-    ArtMethod* resolved_method = referrer->GetDexCache()->GetResolvedMethod(method_idx);
-    if (resolved_method != nullptr) {
-      DCHECK(!resolved_method->IsRuntimeMethod());
-      return resolved_method;
-    }
+inline ArtMethod* ClassLinker::ResolveMethodId(uint32_t method_idx, ArtMethod* referrer) {
+  ArtMethod* resolved = referrer->GetDexCache()->GetResolvedMethod(method_idx);
+  if (resolved != nullptr) {
+    DCHECK(!resolved->IsRuntimeMethod());
+    DCHECK(resolved->GetDeclaringClassUnchecked() != nullptr) << resolved->GetDexMethodIndex();
+    return resolved;
   }
-
-  // For a Proxy constructor, we need to do the lookup in the context of the original method
-  // from where it steals the code.
+  // Fail, get the declaring class.
   referrer = referrer->GetInterfaceMethodIfProxy(image_pointer_size_);
-  StackHandleScope<2> hs(self);
-  Handle<mirror::DexCache> dex_cache(hs.NewHandle(referrer->GetDexCache()));
-  Handle<mirror::ClassLoader> class_loader(
-      hs.NewHandle(referrer->GetDeclaringClass()->GetClassLoader()));
-  return ResolveMethod<kResolveMode>(method_idx, dex_cache, class_loader, referrer, type);
-}
-
-template <ClassLinker::ResolveMode kResolveMode>
-inline ArtMethod* ClassLinker::ResolveMethod(uint32_t method_idx,
-                                             Handle<mirror::DexCache> dex_cache,
-                                             Handle<mirror::ClassLoader> class_loader,
-                                             ArtMethod* referrer,
-                                             InvokeType type) {
-  DCHECK(dex_cache != nullptr);
-  DCHECK(dex_cache->GetClassLoader() == class_loader.Get());
-  DCHECK(!Thread::Current()->IsExceptionPending()) << Thread::Current()->GetException()->Dump();
-  DCHECK(referrer == nullptr || !referrer->IsProxyMethod());
+  const dex::MethodId& method_id = referrer->GetDexFile()->GetMethodId(method_idx);
+  ObjPtr<mirror::Class> klass = ResolveType(method_id.class_idx_, referrer);
+  if (klass == nullptr) {
+    Thread::Current()->AssertPendingException();
+    return nullptr;
+  }
 
-  // Check for hit in the dex cache.
-  ArtMethod* resolved = dex_cache->GetResolvedMethod(method_idx);
-  Thread::PoisonObjectPointersIfDebug();
-  DCHECK(resolved == nullptr || !resolved->IsRuntimeMethod());
-  bool valid_dex_cache_method = resolved != nullptr;
-  if (kResolveMode == ResolveMode::kNoChecks && valid_dex_cache_method) {
-    // We have a valid method from the DexCache and no checks to perform.
-    DCHECK(resolved->GetDeclaringClassUnchecked() != nullptr) << resolved->GetDexMethodIndex();
+  resolved =
+      FindResolvedMethod(klass, referrer->GetDexCache(), referrer->GetClassLoader(), method_idx);
+  if (resolved != nullptr) {
     return resolved;
   }
-  const DexFile& dex_file = *dex_cache->GetDexFile();
-  const dex::MethodId& method_id = dex_file.GetMethodId(method_idx);
-  ObjPtr<mirror::Class> klass = nullptr;
-  if (valid_dex_cache_method) {
-    // We have a valid method from the DexCache but we need to perform ICCE and IAE checks.
-    DCHECK(resolved->GetDeclaringClassUnchecked() != nullptr) << resolved->GetDexMethodIndex();
-    klass = LookupResolvedType(method_id.class_idx_, dex_cache.Get(), class_loader.Get());
-    if (UNLIKELY(klass == nullptr)) {
-      // We normaly should not end up here. However the verifier currently doesn't guarantee
-      // the invariant of having the klass in the class table. b/73760543
-      klass = ResolveType(method_id.class_idx_, dex_cache, class_loader);
-      if (klass == nullptr) {
-        // This can only happen if the current thread is not allowed to load
-        // classes.
-        DCHECK(!Thread::Current()->CanLoadClasses());
-        DCHECK(Thread::Current()->IsExceptionPending());
-        return nullptr;
-      }
+
+  const char* name = referrer->GetDexFile()->GetStringData(method_id.name_idx_);
+  const Signature signature = referrer->GetDexFile()->GetMethodSignature(method_id);
+  ThrowNoSuchMethodError(klass, name, signature);
+  return nullptr;
+}
+
+inline bool ClassLinker::ThrowIfInvokeClassMismatch(ObjPtr<mirror::Class> klass,
+                                                    const DexFile& dex_file,
+                                                    InvokeType type) {
+  if (type == kInterface) {
+    if (UNLIKELY(!klass->IsInterface())) {
+      ThrowIncompatibleClassChangeError(klass,
+                                        "Found class %s, but interface was expected",
+                                        klass->PrettyDescriptor().c_str());
+      return true;
     }
-  } else {
-    // The method was not in the DexCache, resolve the declaring class.
-    klass = ResolveType(method_id.class_idx_, dex_cache, class_loader);
-    if (klass == nullptr) {
-      DCHECK(Thread::Current()->IsExceptionPending());
-      return nullptr;
+  } else if (type == kVirtual) {
+    if (UNLIKELY(klass->IsInterface())) {
+      ThrowIncompatibleClassChangeError(klass,
+                                        "Found interface %s, but class was expected",
+                                        klass->PrettyDescriptor().c_str());
+      return true;
     }
-    // Look for the method again in case the type resolution updated the cache.
-    resolved = dex_cache->GetResolvedMethod(method_idx);
-    if (kResolveMode == ResolveMode::kNoChecks && resolved != nullptr) {
-      return resolved;
+  } else if (type == kDirect) {
+    if (UNLIKELY(klass->IsInterface()) && !dex_file.SupportsDefaultMethods()) {
+      ThrowIncompatibleClassChangeError(klass,
+                                        "Found interface %s, but class was expected",
+                                        klass->PrettyDescriptor().c_str());
+      return true;
     }
   }
+  return false;
+}
 
-  // Check if the invoke type matches the class type.
-  if (kResolveMode == ResolveMode::kCheckICCEAndIAE &&
-      CheckInvokeClassMismatch</* kThrow= */ true>(
-          dex_cache.Get(), type, [klass]() { return klass; })) {
+inline ArtMethod* ClassLinker::ResolveMethodWithChecks(uint32_t method_idx,
+                                                       ArtMethod* referrer,
+                                                       InvokeType type) {
+  DCHECK(referrer != nullptr);
+  DCHECK_IMPLIES(referrer->IsProxyMethod(), referrer->IsConstructor());
+
+  // For a Proxy constructor, we need to do the lookup in the context of the original method
+  // from where it steals the code.
+  referrer = referrer->GetInterfaceMethodIfProxy(image_pointer_size_);
+
+  const dex::MethodId& method_id = referrer->GetDexFile()->GetMethodId(method_idx);
+  ObjPtr<mirror::Class> klass = ResolveType(method_id.class_idx_, referrer);
+  if (klass == nullptr || ThrowIfInvokeClassMismatch(klass, *referrer->GetDexFile(), type)) {
     DCHECK(Thread::Current()->IsExceptionPending());
     return nullptr;
   }
 
-  if (!valid_dex_cache_method) {
-    resolved = FindResolvedMethod(klass, dex_cache.Get(), class_loader.Get(), method_idx);
+  ArtMethod* resolved = referrer->GetDexCache()->GetResolvedMethod(method_idx);
+  if (resolved == nullptr) {
+    resolved = FindResolvedMethod(klass,
+                                  referrer->GetDexCache(),
+                                  referrer->GetDexCache()->GetClassLoader(),
+                                  method_idx);
   }
 
-  // Note: We can check for IllegalAccessError only if we have a referrer.
-  if (kResolveMode == ResolveMode::kCheckICCEAndIAE && resolved != nullptr && referrer != nullptr) {
+  if (resolved != nullptr) {
     ObjPtr<mirror::Class> methods_class = resolved->GetDeclaringClass();
     ObjPtr<mirror::Class> referring_class = referrer->GetDeclaringClass();
     if (UNLIKELY(!referring_class->CanAccess(methods_class))) {
@@ -402,29 +322,25 @@ inline ArtMethod* ClassLinker::ResolveMethod(uint32_t method_idx,
       ThrowIllegalAccessErrorMethod(referring_class, resolved);
       return nullptr;
     }
-  }
-
-  // If we found a method, check for incompatible class changes.
-  if (LIKELY(resolved != nullptr) &&
-      LIKELY(kResolveMode == ResolveMode::kNoChecks ||
-             !resolved->CheckIncompatibleClassChange(type))) {
-    return resolved;
-  }
 
-  // If we had a method, or if we can find one with another lookup type,
-  // it's an incompatible-class-change error.
-  if (resolved == nullptr) {
-    resolved = FindIncompatibleMethod(klass, dex_cache.Get(), class_loader.Get(), method_idx);
+    if (LIKELY(!resolved->CheckIncompatibleClassChange(type))) {
+      return resolved;
+    }
+  } else {
+    resolved = FindIncompatibleMethod(klass,
+                                      referrer->GetDexCache(),
+                                      referrer->GetDexCache()->GetClassLoader(),
+                                      method_idx);
   }
   if (resolved != nullptr) {
     ThrowIncompatibleClassChangeError(type, resolved->GetInvokeType(), resolved, referrer);
-  } else {
-    // We failed to find the method (using all lookup types), so throw a NoSuchMethodError.
-    const char* name = dex_file.GetStringData(method_id.name_idx_);
-    const Signature signature = dex_file.GetMethodSignature(method_id);
-    ThrowNoSuchMethodError(type, klass, name, signature);
+    return nullptr;
   }
-  Thread::Current()->AssertPendingException();
+
+  // We failed to find the method (using all lookup types), so throw a NoSuchMethodError.
+  const char* name = referrer->GetDexFile()->GetStringData(method_id.name_idx_);
+  const Signature signature = referrer->GetDexFile()->GetMethodSignature(method_id);
+  ThrowNoSuchMethodError(type, klass, name, signature);
   return nullptr;
 }
 
diff --git a/runtime/class_linker.cc b/runtime/class_linker.cc
index 2d1bf6f780..c2926ac263 100644
--- a/runtime/class_linker.cc
+++ b/runtime/class_linker.cc
@@ -66,15 +66,18 @@
 #include "class_loader_utils.h"
 #include "class_root-inl.h"
 #include "class_table-inl.h"
+#include "common_throws.h"
 #include "compiler_callbacks.h"
 #include "debug_print.h"
 #include "debugger.h"
 #include "dex/class_accessor-inl.h"
 #include "dex/descriptors_names.h"
 #include "dex/dex_file-inl.h"
+#include "dex/dex_file.h"
 #include "dex/dex_file_annotations.h"
 #include "dex/dex_file_exception_helpers.h"
 #include "dex/dex_file_loader.h"
+#include "dex/modifiers.h"
 #include "dex/signature-inl.h"
 #include "dex/utf.h"
 #include "entrypoints/entrypoint_utils-inl.h"
@@ -2876,8 +2879,9 @@ void ClassLinker::FinishCoreArrayClassSetup(ClassRoot array_root) {
   ObjPtr<mirror::Class> array_class = GetClassRoot(array_root, this);
   FinishArrayClassSetup(array_class);
 
-  std::string temp;
-  const char* descriptor = array_class->GetDescriptor(&temp);
+  std::string descriptor;
+  const char* raw_descriptor = array_class->GetDescriptor(&descriptor);
+  DCHECK(raw_descriptor == descriptor.c_str());
   size_t hash = ComputeModifiedUtf8Hash(descriptor);
   ObjPtr<mirror::Class> existing = InsertClass(descriptor, array_class, hash);
   CHECK(existing == nullptr);
@@ -2891,7 +2895,7 @@ ObjPtr<mirror::ObjectArray<mirror::StackTraceElement>> ClassLinker::AllocStackTr
 }
 
 ObjPtr<mirror::Class> ClassLinker::EnsureResolved(Thread* self,
-                                                  const char* descriptor,
+                                                  std::string_view descriptor,
                                                   ObjPtr<mirror::Class> klass) {
   DCHECK(klass != nullptr);
   if (kIsDebugBuild) {
@@ -2970,8 +2974,9 @@ ObjPtr<mirror::Class> ClassLinker::EnsureResolved(Thread* self,
 using ClassPathEntry = std::pair<const DexFile*, const dex::ClassDef*>;
 
 // Search a collection of DexFiles for a descriptor
-ClassPathEntry FindInClassPath(const char* descriptor,
-                               size_t hash, const std::vector<const DexFile*>& class_path) {
+ClassPathEntry FindInClassPath(std::string_view descriptor,
+                               size_t hash,
+                               const std::vector<const DexFile*>& class_path) {
   for (const DexFile* dex_file : class_path) {
     DCHECK(dex_file != nullptr);
     const dex::ClassDef* dex_class_def = OatDexFile::FindClassDef(*dex_file, descriptor, hash);
@@ -3004,15 +3009,18 @@ do {                                                                          \
 
 bool ClassLinker::FindClassInSharedLibraries(Thread* self,
                                              const char* descriptor,
+                                             size_t descriptor_length,
                                              size_t hash,
                                              Handle<mirror::ClassLoader> class_loader,
                                              /*out*/ ObjPtr<mirror::Class>* result) {
   ArtField* field = WellKnownClasses::dalvik_system_BaseDexClassLoader_sharedLibraryLoaders;
-  return FindClassInSharedLibrariesHelper(self, descriptor, hash, class_loader, field, result);
+  return FindClassInSharedLibrariesHelper(
+      self, descriptor, descriptor_length, hash, class_loader, field, result);
 }
 
 bool ClassLinker::FindClassInSharedLibrariesHelper(Thread* self,
                                                    const char* descriptor,
+                                                   size_t descriptor_length,
                                                    size_t hash,
                                                    Handle<mirror::ClassLoader> class_loader,
                                                    ArtField* field,
@@ -3029,7 +3037,8 @@ bool ClassLinker::FindClassInSharedLibrariesHelper(Thread* self,
   for (auto loader : shared_libraries.Iterate<mirror::ClassLoader>()) {
     temp_loader.Assign(loader);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBaseDexClassLoader(self, descriptor, hash, temp_loader, result),
+        FindClassInBaseDexClassLoader(
+            self, descriptor, descriptor_length, hash, temp_loader, result),
         *result,
         self);
   }
@@ -3038,22 +3047,27 @@ bool ClassLinker::FindClassInSharedLibrariesHelper(Thread* self,
 
 bool ClassLinker::FindClassInSharedLibrariesAfter(Thread* self,
                                                   const char* descriptor,
+                                                  size_t descriptor_length,
                                                   size_t hash,
                                                   Handle<mirror::ClassLoader> class_loader,
                                                   /*out*/ ObjPtr<mirror::Class>* result) {
   ArtField* field = WellKnownClasses::dalvik_system_BaseDexClassLoader_sharedLibraryLoadersAfter;
-  return FindClassInSharedLibrariesHelper(self, descriptor, hash, class_loader, field, result);
+  return FindClassInSharedLibrariesHelper(
+      self, descriptor, descriptor_length, hash, class_loader, field, result);
 }
 
 bool ClassLinker::FindClassInBaseDexClassLoader(Thread* self,
                                                 const char* descriptor,
+                                                size_t descriptor_length,
                                                 size_t hash,
                                                 Handle<mirror::ClassLoader> class_loader,
                                                 /*out*/ ObjPtr<mirror::Class>* result) {
   // Termination case: boot class loader.
   if (IsBootClassLoader(class_loader.Get())) {
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBootClassLoaderClassPath(self, descriptor, hash, result), *result, self);
+        FindClassInBootClassLoaderClassPath(self, descriptor, descriptor_length, hash, result),
+        *result,
+        self);
     return true;
   }
 
@@ -3067,19 +3081,21 @@ bool ClassLinker::FindClassInBaseDexClassLoader(Thread* self,
     StackHandleScope<1> hs(self);
     Handle<mirror::ClassLoader> h_parent(hs.NewHandle(class_loader->GetParent()));
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBaseDexClassLoader(self, descriptor, hash, h_parent, result),
+        FindClassInBaseDexClassLoader(self, descriptor, descriptor_length, hash, h_parent, result),
         *result,
         self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInSharedLibraries(self, descriptor, hash, class_loader, result),
+        FindClassInSharedLibraries(self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBaseDexClassLoaderClassPath(self, descriptor, hash, class_loader, result),
+        FindClassInBaseDexClassLoaderClassPath(
+            self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInSharedLibrariesAfter(self, descriptor, hash, class_loader, result),
+        FindClassInSharedLibrariesAfter(
+            self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
     // We did not find a class, but the class loader chain was recognized, so we
@@ -3094,17 +3110,21 @@ bool ClassLinker::FindClassInBaseDexClassLoader(Thread* self,
     //    - class loader dex files
     //    - parent
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBootClassLoaderClassPath(self, descriptor, hash, result), *result, self);
+        FindClassInBootClassLoaderClassPath(self, descriptor, descriptor_length, hash, result),
+        *result,
+        self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInSharedLibraries(self, descriptor, hash, class_loader, result),
+        FindClassInSharedLibraries(self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBaseDexClassLoaderClassPath(self, descriptor, hash, class_loader, result),
+        FindClassInBaseDexClassLoaderClassPath(
+            self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInSharedLibrariesAfter(self, descriptor, hash, class_loader, result),
+        FindClassInSharedLibrariesAfter(
+            self, descriptor, descriptor_length, hash, class_loader, result),
         *result,
         self);
 
@@ -3112,7 +3132,7 @@ bool ClassLinker::FindClassInBaseDexClassLoader(Thread* self,
     StackHandleScope<1> hs(self);
     Handle<mirror::ClassLoader> h_parent(hs.NewHandle(class_loader->GetParent()));
     RETURN_IF_UNRECOGNIZED_OR_FOUND_OR_EXCEPTION(
-        FindClassInBaseDexClassLoader(self, descriptor, hash, h_parent, result),
+        FindClassInBaseDexClassLoader(self, descriptor, descriptor_length, hash, h_parent, result),
         *result,
         self);
     // We did not find a class, but the class loader chain was recognized, so we
@@ -3156,16 +3176,19 @@ ALWAYS_INLINE void FilterDexFileCaughtExceptions(Thread* self, ClassLinker* clas
 // If the class is found the method returns the resolved class. Otherwise it returns null.
 bool ClassLinker::FindClassInBootClassLoaderClassPath(Thread* self,
                                                       const char* descriptor,
+                                                      size_t descriptor_length,
                                                       size_t hash,
                                                       /*out*/ ObjPtr<mirror::Class>* result) {
-  ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_);
+  std::string_view sv_descriptor(descriptor, descriptor_length);
+  ClassPathEntry pair = FindInClassPath(sv_descriptor, hash, boot_class_path_);
   if (pair.second != nullptr) {
-    ObjPtr<mirror::Class> klass = LookupClass(self, descriptor, hash, nullptr);
+    ObjPtr<mirror::Class> klass = LookupClass(self, sv_descriptor, hash, nullptr);
     if (klass != nullptr) {
-      *result = EnsureResolved(self, descriptor, klass);
+      *result = EnsureResolved(self, sv_descriptor, klass);
     } else {
       *result = DefineClass(self,
                             descriptor,
+                            descriptor_length,
                             hash,
                             ScopedNullHandle<mirror::ClassLoader>(),
                             *pair.first,
@@ -3183,6 +3206,7 @@ bool ClassLinker::FindClassInBootClassLoaderClassPath(Thread* self,
 bool ClassLinker::FindClassInBaseDexClassLoaderClassPath(
     Thread* self,
     const char* descriptor,
+    size_t descriptor_length,
     size_t hash,
     Handle<mirror::ClassLoader> class_loader,
     /*out*/ ObjPtr<mirror::Class>* result) {
@@ -3191,11 +3215,12 @@ bool ClassLinker::FindClassInBaseDexClassLoaderClassPath(
          IsDelegateLastClassLoader(class_loader))
       << "Unexpected class loader for descriptor " << descriptor;
 
+  std::string_view sv_descriptor(descriptor, descriptor_length);
   const DexFile* dex_file = nullptr;
   const dex::ClassDef* class_def = nullptr;
   ObjPtr<mirror::Class> ret;
   auto find_class_def = [&](const DexFile* cp_dex_file) REQUIRES_SHARED(Locks::mutator_lock_) {
-    const dex::ClassDef* cp_class_def = OatDexFile::FindClassDef(*cp_dex_file, descriptor, hash);
+    const dex::ClassDef* cp_class_def = OatDexFile::FindClassDef(*cp_dex_file, sv_descriptor, hash);
     if (cp_class_def != nullptr) {
       dex_file = cp_dex_file;
       class_def = cp_class_def;
@@ -3206,7 +3231,8 @@ bool ClassLinker::FindClassInBaseDexClassLoaderClassPath(
   VisitClassLoaderDexFiles(self, class_loader, find_class_def);
 
   if (class_def != nullptr) {
-    *result = DefineClass(self, descriptor, hash, class_loader, *dex_file, *class_def);
+    *result =
+        DefineClass(self, descriptor, descriptor_length, hash, class_loader, *dex_file, *class_def);
     if (UNLIKELY(*result == nullptr)) {
       CHECK(self->IsExceptionPending()) << descriptor;
       FilterDexFileCaughtExceptions(self, this);
@@ -3218,31 +3244,46 @@ bool ClassLinker::FindClassInBaseDexClassLoaderClassPath(
   return true;
 }
 
+ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
+                                             const DexFile& dex_file,
+                                             dex::TypeIndex type_index,
+                                             Handle<mirror::ClassLoader> class_loader) {
+  dex::StringIndex descriptor_idx = dex_file.GetTypeId(type_index).descriptor_idx_;
+  uint32_t utf16_length;
+  const char* descriptor = dex_file.GetStringDataAndUtf16Length(descriptor_idx, &utf16_length);
+  size_t descriptor_length = DexFile::Utf8Length(descriptor, utf16_length);
+  return FindClass(self, descriptor, descriptor_length, class_loader);
+}
+
 ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
                                              const char* descriptor,
+                                             size_t descriptor_length,
                                              Handle<mirror::ClassLoader> class_loader) {
-  DCHECK_NE(*descriptor, '\0') << "descriptor is empty string";
+  DCHECK_EQ(strlen(descriptor), descriptor_length);
+  DCHECK_NE(descriptor_length, 0u) << "descriptor is empty string";
   DCHECK(self != nullptr);
   self->AssertNoPendingException();
   self->PoisonObjectPointers();  // For DefineClass, CreateArrayClass, etc...
-  if (descriptor[1] == '\0') {
+  if (descriptor_length == 1u) {
     // only the descriptors of primitive types should be 1 character long, also avoid class lookup
     // for primitive classes that aren't backed by dex files.
     return FindPrimitiveClass(descriptor[0]);
   }
-  const size_t hash = ComputeModifiedUtf8Hash(descriptor);
+  const std::string_view sv_descriptor(descriptor, descriptor_length);
+  const size_t hash = ComputeModifiedUtf8Hash(sv_descriptor);
   // Find the class in the loaded classes table.
-  ObjPtr<mirror::Class> klass = LookupClass(self, descriptor, hash, class_loader.Get());
+  ObjPtr<mirror::Class> klass = LookupClass(self, sv_descriptor, hash, class_loader.Get());
   if (klass != nullptr) {
-    return EnsureResolved(self, descriptor, klass);
+    return EnsureResolved(self, sv_descriptor, klass);
   }
   // Class is not yet loaded.
   if (descriptor[0] != '[' && class_loader == nullptr) {
     // Non-array class and the boot class loader, search the boot class path.
-    ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_);
+    ClassPathEntry pair = FindInClassPath(sv_descriptor, hash, boot_class_path_);
     if (pair.second != nullptr) {
       return DefineClass(self,
                          descriptor,
+                         descriptor_length,
                          hash,
                          ScopedNullHandle<mirror::ClassLoader>(),
                          *pair.first,
@@ -3260,20 +3301,20 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
   ObjPtr<mirror::Class> result_ptr;
   bool descriptor_equals;
   if (descriptor[0] == '[') {
-    result_ptr = CreateArrayClass(self, descriptor, hash, class_loader);
+    result_ptr = CreateArrayClass(self, descriptor, descriptor_length, hash, class_loader);
     DCHECK_EQ(result_ptr == nullptr, self->IsExceptionPending());
-    DCHECK(result_ptr == nullptr || result_ptr->DescriptorEquals(descriptor));
+    DCHECK(result_ptr == nullptr || result_ptr->DescriptorEquals(sv_descriptor));
     descriptor_equals = true;
   } else {
     ScopedObjectAccessUnchecked soa(self);
-    bool known_hierarchy =
-        FindClassInBaseDexClassLoader(self, descriptor, hash, class_loader, &result_ptr);
+    bool known_hierarchy = FindClassInBaseDexClassLoader(
+        self, descriptor, descriptor_length, hash, class_loader, &result_ptr);
     if (result_ptr != nullptr) {
       // The chain was understood and we found the class. We still need to add the class to
       // the class table to protect from racy programs that can try and redefine the path list
       // which would change the Class<?> returned for subsequent evaluation of const-class.
       DCHECK(known_hierarchy);
-      DCHECK(result_ptr->DescriptorEquals(descriptor));
+      DCHECK(result_ptr->DescriptorEquals(sv_descriptor));
       descriptor_equals = true;
     } else if (!self->IsExceptionPending()) {
       // Either the chain wasn't understood or the class wasn't found.
@@ -3302,7 +3343,6 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
       // when native code erroneously calls JNI GetFieldId() with signature "java/lang/String"
       // instead of "Ljava/lang/String;", the message below using the "dot" names would be
       // "class loader [...] returned class java.lang.String instead of java.lang.String".
-      size_t descriptor_length = strlen(descriptor);
       if (UNLIKELY(descriptor[0] != 'L') ||
           UNLIKELY(descriptor[descriptor_length - 1] != ';') ||
           UNLIKELY(memchr(descriptor + 1, '.', descriptor_length - 2) != nullptr)) {
@@ -3310,7 +3350,7 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
         return nullptr;
       }
 
-      std::string class_name_string(descriptor + 1, descriptor_length - 2);
+      std::string class_name_string(sv_descriptor.substr(1u, descriptor_length - 2u));
       std::replace(class_name_string.begin(), class_name_string.end(), '/', '.');
       if (known_hierarchy &&
           fast_class_not_found_exceptions_ &&
@@ -3340,7 +3380,7 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
           return nullptr;
         }
         // Check the name of the returned class.
-        descriptor_equals = (result_ptr != nullptr) && result_ptr->DescriptorEquals(descriptor);
+        descriptor_equals = (result_ptr != nullptr) && result_ptr->DescriptorEquals(sv_descriptor);
       }
     } else {
       DCHECK(!MatchesDexFileCaughtExceptions(self->GetException(), this));
@@ -3350,10 +3390,10 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
   if (self->IsExceptionPending()) {
     // If the ClassLoader threw or array class allocation failed, pass that exception up.
     // However, to comply with the RI behavior, first check if another thread succeeded.
-    result_ptr = LookupClass(self, descriptor, hash, class_loader.Get());
+    result_ptr = LookupClass(self, sv_descriptor, hash, class_loader.Get());
     if (result_ptr != nullptr && !result_ptr->IsErroneous()) {
       self->ClearException();
-      return EnsureResolved(self, descriptor, result_ptr);
+      return EnsureResolved(self, sv_descriptor, result_ptr);
     }
     return nullptr;
   }
@@ -3363,7 +3403,7 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
   {
     WriterMutexLock mu(self, *Locks::classlinker_classes_lock_);
     ClassTable* const class_table = InsertClassTableForClassLoader(class_loader.Get());
-    old = class_table->Lookup(descriptor, hash);
+    old = class_table->Lookup(sv_descriptor, hash);
     if (old == nullptr) {
       old = result_ptr;  // For the comparison below, after releasing the lock.
       if (descriptor_equals) {
@@ -3381,7 +3421,7 @@ ObjPtr<mirror::Class> ClassLinker::FindClass(Thread* self,
     LOG(WARNING) << "Initiating class loader of type " << DescriptorToDot(loader_class_name)
         << " is not well-behaved; it returned a different Class for racing loadClass(\""
         << DescriptorToDot(descriptor) << "\").";
-    return EnsureResolved(self, descriptor, old);
+    return EnsureResolved(self, sv_descriptor, old);
   }
   if (UNLIKELY(!descriptor_equals)) {
     std::string result_storage;
@@ -3445,10 +3485,12 @@ struct ScopedDefiningClass {
 
 ObjPtr<mirror::Class> ClassLinker::DefineClass(Thread* self,
                                                const char* descriptor,
+                                               size_t descriptor_length,
                                                size_t hash,
                                                Handle<mirror::ClassLoader> class_loader,
                                                const DexFile& dex_file,
                                                const dex::ClassDef& dex_class_def) {
+  std::string_view sv_descriptor(descriptor, descriptor_length);
   ScopedDefiningClass sdc(self);
   StackHandleScope<3> hs(self);
   metrics::AutoTimer timer{GetMetrics()->ClassLoadingTotalTime()};
@@ -3458,17 +3500,17 @@ ObjPtr<mirror::Class> ClassLinker::DefineClass(Thread* self,
   // Load the class from the dex file.
   if (UNLIKELY(!init_done_)) {
     // finish up init of hand crafted class_roots_
-    if (strcmp(descriptor, "Ljava/lang/Object;") == 0) {
+    if (sv_descriptor == "Ljava/lang/Object;") {
       klass.Assign(GetClassRoot<mirror::Object>(this));
-    } else if (strcmp(descriptor, "Ljava/lang/Class;") == 0) {
+    } else if (sv_descriptor == "Ljava/lang/Class;") {
       klass.Assign(GetClassRoot<mirror::Class>(this));
-    } else if (strcmp(descriptor, "Ljava/lang/String;") == 0) {
+    } else if (sv_descriptor == "Ljava/lang/String;") {
       klass.Assign(GetClassRoot<mirror::String>(this));
-    } else if (strcmp(descriptor, "Ljava/lang/ref/Reference;") == 0) {
+    } else if (sv_descriptor == "Ljava/lang/ref/Reference;") {
       klass.Assign(GetClassRoot<mirror::Reference>(this));
-    } else if (strcmp(descriptor, "Ljava/lang/DexCache;") == 0) {
+    } else if (sv_descriptor == "Ljava/lang/DexCache;") {
       klass.Assign(GetClassRoot<mirror::DexCache>(this));
-    } else if (strcmp(descriptor, "Ldalvik/system/ClassExt;") == 0) {
+    } else if (sv_descriptor == "Ldalvik/system/ClassExt;") {
       klass.Assign(GetClassRoot<mirror::ClassExt>(this));
     }
   }
@@ -3542,7 +3584,7 @@ ObjPtr<mirror::Class> ClassLinker::DefineClass(Thread* self,
 
   // Mark the string class by setting its access flag.
   if (UNLIKELY(!init_done_)) {
-    if (strcmp(descriptor, "Ljava/lang/String;") == 0) {
+    if (sv_descriptor == "Ljava/lang/String;") {
       klass->SetStringClass();
     }
   }
@@ -3553,11 +3595,11 @@ ObjPtr<mirror::Class> ClassLinker::DefineClass(Thread* self,
   klass->SetIfTable(GetClassRoot<mirror::Object>(this)->GetIfTable());
 
   // Add the newly loaded class to the loaded classes table.
-  ObjPtr<mirror::Class> existing = InsertClass(descriptor, klass.Get(), hash);
+  ObjPtr<mirror::Class> existing = InsertClass(sv_descriptor, klass.Get(), hash);
   if (existing != nullptr) {
     // We failed to insert because we raced with another thread. Calling EnsureResolved may cause
     // this thread to block.
-    return sdc.Finish(EnsureResolved(self, descriptor, existing));
+    return sdc.Finish(EnsureResolved(self, sv_descriptor, existing));
   }
 
   // Load the fields and other things after we are inserted in the table. This is so that we don't
@@ -4123,20 +4165,17 @@ void ClassLinker::LoadMethod(const DexFile& dex_file,
     }
   } else if (method_name[0] == '<') {
     // Fix broken access flags for initializers. Bug 11157540.
-    bool is_init = has_ascii_name("<init>", sizeof("<init>") - 1u);
-    bool is_clinit = has_ascii_name("<clinit>", sizeof("<clinit>") - 1u);
-    if (UNLIKELY(!is_init && !is_clinit)) {
-      LOG(WARNING) << "Unexpected '<' at start of method name " << method_name;
-    } else {
-      if (UNLIKELY((access_flags & kAccConstructor) == 0)) {
-        LOG(WARNING) << method_name << " didn't have expected constructor access flag in class "
-            << klass->PrettyDescriptor() << " in dex file " << dex_file.GetLocation();
-        access_flags |= kAccConstructor;
-      }
+    // `DexFileVerifier` rejects method names starting with '<' other than constructors.
+    DCHECK(has_ascii_name("<init>", sizeof("<init>") - 1u) ||
+           has_ascii_name("<clinit>", sizeof("<clinit>") - 1u)) << method_name;
+    if (UNLIKELY((access_flags & kAccConstructor) == 0)) {
+      LOG(WARNING) << method_name << " didn't have expected constructor access flag in class "
+          << klass->PrettyDescriptor() << " in dex file " << dex_file.GetLocation();
+      access_flags |= kAccConstructor;
     }
   }
 
-  access_flags |= GetNterpFastPathFlags(shorty, access_flags, kRuntimeISA);
+  access_flags |= GetNterpFastPathFlags(shorty, access_flags, kRuntimeQuickCodeISA);
 
   if (UNLIKELY((access_flags & kAccNative) != 0u)) {
     // Check if the native method is annotated with @FastNative or @CriticalNative.
@@ -4558,7 +4597,7 @@ void ClassLinker::CreatePrimitiveClass(Thread* self,
   DCHECK_EQ(primitive_class->NumMethods(), 0u);
   // Primitive classes are initialized during single threaded startup, so visibly initialized.
   primitive_class->SetStatusForPrimitiveOrArray(ClassStatus::kVisiblyInitialized);
-  const char* descriptor = Primitive::Descriptor(type);
+  std::string_view descriptor(Primitive::Descriptor(type));
   ObjPtr<mirror::Class> existing = InsertClass(descriptor,
                                                primitive_class,
                                                ComputeModifiedUtf8Hash(descriptor));
@@ -4585,10 +4624,12 @@ inline ObjPtr<mirror::IfTable> ClassLinker::GetArrayIfTable() {
 // Returns null with an exception raised on failure.
 ObjPtr<mirror::Class> ClassLinker::CreateArrayClass(Thread* self,
                                                     const char* descriptor,
+                                                    size_t descriptor_length,
                                                     size_t hash,
                                                     Handle<mirror::ClassLoader> class_loader) {
   // Identify the underlying component type
   CHECK_EQ('[', descriptor[0]);
+  std::string_view sv_descriptor(descriptor, descriptor_length);
   StackHandleScope<2> hs(self);
 
   // This is to prevent the calls to ClassLoad and ClassPrepare which can cause java/user-supplied
@@ -4602,14 +4643,16 @@ ObjPtr<mirror::Class> ClassLinker::CreateArrayClass(Thread* self,
     return nullptr;
   }
 
-  MutableHandle<mirror::Class> component_type(hs.NewHandle(FindClass(self, descriptor + 1,
-                                                                     class_loader)));
+  MutableHandle<mirror::Class> component_type =
+      hs.NewHandle(FindClass(self, descriptor + 1, descriptor_length - 1, class_loader));
   if (component_type == nullptr) {
     DCHECK(self->IsExceptionPending());
     // We need to accept erroneous classes as component types. Under AOT, we
     // don't accept them as we cannot encode the erroneous class in an image.
-    const size_t component_hash = ComputeModifiedUtf8Hash(descriptor + 1);
-    component_type.Assign(LookupClass(self, descriptor + 1, component_hash, class_loader.Get()));
+    std::string_view component_descriptor = sv_descriptor.substr(1u);
+    const size_t component_hash = ComputeModifiedUtf8Hash(component_descriptor);
+    component_type.Assign(
+        LookupClass(self, component_descriptor, component_hash, class_loader.Get()));
     if (component_type == nullptr || Runtime::Current()->IsAotCompiler()) {
       DCHECK(self->IsExceptionPending());
       return nullptr;
@@ -4640,7 +4683,7 @@ ObjPtr<mirror::Class> ClassLinker::CreateArrayClass(Thread* self,
   // other threads.)
   if (class_loader.Get() != component_type->GetClassLoader()) {
     ObjPtr<mirror::Class> new_class =
-        LookupClass(self, descriptor, hash, component_type->GetClassLoader());
+        LookupClass(self, sv_descriptor, hash, component_type->GetClassLoader());
     if (new_class != nullptr) {
       return new_class;
     }
@@ -4684,7 +4727,7 @@ ObjPtr<mirror::Class> ClassLinker::CreateArrayClass(Thread* self,
     return nullptr;
   }
 
-  ObjPtr<mirror::Class> existing = InsertClass(descriptor, new_class.Get(), hash);
+  ObjPtr<mirror::Class> existing = InsertClass(sv_descriptor, new_class.Get(), hash);
   if (existing == nullptr) {
     // We postpone ClassLoad and ClassPrepare events to this point in time to avoid
     // duplicate events in case of races. Array classes don't really follow dedicated
@@ -4731,7 +4774,7 @@ ObjPtr<mirror::Class> ClassLinker::FindPrimitiveClass(char type) {
   return result;
 }
 
-ObjPtr<mirror::Class> ClassLinker::InsertClass(const char* descriptor,
+ObjPtr<mirror::Class> ClassLinker::InsertClass(std::string_view descriptor,
                                                ObjPtr<mirror::Class> klass,
                                                size_t hash) {
   DCHECK(Thread::Current()->CanLoadClasses());
@@ -4784,13 +4827,13 @@ void ClassLinker::UpdateClassMethods(ObjPtr<mirror::Class> klass,
 }
 
 ObjPtr<mirror::Class> ClassLinker::LookupClass(Thread* self,
-                                               const char* descriptor,
+                                               std::string_view descriptor,
                                                ObjPtr<mirror::ClassLoader> class_loader) {
   return LookupClass(self, descriptor, ComputeModifiedUtf8Hash(descriptor), class_loader);
 }
 
 ObjPtr<mirror::Class> ClassLinker::LookupClass(Thread* self,
-                                               const char* descriptor,
+                                               std::string_view descriptor,
                                                size_t hash,
                                                ObjPtr<mirror::ClassLoader> class_loader) {
   ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_);
@@ -4825,47 +4868,6 @@ void ClassLinker::MoveClassTableToPreZygote() {
   VisitClassLoaders(&visitor);
 }
 
-// Look up classes by hash and descriptor and put all matching ones in the result array.
-class LookupClassesVisitor : public ClassLoaderVisitor {
- public:
-  LookupClassesVisitor(const char* descriptor,
-                       size_t hash,
-                       std::vector<ObjPtr<mirror::Class>>* result)
-     : descriptor_(descriptor),
-       hash_(hash),
-       result_(result) {}
-
-  void Visit(ObjPtr<mirror::ClassLoader> class_loader)
-      REQUIRES_SHARED(Locks::classlinker_classes_lock_, Locks::mutator_lock_) override {
-    ClassTable* const class_table = class_loader->GetClassTable();
-    ObjPtr<mirror::Class> klass = class_table->Lookup(descriptor_, hash_);
-    // Add `klass` only if `class_loader` is its defining (not just initiating) class loader.
-    if (klass != nullptr && klass->GetClassLoader() == class_loader) {
-      result_->push_back(klass);
-    }
-  }
-
- private:
-  const char* const descriptor_;
-  const size_t hash_;
-  std::vector<ObjPtr<mirror::Class>>* const result_;
-};
-
-void ClassLinker::LookupClasses(const char* descriptor,
-                                std::vector<ObjPtr<mirror::Class>>& result) {
-  result.clear();
-  Thread* const self = Thread::Current();
-  ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_);
-  const size_t hash = ComputeModifiedUtf8Hash(descriptor);
-  ObjPtr<mirror::Class> klass = boot_class_table_->Lookup(descriptor, hash);
-  if (klass != nullptr) {
-    DCHECK(klass->GetClassLoader() == nullptr);
-    result.push_back(klass);
-  }
-  LookupClassesVisitor visitor(descriptor, hash, &result);
-  VisitClassLoaders(&visitor);
-}
-
 bool ClassLinker::AttemptSupertypeVerification(Thread* self,
                                                verifier::VerifierDeps* verifier_deps,
                                                Handle<mirror::Class> klass,
@@ -5054,7 +5056,7 @@ verifier::FailureKind ClassLinker::VerifyClass(Thread* self,
                      << " in " << klass->GetDexCache()->GetLocation()->ToModifiedUtf8()
                      << ": "
                      << preverified
-                     << "( " << oat_file_class_status << ")";
+                     << " (" << oat_file_class_status << ")";
 
   // If the oat file says the class had an error, re-run the verifier. That way we will either:
   // 1) Be successful at runtime, or
@@ -5163,7 +5165,7 @@ bool ClassLinker::VerifyClassUsingOatFile(Thread* self,
     return true;
   }
   if (oat_file_class_status >= ClassStatus::kVerifiedNeedsAccessChecks) {
-    // We return that the clas has already been verified, and the caller should
+    // We return that the class has already been verified, and the caller should
     // check the class status to ensure we run with access checks.
     return true;
   }
@@ -5285,8 +5287,9 @@ ObjPtr<mirror::Class> ClassLinker::CreateProxyClass(ScopedObjectAccessAlreadyRun
   // Object has an empty iftable, copy it for that reason.
   temp_klass->SetIfTable(GetClassRoot<mirror::Object>(this)->GetIfTable());
   mirror::Class::SetStatus(temp_klass, ClassStatus::kIdx, self);
-  std::string storage;
-  const char* descriptor = temp_klass->GetDescriptor(&storage);
+  std::string descriptor;
+  const char* raw_descriptor = temp_klass->GetDescriptor(&descriptor);
+  DCHECK(raw_descriptor == descriptor.c_str());
   const size_t hash = ComputeModifiedUtf8Hash(descriptor);
 
   // Needs to be before we insert the class so that the allocator field is set.
@@ -5410,7 +5413,7 @@ ObjPtr<mirror::Class> ClassLinker::CreateProxyClass(ScopedObjectAccessAlreadyRun
     // The new class will replace the old one in the class table.
     Handle<mirror::ObjectArray<mirror::Class>> h_interfaces(
         hs.NewHandle(soa.Decode<mirror::ObjectArray<mirror::Class>>(interfaces)));
-    if (!LinkClass(self, descriptor, temp_klass, h_interfaces, &klass)) {
+    if (!LinkClass(self, descriptor.c_str(), temp_klass, h_interfaces, &klass)) {
       if (!temp_klass->IsErroneous()) {
         mirror::Class::SetStatus(temp_klass, ClassStatus::kErrorUnresolved, self);
       }
@@ -5525,6 +5528,9 @@ void ClassLinker::CreateProxyMethod(Handle<mirror::Class> klass, ArtMethod* prot
   // Clear the abstract and default flags to ensure that defaults aren't picked in
   // preference to the invocation handler.
   const uint32_t kRemoveFlags = kAccAbstract | kAccDefault;
+  static_assert((kAccDefault & kAccIntrinsicBits) != 0);
+  DCHECK(!out->IsIntrinsic()) << "Removing kAccDefault from an intrinsic would be a mistake as it "
+                              << "overlaps with kAccIntrinsicBits.";
   // Make the method final.
   // Mark kAccCompileDontBother so that we don't take JIT samples for the method. b/62349349
   const uint32_t kAddFlags = kAccFinal | kAccCompileDontBother;
@@ -8195,6 +8201,9 @@ void ClassLinker::LinkMethodsHelper<kPointerSize>::ReallocMethods(ObjPtr<mirror:
         // TODO This is rather arbitrary. We should maybe support classes where only some of its
         // methods are skip_access_checks.
         DCHECK_EQ(new_method.GetAccessFlags() & kAccNative, 0u);
+        static_assert((kAccDefault & kAccIntrinsicBits) != 0);
+        DCHECK(!new_method.IsIntrinsic()) << "Adding kAccDefault to an intrinsic would be a "
+                                          << "mistake as it overlaps with kAccIntrinsicBits.";
         constexpr uint32_t kSetFlags = kAccDefault | kAccCopied;
         constexpr uint32_t kMaskFlags = ~kAccSkipAccessChecks;
         new_method.SetAccessFlags((new_method.GetAccessFlags() | kSetFlags) & kMaskFlags);
@@ -8211,6 +8220,9 @@ void ClassLinker::LinkMethodsHelper<kPointerSize>::ReallocMethods(ObjPtr<mirror:
         uint32_t access_flags = new_method.GetAccessFlags();
         DCHECK_EQ(access_flags & (kAccNative | kAccIntrinsic), 0u);
         constexpr uint32_t kSetFlags = kAccDefault | kAccAbstract | kAccCopied;
+        static_assert((kAccDefault & kAccIntrinsicBits) != 0);
+        DCHECK(!new_method.IsIntrinsic()) << "Adding kAccDefault to an intrinsic would be a "
+                                          << "mistake as it overlaps with kAccIntrinsicBits.";
         constexpr uint32_t kMaskFlags = ~(kAccSkipAccessChecks | kAccSingleImplementation);
         new_method.SetAccessFlags((access_flags | kSetFlags) & kMaskFlags);
         new_method.SetDataPtrSize(nullptr, kPointerSize);
@@ -8838,6 +8850,9 @@ bool ClassLinker::LinkMethodsHelper<kPointerSize>::LinkMethods(
                        << "This will be a fatal error in subsequent versions of android. "
                        << "Continuing anyway.";
         }
+        static_assert((kAccDefault & kAccIntrinsicBits) != 0);
+        DCHECK(!m->IsIntrinsic()) << "Adding kAccDefault to an intrinsic would be a mistake as it "
+                                  << "overlaps with kAccIntrinsicBits.";
         m->SetAccessFlags(access_flags | kAccDefault);
         has_defaults = true;
       }
@@ -9924,7 +9939,7 @@ ObjPtr<mirror::Class> ClassLinker::DoLookupResolvedType(dex::TypeIndex type_idx,
                                                         ObjPtr<mirror::ClassLoader> class_loader) {
   DCHECK(dex_cache->GetClassLoader() == class_loader);
   const DexFile& dex_file = *dex_cache->GetDexFile();
-  const char* descriptor = dex_file.GetTypeDescriptor(type_idx);
+  std::string_view descriptor = dex_file.GetTypeDescriptorView(type_idx);
   ObjPtr<mirror::Class> type = LookupResolvedType(descriptor, class_loader);
   if (type != nullptr) {
     DCHECK(type->IsResolved());
@@ -9933,11 +9948,11 @@ ObjPtr<mirror::Class> ClassLinker::DoLookupResolvedType(dex::TypeIndex type_idx,
   return type;
 }
 
-ObjPtr<mirror::Class> ClassLinker::LookupResolvedType(const char* descriptor,
+ObjPtr<mirror::Class> ClassLinker::LookupResolvedType(std::string_view descriptor,
                                                       ObjPtr<mirror::ClassLoader> class_loader) {
-  DCHECK_NE(*descriptor, '\0') << "descriptor is empty string";
+  DCHECK(!descriptor.empty()) << "descriptor is empty string";
   ObjPtr<mirror::Class> type = nullptr;
-  if (descriptor[1] == '\0') {
+  if (descriptor.length() == 1u) {
     // only the descriptors of primitive types should be 1 character long, also avoid class lookup
     // for primitive classes that aren't backed by dex files.
     type = LookupPrimitiveClass(descriptor[0]);
@@ -9972,8 +9987,8 @@ ObjPtr<mirror::Class> ClassLinker::DoResolveType(dex::TypeIndex type_idx,
                                                  Handle<mirror::ClassLoader> class_loader) {
   DCHECK(dex_cache->GetClassLoader() == class_loader.Get());
   Thread* self = Thread::Current();
-  const char* descriptor = dex_cache->GetDexFile()->GetTypeDescriptor(type_idx);
-  ObjPtr<mirror::Class> resolved = FindClass(self, descriptor, class_loader);
+  const DexFile* dex_file = dex_cache->GetDexFile();
+  ObjPtr<mirror::Class> resolved = FindClass(self, *dex_file, type_idx, class_loader);
   if (resolved != nullptr) {
     // TODO: we used to throw here if resolved's class loader was not the
     //       boot class loader. This was to permit different classes with the
@@ -9981,14 +9996,15 @@ ObjPtr<mirror::Class> ClassLinker::DoResolveType(dex::TypeIndex type_idx,
     dex_cache->SetResolvedType(type_idx, resolved);
   } else {
     CHECK(self->IsExceptionPending())
-        << "Expected pending exception for failed resolution of: " << descriptor;
+        << "Expected pending exception for failed resolution of: "
+        << dex_file->GetTypeDescriptor(type_idx);
     // Convert a ClassNotFoundException to a NoClassDefFoundError.
     StackHandleScope<1> hs(self);
     Handle<mirror::Throwable> cause(hs.NewHandle(self->GetException()));
     if (cause->InstanceOf(GetClassRoot(ClassRoot::kJavaLangClassNotFoundException, this))) {
       DCHECK(resolved == nullptr);  // No Handle needed to preserve resolved.
       self->ClearException();
-      ThrowNoClassDefFoundError("Failed resolution of: %s", descriptor);
+      ThrowNoClassDefFoundError("Failed resolution of: %s", dex_file->GetTypeDescriptor(type_idx));
       self->GetException()->SetCause(cause.Get());
     }
   }
@@ -10092,9 +10108,9 @@ ArtMethod* ClassLinker::FindIncompatibleMethod(ObjPtr<mirror::Class> klass,
   }
 }
 
-ArtMethod* ClassLinker::ResolveMethodWithoutInvokeType(uint32_t method_idx,
-                                                       Handle<mirror::DexCache> dex_cache,
-                                                       Handle<mirror::ClassLoader> class_loader) {
+ArtMethod* ClassLinker::ResolveMethodId(uint32_t method_idx,
+                                        Handle<mirror::DexCache> dex_cache,
+                                        Handle<mirror::ClassLoader> class_loader) {
   DCHECK(dex_cache->GetClassLoader() == class_loader.Get());
   ArtMethod* resolved = dex_cache->GetResolvedMethod(method_idx);
   Thread::PoisonObjectPointersIfDebug();
@@ -10338,6 +10354,12 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForField(
       ThrowIllegalAccessErrorField(referring_class, target_field);
       return nullptr;
     }
+    // TODO(b/364876321): ResolveField might return instance field when is_static is true and
+    // vice versa.
+    if (UNLIKELY(is_static != target_field->IsStatic())) {
+      ThrowIncompatibleClassChangeErrorField(target_field, is_static, referrer);
+      return nullptr;
+    }
     if (UNLIKELY(is_put && target_field->IsFinal())) {
       ThrowIllegalAccessErrorField(referring_class, target_field);
       return nullptr;
@@ -10430,19 +10452,17 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForMethod(
     case DexFile::MethodHandleType::kInvokeStatic: {
       kind = mirror::MethodHandle::Kind::kInvokeStatic;
       receiver_count = 0;
-      target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                            method_handle.field_or_method_idx_,
-                                                            referrer,
-                                                            InvokeType::kStatic);
+      target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                              referrer,
+                                              InvokeType::kStatic);
       break;
     }
     case DexFile::MethodHandleType::kInvokeInstance: {
       kind = mirror::MethodHandle::Kind::kInvokeVirtual;
       receiver_count = 1;
-      target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                            method_handle.field_or_method_idx_,
-                                                            referrer,
-                                                            InvokeType::kVirtual);
+      target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                              referrer,
+                                              InvokeType::kVirtual);
       break;
     }
     case DexFile::MethodHandleType::kInvokeConstructor: {
@@ -10450,10 +10470,9 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForMethod(
       // are special cased later in this method.
       kind = mirror::MethodHandle::Kind::kInvokeTransform;
       receiver_count = 0;
-      target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                            method_handle.field_or_method_idx_,
-                                                            referrer,
-                                                            InvokeType::kDirect);
+      target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                              referrer,
+                                              InvokeType::kDirect);
       break;
     }
     case DexFile::MethodHandleType::kInvokeDirect: {
@@ -10466,25 +10485,23 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForMethod(
       // the invocation type to determine if the method is private. We
       // then resolve again specifying the intended invocation type to
       // force the appropriate checks.
-      target_method = ResolveMethodWithoutInvokeType(method_handle.field_or_method_idx_,
-                                                     hs.NewHandle(referrer->GetDexCache()),
-                                                     hs.NewHandle(referrer->GetClassLoader()));
+      target_method = ResolveMethodId(method_handle.field_or_method_idx_,
+                                      hs.NewHandle(referrer->GetDexCache()),
+                                      hs.NewHandle(referrer->GetClassLoader()));
       if (UNLIKELY(target_method == nullptr)) {
         break;
       }
 
       if (target_method->IsPrivate()) {
         kind = mirror::MethodHandle::Kind::kInvokeDirect;
-        target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                              method_handle.field_or_method_idx_,
-                                                              referrer,
-                                                              InvokeType::kDirect);
+        target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                                referrer,
+                                                InvokeType::kDirect);
       } else {
         kind = mirror::MethodHandle::Kind::kInvokeSuper;
-        target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                              method_handle.field_or_method_idx_,
-                                                              referrer,
-                                                              InvokeType::kSuper);
+        target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                                referrer,
+                                                InvokeType::kSuper);
         if (UNLIKELY(target_method == nullptr)) {
           break;
         }
@@ -10500,10 +10517,9 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForMethod(
     case DexFile::MethodHandleType::kInvokeInterface: {
       kind = mirror::MethodHandle::Kind::kInvokeInterface;
       receiver_count = 1;
-      target_method = ResolveMethod<ResolveMode::kNoChecks>(self,
-                                                            method_handle.field_or_method_idx_,
-                                                            referrer,
-                                                            InvokeType::kInterface);
+      target_method = ResolveMethodWithChecks(method_handle.field_or_method_idx_,
+                                              referrer,
+                                              InvokeType::kInterface);
       break;
     }
   }
@@ -10513,6 +10529,13 @@ ObjPtr<mirror::MethodHandle> ClassLinker::ResolveMethodHandleForMethod(
     return nullptr;
   }
 
+  // According to JVMS 4.4.8 none of invoke* MethodHandle-s can target <clinit> methods.
+  if (UNLIKELY(target_method->IsClassInitializer())) {
+    ThrowClassFormatError(referrer->GetDeclaringClass(),
+        "Method handles can't target class initializer method");
+    return nullptr;
+  }
+
   ObjPtr<mirror::Class> target_class = target_method->GetDeclaringClass();
   ObjPtr<mirror::Class> referring_class = referrer->GetDeclaringClass();
   uint32_t access_flags = target_method->GetAccessFlags();
diff --git a/runtime/class_linker.h b/runtime/class_linker.h
index 505566f702..4ca6024442 100644
--- a/runtime/class_linker.h
+++ b/runtime/class_linker.h
@@ -207,6 +207,15 @@ class ClassLinker {
   // If class_loader is null, searches boot_class_path_.
   EXPORT ObjPtr<mirror::Class> FindClass(Thread* self,
                                          const char* descriptor,
+                                         size_t descriptor_length,
+                                         Handle<mirror::ClassLoader> class_loader)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      REQUIRES(!Locks::dex_lock_);
+
+  // Helper overload that retrieves the descriptor and its length from the `dex_file`.
+  EXPORT ObjPtr<mirror::Class> FindClass(Thread* self,
+                                         const DexFile& dex_file,
+                                         dex::TypeIndex type_index,
                                          Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_);
@@ -216,7 +225,7 @@ class ClassLinker {
   ObjPtr<mirror::Class> FindSystemClass(Thread* self, const char* descriptor)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_) {
-    return FindClass(self, descriptor, ScopedNullHandle<mirror::ClassLoader>());
+    return FindClass(self, descriptor, strlen(descriptor), ScopedNullHandle<mirror::ClassLoader>());
   }
 
   // Finds the array class given for the element class.
@@ -232,6 +241,7 @@ class ClassLinker {
   // Define a new a class based on a ClassDef from a DexFile
   ObjPtr<mirror::Class> DefineClass(Thread* self,
                                     const char* descriptor,
+                                    size_t descriptor_length,
                                     size_t hash,
                                     Handle<mirror::ClassLoader> class_loader,
                                     const DexFile& dex_file,
@@ -242,16 +252,11 @@ class ClassLinker {
   // Finds a class by its descriptor, returning null if it isn't wasn't loaded
   // by the given 'class_loader'.
   EXPORT ObjPtr<mirror::Class> LookupClass(Thread* self,
-                                           const char* descriptor,
+                                           std::string_view descriptor,
                                            ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::classlinker_classes_lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Finds all the classes with the given descriptor, regardless of ClassLoader.
-  void LookupClasses(const char* descriptor, std::vector<ObjPtr<mirror::Class>>& classes)
-      REQUIRES(!Locks::classlinker_classes_lock_)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   ObjPtr<mirror::Class> LookupPrimitiveClass(char type) REQUIRES_SHARED(Locks::mutator_lock_);
   ObjPtr<mirror::Class> FindPrimitiveClass(char type) REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -325,17 +330,10 @@ class ClassLinker {
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Look up a resolved type with the given descriptor associated with the given ClassLoader.
-  ObjPtr<mirror::Class> LookupResolvedType(const char* descriptor,
+  ObjPtr<mirror::Class> LookupResolvedType(std::string_view descriptor,
                                            ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Determine whether a dex cache result should be trusted, or an IncompatibleClassChangeError
-  // check and IllegalAccessError check should be performed even after a hit.
-  enum class ResolveMode {  // private.
-    kNoChecks,
-    kCheckICCEAndIAE
-  };
-
   // Look up a previously resolved method with the given index.
   ArtMethod* LookupResolvedMethod(uint32_t method_idx,
                                   ObjPtr<mirror::DexCache> dex_cache,
@@ -358,27 +356,26 @@ class ClassLinker {
                                     uint32_t method_idx)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Resolve a method with a given ID from the DexFile associated with the given DexCache
-  // and ClassLoader, storing the result in DexCache. The ClassLinker and ClassLoader are
-  // used as in ResolveType. What is unique is the method type argument which is used to
-  // determine if this method is a direct, static, or virtual method.
-  template <ResolveMode kResolveMode>
-  ArtMethod* ResolveMethod(uint32_t method_idx,
-                           Handle<mirror::DexCache> dex_cache,
-                           Handle<mirror::ClassLoader> class_loader,
-                           ArtMethod* referrer,
-                           InvokeType type)
+  // Check invoke type against the referenced class. Throws IncompatibleClassChangeError
+  // and returns true on mismatch (kInterface on a non-interface class,
+  // kVirtual on interface, kDefault on interface for dex files not supporting default methods),
+  // otherwise returns false.
+  static bool ThrowIfInvokeClassMismatch(ObjPtr<mirror::Class> cls,
+                                         const DexFile& dex_file,
+                                         InvokeType type)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  ArtMethod* ResolveMethodWithChecks(uint32_t method_idx, ArtMethod* referrer, InvokeType type)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
-  template <ResolveMode kResolveMode>
-  ArtMethod* ResolveMethod(Thread* self, uint32_t method_idx, ArtMethod* referrer, InvokeType type)
+  EXPORT ArtMethod* ResolveMethodId(uint32_t method_idx,
+                                    Handle<mirror::DexCache> dex_cache,
+                                    Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
-  EXPORT ArtMethod* ResolveMethodWithoutInvokeType(uint32_t method_idx,
-                                                   Handle<mirror::DexCache> dex_cache,
-                                                   Handle<mirror::ClassLoader> class_loader)
+  ArtMethod* ResolveMethodId(uint32_t method_idx, ArtMethod* referrer)
       REQUIRES_SHARED(Locks::mutator_lock_)
       REQUIRES(!Locks::dex_lock_, !Roles::uninterruptible_);
 
@@ -664,7 +661,7 @@ class ClassLinker {
   // Attempts to insert a class into a class table.  Returns null if
   // the class was inserted, otherwise returns an existing class with
   // the same descriptor and ClassLoader.
-  ObjPtr<mirror::Class> InsertClass(const char* descriptor,
+  ObjPtr<mirror::Class> InsertClass(std::string_view descriptor,
                                     ObjPtr<mirror::Class> klass,
                                     size_t hash)
       REQUIRES(!Locks::classlinker_classes_lock_)
@@ -1106,6 +1103,7 @@ class ClassLinker {
 
   ObjPtr<mirror::Class> CreateArrayClass(Thread* self,
                                          const char* descriptor,
+                                         size_t descriptor_length,
                                          size_t hash,
                                          Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_)
@@ -1140,6 +1138,7 @@ class ClassLinker {
   // PathClassLoader are supported).
   bool FindClassInBaseDexClassLoader(Thread* self,
                                      const char* descriptor,
+                                     size_t descriptor_length,
                                      size_t hash,
                                      Handle<mirror::ClassLoader> class_loader,
                                      /*out*/ ObjPtr<mirror::Class>* result)
@@ -1148,6 +1147,7 @@ class ClassLinker {
 
   bool FindClassInSharedLibraries(Thread* self,
                                   const char* descriptor,
+                                  size_t descriptor_length,
                                   size_t hash,
                                   Handle<mirror::ClassLoader> class_loader,
                                   /*out*/ ObjPtr<mirror::Class>* result)
@@ -1156,6 +1156,7 @@ class ClassLinker {
 
   bool FindClassInSharedLibrariesHelper(Thread* self,
                                         const char* descriptor,
+                                        size_t descriptor_length,
                                         size_t hash,
                                         Handle<mirror::ClassLoader> class_loader,
                                         ArtField* field,
@@ -1165,6 +1166,7 @@ class ClassLinker {
 
   bool FindClassInSharedLibrariesAfter(Thread* self,
                                        const char* descriptor,
+                                       size_t descriptor_length,
                                        size_t hash,
                                        Handle<mirror::ClassLoader> class_loader,
                                        /*out*/ ObjPtr<mirror::Class>* result)
@@ -1181,6 +1183,7 @@ class ClassLinker {
   bool FindClassInBaseDexClassLoaderClassPath(
           Thread* self,
           const char* descriptor,
+          size_t descriptor_length,
           size_t hash,
           Handle<mirror::ClassLoader> class_loader,
           /*out*/ ObjPtr<mirror::Class>* result)
@@ -1193,6 +1196,7 @@ class ClassLinker {
   // boot class loader has a known lookup.
   bool FindClassInBootClassLoaderClassPath(Thread* self,
                                            const char* descriptor,
+                                           size_t descriptor_length,
                                            size_t hash,
                                            /*out*/ ObjPtr<mirror::Class>* result)
       REQUIRES_SHARED(Locks::mutator_lock_)
@@ -1235,7 +1239,7 @@ class ClassLinker {
   // Finds a class by its descriptor, returning NULL if it isn't wasn't loaded
   // by the given 'class_loader'. Uses the provided hash for the descriptor.
   ObjPtr<mirror::Class> LookupClass(Thread* self,
-                                    const char* descriptor,
+                                    std::string_view descriptor,
                                     size_t hash,
                                     ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::classlinker_classes_lock_)
@@ -1346,7 +1350,7 @@ class ClassLinker {
   // retire a class, the version of the class in the table is returned and this may differ from
   // the class passed in.
   ObjPtr<mirror::Class> EnsureResolved(Thread* self,
-                                       const char* descriptor,
+                                       std::string_view descriptor,
                                        ObjPtr<mirror::Class> klass)
       WARN_UNUSED
       REQUIRES_SHARED(Locks::mutator_lock_)
@@ -1396,23 +1400,6 @@ class ClassLinker {
                           /*out*/bool* new_conflict,
                           /*out*/ArtMethod** imt) REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Check invoke type against the referenced class. Throws IncompatibleClassChangeError
-  // (if `kThrowOnError`) and returns true on mismatch (kInterface on a non-interface class,
-  // kVirtual on interface, kDefault on interface for dex files not supporting default methods),
-  // otherwise returns false.
-  template <bool kThrowOnError, typename ClassGetter>
-  static bool CheckInvokeClassMismatch(ObjPtr<mirror::DexCache> dex_cache,
-                                       InvokeType type,
-                                       ClassGetter class_getter)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  // Helper that feeds the above function with `ClassGetter` doing `LookupResolvedType()`.
-  template <bool kThrow>
-  bool CheckInvokeClassMismatch(ObjPtr<mirror::DexCache> dex_cache,
-                                InvokeType type,
-                                uint32_t method_idx,
-                                ObjPtr<mirror::ClassLoader> class_loader)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   ObjPtr<mirror::IfTable> GetArrayIfTable() REQUIRES_SHARED(Locks::mutator_lock_);
 
   bool OpenAndInitImageDexFiles(const gc::space::ImageSpace* space,
diff --git a/runtime/class_linker_test.cc b/runtime/class_linker_test.cc
index 9c4e0289ae..d4fcefef27 100644
--- a/runtime/class_linker_test.cc
+++ b/runtime/class_linker_test.cc
@@ -181,8 +181,7 @@ class ClassLinkerTest : public CommonRuntimeTest {
     Thread* self = Thread::Current();
     StackHandleScope<2> hs(self);
     Handle<mirror::ClassLoader> loader(hs.NewHandle(class_loader));
-    Handle<mirror::Class> array(
-        hs.NewHandle(class_linker_->FindClass(self, array_descriptor.c_str(), loader)));
+    Handle<mirror::Class> array = hs.NewHandle(FindClass(array_descriptor.c_str(), loader));
     std::string temp;
     EXPECT_STREQ(component_type.c_str(), array->GetComponentType()->GetDescriptor(&temp));
     EXPECT_OBJ_PTR_EQ(loader.Get(), array->GetClassLoader());
@@ -912,13 +911,12 @@ TEST_F(ClassLinkerTest, FindClassNested) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Nested"))));
 
-  ObjPtr<mirror::Class> outer = class_linker_->FindClass(soa.Self(), "LNested;", class_loader);
+  ObjPtr<mirror::Class> outer = FindClass("LNested;", class_loader);
   ASSERT_TRUE(outer != nullptr);
   EXPECT_EQ(0U, outer->NumVirtualMethods());
   EXPECT_EQ(1U, outer->NumDirectMethods());
 
-  ObjPtr<mirror::Class> inner =
-      class_linker_->FindClass(soa.Self(), "LNested$Inner;", class_loader);
+  ObjPtr<mirror::Class> inner = FindClass("LNested$Inner;", class_loader);
   ASSERT_TRUE(inner != nullptr);
   EXPECT_EQ(0U, inner->NumVirtualMethods());
   EXPECT_EQ(1U, inner->NumDirectMethods());
@@ -948,7 +946,7 @@ TEST_F(ClassLinkerTest, FindClass) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("MyClass"))));
   AssertNonExistentClass("LMyClass;");
-  ObjPtr<mirror::Class> MyClass = class_linker_->FindClass(soa.Self(), "LMyClass;", class_loader);
+  ObjPtr<mirror::Class> MyClass = FindClass("LMyClass;", class_loader);
   ASSERT_TRUE(MyClass != nullptr);
   ASSERT_TRUE(MyClass->GetClass() != nullptr);
   ASSERT_OBJ_PTR_EQ(MyClass->GetClass(), MyClass->GetClass()->GetClass());
@@ -997,7 +995,7 @@ TEST_F(ClassLinkerTest, LookupResolvedType) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("MyClass"))));
   AssertNonExistentClass("LMyClass;");
-  ObjPtr<mirror::Class> klass = class_linker_->FindClass(soa.Self(), "LMyClass;", class_loader);
+  ObjPtr<mirror::Class> klass = FindClass("LMyClass;", class_loader);
   dex::TypeIndex type_idx = klass->GetClassDef()->class_idx_;
   ObjPtr<mirror::DexCache> dex_cache = klass->GetDexCache();
   EXPECT_OBJ_PTR_EQ(
@@ -1017,8 +1015,7 @@ TEST_F(ClassLinkerTest, LookupResolvedTypeArray) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("AllFields"))));
   // Get the AllFields class for the dex cache and dex file.
-  ObjPtr<mirror::Class> all_fields_klass
-      = class_linker_->FindClass(soa.Self(), "LAllFields;", class_loader);
+  ObjPtr<mirror::Class> all_fields_klass = FindClass("LAllFields;", class_loader);
   ASSERT_TRUE(all_fields_klass != nullptr);
   Handle<mirror::DexCache> dex_cache = hs.NewHandle(all_fields_klass->GetDexCache());
   const DexFile& dex_file = *dex_cache->GetDexFile();
@@ -1030,8 +1027,7 @@ TEST_F(ClassLinkerTest, LookupResolvedTypeArray) {
   EXPECT_TRUE(
       class_linker_->LookupResolvedType(array_idx, dex_cache.Get(), class_loader.Get()) == nullptr);
   // Resolve the array class we want to test.
-  ObjPtr<mirror::Class> array_klass
-      = class_linker_->FindClass(soa.Self(), "[Ljava/lang/Object;", class_loader);
+  ObjPtr<mirror::Class> array_klass = FindClass("[Ljava/lang/Object;", class_loader);
   ASSERT_TRUE(array_klass != nullptr);
   // Test that LookupResolvedType() finds the array class.
   EXPECT_OBJ_PTR_EQ(
@@ -1051,8 +1047,7 @@ TEST_F(ClassLinkerTest, LookupResolvedTypeErroneousInit) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("ErroneousInit"))));
   AssertNonExistentClass("LErroneousInit;");
-  Handle<mirror::Class> klass =
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LErroneousInit;", class_loader));
+  Handle<mirror::Class> klass = hs.NewHandle(FindClass("LErroneousInit;", class_loader));
   ASSERT_TRUE(klass != nullptr);
   dex::TypeIndex type_idx = klass->GetClassDef()->class_idx_;
   Handle<mirror::DexCache> dex_cache = hs.NewHandle(klass->GetDexCache());
@@ -1146,21 +1141,21 @@ TEST_F(ClassLinkerTest, ValidateBoxedTypes) {
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> class_loader;
   ObjPtr<mirror::Class> c;
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Boolean;", class_loader);
+  c = FindClass("Ljava/lang/Boolean;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Byte;", class_loader);
+  c = FindClass("Ljava/lang/Byte;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Character;", class_loader);
+  c = FindClass("Ljava/lang/Character;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Double;", class_loader);
+  c = FindClass("Ljava/lang/Double;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Float;", class_loader);
+  c = FindClass("Ljava/lang/Float;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Integer;", class_loader);
+  c = FindClass("Ljava/lang/Integer;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Long;", class_loader);
+  c = FindClass("Ljava/lang/Long;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Short;", class_loader);
+  c = FindClass("Ljava/lang/Short;", class_loader);
   EXPECT_STREQ("value", c->GetIFieldsPtr()->At(0).GetName());
 }
 
@@ -1171,10 +1166,8 @@ TEST_F(ClassLinkerTest, TwoClassLoadersOneClass) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("MyClass"))));
   Handle<mirror::ClassLoader> class_loader_2(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("MyClass"))));
-  Handle<mirror::Class> MyClass_1 = hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LMyClass;", class_loader_1));
-  ObjPtr<mirror::Class> MyClass_2 =
-      class_linker_->FindClass(soa.Self(), "LMyClass;", class_loader_2);
+  Handle<mirror::Class> MyClass_1 = hs.NewHandle(FindClass("LMyClass;", class_loader_1));
+  ObjPtr<mirror::Class> MyClass_2 = FindClass("LMyClass;", class_loader_2);
   EXPECT_TRUE(MyClass_1 != nullptr);
   EXPECT_TRUE(MyClass_2 != nullptr);
   EXPECT_OBJ_PTR_NE(MyClass_1.Get(), MyClass_2);
@@ -1185,8 +1178,7 @@ TEST_F(ClassLinkerTest, StaticFields) {
   StackHandleScope<2> hs(soa.Self());
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Statics"))));
-  Handle<mirror::Class> statics(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStatics;", class_loader)));
+  Handle<mirror::Class> statics = hs.NewHandle(FindClass("LStatics;", class_loader));
   class_linker_->EnsureInitialized(soa.Self(), statics, true, true);
 
   // Static final primitives that are initialized by a compile-time constant
@@ -1261,16 +1253,11 @@ TEST_F(ClassLinkerTest, Interfaces) {
   StackHandleScope<6> hs(soa.Self());
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Interfaces"))));
-  Handle<mirror::Class> I(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInterfaces$I;", class_loader)));
-  Handle<mirror::Class> J(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInterfaces$J;", class_loader)));
-  Handle<mirror::Class> K(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInterfaces$K;", class_loader)));
-  Handle<mirror::Class> A(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInterfaces$A;", class_loader)));
-  Handle<mirror::Class> B(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LInterfaces$B;", class_loader)));
+  Handle<mirror::Class> I = hs.NewHandle(FindClass("LInterfaces$I;", class_loader));
+  Handle<mirror::Class> J = hs.NewHandle(FindClass("LInterfaces$J;", class_loader));
+  Handle<mirror::Class> K = hs.NewHandle(FindClass("LInterfaces$K;", class_loader));
+  Handle<mirror::Class> A = hs.NewHandle(FindClass("LInterfaces$A;", class_loader));
+  Handle<mirror::Class> B = hs.NewHandle(FindClass("LInterfaces$B;", class_loader));
   EXPECT_TRUE(I->IsAssignableFrom(A.Get()));
   EXPECT_TRUE(J->IsAssignableFrom(A.Get()));
   EXPECT_TRUE(J->IsAssignableFrom(K.Get()));
@@ -1336,8 +1323,7 @@ TEST_F(ClassLinkerTest, ResolveVerifyAndClinit) {
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
-  ObjPtr<mirror::Class> klass =
-      class_linker_->FindClass(soa.Self(), "LStaticsFromCode;", class_loader);
+  ObjPtr<mirror::Class> klass = FindClass("LStaticsFromCode;", class_loader);
   ArtMethod* clinit = klass->FindClassInitializer(kRuntimePointerSize);
   ArtMethod* getS0 =
       klass->FindClassMethod("getS0", "()Ljava/lang/Object;", kRuntimePointerSize);
@@ -1370,7 +1356,7 @@ TEST_F(ClassLinkerTest, ErroneousClass) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
   hs.Self()->AssertNoPendingException();
   const char* descriptor = "LErroneous;";
-  ObjPtr<mirror::Class> klass = class_linker_->FindClass(soa.Self(), descriptor, class_loader);
+  ObjPtr<mirror::Class> klass = FindClass(descriptor, class_loader);
   // Erronenous since we are extending final class.
   hs.Self()->AssertPendingException();
   EXPECT_TRUE(klass == nullptr);
@@ -1429,19 +1415,19 @@ TEST_F(ClassLinkerTest, ValidatePredefinedClassSizes) {
   ScopedNullHandle<mirror::ClassLoader> class_loader;
   ObjPtr<mirror::Class> c;
 
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Class;", class_loader);
+  c = FindClass("Ljava/lang/Class;", class_loader);
   ASSERT_TRUE(c != nullptr);
   EXPECT_EQ(c->GetClassSize(), mirror::Class::ClassClassSize(kRuntimePointerSize));
 
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/Object;", class_loader);
+  c = FindClass("Ljava/lang/Object;", class_loader);
   ASSERT_TRUE(c != nullptr);
   EXPECT_EQ(c->GetClassSize(), mirror::Object::ClassSize(kRuntimePointerSize));
 
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/String;", class_loader);
+  c = FindClass("Ljava/lang/String;", class_loader);
   ASSERT_TRUE(c != nullptr);
   EXPECT_EQ(c->GetClassSize(), mirror::String::ClassSize(kRuntimePointerSize));
 
-  c = class_linker_->FindClass(soa.Self(), "Ljava/lang/DexCache;", class_loader);
+  c = FindClass("Ljava/lang/DexCache;", class_loader);
   ASSERT_TRUE(c != nullptr);
   EXPECT_EQ(c->GetClassSize(), mirror::DexCache::ClassSize(kRuntimePointerSize));
 }
@@ -1494,8 +1480,7 @@ TEST_F(ClassLinkerTest, Preverified_App) {
   StackHandleScope<2> hs(soa.Self());
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("Statics"))));
-  Handle<mirror::Class> statics(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStatics;", class_loader)));
+  Handle<mirror::Class> statics = hs.NewHandle(FindClass("LStatics;", class_loader));
 
   CheckVerificationAttempted(statics.Get(), false);
 
@@ -1517,8 +1502,7 @@ TEST_F(ClassLinkerTest, IsBootStrapClassLoaded) {
   EXPECT_TRUE(jlo_class->IsBootStrapClassLoaded());
 
   // Statics is not a bootstrap class.
-  Handle<mirror::Class> statics(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStatics;", class_loader)));
+  Handle<mirror::Class> statics = hs.NewHandle(FindClass("LStatics;", class_loader));
   ASSERT_TRUE(statics != nullptr);
   EXPECT_FALSE(statics->IsBootStrapClassLoaded());
 }
@@ -1568,8 +1552,7 @@ TEST_F(ClassLinkerMethodHandlesTest, TestResolveMethodTypes) {
 
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(LoadDex("MethodTypes"))));
-  Handle<mirror::Class> method_types(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LMethodTypes;", class_loader)));
+  Handle<mirror::Class> method_types = hs.NewHandle(FindClass("LMethodTypes;", class_loader));
   class_linker_->EnsureInitialized(soa.Self(), method_types, true, true);
 
   ArtMethod* method1 = method_types->FindClassMethod(
@@ -1596,9 +1579,7 @@ TEST_F(ClassLinkerMethodHandlesTest, TestResolveMethodTypes) {
   ASSERT_TRUE(method1_type != nullptr);
 
   // Assert that the return type and the method arguments are as we expect.
-  Handle<mirror::Class> string_class(hs.NewHandle(class_linker_->FindClass(soa.Self(),
-                                                                           "Ljava/lang/String;",
-                                                                           class_loader)));
+  Handle<mirror::Class> string_class = hs.NewHandle(FindClass("Ljava/lang/String;", class_loader));
   ASSERT_OBJ_PTR_EQ(string_class.Get(), method1_type->GetRType());
   ASSERT_OBJ_PTR_EQ(string_class.Get(), method1_type->GetPTypes()->Get(0));
 
@@ -1704,8 +1685,8 @@ class ClassLinkerClassLoaderTest : public ClassLinkerTest {
     Handle<mirror::ClassLoader> class_loader_to_search(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader_to_search_obj)));
 
-    Handle<mirror::Class> klass = hs.NewHandle(
-        class_linker_->FindClass(soa.Self(), descriptor.c_str(), class_loader_to_search));
+    Handle<mirror::Class> klass =
+        hs.NewHandle(FindClass(descriptor.c_str(), class_loader_to_search));
 
     if (!should_find) {
       if (self->IsExceptionPending()) {
diff --git a/runtime/class_table.cc b/runtime/class_table.cc
index 35d3537478..5a20c2f576 100644
--- a/runtime/class_table.cc
+++ b/runtime/class_table.cc
@@ -104,7 +104,7 @@ size_t ClassTable::NumReferencedNonZygoteClasses() const {
   return classes_.back().size();
 }
 
-ObjPtr<mirror::Class> ClassTable::Lookup(const char* descriptor, size_t hash) {
+ObjPtr<mirror::Class> ClassTable::Lookup(std::string_view descriptor, size_t hash) {
   DescriptorHashPair pair(descriptor, hash);
   ReaderMutexLock mu(Thread::Current(), lock_);
   // Search from the last table, assuming that apps shall search for their own classes
diff --git a/runtime/class_table.h b/runtime/class_table.h
index 3374622f00..64ae758208 100644
--- a/runtime/class_table.h
+++ b/runtime/class_table.h
@@ -114,14 +114,15 @@ class ClassTable {
     static constexpr uint32_t kHashMask = kObjectAlignment - 1;
   };
 
-  using DescriptorHashPair = std::pair<const char*, uint32_t>;
+  using DescriptorHashPair = std::pair<std::string_view, uint32_t>;
 
   class ClassDescriptorHash {
    public:
     // uint32_t for cross compilation.
+    // NO_THREAD_SAFETY_ANALYSIS: Used from unannotated `HashSet<>` functions.
     uint32_t operator()(const TableSlot& slot) const NO_THREAD_SAFETY_ANALYSIS;
     // uint32_t for cross compilation.
-    uint32_t operator()(const DescriptorHashPair& pair) const NO_THREAD_SAFETY_ANALYSIS;
+    uint32_t operator()(const DescriptorHashPair& pair) const;
   };
 
   class ClassDescriptorEquals {
@@ -221,7 +222,7 @@ class ClassTable {
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Return the first class that matches the descriptor. Returns null if there are none.
-  ObjPtr<mirror::Class> Lookup(const char* descriptor, size_t hash)
+  ObjPtr<mirror::Class> Lookup(std::string_view descriptor, size_t hash)
       REQUIRES(!lock_)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
diff --git a/runtime/class_table_test.cc b/runtime/class_table_test.cc
index 15cca6dda9..88530bcec8 100644
--- a/runtime/class_table_test.cc
+++ b/runtime/class_table_test.cc
@@ -80,10 +80,8 @@ TEST_F(ClassTableTest, ClassTable) {
   Handle<ClassLoader> class_loader(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader)));
   const char* descriptor_x = "LX;";
   const char* descriptor_y = "LY;";
-  Handle<mirror::Class> h_X(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), descriptor_x, class_loader)));
-  Handle<mirror::Class> h_Y(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), descriptor_y, class_loader)));
+  Handle<mirror::Class> h_X = hs.NewHandle(FindClass(descriptor_x, class_loader));
+  Handle<mirror::Class> h_Y = hs.NewHandle(FindClass(descriptor_y, class_loader));
   Handle<mirror::Object> obj_X = hs.NewHandle(h_X->AllocObject(soa.Self()));
   ASSERT_TRUE(obj_X != nullptr);
   ClassTable table;
diff --git a/runtime/common_runtime_test.cc b/runtime/common_runtime_test.cc
index 165b3a9c8a..ab7ddbcb25 100644
--- a/runtime/common_runtime_test.cc
+++ b/runtime/common_runtime_test.cc
@@ -601,6 +601,12 @@ void CommonRuntimeTestImpl::GenerateProfile(ArrayRef<const std::string> dexes,
   EXPECT_EQ(out_file->Flush(), 0);
 }
 
+ObjPtr<mirror::Class> CommonRuntimeTestImpl::FindClass(
+    const char* descriptor,
+    Handle<mirror::ClassLoader> class_loader) const {
+  return class_linker_->FindClass(Thread::Current(), descriptor, strlen(descriptor), class_loader);
+}
+
 CheckJniAbortCatcher::CheckJniAbortCatcher() : vm_(Runtime::Current()->GetJavaVM()) {
   vm_->SetCheckJniAbortHook(Hook, &actual_);
 }
diff --git a/runtime/common_runtime_test.h b/runtime/common_runtime_test.h
index 87c8d111f0..7c20de30fd 100644
--- a/runtime/common_runtime_test.h
+++ b/runtime/common_runtime_test.h
@@ -32,7 +32,6 @@
 #include "base/os.h"
 #include "base/unix_file/fd_file.h"
 #include "dex/art_dex_file_loader.h"
-#include "dex/compact_dex_level.h"
 // TODO: Add inl file and avoid including inl.
 #include "obj_ptr-inl.h"
 #include "runtime_globals.h"
@@ -191,6 +190,10 @@ class CommonRuntimeTestImpl : public CommonArtTestImpl {
         dexes, out_file, method_frequency, type_frequency, /*for_boot_image=*/ true);
   }
 
+  ObjPtr<mirror::Class> FindClass(const char* descriptor,
+                                  Handle<mirror::ClassLoader> class_loader) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   std::unique_ptr<Runtime> runtime_;
 
   // The class_linker_, java_lang_dex_file_, and boot_class_path_ are all
@@ -203,7 +206,7 @@ class CommonRuntimeTestImpl : public CommonArtTestImpl {
   // This only looks into the current class loader and does not recurse into the parents.
   std::vector<const DexFile*> GetDexFiles(jobject jclass_loader);
   std::vector<const DexFile*> GetDexFiles(Thread* self, Handle<mirror::ClassLoader> class_loader)
-    REQUIRES_SHARED(Locks::mutator_lock_);
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Get the first dex file from a PathClassLoader. Will abort if it is null.
   const DexFile* GetFirstDexFile(jobject jclass_loader);
@@ -309,6 +312,11 @@ class CheckJniAbortCatcher {
     GTEST_SKIP() << "WARNING: TEST DISABLED ON KERNEL THAT SEGFAULT ON CACHE OPERATIONS"; \
   }
 
+#define TEST_DISABLED_ON_VM() \
+  if (RunningOnVM()) {        \
+    GTEST_SKIP();             \
+  }
+
 }  // namespace art
 
 #endif  // ART_RUNTIME_COMMON_RUNTIME_TEST_H_
diff --git a/runtime/common_throws.cc b/runtime/common_throws.cc
index ec43f69b19..c1d9a00d5d 100644
--- a/runtime/common_throws.cc
+++ b/runtime/common_throws.cc
@@ -418,6 +418,16 @@ void ThrowNoSuchMethodError(InvokeType type,
   ThrowException("Ljava/lang/NoSuchMethodError;", c, msg.str().c_str());
 }
 
+void ThrowNoSuchMethodError(ObjPtr<mirror::Class> c,
+                            std::string_view name,
+                            const Signature& signature) {
+  std::ostringstream msg;
+  std::string temp;
+  msg << "No method " << name << signature
+      << " in class " << c->GetDescriptor(&temp) << " or its super classes";
+  ThrowException("Ljava/lang/NoSuchMethodError;", c, msg.str().c_str());
+}
+
 // NullPointerException
 
 void ThrowNullPointerExceptionForFieldAccess(ArtField* field, ArtMethod* method, bool is_read) {
@@ -696,13 +706,23 @@ void ThrowSecurityException(const char* fmt, ...) {
 
 // Stack overflow.
 
+template <StackType stack_type>
 void ThrowStackOverflowError(Thread* self) {
-  if (self->IsHandlingStackOverflow()) {
+  if (self->IsHandlingStackOverflow<stack_type>()) {
     LOG(ERROR) << "Recursive stack overflow.";
     // We don't fail here because SetStackEndForStackOverflow will print better diagnostics.
   }
 
-  self->SetStackEndForStackOverflow();  // Allow space on the stack for constructor to execute.
+  // Allow space on the stack for constructor to execute.
+  self->SetStackEndForStackOverflow<stack_type>();
+
+  // Remove the stack overflow protection if it is set up.
+  bool implicit_stack_check = Runtime::Current()->GetImplicitStackOverflowChecks();
+  if (implicit_stack_check) {
+    if (!self->UnprotectStack<stack_type>()) {
+      LOG(ERROR) << "Unable to remove stack protection for stack overflow";
+    }
+  }
 
   // Avoid running Java code for exception initialization.
   // TODO: Checks to make this a bit less brittle.
@@ -713,7 +733,7 @@ void ThrowStackOverflowError(Thread* self) {
   //       with larger stack sizes (e.g., ASAN).
   auto create_and_throw = [self]() REQUIRES_SHARED(Locks::mutator_lock_) NO_INLINE {
     std::string msg("stack size ");
-    msg += PrettySize(self->GetStackSize());
+    msg += PrettySize(self->GetUsableStackSize<stack_type>());
 
     ScopedObjectAccessUnchecked soa(self);
     StackHandleScope<1u> hs(self);
@@ -791,14 +811,17 @@ void ThrowStackOverflowError(Thread* self) {
   create_and_throw();
   CHECK(self->IsExceptionPending());
 
-  self->ResetDefaultStackEnd();  // Return to default stack size.
+  self->ResetDefaultStackEnd<stack_type>();  // Return to default stack size.
 
   // And restore protection if implicit checks are on.
-  if (Runtime::Current()->GetImplicitStackOverflowChecks()) {
-    self->ProtectStack();
+  if (implicit_stack_check) {
+    self->ProtectStack<stack_type>();
   }
 }
 
+// Explicit instantiations to keep this definition separate to the declaration.
+template void ThrowStackOverflowError<StackType::kHardware>(Thread* self);
+
 // StringIndexOutOfBoundsException
 
 void ThrowStringIndexOutOfBoundsException(int index, int length) {
diff --git a/runtime/common_throws.h b/runtime/common_throws.h
index 9b5da327f2..ccf31a3b8b 100644
--- a/runtime/common_throws.h
+++ b/runtime/common_throws.h
@@ -34,6 +34,7 @@ class ArtMethod;
 class DexFile;
 enum InvokeType : uint32_t;
 class Signature;
+enum class StackType;
 
 // The descriptor of the transaction abort exception.
 constexpr const char kTransactionAbortErrorDescriptor[] = "Ldalvik/system/TransactionAbortError;";
@@ -215,6 +216,11 @@ void ThrowNoSuchMethodError(InvokeType type,
                             const Signature& signature)
     REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
+void ThrowNoSuchMethodError(ObjPtr<mirror::Class> c,
+                            std::string_view name,
+                            const Signature& signature)
+    REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
+
 // NullPointerException
 EXPORT
 void ThrowNullPointerExceptionForFieldAccess(ArtField* field, ArtMethod* method, bool is_read)
@@ -253,6 +259,7 @@ void ThrowSecurityException(const char* fmt, ...)
 
 // Stack overflow.
 
+template <StackType stack_type>
 void ThrowStackOverflowError(Thread* self) REQUIRES_SHARED(Locks::mutator_lock_) COLD_ATTR;
 
 // StringIndexOutOfBoundsException
diff --git a/runtime/dex/dex_file_annotations.cc b/runtime/dex/dex_file_annotations.cc
index f44077655b..efcc4a0a38 100644
--- a/runtime/dex/dex_file_annotations.cc
+++ b/runtime/dex/dex_file_annotations.cc
@@ -521,7 +521,7 @@ bool ProcessAnnotationValue(const ClassData& klass,
       } else {
         ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
         StackHandleScope<2> hs(self);
-        ArtMethod* method = class_linker->ResolveMethodWithoutInvokeType(
+        ArtMethod* method = class_linker->ResolveMethodId(
             index,
             hs.NewHandle(klass.GetDexCache()),
             hs.NewHandle(klass.GetClassLoader()));
@@ -1616,7 +1616,7 @@ ObjPtr<mirror::Class> GetEnclosingClass(Handle<mirror::Class> klass) {
     return nullptr;
   }
   StackHandleScope<2> hs(Thread::Current());
-  ArtMethod* method = Runtime::Current()->GetClassLinker()->ResolveMethodWithoutInvokeType(
+  ArtMethod* method = Runtime::Current()->GetClassLinker()->ResolveMethodId(
       annotation_value.value_.GetI(),
       hs.NewHandle(data.GetDexCache()),
       hs.NewHandle(data.GetClassLoader()));
diff --git a/runtime/entrypoints/entrypoint_utils-inl.h b/runtime/entrypoints/entrypoint_utils-inl.h
index fde8043032..7ddf06f5ab 100644
--- a/runtime/entrypoints/entrypoint_utils-inl.h
+++ b/runtime/entrypoints/entrypoint_utils-inl.h
@@ -387,16 +387,15 @@ inline ArtField* ResolveFieldWithAccessChecks(Thread* self,
   }
 
   caller = caller->GetInterfaceMethodIfProxy(class_linker->GetImagePointerSize());
-
-  StackHandleScope<2> hs(self);
-  Handle<mirror::DexCache> h_dex_cache(hs.NewHandle(caller->GetDexCache()));
-  Handle<mirror::ClassLoader> h_class_loader(hs.NewHandle(caller->GetClassLoader()));
-
-  ArtField* resolved_field = class_linker->ResolveFieldJLS(field_index,
-                                                           h_dex_cache,
-                                                           h_class_loader);
+  ArtField* resolved_field = caller->GetDexCache()->GetResolvedField(field_index);
   if (resolved_field == nullptr) {
-    return nullptr;
+    StackHandleScope<2> hs(self);
+    Handle<mirror::DexCache> h_dex_cache(hs.NewHandle(caller->GetDexCache()));
+    Handle<mirror::ClassLoader> h_class_loader(hs.NewHandle(caller->GetClassLoader()));
+    resolved_field = class_linker->ResolveFieldJLS(field_index, h_dex_cache, h_class_loader);
+    if (resolved_field == nullptr) {
+      return nullptr;
+    }
   }
 
   ObjPtr<mirror::Class> fields_class = resolved_field->GetDeclaringClass();
diff --git a/runtime/entrypoints/jni/jni_entrypoints.cc b/runtime/entrypoints/jni/jni_entrypoints.cc
index fc18269e7b..1167710215 100644
--- a/runtime/entrypoints/jni/jni_entrypoints.cc
+++ b/runtime/entrypoints/jni/jni_entrypoints.cc
@@ -60,8 +60,7 @@ extern "C" const void* artFindNativeMethodRunnable(Thread* self)
     // We're coming from compiled managed code and the `method` we see here is the caller.
     // Resolve target @CriticalNative method for a direct call from compiled managed code.
     uint32_t method_idx = GetInvokeStaticMethodIndex(method, dex_pc);
-    ArtMethod* target_method = class_linker->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(
-        self, method_idx, method, kStatic);
+    ArtMethod* target_method = class_linker->ResolveMethodId(method_idx, method);
     if (target_method == nullptr) {
       self->AssertPendingException();
       return nullptr;
diff --git a/runtime/entrypoints/math_entrypoints.cc b/runtime/entrypoints/math_entrypoints.cc
index 5db8dbfe9d..6d94ba5ef8 100644
--- a/runtime/entrypoints/math_entrypoints.cc
+++ b/runtime/entrypoints/math_entrypoints.cc
@@ -14,8 +14,6 @@
  * limitations under the License.
  */
 
-#include "math_entrypoints.h"
-
 #include "entrypoint_utils-inl.h"
 
 namespace art HIDDEN {
diff --git a/runtime/entrypoints/math_entrypoints_test.cc b/runtime/entrypoints/math_entrypoints_test.cc
index 337f9f0925..82b4a52835 100644
--- a/runtime/entrypoints/math_entrypoints_test.cc
+++ b/runtime/entrypoints/math_entrypoints_test.cc
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "math_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 
 #include <limits>
 
diff --git a/runtime/entrypoints/quick/callee_save_frame.h b/runtime/entrypoints/quick/callee_save_frame.h
index 1049e235ec..43602f0431 100644
--- a/runtime/entrypoints/quick/callee_save_frame.h
+++ b/runtime/entrypoints/quick/callee_save_frame.h
@@ -96,7 +96,7 @@ struct CSFSelector<InstructionSet::kX86_64> {
 
 }  // namespace detail
 
-using RuntimeCalleeSaveFrame = detail::CSFSelector<kRuntimeISA>::type;
+using RuntimeCalleeSaveFrame = detail::CSFSelector<kRuntimeQuickCodeISA>::type;
 
 }  // namespace art
 
diff --git a/runtime/entrypoints/quick/quick_entrypoints.h b/runtime/entrypoints/quick/quick_entrypoints.h
index fe01424c7c..cd6debea95 100644
--- a/runtime/entrypoints/quick/quick_entrypoints.h
+++ b/runtime/entrypoints/quick/quick_entrypoints.h
@@ -53,51 +53,9 @@ struct QuickEntryPoints {
 #undef ENTRYPOINT_ENUM
 };
 
-
 // JNI entrypoints.
-extern "C" void artJniMethodStart(Thread* self) UNLOCK_FUNCTION(Locks::mutator_lock_) HOT_ATTR;
-extern "C" void artJniMethodEnd(Thread* self) SHARED_LOCK_FUNCTION(Locks::mutator_lock_) HOT_ATTR;
 extern mirror::Object* JniDecodeReferenceResult(jobject result, Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-extern "C" void artJniReadBarrier(ArtMethod* method)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-extern "C" void artJniUnlockObject(mirror::Object* locked, Thread* self)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-
-// JNI entrypoints when monitoring entry/exit.
-extern "C" void artJniMonitoredMethodStart(Thread* self) UNLOCK_FUNCTION(Locks::mutator_lock_);
-extern "C" void artJniMonitoredMethodEnd(Thread* self) SHARED_LOCK_FUNCTION(Locks::mutator_lock_);
-extern "C" void artJniMethodEntryHook(Thread* self);
-
-// StringAppend pattern entrypoint.
-extern "C" mirror::String* artStringBuilderAppend(uint32_t format,
-                                                  const uint32_t* args,
-                                                  Thread* self)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-
-// Read barrier entrypoints.
-//
-// Compilers for ARM, ARM64 can insert a call to these
-// functions directly.  For x86 and x86-64, compilers need a wrapper
-// assembly function, to handle mismatch in ABI.
-
-// Mark the heap reference `obj`. This entry point is used by read
-// barrier fast path implementations generated by the compiler to mark
-// an object that is referenced by a field of a gray object.
-extern "C" mirror::Object* artReadBarrierMark(mirror::Object* obj)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-
-// Read barrier entrypoint for heap references.
-// This is the read barrier slow path for instance and static fields
-// and reference type arrays.
-extern "C" mirror::Object* artReadBarrierSlow(mirror::Object* ref,
-                                              mirror::Object* obj,
-                                              uint32_t offset)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
-
-// Read barrier entrypoint for GC roots.
-extern "C" mirror::Object* artReadBarrierForRootSlow(GcRoot<mirror::Object>* root)
-    REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR;
 
 }  // namespace art
 
diff --git a/runtime/entrypoints/quick/quick_field_entrypoints.cc b/runtime/entrypoints/quick/quick_field_entrypoints.cc
index 39b21ead02..1666e7d06b 100644
--- a/runtime/entrypoints/quick/quick_field_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_field_entrypoints.cc
@@ -425,14 +425,28 @@ extern "C" int artSet16InstanceFromCode(uint32_t field_idx,
   return artSetCharInstanceFromCode(field_idx, obj, new_value, referrer, self);
 }
 
-extern "C" mirror::Object* artReadBarrierMark(mirror::Object* obj) {
+// Read barrier entrypoints.
+//
+// Compilers for ARM, ARM64 can insert a call to these
+// functions directly.  For x86 and x86-64, compilers need a wrapper
+// assembly function, to handle mismatch in ABI.
+
+// Mark the heap reference `obj`. This entry point is used by read
+// barrier fast path implementations generated by the compiler to mark
+// an object that is referenced by a field of a gray object.
+extern "C" mirror::Object* artReadBarrierMark(mirror::Object* obj)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(gUseReadBarrier);
   return ReadBarrier::Mark(obj);
 }
 
+// Read barrier entrypoint for heap references.
+// This is the read barrier slow path for instance and static fields
+// and reference type arrays.
 extern "C" mirror::Object* artReadBarrierSlow([[maybe_unused]] mirror::Object* ref,
                                               mirror::Object* obj,
-                                              uint32_t offset) {
+                                              uint32_t offset)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
   // Used only in connection with non-volatile loads.
   DCHECK(gUseReadBarrier);
   uint8_t* raw_addr = reinterpret_cast<uint8_t*>(obj) + offset;
@@ -446,7 +460,9 @@ extern "C" mirror::Object* artReadBarrierSlow([[maybe_unused]] mirror::Object* r
   return result;
 }
 
-extern "C" mirror::Object* artReadBarrierForRootSlow(GcRoot<mirror::Object>* root) {
+// Read barrier entrypoint for GC roots.
+extern "C" mirror::Object* artReadBarrierForRootSlow(GcRoot<mirror::Object>* root)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(gUseReadBarrier);
   return root->Read();
 }
diff --git a/runtime/entrypoints/quick/quick_jni_entrypoints.cc b/runtime/entrypoints/quick/quick_jni_entrypoints.cc
index 3c1dbffd7c..1359fef086 100644
--- a/runtime/entrypoints/quick/quick_jni_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_jni_entrypoints.cc
@@ -24,6 +24,7 @@
 #include "palette/palette.h"
 #include "thread-inl.h"
 #include "verify_object.h"
+#include "runtime_entrypoints_list.h"
 
 // For methods that monitor JNI invocations and report their begin/end to
 // palette hooks.
@@ -38,15 +39,11 @@
 
 namespace art HIDDEN {
 
-extern "C" int artMethodExitHook(Thread* self,
-                                 ArtMethod* method,
-                                 uint64_t* gpr_result,
-                                 uint64_t* fpr_result);
-
 static_assert(sizeof(jni::LRTSegmentState) == sizeof(uint32_t), "LRTSegmentState size unexpected");
 static_assert(std::is_trivial<jni::LRTSegmentState>::value, "LRTSegmentState not trivial");
 
-extern "C" void artJniReadBarrier(ArtMethod* method) {
+extern "C" void artJniReadBarrier(ArtMethod* method)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
   DCHECK(gUseReadBarrier);
   mirror::CompressedReference<mirror::Object>* declaring_class =
       method->GetDeclaringClassAddressWithoutBarrier();
@@ -64,7 +61,8 @@ extern "C" void artJniReadBarrier(ArtMethod* method) {
 }
 
 // Called on entry to JNI, transition out of Runnable and release share of mutator_lock_.
-extern "C" void artJniMethodStart(Thread* self) {
+extern "C" void artJniMethodStart(Thread* self)
+    UNLOCK_FUNCTION(Locks::mutator_lock_) {
   if (kIsDebugBuild) {
     ArtMethod* native_method = *self->GetManagedStack()->GetTopQuickFrame();
     CHECK(!native_method->IsFastNative()) << native_method->PrettyMethod();
@@ -88,7 +86,7 @@ static void PopLocalReferences(uint32_t saved_local_ref_cookie, Thread* self)
 __attribute__((no_sanitize("memtag")))  // TODO(b/305919664)
 extern "C" void
 artJniUnlockObject(mirror::Object* locked, Thread* self) NO_THREAD_SAFETY_ANALYSIS
-    REQUIRES(!Roles::uninterruptible_) {
+    REQUIRES(!Roles::uninterruptible_) REQUIRES_SHARED(Locks::mutator_lock_) {
   // Note: No thread suspension is allowed for successful unlocking, otherwise plain
   // `mirror::Object*` return value saved by the assembly stub would need to be updated.
   uintptr_t old_poison_object_cookie = kIsDebugBuild ? self->GetPoisonObjectCookie() : 0u;
@@ -120,7 +118,7 @@ artJniUnlockObject(mirror::Object* locked, Thread* self) NO_THREAD_SAFETY_ANALYS
 // TODO: These should probably be templatized or macro-ized.
 // Otherwise there's just too much repetitive boilerplate.
 
-extern "C" void artJniMethodEnd(Thread* self) {
+extern "C" void artJniMethodEnd(Thread* self) SHARED_LOCK_FUNCTION(Locks::mutator_lock_) {
   self->TransitionFromSuspendedToRunnable();
 
   if (kIsDebugBuild) {
@@ -233,12 +231,12 @@ extern uint64_t GenericJniMethodEnd(Thread* self,
   return ret;
 }
 
-extern "C" void artJniMonitoredMethodStart(Thread* self) {
+extern "C" void artJniMonitoredMethodStart(Thread* self) UNLOCK_FUNCTION(Locks::mutator_lock_) {
   artJniMethodStart(self);
   MONITOR_JNI(PaletteNotifyBeginJniInvocation);
 }
 
-extern "C" void artJniMonitoredMethodEnd(Thread* self) {
+extern "C" void artJniMonitoredMethodEnd(Thread* self) SHARED_LOCK_FUNCTION(Locks::mutator_lock_) {
   MONITOR_JNI(PaletteNotifyEndJniInvocation);
   artJniMethodEnd(self);
 }
diff --git a/runtime/entrypoints/quick/quick_string_builder_append_entrypoints.cc b/runtime/entrypoints/quick/quick_string_builder_append_entrypoints.cc
index 9e5fe1c826..4db8094ff3 100644
--- a/runtime/entrypoints/quick/quick_string_builder_append_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_string_builder_append_entrypoints.cc
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#include "quick_entrypoints.h"
+#include "runtime_entrypoints_list.h"
 
 #include "string_builder_append.h"
 #include "obj_ptr-inl.h"
@@ -23,7 +23,8 @@ namespace art HIDDEN {
 
 extern "C" mirror::String* artStringBuilderAppend(uint32_t format,
                                                   const uint32_t* args,
-                                                  Thread* self) {
+                                                  Thread* self)
+    REQUIRES_SHARED(Locks::mutator_lock_) {
   return StringBuilderAppend::AppendF(format, args, self).Ptr();
 }
 
diff --git a/runtime/entrypoints/quick/quick_throw_entrypoints.cc b/runtime/entrypoints/quick/quick_throw_entrypoints.cc
index 3ca95eabe4..a3ac287236 100644
--- a/runtime/entrypoints/quick/quick_throw_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_throw_entrypoints.cc
@@ -123,7 +123,10 @@ extern "C" Context* artThrowStringBoundsFromCode(int index, int length, Thread*
 extern "C" Context* artThrowStackOverflowFromCode(Thread* self)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   ScopedQuickEntrypointChecks sqec(self);
-  ThrowStackOverflowError(self);
+  // Throw a stack overflow error for the quick stack. This is needed to throw stack overflow
+  // errors on the simulated stack, which is used for quick code when building for the simulator.
+  // See kQuickStackType for more details.
+  ThrowStackOverflowError<kQuickStackType>(self);
   std::unique_ptr<Context> context = self->QuickDeliverException();
   DCHECK(context != nullptr);
   return context.release();
diff --git a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
index 99390f1b3e..6c817d5e16 100644
--- a/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
+++ b/runtime/entrypoints/quick/quick_trampoline_entrypoints.cc
@@ -16,6 +16,7 @@
 
 #include "android-base/logging.h"
 #include "arch/context.h"
+#include "arch/instruction_set.h"
 #include "art_method-inl.h"
 #include "art_method.h"
 #include "base/callee_save_type.h"
@@ -61,14 +62,13 @@
 #include "thread-inl.h"
 #include "var_handles.h"
 #include "well_known_classes.h"
+#include "runtime_entrypoints_list.h"
 
 namespace art HIDDEN {
 
-extern "C" Context* artDeoptimizeFromCompiledCode(DeoptimizationKind kind, Thread* self);
-extern "C" Context* artDeoptimize(Thread* self, bool skip_method_exit_callbacks);
-
 // Visits the arguments as saved to the stack by a CalleeSaveType::kRefAndArgs callee save frame.
-class QuickArgumentVisitor {
+template <typename FrameInfo>
+class QuickArgumentVisitorImpl {
   // Number of bytes for each out register in the caller method's frame.
   static constexpr size_t kBytesStackArgLocation = 4;
   // Frame size in bytes of a callee-save frame for RefsAndArgs.
@@ -83,206 +83,25 @@ class QuickArgumentVisitor {
   // Offset of return address.
   static constexpr size_t kQuickCalleeSaveFrame_RefAndArgs_ReturnPcOffset =
       RuntimeCalleeSaveFrame::GetReturnPcOffset(CalleeSaveType::kSaveRefsAndArgs);
-#if defined(__arm__)
-  // The callee save frame is pointed to by SP.
-  // | argN       |  |
-  // | ...        |  |
-  // | arg4       |  |
-  // | arg3 spill |  |  Caller's frame
-  // | arg2 spill |  |
-  // | arg1 spill |  |
-  // | Method*    | ---
-  // | LR         |
-  // | ...        |    4x6 bytes callee saves
-  // | R3         |
-  // | R2         |
-  // | R1         |
-  // | S15        |
-  // | :          |
-  // | S0         |
-  // |            |    4x2 bytes padding
-  // | Method*    |  <- sp
-  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
-  static constexpr bool kAlignPairRegister = true;
-  static constexpr bool kQuickSoftFloatAbi = false;
-  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = true;
-  static constexpr bool kQuickSkipOddFpRegisters = false;
-  static constexpr size_t kNumQuickGprArgs = 3;
-  static constexpr size_t kNumQuickFprArgs = 16;
-  static constexpr bool kGprFprLockstep = false;
-  static constexpr bool kNaNBoxing = false;
-  static size_t GprIndexToGprOffset(uint32_t gpr_index) {
-    return gpr_index * GetBytesPerGprSpillLocation(kRuntimeISA);
-  }
-#elif defined(__aarch64__)
-  // The callee save frame is pointed to by SP.
-  // | argN       |  |
-  // | ...        |  |
-  // | arg4       |  |
-  // | arg3 spill |  |  Caller's frame
-  // | arg2 spill |  |
-  // | arg1 spill |  |
-  // | Method*    | ---
-  // | LR         |
-  // | X29        |
-  // |  :         |
-  // | X20        |
-  // | X7         |
-  // | :          |
-  // | X1         |
-  // | D7         |
-  // |  :         |
-  // | D0         |
-  // |            |    padding
-  // | Method*    |  <- sp
-  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
-  static constexpr bool kAlignPairRegister = false;
-  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
-  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
-  static constexpr bool kQuickSkipOddFpRegisters = false;
-  static constexpr size_t kNumQuickGprArgs = 7;  // 7 arguments passed in GPRs.
-  static constexpr size_t kNumQuickFprArgs = 8;  // 8 arguments passed in FPRs.
-  static constexpr bool kGprFprLockstep = false;
-  static constexpr bool kNaNBoxing = false;
-  static size_t GprIndexToGprOffset(uint32_t gpr_index) {
-    return gpr_index * GetBytesPerGprSpillLocation(kRuntimeISA);
-  }
-#elif defined(__riscv)
-  // The callee save frame is pointed to by SP.
-  // | argN            |  |
-  // | ...             |  |
-  // | reg. arg spills |  |  Caller's frame
-  // | Method*         | ---
-  // | RA              |
-  // | S11/X27         |  callee-saved 11
-  // | S10/X26         |  callee-saved 10
-  // | S9/X25          |  callee-saved 9
-  // | S9/X24          |  callee-saved 8
-  // | S7/X23          |  callee-saved 7
-  // | S6/X22          |  callee-saved 6
-  // | S5/X21          |  callee-saved 5
-  // | S4/X20          |  callee-saved 4
-  // | S3/X19          |  callee-saved 3
-  // | S2/X18          |  callee-saved 2
-  // | A7/X17          |  arg 7
-  // | A6/X16          |  arg 6
-  // | A5/X15          |  arg 5
-  // | A4/X14          |  arg 4
-  // | A3/X13          |  arg 3
-  // | A2/X12          |  arg 2
-  // | A1/X11          |  arg 1 (A0 is the method => skipped)
-  // | S0/X8/FP        |  callee-saved 0 (S1 is TR => skipped)
-  // | FA7             |  float arg 8
-  // | FA6             |  float arg 7
-  // | FA5             |  float arg 6
-  // | FA4             |  float arg 5
-  // | FA3             |  float arg 4
-  // | FA2             |  float arg 3
-  // | FA1             |  float arg 2
-  // | FA0             |  float arg 1
-  // | A0/Method*      | <- sp
-  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
-  static constexpr bool kAlignPairRegister = false;
-  static constexpr bool kQuickSoftFloatAbi = false;
-  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
-  static constexpr bool kQuickSkipOddFpRegisters = false;
-  static constexpr size_t kNumQuickGprArgs = 7;
-  static constexpr size_t kNumQuickFprArgs = 8;
-  static constexpr bool kGprFprLockstep = false;
-  static constexpr bool kNaNBoxing = true;
-  static size_t GprIndexToGprOffset(uint32_t gpr_index) {
-    return (gpr_index + 1) * GetBytesPerGprSpillLocation(kRuntimeISA);  // skip S0/X8/FP
-  }
-#elif defined(__i386__)
-  // The callee save frame is pointed to by SP.
-  // | argN        |  |
-  // | ...         |  |
-  // | arg4        |  |
-  // | arg3 spill  |  |  Caller's frame
-  // | arg2 spill  |  |
-  // | arg1 spill  |  |
-  // | Method*     | ---
-  // | Return      |
-  // | EBP,ESI,EDI |    callee saves
-  // | EBX         |    arg3
-  // | EDX         |    arg2
-  // | ECX         |    arg1
-  // | XMM3        |    float arg 4
-  // | XMM2        |    float arg 3
-  // | XMM1        |    float arg 2
-  // | XMM0        |    float arg 1
-  // | EAX/Method* |  <- sp
-  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
-  static constexpr bool kAlignPairRegister = false;
-  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
-  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
-  static constexpr bool kQuickSkipOddFpRegisters = false;
-  static constexpr size_t kNumQuickGprArgs = 3;  // 3 arguments passed in GPRs.
-  static constexpr size_t kNumQuickFprArgs = 4;  // 4 arguments passed in FPRs.
-  static constexpr bool kGprFprLockstep = false;
-  static constexpr bool kNaNBoxing = false;
-  static size_t GprIndexToGprOffset(uint32_t gpr_index) {
-    return gpr_index * GetBytesPerGprSpillLocation(kRuntimeISA);
-  }
-#elif defined(__x86_64__)
-  // The callee save frame is pointed to by SP.
-  // | argN            |  |
-  // | ...             |  |
-  // | reg. arg spills |  |  Caller's frame
-  // | Method*         | ---
-  // | Return          |
-  // | R15             |    callee save
-  // | R14             |    callee save
-  // | R13             |    callee save
-  // | R12             |    callee save
-  // | R9              |    arg5
-  // | R8              |    arg4
-  // | RSI/R6          |    arg1
-  // | RBP/R5          |    callee save
-  // | RBX/R3          |    callee save
-  // | RDX/R2          |    arg2
-  // | RCX/R1          |    arg3
-  // | XMM15           |    callee save
-  // | XMM14           |    callee save
-  // | XMM13           |    callee save
-  // | XMM12           |    callee save
-  // | XMM7            |    float arg 8
-  // | XMM6            |    float arg 7
-  // | XMM5            |    float arg 6
-  // | XMM4            |    float arg 5
-  // | XMM3            |    float arg 4
-  // | XMM2            |    float arg 3
-  // | XMM1            |    float arg 2
-  // | XMM0            |    float arg 1
-  // | Padding         |
-  // | RDI/Method*     |  <- sp
-  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
-  static constexpr bool kAlignPairRegister = false;
-  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
-  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
-  static constexpr bool kQuickSkipOddFpRegisters = false;
-  static constexpr size_t kNumQuickGprArgs = 5;  // 5 arguments passed in GPRs.
-  static constexpr size_t kNumQuickFprArgs = 8;  // 8 arguments passed in FPRs.
-  static constexpr bool kGprFprLockstep = false;
-  static constexpr bool kNaNBoxing = false;
+
   static size_t GprIndexToGprOffset(uint32_t gpr_index) {
-    switch (gpr_index) {
-      case 0: return (4 * GetBytesPerGprSpillLocation(kRuntimeISA));
-      case 1: return (1 * GetBytesPerGprSpillLocation(kRuntimeISA));
-      case 2: return (0 * GetBytesPerGprSpillLocation(kRuntimeISA));
-      case 3: return (5 * GetBytesPerGprSpillLocation(kRuntimeISA));
-      case 4: return (6 * GetBytesPerGprSpillLocation(kRuntimeISA));
-      default:
-      LOG(FATAL) << "Unexpected GPR index: " << gpr_index;
-      UNREACHABLE();
-    }
+    return FrameInfo::GprIndexToGprOffsetImpl(gpr_index);
   }
-#else
-#error "Unsupported architecture"
-#endif
+
+  static constexpr bool kSplitPairAcrossRegisterAndStack =
+      FrameInfo::kSplitPairAcrossRegisterAndStack;
+  static constexpr bool kAlignPairRegister = FrameInfo::kAlignPairRegister;
+  static constexpr bool kQuickSoftFloatAbi = FrameInfo::kQuickSoftFloatAbi;
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled =
+      FrameInfo::kQuickDoubleRegAlignedFloatBackFilled;
+  static constexpr bool kQuickSkipOddFpRegisters = FrameInfo::kQuickSkipOddFpRegisters;
+  static constexpr size_t kNumQuickGprArgs = FrameInfo::kNumQuickGprArgs;
+  static constexpr size_t kNumQuickFprArgs = FrameInfo::kNumQuickFprArgs;
+  static constexpr bool kGprFprLockstep = FrameInfo::kGprFprLockstep;
+  static constexpr bool kNaNBoxing = FrameInfo::kNanBoxing;
 
  public:
-  static constexpr bool NaNBoxing() { return kNaNBoxing; }
+  static constexpr bool NaNBoxing() { return FrameInfo::kNaNBoxing; }
 
   static StackReference<mirror::Object>* GetThisObjectReference(ArtMethod** sp)
       REQUIRES_SHARED(Locks::mutator_lock_) {
@@ -324,7 +143,7 @@ class QuickArgumentVisitor {
     return *reinterpret_cast<uintptr_t*>(GetCallingPcAddr(sp));
   }
 
-  QuickArgumentVisitor(ArtMethod** sp, bool is_static, std::string_view shorty)
+  QuickArgumentVisitorImpl(ArtMethod** sp, bool is_static, std::string_view shorty)
       REQUIRES_SHARED(Locks::mutator_lock_)
       : is_static_(is_static),
         shorty_(shorty),
@@ -349,7 +168,7 @@ class QuickArgumentVisitor {
     DCHECK_EQ(Runtime::Current()->GetClassLinker()->GetImagePointerSize(), kRuntimePointerSize);
   }
 
-  virtual ~QuickArgumentVisitor() {}
+  virtual ~QuickArgumentVisitorImpl() {}
 
   virtual void Visit() = 0;
 
@@ -363,10 +182,11 @@ class QuickArgumentVisitor {
       if (UNLIKELY((type == Primitive::kPrimDouble) || (type == Primitive::kPrimFloat))) {
         if (type == Primitive::kPrimDouble && kQuickDoubleRegAlignedFloatBackFilled) {
           if (fpr_double_index_ + 2 < kNumQuickFprArgs + 1) {
-            return fpr_args_ + (fpr_double_index_ * GetBytesPerFprSpillLocation(kRuntimeISA));
+            return fpr_args_ +
+                   (fpr_double_index_ * GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA));
           }
         } else if (fpr_index_ + 1 < kNumQuickFprArgs + 1) {
-          return fpr_args_ + (fpr_index_ * GetBytesPerFprSpillLocation(kRuntimeISA));
+          return fpr_args_ + (fpr_index_ * GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA));
         }
         return stack_args_ + (stack_index_ * kBytesStackArgLocation);
       }
@@ -378,8 +198,8 @@ class QuickArgumentVisitor {
   }
 
   bool IsSplitLongOrDouble() const {
-    if ((GetBytesPerGprSpillLocation(kRuntimeISA) == 4) ||
-        (GetBytesPerFprSpillLocation(kRuntimeISA) == 4)) {
+    if ((GetBytesPerGprSpillLocation(kRuntimeQuickCodeISA) == 4) ||
+        (GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA) == 4)) {
       return is_split_long_or_double_;
     } else {
       return false;  // An optimization for when GPR and FPRs are 64bit.
@@ -485,7 +305,7 @@ class QuickArgumentVisitor {
               // even-numbered registers by skipping R1 and using R2 instead.
               IncGprIndex();
             }
-            is_split_long_or_double_ = (GetBytesPerGprSpillLocation(kRuntimeISA) == 4) &&
+            is_split_long_or_double_ = (GetBytesPerGprSpillLocation(kRuntimeQuickCodeISA) == 4) &&
                 ((gpr_index_ + 1) == kNumQuickGprArgs);
             if (!kSplitPairAcrossRegisterAndStack && is_split_long_or_double_) {
               // We don't want to split this. Pass over this register.
@@ -501,14 +321,14 @@ class QuickArgumentVisitor {
             }
             if (gpr_index_ < kNumQuickGprArgs) {
               IncGprIndex();
-              if (GetBytesPerGprSpillLocation(kRuntimeISA) == 4) {
+              if (GetBytesPerGprSpillLocation(kRuntimeQuickCodeISA) == 4) {
                 if (gpr_index_ < kNumQuickGprArgs) {
                   IncGprIndex();
                 }
               }
             }
           } else {
-            is_split_long_or_double_ = (GetBytesPerFprSpillLocation(kRuntimeISA) == 4) &&
+            is_split_long_or_double_ = (GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA) == 4) &&
                 ((fpr_index_ + 1) == kNumQuickFprArgs) && !kQuickDoubleRegAlignedFloatBackFilled;
             Visit();
             if (kBytesStackArgLocation == 4) {
@@ -527,7 +347,7 @@ class QuickArgumentVisitor {
               }
             } else if (fpr_index_ + 1 < kNumQuickFprArgs + 1) {
               IncFprIndex();
-              if (GetBytesPerFprSpillLocation(kRuntimeISA) == 4) {
+              if (GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA) == 4) {
                 if (fpr_index_ + 1 < kNumQuickFprArgs + 1) {
                   IncFprIndex();
                 }
@@ -565,6 +385,238 @@ class QuickArgumentVisitor {
   bool is_split_long_or_double_;
 };
 
+class QuickArgumentFrameInfoARM {
+ public:
+  // The callee save frame is pointed to by SP.
+  // | argN       |  |
+  // | ...        |  |
+  // | arg4       |  |
+  // | arg3 spill |  |  Caller's frame
+  // | arg2 spill |  |
+  // | arg1 spill |  |
+  // | Method*    | ---
+  // | LR         |
+  // | ...        |    4x6 bytes callee saves
+  // | R3         |
+  // | R2         |
+  // | R1         |
+  // | S15        |
+  // | :          |
+  // | S0         |
+  // |            |    4x2 bytes padding
+  // | Method*    |  <- sp
+  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
+  static constexpr bool kAlignPairRegister = true;
+  static constexpr bool kQuickSoftFloatAbi = false;
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = true;
+  static constexpr bool kQuickSkipOddFpRegisters = false;
+  static constexpr size_t kNumQuickGprArgs = 3;
+  static constexpr size_t kNumQuickFprArgs = 16;
+  static constexpr bool kGprFprLockstep = false;
+  static constexpr bool kNaNBoxing = false;
+  static size_t GprIndexToGprOffsetImpl(uint32_t gpr_index) {
+    return gpr_index * GetBytesPerGprSpillLocation(InstructionSet::kArm);
+  }
+};
+
+class QuickArgumentFrameInfoARM64 {
+ public:
+  // The callee save frame is pointed to by SP.
+  // | argN       |  |
+  // | ...        |  |
+  // | arg4       |  |
+  // | arg3 spill |  |  Caller's frame
+  // | arg2 spill |  |
+  // | arg1 spill |  |
+  // | Method*    | ---
+  // | LR         |
+  // | X29        |
+  // |  :         |
+  // | X20        |
+  // | X7         |
+  // | :          |
+  // | X1         |
+  // | D7         |
+  // |  :         |
+  // | D0         |
+  // |            |    padding
+  // | Method*    |  <- sp
+  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
+  static constexpr bool kAlignPairRegister = false;
+  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
+  static constexpr bool kQuickSkipOddFpRegisters = false;
+  static constexpr size_t kNumQuickGprArgs = 7;  // 7 arguments passed in GPRs.
+  static constexpr size_t kNumQuickFprArgs = 8;  // 8 arguments passed in FPRs.
+  static constexpr bool kGprFprLockstep = false;
+  static constexpr bool kNaNBoxing = false;
+  static size_t GprIndexToGprOffsetImpl(uint32_t gpr_index) {
+    return gpr_index * GetBytesPerGprSpillLocation(InstructionSet::kArm64);
+  }
+};
+
+class QuickArgumentFrameInfoRISCV64 {
+ public:
+  // The callee save frame is pointed to by SP.
+  // | argN            |  |
+  // | ...             |  |
+  // | reg. arg spills |  |  Caller's frame
+  // | Method*         | ---
+  // | RA              |
+  // | S11/X27         |  callee-saved 11
+  // | S10/X26         |  callee-saved 10
+  // | S9/X25          |  callee-saved 9
+  // | S9/X24          |  callee-saved 8
+  // | S7/X23          |  callee-saved 7
+  // | S6/X22          |  callee-saved 6
+  // | S5/X21          |  callee-saved 5
+  // | S4/X20          |  callee-saved 4
+  // | S3/X19          |  callee-saved 3
+  // | S2/X18          |  callee-saved 2
+  // | A7/X17          |  arg 7
+  // | A6/X16          |  arg 6
+  // | A5/X15          |  arg 5
+  // | A4/X14          |  arg 4
+  // | A3/X13          |  arg 3
+  // | A2/X12          |  arg 2
+  // | A1/X11          |  arg 1 (A0 is the method => skipped)
+  // | S0/X8/FP        |  callee-saved 0 (S1 is TR => skipped)
+  // | FA7             |  float arg 8
+  // | FA6             |  float arg 7
+  // | FA5             |  float arg 6
+  // | FA4             |  float arg 5
+  // | FA3             |  float arg 4
+  // | FA2             |  float arg 3
+  // | FA1             |  float arg 2
+  // | FA0             |  float arg 1
+  // | A0/Method*      | <- sp
+  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
+  static constexpr bool kAlignPairRegister = false;
+  static constexpr bool kQuickSoftFloatAbi = false;
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
+  static constexpr bool kQuickSkipOddFpRegisters = false;
+  static constexpr size_t kNumQuickGprArgs = 7;
+  static constexpr size_t kNumQuickFprArgs = 8;
+  static constexpr bool kGprFprLockstep = false;
+  static constexpr bool kNaNBoxing = true;
+  static size_t GprIndexToGprOffsetImpl(uint32_t gpr_index) {
+    // skip S0/X8/FP
+    return (gpr_index + 1) * GetBytesPerGprSpillLocation(InstructionSet::kRiscv64);
+  }
+};
+
+class QuickArgumentFrameInfoX86 {
+ public:
+  // The callee save frame is pointed to by SP.
+  // | argN        |  |
+  // | ...         |  |
+  // | arg4        |  |
+  // | arg3 spill  |  |  Caller's frame
+  // | arg2 spill  |  |
+  // | arg1 spill  |  |
+  // | Method*     | ---
+  // | Return      |
+  // | EBP,ESI,EDI |    callee saves
+  // | EBX         |    arg3
+  // | EDX         |    arg2
+  // | ECX         |    arg1
+  // | XMM3        |    float arg 4
+  // | XMM2        |    float arg 3
+  // | XMM1        |    float arg 2
+  // | XMM0        |    float arg 1
+  // | EAX/Method* |  <- sp
+  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
+  static constexpr bool kAlignPairRegister = false;
+  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
+  static constexpr bool kQuickSkipOddFpRegisters = false;
+  static constexpr size_t kNumQuickGprArgs = 3;  // 3 arguments passed in GPRs.
+  static constexpr size_t kNumQuickFprArgs = 4;  // 4 arguments passed in FPRs.
+  static constexpr bool kGprFprLockstep = false;
+  static constexpr bool kNaNBoxing = false;
+  static size_t GprIndexToGprOffsetImpl(uint32_t gpr_index) {
+    return gpr_index * GetBytesPerGprSpillLocation(InstructionSet::kX86);
+  }
+};
+
+class QuickArgumentFrameInfoX86_64 {
+ public:
+  // The callee save frame is pointed to by SP.
+  // | argN            |  |
+  // | ...             |  |
+  // | reg. arg spills |  |  Caller's frame
+  // | Method*         | ---
+  // | Return          |
+  // | R15             |    callee save
+  // | R14             |    callee save
+  // | R13             |    callee save
+  // | R12             |    callee save
+  // | R9              |    arg5
+  // | R8              |    arg4
+  // | RSI/R6          |    arg1
+  // | RBP/R5          |    callee save
+  // | RBX/R3          |    callee save
+  // | RDX/R2          |    arg2
+  // | RCX/R1          |    arg3
+  // | XMM15           |    callee save
+  // | XMM14           |    callee save
+  // | XMM13           |    callee save
+  // | XMM12           |    callee save
+  // | XMM7            |    float arg 8
+  // | XMM6            |    float arg 7
+  // | XMM5            |    float arg 6
+  // | XMM4            |    float arg 5
+  // | XMM3            |    float arg 4
+  // | XMM2            |    float arg 3
+  // | XMM1            |    float arg 2
+  // | XMM0            |    float arg 1
+  // | Padding         |
+  // | RDI/Method*     |  <- sp
+  static constexpr bool kSplitPairAcrossRegisterAndStack = false;
+  static constexpr bool kAlignPairRegister = false;
+  static constexpr bool kQuickSoftFloatAbi = false;  // This is a hard float ABI.
+  static constexpr bool kQuickDoubleRegAlignedFloatBackFilled = false;
+  static constexpr bool kQuickSkipOddFpRegisters = false;
+  static constexpr size_t kNumQuickGprArgs = 5;  // 5 arguments passed in GPRs.
+  static constexpr size_t kNumQuickFprArgs = 8;  // 8 arguments passed in FPRs.
+  static constexpr bool kGprFprLockstep = false;
+  static constexpr bool kNaNBoxing = false;
+  static size_t GprIndexToGprOffsetImpl(uint32_t gpr_index) {
+    static constexpr size_t kBytesPerSpill = GetBytesPerGprSpillLocation(InstructionSet::kX86_64);
+    switch (gpr_index) {
+      case 0: return (4 * kBytesPerSpill);
+      case 1: return (1 * kBytesPerSpill);
+      case 2: return (0 * kBytesPerSpill);
+      case 3: return (5 * kBytesPerSpill);
+      case 4: return (6 * kBytesPerSpill);
+      default:
+      LOG(FATAL) << "Unexpected GPR index: " << gpr_index;
+      UNREACHABLE();
+    }
+  }
+};
+
+namespace detail {
+
+template <InstructionSet>
+struct QAFISelector;
+
+template <>
+struct QAFISelector<InstructionSet::kArm> { using type = QuickArgumentFrameInfoARM; };
+template <>
+struct QAFISelector<InstructionSet::kArm64> { using type = QuickArgumentFrameInfoARM64; };
+template <>
+struct QAFISelector<InstructionSet::kRiscv64> { using type = QuickArgumentFrameInfoRISCV64; };
+template <>
+struct QAFISelector<InstructionSet::kX86> { using type = QuickArgumentFrameInfoX86; };
+template <>
+struct QAFISelector<InstructionSet::kX86_64> { using type = QuickArgumentFrameInfoX86_64; };
+
+}  // namespace detail
+
+using QuickArgumentVisitor =
+    QuickArgumentVisitorImpl<detail::QAFISelector<kRuntimeQuickCodeISA>::type>;
+
 // Returns the 'this' object of a proxy method. This function is only used by StackVisitor. It
 // allows to use the QuickArgumentVisitor constants without moving all the code in its own module.
 extern "C" mirror::Object* artQuickGetProxyThisObject(ArtMethod** sp)
@@ -1245,8 +1297,7 @@ extern "C" const void* artQuickResolutionTrampoline(
     HandleWrapper<mirror::Object> h_receiver(
         hs.NewHandleWrapper(virtual_or_interface ? &receiver : &fake_receiver));
     DCHECK_EQ(caller->GetDexFile(), called_method.dex_file);
-    called = linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-        self, called_method.index, caller, invoke_type);
+    called = linker->ResolveMethodWithChecks(called_method.index, caller, invoke_type);
   }
   const void* code = nullptr;
   if (LIKELY(!self->IsExceptionPending())) {
@@ -2262,8 +2313,7 @@ extern "C" TwoWordReturn artInvokeInterfaceTrampoline(ArtMethod* interface_metho
       RememberForGcArgumentVisitor visitor(sp, false, shorty, &soa);
       visitor.VisitArguments();
       ClassLinker* class_linker = runtime->GetClassLinker();
-      interface_method = class_linker->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(
-          self, dex_method_idx, caller_method, kInterface);
+      interface_method = class_linker->ResolveMethodId(dex_method_idx, caller_method);
       visitor.FixupReferences();
     }
 
@@ -2377,8 +2427,8 @@ extern "C" uint64_t artInvokePolymorphic(mirror::Object* raw_receiver, Thread* s
 
   // Resolve method.
   ClassLinker* linker = Runtime::Current()->GetClassLinker();
-  ArtMethod* resolved_method = linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-      self, inst.VRegB(), caller_method, kVirtual);
+  ArtMethod* resolved_method = linker->ResolveMethodWithChecks(
+      inst.VRegB(), caller_method, kVirtual);
 
   DCHECK_EQ(ArtMethod::NumArgRegisters(shorty) + 1u, (uint32_t)inst.VRegA());
   DCHECK_EQ(resolved_method->IsStatic(), kMethodIsStatic);
@@ -2507,8 +2557,8 @@ extern "C" uint64_t artInvokePolymorphicWithHiddenReceiver(mirror::Object* raw_r
   ClassLinker* linker = Runtime::Current()->GetClassLinker();
   ArtMethod* invoke_exact = WellKnownClasses::java_lang_invoke_MethodHandle_invokeExact;
   if (kIsDebugBuild) {
-    ArtMethod* resolved_method = linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-        self, inst.VRegB(), caller_method, kVirtual);
+    ArtMethod* resolved_method = linker->ResolveMethodWithChecks(
+        inst.VRegB(), caller_method, kVirtual);
     CHECK_EQ(resolved_method, invoke_exact);
   }
 
diff --git a/runtime/entrypoints/quick/runtime_entrypoints_list.h b/runtime/entrypoints/quick/runtime_entrypoints_list.h
new file mode 100644
index 0000000000..dd13c742c2
--- /dev/null
+++ b/runtime/entrypoints/quick/runtime_entrypoints_list.h
@@ -0,0 +1,450 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_ENTRYPOINTS_QUICK_RUNTIME_ENTRYPOINTS_LIST_H_
+#define ART_RUNTIME_ENTRYPOINTS_QUICK_RUNTIME_ENTRYPOINTS_LIST_H_
+
+
+#include "entrypoints/entrypoint_utils.h"
+#include "arch/instruction_set.h"
+#include <math.h>
+
+namespace art {
+
+namespace mirror {
+class Array;
+class Class;
+template<class MirrorType> class CompressedReference;
+class Object;
+class String;
+class Throwable;
+template<class T> class PrimitiveArray;
+using ByteArray = PrimitiveArray<int8_t>;
+using CharArray = PrimitiveArray<uint16_t>;
+}  // namespace mirror
+
+class ArtMethod;
+template<class MirrorType> class GcRoot;
+template<class MirrorType> class StackReference;
+class Thread;
+class Context;
+enum class DeoptimizationKind;
+
+// All C++ quick entrypoints, i.e.: C++ entrypoint functions called from quick assembly code.
+// Format is name, attribute, return type, argument types.
+#define RUNTIME_ENTRYPOINT_LIST(V) \
+  V(artDeliverPendingExceptionFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,          \
+      Thread* self)                                                                               \
+  V(artInvokeObsoleteMethod, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                     \
+      ArtMethod* method,                                                                          \
+      Thread* self)                                                                               \
+  V(artDeliverExceptionFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                 \
+      mirror::Throwable* exception,                                                               \
+      Thread* self)                                                                               \
+  V(artThrowNullPointerExceptionFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,        \
+      Thread* self)                                                                               \
+  V(artThrowNullPointerExceptionFromSignal, REQUIRES_SHARED(Locks::mutator_lock_), Context*,      \
+      uintptr_t addr,                                                                             \
+      Thread* self)                                                                               \
+  V(artThrowDivZeroFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                     \
+      Thread* self)                                                                               \
+  V(artThrowArrayBoundsFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                 \
+      int index,                                                                                  \
+      int length,                                                                                 \
+      Thread* self)                                                                               \
+  V(artThrowStringBoundsFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                \
+      int index,                                                                                  \
+      int length,                                                                                 \
+      Thread* self)                                                                               \
+  V(artThrowStackOverflowFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,               \
+      Thread* self)                                                                               \
+  V(artThrowClassCastExceptionForObject, REQUIRES_SHARED(Locks::mutator_lock_), Context*,         \
+      mirror::Object* obj,                                                                        \
+      mirror::Class* dest_type,                                                                   \
+      Thread* self)                                                                               \
+  V(artThrowArrayStoreException, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                 \
+      mirror::Object* array,                                                                      \
+      mirror::Object* value,                                                                      \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artDeoptimizeIfNeeded, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                       \
+      Thread* self,                                                                               \
+      uintptr_t result,                                                                           \
+      bool is_ref)                                                                                \
+  V(artTestSuspendFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                      \
+      Thread* self)                                                                               \
+  V(artImplicitSuspendFromCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                  \
+      Thread* self)                                                                               \
+  V(artCompileOptimized, REQUIRES_SHARED(Locks::mutator_lock_), void,                             \
+      ArtMethod* method,                                                                          \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artQuickToInterpreterBridge, REQUIRES_SHARED(Locks::mutator_lock_), uint64_t,                 \
+      ArtMethod* method,                                                                          \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artQuickProxyInvokeHandler, REQUIRES_SHARED(Locks::mutator_lock_), uint64_t,                  \
+      ArtMethod* proxy_method,                                                                    \
+      mirror::Object* receiver,                                                                   \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artQuickResolutionTrampoline, REQUIRES_SHARED(Locks::mutator_lock_), const void*,             \
+      ArtMethod* called,                                                                          \
+      mirror::Object* receiver,                                                                   \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artQuickGenericJniTrampoline, REQUIRES_SHARED(Locks::mutator_lock_)                           \
+      NO_THREAD_SAFETY_ANALYSIS, const void*,                                                     \
+      Thread* self,                                                                               \
+      ArtMethod** managed_sp,                                                                     \
+      uintptr_t* reserved_area)                                                                   \
+  V(artQuickGenericJniEndTrampoline, , uint64_t,                                                  \
+      Thread* self,                                                                               \
+      jvalue result,                                                                              \
+      uint64_t result_fp)                                                                         \
+  V(artInvokeInterfaceTrampolineWithAccessCheck, REQUIRES_SHARED(Locks::mutator_lock_),           \
+      TwoWordReturn,                                                                              \
+      uint32_t method_idx,                                                                        \
+      mirror::Object* this_object,                                                                \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeDirectTrampolineWithAccessCheck, REQUIRES_SHARED(Locks::mutator_lock_),              \
+      TwoWordReturn,                                                                              \
+      uint32_t method_idx,                                                                        \
+      mirror::Object* this_object,                                                                \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeStaticTrampolineWithAccessCheck, REQUIRES_SHARED(Locks::mutator_lock_),              \
+      TwoWordReturn,                                                                              \
+      uint32_t method_idx,                                                                        \
+      [[maybe_unused]] mirror::Object* this_object,                                               \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeSuperTrampolineWithAccessCheck, REQUIRES_SHARED(Locks::mutator_lock_),               \
+      TwoWordReturn,                                                                              \
+      uint32_t method_idx,                                                                        \
+      mirror::Object* this_object,                                                                \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeVirtualTrampolineWithAccessCheck, REQUIRES_SHARED(Locks::mutator_lock_),             \
+      TwoWordReturn,                                                                              \
+      uint32_t method_idx,                                                                        \
+      mirror::Object* this_object,                                                                \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeInterfaceTrampoline, REQUIRES_SHARED(Locks::mutator_lock_), TwoWordReturn,           \
+      ArtMethod* interface_method,                                                                \
+      mirror::Object* raw_this_object,                                                            \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokePolymorphic, REQUIRES_SHARED(Locks::mutator_lock_), uint64_t,                        \
+      mirror::Object* raw_receiver,                                                               \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokePolymorphicWithHiddenReceiver, REQUIRES_SHARED(Locks::mutator_lock_), uint64_t,      \
+      mirror::Object* raw_receiver,                                                               \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artInvokeCustom, REQUIRES_SHARED(Locks::mutator_lock_), uint64_t,                             \
+      uint32_t call_site_idx,                                                                     \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artJniMethodEntryHook, REQUIRES_SHARED(Locks::mutator_lock_), void,                           \
+      Thread* self)                                                                               \
+  V(artMethodEntryHook, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                          \
+      ArtMethod* method,                                                                          \
+      Thread* self,                                                                               \
+      ArtMethod** sp)                                                                             \
+  V(artMethodExitHook, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                           \
+      Thread* self,                                                                               \
+      ArtMethod** sp,                                                                             \
+      uint64_t* gpr_result,                                                                       \
+      uint64_t* fpr_result,                                                                       \
+      uint32_t frame_size)                                                                        \
+                                                                                                  \
+  V(artIsAssignableFromCode, REQUIRES_SHARED(Locks::mutator_lock_), size_t,                       \
+      mirror::Class* klass,                                                                       \
+      mirror::Class* ref_class)                                                                   \
+  V(artInstanceOfFromCode, REQUIRES_SHARED(Locks::mutator_lock_), size_t,                         \
+      mirror::Object* obj,                                                                        \
+      mirror::Class* ref_class)                                                                   \
+                                                                                                  \
+  V(artInitializeStaticStorageFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::Class*,    \
+      mirror::Class* klass,                                                                       \
+      Thread* self)                                                                               \
+  V(artResolveTypeFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::Class*,                \
+      uint32_t type_idx,                                                                          \
+      Thread* self)                                                                               \
+  V(artResolveTypeAndVerifyAccessFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::Class*, \
+      uint32_t type_idx,                                                                          \
+      Thread* self)                                                                               \
+  V(artResolveMethodHandleFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::MethodHandle*, \
+      uint32_t method_handle_idx,                                                                 \
+      Thread* self)                                                                               \
+  V(artResolveMethodTypeFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::MethodType*,     \
+      uint32_t proto_idx,                                                                         \
+      Thread* self)                                                                               \
+  V(artResolveStringFromCode, REQUIRES_SHARED(Locks::mutator_lock_), mirror::String*,             \
+      int32_t string_idx, Thread* self)                                                           \
+                                                                                                  \
+  V(artDeoptimize, REQUIRES_SHARED(Locks::mutator_lock_), Context*,                               \
+      Thread* self,                                                                               \
+      bool skip_method_exit_callbacks)                                                            \
+  V(artDeoptimizeFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), Context*,               \
+      DeoptimizationKind kind,                                                                    \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artHandleFillArrayDataFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                   \
+      const Instruction::ArrayDataPayload* payload,                                               \
+      mirror::Array* array,                                                                       \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artJniReadBarrier, REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, void,                      \
+      ArtMethod* method)                                                                          \
+  V(artJniMethodStart, UNLOCK_FUNCTION(Locks::mutator_lock_) HOT_ATTR, void,                      \
+      Thread* self)                                                                               \
+  V(artJniUnlockObject, NO_THREAD_SAFETY_ANALYSIS REQUIRES(!Roles::uninterruptible_)              \
+      REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, void,                                       \
+      mirror::Object* locked,                                                                     \
+      Thread* self)                                                                               \
+  V(artJniMethodEnd, SHARED_LOCK_FUNCTION(Locks::mutator_lock_) HOT_ATTR, void,                   \
+      Thread* self)                                                                               \
+  V(artJniMonitoredMethodStart, UNLOCK_FUNCTION(Locks::mutator_lock_), void,                      \
+      Thread* self)                                                                               \
+  V(artJniMonitoredMethodEnd, SHARED_LOCK_FUNCTION(Locks::mutator_lock_), void,                   \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artStringBuilderAppend, REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, mirror::String*,      \
+      uint32_t format,                                                                            \
+      const uint32_t* args,                                                                       \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artContextCopyForLongJump, , void,                                                            \
+      Context* context,                                                                           \
+      uintptr_t* gprs,                                                                            \
+      uintptr_t* fprs)                                                                            \
+                                                                                                  \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, DlMalloc)                                            \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, RosAlloc)                                            \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, BumpPointer)                                         \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, TLAB)                                                \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, Region)                                              \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, RegionTLAB)                                          \
+                                                                                                  \
+  ART_GET_FIELD_FROM_CODE_DECL(V, Byte, ssize_t, uint32_t)                                        \
+  ART_GET_FIELD_FROM_CODE_DECL(V, Boolean, size_t, uint32_t)                                      \
+  ART_GET_FIELD_FROM_CODE_DECL(V, Short, ssize_t, uint16_t)                                       \
+  ART_GET_FIELD_FROM_CODE_DECL(V, Char, size_t, uint16_t)                                         \
+  ART_GET_FIELD_FROM_CODE_DECL(V, 32, FIELD_RETURN_TYPE_32, uint32_t)                             \
+  ART_GET_FIELD_FROM_CODE_DECL(V, 64, uint64_t, uint64_t)                                         \
+  ART_GET_FIELD_FROM_CODE_DECL(V, Obj, mirror::Object*, mirror::Object*)                          \
+  V(artSet8StaticFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                    \
+      uint32_t field_idx,                                                                         \
+      uint32_t new_value,                                                                         \
+      Thread* self)                                                                               \
+  V(artSet16StaticFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                   \
+      uint32_t field_idx,                                                                         \
+      uint16_t new_value,                                                                         \
+      Thread* self)                                                                               \
+  V(artSet8InstanceFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                  \
+      uint32_t field_idx,                                                                         \
+      mirror::Object* obj,                                                                        \
+      uint8_t new_value,                                                                          \
+      Thread* self)                                                                               \
+  V(artSet16InstanceFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                 \
+      uint32_t field_idx,                                                                         \
+      mirror::Object* obj,                                                                        \
+      uint16_t new_value,                                                                         \
+      Thread* self)                                                                               \
+  V(artSet8StaticFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                            \
+      uint32_t field_idx,                                                                         \
+      uint32_t new_value,                                                                         \
+      ArtMethod* referrer,                                                                        \
+      Thread* self)                                                                               \
+  V(artSet16StaticFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                           \
+      uint32_t field_idx,                                                                         \
+      uint16_t new_value,                                                                         \
+      ArtMethod* referrer,                                                                        \
+      Thread* self)                                                                               \
+  V(artSet8InstanceFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                          \
+      uint32_t field_idx,                                                                         \
+      mirror::Object* obj,                                                                        \
+      uint8_t new_value,                                                                          \
+      ArtMethod* referrer,                                                                        \
+      Thread* self)                                                                               \
+  V(artSet16InstanceFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,                         \
+      uint32_t field_idx,                                                                         \
+      mirror::Object* obj,                                                                        \
+      uint16_t new_value,                                                                         \
+      ArtMethod* referrer,                                                                        \
+      Thread* self)                                                                               \
+  V(artReadBarrierMark, REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, mirror::Object*,          \
+      mirror::Object* obj)                                                                        \
+  V(artReadBarrierSlow, REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, mirror::Object*,          \
+      mirror::Object* ref,                                                                        \
+      mirror::Object* obj,                                                                        \
+      uint32_t offset)                                                                            \
+  V(artReadBarrierForRootSlow, REQUIRES_SHARED(Locks::mutator_lock_) HOT_ATTR, mirror::Object*,   \
+      GcRoot<mirror::Object>* root)                                                               \
+                                                                                                  \
+  V(artLockObjectFromCode, NO_THREAD_SAFETY_ANALYSIS REQUIRES(!Roles::uninterruptible_)           \
+      REQUIRES_SHARED(Locks::mutator_lock_), int,                                                 \
+      mirror::Object* obj,                                                                        \
+      Thread* self)                                                                               \
+  V(artUnlockObjectFromCode, NO_THREAD_SAFETY_ANALYSIS REQUIRES(!Roles::uninterruptible_)         \
+      REQUIRES_SHARED(Locks::mutator_lock_), int,                                                 \
+      mirror::Object* obj,                                                                        \
+      Thread* self)                                                                               \
+                                                                                                  \
+  V(artFindNativeMethodRunnable, REQUIRES_SHARED(Locks::mutator_lock_), const void*,              \
+      Thread* self)                                                                               \
+  V(artFindNativeMethod, , const void*,                                                           \
+      Thread* self)                                                                               \
+  V(artCriticalNativeFrameSize, REQUIRES_SHARED(Locks::mutator_lock_), size_t,                    \
+      ArtMethod* method,                                                                          \
+      uintptr_t caller_pc)                                                                        \
+                                                                                                  \
+  V(artLmul, , int64_t,                                                                           \
+      int64_t a,                                                                                  \
+      int64_t b)                                                                                  \
+  V(artLdiv, , int64_t,                                                                           \
+      int64_t a,                                                                                  \
+      int64_t b)                                                                                  \
+  V(artLmod, , int64_t,                                                                           \
+      int64_t a,                                                                                  \
+      int64_t b)                                                                                  \
+                                                                                                  \
+  V(art_l2d, , double,                                                                            \
+      int64_t l)                                                                                  \
+  V(art_l2f, , float,                                                                             \
+      int64_t l)                                                                                  \
+  V(art_d2l, , int64_t,                                                                           \
+      double d)                                                                                   \
+  V(art_f2l, , int64_t,                                                                           \
+      float f)                                                                                    \
+  V(art_d2i, , int32_t,                                                                           \
+      double d)                                                                                   \
+  V(art_f2i, , int32_t,                                                                           \
+      float f)                                                                                    \
+  V(fmodf, , float,                                                                               \
+      float,                                                                                      \
+      float)                                                                                      \
+  V(fmod, , double,                                                                               \
+      double,                                                                                     \
+      double)
+
+// Declarations from quick_alloc_entrypoints.cc
+#define GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR_INST(V, suffix, suffix2)                          \
+  V(artAllocObjectFromCodeWithChecks##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),     \
+      mirror::Object*,                                                                            \
+      mirror::Class* klass,                                                                       \
+      Thread* self)                                                                               \
+  V(artAllocObjectFromCodeResolved##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),       \
+      mirror::Object*,                                                                            \
+      mirror::Class* klass,                                                                       \
+      Thread* self)                                                                               \
+  V(artAllocObjectFromCodeInitialized##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),    \
+      mirror::Object*,                                                                            \
+      mirror::Class* klass,                                                                       \
+      Thread* self)                                                                               \
+  V(artAllocStringObject##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),                 \
+      mirror::String*,                                                                            \
+      mirror::Class* klass,                                                                       \
+      Thread* self)                                                                               \
+  V(artAllocArrayFromCodeResolved##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),        \
+      mirror::Array*,                                                                             \
+      mirror::Class* klass,                                                                       \
+      int32_t component_count,                                                                    \
+      Thread* self)                                                                               \
+  V(artAllocStringFromBytesFromCode##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),      \
+      mirror::String*,                                                                            \
+      mirror::ByteArray* byte_array,                                                              \
+      int32_t high,                                                                               \
+      int32_t offset,                                                                             \
+      int32_t byte_count,                                                                         \
+      Thread* self)                                                                               \
+  V(artAllocStringFromCharsFromCode##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),      \
+      mirror::String*,                                                                            \
+      int32_t offset,                                                                             \
+      int32_t char_count,                                                                         \
+      mirror::CharArray* char_array,                                                              \
+      Thread* self)                                                                               \
+  V(artAllocStringFromStringFromCode##suffix##suffix2, REQUIRES_SHARED(Locks::mutator_lock_),     \
+      mirror::String*,                                                                            \
+      mirror::String* string,                                                                     \
+      Thread* self)
+
+#define GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR(V, suffix)              \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR_INST(V, suffix, Instrumented) \
+  GENERATE_ENTRYPOINTS_DECL_FOR_ALLOCATOR_INST(V, suffix, )
+
+// Declarations from quick_field_entrypoints.cc
+#define ART_GET_FIELD_FROM_CODE_DECL(V, Kind, RetType, SetType)                                 \
+  V(artGet ## Kind ## StaticFromCode, REQUIRES_SHARED(Locks::mutator_lock_), RetType,           \
+      uint32_t field_idx,                                                                       \
+      ArtMethod* referrer,                                                                      \
+      Thread* self)                                                                             \
+  V(artGet ## Kind ## InstanceFromCode, REQUIRES_SHARED(Locks::mutator_lock_), RetType,         \
+      uint32_t field_idx,                                                                       \
+      mirror::Object* obj,                                                                      \
+      ArtMethod* referrer,                                                                      \
+      Thread* self)                                                                             \
+  V(artSet ## Kind ## StaticFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,               \
+      uint32_t field_idx,                                                                       \
+      SetType new_value,                                                                        \
+      ArtMethod* referrer,                                                                      \
+      Thread* self)                                                                             \
+  V(artSet ## Kind ## InstanceFromCode, REQUIRES_SHARED(Locks::mutator_lock_), int,             \
+      uint32_t field_idx,                                                                       \
+      mirror::Object* obj,                                                                      \
+      SetType new_value,                                                                        \
+      ArtMethod* referrer,                                                                      \
+      Thread* self)                                                                             \
+  V(artGet ## Kind ## StaticFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), RetType,   \
+      uint32_t field_idx,                                                                       \
+      Thread* self)                                                                             \
+  V(artGet ## Kind ## InstanceFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), RetType, \
+      uint32_t field_idx,                                                                       \
+      mirror::Object* obj,                                                                      \
+      Thread* self)                                                                             \
+  V(artSet ## Kind ## StaticFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,       \
+      uint32_t field_idx,                                                                       \
+      SetType new_value,                                                                        \
+      Thread* self)                                                                             \
+  V(artSet ## Kind ## InstanceFromCompiledCode, REQUIRES_SHARED(Locks::mutator_lock_), int,     \
+      uint32_t field_idx,                                                                       \
+      mirror::Object* obj,                                                                      \
+      SetType new_value,                                                                        \
+      Thread* self)
+
+#if defined(__riscv)
+#define FIELD_RETURN_TYPE_32 uint32_t
+#else
+#define FIELD_RETURN_TYPE_32 size_t
+#endif
+
+// Define a macro that will extract information from RUNTIME_ENTRYPOINT_LIST to create a function
+// declaration.
+#define ENTRYPOINT_ENUM(name, attr, rettype, ...) \
+  extern "C" rettype name(__VA_ARGS__) attr;
+
+// Declare all C++ quick entrypoints.
+RUNTIME_ENTRYPOINT_LIST(ENTRYPOINT_ENUM)
+#undef ENTRYPOINT_ENUM
+
+}  // namespace art
+
+#endif  // ART_RUNTIME_ENTRYPOINTS_QUICK_RUNTIME_ENTRYPOINTS_LIST_H_
diff --git a/runtime/fault_handler.cc b/runtime/fault_handler.cc
index 05bbfcf912..881dbadd0c 100644
--- a/runtime/fault_handler.cc
+++ b/runtime/fault_handler.cc
@@ -242,7 +242,7 @@ bool FaultManager::HandleSigbusFault(int sig, siginfo_t* info, [[maybe_unused]]
 
 inline void FaultManager::CheckForUnrecognizedImplicitSuspendCheckInBootImage(
     siginfo_t* siginfo, void* context) {
-  CHECK_EQ(kRuntimeISA, InstructionSet::kArm64);
+  CHECK_EQ(kRuntimeQuickCodeISA, InstructionSet::kArm64);
   uintptr_t fault_pc = GetFaultPc(siginfo, context);
   if (fault_pc == 0u || !IsUint<32>(fault_pc) || !IsAligned<4u>(fault_pc)) {
     return;
@@ -301,7 +301,7 @@ bool FaultManager::HandleSigsegvFault(int sig, siginfo_t* info, void* context) {
         return true;
       }
     }
-  } else if (kRuntimeISA == InstructionSet::kArm64) {
+  } else if (kRuntimeQuickCodeISA == InstructionSet::kArm64) {
     CheckForUnrecognizedImplicitSuspendCheckInBootImage(info, context);
   }
 
diff --git a/runtime/fuzzer_corpus_test.cc b/runtime/fuzzer_corpus_test.cc
index 24edebcc20..6b312d5973 100644
--- a/runtime/fuzzer_corpus_test.cc
+++ b/runtime/fuzzer_corpus_test.cc
@@ -124,8 +124,8 @@ class FuzzerCorpusTest : public CommonRuntimeTest {
           scope.NewHandle<art::mirror::DexCache>(nullptr));
 
       for (art::ClassAccessor accessor : dex_file.GetClasses()) {
-        const char* descriptor = accessor.GetDescriptor();
-        h_klass.Assign(class_linker->FindClass(soa.Self(), descriptor, h_loader));
+        h_klass.Assign(
+            class_linker->FindClass(soa.Self(), dex_file, accessor.GetClassIdx(), h_loader));
         // Ignore classes that couldn't be loaded since we are looking for crashes during
         // class/method verification.
         if (h_klass == nullptr || h_klass->IsErroneous()) {
diff --git a/runtime/gc/collector/mark_compact-inl.h b/runtime/gc/collector/mark_compact-inl.h
index 05dc65a961..d840223720 100644
--- a/runtime/gc/collector/mark_compact-inl.h
+++ b/runtime/gc/collector/mark_compact-inl.h
@@ -20,6 +20,7 @@
 #include "gc/space/bump_pointer_space.h"
 #include "mark_compact.h"
 #include "mirror/object-inl.h"
+#include "thread-inl.h"
 
 namespace art HIDDEN {
 namespace gc {
@@ -256,8 +257,11 @@ inline bool MarkCompact::VerifyRootSingleUpdate(void* root,
     }
     Thread* self = Thread::Current();
     if (UNLIKELY(stack_low_addr == nullptr)) {
-      stack_low_addr = self->GetStackEnd();
-      stack_high_addr = reinterpret_cast<char*>(stack_low_addr) + self->GetStackSize();
+      // TODO(Simulator): Test that this should not operate on the simulated stack when the
+      // simulator supports mark compact.
+      stack_low_addr = self->GetStackEnd<kNativeStackType>();
+      stack_high_addr = reinterpret_cast<char*>(stack_low_addr)
+                        + self->GetUsableStackSize<kNativeStackType>();
     }
     if (std::less<void*>{}(root, stack_low_addr) || std::greater<void*>{}(root, stack_high_addr)) {
       bool inserted;
diff --git a/runtime/gc/collector/mark_compact.cc b/runtime/gc/collector/mark_compact.cc
index 618625ec61..a7af756970 100644
--- a/runtime/gc/collector/mark_compact.cc
+++ b/runtime/gc/collector/mark_compact.cc
@@ -113,13 +113,12 @@ static uint64_t gUffdFeatures = 0;
 static constexpr uint64_t kUffdFeaturesForMinorFault =
     UFFD_FEATURE_MISSING_SHMEM | UFFD_FEATURE_MINOR_SHMEM;
 static constexpr uint64_t kUffdFeaturesForSigbus = UFFD_FEATURE_SIGBUS;
-
+// A region which is more than kBlackDenseRegionThreshold percent live doesn't
+// need to be compacted as it is too densely packed.
+static constexpr uint kBlackDenseRegionThreshold = 95U;
 // We consider SIGBUS feature necessary to enable this GC as it's superior than
-// threading-based implementation for janks. However, since we have the latter
-// already implemented, for testing purposes, we allow choosing either of the
-// two at boot time in the constructor below.
-// We may want minor-fault in future to be available for making jit-code-cache
-// updation concurrent, which uses shmem.
+// threading-based implementation for janks. We may want minor-fault in future
+// to be available for making jit-code-cache updation concurrent, which uses shmem.
 bool KernelSupportsUffd() {
 #ifdef __linux__
   if (gHaveMremapDontunmap) {
@@ -447,6 +446,7 @@ MarkCompact::MarkCompact(Heap* heap)
       moving_space_bitmap_(bump_pointer_space_->GetMarkBitmap()),
       moving_space_begin_(bump_pointer_space_->Begin()),
       moving_space_end_(bump_pointer_space_->Limit()),
+      black_dense_end_(moving_space_begin_),
       uffd_(kFdUnused),
       sigbus_in_progress_count_{kSigbusCounterCompactionDoneMask, kSigbusCounterCompactionDoneMask},
       compacting_(false),
@@ -703,10 +703,14 @@ void MarkCompact::InitializePhase() {
   freed_objects_ = 0;
   // The first buffer is used by gc-thread.
   compaction_buffer_counter_.store(1, std::memory_order_relaxed);
-  from_space_slide_diff_ = from_space_begin_ - bump_pointer_space_->Begin();
   black_allocations_begin_ = bump_pointer_space_->Limit();
-  CHECK_EQ(moving_space_begin_, bump_pointer_space_->Begin());
+  DCHECK_EQ(moving_space_begin_, bump_pointer_space_->Begin());
+  from_space_slide_diff_ = from_space_begin_ - moving_space_begin_;
   moving_space_end_ = bump_pointer_space_->Limit();
+  if (black_dense_end_ > moving_space_begin_) {
+    moving_space_bitmap_->Clear();
+  }
+  black_dense_end_ = moving_space_begin_;
   // TODO: Would it suffice to read it once in the constructor, which is called
   // in zygote process?
   pointer_size_ = Runtime::Current()->GetClassLinker()->GetImagePointerSize();
@@ -763,47 +767,49 @@ void MarkCompact::RunPhases() {
       bump_pointer_space_->AssertAllThreadLocalBuffersAreRevoked();
     }
   }
+  bool perform_compaction;
   {
     ReaderMutexLock mu(self, *Locks::mutator_lock_);
     ReclaimPhase();
-    PrepareForCompaction();
+    perform_compaction = PrepareForCompaction();
   }
 
-  {
+  if (perform_compaction) {
     // Compaction pause
     ThreadFlipVisitor visitor(this);
     FlipCallback callback(this);
     runtime->GetThreadList()->FlipThreadRoots(
         &visitor, &callback, this, GetHeap()->GetGcPauseListener());
-  }
 
-  if (IsValidFd(uffd_)) {
-    ReaderMutexLock mu(self, *Locks::mutator_lock_);
-    CompactionPhase();
+    if (IsValidFd(uffd_)) {
+      ReaderMutexLock mu(self, *Locks::mutator_lock_);
+      CompactionPhase();
+    }
   }
-
   FinishPhase();
+  GetHeap()->PostGcVerification(this);
   thread_running_gc_ = nullptr;
 }
 
-void MarkCompact::InitMovingSpaceFirstObjects(const size_t vec_len) {
-  // Find the first live word first.
-  size_t to_space_page_idx = 0;
+void MarkCompact::InitMovingSpaceFirstObjects(size_t vec_len, size_t to_space_page_idx) {
   uint32_t offset_in_chunk_word;
   uint32_t offset;
   mirror::Object* obj;
   const uintptr_t heap_begin = moving_space_bitmap_->HeapBegin();
 
-  size_t chunk_idx;
+  // Find the first live word.
+  size_t chunk_idx = to_space_page_idx * (gPageSize / kOffsetChunkSize);
+  DCHECK_LT(chunk_idx, vec_len);
   // Find the first live word in the space
-  for (chunk_idx = 0; chunk_info_vec_[chunk_idx] == 0; chunk_idx++) {
+  for (; chunk_info_vec_[chunk_idx] == 0; chunk_idx++) {
     if (chunk_idx >= vec_len) {
       // We don't have any live data on the moving-space.
+      moving_first_objs_count_ = to_space_page_idx;
       return;
     }
   }
   DCHECK_LT(chunk_idx, vec_len);
-  // Use live-words bitmap to find the first word
+  // Use live-words bitmap to find the first live word
   offset_in_chunk_word = live_words_bitmap_->FindNthLiveWordOffset(chunk_idx, /*n*/ 0);
   offset = chunk_idx * kBitsPerVectorWord + offset_in_chunk_word;
   DCHECK(live_words_bitmap_->Test(offset)) << "offset=" << offset
@@ -812,8 +818,7 @@ void MarkCompact::InitMovingSpaceFirstObjects(const size_t vec_len) {
                                            << " offset_in_word=" << offset_in_chunk_word
                                            << " word=" << std::hex
                                            << live_words_bitmap_->GetWord(chunk_idx);
-  // The first object doesn't require using FindPrecedingObject().
-  obj = reinterpret_cast<mirror::Object*>(heap_begin + offset * kAlignment);
+  obj = moving_space_bitmap_->FindPrecedingObject(heap_begin + offset * kAlignment);
   // TODO: add a check to validate the object.
 
   pre_compact_offset_moving_space_[to_space_page_idx] = offset;
@@ -862,10 +867,10 @@ void MarkCompact::InitMovingSpaceFirstObjects(const size_t vec_len) {
   }
 }
 
-void MarkCompact::InitNonMovingSpaceFirstObjects() {
-  accounting::ContinuousSpaceBitmap* bitmap = non_moving_space_->GetLiveBitmap();
-  uintptr_t begin = reinterpret_cast<uintptr_t>(non_moving_space_->Begin());
-  const uintptr_t end = reinterpret_cast<uintptr_t>(non_moving_space_->End());
+size_t MarkCompact::InitNonMovingFirstObjects(uintptr_t begin,
+                                              uintptr_t end,
+                                              accounting::ContinuousSpaceBitmap* bitmap,
+                                              ObjReference* first_objs_arr) {
   mirror::Object* prev_obj;
   size_t page_idx;
   {
@@ -877,11 +882,11 @@ void MarkCompact::InitNonMovingSpaceFirstObjects() {
                                                     obj = o;
                                                   });
     if (obj == nullptr) {
-      // There are no live objects in the non-moving space
-      return;
+      // There are no live objects in the space
+      return 0;
     }
     page_idx = DivideByPageSize(reinterpret_cast<uintptr_t>(obj) - begin);
-    first_objs_non_moving_space_[page_idx++].Assign(obj);
+    first_objs_arr[page_idx++].Assign(obj);
     prev_obj = obj;
   }
   // TODO: check obj is valid
@@ -896,13 +901,7 @@ void MarkCompact::InitNonMovingSpaceFirstObjects() {
     // overlaps with this page as well.
     if (prev_obj != nullptr && prev_obj_end > begin) {
       DCHECK_LT(prev_obj, reinterpret_cast<mirror::Object*>(begin));
-      first_objs_non_moving_space_[page_idx].Assign(prev_obj);
-      mirror::Class* klass = prev_obj->GetClass<kVerifyNone, kWithoutReadBarrier>();
-      if (HasAddress(klass)) {
-        LOG(WARNING) << "found inter-page object " << prev_obj
-                     << " in non-moving space with klass " << klass
-                     << " in moving space";
-      }
+      first_objs_arr[page_idx].Assign(prev_obj);
     } else {
       prev_obj_end = 0;
       // It's sufficient to only search for previous object in the preceding page.
@@ -915,21 +914,13 @@ void MarkCompact::InitNonMovingSpaceFirstObjects() {
                         + RoundUp(prev_obj->SizeOf<kDefaultVerifyFlags>(), kAlignment);
       }
       if (prev_obj_end > begin) {
-        mirror::Class* klass = prev_obj->GetClass<kVerifyNone, kWithoutReadBarrier>();
-        if (HasAddress(klass)) {
-          LOG(WARNING) << "found inter-page object " << prev_obj
-                       << " in non-moving space with klass " << klass
-                       << " in moving space";
-        }
-        first_objs_non_moving_space_[page_idx].Assign(prev_obj);
+        first_objs_arr[page_idx].Assign(prev_obj);
       } else {
         // Find the first live object in this page
         bitmap->VisitMarkedRange</*kVisitOnce*/ true>(
-                begin,
-                begin + gPageSize,
-                [this, page_idx] (mirror::Object* obj) {
-                  first_objs_non_moving_space_[page_idx].Assign(obj);
-                });
+            begin, begin + gPageSize, [first_objs_arr, page_idx](mirror::Object* obj) {
+              first_objs_arr[page_idx].Assign(obj);
+            });
       }
       // An empty entry indicates that the page has no live objects and hence
       // can be skipped.
@@ -937,20 +928,23 @@ void MarkCompact::InitNonMovingSpaceFirstObjects() {
     begin += gPageSize;
     page_idx++;
   }
-  non_moving_first_objs_count_ = page_idx;
+  return page_idx;
 }
 
-void MarkCompact::PrepareForCompaction() {
+bool MarkCompact::PrepareForCompaction() {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
-  uint8_t* space_begin = bump_pointer_space_->Begin();
-  size_t vector_len = (black_allocations_begin_ - space_begin) / kOffsetChunkSize;
+  size_t chunk_info_per_page = gPageSize / kOffsetChunkSize;
+  size_t vector_len = (black_allocations_begin_ - moving_space_begin_) / kOffsetChunkSize;
   DCHECK_LE(vector_len, vector_length_);
+  DCHECK_ALIGNED_PARAM(vector_length_, chunk_info_per_page);
+  if (UNLIKELY(vector_len == 0)) {
+    // Nothing to compact.
+    return false;
+  }
   for (size_t i = 0; i < vector_len; i++) {
     DCHECK_LE(chunk_info_vec_[i], kOffsetChunkSize);
     DCHECK_EQ(chunk_info_vec_[i], live_words_bitmap_->LiveBytesInBitmapWord(i));
   }
-  InitMovingSpaceFirstObjects(vector_len);
-  InitNonMovingSpaceFirstObjects();
 
   // TODO: We can do a lot of neat tricks with this offset vector to tune the
   // compaction as we wish. Originally, the compaction algorithm slides all
@@ -974,29 +968,107 @@ void MarkCompact::PrepareForCompaction() {
   // of the corresponding chunk. For old-to-new address computation we need
   // every element to reflect total live-bytes till the corresponding chunk.
 
-  // Live-bytes count is required to compute post_compact_end_ below.
-  uint32_t total;
+  size_t black_dense_idx = 0;
+  GcCause gc_cause = GetCurrentIteration()->GetGcCause();
+  if (gc_cause != kGcCauseExplicit && gc_cause != kGcCauseCollectorTransition &&
+      !GetCurrentIteration()->GetClearSoftReferences()) {
+    uint64_t live_bytes = 0, total_bytes = 0;
+    size_t aligned_vec_len = RoundUp(vector_len, chunk_info_per_page);
+    size_t num_pages = aligned_vec_len / chunk_info_per_page;
+    size_t threshold_passing_marker = 0;  // In number of pages
+    std::vector<uint32_t> pages_live_bytes;
+    pages_live_bytes.reserve(num_pages);
+    // Identify the largest chunk towards the beginning of moving space which
+    // passes the black-dense threshold.
+    for (size_t i = 0; i < aligned_vec_len; i += chunk_info_per_page) {
+      uint32_t page_live_bytes = 0;
+      for (size_t j = 0; j < chunk_info_per_page; j++) {
+        page_live_bytes += chunk_info_vec_[i + j];
+        total_bytes += kOffsetChunkSize;
+      }
+      live_bytes += page_live_bytes;
+      pages_live_bytes.push_back(page_live_bytes);
+      if (live_bytes * 100U >= total_bytes * kBlackDenseRegionThreshold) {
+        threshold_passing_marker = pages_live_bytes.size();
+      }
+    }
+    DCHECK_EQ(pages_live_bytes.size(), num_pages);
+    // Eliminate the pages at the end of the chunk which are lower than the threshold.
+    if (threshold_passing_marker > 0) {
+      auto iter = std::find_if(
+          pages_live_bytes.rbegin() + (num_pages - threshold_passing_marker),
+          pages_live_bytes.rend(),
+          [](uint32_t bytes) { return bytes * 100U >= gPageSize * kBlackDenseRegionThreshold; });
+      black_dense_idx = (pages_live_bytes.rend() - iter) * chunk_info_per_page;
+    }
+    black_dense_end_ = moving_space_begin_ + black_dense_idx * kOffsetChunkSize;
+    DCHECK_ALIGNED_PARAM(black_dense_end_, gPageSize);
+
+    // Adjust for class allocated after black_dense_end_ while its object(s)
+    // are earlier. This is required as we update the references in the
+    // black-dense region in-place. And if the class pointer of some first
+    // object for a page, which started in some preceding page, is already
+    // updated, then we will read wrong class data like ref-offset bitmap.
+    for (auto iter = class_after_obj_map_.rbegin();
+         iter != class_after_obj_map_.rend() &&
+         reinterpret_cast<uint8_t*>(iter->first.AsMirrorPtr()) >= black_dense_end_;
+         iter++) {
+      black_dense_end_ =
+          std::min(black_dense_end_, reinterpret_cast<uint8_t*>(iter->second.AsMirrorPtr()));
+      black_dense_end_ = AlignDown(black_dense_end_, gPageSize);
+    }
+    black_dense_idx = (black_dense_end_ - moving_space_begin_) / kOffsetChunkSize;
+    DCHECK_LE(black_dense_idx, vector_len);
+    if (black_dense_idx == vector_len) {
+      // There is nothing to compact.
+      return false;
+    }
+    InitNonMovingFirstObjects(reinterpret_cast<uintptr_t>(moving_space_begin_),
+                              reinterpret_cast<uintptr_t>(black_dense_end_),
+                              moving_space_bitmap_,
+                              first_objs_moving_space_);
+  }
+
+  InitMovingSpaceFirstObjects(vector_len, black_dense_idx / chunk_info_per_page);
+  non_moving_first_objs_count_ =
+      InitNonMovingFirstObjects(reinterpret_cast<uintptr_t>(non_moving_space_->Begin()),
+                                reinterpret_cast<uintptr_t>(non_moving_space_->End()),
+                                non_moving_space_->GetLiveBitmap(),
+                                first_objs_non_moving_space_);
   // Update the vector one past the heap usage as it is required for black
   // allocated objects' post-compact address computation.
+  uint32_t total_bytes;
   if (vector_len < vector_length_) {
     vector_len++;
-    total = 0;
+    total_bytes = 0;
   } else {
     // Fetch the value stored in the last element before it gets overwritten by
     // std::exclusive_scan().
-    total = chunk_info_vec_[vector_len - 1];
+    total_bytes = chunk_info_vec_[vector_len - 1];
+  }
+  std::exclusive_scan(chunk_info_vec_ + black_dense_idx,
+                      chunk_info_vec_ + vector_len,
+                      chunk_info_vec_ + black_dense_idx,
+                      black_dense_idx * kOffsetChunkSize);
+  total_bytes += chunk_info_vec_[vector_len - 1];
+  post_compact_end_ = AlignUp(moving_space_begin_ + total_bytes, gPageSize);
+  CHECK_EQ(post_compact_end_, moving_space_begin_ + moving_first_objs_count_ * gPageSize)
+      << "moving_first_objs_count_:" << moving_first_objs_count_
+      << " black_dense_idx:" << black_dense_idx << " vector_len:" << vector_len
+      << " total_bytes:" << total_bytes
+      << " black_dense_end:" << reinterpret_cast<void*>(black_dense_end_)
+      << " chunk_info_per_page:" << chunk_info_per_page;
+  black_objs_slide_diff_ = black_allocations_begin_ - post_compact_end_;
+  // We shouldn't be consuming more space after compaction than pre-compaction.
+  CHECK_GE(black_objs_slide_diff_, 0);
+  if (black_objs_slide_diff_ == 0) {
+    black_dense_end_ = black_allocations_begin_;
+    return false;
   }
-  std::exclusive_scan(chunk_info_vec_, chunk_info_vec_ + vector_len, chunk_info_vec_, 0);
-  total += chunk_info_vec_[vector_len - 1];
-
   for (size_t i = vector_len; i < vector_length_; i++) {
     DCHECK_EQ(chunk_info_vec_[i], 0u);
   }
-  post_compact_end_ = AlignUp(space_begin + total, gPageSize);
-  CHECK_EQ(post_compact_end_, space_begin + moving_first_objs_count_ * gPageSize);
-  black_objs_slide_diff_ = black_allocations_begin_ - post_compact_end_;
-  // We shouldn't be consuming more space after compaction than pre-compaction.
-  CHECK_GE(black_objs_slide_diff_, 0);
+
   // How do we handle compaction of heap portion used for allocations after the
   // marking-pause?
   // All allocations after the marking-pause are considered black (reachable)
@@ -1011,6 +1083,7 @@ void MarkCompact::PrepareForCompaction() {
   if (!uffd_initialized_) {
     CreateUserfaultfd(/*post_fork=*/false);
   }
+  return true;
 }
 
 class MarkCompact::VerifyRootMarkedVisitor : public SingleRootVisitor {
@@ -1191,7 +1264,7 @@ class MarkCompact::RefsUpdateVisitor {
                              uint8_t* begin,
                              uint8_t* end)
       : collector_(collector),
-        moving_space_begin_(collector->moving_space_begin_),
+        moving_space_begin_(collector->black_dense_end_),
         moving_space_end_(collector->moving_space_end_),
         obj_(obj),
         begin_(begin),
@@ -1894,24 +1967,32 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
     }
   } else {
     DCHECK_GE(pre_compact_offset_moving_space_[idx], 0u);
-    idx_addr = bump_pointer_space_->Begin() + pre_compact_offset_moving_space_[idx] * kAlignment;
+    idx_addr = moving_space_begin_ + idx * gPageSize;
+    if (idx_addr >= black_dense_end_) {
+      idx_addr = moving_space_begin_ + pre_compact_offset_moving_space_[idx] * kAlignment;
+    }
     reclaim_begin = idx_addr;
     DCHECK_LE(reclaim_begin, black_allocations_begin_);
     mirror::Object* first_obj = first_objs_moving_space_[idx].AsMirrorPtr();
-    if (reinterpret_cast<uint8_t*>(first_obj) < reclaim_begin) {
-      DCHECK_LT(idx, moving_first_objs_count_);
-      mirror::Object* obj = first_obj;
-      for (size_t i = idx + 1; i < moving_first_objs_count_; i++) {
-        obj = first_objs_moving_space_[i].AsMirrorPtr();
-        if (first_obj != obj) {
-          DCHECK_LT(first_obj, obj);
-          DCHECK_LT(reclaim_begin, reinterpret_cast<uint8_t*>(obj));
-          reclaim_begin = reinterpret_cast<uint8_t*>(obj);
-          break;
+    if (first_obj != nullptr) {
+      if (reinterpret_cast<uint8_t*>(first_obj) < reclaim_begin) {
+        DCHECK_LT(idx, moving_first_objs_count_);
+        mirror::Object* obj = first_obj;
+        for (size_t i = idx + 1; i < moving_first_objs_count_; i++) {
+          obj = first_objs_moving_space_[i].AsMirrorPtr();
+          if (obj == nullptr) {
+            reclaim_begin = moving_space_begin_ + i * gPageSize;
+            break;
+          } else if (first_obj != obj) {
+            DCHECK_LT(first_obj, obj);
+            DCHECK_LT(reclaim_begin, reinterpret_cast<uint8_t*>(obj));
+            reclaim_begin = reinterpret_cast<uint8_t*>(obj);
+            break;
+          }
+        }
+        if (obj == first_obj) {
+          reclaim_begin = black_allocations_begin_;
         }
-      }
-      if (obj == first_obj) {
-        reclaim_begin = black_allocations_begin_;
       }
     }
     reclaim_begin = AlignUp(reclaim_begin, gPageSize);
@@ -1973,8 +2054,7 @@ bool MarkCompact::FreeFromSpacePages(size_t cur_page_idx, int mode, size_t end_i
       cur_reclaimable_page_ = addr;
     }
   }
-  CHECK_LE(reclaim_begin, last_reclaimable_page_);
-  last_reclaimable_page_ = reclaim_begin;
+  last_reclaimable_page_ = std::min(reclaim_begin, last_reclaimable_page_);
   last_checked_reclaim_page_idx_ = idx;
   return all_mapped;
 }
@@ -1994,7 +2074,8 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
   TimingLogger::ScopedTiming t(__FUNCTION__, GetTimings());
   size_t page_status_arr_len = moving_first_objs_count_ + black_page_count_;
   size_t idx = page_status_arr_len;
-  uint8_t* to_space_end = bump_pointer_space_->Begin() + page_status_arr_len * gPageSize;
+  size_t black_dense_end_idx = (black_dense_end_ - moving_space_begin_) / gPageSize;
+  uint8_t* to_space_end = moving_space_begin_ + page_status_arr_len * gPageSize;
   uint8_t* pre_compact_page = black_allocations_begin_ + (black_page_count_ * gPageSize);
 
   DCHECK(IsAlignedParam(pre_compact_page, gPageSize));
@@ -2041,7 +2122,7 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
   // Reserved page to be used if we can't find any reclaimable page for processing.
   uint8_t* reserve_page = page;
   size_t end_idx_for_mapping = idx;
-  while (idx > 0) {
+  while (idx > black_dense_end_idx) {
     idx--;
     to_space_end -= gPageSize;
     if (kMode == kFallbackMode) {
@@ -2077,6 +2158,36 @@ void MarkCompact::CompactMovingSpace(uint8_t* page) {
       end_idx_for_mapping = idx;
     }
   }
+  while (idx > 0) {
+    idx--;
+    to_space_end -= gPageSize;
+    mirror::Object* first_obj = first_objs_moving_space_[idx].AsMirrorPtr();
+    if (first_obj != nullptr) {
+      DoPageCompactionWithStateChange<kMode>(
+          idx,
+          to_space_end,
+          to_space_end + from_space_slide_diff_,
+          /*map_immediately=*/false,
+          [&]() REQUIRES_SHARED(Locks::mutator_lock_) {
+            UpdateNonMovingPage(
+                first_obj, to_space_end, from_space_slide_diff_, moving_space_bitmap_);
+            if (kMode == kFallbackMode) {
+              memcpy(to_space_end, to_space_end + from_space_slide_diff_, gPageSize);
+            }
+          });
+    } else {
+      // The page has no reachable object on it. Just declare it mapped.
+      // Mutators shouldn't step on this page, which is asserted in sigbus
+      // handler.
+      DCHECK_EQ(moving_pages_status_[idx].load(std::memory_order_relaxed),
+                static_cast<uint8_t>(PageState::kUnprocessed));
+      moving_pages_status_[idx].store(static_cast<uint8_t>(PageState::kProcessedAndMapped),
+                                      std::memory_order_release);
+    }
+    if (FreeFromSpacePages(idx, kMode, end_idx_for_mapping)) {
+      end_idx_for_mapping = idx;
+    }
+  }
   // map one last time to finish anything left.
   if (kMode == kCopyMode && end_idx_for_mapping > 0) {
     MapMovingSpacePages(idx,
@@ -2100,12 +2211,13 @@ size_t MarkCompact::MapMovingSpacePages(size_t start_idx,
     size_t map_count = 0;
     uint32_t cur_state = moving_pages_status_[arr_idx].load(std::memory_order_acquire);
     // Find a contiguous range that can be mapped with single ioctl.
-    for (size_t i = arr_idx; i < arr_len; i++, map_count++) {
+    for (uint32_t i = arr_idx, from_page = cur_state & ~kPageStateMask; i < arr_len;
+         i++, map_count++, from_page += gPageSize) {
       uint32_t s = moving_pages_status_[i].load(std::memory_order_acquire);
-      if (GetPageStateFromWord(s) != PageState::kProcessed) {
+      uint32_t cur_from_page = s & ~kPageStateMask;
+      if (GetPageStateFromWord(s) != PageState::kProcessed || cur_from_page != from_page) {
         break;
       }
-      DCHECK_EQ((cur_state & ~kPageStateMask) + (i - arr_idx) * gPageSize, s & ~kPageStateMask);
     }
 
     if (map_count == 0) {
@@ -2162,7 +2274,10 @@ size_t MarkCompact::MapMovingSpacePages(size_t start_idx,
   return arr_len - start_idx;
 }
 
-void MarkCompact::UpdateNonMovingPage(mirror::Object* first, uint8_t* page) {
+void MarkCompact::UpdateNonMovingPage(mirror::Object* first,
+                                      uint8_t* page,
+                                      ptrdiff_t from_space_diff,
+                                      accounting::ContinuousSpaceBitmap* bitmap) {
   DCHECK_LT(reinterpret_cast<uint8_t*>(first), page + gPageSize);
   // For every object found in the page, visit the previous object. This ensures
   // that we can visit without checking page-end boundary.
@@ -2171,41 +2286,43 @@ void MarkCompact::UpdateNonMovingPage(mirror::Object* first, uint8_t* page) {
   // TODO: Set kVisitNativeRoots to false once we implement concurrent
   // compaction
   mirror::Object* curr_obj = first;
-  non_moving_space_bitmap_->VisitMarkedRange(
-          reinterpret_cast<uintptr_t>(first) + mirror::kObjectHeaderSize,
-          reinterpret_cast<uintptr_t>(page + gPageSize),
-          [&](mirror::Object* next_obj) {
-            // TODO: Once non-moving space update becomes concurrent, we'll
-            // require fetching the from-space address of 'curr_obj' and then call
-            // visitor on that.
-            if (reinterpret_cast<uint8_t*>(curr_obj) < page) {
-              RefsUpdateVisitor</*kCheckBegin*/true, /*kCheckEnd*/false>
-                      visitor(this, curr_obj, page, page + gPageSize);
-              MemberOffset begin_offset(page - reinterpret_cast<uint8_t*>(curr_obj));
-              // Native roots shouldn't be visited as they are done when this
-              // object's beginning was visited in the preceding page.
-              curr_obj->VisitRefsForCompaction</*kFetchObjSize*/false, /*kVisitNativeRoots*/false>(
-                      visitor, begin_offset, MemberOffset(-1));
-            } else {
-              RefsUpdateVisitor</*kCheckBegin*/false, /*kCheckEnd*/false>
-                      visitor(this, curr_obj, page, page + gPageSize);
-              curr_obj->VisitRefsForCompaction</*kFetchObjSize*/false>(visitor,
-                                                                       MemberOffset(0),
-                                                                       MemberOffset(-1));
-            }
-            curr_obj = next_obj;
-          });
+  uint8_t* from_page = page + from_space_diff;
+  uint8_t* from_page_end = from_page + gPageSize;
+  bitmap->VisitMarkedRange(
+      reinterpret_cast<uintptr_t>(first) + mirror::kObjectHeaderSize,
+      reinterpret_cast<uintptr_t>(page + gPageSize),
+      [&](mirror::Object* next_obj) {
+        mirror::Object* from_obj = reinterpret_cast<mirror::Object*>(
+            reinterpret_cast<uint8_t*>(curr_obj) + from_space_diff);
+        if (reinterpret_cast<uint8_t*>(curr_obj) < page) {
+          RefsUpdateVisitor</*kCheckBegin*/ true, /*kCheckEnd*/ false> visitor(
+              this, from_obj, from_page, from_page_end);
+          MemberOffset begin_offset(page - reinterpret_cast<uint8_t*>(curr_obj));
+          // Native roots shouldn't be visited as they are done when this
+          // object's beginning was visited in the preceding page.
+          from_obj->VisitRefsForCompaction</*kFetchObjSize*/ false, /*kVisitNativeRoots*/ false>(
+              visitor, begin_offset, MemberOffset(-1));
+        } else {
+          RefsUpdateVisitor</*kCheckBegin*/ false, /*kCheckEnd*/ false> visitor(
+              this, from_obj, from_page, from_page_end);
+          from_obj->VisitRefsForCompaction</*kFetchObjSize*/ false>(
+              visitor, MemberOffset(0), MemberOffset(-1));
+        }
+        curr_obj = next_obj;
+      });
 
+  mirror::Object* from_obj =
+      reinterpret_cast<mirror::Object*>(reinterpret_cast<uint8_t*>(curr_obj) + from_space_diff);
   MemberOffset end_offset(page + gPageSize - reinterpret_cast<uint8_t*>(curr_obj));
   if (reinterpret_cast<uint8_t*>(curr_obj) < page) {
-    RefsUpdateVisitor</*kCheckBegin*/true, /*kCheckEnd*/true>
-            visitor(this, curr_obj, page, page + gPageSize);
-    curr_obj->VisitRefsForCompaction</*kFetchObjSize*/false, /*kVisitNativeRoots*/false>(
-            visitor, MemberOffset(page - reinterpret_cast<uint8_t*>(curr_obj)), end_offset);
+    RefsUpdateVisitor</*kCheckBegin*/ true, /*kCheckEnd*/ true> visitor(
+        this, from_obj, from_page, from_page_end);
+    from_obj->VisitRefsForCompaction</*kFetchObjSize*/ false, /*kVisitNativeRoots*/ false>(
+        visitor, MemberOffset(page - reinterpret_cast<uint8_t*>(curr_obj)), end_offset);
   } else {
-    RefsUpdateVisitor</*kCheckBegin*/false, /*kCheckEnd*/true>
-            visitor(this, curr_obj, page, page + gPageSize);
-    curr_obj->VisitRefsForCompaction</*kFetchObjSize*/false>(visitor, MemberOffset(0), end_offset);
+    RefsUpdateVisitor</*kCheckBegin*/ false, /*kCheckEnd*/ true> visitor(
+        this, from_obj, from_page, from_page_end);
+    from_obj->VisitRefsForCompaction</*kFetchObjSize*/ false>(visitor, MemberOffset(0), end_offset);
   }
 }
 
@@ -2223,7 +2340,7 @@ void MarkCompact::UpdateNonMovingSpace() {
     page -= gPageSize;
     // null means there are no objects on the page to update references.
     if (obj != nullptr) {
-      UpdateNonMovingPage(obj, page);
+      UpdateNonMovingPage(obj, page, /*from_space_diff=*/0, non_moving_space_bitmap_);
     }
   }
 }
@@ -2442,7 +2559,7 @@ class MarkCompact::ClassLoaderRootsUpdater : public ClassLoaderVisitor {
  public:
   explicit ClassLoaderRootsUpdater(MarkCompact* collector)
       : collector_(collector),
-        moving_space_begin_(collector->moving_space_begin_),
+        moving_space_begin_(collector->black_dense_end_),
         moving_space_end_(collector->moving_space_end_) {}
 
   void Visit(ObjPtr<mirror::ClassLoader> class_loader) override
@@ -2477,7 +2594,7 @@ class MarkCompact::LinearAllocPageUpdater {
  public:
   explicit LinearAllocPageUpdater(MarkCompact* collector)
       : collector_(collector),
-        moving_space_begin_(collector->moving_space_begin_),
+        moving_space_begin_(collector->black_dense_end_),
         moving_space_end_(collector->moving_space_end_),
         last_page_touched_(false) {}
 
@@ -2658,9 +2775,11 @@ void MarkCompact::CompactionPause() {
   non_moving_space_bitmap_ = non_moving_space_->GetLiveBitmap();
   if (kIsDebugBuild) {
     DCHECK_EQ(thread_running_gc_, Thread::Current());
-    stack_low_addr_ = thread_running_gc_->GetStackEnd();
-    stack_high_addr_ =
-        reinterpret_cast<char*>(stack_low_addr_) + thread_running_gc_->GetStackSize();
+    // TODO(Simulator): Test that this should not operate on the simulated stack when the simulator
+    // supports mark compact.
+    stack_low_addr_ = thread_running_gc_->GetStackEnd<kNativeStackType>();
+    stack_high_addr_ = reinterpret_cast<char*>(stack_low_addr_)
+                       + thread_running_gc_->GetUsableStackSize<kNativeStackType>();
   }
   {
     TimingLogger::ScopedTiming t2("(Paused)UpdateCompactionDataStructures", GetTimings());
@@ -3009,6 +3128,7 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
   DCHECK_LT(page_idx, moving_first_objs_count_ + black_page_count_);
   mirror::Object* first_obj = first_objs_moving_space_[page_idx].AsMirrorPtr();
   if (first_obj == nullptr) {
+    DCHECK_GT(fault_page, post_compact_end_);
     // Install zero-page in the entire remaining tlab to avoid multiple ioctl invocations.
     uint8_t* end = AlignDown(self->GetTlabEnd(), gPageSize);
     if (fault_page < self->GetTlabStart() || fault_page >= end) {
@@ -3056,37 +3176,42 @@ void MarkCompact::ConcurrentlyProcessMovingPage(uint8_t* fault_page,
               raw_state,
               static_cast<uint8_t>(PageState::kMutatorProcessing),
               std::memory_order_acquire)) {
-        if (UNLIKELY(buf == nullptr)) {
-          uint16_t idx = compaction_buffer_counter_.fetch_add(1, std::memory_order_relaxed);
-          // The buffer-map is one page bigger as the first buffer is used by GC-thread.
-          CHECK_LE(idx, kMutatorCompactionBufferCount);
-          buf = compaction_buffers_map_.Begin() + idx * gPageSize;
-          DCHECK(compaction_buffers_map_.HasAddress(buf));
-          self->SetThreadLocalGcBuffer(buf);
-        }
-
-        if (fault_page < post_compact_end_) {
-          // The page has to be compacted.
-          CompactPage(first_obj,
-                      pre_compact_offset_moving_space_[page_idx],
-                      buf,
-                      /*needs_memset_zero=*/true);
+        if (fault_page < black_dense_end_) {
+          UpdateNonMovingPage(first_obj, fault_page, from_space_slide_diff_, moving_space_bitmap_);
+          buf = fault_page + from_space_slide_diff_;
         } else {
-          DCHECK_NE(first_obj, nullptr);
-          DCHECK_GT(pre_compact_offset_moving_space_[page_idx], 0u);
-          uint8_t* pre_compact_page = black_allocations_begin_ + (fault_page - post_compact_end_);
-          uint32_t first_chunk_size = black_alloc_pages_first_chunk_size_[page_idx];
-          mirror::Object* next_page_first_obj = nullptr;
-          if (page_idx + 1 < moving_first_objs_count_ + black_page_count_) {
-            next_page_first_obj = first_objs_moving_space_[page_idx + 1].AsMirrorPtr();
+          if (UNLIKELY(buf == nullptr)) {
+            uint16_t idx = compaction_buffer_counter_.fetch_add(1, std::memory_order_relaxed);
+            // The buffer-map is one page bigger as the first buffer is used by GC-thread.
+            CHECK_LE(idx, kMutatorCompactionBufferCount);
+            buf = compaction_buffers_map_.Begin() + idx * gPageSize;
+            DCHECK(compaction_buffers_map_.HasAddress(buf));
+            self->SetThreadLocalGcBuffer(buf);
+          }
+
+          if (fault_page < post_compact_end_) {
+            // The page has to be compacted.
+            CompactPage(first_obj,
+                        pre_compact_offset_moving_space_[page_idx],
+                        buf,
+                        /*needs_memset_zero=*/true);
+          } else {
+            DCHECK_NE(first_obj, nullptr);
+            DCHECK_GT(pre_compact_offset_moving_space_[page_idx], 0u);
+            uint8_t* pre_compact_page = black_allocations_begin_ + (fault_page - post_compact_end_);
+            uint32_t first_chunk_size = black_alloc_pages_first_chunk_size_[page_idx];
+            mirror::Object* next_page_first_obj = nullptr;
+            if (page_idx + 1 < moving_first_objs_count_ + black_page_count_) {
+              next_page_first_obj = first_objs_moving_space_[page_idx + 1].AsMirrorPtr();
+            }
+            DCHECK(IsAlignedParam(pre_compact_page, gPageSize));
+            SlideBlackPage(first_obj,
+                           next_page_first_obj,
+                           first_chunk_size,
+                           pre_compact_page,
+                           buf,
+                           /*needs_memset_zero=*/true);
           }
-          DCHECK(IsAlignedParam(pre_compact_page, gPageSize));
-          SlideBlackPage(first_obj,
-                         next_page_first_obj,
-                         first_chunk_size,
-                         pre_compact_page,
-                         buf,
-                         /*needs_memset_zero=*/true);
         }
         // Nobody else would simultaneously modify this page's state so an
         // atomic store is sufficient. Use 'release' order to guarantee that
@@ -3890,6 +4015,33 @@ void MarkCompact::UpdateLivenessInfo(mirror::Object* obj, size_t obj_size) {
 
 template <bool kUpdateLiveWords>
 void MarkCompact::ScanObject(mirror::Object* obj) {
+  mirror::Class* klass = obj->GetClass<kVerifyNone, kWithoutReadBarrier>();
+  // TODO(lokeshgidra): Remove the following condition once b/373609505 is fixed.
+  if (UNLIKELY(klass == nullptr)) {
+    // It was seen in ConcurrentCopying GC that after a small wait when we reload
+    // the class pointer, it turns out to be a valid class object. So as a workaround,
+    // we can continue execution and log an error that this happened.
+    for (size_t i = 0; i < 1000; i++) {
+      // Wait for 1ms at a time. Don't wait for more than 1 second in total.
+      usleep(1000);
+      klass = obj->GetClass<kVerifyNone, kWithoutReadBarrier>();
+      if (klass != nullptr) {
+        std::ostringstream oss;
+        klass->DumpClass(oss, mirror::Class::kDumpClassFullDetail);
+        LOG(FATAL_WITHOUT_ABORT) << "klass pointer for obj: " << obj
+                                 << " found to be null first. Reloading after " << i
+                                 << " iterations of 1ms sleep fetched klass: " << oss.str();
+        break;
+      }
+    }
+
+    if (UNLIKELY(klass == nullptr)) {
+      // It must be heap corruption.
+      LOG(FATAL_WITHOUT_ABORT) << "klass pointer for obj: " << obj << " found to be null.";
+    }
+    heap_->GetVerification()->LogHeapCorruption(
+        obj, mirror::Object::ClassOffset(), klass, /*fatal=*/true);
+  }
   // The size of `obj` is used both here (to update `bytes_scanned_`) and in
   // `UpdateLivenessInfo`. As fetching this value can be expensive, do it once
   // here and pass that information to `UpdateLivenessInfo`.
@@ -4005,7 +4157,7 @@ void MarkCompact::VisitRoots(mirror::Object*** roots,
                              size_t count,
                              const RootInfo& info) {
   if (compacting_) {
-    uint8_t* moving_space_begin = moving_space_begin_;
+    uint8_t* moving_space_begin = black_dense_end_;
     uint8_t* moving_space_end = moving_space_end_;
     for (size_t i = 0; i < count; ++i) {
       UpdateRoot(roots[i], moving_space_begin, moving_space_end, info);
@@ -4022,7 +4174,7 @@ void MarkCompact::VisitRoots(mirror::CompressedReference<mirror::Object>** roots
                              const RootInfo& info) {
   // TODO: do we need to check if the root is null or not?
   if (compacting_) {
-    uint8_t* moving_space_begin = moving_space_begin_;
+    uint8_t* moving_space_begin = black_dense_end_;
     uint8_t* moving_space_end = moving_space_end_;
     for (size_t i = 0; i < count; ++i) {
       UpdateRoot(roots[i], moving_space_begin, moving_space_end, info);
@@ -4040,8 +4192,12 @@ mirror::Object* MarkCompact::IsMarked(mirror::Object* obj) {
     if (compacting_) {
       if (is_black) {
         return PostCompactBlackObjAddr(obj);
-      } else if (live_words_bitmap_->Test(obj)) {
-        return PostCompactOldObjAddr(obj);
+      } else if (moving_space_bitmap_->Test(obj)) {
+        if (reinterpret_cast<uint8_t*>(obj) < black_dense_end_) {
+          return obj;
+        } else {
+          return PostCompactOldObjAddr(obj);
+        }
       } else {
         return nullptr;
       }
@@ -4101,11 +4257,15 @@ void MarkCompact::FinishPhase() {
   ZeroAndReleaseMemory(compaction_buffers_map_.Begin(), compaction_buffers_map_.Size());
   info_map_.MadviseDontNeedAndZero();
   live_words_bitmap_->ClearBitmap();
-  // TODO: We can clear this bitmap right before compaction pause. But in that
-  // case we need to ensure that we don't assert on this bitmap afterwards.
-  // Also, we would still need to clear it here again as we may have to use the
-  // bitmap for black-allocations (see UpdateMovingSpaceBlackAllocations()).
-  moving_space_bitmap_->Clear();
+  if (moving_space_begin_ == black_dense_end_) {
+    moving_space_bitmap_->Clear();
+  } else {
+    DCHECK_LT(moving_space_begin_, black_dense_end_);
+    DCHECK_LE(black_dense_end_, moving_space_end_);
+    moving_space_bitmap_->ClearRange(reinterpret_cast<mirror::Object*>(black_dense_end_),
+                                     reinterpret_cast<mirror::Object*>(moving_space_end_));
+  }
+  bump_pointer_space_->SetBlackDenseRegionSize(black_dense_end_ - moving_space_begin_);
 
   if (UNLIKELY(is_zygote && IsValidFd(uffd_))) {
     // This unregisters all ranges as a side-effect.
diff --git a/runtime/gc/collector/mark_compact.h b/runtime/gc/collector/mark_compact.h
index 56a6a17196..dd9fefb2a9 100644
--- a/runtime/gc/collector/mark_compact.h
+++ b/runtime/gc/collector/mark_compact.h
@@ -330,8 +330,10 @@ class MarkCompact final : public GarbageCollector {
   // on the fly.
   void CompactionPause() REQUIRES(Locks::mutator_lock_);
   // Compute offsets (in chunk_info_vec_) and other data structures required
-  // during concurrent compaction.
-  void PrepareForCompaction() REQUIRES_SHARED(Locks::mutator_lock_);
+  // during concurrent compaction. Also determines a black-dense region at the
+  // beginning of the moving space which is not compacted. Returns false if
+  // performing compaction isn't required.
+  bool PrepareForCompaction() REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Copy gPageSize live bytes starting from 'offset' (within the moving space),
   // which must be within 'obj', into the gPageSize sized memory pointed by 'addr'.
@@ -355,22 +357,30 @@ class MarkCompact final : public GarbageCollector {
                                                      CompactionFn func)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Update all the objects in the given non-moving space page. 'first' object
+  // Update all the objects in the given non-moving page. 'first' object
   // could have started in some preceding page.
-  void UpdateNonMovingPage(mirror::Object* first, uint8_t* page)
+  void UpdateNonMovingPage(mirror::Object* first,
+                           uint8_t* page,
+                           ptrdiff_t from_space_diff,
+                           accounting::ContinuousSpaceBitmap* bitmap)
       REQUIRES_SHARED(Locks::mutator_lock_);
   // Update all the references in the non-moving space.
   void UpdateNonMovingSpace() REQUIRES_SHARED(Locks::mutator_lock_);
 
   // For all the pages in non-moving space, find the first object that overlaps
   // with the pages' start address, and store in first_objs_non_moving_space_ array.
-  void InitNonMovingSpaceFirstObjects() REQUIRES_SHARED(Locks::mutator_lock_);
+  size_t InitNonMovingFirstObjects(uintptr_t begin,
+                                   uintptr_t end,
+                                   accounting::ContinuousSpaceBitmap* bitmap,
+                                   ObjReference* first_objs_arr)
+      REQUIRES_SHARED(Locks::mutator_lock_);
   // In addition to the first-objects for every post-compact moving space page,
   // also find offsets within those objects from where the contents should be
   // copied to the page. The offsets are relative to the moving-space's
   // beginning. Store the computed first-object and offset in first_objs_moving_space_
   // and pre_compact_offset_moving_space_ respectively.
-  void InitMovingSpaceFirstObjects(const size_t vec_len) REQUIRES_SHARED(Locks::mutator_lock_);
+  void InitMovingSpaceFirstObjects(size_t vec_len, size_t to_space_page_idx)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Gather the info related to black allocations from bump-pointer space to
   // enable concurrent sliding of these pages.
@@ -731,6 +741,11 @@ class MarkCompact final : public GarbageCollector {
   // clamped.
   uint8_t* const moving_space_begin_;
   uint8_t* moving_space_end_;
+  // Set to moving_space_begin_ if compacting the entire moving space.
+  // Otherwise, set to a page-aligned address such that [moving_space_begin_,
+  // black_dense_end_) is considered to be densely populated with reachable
+  // objects and hence is not compacted.
+  uint8_t* black_dense_end_;
   // moving-space's end pointer at the marking pause. All allocations beyond
   // this will be considered black in the current GC cycle. Aligned up to page
   // size.
diff --git a/runtime/gc/heap.cc b/runtime/gc/heap.cc
index 8f3189f6e5..7ea675d4cf 100644
--- a/runtime/gc/heap.cc
+++ b/runtime/gc/heap.cc
@@ -202,15 +202,13 @@ static constexpr bool kLogAllGCs = false;
 static constexpr size_t kPostForkMaxHeapDurationMS = 2000;
 
 #if defined(__LP64__) || !defined(ADDRESS_SANITIZER)
-// 320 MB (0x14000000) - (default non-moving space capacity).
-// The value is picked to ensure it is aligned to the largest supported PMD
+// 32 MB (0x2000000) is picked to ensure it is aligned to the largest supported PMD
 // size, which is 32mb with a 16k page size on AArch64.
 uint8_t* const Heap::kPreferredAllocSpaceBegin = reinterpret_cast<uint8_t*>(([]() constexpr {
-  constexpr size_t kBegin = 320 * MB - Heap::kDefaultNonMovingSpaceCapacity;
+  constexpr size_t kBegin = 32 * MB;
   constexpr int kMaxPMDSize = (kMaxPageSize / sizeof(uint64_t)) * kMaxPageSize;
   static_assert(IsAligned<kMaxPMDSize>(kBegin),
-                "kPreferredAllocSpaceBegin should be aligned to the maximum "
-                "supported PMD size.");
+                "Moving-space's begin should be aligned to the maximum supported PMD size.");
   return kBegin;
 })());
 #else
@@ -590,7 +588,9 @@ Heap::Heap(size_t initial_size,
     CHECK(non_moving_space_mem_map.IsValid()) << error_str;
     DCHECK(!heap_reservation.IsValid());
     // Try to reserve virtual memory at a lower address if we have a separate non moving space.
-    request_begin = kPreferredAllocSpaceBegin + non_moving_space_capacity;
+    request_begin = non_moving_space_mem_map.Begin() == kPreferredAllocSpaceBegin
+                        ? non_moving_space_mem_map.End()
+                        : kPreferredAllocSpaceBegin;
   }
   // Attempt to create 2 mem maps at or after the requested begin.
   if (foreground_collector_type_ != kCollectorTypeCC) {
@@ -1500,8 +1500,10 @@ std::string Heap::DumpSpaceNameFromAddress(const void* addr) const {
 
 void Heap::ThrowOutOfMemoryError(Thread* self, size_t byte_count, AllocatorType allocator_type) {
   // If we're in a stack overflow, do not create a new exception. It would require running the
-  // constructor, which will of course still be in a stack overflow.
-  if (self->IsHandlingStackOverflow()) {
+  // constructor, which will of course still be in a stack overflow. Note: we only care if the
+  // native stack has overflowed. If the simulated stack overflows, it is still possible that the
+  // native stack has room to create a new exception.
+  if (self->IsHandlingStackOverflow<kNativeStackType>()) {
     self->SetException(
         Runtime::Current()->GetPreAllocatedOutOfMemoryErrorWhenHandlingStackOverflow());
     return;
@@ -2794,9 +2796,12 @@ collector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type,
     // This would likely cause a deadlock if we acted on a suspension request.
     // TODO: We really want to assert that we don't transition to kRunnable.
     ScopedAssertNoThreadSuspension scoped_assert("Performing GC");
-    if (self->IsHandlingStackOverflow()) {
+    if (self->IsHandlingStackOverflow<kNativeStackType>()) {
       // If we are throwing a stack overflow error we probably don't have enough remaining stack
-      // space to run the GC.
+      // space to run the GC. Note: we only care if the native stack has overflowed. If the
+      // simulated stack overflows it is still possible that the native stack has room to run the
+      // GC.
+
       // Count this as a GC in case someone is waiting for it to complete.
       gcs_completed_.fetch_add(1, std::memory_order_release);
       return collector::kGcTypeNone;
@@ -3975,8 +3980,10 @@ class Heap::ConcurrentGCTask : public HeapTask {
 
 static bool CanAddHeapTask(Thread* self) REQUIRES(!Locks::runtime_shutdown_lock_) {
   Runtime* runtime = Runtime::Current();
+  // We only care if the native stack has overflowed. If the simulated stack overflows, it is still
+  // possible that the native stack has room to add a heap task.
   return runtime != nullptr && runtime->IsFinishedStarting() && !runtime->IsShuttingDown(self) &&
-      !self->IsHandlingStackOverflow();
+      !self->IsHandlingStackOverflow<kNativeStackType>();
 }
 
 bool Heap::RequestConcurrentGC(Thread* self,
diff --git a/runtime/gc/heap.h b/runtime/gc/heap.h
index 58a73af74b..20a74a475a 100644
--- a/runtime/gc/heap.h
+++ b/runtime/gc/heap.h
@@ -1455,16 +1455,16 @@ class Heap {
   // matter.
 
   // Collector type of the running GC.
-  volatile CollectorType collector_type_running_ GUARDED_BY(gc_complete_lock_);
+  CollectorType collector_type_running_ GUARDED_BY(gc_complete_lock_);
 
   // Cause of the last running or attempted GC or GC-like action.
-  volatile GcCause last_gc_cause_ GUARDED_BY(gc_complete_lock_);
+  GcCause last_gc_cause_ GUARDED_BY(gc_complete_lock_);
 
   // The thread currently running the GC.
-  volatile Thread* thread_running_gc_ GUARDED_BY(gc_complete_lock_);
+  Thread* thread_running_gc_ GUARDED_BY(gc_complete_lock_);
 
   // Last Gc type we ran. Used by WaitForConcurrentGc to know which Gc was waited on.
-  volatile collector::GcType last_gc_type_ GUARDED_BY(gc_complete_lock_);
+  collector::GcType last_gc_type_ GUARDED_BY(gc_complete_lock_);
   collector::GcType next_gc_type_;
 
   // Maximum size that the heap can reach.
diff --git a/runtime/gc/reference_queue_test.cc b/runtime/gc/reference_queue_test.cc
index 2b5c3fdea7..ce4f8d93b0 100644
--- a/runtime/gc/reference_queue_test.cc
+++ b/runtime/gc/reference_queue_test.cc
@@ -42,8 +42,7 @@ TEST_F(ReferenceQueueTest, EnqueueDequeue) {
   ASSERT_TRUE(queue.IsEmpty());
   ASSERT_EQ(queue.GetLength(), 0U);
   auto ref_class = hs.NewHandle(
-      Runtime::Current()->GetClassLinker()->FindClass(self, "Ljava/lang/ref/WeakReference;",
-                                                      ScopedNullHandle<mirror::ClassLoader>()));
+      FindClass("Ljava/lang/ref/WeakReference;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(ref_class != nullptr);
   auto ref1(hs.NewHandle(ref_class->AllocObject(self)->AsReference()));
   ASSERT_TRUE(ref1 != nullptr);
@@ -77,12 +76,10 @@ TEST_F(ReferenceQueueTest, Dump) {
   queue.Dump(oss);
   LOG(INFO) << oss.str();
   auto weak_ref_class = hs.NewHandle(
-      Runtime::Current()->GetClassLinker()->FindClass(self, "Ljava/lang/ref/WeakReference;",
-                                                      ScopedNullHandle<mirror::ClassLoader>()));
+      FindClass("Ljava/lang/ref/WeakReference;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(weak_ref_class != nullptr);
   auto finalizer_ref_class = hs.NewHandle(
-      Runtime::Current()->GetClassLinker()->FindClass(self, "Ljava/lang/ref/FinalizerReference;",
-                                                      ScopedNullHandle<mirror::ClassLoader>()));
+      FindClass("Ljava/lang/ref/FinalizerReference;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(finalizer_ref_class != nullptr);
   auto ref1(hs.NewHandle(weak_ref_class->AllocObject(self)->AsReference()));
   ASSERT_TRUE(ref1 != nullptr);
diff --git a/runtime/gc/space/bump_pointer_space-walk-inl.h b/runtime/gc/space/bump_pointer_space-walk-inl.h
index 86af0451de..26402e8d3d 100644
--- a/runtime/gc/space/bump_pointer_space-walk-inl.h
+++ b/runtime/gc/space/bump_pointer_space-walk-inl.h
@@ -34,6 +34,7 @@ inline void BumpPointerSpace::Walk(Visitor&& visitor) {
   uint8_t* pos = Begin();
   uint8_t* end = End();
   uint8_t* main_end = pos;
+  size_t black_dense_size;
   std::unique_ptr<std::vector<size_t>> block_sizes_copy;
   // Internal indirection w/ NO_THREAD_SAFETY_ANALYSIS. Optimally, we'd like to have an annotation
   // like
@@ -64,6 +65,30 @@ inline void BumpPointerSpace::Walk(Visitor&& visitor) {
     } else {
       block_sizes_copy.reset(new std::vector<size_t>(block_sizes_.begin(), block_sizes_.end()));
     }
+
+    black_dense_size = black_dense_region_size_;
+  }
+
+  // black_dense_region_size_ will be non-zero only in case of moving-space of CMC GC.
+  if (black_dense_size > 0) {
+    // Objects are not packed in this case, and therefore the bitmap is needed
+    // to walk this part of the space.
+    // Remember the last object visited using bitmap to be able to fetch its size.
+    mirror::Object* last_obj = nullptr;
+    auto return_obj_visit = [&](mirror::Object* obj) NO_THREAD_SAFETY_ANALYSIS {
+      visitor(obj);
+      last_obj = obj;
+    };
+    GetMarkBitmap()->VisitMarkedRange(reinterpret_cast<uintptr_t>(pos),
+                                      reinterpret_cast<uintptr_t>(pos + black_dense_size),
+                                      return_obj_visit);
+    pos += black_dense_size;
+    if (last_obj != nullptr) {
+      // If the last object visited using bitmap was large enough to go past the
+      // black-dense region, then we need to adjust for that to be able to visit
+      // objects one after the other below.
+      pos = std::max(pos, reinterpret_cast<uint8_t*>(GetNextObject(last_obj)));
+    }
   }
   // Walk all of the objects in the main block first.
   while (pos < main_end) {
@@ -81,7 +106,23 @@ inline void BumpPointerSpace::Walk(Visitor&& visitor) {
   }
   // Walk the other blocks (currently only TLABs).
   if (block_sizes_copy != nullptr) {
-    for (size_t block_size : *block_sizes_copy) {
+    size_t iter = 0;
+    size_t num_blks = block_sizes_copy->size();
+    // Skip blocks which are already visited above as part of black-dense region.
+    for (uint8_t* ptr = main_end; iter < num_blks; iter++) {
+      size_t block_size = (*block_sizes_copy)[iter];
+      ptr += block_size;
+      if (ptr > pos) {
+        // Adjust block-size in case 'pos' is in the middle of the block.
+        if (static_cast<ssize_t>(block_size) > ptr - pos) {
+          (*block_sizes_copy)[iter] = ptr - pos;
+        }
+        break;
+      }
+    }
+
+    for (; iter < num_blks; iter++) {
+      size_t block_size = (*block_sizes_copy)[iter];
       mirror::Object* obj = reinterpret_cast<mirror::Object*>(pos);
       const mirror::Object* end_obj = reinterpret_cast<const mirror::Object*>(pos + block_size);
       CHECK_LE(reinterpret_cast<const uint8_t*>(end_obj), End());
diff --git a/runtime/gc/space/bump_pointer_space.cc b/runtime/gc/space/bump_pointer_space.cc
index 17e08357e8..ad9c68da3e 100644
--- a/runtime/gc/space/bump_pointer_space.cc
+++ b/runtime/gc/space/bump_pointer_space.cc
@@ -303,6 +303,12 @@ void BumpPointerSpace::SetBlockSizes(Thread* self,
   end_.store(Begin() + size, std::memory_order_relaxed);
 }
 
+void BumpPointerSpace::SetBlackDenseRegionSize(size_t size) {
+  DCHECK_ALIGNED_PARAM(size, gPageSize);
+  MutexLock mu(Thread::Current(), lock_);
+  black_dense_region_size_ = size;
+}
+
 }  // namespace space
 }  // namespace gc
 }  // namespace art
diff --git a/runtime/gc/space/bump_pointer_space.h b/runtime/gc/space/bump_pointer_space.h
index 77beb476e6..7dad977c44 100644
--- a/runtime/gc/space/bump_pointer_space.h
+++ b/runtime/gc/space/bump_pointer_space.h
@@ -193,6 +193,9 @@ class EXPORT BumpPointerSpace final : public ContinuousMemMapAllocSpace {
   // The compaction algorithm should ideally compact all objects into the main
   // block, thereby enabling erasing corresponding entries from here.
   std::deque<size_t> block_sizes_ GUARDED_BY(lock_);
+  // Size of the black-dense region that is to be walked using mark-bitmap and
+  // not object-by-object.
+  size_t black_dense_region_size_ GUARDED_BY(lock_) = 0;
 
  private:
   // Return the object which comes after obj, while ensuring alignment.
@@ -215,6 +218,8 @@ class EXPORT BumpPointerSpace final : public ContinuousMemMapAllocSpace {
   // mutators are suspended so that upcoming TLAB allocations start with a new
   // page. Adjust's heap's bytes_allocated accordingly. Returns the aligned end.
   uint8_t* AlignEnd(Thread* self, size_t alignment, Heap* heap) REQUIRES(Locks::mutator_lock_);
+  // Called only by CMC GC at the end of GC.
+  void SetBlackDenseRegionSize(size_t size) REQUIRES(!lock_);
 
   friend class collector::MarkSweep;
   friend class collector::MarkCompact;
diff --git a/runtime/gc/space/image_space.cc b/runtime/gc/space/image_space.cc
index b970b12978..18f4c4205a 100644
--- a/runtime/gc/space/image_space.cc
+++ b/runtime/gc/space/image_space.cc
@@ -65,6 +65,7 @@
 #include "oat/oat_file.h"
 #include "profile/profile_compilation_info.h"
 #include "runtime.h"
+#include "runtime_globals.h"
 #include "space-inl.h"
 
 namespace art HIDDEN {
@@ -561,9 +562,14 @@ class ImageSpace::Loader {
                                                   const OatFile* oat_file,
                                                   ArrayRef<ImageSpace* const> boot_image_spaces,
                                                   /*out*/std::string* error_msg)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
+        REQUIRES(!Locks::mutator_lock_) {
     TimingLogger logger(__PRETTY_FUNCTION__, /*precise=*/ true, VLOG_IS_ON(image));
 
+    if (gPageSize != kMinPageSize) {
+      *error_msg = "Loading app image is only supported on devices with 4K page size";
+      return nullptr;
+    }
+
     std::unique_ptr<ImageSpace> space = Init(image_filename,
                                              image_location,
                                              &logger,
@@ -633,6 +639,7 @@ class ImageSpace::Loader {
         ArrayRef<ImageSpace* const> old_spaces =
             boot_image_spaces.SubArray(/*pos=*/ boot_image_space_dependencies);
         SafeMap<mirror::String*, mirror::String*> intern_remap;
+        ScopedObjectAccess soa(Thread::Current());
         RemoveInternTableDuplicates(old_spaces, space.get(), &intern_remap);
         if (!intern_remap.empty()) {
           RemapInternedStringDuplicates(intern_remap, space.get());
@@ -659,8 +666,7 @@ class ImageSpace::Loader {
                                           const char* image_location,
                                           TimingLogger* logger,
                                           /*inout*/MemMap* image_reservation,
-                                          /*out*/std::string* error_msg)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
+                                          /*out*/std::string* error_msg) {
     CHECK(image_filename != nullptr);
     CHECK(image_location != nullptr);
 
@@ -690,8 +696,7 @@ class ImageSpace::Loader {
                                           bool allow_direct_mapping,
                                           TimingLogger* logger,
                                           /*inout*/MemMap* image_reservation,
-                                          /*out*/std::string* error_msg)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
+                                          /*out*/std::string* error_msg) {
     CHECK(image_filename != nullptr);
     CHECK(image_location != nullptr);
 
@@ -990,8 +995,7 @@ class ImageSpace::Loader {
                               bool allow_direct_mapping,
                               TimingLogger* logger,
                               /*inout*/MemMap* image_reservation,
-                              /*out*/std::string* error_msg)
-        REQUIRES_SHARED(Locks::mutator_lock_) {
+                              /*out*/std::string* error_msg) {
     TimingLogger::ScopedTiming timing("MapImageFile", logger);
 
     // The runtime might not be available at this point if we're running dex2oat or oatdump, in
@@ -1085,8 +1089,6 @@ class ImageSpace::Loader {
         }
         if (use_parallel) {
           ScopedTrace trace("Waiting for workers");
-          // Go to native since we don't want to suspend while holding the mutator lock.
-          ScopedThreadSuspension sts(Thread::Current(), ThreadState::kNative);
           pool->Wait(self, true, false);
         }
         const uint64_t time = NanoTime() - start;
@@ -1285,7 +1287,7 @@ class ImageSpace::Loader {
       // Nothing to fix up.
       return true;
     }
-    ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
+
     // TODO: Assert that the app image does not contain any Method, Constructor,
     // FieldVarHandle or StaticFieldVarHandle. These require extra relocation
     // for the `ArtMethod*` and `ArtField*` pointers they contain.
@@ -1307,7 +1309,10 @@ class ImageSpace::Loader {
                                                         image_header->GetImageSize()));
       {
         TimingLogger::ScopedTiming timing("Fixup classes", &logger);
-        ObjPtr<mirror::Class> class_class = [&]() NO_THREAD_SAFETY_ANALYSIS {
+        const auto& class_table_section = image_header->GetClassTableSection();
+        if (class_table_section.Size() > 0u) {
+          ScopedObjectAccess soa(Thread::Current());
+          ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
           ObjPtr<mirror::ObjectArray<mirror::Object>> image_roots = app_image_objects.ToDest(
               image_header->GetImageRoots<kWithoutReadBarrier>().Ptr());
           int32_t class_roots_index = enum_cast<int32_t>(ImageHeader::kClassRoots);
@@ -1316,11 +1321,8 @@ class ImageSpace::Loader {
               ObjPtr<mirror::ObjectArray<mirror::Class>>::DownCast(boot_image.ToDest(
                   image_roots->GetWithoutChecks<kVerifyNone,
                                                 kWithoutReadBarrier>(class_roots_index).Ptr()));
-          return GetClassRoot<mirror::Class, kWithoutReadBarrier>(class_roots);
-        }();
-        const auto& class_table_section = image_header->GetClassTableSection();
-        if (class_table_section.Size() > 0u) {
-          ScopedObjectAccess soa(Thread::Current());
+          ObjPtr<mirror::Class> class_class =
+              GetClassRoot<mirror::Class, kWithoutReadBarrier>(class_roots);
           ClassTableVisitor class_table_visitor(forward_object);
           size_t read_count = 0u;
           const uint8_t* data = target_base + class_table_section.Offset();
@@ -1370,6 +1372,7 @@ class ImageSpace::Loader {
       // probably not required).
       TimingLogger::ScopedTiming timing("Fixup objects", &logger);
       ScopedObjectAccess soa(Thread::Current());
+      ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
       // Need to update the image to be at the target base.
       uintptr_t objects_begin = reinterpret_cast<uintptr_t>(target_base + objects_section.Offset());
       uintptr_t objects_end = reinterpret_cast<uintptr_t>(target_base + objects_section.End());
@@ -1395,6 +1398,7 @@ class ImageSpace::Loader {
     {
       // Only touches objects in the app image, no need for mutator lock.
       TimingLogger::ScopedTiming timing("Fixup methods", &logger);
+      ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
       image_header->VisitPackedArtMethods([&](ArtMethod& method) NO_THREAD_SAFETY_ANALYSIS {
         // TODO: Consider a separate visitor for runtime vs normal methods.
         if (UNLIKELY(method.IsRuntimeMethod())) {
@@ -1426,6 +1430,7 @@ class ImageSpace::Loader {
       {
         // Only touches objects in the app image, no need for mutator lock.
         TimingLogger::ScopedTiming timing("Fixup fields", &logger);
+        ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
         image_header->VisitPackedArtFields([&](ArtField& field) NO_THREAD_SAFETY_ANALYSIS {
           patch_object_visitor.template PatchGcRoot</*kMayBeNull=*/ false>(
               &field.DeclaringClassRoot());
@@ -1433,10 +1438,12 @@ class ImageSpace::Loader {
       }
       {
         TimingLogger::ScopedTiming timing("Fixup imt", &logger);
+        ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
         image_header->VisitPackedImTables(forward_metadata, target_base, kPointerSize);
       }
       {
         TimingLogger::ScopedTiming timing("Fixup conflict tables", &logger);
+        ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
         image_header->VisitPackedImtConflictTables(forward_metadata, target_base, kPointerSize);
       }
       // Fix up the intern table.
@@ -1444,6 +1451,7 @@ class ImageSpace::Loader {
       if (intern_table_section.Size() > 0u) {
         TimingLogger::ScopedTiming timing("Fixup intern table", &logger);
         ScopedObjectAccess soa(Thread::Current());
+        ScopedDebugDisallowReadBarriers sddrb(Thread::Current());
         // Fixup the pointers in the newly written intern table to contain image addresses.
         InternTable temp_intern_table;
         // Note that we require that ReadFromMemory does not make an internal copy of the elements
@@ -3241,6 +3249,11 @@ bool ImageSpace::BootImageLoader::LoadFromSystem(
     /*out*/std::string* error_msg) {
   TimingLogger logger(__PRETTY_FUNCTION__, /*precise=*/ true, VLOG_IS_ON(image));
 
+  if (gPageSize != kMinPageSize) {
+    *error_msg = "Loading boot image is only supported on devices with 4K page size";
+    return false;
+  }
+
   BootImageLayout layout(image_locations_,
                          boot_class_path_,
                          boot_class_path_locations_,
diff --git a/runtime/gc/space/image_space.h b/runtime/gc/space/image_space.h
index 3b59ffd758..266b1d5925 100644
--- a/runtime/gc/space/image_space.h
+++ b/runtime/gc/space/image_space.h
@@ -155,13 +155,13 @@ class ImageSpace : public MemMapSpace {
   EXPORT static std::unique_ptr<ImageSpace> CreateFromAppImage(const char* image,
                                                                const OatFile* oat_file,
                                                                std::string* error_msg)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+      REQUIRES(!Locks::mutator_lock_);
   // Try to open an existing app image space for an the oat file and given boot image spaces.
   static std::unique_ptr<ImageSpace> CreateFromAppImage(
       const char* image,
       const OatFile* oat_file,
       ArrayRef<ImageSpace* const> boot_image_spaces,
-      std::string* error_msg) REQUIRES_SHARED(Locks::mutator_lock_);
+      std::string* error_msg) REQUIRES(!Locks::mutator_lock_);
 
   // Checks whether we have a primary boot image on the disk.
   static bool IsBootClassPathOnDisk(InstructionSet image_isa);
diff --git a/runtime/gc/space/image_space_test.cc b/runtime/gc/space/image_space_test.cc
index 2979544d90..88f4135d8d 100644
--- a/runtime/gc/space/image_space_test.cc
+++ b/runtime/gc/space/image_space_test.cc
@@ -209,11 +209,15 @@ TEST_F(ImageSpaceTest, StringDeduplication) {
   ASSERT_TRUE(odex_file != nullptr) << error_msg;
   std::vector<ImageSpace*> non_owning_boot_image_spaces =
       MakeNonOwningPointerVector(boot_image_spaces);
-  std::unique_ptr<ImageSpace> app_image_space =
-      ImageSpace::CreateFromAppImage(app_image_name.c_str(),
-                                     odex_file.get(),
-                                     ArrayRef<ImageSpace* const>(non_owning_boot_image_spaces),
-                                     &error_msg);
+  std::unique_ptr<ImageSpace> app_image_space;
+  {
+    ScopedThreadSuspension sts(soa.Self(), ThreadState::kNative);
+    app_image_space = ImageSpace::CreateFromAppImage(
+        app_image_name.c_str(),
+        odex_file.get(),
+        ArrayRef<ImageSpace* const>(non_owning_boot_image_spaces),
+        &error_msg);
+  }
   ASSERT_TRUE(app_image_space != nullptr) << error_msg;
 
   // The string in the app image should be replaced and removed from interned string section.
diff --git a/runtime/handle.h b/runtime/handle.h
index 318f86375b..60a8bb4cb1 100644
--- a/runtime/handle.h
+++ b/runtime/handle.h
@@ -48,10 +48,10 @@ template<typename T> using ConstHandleArrayIter = ArrayIter<T, const Handle<Obje
 template<class T>
 class Handle : public ValueObject {
  public:
-  Handle() : reference_(nullptr) {
+  constexpr Handle() : reference_(nullptr) {
   }
 
-  ALWAYS_INLINE Handle(const Handle<T>& handle) = default;
+  constexpr ALWAYS_INLINE Handle(const Handle<T>& handle) = default;
 
   ALWAYS_INLINE Handle<T>& operator=(const Handle<T>& handle) = default;
 
@@ -93,11 +93,11 @@ class Handle : public ValueObject {
     return reference_->IsNull();
   }
 
-  ALWAYS_INLINE StackReference<mirror::Object>* GetReference() {
+  constexpr ALWAYS_INLINE StackReference<mirror::Object>* GetReference() {
     return reference_;
   }
 
-  ALWAYS_INLINE const StackReference<mirror::Object>* GetReference() const {
+  constexpr ALWAYS_INLINE const StackReference<mirror::Object>* GetReference() const {
     return reference_;
   }
 
diff --git a/runtime/hidden_api.h b/runtime/hidden_api.h
index 43883ef4e1..21cd04e2dc 100644
--- a/runtime/hidden_api.h
+++ b/runtime/hidden_api.h
@@ -292,7 +292,6 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
       case Intrinsics::kSystemArrayCopyInt:
       case Intrinsics::kStringGetCharsNoCheck:
       case Intrinsics::kReferenceGetReferent:
-      case Intrinsics::kReferenceRefersTo:
       case Intrinsics::kMemoryPeekByte:
       case Intrinsics::kMemoryPokeByte:
       case Intrinsics::kCRC32Update:
@@ -358,11 +357,13 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
       case Intrinsics::kJdkUnsafeStoreFence:
       case Intrinsics::kJdkUnsafeFullFence:
       case Intrinsics::kJdkUnsafeGet:
+      case Intrinsics::kJdkUnsafeGetAbsolute:
       case Intrinsics::kJdkUnsafeGetLong:
       case Intrinsics::kJdkUnsafeGetByte:
       case Intrinsics::kJdkUnsafeGetReference:
       case Intrinsics::kJdkUnsafePutLong:
       case Intrinsics::kJdkUnsafePut:
+      case Intrinsics::kJdkUnsafePutAbsolute:
       case Intrinsics::kJdkUnsafePutReference:
       case Intrinsics::kJdkUnsafePutByte:
         return 0u;
@@ -380,11 +381,13 @@ ALWAYS_INLINE inline uint32_t GetRuntimeFlags(ArtMethod* method)
       case Intrinsics::kFP16Rint:
       case Intrinsics::kUnsafeArrayBaseOffset:
       case Intrinsics::kUnsafeGet:
+      case Intrinsics::kUnsafeGetAbsolute:
       case Intrinsics::kUnsafeGetLong:
       case Intrinsics::kUnsafeGetByte:
       case Intrinsics::kUnsafeGetObject:
       case Intrinsics::kUnsafePutLong:
       case Intrinsics::kUnsafePut:
+      case Intrinsics::kUnsafePutAbsolute:
       case Intrinsics::kUnsafePutObject:
       case Intrinsics::kUnsafePutByte:
         return kAccCorePlatformApi;
diff --git a/runtime/hidden_api_test.cc b/runtime/hidden_api_test.cc
index eff54bd861..b16c42f1a7 100644
--- a/runtime/hidden_api_test.cc
+++ b/runtime/hidden_api_test.cc
@@ -626,8 +626,8 @@ TEST_F(HiddenApiTest, CheckMemberSignatureForProxyClass) {
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader_)));
 
   // Find interface we will create a proxy for.
-  Handle<mirror::Class> h_iface(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "Lmypackage/packagea/Interface;", class_loader)));
+  Handle<mirror::Class> h_iface =
+      hs.NewHandle(FindClass("Lmypackage/packagea/Interface;", class_loader));
   ASSERT_TRUE(h_iface != nullptr);
 
   // Create the proxy class.
diff --git a/runtime/imtable_test.cc b/runtime/imtable_test.cc
index 9fed220f44..30c5c0b611 100644
--- a/runtime/imtable_test.cc
+++ b/runtime/imtable_test.cc
@@ -51,8 +51,7 @@ class ImTableTest : public CommonRuntimeTest {
     // A.
     h_class_loader.Assign(
         ObjPtr<mirror::ClassLoader>::DownCast(self->DecodeJObject(jclass_loader_a)));
-    Handle<mirror::Class> h_class_a(
-          hs.NewHandle(class_linker->FindClass(self, class_name.c_str(), h_class_loader)));
+    Handle<mirror::Class> h_class_a = hs.NewHandle(FindClass(class_name.c_str(), h_class_loader));
     if (h_class_a == nullptr) {
       LOG(ERROR) << self->GetException()->Dump();
       CHECK(false) << "h_class_a == nullptr";
@@ -61,8 +60,7 @@ class ImTableTest : public CommonRuntimeTest {
     // B.
     h_class_loader.Assign(
         ObjPtr<mirror::ClassLoader>::DownCast(self->DecodeJObject(jclass_loader_b)));
-    Handle<mirror::Class> h_class_b(
-          hs.NewHandle(class_linker->FindClass(self, class_name.c_str(), h_class_loader)));
+    Handle<mirror::Class> h_class_b = hs.NewHandle(FindClass(class_name.c_str(), h_class_loader));
     if (h_class_b == nullptr) {
       LOG(ERROR) << self->GetException()->Dump();
       CHECK(false) << "h_class_b == nullptr";
diff --git a/runtime/instrumentation.cc b/runtime/instrumentation.cc
index ce8c35bfac..ce740da1a8 100644
--- a/runtime/instrumentation.cc
+++ b/runtime/instrumentation.cc
@@ -34,6 +34,7 @@
 #include "dex/dex_instruction-inl.h"
 #include "entrypoints/quick/quick_alloc_entrypoints.h"
 #include "entrypoints/quick/quick_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "gc_root-inl.h"
 #include "interpreter/interpreter.h"
@@ -55,7 +56,6 @@
 #include "thread_list.h"
 
 namespace art HIDDEN {
-extern "C" void artDeliverPendingExceptionFromCode(Thread* self);
 
 namespace instrumentation {
 
@@ -266,7 +266,7 @@ static void UpdateEntryPoints(ArtMethod* method, const void* new_code)
     jit::Jit* jit = Runtime::Current()->GetJit();
     if (jit != nullptr && jit->GetCodeCache()->ContainsPc(new_code)) {
       // Ensure we always have the thumb entrypoint for JIT on arm32.
-      if (kRuntimeISA == InstructionSet::kArm) {
+      if (kRuntimeQuickCodeISA == InstructionSet::kArm) {
         CHECK_EQ(reinterpret_cast<uintptr_t>(new_code) & 1, 1u);
       }
     }
diff --git a/runtime/instrumentation_test.cc b/runtime/instrumentation_test.cc
index 664d3577be..e9fb0eafd2 100644
--- a/runtime/instrumentation_test.cc
+++ b/runtime/instrumentation_test.cc
@@ -491,7 +491,7 @@ TEST_F(InstrumentationTest, MethodEntryEvent) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtMethod* method =
       klass->FindClassMethod("returnReference", "()Ljava/lang/Object;", kRuntimePointerSize);
@@ -512,7 +512,7 @@ TEST_F(InstrumentationTest, MethodExitObjectEvent) {
   StackHandleScope<1> hs(soa.Self());
   MutableHandle<mirror::ClassLoader> loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtMethod* method =
       klass->FindClassMethod("returnReference", "()Ljava/lang/Object;", kRuntimePointerSize);
@@ -532,7 +532,7 @@ TEST_F(InstrumentationTest, MethodExitPrimEvent) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtMethod* method = klass->FindClassMethod("returnPrimitive", "()I", kRuntimePointerSize);
   ASSERT_TRUE(method != nullptr);
@@ -567,7 +567,7 @@ TEST_F(InstrumentationTest, FieldWriteObjectEvent) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtField* field = klass->FindDeclaredStaticField("referenceField", "Ljava/lang/Object;");
   ASSERT_TRUE(field != nullptr);
@@ -585,7 +585,7 @@ TEST_F(InstrumentationTest, FieldWritePrimEvent) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtField* field = klass->FindDeclaredStaticField("primitiveField", "I");
   ASSERT_TRUE(field != nullptr);
@@ -616,7 +616,7 @@ TEST_F(InstrumentationTest, DeoptimizeDirectMethod) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtMethod* method_to_deoptimize =
       klass->FindClassMethod("instanceMethod", "()V", kRuntimePointerSize);
@@ -666,7 +666,7 @@ TEST_F(InstrumentationTest, MixedDeoptimization) {
   ClassLinker* class_linker = runtime->GetClassLinker();
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> klass = class_linker->FindClass(soa.Self(), "LInstrumentation;", loader);
+  ObjPtr<mirror::Class> klass = FindClass("LInstrumentation;", loader);
   ASSERT_TRUE(klass != nullptr);
   ArtMethod* method_to_deoptimize =
       klass->FindClassMethod("instanceMethod", "()V", kRuntimePointerSize);
diff --git a/runtime/interpreter/interpreter.cc b/runtime/interpreter/interpreter.cc
index eeeb300a92..2665d00c8b 100644
--- a/runtime/interpreter/interpreter.cc
+++ b/runtime/interpreter/interpreter.cc
@@ -235,14 +235,13 @@ NO_STACK_PROTECTOR
 static JValue ExecuteSwitch(Thread* self,
                             const CodeItemDataAccessor& accessor,
                             ShadowFrame& shadow_frame,
-                            JValue result_register,
-                            bool interpret_one_instruction) REQUIRES_SHARED(Locks::mutator_lock_) {
+                            JValue result_register) REQUIRES_SHARED(Locks::mutator_lock_) {
   Runtime* runtime = Runtime::Current();
   auto switch_impl_cpp = runtime->IsActiveTransaction()
       ? runtime->GetClassLinker()->GetTransactionalInterpreter()
       : reinterpret_cast<const void*>(&ExecuteSwitchImplCpp</*transaction_active=*/ false>);
   return ExecuteSwitchImpl(
-      self, accessor, shadow_frame, result_register, interpret_one_instruction, switch_impl_cpp);
+      self, accessor, shadow_frame, result_register, switch_impl_cpp);
 }
 
 NO_STACK_PROTECTOR
@@ -339,8 +338,7 @@ static inline JValue Execute(
 
   VLOG(interpreter) << "Interpreting " << method->PrettyMethod();
 
-  return ExecuteSwitch(
-      self, accessor, shadow_frame, result_register, /*interpret_one_instruction=*/ false);
+  return ExecuteSwitch(self, accessor, shadow_frame, result_register);
 }
 
 void EnterInterpreterFromInvoke(Thread* self,
@@ -352,7 +350,7 @@ void EnterInterpreterFromInvoke(Thread* self,
   DCHECK_EQ(self, Thread::Current());
   bool implicit_check = Runtime::Current()->GetImplicitStackOverflowChecks();
   if (UNLIKELY(__builtin_frame_address(0) < self->GetStackEndForInterpreter(implicit_check))) {
-    ThrowStackOverflowError(self);
+    ThrowStackOverflowError<kNativeStackType>(self);
     return;
   }
 
@@ -570,7 +568,7 @@ JValue EnterInterpreterFromEntryPoint(Thread* self, const CodeItemDataAccessor&
   DCHECK_EQ(self, Thread::Current());
   bool implicit_check = Runtime::Current()->GetImplicitStackOverflowChecks();
   if (UNLIKELY(__builtin_frame_address(0) < self->GetStackEndForInterpreter(implicit_check))) {
-    ThrowStackOverflowError(self);
+    ThrowStackOverflowError<kNativeStackType>(self);
     return JValue();
   }
 
@@ -588,7 +586,7 @@ void ArtInterpreterToInterpreterBridge(Thread* self,
                                        JValue* result) {
   bool implicit_check = Runtime::Current()->GetImplicitStackOverflowChecks();
   if (UNLIKELY(__builtin_frame_address(0) < self->GetStackEndForInterpreter(implicit_check))) {
-    ThrowStackOverflowError(self);
+    ThrowStackOverflowError<kNativeStackType>(self);
     return;
   }
 
diff --git a/runtime/interpreter/interpreter_common.cc b/runtime/interpreter/interpreter_common.cc
index f530fa245d..5024b16ba2 100644
--- a/runtime/interpreter/interpreter_common.cc
+++ b/runtime/interpreter/interpreter_common.cc
@@ -62,7 +62,7 @@ bool CheckStackOverflow(Thread* self, size_t frame_size)
   bool implicit_check = Runtime::Current()->GetImplicitStackOverflowChecks();
   uint8_t* stack_end = self->GetStackEndForInterpreter(implicit_check);
   if (UNLIKELY(__builtin_frame_address(0) < stack_end + frame_size)) {
-    ThrowStackOverflowError(self);
+    ThrowStackOverflowError<kNativeStackType>(self);
     return false;
   }
   return true;
@@ -189,14 +189,7 @@ bool MoveToExceptionHandler(Thread* self,
   } else {
     shadow_frame.SetDexPC(found_dex_pc);
     if (!skip_listeners && instrumentation->HasExceptionHandledListeners()) {
-      self->ClearException();
-      instrumentation->ExceptionHandledEvent(self, exception.Get());
-      if (UNLIKELY(self->IsExceptionPending())) {
-        // Exception handled event threw an exception. Try to find the handler for this one.
-        return MoveToExceptionHandler(self, shadow_frame, skip_listeners, skip_throw_listener);
-      } else if (!clear_exception) {
-        self->SetException(exception.Get());
-      }
+      shadow_frame.SetNotifyExceptionHandledEvent(/*enable=*/ true);
     } else if (clear_exception) {
       self->ClearException();
     }
@@ -520,8 +513,8 @@ bool DoInvokePolymorphic(Thread* self,
   const int invoke_method_idx = inst->VRegB();
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
   ArtMethod* invoke_method =
-      class_linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-          self, invoke_method_idx, shadow_frame.GetMethod(), kPolymorphic);
+      class_linker->ResolveMethodWithChecks(
+          invoke_method_idx, shadow_frame.GetMethod(), kPolymorphic);
 
   // Ensure intrinsic identifiers are initialized.
   DCHECK(invoke_method->IsIntrinsic());
diff --git a/runtime/interpreter/interpreter_switch_impl-inl.h b/runtime/interpreter/interpreter_switch_impl-inl.h
index 1ebac52c1e..7915a10094 100644
--- a/runtime/interpreter/interpreter_switch_impl-inl.h
+++ b/runtime/interpreter/interpreter_switch_impl-inl.h
@@ -379,6 +379,26 @@ class InstructionHandler {
         return false;
       }
     }
+
+    // Call any exception handled event handlers after the dex pc move event.
+    // The order is important to see a consistent behaviour in the debuggers.
+    // See b/333446719 for more discussion.
+    if (UNLIKELY(shadow_frame_.GetNotifyExceptionHandledEvent())) {
+      shadow_frame_.SetNotifyExceptionHandledEvent(/*enable=*/ false);
+      bool is_move_exception = (inst_->Opcode(inst_data_) == Instruction::MOVE_EXCEPTION);
+
+      if (!InstrumentationHandler::ExceptionHandledEvent(
+              Self(), is_move_exception, Instrumentation())) {
+        DCHECK(Self()->IsExceptionPending());
+        // TODO(375373721): We need to set SetSkipNextExceptionEvent here since the exception was
+        // thrown by an instrumentation handler.
+        return false;  // Pending exception.
+      }
+
+      if (!CheckForceReturn()) {
+        return false;
+      }
+    }
     return true;
   }
 
@@ -2035,7 +2055,6 @@ void ExecuteSwitchImplCpp(SwitchImplContext* ctx) {
   DCHECK(!shadow_frame.GetForceRetryInstruction())
       << "Entered interpreter from invoke without retry instruction being handled!";
 
-  bool const interpret_one_instruction = ctx->interpret_one_instruction;
   while (true) {
     const Instruction* const inst = next;
     dex_pc = inst->GetDexPc(insns);
@@ -2054,7 +2073,7 @@ void ExecuteSwitchImplCpp(SwitchImplContext* ctx) {
           next = inst->RelativeAt(Instruction::SizeInCodeUnits(Instruction::FORMAT));             \
           success = OP_##OPCODE_NAME<transaction_active>(                                         \
               ctx, instrumentation, self, shadow_frame, dex_pc, inst, inst_data, next, exit);     \
-          if (success && LIKELY(!interpret_one_instruction)) {                                    \
+          if (success) {                                                                          \
             continue;                                                                             \
           }                                                                                       \
           break;                                                                                  \
@@ -2076,11 +2095,6 @@ void ExecuteSwitchImplCpp(SwitchImplContext* ctx) {
       }
       // Continue execution in the catch block.
     }
-    if (interpret_one_instruction) {
-      shadow_frame.SetDexPC(next->GetDexPc(insns));  // Record where we stopped.
-      ctx->result = ctx->result_register;
-      return;
-    }
   }
 }  // NOLINT(readability/fn_size)
 
diff --git a/runtime/interpreter/interpreter_switch_impl.h b/runtime/interpreter/interpreter_switch_impl.h
index 0b5a86f22d..9e5f8f5f7d 100644
--- a/runtime/interpreter/interpreter_switch_impl.h
+++ b/runtime/interpreter/interpreter_switch_impl.h
@@ -40,7 +40,6 @@ struct SwitchImplContext {
   const CodeItemDataAccessor& accessor;
   ShadowFrame& shadow_frame;
   JValue& result_register;
-  bool interpret_one_instruction;
   JValue result;
 };
 
@@ -60,7 +59,6 @@ ALWAYS_INLINE inline JValue ExecuteSwitchImpl(Thread* self,
                                               const CodeItemDataAccessor& accessor,
                                               ShadowFrame& shadow_frame,
                                               JValue result_register,
-                                              bool interpret_one_instruction,
                                               const void* switch_impl_cpp)
   REQUIRES_SHARED(Locks::mutator_lock_) {
   SwitchImplContext ctx {
@@ -68,7 +66,6 @@ ALWAYS_INLINE inline JValue ExecuteSwitchImpl(Thread* self,
     .accessor = accessor,
     .shadow_frame = shadow_frame,
     .result_register = result_register,
-    .interpret_one_instruction = interpret_one_instruction,
     .result = JValue(),
   };
   const uint16_t* dex_pc = ctx.accessor.Insns();
diff --git a/runtime/interpreter/interpreter_switch_impl0.cc b/runtime/interpreter/interpreter_switch_impl0.cc
index 1bea9da838..61280d3fce 100644
--- a/runtime/interpreter/interpreter_switch_impl0.cc
+++ b/runtime/interpreter/interpreter_switch_impl0.cc
@@ -115,6 +115,30 @@ class ActiveInstrumentationHandler {
     instrumentation->Branch(self, method, dex_pc, dex_pc_offset);
   }
 
+  static bool ExceptionHandledEvent(Thread* self,
+                                    bool is_move_exception,
+                                    const instrumentation::Instrumentation* instrumentation)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    StackHandleScope<1> hs(self);
+    Handle<mirror::Throwable> exception(hs.NewHandle(self->GetException()));
+    // Clear any exception while reporting the ExceptionHandled event. We should not run the handler
+    // with an exception set.
+    self->ClearException();
+    instrumentation->ExceptionHandledEvent(self, exception.Get());
+    // If there is an exception then that is the exception thrown by the exception handled event
+    // and we should just handle the new exception. The earlier exception if any is ignored.
+    if (self->IsExceptionPending()) {
+      return false;  // Pending exception.
+    }
+
+    // Restore the original exception if the instruction we are going to execute is a move exception
+    // instruction.
+    if (is_move_exception) {
+      self->SetException(exception.Get());
+    }
+    return true;
+  }
+
   // Unlike most other events the DexPcMovedEvent can be sent when there is a pending exception (if
   // the next instruction is MOVE_EXCEPTION). This means it needs to be handled carefully to be able
   // to detect exceptions thrown by the DexPcMovedEvent itself. These exceptions could be thrown by
diff --git a/runtime/interpreter/mterp/arm64ng/main.S b/runtime/interpreter/mterp/arm64ng/main.S
index 7d83edbad1..995ff86f18 100644
--- a/runtime/interpreter/mterp/arm64ng/main.S
+++ b/runtime/interpreter/mterp/arm64ng/main.S
@@ -1541,6 +1541,8 @@ END \name
 .macro CHECK_AND_UPDATE_SHARED_MEMORY_METHOD if_hot, if_not_hot
     ldr wip, [x0, #ART_METHOD_ACCESS_FLAGS_OFFSET]
     tbz wip, #ART_METHOD_IS_MEMORY_SHARED_FLAG_BIT, \if_hot
+    // Intrinsics are always in the boot image and considered hot.
+    tbnz wip, #ART_METHOD_IS_INTRINSIC_FLAG_BIT, \if_hot
     ldr wip, [xSELF, #THREAD_SHARED_METHOD_HOTNESS_OFFSET]
     cbz wip, \if_hot
     add wip, wip, #-1
diff --git a/runtime/interpreter/mterp/armng/main.S b/runtime/interpreter/mterp/armng/main.S
index 906536654b..5298840f92 100644
--- a/runtime/interpreter/mterp/armng/main.S
+++ b/runtime/interpreter/mterp/armng/main.S
@@ -1544,6 +1544,9 @@ END \name
     ldr ip, [r0, #ART_METHOD_ACCESS_FLAGS_OFFSET]
     tst ip, #ART_METHOD_IS_MEMORY_SHARED_FLAG
     beq \if_hot
+    // Intrinsics are always in the boot image and considered hot.
+    tst ip, #ART_METHOD_IS_INTRINSIC_FLAG
+    bne \if_hot
     ldr ip, [rSELF, #THREAD_SHARED_METHOD_HOTNESS_OFFSET]
     cmp ip, #0
     beq \if_hot
diff --git a/runtime/interpreter/mterp/nterp.cc b/runtime/interpreter/mterp/nterp.cc
index a3e72725ce..b929444fc6 100644
--- a/runtime/interpreter/mterp/nterp.cc
+++ b/runtime/interpreter/mterp/nterp.cc
@@ -35,7 +35,7 @@ namespace art HIDDEN {
 namespace interpreter {
 
 bool IsNterpSupported() {
-  switch (kRuntimeISA) {
+  switch (kRuntimeQuickCodeISA) {
     case InstructionSet::kArm:
     case InstructionSet::kThumb2:
     case InstructionSet::kArm64:
@@ -106,10 +106,11 @@ void CheckNterpAsmConstants() {
    * which one did, but if any one is too big the total size will
    * overflow.
    */
-  const int width = kNterpHandlerSize;
+  constexpr size_t width = kNterpHandlerSize;
   ptrdiff_t interp_size = reinterpret_cast<uintptr_t>(artNterpAsmInstructionEnd) -
                           reinterpret_cast<uintptr_t>(artNterpAsmInstructionStart);
-  if ((interp_size == 0) || (interp_size != (art::kNumPackedOpcodes * width))) {
+  static_assert(kNumPackedOpcodes * width != 0);
+  if (interp_size != kNumPackedOpcodes * width) {
     LOG(FATAL) << "ERROR: unexpected asm interp size " << interp_size
                << "(did an instruction handler exceed " << width << " bytes?)";
   }
@@ -118,11 +119,7 @@ void CheckNterpAsmConstants() {
 inline void UpdateHotness(ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_) {
   // The hotness we will add to a method when we perform a
   // field/method/class/string lookup.
-  Runtime* runtime = Runtime::Current();
-  bool increase_hotness_for_ui = runtime->GetStartupCompleted() &&
-      runtime->InJankPerceptibleProcessState() &&
-      Thread::Current()->IsJitSensitiveThread();
-  method->UpdateCounter(increase_hotness_for_ui ? 0x6ff : 0xf);
+  method->UpdateCounter(0xf);
 }
 
 template<typename T>
@@ -334,10 +331,8 @@ extern "C" size_t NterpGetMethod(Thread* self, ArtMethod* caller, const uint16_t
 
   ClassLinker* const class_linker = Runtime::Current()->GetClassLinker();
   ArtMethod* resolved_method = caller->SkipAccessChecks()
-      ? class_linker->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(
-            self, method_index, caller, invoke_type)
-      : class_linker->ResolveMethod<ClassLinker::ResolveMode::kCheckICCEAndIAE>(
-            self, method_index, caller, invoke_type);
+      ? class_linker->ResolveMethodId(method_index, caller)
+      : class_linker->ResolveMethodWithChecks(method_index, caller, invoke_type);
   if (resolved_method == nullptr) {
     DCHECK(self->IsExceptionPending());
     return 0;
@@ -694,8 +689,11 @@ extern "C" jit::OsrData* NterpHotMethod(ArtMethod* method, uint16_t* dex_pc_ptr,
   ScopedAssertNoThreadSuspension sants("In nterp");
   Runtime* runtime = Runtime::Current();
   if (method->IsMemorySharedMethod()) {
-    DCHECK_EQ(Thread::Current()->GetSharedMethodHotness(), 0u);
-    Thread::Current()->ResetSharedMethodHotness();
+    if (!method->IsIntrinsic()) {
+      // Intrinsics are special and will be considered hot from the first call.
+      DCHECK_EQ(Thread::Current()->GetSharedMethodHotness(), 0u);
+      Thread::Current()->ResetSharedMethodHotness();
+    }
   } else {
     // Move the counter to the initial threshold in case we have to re-JIT it.
     method->ResetCounter(runtime->GetJITOptions()->GetWarmupThreshold());
diff --git a/runtime/interpreter/mterp/riscv64/main.S b/runtime/interpreter/mterp/riscv64/main.S
index a9b917ad35..11428646ad 100644
--- a/runtime/interpreter/mterp/riscv64/main.S
+++ b/runtime/interpreter/mterp/riscv64/main.S
@@ -249,9 +249,12 @@ END \name
 //   - xSELF
 // Clobbers: t0
 .macro CHECK_AND_UPDATE_SHARED_MEMORY_METHOD if_hot, if_not_hot
+    // TODO(solanes): Figure out if there's a way to load t0 only once.
     lwu t0, ART_METHOD_ACCESS_FLAGS_OFFSET(a0)
     BRANCH_IF_BIT_CLEAR t0, t0, ART_METHOD_IS_MEMORY_SHARED_FLAG_BIT, \if_hot
-
+    lwu t0, ART_METHOD_ACCESS_FLAGS_OFFSET(a0)
+    // Intrinsics are always in the boot image and considered hot.
+    BRANCH_IF_BIT_SET t0, t0, ART_METHOD_IS_INTRINSIC_FLAG_BIT, \if_hot
     lwu t0, THREAD_SHARED_METHOD_HOTNESS_OFFSET(xSELF)  // t0 := hotness
     beqz t0, \if_hot
 
diff --git a/runtime/interpreter/mterp/x86_64ng/main.S b/runtime/interpreter/mterp/x86_64ng/main.S
index f6f48ffcc3..80753c4fc2 100644
--- a/runtime/interpreter/mterp/x86_64ng/main.S
+++ b/runtime/interpreter/mterp/x86_64ng/main.S
@@ -1610,6 +1610,9 @@ END_FUNCTION \name
 .macro CHECK_AND_UPDATE_SHARED_MEMORY_METHOD if_hot, if_not_hot
     testl $$ART_METHOD_IS_MEMORY_SHARED_FLAG, ART_METHOD_ACCESS_FLAGS_OFFSET(%rdi)
     jz \if_hot
+    // Intrinsics are always in the boot image and considered hot.
+    testl $$ART_METHOD_IS_INTRINSIC_FLAG, ART_METHOD_ACCESS_FLAGS_OFFSET(%rdi)
+    jnz \if_hot
     movzwl rSELF:THREAD_SHARED_METHOD_HOTNESS_OFFSET, %esi
     testl %esi, %esi
     je \if_hot
diff --git a/runtime/interpreter/mterp/x86ng/main.S b/runtime/interpreter/mterp/x86ng/main.S
index 65a6a75df1..d2f4271f99 100644
--- a/runtime/interpreter/mterp/x86ng/main.S
+++ b/runtime/interpreter/mterp/x86ng/main.S
@@ -1687,6 +1687,9 @@ END_FUNCTION \name
 .macro CHECK_AND_UPDATE_SHARED_MEMORY_METHOD if_hot, if_not_hot
     testl $$ART_METHOD_IS_MEMORY_SHARED_FLAG, ART_METHOD_ACCESS_FLAGS_OFFSET(%eax)
     jz \if_hot
+    // Intrinsics are always in the boot image and considered hot.
+    testl $$ART_METHOD_IS_INTRINSIC_FLAG, ART_METHOD_ACCESS_FLAGS_OFFSET(%eax)
+    jnz \if_hot
     movzwl rSELF:THREAD_SHARED_METHOD_HOTNESS_OFFSET, %ecx
     testl %ecx, %ecx
     je \if_hot
diff --git a/runtime/interpreter/shadow_frame.h b/runtime/interpreter/shadow_frame.h
index 54c40b2e3c..6b3ec915df 100644
--- a/runtime/interpreter/shadow_frame.h
+++ b/runtime/interpreter/shadow_frame.h
@@ -65,6 +65,10 @@ class ShadowFrame {
     // Used to specify if DexPCMoveEvents have to be reported. These events will
     // only be reported if the method has a breakpoint set.
     kNotifyDexPcMoveEvents = 1 << 5,
+    // Used to specify if ExceptionHandledEvent has to be reported. When enabled these events are
+    // reported when we reach the catch block after an exception was thrown. These events have to
+    // be reported after the DexPCMoveEvent if enabled.
+    kNotifyExceptionHandledEvent = 1 << 6,
   };
 
  public:
@@ -300,10 +304,6 @@ class ShadowFrame {
     return OFFSETOF_MEMBER(ShadowFrame, vregs_);
   }
 
-  static constexpr size_t ResultRegisterOffset() {
-    return OFFSETOF_MEMBER(ShadowFrame, result_register_);
-  }
-
   static constexpr size_t DexPCPtrOffset() {
     return OFFSETOF_MEMBER(ShadowFrame, dex_pc_ptr_);
   }
@@ -336,10 +336,6 @@ class ShadowFrame {
     dex_pc_ptr_ = dex_pc_ptr;
   }
 
-  JValue* GetResultRegister() {
-    return result_register_;
-  }
-
   bool NeedsNotifyPop() const {
     return GetFrameFlag(FrameFlags::kNotifyFramePop);
   }
@@ -388,6 +384,14 @@ class ShadowFrame {
     UpdateFrameFlag(enable, FrameFlags::kNotifyDexPcMoveEvents);
   }
 
+  bool GetNotifyExceptionHandledEvent() const {
+    return GetFrameFlag(FrameFlags::kNotifyExceptionHandledEvent);
+  }
+
+  void SetNotifyExceptionHandledEvent(bool enable) {
+    UpdateFrameFlag(enable, FrameFlags::kNotifyExceptionHandledEvent);
+  }
+
   void CheckConsistentVRegs() const {
     if (kIsDebugBuild) {
       // A shadow frame visible to GC requires the following rule: for a given vreg,
@@ -403,7 +407,6 @@ class ShadowFrame {
   ShadowFrame(uint32_t num_vregs, ArtMethod* method, uint32_t dex_pc)
       : link_(nullptr),
         method_(method),
-        result_register_(nullptr),
         dex_pc_ptr_(nullptr),
         dex_instructions_(nullptr),
         number_of_vregs_(num_vregs),
@@ -439,7 +442,6 @@ class ShadowFrame {
   // Link to previous shadow frame or null.
   ShadowFrame* link_;
   ArtMethod* method_;
-  JValue* result_register_;
   const uint16_t* dex_pc_ptr_;
   // Dex instruction base of the code item.
   const uint16_t* dex_instructions_;
@@ -450,7 +452,7 @@ class ShadowFrame {
   int16_t hotness_countdown_;
 
   // This is a set of ShadowFrame::FrameFlags which denote special states this frame is in.
-  // NB alignment requires that this field takes 4 bytes no matter its size. Only 3 bits are
+  // NB alignment requires that this field takes 4 bytes no matter its size. Only 7 bits are
   // currently used.
   uint32_t frame_flags_;
 
diff --git a/runtime/interpreter/unstarted_runtime.cc b/runtime/interpreter/unstarted_runtime.cc
index 0dde04145a..9149f3a6c2 100644
--- a/runtime/interpreter/unstarted_runtime.cc
+++ b/runtime/interpreter/unstarted_runtime.cc
@@ -142,7 +142,8 @@ static void UnstartedRuntimeFindClass(Thread* self,
   std::string descriptor(DotToDescriptor(className->ToModifiedUtf8().c_str()));
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
 
-  ObjPtr<mirror::Class> found = class_linker->FindClass(self, descriptor.c_str(), class_loader);
+  ObjPtr<mirror::Class> found =
+      class_linker->FindClass(self, descriptor.c_str(), descriptor.length(), class_loader);
   if (found != nullptr && !found->CheckIsVisibleWithTargetSdk(self)) {
     CHECK(self->IsExceptionPending());
     return;
@@ -626,9 +627,7 @@ static void GetResourceAsStream(Thread* self,
 
   // Create a ByteArrayInputStream.
   Handle<mirror::Class> h_class(hs.NewHandle(
-      runtime->GetClassLinker()->FindClass(self,
-                                           "Ljava/io/ByteArrayInputStream;",
-                                           ScopedNullHandle<mirror::ClassLoader>())));
+      runtime->GetClassLinker()->FindSystemClass(self, "Ljava/io/ByteArrayInputStream;")));
   if (h_class == nullptr) {
     AbortTransactionOrFail(self, "Could not find ByteArrayInputStream class");
     return;
@@ -755,6 +754,47 @@ void UnstartedRuntime::UnstartedConstructorNewInstance0(
   }
 }
 
+void UnstartedRuntime::UnstartedJNIExecutableGetParameterTypesInternal(
+    Thread* self, ArtMethod*, mirror::Object* receiver, uint32_t*, JValue* result) {
+  StackHandleScope<3> hs(self);
+  ScopedObjectAccessUnchecked soa(self);
+  Handle<mirror::Executable> executable(hs.NewHandle(
+      reinterpret_cast<mirror::Executable*>(receiver)));
+  if (executable == nullptr) {
+    AbortTransactionOrFail(self, "Receiver can't be null in GetParameterTypesInternal");
+  }
+
+  ArtMethod* method = executable->GetArtMethod();
+  const dex::TypeList* params = method->GetParameterTypeList();
+  if (params == nullptr) {
+    result->SetL(nullptr);
+    return;
+  }
+
+  const uint32_t num_params = params->Size();
+
+  ObjPtr<mirror::Class> class_array_class = GetClassRoot<mirror::ObjectArray<mirror::Class>>();
+  Handle<mirror::ObjectArray<mirror::Class>> ptypes = hs.NewHandle(
+      mirror::ObjectArray<mirror::Class>::Alloc(soa.Self(), class_array_class, num_params));
+  if (ptypes.IsNull()) {
+    AbortTransactionOrFail(self, "Could not allocate array of mirror::Class");
+    return;
+  }
+
+  MutableHandle<mirror::Class> param(hs.NewHandle<mirror::Class>(nullptr));
+  for (uint32_t i = 0; i < num_params; ++i) {
+    const dex::TypeIndex type_idx = params->GetTypeItem(i).type_idx_;
+    param.Assign(Runtime::Current()->GetClassLinker()->ResolveType(type_idx, method));
+    if (param.Get() == nullptr) {
+      AbortTransactionOrFail(self, "Could not resolve type");
+      return;
+    }
+    ptypes->SetWithoutChecks<false>(i, param.Get());
+  }
+
+  result->SetL(ptypes.Get());
+}
+
 void UnstartedRuntime::UnstartedVmClassLoaderFindLoadedClass(
     Thread* self, ShadowFrame* shadow_frame, JValue* result, size_t arg_offset) {
   ObjPtr<mirror::String> class_name = shadow_frame->GetVRegReference(arg_offset + 1)->AsString();
@@ -974,9 +1014,7 @@ static void GetSystemProperty(Thread* self,
   // Get the storage class.
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
   Handle<mirror::Class> h_props_class(hs.NewHandle(
-      class_linker->FindClass(self,
-                              "Ljava/lang/AndroidHardcodedSystemProperties;",
-                              ScopedNullHandle<mirror::ClassLoader>())));
+      class_linker->FindSystemClass(self, "Ljava/lang/AndroidHardcodedSystemProperties;")));
   if (h_props_class == nullptr) {
     AbortTransactionOrFail(self, "Could not find AndroidHardcodedSystemProperties");
     return;
@@ -1046,6 +1084,13 @@ void UnstartedRuntime::UnstartedSystemGetPropertyWithDefault(
   GetSystemProperty(self, shadow_frame, result, arg_offset, true);
 }
 
+void UnstartedRuntime::UnstartedSystemNanoTime(Thread* self, ShadowFrame*, JValue*, size_t) {
+  // We don't want `System.nanoTime` to be called at compile time because `java.util.Random`'s
+  // default constructor uses `nanoTime` to initialize seed and having it set during compile time
+  // makes that `java.util.Random` instance deterministic for given system image.
+  AbortTransactionOrFail(self, "Should not be called by UnstartedRuntime");
+}
+
 static std::string GetImmediateCaller(ShadowFrame* shadow_frame)
     REQUIRES_SHARED(Locks::mutator_lock_) {
   if (shadow_frame->GetLink() == nullptr) {
@@ -1076,8 +1121,7 @@ static ObjPtr<mirror::Object> CreateInstanceOf(Thread* self, const char* class_d
     REQUIRES_SHARED(Locks::mutator_lock_) {
   // Find the requested class.
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  ObjPtr<mirror::Class> klass =
-      class_linker->FindClass(self, class_descriptor, ScopedNullHandle<mirror::ClassLoader>());
+  ObjPtr<mirror::Class> klass = class_linker->FindSystemClass(self, class_descriptor);
   if (klass == nullptr) {
     AbortTransactionOrFail(self, "Could not load class %s", class_descriptor);
     return nullptr;
@@ -1108,8 +1152,9 @@ void UnstartedRuntime::UnstartedThreadLocalGet(Thread* self,
                                                ShadowFrame* shadow_frame,
                                                JValue* result,
                                                [[maybe_unused]] size_t arg_offset) {
-  if (CheckCallers(shadow_frame, { "jdk.internal.math.FloatingDecimal$BinaryToASCIIBuffer "
-                                       "jdk.internal.math.FloatingDecimal.getBinaryToASCIIBuffer()" })) {
+  if (CheckCallers(shadow_frame,
+                   { "jdk.internal.math.FloatingDecimal$BinaryToASCIIBuffer "
+                         "jdk.internal.math.FloatingDecimal.getBinaryToASCIIBuffer()" })) {
     result->SetL(CreateInstanceOf(self, "Ljdk/internal/math/FloatingDecimal$BinaryToASCIIBuffer;"));
   } else {
     AbortTransactionOrFail(self,
diff --git a/runtime/interpreter/unstarted_runtime_list.h b/runtime/interpreter/unstarted_runtime_list.h
index 71e3ae71ae..55e30e9007 100644
--- a/runtime/interpreter/unstarted_runtime_list.h
+++ b/runtime/interpreter/unstarted_runtime_list.h
@@ -46,6 +46,7 @@
   V(SystemGetSecurityManager, "Ljava/lang/System;", "getSecurityManager", "()Ljava/lang/SecurityManager;") \
   V(SystemGetProperty, "Ljava/lang/System;", "getProperty", "(Ljava/lang/String;)Ljava/lang/String;") \
   V(SystemGetPropertyWithDefault, "Ljava/lang/System;", "getProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;") \
+  V(SystemNanoTime, "Ljava/lang/System;", "nanoTime", "()J") \
   V(ThreadLocalGet, "Ljava/lang/ThreadLocal;", "get", "()Ljava/lang/Object;") \
   V(MathCeil, "Ljava/lang/Math;", "ceil", "(D)D") \
   V(MathFloor, "Ljava/lang/Math;", "floor", "(D)D") \
@@ -101,6 +102,7 @@
   V(AtomicLongVMSupportsCS8, "Ljava/util/concurrent/atomic/AtomicLong;", "VMSupportsCS8", "()Z") \
   V(ClassGetNameNative, "Ljava/lang/Class;", "getNameNative", "()Ljava/lang/String;") \
   V(DoubleLongBitsToDouble, "Ljava/lang/Double;", "longBitsToDouble", "(J)D") \
+  V(ExecutableGetParameterTypesInternal, "Ljava/lang/reflect/Executable;", "getParameterTypesInternal", "()[Ljava/lang/Class;") \
   V(FloatFloatToRawIntBits, "Ljava/lang/Float;", "floatToRawIntBits", "(F)I") \
   V(FloatIntBitsToFloat, "Ljava/lang/Float;", "intBitsToFloat", "(I)F") \
   V(ObjectInternalClone, "Ljava/lang/Object;", "internalClone", "()Ljava/lang/Object;") \
diff --git a/runtime/interpreter/unstarted_runtime_test.cc b/runtime/interpreter/unstarted_runtime_test.cc
index cf7782dcdc..1f5f111c59 100644
--- a/runtime/interpreter/unstarted_runtime_test.cc
+++ b/runtime/interpreter/unstarted_runtime_test.cc
@@ -784,7 +784,7 @@ TEST_F(UnstartedRuntimeTest, IsAnonymousClass) {
   StackHandleScope<1> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
-  ObjPtr<mirror::Class> c = class_linker_->FindClass(soa.Self(), "LNested$1;", loader);
+  ObjPtr<mirror::Class> c = FindClass("LNested$1;", loader);
   ASSERT_TRUE(c != nullptr);
   shadow_frame->SetVRegReference(0, c);
   UnstartedClassIsAnonymousClass(self, shadow_frame.get(), &result, 0);
@@ -803,12 +803,9 @@ TEST_F(UnstartedRuntimeTest, GetDeclaringClass) {
   Handle<mirror::ClassLoader> loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader)));
 
-  Handle<mirror::Class> nested_klass(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LNested;", loader)));
-  Handle<mirror::Class> inner_klass(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LNested$Inner;", loader)));
-  Handle<mirror::Class> anon_klass(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LNested$1;", loader)));
+  Handle<mirror::Class> nested_klass = hs.NewHandle(FindClass("LNested;", loader));
+  Handle<mirror::Class> inner_klass = hs.NewHandle(FindClass("LNested$Inner;", loader));
+  Handle<mirror::Class> anon_klass = hs.NewHandle(FindClass("LNested$1;", loader));
 
   shadow_frame->SetVRegReference(0, nested_klass.Get());
   UnstartedClassGetDeclaringClass(self, shadow_frame.get(), &result, 0);
@@ -835,9 +832,7 @@ TEST_F(UnstartedRuntimeTest, ThreadLocalGet) {
   // Positive test. See that We get something for float conversion.
   {
     Handle<mirror::Class> floating_decimal = hs.NewHandle(
-        class_linker_->FindClass(self,
-                                 "Ljdk/internal/math/FloatingDecimal;",
-                                 ScopedNullHandle<mirror::ClassLoader>()));
+        FindClass("Ljdk/internal/math/FloatingDecimal;", ScopedNullHandle<mirror::ClassLoader>()));
     ASSERT_TRUE(floating_decimal != nullptr);
     ASSERT_TRUE(class_linker_->EnsureInitialized(self, floating_decimal, true, true));
 
@@ -865,10 +860,8 @@ TEST_F(UnstartedRuntimeTest, FloatConversion) {
   ScopedObjectAccess soa(self);
 
   StackHandleScope<1> hs(self);
-  Handle<mirror::Class> double_class = hs.NewHandle(
-          class_linker_->FindClass(self,
-                                   "Ljava/lang/Double;",
-                                   ScopedNullHandle<mirror::ClassLoader>()));
+  Handle<mirror::Class> double_class =
+      hs.NewHandle(FindClass("Ljava/lang/Double;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(double_class != nullptr);
   ASSERT_TRUE(class_linker_->EnsureInitialized(self, double_class, true, true));
 
@@ -905,8 +898,8 @@ TEST_F(UnstartedRuntimeTest, LogManager) {
   ScopedObjectAccess soa(self);
 
   StackHandleScope<1> hs(self);
-  Handle<mirror::Class> log_manager_class = hs.NewHandle(class_linker_->FindClass(
-      self, "Ljava/util/logging/LogManager;", ScopedNullHandle<mirror::ClassLoader>()));
+  Handle<mirror::Class> log_manager_class = hs.NewHandle(
+      FindClass("Ljava/util/logging/LogManager;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(log_manager_class.Get() != nullptr);
   ASSERT_TRUE(class_linker_->EnsureInitialized(self, log_manager_class, true, true));
 }
@@ -991,10 +984,8 @@ TEST_F(UnstartedRuntimeTest, ClassGetSignatureAnnotation) {
   ScopedObjectAccess soa(self);
 
   StackHandleScope<1> hs(self);
-  Handle<mirror::Class> list_class = hs.NewHandle(
-      class_linker_->FindClass(self,
-                               "Ljava/util/List;",
-                               ScopedNullHandle<mirror::ClassLoader>()));
+  Handle<mirror::Class> list_class =
+      hs.NewHandle(FindClass("Ljava/util/List;", ScopedNullHandle<mirror::ClassLoader>()));
   ASSERT_TRUE(list_class.Get() != nullptr);
   ASSERT_TRUE(class_linker_->EnsureInitialized(self, list_class, true, true));
 
diff --git a/runtime/interpreter/unstarted_runtime_test.h b/runtime/interpreter/unstarted_runtime_test.h
index 465a4268ea..eb0a28aaec 100644
--- a/runtime/interpreter/unstarted_runtime_test.h
+++ b/runtime/interpreter/unstarted_runtime_test.h
@@ -85,8 +85,8 @@ class UnstartedRuntimeTestBase : public CommonRuntimeTest {
     StackHandleScope<2> hs(self);
 
     // Create the fake boot classloader. Any instance is fine, they are technically interchangeable.
-    Handle<mirror::Class> boot_cp_class = hs.NewHandle(class_linker_->FindClass(
-        self, "Ljava/lang/BootClassLoader;", ScopedNullHandle<mirror::ClassLoader>()));
+    Handle<mirror::Class> boot_cp_class = hs.NewHandle(
+        FindClass("Ljava/lang/BootClassLoader;", ScopedNullHandle<mirror::ClassLoader>()));
     CHECK(boot_cp_class != nullptr);
     CHECK(class_linker_->EnsureInitialized(
         self, boot_cp_class, /*can_init_fields=*/ true, /*can_init_parents=*/ true));
diff --git a/runtime/intrinsics_list.h b/runtime/intrinsics_list.h
index cdd23596b5..ccb94645f2 100644
--- a/runtime/intrinsics_list.h
+++ b/runtime/intrinsics_list.h
@@ -239,6 +239,7 @@
   V(UnsafeCASLong, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "compareAndSwapLong", "(Ljava/lang/Object;JJJ)Z") \
   V(UnsafeCASObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "compareAndSwapObject", "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z") \
   V(UnsafeGet, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getInt", "(Ljava/lang/Object;J)I") \
+  V(UnsafeGetAbsolute, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getInt", "(J)I") \
   V(UnsafeGetVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getIntVolatile", "(Ljava/lang/Object;J)I") \
   V(UnsafeGetObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getObject", "(Ljava/lang/Object;J)Ljava/lang/Object;") \
   V(UnsafeGetObjectVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getObjectVolatile", "(Ljava/lang/Object;J)Ljava/lang/Object;") \
@@ -246,6 +247,7 @@
   V(UnsafeGetLongVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getLongVolatile", "(Ljava/lang/Object;J)J") \
   V(UnsafeGetByte, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "getByte", "(Ljava/lang/Object;J)B") \
   V(UnsafePut, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "putInt", "(Ljava/lang/Object;JI)V") \
+  V(UnsafePutAbsolute, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "putInt", "(JI)V") \
   V(UnsafePutOrdered, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "putOrderedInt", "(Ljava/lang/Object;JI)V") \
   V(UnsafePutVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "putIntVolatile", "(Ljava/lang/Object;JI)V") \
   V(UnsafePutObject, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Lsun/misc/Unsafe;", "putObject", "(Ljava/lang/Object;JLjava/lang/Object;)V") \
@@ -268,6 +270,7 @@
   V(JdkUnsafeCompareAndSetLong, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "compareAndSetLong", "(Ljava/lang/Object;JJJ)Z") \
   V(JdkUnsafeCompareAndSetReference, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "compareAndSetReference", "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z") \
   V(JdkUnsafeGet, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getInt", "(Ljava/lang/Object;J)I") \
+  V(JdkUnsafeGetAbsolute, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getInt", "(J)I") \
   V(JdkUnsafeGetVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getIntVolatile", "(Ljava/lang/Object;J)I") \
   V(JdkUnsafeGetAcquire, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getIntAcquire", "(Ljava/lang/Object;J)I") \
   V(JdkUnsafeGetReference, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getReference", "(Ljava/lang/Object;J)Ljava/lang/Object;") \
@@ -278,6 +281,7 @@
   V(JdkUnsafeGetLongAcquire, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getLongAcquire", "(Ljava/lang/Object;J)J") \
   V(JdkUnsafeGetByte, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "getByte", "(Ljava/lang/Object;J)B") \
   V(JdkUnsafePut, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "putInt", "(Ljava/lang/Object;JI)V") \
+  V(JdkUnsafePutAbsolute, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "putInt", "(JI)V") \
   V(JdkUnsafePutOrdered, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "putOrderedInt", "(Ljava/lang/Object;JI)V") \
   V(JdkUnsafePutRelease, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "putIntRelease", "(Ljava/lang/Object;JI)V") \
   V(JdkUnsafePutVolatile, kVirtual, kNeedsEnvironment, kAllSideEffects, kCanThrow, "Ljdk/internal/misc/Unsafe;", "putIntVolatile", "(Ljava/lang/Object;JI)V") \
diff --git a/runtime/jit/jit-inl.h b/runtime/jit/jit-inl.h
index 52099c2e1d..684e5c85b0 100644
--- a/runtime/jit/jit-inl.h
+++ b/runtime/jit/jit-inl.h
@@ -17,6 +17,7 @@
 #ifndef ART_RUNTIME_JIT_JIT_INL_H_
 #define ART_RUNTIME_JIT_JIT_INL_H_
 
+#include "android-base/macros.h"
 #include "jit/jit.h"
 
 #include "art_method.h"
@@ -28,12 +29,20 @@ namespace art HIDDEN {
 namespace jit {
 
 inline void Jit::AddSamples(Thread* self, ArtMethod* method) {
+  // `hotness_count_` should always be 0 for intrinsics (which are considered hot from the first
+  // call), and for memory shared methods which use `shared_method_hotness`.
+  DCHECK_IMPLIES(method->IsIntrinsic(), method->CounterIsHot());
+  DCHECK_IMPLIES(method->IsMemorySharedMethod(), method->CounterIsHot());
+
   if (method->CounterIsHot()) {
     if (method->IsMemorySharedMethod()) {
-      if (self->DecrementSharedMethodHotness() == 0) {
-        self->ResetSharedMethodHotness();
-      } else {
-        return;
+      // Intrinsics do not use `shared_method_hotness`.
+      if (!method->IsIntrinsic()) {
+        if (self->DecrementSharedMethodHotness() == 0) {
+          self->ResetSharedMethodHotness();
+        } else {
+          return;
+        }
       }
     } else {
       method->ResetCounter(Runtime::Current()->GetJITOptions()->GetWarmupThreshold());
diff --git a/runtime/jit/jit.cc b/runtime/jit/jit.cc
index 567f07adf0..a399cafcf4 100644
--- a/runtime/jit/jit.cc
+++ b/runtime/jit/jit.cc
@@ -19,6 +19,7 @@
 #include <dlfcn.h>
 #include <sys/resource.h>
 
+#include "app_info.h"
 #include "art_method-inl.h"
 #include "base/file_utils.h"
 #include "base/logging.h"  // For VLOG.
@@ -35,6 +36,7 @@
 #include "entrypoints/entrypoint_utils-inl.h"
 #include "entrypoints/runtime_asm_entrypoints.h"
 #include "gc/space/image_space.h"
+#include "gc/task_processor.h"
 #include "interpreter/interpreter.h"
 #include "jit-inl.h"
 #include "jit_code_cache.h"
@@ -275,13 +277,15 @@ void Jit::DeleteThreadPool() {
 
 void Jit::StartProfileSaver(const std::string& profile_filename,
                             const std::vector<std::string>& code_paths,
-                            const std::string& ref_profile_filename) {
+                            const std::string& ref_profile_filename,
+                            AppInfo::CodeType code_type) {
   if (options_->GetSaveProfilingInfo()) {
     ProfileSaver::Start(options_->GetProfileSaverOptions(),
                         profile_filename,
                         code_cache_,
                         code_paths,
-                        ref_profile_filename);
+                        ref_profile_filename,
+                        code_type);
   }
 }
 
@@ -432,7 +436,7 @@ OsrData* Jit::PrepareForOsr(ArtMethod* method, uint32_t dex_pc, uint32_t* vregs)
       }
     }
 
-    osr_data->native_pc = stack_map.GetNativePcOffset(kRuntimeISA) +
+    osr_data->native_pc = stack_map.GetNativePcOffset(kRuntimeQuickCodeISA) +
         osr_method->GetEntryPoint();
     VLOG(jit) << "Jumping to "
               << method_name
@@ -452,7 +456,7 @@ bool Jit::MaybeDoOnStackReplacement(Thread* thread,
     return false;
   }
 
-  if (UNLIKELY(__builtin_frame_address(0) < thread->GetStackEnd())) {
+  if (UNLIKELY(__builtin_frame_address(0) < thread->GetStackEnd<kNativeStackType>())) {
     // Don't attempt to do an OSR if we are close to the stack limit. Since
     // the interpreter frames are still on stack, OSR has the potential
     // to stack overflow even for a simple loop.
@@ -568,6 +572,7 @@ void Jit::NotifyZygoteCompilationDone() {
       /* start= */ 0,
       /* low_4gb= */ false,
       "boot-image-methods",
+      /* reuse= */ true,  // The mapping will be reused by the mremaps below.
       &error_str);
 
   if (!child_mapping_methods.IsValid()) {
@@ -640,10 +645,6 @@ void Jit::NotifyZygoteCompilationDone() {
   // Mark that compilation of boot classpath is done, and memory can now be
   // shared. Other processes will pick up this information.
   code_cache_->GetZygoteMap()->SetCompilationState(ZygoteCompilationState::kNotifiedOk);
-
-  // The private mapping created for this process has been mremaped. We can
-  // reset it.
-  child_mapping_methods.Reset();
 }
 
 class JitCompileTask final : public Task {
@@ -805,15 +806,17 @@ class ZygoteVerificationTask final : public Task {
     const std::vector<const DexFile*>& boot_class_path =
         runtime->GetClassLinker()->GetBootClassPath();
     ScopedObjectAccess soa(self);
-    StackHandleScope<1> hs(self);
+    StackHandleScope<2> hs(self);
+    MutableHandle<mirror::DexCache> dex_cache = hs.NewHandle<mirror::DexCache>(nullptr);
     MutableHandle<mirror::Class> klass = hs.NewHandle<mirror::Class>(nullptr);
     uint64_t start_ns = ThreadCpuNanoTime();
     uint64_t number_of_classes = 0;
     for (const DexFile* dex_file : boot_class_path) {
+      dex_cache.Assign(linker->FindDexCache(self, *dex_file));
       for (uint32_t i = 0; i < dex_file->NumClassDefs(); ++i) {
         const dex::ClassDef& class_def = dex_file->GetClassDef(i);
-        const char* descriptor = dex_file->GetClassDescriptor(class_def);
-        klass.Assign(linker->LookupResolvedType(descriptor, /* class_loader= */ nullptr));
+        klass.Assign(linker->LookupResolvedType(
+            class_def.class_idx_, dex_cache.Get(), /* class_loader= */ nullptr));
         if (klass == nullptr) {
           // Class not loaded yet.
           DCHECK(!self->IsExceptionPending());
@@ -975,6 +978,7 @@ void Jit::MapBootImageMethods() {
       /* start= */ 0,
       /* low_4gb= */ false,
       "boot-image-methods",
+      /* reuse= */ true,  // The mapping will be reused by the mremaps below.
       &error_str);
 
   // We don't need the fd anymore.
@@ -1071,9 +1075,6 @@ void Jit::MapBootImageMethods() {
     offset += capacity;
   }
 
-  // The private mapping created for this process has been mremaped. We can
-  // reset it.
-  child_mapping_methods.Reset();
   LOG(INFO) << "Successfully mapped boot image methods";
 }
 
@@ -1226,8 +1227,7 @@ bool Jit::CompileMethodFromProfile(Thread* self,
                                    Handle<mirror::ClassLoader> class_loader,
                                    bool add_to_queue,
                                    bool compile_after_boot) {
-  ArtMethod* method = class_linker->ResolveMethodWithoutInvokeType(
-      method_idx, dex_cache, class_loader);
+  ArtMethod* method = class_linker->ResolveMethodId(method_idx, dex_cache, class_loader);
   if (method == nullptr) {
     self->ClearException();
     return false;
@@ -1481,40 +1481,25 @@ ScopedJitSuspend::~ScopedJitSuspend() {
   }
 }
 
-static void* RunPollingThread(void* arg) {
-  Jit* jit = reinterpret_cast<Jit*>(arg);
-  do {
-    sleep(10);
-  } while (!jit->GetCodeCache()->GetZygoteMap()->IsCompilationNotified());
+class MapBootImageMethodsTask : public gc::HeapTask {
+ public:
+  explicit MapBootImageMethodsTask(uint64_t target_run_time) : gc::HeapTask(target_run_time) {}
 
-  // We will suspend other threads: we can only do that if we're attached to the
-  // runtime.
-  Runtime* runtime = Runtime::Current();
-  bool thread_attached = runtime->AttachCurrentThread(
-      "BootImagePollingThread",
-      /* as_daemon= */ true,
-      /* thread_group= */ nullptr,
-      /* create_peer= */ false);
-  CHECK(thread_attached);
-
-  if (getpriority(PRIO_PROCESS, 0 /* this thread */) == 0) {
-    // Slightly reduce thread priority, mostly so the suspend logic notices that we're
-    // not a high priority thread, and can time out more slowly. May fail on host.
-    (void)setpriority(PRIO_PROCESS, 0 /* this thread */, 1);
-  } else {
-    PLOG(ERROR) << "Unexpected BootImagePollingThread priority: " << getpriority(PRIO_PROCESS, 0);
-  }
-  {
+  void Run(Thread* self ATTRIBUTE_UNUSED) override {
+    Runtime* runtime = Runtime::Current();
+    if (!runtime->GetJit()->GetCodeCache()->GetZygoteMap()->IsCompilationNotified()) {
+      // Add a new task that will execute in 10 seconds.
+      static constexpr uint64_t kWaitTimeNs = MsToNs(10000);  // 10 seconds
+      runtime->GetHeap()->AddHeapTask(new MapBootImageMethodsTask(NanoTime() + kWaitTimeNs));
+      return;
+    }
     // Prevent other threads from running while we are remapping the boot image
     // ArtMethod's. Native threads might still be running, but they cannot
     // change the contents of ArtMethod's.
     ScopedSuspendAll ssa(__FUNCTION__);
     runtime->GetJit()->MapBootImageMethods();
   }
-
-  Runtime::Current()->DetachCurrentThread();
-  return nullptr;
-}
+};
 
 void Jit::PostForkChildAction(bool is_system_server, bool is_zygote) {
   // Clear the potential boot tasks inherited from the zygote.
@@ -1526,19 +1511,8 @@ void Jit::PostForkChildAction(bool is_system_server, bool is_zygote) {
   Runtime* const runtime = Runtime::Current();
   // Check if we'll need to remap the boot image methods.
   if (!is_zygote && fd_methods_ != -1) {
-    // Create a thread that will poll the status of zygote compilation, and map
-    // the private mapping of boot image methods.
-    // For child zygote, we instead query IsCompilationNotified() post zygote fork.
-    zygote_mapping_methods_.ResetInForkedProcess();
-    pthread_t polling_thread;
-    pthread_attr_t attr;
-    CHECK_PTHREAD_CALL(pthread_attr_init, (&attr), "new thread");
-    CHECK_PTHREAD_CALL(pthread_attr_setdetachstate, (&attr, PTHREAD_CREATE_DETACHED),
-                       "PTHREAD_CREATE_DETACHED");
-    CHECK_PTHREAD_CALL(
-        pthread_create,
-        (&polling_thread, &attr, RunPollingThread, reinterpret_cast<void*>(this)),
-        "Methods maps thread");
+    Runtime::Current()->GetHeap()->AddHeapTask(
+        new MapBootImageMethodsTask(NanoTime() + MsToNs(10000)));
   }
 
   if (is_zygote || runtime->IsSafeMode()) {
@@ -1716,7 +1690,8 @@ void Jit::MaybeEnqueueCompilation(ArtMethod* method, Thread* self) {
   }
 
   static constexpr size_t kIndividualSharedMethodHotnessThreshold = 0x3f;
-  if (method->IsMemorySharedMethod()) {
+  // Intrinsics are always in the boot image and considered hot.
+  if (method->IsMemorySharedMethod() && !method->IsIntrinsic()) {
     MutexLock mu(self, lock_);
     auto it = shared_method_counters_.find(method);
     if (it == shared_method_counters_.end()) {
diff --git a/runtime/jit/jit.h b/runtime/jit/jit.h
index 64b522251d..5e1429eb41 100644
--- a/runtime/jit/jit.h
+++ b/runtime/jit/jit.h
@@ -17,21 +17,22 @@
 #ifndef ART_RUNTIME_JIT_JIT_H_
 #define ART_RUNTIME_JIT_JIT_H_
 
-#include <unordered_set>
-
 #include <android-base/unique_fd.h>
 
+#include <unordered_set>
+
+#include "app_info.h"
 #include "base/histogram-inl.h"
 #include "base/macros.h"
 #include "base/mutex.h"
 #include "base/timing_logger.h"
 #include "compilation_kind.h"
 #include "handle.h"
-#include "offsets.h"
 #include "interpreter/mterp/nterp.h"
 #include "jit/debugger_interface.h"
 #include "jit_options.h"
 #include "obj_ptr.h"
+#include "offsets.h"
 #include "thread_pool.h"
 
 namespace art HIDDEN {
@@ -280,7 +281,8 @@ class Jit {
   // It can be empty indicating there is no reference profile.
   void StartProfileSaver(const std::string& profile_filename,
                          const std::vector<std::string>& code_paths,
-                         const std::string& ref_profile_filename);
+                         const std::string& ref_profile_filename,
+                         AppInfo::CodeType code_type);
   void StopProfileSaver();
 
   void DumpForSigQuit(std::ostream& os) REQUIRES(!lock_);
diff --git a/runtime/jit/jit_code_cache.cc b/runtime/jit/jit_code_cache.cc
index 2b83eff44f..a8a03d4fdd 100644
--- a/runtime/jit/jit_code_cache.cc
+++ b/runtime/jit/jit_code_cache.cc
@@ -366,12 +366,12 @@ bool JitCodeCache::WaitForPotentialCollectionToComplete(Thread* self) {
 }
 
 static uintptr_t FromCodeToAllocation(const void* code) {
-  size_t alignment = GetInstructionSetCodeAlignment(kRuntimeISA);
+  size_t alignment = GetInstructionSetCodeAlignment(kRuntimeQuickCodeISA);
   return reinterpret_cast<uintptr_t>(code) - RoundUp(sizeof(OatQuickMethodHeader), alignment);
 }
 
 static const void* FromAllocationToCode(const uint8_t* alloc) {
-  size_t alignment = GetInstructionSetCodeAlignment(kRuntimeISA);
+  size_t alignment = GetInstructionSetCodeAlignment(kRuntimeQuickCodeISA);
   return reinterpret_cast<const void*>(alloc + RoundUp(sizeof(OatQuickMethodHeader), alignment));
 }
 
@@ -530,7 +530,8 @@ void JitCodeCache::FreeAllMethodHeaders(
       }
     });
     ForEachNativeDebugSymbol([&](const void* addr, size_t, const char* name) {
-      addr = AlignDown(addr, GetInstructionSetInstructionAlignment(kRuntimeISA));  // Thumb-bit.
+      addr = AlignDown(addr,
+                       GetInstructionSetInstructionAlignment(kRuntimeQuickCodeISA));  // Thumb-bit.
       bool res = debug_info.emplace(addr).second;
       CHECK(res) << "Duplicate debug info: " << addr << " " << name;
       CHECK_EQ(compiled_methods.count(addr), 1u) << "Extra debug info: " << addr << " " << name;
@@ -805,6 +806,9 @@ bool JitCodeCache::Commit(Thread* self,
 
             DCHECK(std::find(code_ptrs.begin(), code_ptrs.end(), code_ptr) == code_ptrs.end());
             it->second.emplace_back(code_ptr);
+
+            // `MethodType`s are strong GC roots and need write barrier.
+            WriteBarrier::ForEveryFieldWrite(method->GetDeclaringClass<kWithoutReadBarrier>());
             break;
           }
         }
@@ -891,10 +895,11 @@ bool JitCodeCache::RemoveMethodLocked(ArtMethod* method, bool release_memory) {
           FreeCodeAndData(it->second.GetCode());
         }
         jni_stubs_map_.erase(it);
-        zombie_jni_code_.erase(method);
       } else {
         it->first.UpdateShorty(it->second.GetMethods().front());
       }
+      zombie_jni_code_.erase(method);
+      processed_zombie_jni_code_.erase(method);
     }
   } else {
     for (auto it = method_code_map_.begin(); it != method_code_map_.end();) {
@@ -1195,19 +1200,11 @@ void JitCodeCache::RemoveUnmarkedCode(Thread* self) {
     WriterMutexLock mu2(self, *Locks::jit_mutator_lock_);
     ArtMethod* method = *it;
     auto stub = jni_stubs_map_.find(JniStubKey(method));
-    if (stub == jni_stubs_map_.end()) {
-      it = processed_zombie_jni_code_.erase(it);
-      continue;
-    }
+    DCHECK(stub != jni_stubs_map_.end()) << method->PrettyMethod();
     JniStubData& data = stub->second;
-    if (!data.IsCompiled() || !ContainsElement(data.GetMethods(), method)) {
-      it = processed_zombie_jni_code_.erase(it);
-    } else if (method->GetEntryPointFromQuickCompiledCode() ==
-            OatQuickMethodHeader::FromCodePointer(data.GetCode())->GetEntryPoint()) {
-      // The stub got reused for this method, remove ourselves from the zombie
-      // list.
-      it = processed_zombie_jni_code_.erase(it);
-    } else if (!GetLiveBitmap()->Test(FromCodeToAllocation(data.GetCode()))) {
+    DCHECK(data.IsCompiled());
+    DCHECK(ContainsElement(data.GetMethods(), method));
+    if (!GetLiveBitmap()->Test(FromCodeToAllocation(data.GetCode()))) {
       data.RemoveMethod(method);
       if (data.GetMethods().empty()) {
         OatQuickMethodHeader* header = OatQuickMethodHeader::FromCodePointer(data.GetCode());
@@ -1257,6 +1254,13 @@ void JitCodeCache::AddZombieCode(ArtMethod* method, const void* entry_point) {
 
 void JitCodeCache::AddZombieCodeInternal(ArtMethod* method, const void* code_ptr) {
   if (method->IsNative()) {
+    if (kIsDebugBuild) {
+      auto it = jni_stubs_map_.find(JniStubKey(method));
+      CHECK(it != jni_stubs_map_.end()) << method->PrettyMethod();
+      CHECK(it->second.IsCompiled()) << method->PrettyMethod();
+      CHECK_EQ(it->second.GetCode(), code_ptr) << method->PrettyMethod();
+      CHECK(ContainsElement(it->second.GetMethods(), method)) << method->PrettyMethod();
+    }
     zombie_jni_code_.insert(method);
   } else {
     CHECK(!ContainsElement(zombie_code_, code_ptr));
@@ -1370,7 +1374,7 @@ void JitCodeCache::DoCollection(Thread* self) {
 }
 
 OatQuickMethodHeader* JitCodeCache::LookupMethodHeader(uintptr_t pc, ArtMethod* method) {
-  static_assert(kRuntimeISA != InstructionSet::kThumb2, "kThumb2 cannot be a runtime ISA");
+  static_assert(kRuntimeQuickCodeISA != InstructionSet::kThumb2, "kThumb2 cannot be a runtime ISA");
   const void* pc_ptr = reinterpret_cast<const void*>(pc);
   if (!ContainsPc(pc_ptr)) {
     return nullptr;
@@ -1683,6 +1687,7 @@ bool JitCodeCache::NotifyCompilationOf(ArtMethod* method,
 
   if (UNLIKELY(method->IsNative())) {
     JniStubKey key(method);
+    MutexLock mu2(self, *Locks::jit_lock_);
     WriterMutexLock mu(self, *Locks::jit_mutator_lock_);
     auto it = jni_stubs_map_.find(key);
     bool new_compilation = false;
@@ -1701,6 +1706,10 @@ bool JitCodeCache::NotifyCompilationOf(ArtMethod* method,
       // changed these entrypoints to GenericJNI in preparation for a full GC, we may
       // as well change them back as this stub shall not be collected anyway and this
       // can avoid a few expensive GenericJNI calls.
+      for (ArtMethod* m : it->second.GetMethods()) {
+        zombie_jni_code_.erase(m);
+        processed_zombie_jni_code_.erase(m);
+      }
       data->UpdateEntryPoints(entrypoint);
     }
     return new_compilation;
diff --git a/runtime/jit/profile_saver.cc b/runtime/jit/profile_saver.cc
index 81cb384f62..733ad47ef3 100644
--- a/runtime/jit/profile_saver.cc
+++ b/runtime/jit/profile_saver.cc
@@ -22,11 +22,18 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#include <algorithm>
+#include <string>
+#include <utility>
+
+#include "android-base/file.h"
 #include "android-base/strings.h"
+#include "app_info.h"
 #include "art_method-inl.h"
 #include "base/compiler_filter.h"
 #include "base/logging.h"  // For VLOG.
 #include "base/pointer_size.h"
+#include "base/safe_map.h"
 #include "base/scoped_arena_containers.h"
 #include "base/stl_util.h"
 #include "base/systrace.h"
@@ -238,7 +245,7 @@ static bool IsProfileEmpty(const std::string& location) {
 
 bool ProfileSaver::IsFirstSave() {
   Thread* self = Thread::Current();
-  SafeMap<std::string, std::string> tracked_locations;
+  SafeMap<std::string, std::pair<std::string, AppInfo::CodeType>> tracked_locations;
   {
     // Make a copy so that we don't hold the lock while doing I/O.
     MutexLock mu(self, *Locks::profiler_lock_);
@@ -250,7 +257,7 @@ bool ProfileSaver::IsFirstSave() {
       return false;
     }
     const std::string& cur_profile = it.first;
-    const std::string& ref_profile = it.second;
+    const std::string& ref_profile = it.second.first;
 
     // Check if any profile is non empty. If so, then this is not the first save.
     if (!IsProfileEmpty(cur_profile) || !IsProfileEmpty(ref_profile)) {
@@ -770,13 +777,27 @@ bool ProfileSaver::ProcessProfilingInfo(bool force_save, /*out*/uint16_t* number
   // Resolve any new registered locations.
   ResolveTrackedLocations();
 
-  SafeMap<std::string, std::set<std::string>> tracked_locations;
+  std::vector<std::pair<std::string, std::set<std::string>>> tracked_locations;
+  SafeMap<std::string, AppInfo::CodeType> profile_to_code_type;
   {
     // Make a copy so that we don't hold the lock while doing I/O.
     MutexLock mu(Thread::Current(), *Locks::profiler_lock_);
-    tracked_locations = tracked_dex_base_locations_;
+    tracked_locations.assign(tracked_dex_base_locations_.begin(),
+                             tracked_dex_base_locations_.end());
+    for (const auto& [key, value] : tracked_profiles_) {
+      profile_to_code_type.Put(key, value.second);
+    }
   }
 
+  // Put "primary.prof" at the end. `artd` relies on the fact that "primary.prof" is the last one to
+  // write when it waits for a profile save to be done.
+  std::sort(tracked_locations.begin(),
+            tracked_locations.end(),
+            [&](const auto& pair1, const auto& pair2) {
+              return profile_to_code_type.Get(pair1.first) != AppInfo::CodeType::kPrimaryApk &&
+                     profile_to_code_type.Get(pair2.first) == AppInfo::CodeType::kPrimaryApk;
+            });
+
   bool profile_file_saved = false;
   if (number_of_new_methods != nullptr) {
     *number_of_new_methods = 0;
@@ -857,6 +878,8 @@ bool ProfileSaver::ProcessProfilingInfo(bool force_save, /*out*/uint16_t* number
         int64_t delta_number_of_classes =
             info.GetNumberOfResolvedClasses() - last_save_number_of_classes;
 
+        // Always write on a forced save. `artd` relies on the fact that profiles are always
+        // written when it waits for a forced profile save to be done.
         if (!force_save &&
             delta_number_of_methods < options_.GetMinMethodsToSave() &&
             delta_number_of_classes < options_.GetMinClassesToSave()) {
@@ -875,7 +898,7 @@ bool ProfileSaver::ProcessProfilingInfo(bool force_save, /*out*/uint16_t* number
         uint64_t bytes_written;
         // Force the save. In case the profile data is corrupted or the profile
         // has the wrong version this will "fix" the file to the correct format.
-        if (info.Save(filename, &bytes_written)) {
+        if (info.Save(filename, &bytes_written, force_save)) {
           // We managed to save the profile. Clear the cache stored during startup.
           if (profile_cache_it != profile_cache_.end()) {
             ProfileCompilationInfo *cached_info = profile_cache_it->second;
@@ -957,11 +980,12 @@ static bool ShouldProfileLocation(const std::string& location, bool profile_aot_
   return true;
 }
 
-void  ProfileSaver::Start(const ProfileSaverOptions& options,
-                          const std::string& output_filename,
-                          jit::JitCodeCache* jit_code_cache,
-                          const std::vector<std::string>& code_paths,
-                          const std::string& ref_profile_filename) {
+void ProfileSaver::Start(const ProfileSaverOptions& options,
+                         const std::string& output_filename,
+                         jit::JitCodeCache* jit_code_cache,
+                         const std::vector<std::string>& code_paths,
+                         const std::string& ref_profile_filename,
+                         AppInfo::CodeType code_type) {
   Runtime* const runtime = Runtime::Current();
   DCHECK(options.IsEnabled());
   DCHECK(runtime->GetJit() != nullptr);
@@ -1014,7 +1038,8 @@ void  ProfileSaver::Start(const ProfileSaverOptions& options,
     // apps which share the same runtime).
     DCHECK_EQ(instance_->jit_code_cache_, jit_code_cache);
     // Add the code_paths to the tracked locations.
-    instance_->AddTrackedLocations(output_filename, code_paths_to_profile, ref_profile_filename);
+    instance_->AddTrackedLocations(
+        output_filename, code_paths_to_profile, ref_profile_filename, code_type);
     return;
   }
 
@@ -1023,7 +1048,8 @@ void  ProfileSaver::Start(const ProfileSaverOptions& options,
       << ". With reference profile: " << ref_profile_filename;
 
   instance_ = new ProfileSaver(options, jit_code_cache);
-  instance_->AddTrackedLocations(output_filename, code_paths_to_profile, ref_profile_filename);
+  instance_->AddTrackedLocations(
+      output_filename, code_paths_to_profile, ref_profile_filename, code_type);
 
   // Create a new thread which does the saving.
   CHECK_PTHREAD_CALL(
@@ -1103,7 +1129,7 @@ static void AddTrackedLocationsToMap(const std::string& output_filename,
   // We should find a better way which allows us to do the tracking based on full paths.
   for (const std::string& path : code_paths) {
     size_t last_sep_index = path.find_last_of('/');
-    if (last_sep_index == path.size() - 1) {
+    if (path.empty() || last_sep_index == path.size() - 1) {
       // Should not happen, but anyone can register code paths so better be prepared and ignore
       // such locations.
       continue;
@@ -1116,23 +1142,18 @@ static void AddTrackedLocationsToMap(const std::string& output_filename,
     code_paths_and_filenames.push_back(filename);
   }
 
-  auto it = map->find(output_filename);
-  if (it == map->end()) {
-    map->Put(
-        output_filename,
-        std::set<std::string>(code_paths_and_filenames.begin(), code_paths_and_filenames.end()));
-  } else {
-    it->second.insert(code_paths_and_filenames.begin(), code_paths_and_filenames.end());
-  }
+  auto it = map->FindOrAdd(output_filename);
+  it->second.insert(code_paths_and_filenames.begin(), code_paths_and_filenames.end());
 }
 
 void ProfileSaver::AddTrackedLocations(const std::string& output_filename,
                                        const std::vector<std::string>& code_paths,
-                                       const std::string& ref_profile_filename) {
+                                       const std::string& ref_profile_filename,
+                                       AppInfo::CodeType code_type) {
   // Register the output profile and its reference profile.
   auto it = tracked_profiles_.find(output_filename);
   if (it == tracked_profiles_.end()) {
-    tracked_profiles_.Put(output_filename, ref_profile_filename);
+    tracked_profiles_.Put(output_filename, std::make_pair(ref_profile_filename, code_type));
   }
 
   // Add the code paths to the list of tracked location.
@@ -1199,9 +1220,8 @@ void ProfileSaver::ResolveTrackedLocations() {
   for (const auto& it : locations_to_be_resolved) {
     const std::string& filename = it.first;
     const std::set<std::string>& locations = it.second;
-    auto resolved_locations_it = resolved_locations_map.Put(
-        filename,
-        std::vector<std::string>(locations.size()));
+    auto resolved_locations_it = resolved_locations_map.Put(filename, std::vector<std::string>());
+    resolved_locations_it->second.reserve(locations.size());
 
     for (const auto& location : locations) {
       UniqueCPtr<const char[]> location_real(realpath(location.c_str(), nullptr));
diff --git a/runtime/jit/profile_saver.h b/runtime/jit/profile_saver.h
index ee99bf1594..c37545fa4b 100644
--- a/runtime/jit/profile_saver.h
+++ b/runtime/jit/profile_saver.h
@@ -17,6 +17,9 @@
 #ifndef ART_RUNTIME_JIT_PROFILE_SAVER_H_
 #define ART_RUNTIME_JIT_PROFILE_SAVER_H_
 
+#include <utility>
+
+#include "app_info.h"
 #include "base/mutex.h"
 #include "base/safe_map.h"
 #include "dex/method_reference.h"
@@ -38,7 +41,8 @@ class ProfileSaver {
                     const std::string& output_filename,
                     jit::JitCodeCache* jit_code_cache,
                     const std::vector<std::string>& code_paths,
-                    const std::string& ref_profile_filename)
+                    const std::string& ref_profile_filename,
+                    AppInfo::CodeType code_type)
       REQUIRES(!Locks::profiler_lock_, !instance_->wait_lock_);
 
   // Stops the profile saver thread.
@@ -92,8 +96,8 @@ class ProfileSaver {
 
   void AddTrackedLocations(const std::string& output_filename,
                            const std::vector<std::string>& code_paths,
-                           const std::string& ref_profile_filename)
-      REQUIRES(Locks::profiler_lock_);
+                           const std::string& ref_profile_filename,
+                           AppInfo::CodeType code_type) REQUIRES(Locks::profiler_lock_);
 
   // Fetches the current resolved classes and methods from the ClassLinker and stores them in the
   // profile_cache_ for later save.
@@ -134,10 +138,11 @@ class ProfileSaver {
       GUARDED_BY(Locks::profiler_lock_);
 
   // Collection of output profiles that the profile tracks.
-  // It maps output profile locations to reference profiles, and is used
-  // to determine if any profile is non-empty at the start of the ProfileSaver.
-  // This influences the time of the first ever save.
-  SafeMap<std::string, std::string> tracked_profiles_
+  // It maps output profile locations to reference profiles and code types.
+  // This is used to determine if any profile is non-empty at the start of the ProfileSaver, which
+  // influences the time of the first ever save.
+  // It's also used to determine the save order.
+  SafeMap<std::string, std::pair<std::string, AppInfo::CodeType>> tracked_profiles_
       GUARDED_BY(Locks::profiler_lock_);
 
   bool shutting_down_ GUARDED_BY(Locks::profiler_lock_);
diff --git a/runtime/jit/profiling_info_test.cc b/runtime/jit/profiling_info_test.cc
index 9b91c28ac5..41f75b87fc 100644
--- a/runtime/jit/profiling_info_test.cc
+++ b/runtime/jit/profiling_info_test.cc
@@ -46,15 +46,14 @@ class ProfileCompilationInfoTest : public CommonRuntimeTest {
   }
 
  protected:
-  std::vector<ArtMethod*> GetVirtualMethods(jobject class_loader,
-                                            const std::string& clazz) {
+  std::vector<ArtMethod*> GetVirtualMethods(jobject class_loader, const char* clazz) {
     ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
     Thread* self = Thread::Current();
     ScopedObjectAccess soa(self);
     StackHandleScope<1> hs(self);
     Handle<mirror::ClassLoader> h_loader(
         hs.NewHandle(self->DecodeJObject(class_loader)->AsClassLoader()));
-    ObjPtr<mirror::Class> klass = class_linker->FindClass(self, clazz.c_str(), h_loader);
+    ObjPtr<mirror::Class> klass = FindClass(clazz, h_loader);
 
     const auto pointer_size = class_linker->GetImagePointerSize();
     std::vector<ArtMethod*> methods;
diff --git a/runtime/jit/small_pattern_matcher.cc b/runtime/jit/small_pattern_matcher.cc
index 5dd116c560..1fc320f780 100644
--- a/runtime/jit/small_pattern_matcher.cc
+++ b/runtime/jit/small_pattern_matcher.cc
@@ -177,11 +177,7 @@ const void* SmallPatternMatcher::TryMatch(ArtMethod* method) REQUIRES_SHARED(Loc
       REQUIRES_SHARED(Locks::mutator_lock_) {
     uint16_t method_idx = instruction.VRegB_35c();
     Thread* self = Thread::Current();
-    ArtMethod* target_method =
-        class_linker->ResolveMethod<ClassLinker::ResolveMode::kNoChecks>(self,
-                                                                         method_idx,
-                                                                         method,
-                                                                         kDirect);
+    ArtMethod* target_method = class_linker->ResolveMethodId(method_idx, method);
     if (target_method == nullptr) {
       self->ClearException();
       return false;
diff --git a/runtime/jni/java_vm_ext.cc b/runtime/jni/java_vm_ext.cc
index 60b436984d..2c17537636 100644
--- a/runtime/jni/java_vm_ext.cc
+++ b/runtime/jni/java_vm_ext.cc
@@ -353,7 +353,24 @@ class Libraries {
     Thread* const self = Thread::Current();
     std::vector<SharedLibrary*> unload_libraries;
     {
-      MutexLock mu(self, *Locks::jni_libraries_lock_);
+      // jni_libraries_lock_ appears to be held long enough that we just retry once, rather than
+      // spinning.
+      int retries = 0;
+      static constexpr int MAX_RETRIES = 5;
+      while (!Locks::jni_libraries_lock_->ExclusiveTryLock(self)) {
+        if (Runtime::Current()->IsZygote()) {
+          // Do not risk deferring to the child processes.
+          Locks::jni_libraries_lock_->ExclusiveLock(self);
+          break;
+        }
+        if (++retries > MAX_RETRIES) {
+          // We do not want to block indefinitely here, for fear of timeouts. See b/374209523.
+          LOG(WARNING) << "Deferring native library unloading due to contention";
+          return;
+        }
+        ScopedTrace("sleep 1 msec for jni_libraries_lock_");
+        usleep(1000);
+      }
       for (auto it = libraries_.begin(); it != libraries_.end(); ) {
         SharedLibrary* const library = it->second;
         // If class loader is null then it was unloaded, call JNI_OnUnload.
@@ -367,6 +384,7 @@ class Libraries {
           ++it;
         }
       }
+      Locks::jni_libraries_lock_->ExclusiveUnlock(self);
     }
     ScopedThreadSuspension sts(self, ThreadState::kNative);
     // Do this without holding the jni libraries lock to prevent possible deadlocks.
diff --git a/runtime/jni/jni_internal.cc b/runtime/jni/jni_internal.cc
index 51350dc713..f1ea88da4e 100644
--- a/runtime/jni/jni_internal.cc
+++ b/runtime/jni/jni_internal.cc
@@ -535,7 +535,7 @@ ArtField* FindFieldJNI(const ScopedObjectAccess& soa,
     DCHECK(field == nullptr);
   } else if (sig[1] != '\0') {
     Handle<mirror::ClassLoader> class_loader(hs.NewHandle(c->GetClassLoader()));
-    field_type = class_linker->FindClass(soa.Self(), sig, class_loader);
+    field_type = class_linker->FindClass(soa.Self(), sig, strlen(sig), class_loader);
   } else {
     field_type = class_linker->FindPrimitiveClass(*sig);
   }
@@ -675,14 +675,11 @@ class JNI {
     ClassLinker* class_linker = runtime->GetClassLinker();
     std::string descriptor(NormalizeJniClassDescriptor(name));
     ScopedObjectAccess soa(env);
-    ObjPtr<mirror::Class> c = nullptr;
-    if (runtime->IsStarted()) {
-      StackHandleScope<1> hs(soa.Self());
-      Handle<mirror::ClassLoader> class_loader(hs.NewHandle(GetClassLoader<kEnableIndexIds>(soa)));
-      c = class_linker->FindClass(soa.Self(), descriptor.c_str(), class_loader);
-    } else {
-      c = class_linker->FindSystemClass(soa.Self(), descriptor.c_str());
-    }
+    StackHandleScope<1> hs(soa.Self());
+    Handle<mirror::ClassLoader> class_loader = hs.NewHandle(
+        runtime->IsStarted() ? GetClassLoader<kEnableIndexIds>(soa) : nullptr);
+    ObjPtr<mirror::Class> c = class_linker->FindClass(
+        soa.Self(), descriptor.c_str(), descriptor.length(), class_loader);
     return soa.AddLocalReference<jclass>(c);
   }
 
diff --git a/runtime/jni/jni_internal_test.cc b/runtime/jni/jni_internal_test.cc
index ed97e4d4c8..6115556940 100644
--- a/runtime/jni/jni_internal_test.cc
+++ b/runtime/jni/jni_internal_test.cc
@@ -624,7 +624,7 @@ class JniInternalTest : public CommonRuntimeTest {
         StackHandleScope<1> hs(soa.Self());
         Handle<mirror::ClassLoader> loader(
             hs.NewHandle(soa.Decode<mirror::ClassLoader>(class_loader_)));
-        ObjPtr<mirror::Class> c = class_linker_->FindClass(soa.Self(), "LMyClassNatives;", loader);
+        ObjPtr<mirror::Class> c = FindClass("LMyClassNatives;", loader);
         const auto pointer_size = class_linker_->GetImagePointerSize();
         ArtMethod* method = c->FindClassMethod(method_name, method_sig, pointer_size);
         ASSERT_TRUE(method != nullptr) << method_name << " " << method_sig;
diff --git a/runtime/method_handles.cc b/runtime/method_handles.cc
index c4e4d206a4..161fa2cd01 100644
--- a/runtime/method_handles.cc
+++ b/runtime/method_handles.cc
@@ -463,11 +463,13 @@ ArtMethod* RefineTargetMethod(Thread* self,
           target_method, kRuntimePointerSize);
     }
   } else if (handle_kind == mirror::MethodHandle::Kind::kInvokeDirect) {
-    // String constructors are a special case, they are replaced with
-    // StringFactory methods.
-    if (target_method->IsStringConstructor()) {
-      DCHECK(handle_type->GetRType()->IsStringClass());
-      return WellKnownClasses::StringInitToStringFactory(target_method);
+    // String constructors are replaced with static StringFactory methods when a MethodHandle
+    // object is created.
+    DCHECK(!target_method->IsStringConstructor());
+    ObjPtr<mirror::Object> receiver(shadow_frame.GetVRegReference(receiver_reg));
+    if (receiver == nullptr) {
+      ThrowNullPointerException("null receiver");
+      return nullptr;
     }
   } else if (handle_kind == mirror::MethodHandle::Kind::kInvokeSuper) {
     // Note that we're not dynamically dispatching on the type of the receiver
@@ -772,11 +774,17 @@ static bool DoMethodHandleInvokeMethod(Thread* self,
     first_dest_reg = num_regs - accessor.InsSize();
     // Parameter registers go at the end of the shadow frame.
     DCHECK_NE(first_dest_reg, (size_t)-1);
-  } else {
+  } else if (called_method->IsNative() || called_method->IsProxyMethod()) {
     // No local regs for proxy and native methods.
-    DCHECK(called_method->IsNative() || called_method->IsProxyMethod());
     num_regs = GetInsForProxyOrNativeMethod(called_method);
     first_dest_reg = 0;
+  } else {
+    if (called_method->IsDefaultConflicting()) {
+      ThrowIncompatibleClassChangeErrorForMethodConflict(called_method);
+    } else {
+      ThrowAbstractMethodError(called_method);
+    }
+    return false;
   }
 
   const char* old_cause = self->StartAssertNoThreadSuspension("DoMethodHandleInvokeMethod");
diff --git a/runtime/metrics/statsd.cc b/runtime/metrics/statsd.cc
index e6d26d9746..605dadbc9b 100644
--- a/runtime/metrics/statsd.cc
+++ b/runtime/metrics/statsd.cc
@@ -442,6 +442,20 @@ void SetupCallbackForDeviceStatus() {
       statsd::ART_DEVICE_STATUS, /*metadata=*/nullptr, DeviceStatusCallback, /*cookie=*/nullptr);
 }
 
+void ReportDeviceMetrics() {
+  Runtime* runtime = Runtime::Current();
+  int32_t boot_image_status;
+  if (runtime->GetHeap()->HasBootImageSpace() && !runtime->HasImageWithProfile()) {
+    boot_image_status = statsd::ART_DEVICE_DATUM_REPORTED__BOOT_IMAGE_STATUS__STATUS_FULL;
+  } else if (runtime->GetHeap()->HasBootImageSpace() &&
+             runtime->GetHeap()->GetBootImageSpaces()[0]->GetProfileFiles().empty()) {
+    boot_image_status = statsd::ART_DEVICE_DATUM_REPORTED__BOOT_IMAGE_STATUS__STATUS_MINIMAL;
+  } else {
+    boot_image_status = statsd::ART_DEVICE_DATUM_REPORTED__BOOT_IMAGE_STATUS__STATUS_NONE;
+  }
+  statsd::stats_write(statsd::ART_DEVICE_DATUM_REPORTED, boot_image_status);
+}
+
 }  // namespace metrics
 }  // namespace art
 
diff --git a/runtime/metrics/statsd.h b/runtime/metrics/statsd.h
index 00bd595ca1..f4c8a5d295 100644
--- a/runtime/metrics/statsd.h
+++ b/runtime/metrics/statsd.h
@@ -30,9 +30,11 @@ class MetricsBackend;
 #ifdef __ANDROID__
 std::unique_ptr<MetricsBackend> CreateStatsdBackend();
 void SetupCallbackForDeviceStatus();
+void ReportDeviceMetrics();
 #else
 inline std::unique_ptr<MetricsBackend> CreateStatsdBackend() { return nullptr; }
 inline void SetupCallbackForDeviceStatus() {}
+inline void ReportDeviceMetrics() {}
 #endif
 
 }  // namespace metrics
diff --git a/runtime/mirror/class-inl.h b/runtime/mirror/class-inl.h
index f60a554f91..3d3c71759b 100644
--- a/runtime/mirror/class-inl.h
+++ b/runtime/mirror/class-inl.h
@@ -959,26 +959,26 @@ inline std::string_view Class::GetDescriptorView() {
   return GetDexFile().GetTypeDescriptorView(GetDexTypeIndex());
 }
 
-inline bool Class::DescriptorEquals(const char* match) {
+inline bool Class::DescriptorEquals(std::string_view match) {
   ObjPtr<mirror::Class> klass = this;
   while (klass->IsArrayClass()) {
-    if (match[0] != '[') {
+    if (UNLIKELY(match.empty()) || match[0] != '[') {
       return false;
     }
-    ++match;
+    match.remove_prefix(1u);
     // No read barrier needed, we're reading a chain of constant references for comparison
     // with null. Then we follow up below with reading constant references to read constant
     // primitive data in both proxy and non-proxy paths. See ReadBarrierOption.
     klass = klass->GetComponentType<kDefaultVerifyFlags, kWithoutReadBarrier>();
   }
   if (klass->IsPrimitive()) {
-    return strcmp(Primitive::Descriptor(klass->GetPrimitiveType()), match) == 0;
-  } else if (klass->IsProxyClass()) {
+    return match.length() == 1u && match[0] == Primitive::Descriptor(klass->GetPrimitiveType())[0];
+  } else if (UNLIKELY(klass->IsProxyClass())) {
     return klass->ProxyDescriptorEquals(match);
   } else {
     const DexFile& dex_file = klass->GetDexFile();
     const dex::TypeId& type_id = dex_file.GetTypeId(klass->GetDexTypeIndex());
-    return strcmp(dex_file.GetTypeDescriptor(type_id), match) == 0;
+    return dex_file.GetTypeDescriptorView(type_id) == match;
   }
 }
 
@@ -1284,7 +1284,7 @@ inline void Class::FixupNativePointers(Class* dest,
 }
 
 inline bool Class::CanAccess(ObjPtr<Class> that) {
-  return that->IsPublic() || this->IsInSamePackage(that);
+  return this == that || that->IsPublic() || this->IsInSamePackage(that);
 }
 
 
diff --git a/runtime/mirror/class.cc b/runtime/mirror/class.cc
index 43dbc43115..a122393171 100644
--- a/runtime/mirror/class.cc
+++ b/runtime/mirror/class.cc
@@ -480,17 +480,10 @@ void Class::SetReferenceInstanceOffsets(uint32_t new_reference_offsets) {
 }
 
 bool Class::IsInSamePackage(std::string_view descriptor1, std::string_view descriptor2) {
-  size_t i = 0;
-  size_t min_length = std::min(descriptor1.size(), descriptor2.size());
-  while (i < min_length && descriptor1[i] == descriptor2[i]) {
-    ++i;
-  }
-  if (descriptor1.find('/', i) != std::string_view::npos ||
-      descriptor2.find('/', i) != std::string_view::npos) {
-    return false;
-  } else {
-    return true;
-  }
+  static_assert(std::string_view::npos + 1u == 0u);
+  size_t d1_after_package = descriptor1.rfind('/') + 1u;
+  return descriptor2.starts_with(descriptor1.substr(0u, d1_after_package)) &&
+         descriptor2.find('/', d1_after_package) == std::string_view::npos;
 }
 
 bool Class::IsInSamePackage(ObjPtr<Class> that) {
@@ -515,8 +508,18 @@ bool Class::IsInSamePackage(ObjPtr<Class> that) {
     return true;
   }
   // Compare the package part of the descriptor string.
-  std::string temp1, temp2;
-  return IsInSamePackage(klass1->GetDescriptor(&temp1), klass2->GetDescriptor(&temp2));
+  if (UNLIKELY(klass1->IsProxyClass()) || UNLIKELY(klass2->IsProxyClass())) {
+    std::string temp1, temp2;
+    return IsInSamePackage(klass1->GetDescriptor(&temp1), klass2->GetDescriptor(&temp2));
+  }
+  if (UNLIKELY(klass1->IsPrimitive()) || UNLIKELY(klass2->IsPrimitive())) {
+    if (klass1->IsPrimitive() && klass2->IsPrimitive()) {
+      return true;
+    }
+    ObjPtr<Class> other_class = klass1->IsPrimitive() ? klass2 : klass1;
+    return other_class->GetDescriptorView().find('/') == std::string_view::npos;
+  }
+  return IsInSamePackage(klass1->GetDescriptorView(), klass2->GetDescriptorView());
 }
 
 bool Class::IsThrowableClass() {
@@ -1879,7 +1882,7 @@ bool Class::ProxyDescriptorEquals(ObjPtr<mirror::Class> match) {
   return descriptor == match_descriptor;
 }
 
-bool Class::ProxyDescriptorEquals(const char* match) {
+bool Class::ProxyDescriptorEquals(std::string_view match) {
   DCHECK(IsProxyClass());
   std::string storage;
   const char* descriptor = GetDescriptor(&storage);
diff --git a/runtime/mirror/class.h b/runtime/mirror/class.h
index 6384bfabc0..9560f985ac 100644
--- a/runtime/mirror/class.h
+++ b/runtime/mirror/class.h
@@ -1252,7 +1252,7 @@ class EXPORT MANAGED Class final : public Object {
   const char* GetDescriptor(std::string* storage) REQUIRES_SHARED(Locks::mutator_lock_);
 
   bool DescriptorEquals(ObjPtr<mirror::Class> match) REQUIRES_SHARED(Locks::mutator_lock_);
-  bool DescriptorEquals(const char* match) REQUIRES_SHARED(Locks::mutator_lock_);
+  bool DescriptorEquals(std::string_view match) REQUIRES_SHARED(Locks::mutator_lock_);
 
   uint32_t DescriptorHash() REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -1440,11 +1440,10 @@ class EXPORT MANAGED Class final : public Object {
   ALWAYS_INLINE uint32_t GetDirectMethodsStartOffset() REQUIRES_SHARED(Locks::mutator_lock_);
 
   bool ProxyDescriptorEquals(ObjPtr<mirror::Class> match) REQUIRES_SHARED(Locks::mutator_lock_);
-  bool ProxyDescriptorEquals(const char* match) REQUIRES_SHARED(Locks::mutator_lock_);
+  bool ProxyDescriptorEquals(std::string_view match) REQUIRES_SHARED(Locks::mutator_lock_);
   static uint32_t UpdateHashForProxyClass(uint32_t hash, ObjPtr<mirror::Class> proxy_class)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-
   template<VerifyObjectFlags kVerifyFlags>
   void GetAccessFlagsDCheck() REQUIRES_SHARED(Locks::mutator_lock_);
 
diff --git a/runtime/mirror/class_ext.cc b/runtime/mirror/class_ext.cc
index 49177aca02..b4ab2dc26a 100644
--- a/runtime/mirror/class_ext.cc
+++ b/runtime/mirror/class_ext.cc
@@ -84,9 +84,7 @@ bool ClassExt::ExtendObsoleteArrays(Handle<ClassExt> h_this, Thread* self, uint3
   }
   Handle<ObjectArray<DexCache>> new_dex_caches(hs.NewHandle<ObjectArray<DexCache>>(
       ObjectArray<DexCache>::Alloc(self,
-                                   cl->FindClass(self,
-                                                 "[Ljava/lang/DexCache;",
-                                                 ScopedNullHandle<ClassLoader>()),
+                                   cl->FindSystemClass(self, "[Ljava/lang/DexCache;"),
                                    new_len)));
   if (new_dex_caches.IsNull()) {
     // Fail.
diff --git a/runtime/mirror/dex_cache_test.cc b/runtime/mirror/dex_cache_test.cc
index 9ca8d307ba..1429bb3e04 100644
--- a/runtime/mirror/dex_cache_test.cc
+++ b/runtime/mirror/dex_cache_test.cc
@@ -79,11 +79,9 @@ TEST_F(DexCacheTest, TestResolvedFieldAccess) {
   StackHandleScope<3> hs(soa.Self());
   Handle<mirror::ClassLoader> class_loader(hs.NewHandle(
       soa.Decode<mirror::ClassLoader>(jclass_loader)));
-  Handle<mirror::Class> klass1 =
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "Lpackage1/Package1;", class_loader));
+  Handle<mirror::Class> klass1 = hs.NewHandle(FindClass("Lpackage1/Package1;", class_loader));
   ASSERT_TRUE(klass1 != nullptr);
-  Handle<mirror::Class> klass2 =
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "Lpackage2/Package2;", class_loader));
+  Handle<mirror::Class> klass2 = hs.NewHandle(FindClass("Lpackage2/Package2;", class_loader));
   ASSERT_TRUE(klass2 != nullptr);
   EXPECT_OBJ_PTR_EQ(klass1->GetDexCache(), klass2->GetDexCache());
 
@@ -107,8 +105,7 @@ TEST_F(DexCacheMethodHandlesTest, TestResolvedMethodTypes) {
   Handle<mirror::ClassLoader> class_loader(hs.NewHandle(
       soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
-  Handle<mirror::Class> method_types(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LMethodTypes;", class_loader)));
+  Handle<mirror::Class> method_types = hs.NewHandle(FindClass("LMethodTypes;", class_loader));
   class_linker_->EnsureInitialized(soa.Self(), method_types, true, true);
 
   ArtMethod* method1 = method_types->FindClassMethod(
diff --git a/runtime/mirror/method_type_test.cc b/runtime/mirror/method_type_test.cc
index 9d23f8f23d..c5ab7dd522 100644
--- a/runtime/mirror/method_type_test.cc
+++ b/runtime/mirror/method_type_test.cc
@@ -32,43 +32,48 @@
 namespace art HIDDEN {
 namespace mirror {
 
-class MethodTypeTest : public CommonRuntimeTest {};
+class MethodTypeTest : public CommonRuntimeTest {
+ protected:
+  ObjPtr<mirror::MethodType> CreateMethodType(const std::string& return_type,
+                                              const std::vector<std::string>& param_types);
+};
 
 static std::string FullyQualifiedType(const std::string& shorthand) {
   return "Ljava/lang/" + shorthand + ";";
 }
 
-ObjPtr<mirror::Class> FindClass(Thread* self, ClassLinker* const cl, const std::string& shorthand)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
-  StackHandleScope<1> hs(self);
-  Handle<mirror::ClassLoader> boot_class_loader = hs.NewHandle<mirror::ClassLoader>(nullptr);
+std::string ExpandShortHand(const std::string& shorthand) {
   if (shorthand.size() == 1) {
-    return cl->FindSystemClass(self, shorthand.c_str());
+    return shorthand;
   } else if (shorthand.find('/') == std::string::npos) {
-    return cl->FindClass(self, FullyQualifiedType(shorthand).c_str(), boot_class_loader);
+    return FullyQualifiedType(shorthand);
   } else {
-    return cl->FindClass(self, shorthand.c_str(), boot_class_loader);
+    return shorthand;
   }
 }
 
-static ObjPtr<mirror::MethodType> CreateMethodType(const std::string& return_type,
-                                                   const std::vector<std::string>& param_types) {
+ObjPtr<mirror::MethodType> MethodTypeTest::CreateMethodType(
+    const std::string& return_type,
+    const std::vector<std::string>& param_types) {
   Runtime* const runtime = Runtime::Current();
-  ClassLinker* const class_linker = runtime->GetClassLinker();
   Thread* const self = Thread::Current();
 
   ScopedObjectAccess soa(self);
   StackHandleScope<2> hs(soa.Self());
 
-  Handle<mirror::Class> return_clazz = hs.NewHandle(FindClass(self, class_linker, return_type));
+  ScopedNullHandle<mirror::ClassLoader> boot_class_loader;
+  Handle<mirror::Class> return_clazz =
+      hs.NewHandle(FindClass(ExpandShortHand(return_type).c_str(), boot_class_loader));
   CHECK(return_clazz != nullptr);
 
   ObjPtr<mirror::Class> class_array_type =
-      GetClassRoot<mirror::ObjectArray<mirror::Class>>(class_linker);
+      GetClassRoot<mirror::ObjectArray<mirror::Class>>(class_linker_);
   Handle<mirror::ObjectArray<mirror::Class>> param_classes = hs.NewHandle(
       mirror::ObjectArray<mirror::Class>::Alloc(self, class_array_type, param_types.size()));
+  CHECK(param_classes != nullptr);
   for (uint32_t i = 0; i < param_types.size(); ++i) {
-    ObjPtr<mirror::Class> param = FindClass(self, class_linker, param_types[i]);
+    ObjPtr<mirror::Class> param =
+        FindClass(ExpandShortHand(param_types[i]).c_str(), boot_class_loader);
     CHECK(!param.IsNull());
     param_classes->Set(i, param);
   }
diff --git a/runtime/mirror/object-inl.h b/runtime/mirror/object-inl.h
index 6a6f50347c..9e807d1c5b 100644
--- a/runtime/mirror/object-inl.h
+++ b/runtime/mirror/object-inl.h
@@ -585,6 +585,23 @@ inline bool Object::CasFieldStrongSequentiallyConsistent64(MemberOffset field_of
   return success;
 }
 
+template <bool kTransactionActive, bool kCheckTransaction, VerifyObjectFlags kVerifyFlags>
+inline int64_t Object::CaeFieldStrongSequentiallyConsistent64(MemberOffset field_offset,
+                                                              int64_t old_value,
+                                                              int64_t new_value) {
+  VerifyTransaction<kTransactionActive, kCheckTransaction>();
+  Verify<kVerifyFlags>();
+  uint8_t* raw_addr = reinterpret_cast<uint8_t*>(this) + field_offset.Int32Value();
+  Atomic<int64_t>* atomic_addr = reinterpret_cast<Atomic<int64_t>*>(raw_addr);
+  int64_t found_value =
+      atomic_addr->CompareAndExchangeStrongSequentiallyConsistent(old_value, new_value);
+  if (kTransactionActive && found_value == old_value) {
+    Runtime::Current()->GetClassLinker()->RecordWriteField64(
+        this, field_offset, old_value, /*is_volatile=*/true);
+  }
+  return found_value;
+}
+
 /*
  * Returns a pointer to an object representing what the field points to, not an
  * object representing the field.
diff --git a/runtime/mirror/object.h b/runtime/mirror/object.h
index 97e218b4de..2b04a55c73 100644
--- a/runtime/mirror/object.h
+++ b/runtime/mirror/object.h
@@ -550,14 +550,22 @@ class EXPORT MANAGED LOCKABLE Object {
                                             int64_t new_value)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  template<bool kTransactionActive,
-           bool kCheckTransaction = true,
-           VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
+  template <bool kTransactionActive,
+            bool kCheckTransaction = true,
+            VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
   bool CasFieldStrongSequentiallyConsistent64(MemberOffset field_offset,
                                               int64_t old_value,
                                               int64_t new_value)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  template <bool kTransactionActive,
+            bool kCheckTransaction = true,
+            VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags>
+  int64_t CaeFieldStrongSequentiallyConsistent64(MemberOffset field_offset,
+                                                 int64_t old_value,
+                                                 int64_t new_value)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   template<bool kTransactionActive,
            bool kCheckTransaction = true,
            VerifyObjectFlags kVerifyFlags = kDefaultVerifyFlags,
diff --git a/runtime/mirror/object_test.cc b/runtime/mirror/object_test.cc
index f879b805a9..579ccdce01 100644
--- a/runtime/mirror/object_test.cc
+++ b/runtime/mirror/object_test.cc
@@ -407,8 +407,7 @@ TEST_F(ObjectTest, StaticFieldFromCode) {
 
   StackHandleScope<3> hs(soa.Self());
   Handle<mirror::ClassLoader> loader(hs.NewHandle(soa.Decode<ClassLoader>(class_loader)));
-  Handle<Class> klass =
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LStaticsFromCode;", loader));
+  Handle<Class> klass = hs.NewHandle(FindClass("LStaticsFromCode;", loader));
   ArtMethod* clinit = klass->FindClassInitializer(kRuntimePointerSize);
   const dex::TypeId* klass_type_id = dex_file->FindTypeId("LStaticsFromCode;");
   ASSERT_TRUE(klass_type_id != nullptr);
@@ -534,7 +533,6 @@ TEST_F(ObjectTest, StringLength) {
 TEST_F(ObjectTest, DescriptorCompare) {
   // Two classloaders conflicts in compile_time_class_paths_.
   ScopedObjectAccess soa(Thread::Current());
-  ClassLinker* linker = class_linker_;
 
   jobject jclass_loader_1 = LoadDex("ProtoCompare");
   jobject jclass_loader_2 = LoadDex("ProtoCompare2");
@@ -542,11 +540,9 @@ TEST_F(ObjectTest, DescriptorCompare) {
   Handle<ClassLoader> class_loader_1(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader_1)));
   Handle<ClassLoader> class_loader_2(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader_2)));
 
-  Handle<Class> klass1 =
-      hs.NewHandle(linker->FindClass(soa.Self(), "LProtoCompare;", class_loader_1));
+  Handle<Class> klass1 = hs.NewHandle(FindClass("LProtoCompare;", class_loader_1));
   ASSERT_TRUE(klass1 != nullptr);
-  Handle<Class> klass2 =
-      hs.NewHandle(linker->FindClass(soa.Self(), "LProtoCompare2;", class_loader_2));
+  Handle<Class> klass2 = hs.NewHandle(FindClass("LProtoCompare2;", class_loader_2));
   ASSERT_TRUE(klass2 != nullptr);
 
   ArtMethod* m1_1 = klass1->GetVirtualMethod(0, kRuntimePointerSize);
@@ -586,8 +582,8 @@ TEST_F(ObjectTest, InstanceOf) {
   StackHandleScope<10> hs(soa.Self());
   Handle<ClassLoader> class_loader(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader)));
 
-  Handle<Class> X = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LX;", class_loader));
-  Handle<Class> Y = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LY;", class_loader));
+  Handle<Class> X = hs.NewHandle(FindClass("LX;", class_loader));
+  Handle<Class> Y = hs.NewHandle(FindClass("LY;", class_loader));
   ASSERT_TRUE(X != nullptr);
   ASSERT_TRUE(Y != nullptr);
 
@@ -625,8 +621,8 @@ TEST_F(ObjectTest, IsAssignableFrom) {
   jobject jclass_loader = LoadDex("XandY");
   StackHandleScope<5> hs(soa.Self());
   Handle<ClassLoader> class_loader(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader)));
-  Handle<Class> X = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LX;", class_loader));
-  Handle<Class> Y = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LY;", class_loader));
+  Handle<Class> X = hs.NewHandle(FindClass("LX;", class_loader));
+  Handle<Class> Y = hs.NewHandle(FindClass("LY;", class_loader));
 
   EXPECT_TRUE(X->IsAssignableFrom(X.Get()));
   EXPECT_TRUE(X->IsAssignableFrom(Y.Get()));
@@ -665,17 +661,17 @@ TEST_F(ObjectTest, IsAssignableFromArray) {
   jobject jclass_loader = LoadDex("XandY");
   StackHandleScope<14> hs(soa.Self());
   Handle<ClassLoader> class_loader(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader)));
-  Handle<Class> X = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LX;", class_loader));
-  Handle<Class> Y = hs.NewHandle(class_linker_->FindClass(soa.Self(), "LY;", class_loader));
+  Handle<Class> X = hs.NewHandle(FindClass("LX;", class_loader));
+  Handle<Class> Y = hs.NewHandle(FindClass("LY;", class_loader));
   ASSERT_TRUE(X != nullptr);
   ASSERT_TRUE(Y != nullptr);
 
-  Handle<Class> YA = hs.NewHandle(class_linker_->FindClass(soa.Self(), "[LY;", class_loader));
-  Handle<Class> YAA = hs.NewHandle(class_linker_->FindClass(soa.Self(), "[[LY;", class_loader));
+  Handle<Class> YA = hs.NewHandle(FindClass("[LY;", class_loader));
+  Handle<Class> YAA = hs.NewHandle(FindClass("[[LY;", class_loader));
   ASSERT_TRUE(YA != nullptr);
   ASSERT_TRUE(YAA != nullptr);
 
-  Handle<Class> XAA = hs.NewHandle(class_linker_->FindClass(soa.Self(), "[[LX;", class_loader));
+  Handle<Class> XAA = hs.NewHandle(FindClass("[[LX;", class_loader));
   ASSERT_TRUE(XAA != nullptr);
 
   Handle<Class> O = hs.NewHandle(class_linker_->FindSystemClass(soa.Self(), "Ljava/lang/Object;"));
@@ -797,8 +793,7 @@ TEST_F(ObjectTest, ObjectPointer) {
   jobject jclass_loader = LoadDex("XandY");
   StackHandleScope<2> hs(soa.Self());
   Handle<ClassLoader> class_loader(hs.NewHandle(soa.Decode<ClassLoader>(jclass_loader)));
-  Handle<mirror::Class> h_X(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), "LX;", class_loader)));
+  Handle<mirror::Class> h_X = hs.NewHandle(FindClass("LX;", class_loader));
 
   if (kObjPtrPoisoning) {
     ObjPtr<mirror::Object> null_ptr;
@@ -816,7 +811,7 @@ TEST_F(ObjectTest, ObjectPointer) {
     EXPECT_TRUE(X.Ptr() != nullptr);
     EXPECT_OBJ_PTR_EQ(h_X.Get(), X);
     // FindClass may cause thread suspension, it should invalidate X.
-    ObjPtr<Class> Y(class_linker_->FindClass(soa.Self(), "LY;", class_loader));
+    ObjPtr<Class> Y = FindClass("LY;", class_loader);
     EXPECT_TRUE(!Y.IsNull());
     EXPECT_TRUE(Y.IsValid());
     EXPECT_TRUE(Y.Ptr() != nullptr);
diff --git a/runtime/mirror/var_handle_test.cc b/runtime/mirror/var_handle_test.cc
index 22d1e4a6d4..bb7753c42a 100644
--- a/runtime/mirror/var_handle_test.cc
+++ b/runtime/mirror/var_handle_test.cc
@@ -137,6 +137,26 @@ class VarHandleTest : public CommonRuntimeTest {
     return AccessModesBitMask(first) | AccessModesBitMask(args...);
   }
 
+  ObjPtr<MethodType> MethodTypeOf(const std::string& method_descriptor);
+
+  template <typename VH>
+  bool AccessModeExactMatch(Handle<VH> vh,
+                            VarHandle::AccessMode access_mode,
+                            const char* descriptor)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  template <typename VH>
+  bool AccessModeWithConversionsMatch(Handle<VH> vh,
+                                      VarHandle::AccessMode access_mode,
+                                      const char* descriptor)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  template <typename VH>
+  bool AccessModeNoMatch(Handle<VH> vh,
+                         VarHandle::AccessMode access_mode,
+                         const char* descriptor)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
  private:
   static void InitializeVarHandle(ObjPtr<VarHandle> vh,
                                   Handle<Class> var_type,
@@ -169,7 +189,7 @@ class VarHandleTest : public CommonRuntimeTest {
 
 // Convenience method for constructing MethodType instances from
 // well-formed method descriptors.
-static ObjPtr<MethodType> MethodTypeOf(const std::string& method_descriptor) {
+ObjPtr<MethodType> VarHandleTest::MethodTypeOf(const std::string& method_descriptor) {
   std::vector<std::string> descriptors;
 
   auto it = method_descriptor.cbegin();
@@ -226,10 +246,9 @@ static ObjPtr<MethodType> MethodTypeOf(const std::string& method_descriptor) {
       ObjectArray<Class>::Alloc(Thread::Current(), array_of_class, ptypes_count));
   Handle<mirror::ClassLoader> boot_class_loader = hs.NewHandle<mirror::ClassLoader>(nullptr);
   for (int i = 0; i < ptypes_count; ++i) {
-    ptypes->Set(i, class_linker->FindClass(self, descriptors[i].c_str(), boot_class_loader));
+    ptypes->Set(i, FindClass(descriptors[i].c_str(), boot_class_loader));
   }
-  Handle<Class> rtype =
-      hs.NewHandle(class_linker->FindClass(self, descriptors.back().c_str(), boot_class_loader));
+  Handle<Class> rtype = hs.NewHandle(FindClass(descriptors.back().c_str(), boot_class_loader));
   return MethodType::Create(self, rtype, ptypes);
 }
 
@@ -242,10 +261,9 @@ static bool AccessModeMatch(ObjPtr<VarHandle> vh,
 }
 
 template <typename VH>
-static bool AccessModeExactMatch(Handle<VH> vh,
-                                 VarHandle::AccessMode access_mode,
-                                 const char* descriptor)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
+bool VarHandleTest::AccessModeExactMatch(Handle<VH> vh,
+                                         VarHandle::AccessMode access_mode,
+                                         const char* descriptor) {
   ObjPtr<MethodType> method_type = MethodTypeOf(descriptor);
   return AccessModeMatch(vh.Get(),
                          access_mode,
@@ -254,10 +272,9 @@ static bool AccessModeExactMatch(Handle<VH> vh,
 }
 
 template <typename VH>
-static bool AccessModeWithConversionsMatch(Handle<VH> vh,
-                                          VarHandle::AccessMode access_mode,
-                                          const char* descriptor)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
+bool VarHandleTest::AccessModeWithConversionsMatch(Handle<VH> vh,
+                                                   VarHandle::AccessMode access_mode,
+                                                   const char* descriptor) {
   ObjPtr<MethodType> method_type = MethodTypeOf(descriptor);
   return AccessModeMatch(vh.Get(),
                          access_mode,
@@ -266,10 +283,9 @@ static bool AccessModeWithConversionsMatch(Handle<VH> vh,
 }
 
 template <typename VH>
-static bool AccessModeNoMatch(Handle<VH> vh,
-                              VarHandle::AccessMode access_mode,
-                              const char* descriptor)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
+bool VarHandleTest::AccessModeNoMatch(Handle<VH> vh,
+                                      VarHandle::AccessMode access_mode,
+                                      const char* descriptor) {
   ObjPtr<MethodType> method_type = MethodTypeOf(descriptor);
   return AccessModeMatch(vh.Get(),
                          access_mode,
diff --git a/runtime/native/dalvik_system_DexFile.cc b/runtime/native/dalvik_system_DexFile.cc
index f7f446542c..a1d4f16d26 100644
--- a/runtime/native/dalvik_system_DexFile.cc
+++ b/runtime/native/dalvik_system_DexFile.cc
@@ -488,10 +488,9 @@ static jclass DexFile_defineClassNative(JNIEnv* env,
     return nullptr;
   }
   const std::string descriptor(DotToDescriptor(class_name.c_str()));
-  const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));
+  const size_t hash = ComputeModifiedUtf8Hash(descriptor);
   for (auto& dex_file : dex_files) {
-    const dex::ClassDef* dex_class_def =
-        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);
+    const dex::ClassDef* dex_class_def = OatDexFile::FindClassDef(*dex_file, descriptor, hash);
     if (dex_class_def != nullptr) {
       ScopedObjectAccess soa(env);
       ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
@@ -507,6 +506,7 @@ static jclass DexFile_defineClassNative(JNIEnv* env,
       }
       ObjPtr<mirror::Class> result = class_linker->DefineClass(soa.Self(),
                                                                descriptor.c_str(),
+                                                               descriptor.length(),
                                                                hash,
                                                                class_loader,
                                                                *dex_file,
diff --git a/runtime/native/dalvik_system_VMDebug.cc b/runtime/native/dalvik_system_VMDebug.cc
index 11d2898c3c..9440610f36 100644
--- a/runtime/native/dalvik_system_VMDebug.cc
+++ b/runtime/native/dalvik_system_VMDebug.cc
@@ -21,8 +21,6 @@
 
 #include <sstream>
 
-#include "nativehelper/jni_macros.h"
-
 #include "base/file_utils.h"
 #include "base/histogram-inl.h"
 #include "base/time_utils.h"
@@ -30,6 +28,8 @@
 #include "class_root-inl.h"
 #include "common_throws.h"
 #include "debugger.h"
+#include "dex/class_accessor-inl.h"
+#include "dex/descriptors_names.h"
 #include "gc/space/bump_pointer_space.h"
 #include "gc/space/dlmalloc_space.h"
 #include "gc/space/large_object_space.h"
@@ -42,10 +42,14 @@
 #include "mirror/array-alloc-inl.h"
 #include "mirror/array-inl.h"
 #include "mirror/class.h"
+#include "mirror/executable-inl.h"
 #include "mirror/object_array-alloc-inl.h"
 #include "native_util.h"
+#include "nativehelper/jni_macros.h"
 #include "nativehelper/scoped_local_ref.h"
 #include "nativehelper/scoped_utf_chars.h"
+#include "nativehelper/utils.h"
+#include "oat/oat_quick_method_header.h"
 #include "scoped_fast_native_object_access-inl.h"
 #include "string_array_utils.h"
 #include "thread-inl.h"
@@ -161,29 +165,23 @@ static void VMDebug_stopLowOverheadTraceImpl(JNIEnv*, jclass) {
 static void VMDebug_dumpLowOverheadTraceImpl(JNIEnv* env, jclass, jstring javaProfileFileName) {
   ScopedUtfChars profileFileName(env, javaProfileFileName);
   if (profileFileName.c_str() == nullptr) {
-    LOG(ERROR) << "Filename not provided, ignoring the request to dump profile";
+    LOG(ERROR) << "Filename not provided, ignoring the request to dump low-overhead trace";
     return;
   }
   TraceProfiler::Dump(profileFileName.c_str());
 }
 
-static void VMDebug_dumpLowOverheadTraceFdImpl(JNIEnv* env, jclass, jint originalFd) {
+static void VMDebug_dumpLowOverheadTraceFdImpl(JNIEnv*, jclass, jint originalFd) {
   if (originalFd < 0) {
-    ScopedObjectAccess soa(env);
-    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
-                                   "Trace fd is invalid: %d",
-                                   originalFd);
+    LOG(ERROR) << "Invalid file descriptor, ignoring the request to dump low-overhead trace";
     return;
   }
 
   // Set the O_CLOEXEC flag atomically here, so the file gets closed when a new process is forked.
   int fd = DupCloexec(originalFd);
   if (fd < 0) {
-    ScopedObjectAccess soa(env);
-    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
-                                   "dup(%d) failed: %s",
-                                   originalFd,
-                                   strerror(errno));
+    LOG(ERROR)
+        << "Unable to dup the file descriptor, ignoring the request to dump low-overhead trace";
     return;
   }
 
@@ -312,6 +310,72 @@ static jlong VMDebug_countInstancesOfClass(JNIEnv* env,
   return count;
 }
 
+static jobject VMDebug_getExecutableMethodFileOffsetsNative(JNIEnv* env,
+                                                            jclass,
+                                                            jobject javaMethod) {
+  ScopedObjectAccess soa(env);
+  ObjPtr<mirror::Executable> m = soa.Decode<mirror::Executable>(javaMethod);
+  if (m == nullptr) {
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
+                                   "Could not find mirror::Executable for supplied jobject");
+    return nullptr;
+  }
+
+  ObjPtr<mirror::Class> c = m->GetDeclaringClass();
+  if (c == nullptr) {
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;",
+                                   "Could not find mirror::Class for supplied jobject");
+    return nullptr;
+  }
+
+  ArtMethod* art_method = m->GetArtMethod();
+  auto oat_method_quick_code =
+      reinterpret_cast<const uint8_t*>(art_method->GetOatMethodQuickCode(kRuntimePointerSize));
+
+  if (oat_method_quick_code == nullptr) {
+    LOG(ERROR) << "No OatMethodQuickCode for method " << art_method->PrettyMethod();
+    return nullptr;
+  }
+
+  const OatDexFile* oat_dex_file = c->GetDexFile().GetOatDexFile();
+  if (oat_dex_file == nullptr) {
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;", "Could not find oat_dex_file");
+    return nullptr;
+  }
+
+  const OatFile* oat_file = oat_dex_file->GetOatFile();
+  if (oat_file == nullptr) {
+    soa.Self()->ThrowNewExceptionF("Ljava/lang/RuntimeException;", "Could not find oat_file");
+    return nullptr;
+  }
+
+  std::string error_msg;
+  const uint8_t* elf_begin = oat_file->ComputeElfBegin(&error_msg);
+  if (elf_begin == nullptr) {
+    soa.Self()->ThrowNewExceptionF(
+        "Ljava/lang/RuntimeException;", "Could not find elf_begin: %s", error_msg.c_str());
+    return nullptr;
+  }
+
+  size_t adjusted_offset = oat_method_quick_code - elf_begin;
+
+  ScopedLocalRef<jstring> odex_path = CREATE_UTF_OR_RETURN(env, oat_file->GetLocation());
+  auto odex_offset = reinterpret_cast64<jlong>(elf_begin);
+  auto method_offset = static_cast<jlong>(adjusted_offset);
+
+  ScopedLocalRef<jclass> clazz(env,
+                               env->FindClass("dalvik/system/VMDebug$ExecutableMethodFileOffsets"));
+  if (clazz == nullptr) {
+    soa.Self()->ThrowNewExceptionF(
+        "Ljava/lang/RuntimeException;",
+        "Could not find dalvik/system/VMDebug$ExecutableMethodFileOffsets");
+    return nullptr;
+  }
+
+  jmethodID constructor_id = env->GetMethodID(clazz.get(), "<init>", "(Ljava/lang/String;JJ)V");
+  return env->NewObject(clazz.get(), constructor_id, odex_path.get(), odex_offset, method_offset);
+}
+
 static jlongArray VMDebug_countInstancesOfClasses(JNIEnv* env,
                                                   jclass,
                                                   jobjectArray javaClasses,
@@ -559,7 +623,7 @@ static void VMDebug_setAllocTrackerStackDepth(JNIEnv* env, jclass, jint stack_de
 }
 
 static void VMDebug_setCurrentProcessName(JNIEnv* env, jclass, jstring process_name) {
-  ScopedFastNativeObjectAccess soa(env);
+  ScopedObjectAccess soa(env);
 
   // Android application ID naming convention states:
   // "The name can contain uppercase or lowercase letters, numbers, and underscores ('_')"
@@ -570,7 +634,7 @@ static void VMDebug_setCurrentProcessName(JNIEnv* env, jclass, jstring process_n
 }
 
 static void VMDebug_addApplication(JNIEnv* env, jclass, jstring package_name) {
-  ScopedFastNativeObjectAccess soa(env);
+  ScopedObjectAccess soa(env);
 
   // Android application ID naming convention states:
   // "The name can contain uppercase or lowercase letters, numbers, and underscores ('_')"
@@ -581,7 +645,7 @@ static void VMDebug_addApplication(JNIEnv* env, jclass, jstring package_name) {
 }
 
 static void VMDebug_removeApplication(JNIEnv* env, jclass, jstring package_name) {
-  ScopedFastNativeObjectAccess soa(env);
+  ScopedObjectAccess soa(env);
 
   // Android application ID naming convention states:
   // "The name can contain uppercase or lowercase letters, numbers, and underscores ('_')"
@@ -592,12 +656,12 @@ static void VMDebug_removeApplication(JNIEnv* env, jclass, jstring package_name)
 }
 
 static void VMDebug_setWaitingForDebugger(JNIEnv* env, jclass, jboolean waiting) {
-  ScopedFastNativeObjectAccess soa(env);
+  ScopedObjectAccess soa(env);
   Runtime::Current()->GetRuntimeCallbacks()->SetWaitingForDebugger(waiting);
 }
 
 static void VMDebug_setUserId(JNIEnv* env, jclass, jint user_id) {
-  ScopedFastNativeObjectAccess soa(env);
+  ScopedObjectAccess soa(env);
   Runtime::Current()->GetRuntimeCallbacks()->SetUserId(user_id);
 }
 
@@ -638,6 +702,10 @@ static JNINativeMethod gMethods[] = {
     NATIVE_METHOD(VMDebug, stopLowOverheadTraceImpl, "()V"),
     NATIVE_METHOD(VMDebug, dumpLowOverheadTraceImpl, "(Ljava/lang/String;)V"),
     NATIVE_METHOD(VMDebug, dumpLowOverheadTraceFdImpl, "(I)V"),
+    NATIVE_METHOD(
+        VMDebug,
+        getExecutableMethodFileOffsetsNative,
+        "(Ljava/lang/reflect/Method;)Ldalvik/system/VMDebug$ExecutableMethodFileOffsets;"),
 };
 
 void register_dalvik_system_VMDebug(JNIEnv* env) {
diff --git a/runtime/native/java_lang_Class.cc b/runtime/native/java_lang_Class.cc
index 79c8176027..c31c9790bd 100644
--- a/runtime/native/java_lang_Class.cc
+++ b/runtime/native/java_lang_Class.cc
@@ -111,8 +111,8 @@ static jclass Class_classForName(JNIEnv* env, jclass, jstring javaName, jboolean
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(javaLoader)));
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  Handle<mirror::Class> c(
-      hs.NewHandle(class_linker->FindClass(soa.Self(), descriptor.c_str(), class_loader)));
+  Handle<mirror::Class> c = hs.NewHandle(
+      class_linker->FindClass(soa.Self(), descriptor.c_str(), descriptor.length(), class_loader));
   if (UNLIKELY(c == nullptr)) {
     StackHandleScope<2> hs2(soa.Self());
     Handle<mirror::Object> cause = hs2.NewHandle(soa.Self()->GetException());
diff --git a/runtime/native/java_lang_VMClassLoader.cc b/runtime/native/java_lang_VMClassLoader.cc
index ba1fde00d3..eeae51c5e7 100644
--- a/runtime/native/java_lang_VMClassLoader.cc
+++ b/runtime/native/java_lang_VMClassLoader.cc
@@ -45,7 +45,7 @@ class VMClassLoader {
  public:
   static ObjPtr<mirror::Class> LookupClass(ClassLinker* cl,
                                            Thread* self,
-                                           const char* descriptor,
+                                           std::string_view descriptor,
                                            size_t hash,
                                            ObjPtr<mirror::ClassLoader> class_loader)
       REQUIRES(!Locks::classlinker_classes_lock_)
@@ -56,11 +56,13 @@ class VMClassLoader {
   static ObjPtr<mirror::Class> FindClassInPathClassLoader(ClassLinker* cl,
                                                           Thread* self,
                                                           const char* descriptor,
+                                                          size_t descriptor_length,
                                                           size_t hash,
                                                           Handle<mirror::ClassLoader> class_loader)
       REQUIRES_SHARED(Locks::mutator_lock_) {
     ObjPtr<mirror::Class> result;
-    if (cl->FindClassInBaseDexClassLoader(self, descriptor, hash, class_loader, &result)) {
+    if (cl->FindClassInBaseDexClassLoader(
+            self, descriptor, descriptor_length, hash, class_loader, &result)) {
       DCHECK(!self->IsExceptionPending());
       return result;
     }
@@ -83,11 +85,11 @@ static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoa
 
   // Compute hash once.
   std::string descriptor(DotToDescriptor(name.c_str()));
-  const size_t descriptor_hash = ComputeModifiedUtf8Hash(descriptor.c_str());
+  const size_t descriptor_hash = ComputeModifiedUtf8Hash(descriptor);
 
   ObjPtr<mirror::Class> c = VMClassLoader::LookupClass(cl,
                                                        soa.Self(),
-                                                       descriptor.c_str(),
+                                                       descriptor,
                                                        descriptor_hash,
                                                        loader);
   if (c != nullptr && c->IsResolved()) {
@@ -115,6 +117,7 @@ static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoa
     c = VMClassLoader::FindClassInPathClassLoader(cl,
                                                   soa.Self(),
                                                   descriptor.c_str(),
+                                                  descriptor.length(),
                                                   descriptor_hash,
                                                   hs.NewHandle(loader));
     if (c != nullptr) {
diff --git a/runtime/native/jdk_internal_misc_Unsafe.cc b/runtime/native/jdk_internal_misc_Unsafe.cc
index ba64c818c6..e9d6f3a83f 100644
--- a/runtime/native/jdk_internal_misc_Unsafe.cc
+++ b/runtime/native/jdk_internal_misc_Unsafe.cc
@@ -84,6 +84,15 @@ static jboolean Unsafe_compareAndSetLong(JNIEnv* env, jobject, jobject javaObj,
   return success ? JNI_TRUE : JNI_FALSE;
 }
 
+static jlong Unsafe_compareAndExchangeLong(
+    JNIEnv* env, jobject, jobject javaObj, jlong offset, jlong expectedValue, jlong newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  // JNI must use non transactional mode.
+  return obj->CaeFieldStrongSequentiallyConsistent64<false>(
+      MemberOffset(offset), expectedValue, newValue);
+}
+
 static jboolean Unsafe_compareAndSwapLong(JNIEnv* env, jobject obj, jobject javaObj, jlong offset,
                                           jlong expectedValue, jlong newValue) {
   // compareAndSetLong has the same semantics as compareAndSwapLong, except for
@@ -386,19 +395,40 @@ static jboolean Unsafe_getBoolean(JNIEnv* env, jobject, jobject javaObj, jlong o
   return obj->GetFieldBoolean(MemberOffset(offset));
 }
 
-static void Unsafe_putBoolean(JNIEnv* env, jobject, jobject javaObj, jlong offset, jboolean newValue) {
+static jboolean Unsafe_getBooleanVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  return obj->GetFieldBooleanVolatile(MemberOffset(offset));
+}
+
+static void Unsafe_putBoolean(JNIEnv* env, jobject, jobject javaObj, jlong offset,
+                              jboolean newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
   // JNI must use non transactional mode (SetField8 is non-transactional).
   obj->SetFieldBoolean<false>(MemberOffset(offset), newValue);
 }
 
+static void Unsafe_putBooleanVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset,
+                                      jboolean newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  // JNI must use non transactional mode (SetField8 is non-transactional).
+  obj->SetFieldBooleanVolatile<false>(MemberOffset(offset), newValue);
+}
+
 static jbyte Unsafe_getByte(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
   return obj->GetFieldByte(MemberOffset(offset));
 }
 
+static jbyte Unsafe_getByteVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  return obj->GetFieldByteVolatile(MemberOffset(offset));
+}
+
 static void Unsafe_putByte(JNIEnv* env, jobject, jobject javaObj, jlong offset, jbyte newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -406,12 +436,26 @@ static void Unsafe_putByte(JNIEnv* env, jobject, jobject javaObj, jlong offset,
   obj->SetFieldByte<false>(MemberOffset(offset), newValue);
 }
 
+static void Unsafe_putByteVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset,
+                                   jbyte newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  // JNI must use non transactional mode.
+  obj->SetFieldByteVolatile<false>(MemberOffset(offset), newValue);
+}
+
 static jchar Unsafe_getChar(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
   return obj->GetFieldChar(MemberOffset(offset));
 }
 
+static jchar Unsafe_getCharVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  return obj->GetFieldCharVolatile(MemberOffset(offset));
+}
+
 static void Unsafe_putChar(JNIEnv* env, jobject, jobject javaObj, jlong offset, jchar newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -419,12 +463,25 @@ static void Unsafe_putChar(JNIEnv* env, jobject, jobject javaObj, jlong offset,
   obj->SetFieldChar<false>(MemberOffset(offset), newValue);
 }
 
+static void Unsafe_putCharVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset, jchar newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  // JNI must use non transactional mode.
+  obj->SetFieldCharVolatile<false>(MemberOffset(offset), newValue);
+}
+
 static jshort Unsafe_getShort(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
   return obj->GetFieldShort(MemberOffset(offset));
 }
 
+static jshort Unsafe_getShortVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  return obj->GetFieldShortVolatile(MemberOffset(offset));
+}
+
 static void Unsafe_putShort(JNIEnv* env, jobject, jobject javaObj, jlong offset, jshort newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -432,6 +489,14 @@ static void Unsafe_putShort(JNIEnv* env, jobject, jobject javaObj, jlong offset,
   obj->SetFieldShort<false>(MemberOffset(offset), newValue);
 }
 
+static void Unsafe_putShortVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset,
+                                    jshort newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  // JNI must use non transactional mode.
+  obj->SetFieldShortVolatile<false>(MemberOffset(offset), newValue);
+}
+
 static jfloat Unsafe_getFloat(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -440,6 +505,14 @@ static jfloat Unsafe_getFloat(JNIEnv* env, jobject, jobject javaObj, jlong offse
   return conv.converted;
 }
 
+static jfloat Unsafe_getFloatVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  union {int32_t val; jfloat converted;} conv;
+  conv.val = obj->GetField32Volatile(MemberOffset(offset));
+  return conv.converted;
+}
+
 static void Unsafe_putFloat(JNIEnv* env, jobject, jobject javaObj, jlong offset, jfloat newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -449,6 +522,16 @@ static void Unsafe_putFloat(JNIEnv* env, jobject, jobject javaObj, jlong offset,
   obj->SetField32<false>(MemberOffset(offset), conv.converted);
 }
 
+static void Unsafe_putFloatVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset,
+                                    jfloat newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  union {int32_t converted; jfloat val;} conv;
+  conv.val = newValue;
+  // JNI must use non transactional mode.
+  obj->SetField32Volatile<false>(MemberOffset(offset), conv.converted);
+}
+
 static jdouble Unsafe_getDouble(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -457,6 +540,14 @@ static jdouble Unsafe_getDouble(JNIEnv* env, jobject, jobject javaObj, jlong off
   return conv.converted;
 }
 
+static jdouble Unsafe_getDoubleVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  union {int64_t val; jdouble converted;} conv;
+  conv.val = obj->GetField64Volatile(MemberOffset(offset));
+  return conv.converted;
+}
+
 static void Unsafe_putDouble(JNIEnv* env, jobject, jobject javaObj, jlong offset, jdouble newValue) {
   ScopedFastNativeObjectAccess soa(env);
   ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
@@ -466,6 +557,15 @@ static void Unsafe_putDouble(JNIEnv* env, jobject, jobject javaObj, jlong offset
   obj->SetField64<false>(MemberOffset(offset), conv.converted);
 }
 
+static void Unsafe_putDoubleVolatile(JNIEnv* env, jobject, jobject javaObj, jlong offset, jdouble newValue) {
+  ScopedFastNativeObjectAccess soa(env);
+  ObjPtr<mirror::Object> obj = soa.Decode<mirror::Object>(javaObj);
+  union {int64_t converted; jdouble val;} conv;
+  conv.val = newValue;
+  // JNI must use non transactional mode.
+  obj->SetField64Volatile<false>(MemberOffset(offset), conv.converted);
+}
+
 static void Unsafe_loadFence(JNIEnv*, jobject) {
   std::atomic_thread_fence(std::memory_order_acquire);
 }
@@ -514,13 +614,26 @@ static JNINativeMethod gMethods[] = {
         Unsafe, compareAndSwapObject, "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z"),
     FAST_NATIVE_METHOD(Unsafe, compareAndSetInt, "(Ljava/lang/Object;JII)Z"),
     FAST_NATIVE_METHOD(Unsafe, compareAndSetLong, "(Ljava/lang/Object;JJJ)Z"),
+    FAST_NATIVE_METHOD(Unsafe, compareAndExchangeLong, "(Ljava/lang/Object;JJJ)J"),
     FAST_NATIVE_METHOD(Unsafe,
                        compareAndSetReference,
                        "(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z"),
     FAST_NATIVE_METHOD(Unsafe, getIntVolatile, "(Ljava/lang/Object;J)I"),
     FAST_NATIVE_METHOD(Unsafe, putIntVolatile, "(Ljava/lang/Object;JI)V"),
+    FAST_NATIVE_METHOD(Unsafe, getBooleanVolatile, "(Ljava/lang/Object;J)Z"),
+    FAST_NATIVE_METHOD(Unsafe, putBooleanVolatile, "(Ljava/lang/Object;JZ)V"),
+    FAST_NATIVE_METHOD(Unsafe, getByteVolatile, "(Ljava/lang/Object;J)B"),
+    FAST_NATIVE_METHOD(Unsafe, putByteVolatile, "(Ljava/lang/Object;JB)V"),
+    FAST_NATIVE_METHOD(Unsafe, getShortVolatile, "(Ljava/lang/Object;J)S"),
+    FAST_NATIVE_METHOD(Unsafe, putShortVolatile, "(Ljava/lang/Object;JS)V"),
+    FAST_NATIVE_METHOD(Unsafe, getCharVolatile, "(Ljava/lang/Object;J)C"),
+    FAST_NATIVE_METHOD(Unsafe, putCharVolatile, "(Ljava/lang/Object;JC)V"),
     FAST_NATIVE_METHOD(Unsafe, getLongVolatile, "(Ljava/lang/Object;J)J"),
     FAST_NATIVE_METHOD(Unsafe, putLongVolatile, "(Ljava/lang/Object;JJ)V"),
+    FAST_NATIVE_METHOD(Unsafe, getFloatVolatile, "(Ljava/lang/Object;J)F"),
+    FAST_NATIVE_METHOD(Unsafe, putFloatVolatile, "(Ljava/lang/Object;JF)V"),
+    FAST_NATIVE_METHOD(Unsafe, getDoubleVolatile, "(Ljava/lang/Object;J)D"),
+    FAST_NATIVE_METHOD(Unsafe, putDoubleVolatile, "(Ljava/lang/Object;JD)V"),
     FAST_NATIVE_METHOD(Unsafe, getReferenceVolatile, "(Ljava/lang/Object;J)Ljava/lang/Object;"),
     FAST_NATIVE_METHOD(Unsafe, putReferenceVolatile, "(Ljava/lang/Object;JLjava/lang/Object;)V"),
     FAST_NATIVE_METHOD(Unsafe, getInt, "(Ljava/lang/Object;J)I"),
diff --git a/runtime/nterp_helpers.cc b/runtime/nterp_helpers.cc
index ba93df693d..0a306e2f56 100644
--- a/runtime/nterp_helpers.cc
+++ b/runtime/nterp_helpers.cc
@@ -181,7 +181,9 @@ QuickMethodFrameInfo NterpFrameInfo(ArtMethod** frame) {
       RuntimeCalleeSaveFrame::GetCoreSpills(CalleeSaveType::kSaveAllCalleeSaves);
   uint32_t fp_spills =
       RuntimeCalleeSaveFrame::GetFpSpills(CalleeSaveType::kSaveAllCalleeSaves);
-  return QuickMethodFrameInfo(NterpGetFrameSize(*frame, kRuntimeISA), core_spills, fp_spills);
+  return QuickMethodFrameInfo(NterpGetFrameSize(*frame, kRuntimeQuickCodeISA),
+                              core_spills,
+                              fp_spills);
 }
 
 uintptr_t NterpGetRegistersArray(ArtMethod** frame) {
@@ -192,7 +194,7 @@ uintptr_t NterpGetRegistersArray(ArtMethod** frame) {
 }
 
 uintptr_t NterpGetReferenceArray(ArtMethod** frame) {
-  const uint16_t out_regs = GetNumberOfOutRegs(*frame, kRuntimeISA);
+  const uint16_t out_regs = GetNumberOfOutRegs(*frame, kRuntimeQuickCodeISA);
   // The references array is just above the saved frame pointer.
   return reinterpret_cast<uintptr_t>(frame) +
       kPointerSize +  // method
@@ -202,7 +204,7 @@ uintptr_t NterpGetReferenceArray(ArtMethod** frame) {
 }
 
 uint32_t NterpGetDexPC(ArtMethod** frame) {
-  const uint16_t out_regs = GetNumberOfOutRegs(*frame, kRuntimeISA);
+  const uint16_t out_regs = GetNumberOfOutRegs(*frame, kRuntimeQuickCodeISA);
   uintptr_t dex_pc_ptr = reinterpret_cast<uintptr_t>(frame) +
       kPointerSize +  // method
       RoundUp(out_regs * kVRegSize, kPointerSize);  // out arguments and pointer alignment
diff --git a/runtime/nterp_helpers.h b/runtime/nterp_helpers.h
index 6ce2038a9d..a6edeb0ee0 100644
--- a/runtime/nterp_helpers.h
+++ b/runtime/nterp_helpers.h
@@ -73,7 +73,7 @@ uint32_t NterpGetVRegReference(ArtMethod** frame, uint16_t vreg)
  * Returns whether the given method can run with nterp. The instruction set can
  * be passed for cross-compilation.
  */
-EXPORT bool CanMethodUseNterp(ArtMethod* method, InstructionSet isa = kRuntimeISA)
+EXPORT bool CanMethodUseNterp(ArtMethod* method, InstructionSet isa = kRuntimeQuickCodeISA)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
 /**
diff --git a/runtime/oat/elf_file.cc b/runtime/oat/elf_file.cc
index 436a28a603..5fb8053856 100644
--- a/runtime/oat/elf_file.cc
+++ b/runtime/oat/elf_file.cc
@@ -1116,9 +1116,9 @@ bool ElfFileImpl<ElfTypes>::Load(File* file,
 
   if (executable) {
     InstructionSet elf_ISA = GetInstructionSetFromELF(GetHeader().e_machine, GetHeader().e_flags);
-    if (elf_ISA != kRuntimeISA) {
+    if (elf_ISA != kRuntimeQuickCodeISA) {
       std::ostringstream oss;
-      oss << "Expected ISA " << kRuntimeISA << " but found " << elf_ISA;
+      oss << "Expected ISA " << kRuntimeQuickCodeISA << " but found " << elf_ISA;
       *error_msg = oss.str();
       return false;
     }
diff --git a/runtime/oat/image.cc b/runtime/oat/image.cc
index d1ab8a1cce..b62a4e0621 100644
--- a/runtime/oat/image.cc
+++ b/runtime/oat/image.cc
@@ -34,8 +34,8 @@
 namespace art HIDDEN {
 
 const uint8_t ImageHeader::kImageMagic[] = { 'a', 'r', 't', '\n' };
-// Last change: Add intrinsics for Unsafe/JdkUnsafe.arrayBaseOffset.
-const uint8_t ImageHeader::kImageVersion[] = { '1', '1', '4', '\0' };
+// Revert dex cache change.
+const uint8_t ImageHeader::kImageVersion[] = { '1', '1', '8', '\0' };
 
 ImageHeader::ImageHeader(uint32_t image_reservation_size,
                          uint32_t component_count,
diff --git a/runtime/oat/image.h b/runtime/oat/image.h
index c21961d127..104143a1b5 100644
--- a/runtime/oat/image.h
+++ b/runtime/oat/image.h
@@ -19,6 +19,7 @@
 
 #include <string.h>
 
+#include "base/file_utils.h"
 #include "base/iteration_range.h"
 #include "base/macros.h"
 #include "base/os.h"
@@ -202,11 +203,11 @@ class PACKED(8) ImageHeader {
   EXPORT PointerSize GetPointerSize() const;
 
   static std::string GetOatLocationFromImageLocation(const std::string& image) {
-    return GetLocationFromImageLocation(image, "oat");
+    return ReplaceFileExtension(image, kOatExtension);
   }
 
   static std::string GetVdexLocationFromImageLocation(const std::string& image) {
-    return GetLocationFromImageLocation(image, "vdex");
+    return ReplaceFileExtension(image, kVdexExtension);
   }
 
   enum ImageMethod {
@@ -441,17 +442,6 @@ class PACKED(8) ImageHeader {
   static const uint8_t kImageMagic[4];
   static const uint8_t kImageVersion[4];
 
-  static std::string GetLocationFromImageLocation(const std::string& image,
-                                                  const std::string& extension) {
-    std::string filename = image;
-    if (filename.length() <= 3) {
-      filename += "." + extension;
-    } else {
-      filename.replace(filename.length() - 3, 3, extension);
-    }
-    return filename;
-  }
-
   uint8_t magic_[4];
   uint8_t version_[4];
 
diff --git a/runtime/oat/oat.h b/runtime/oat/oat.h
index fa50571b27..2b5c21e129 100644
--- a/runtime/oat/oat.h
+++ b/runtime/oat/oat.h
@@ -44,8 +44,8 @@ std::ostream& operator<<(std::ostream& stream, StubType stub_type);
 class EXPORT PACKED(4) OatHeader {
  public:
   static constexpr std::array<uint8_t, 4> kOatMagic { { 'o', 'a', 't', '\n' } };
-  // Last oat version changed reason: Adding new entrypoints for InvokeExact intrisic.
-  static constexpr std::array<uint8_t, 4> kOatVersion{{'2', '4', '7', '\0'}};
+  // Last oat version changed reason: reland "arm64: Store resolved MethodType-s in .bss."
+  static constexpr std::array<uint8_t, 4> kOatVersion{{'2', '5', '4', '\0'}};
 
   static constexpr const char* kDex2OatCmdLineKey = "dex2oat-cmdline";
   static constexpr const char* kDebuggableKey = "debuggable";
diff --git a/runtime/oat/oat_file.cc b/runtime/oat/oat_file.cc
index 879e3f1622..3e298e5590 100644
--- a/runtime/oat/oat_file.cc
+++ b/runtime/oat/oat_file.cc
@@ -1862,7 +1862,7 @@ class OatFileBackedByVdex final : public OatFileBase {
       store.Put(OatHeader::kClassPathKey, context->EncodeContextForOatFile(""));
     }
 
-    oat_header_.reset(OatHeader::Create(kRuntimeISA,
+    oat_header_.reset(OatHeader::Create(kRuntimeQuickCodeISA,
                                         isa_features.get(),
                                         number_of_dex_files,
                                         &store));
diff --git a/runtime/oat/oat_file_assistant.cc b/runtime/oat/oat_file_assistant.cc
index 149b97b598..7ee65db1a5 100644
--- a/runtime/oat/oat_file_assistant.cc
+++ b/runtime/oat/oat_file_assistant.cc
@@ -51,6 +51,7 @@
 #include "oat.h"
 #include "oat_file_assistant_context.h"
 #include "runtime.h"
+#include "runtime_globals.h"
 #include "scoped_thread_state_change-inl.h"
 #include "vdex_file.h"
 #include "zlib.h"
@@ -61,8 +62,6 @@ using ::android::base::ConsumePrefix;
 using ::android::base::StringPrintf;
 
 static constexpr const char* kAnonymousDexPrefix = "Anonymous-DexFile@";
-static constexpr const char* kVdexExtension = ".vdex";
-static constexpr const char* kDmExtension = ".dm";
 
 std::ostream& operator<<(std::ostream& stream, const OatFileAssistant::OatStatus status) {
   switch (status) {
@@ -145,9 +144,9 @@ OatFileAssistant::OatFileAssistant(const char* dex_location,
     load_executable_ = false;
   }
 
-  if (load_executable_ && isa != kRuntimeISA) {
+  if (load_executable_ && isa != kRuntimeQuickCodeISA) {
     LOG(WARNING) << "OatFileAssistant: Load executable specified, "
-                 << "but isa is not kRuntimeISA. Will not attempt to load executable.";
+                 << "but isa is not kRuntimeQuickCodeISA. Will not attempt to load executable.";
     load_executable_ = false;
   }
 
@@ -643,7 +642,7 @@ bool OatFileAssistant::DexLocationToOdexFilename(const std::string& location,
   pos = file.rfind('.');
   std::string base = pos != std::string::npos ? file.substr(0, pos) : file;
 
-  *odex_filename = dir + "/" + base + ".odex";
+  *odex_filename = dir + "/" + base + kOdexExtension;
   return true;
 }
 
@@ -946,12 +945,11 @@ OatFileAssistant::OatFileInfo& OatFileAssistant::GetBestInfo() {
 
 std::unique_ptr<gc::space::ImageSpace> OatFileAssistant::OpenImageSpace(const OatFile* oat_file) {
   DCHECK(oat_file != nullptr);
-  std::string art_file = ReplaceFileExtension(oat_file->GetLocation(), "art");
+  std::string art_file = ReplaceFileExtension(oat_file->GetLocation(), kArtExtension);
   if (art_file.empty()) {
     return nullptr;
   }
   std::string error_msg;
-  ScopedObjectAccess soa(Thread::Current());
   std::unique_ptr<gc::space::ImageSpace> ret =
       gc::space::ImageSpace::CreateFromAppImage(art_file.c_str(), oat_file, &error_msg);
   if (ret == nullptr && (VLOG_IS_ON(image) || OS::FileExists(art_file.c_str()))) {
@@ -1109,6 +1107,12 @@ const OatFile* OatFileAssistant::OatFileInfo::GetFile() {
       executable = LocationIsTrusted(filename_, /*trust_art_apex_data_files=*/true);
     }
     VLOG(oat) << "Loading " << filename_ << " with executable: " << executable;
+
+    if (gPageSize != kMinPageSize) {
+      LOG(WARNING) << "Loading odex files is only supported on devices with 4K page size";
+      return nullptr;
+    }
+
     if (use_fd_) {
       if (oat_fd_ >= 0 && vdex_fd_ >= 0) {
         ArrayRef<const std::string> dex_locations(&oat_file_assistant_->dex_location_,
@@ -1147,6 +1151,13 @@ bool OatFileAssistant::OatFileInfo::ShouldRecompileForFilter(CompilerFilter::Fil
   const OatFile* file = GetFile();
   DCHECK(file != nullptr);
 
+  if (CompilerFilter::IsBetter(target, CompilerFilter::kVerify) && gPageSize != kMinPageSize) {
+    // Prevent infinite recompilations during background dexopt on 16K page devices.
+    VLOG(oat) << "Adjusting target filter to 'verify' because loading odex files is only supported "
+                 "on devices with 4K page size";
+    target = CompilerFilter::kVerify;
+  }
+
   CompilerFilter::Filter current = file->GetCompilerFilter();
   if (dexopt_trigger.targetFilterIsBetter && CompilerFilter::IsBetter(target, current)) {
     VLOG(oat) << ART_FORMAT("Should recompile: targetFilterIsBetter (current: {}, target: {})",
diff --git a/runtime/oat/oat_file_assistant_context.cc b/runtime/oat/oat_file_assistant_context.cc
index fd168ffa04..23ad19b652 100644
--- a/runtime/oat/oat_file_assistant_context.cc
+++ b/runtime/oat/oat_file_assistant_context.cc
@@ -62,7 +62,8 @@ OatFileAssistantContext::OatFileAssistantContext(Runtime* runtime)
               .deny_art_apex_data_files = runtime->DenyArtApexDataFiles(),
           })) {
   // Fetch boot image info from the runtime.
-  std::vector<BootImageInfo>& boot_image_info_list = boot_image_info_list_by_isa_[kRuntimeISA];
+  std::vector<BootImageInfo>& boot_image_info_list =
+      boot_image_info_list_by_isa_[kRuntimeQuickCodeISA];
   for (const ImageSpace* image_space : runtime->GetHeap()->GetBootImageSpaces()) {
     // We only need the checksum of the first component for each boot image. They are in image
     // spaces that have a non-zero component count.
diff --git a/runtime/oat/oat_file_manager.cc b/runtime/oat/oat_file_manager.cc
index c32125cf75..320961755f 100644
--- a/runtime/oat/oat_file_manager.cc
+++ b/runtime/oat/oat_file_manager.cc
@@ -219,7 +219,7 @@ std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
                  << "Are you using the deprecated DexFile APIs?";
   } else if (context != nullptr) {
     auto oat_file_assistant = std::make_unique<OatFileAssistant>(dex_location,
-                                                                 kRuntimeISA,
+                                                                 kRuntimeQuickCodeISA,
                                                                  context.get(),
                                                                  runtime->GetOatFilesExecutable(),
                                                                  only_use_system_oat_files_);
@@ -296,7 +296,6 @@ std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
         if (kEnableRuntimeAppImage && image_space == nullptr && !compilation_enabled) {
           std::string art_file = RuntimeImage::GetRuntimeImagePath(dex_location);
           std::string error_msg;
-          ScopedObjectAccess soa(self);
           image_space = gc::space::ImageSpace::CreateFromAppImage(
               art_file.c_str(), oat_file.get(), &error_msg);
           if (image_space == nullptr) {
@@ -369,7 +368,7 @@ std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat(
           // file as non-executable.
           auto nonexecutable_oat_file_assistant =
               std::make_unique<OatFileAssistant>(dex_location,
-                                                 kRuntimeISA,
+                                                 kRuntimeQuickCodeISA,
                                                  context.get(),
                                                  /*load_executable=*/false,
                                                  only_use_system_oat_files_);
@@ -548,7 +547,7 @@ std::vector<std::unique_ptr<const DexFile>> OatFileManager::OpenDexFilesFromOat_
   std::string dex_location;
   std::string vdex_path;
   bool has_vdex = OatFileAssistant::AnonymousDexVdexLocation(dex_headers,
-                                                             kRuntimeISA,
+                                                             kRuntimeQuickCodeISA,
                                                              &dex_location,
                                                              &vdex_path);
 
@@ -725,10 +724,8 @@ class BackgroundVerificationTask final : public Task {
         StackHandleScope<2> hs(self);
         Handle<mirror::ClassLoader> h_loader(hs.NewHandle(
             soa.Decode<mirror::ClassLoader>(class_loader_)));
-        Handle<mirror::Class> h_class(hs.NewHandle<mirror::Class>(class_linker->FindClass(
-            self,
-            dex_file->GetClassDescriptor(class_def),
-            h_loader)));
+        Handle<mirror::Class> h_class =
+            hs.NewHandle(class_linker->FindClass(self, *dex_file, class_def.class_idx_, h_loader));
 
         if (h_class == nullptr) {
           DCHECK(self->IsExceptionPending());
@@ -839,7 +836,7 @@ void OatFileManager::RunBackgroundVerification(const std::vector<const DexFile*>
   std::string error_msg;
   std::string odex_filename;
   if (!OatFileAssistant::DexLocationToOdexFilename(dex_location,
-                                                   kRuntimeISA,
+                                                   kRuntimeQuickCodeISA,
                                                    &odex_filename,
                                                    &error_msg)) {
     LOG(WARNING) << "Could not get odex filename for " << dex_location << ": " << error_msg;
diff --git a/runtime/oat/oat_quick_method_header.cc b/runtime/oat/oat_quick_method_header.cc
index 3d086e88bf..17120c482f 100644
--- a/runtime/oat/oat_quick_method_header.cc
+++ b/runtime/oat/oat_quick_method_header.cc
@@ -74,7 +74,8 @@ uintptr_t OatQuickMethodHeader::ToNativeQuickPc(ArtMethod* method,
 
   StackMap stack_map = code_info.GetStackMapForDexPc(dex_pc);
   if (stack_map.IsValid()) {
-    return reinterpret_cast<uintptr_t>(entry_point) + stack_map.GetNativePcOffset(kRuntimeISA);
+    return reinterpret_cast<uintptr_t>(entry_point) +
+        stack_map.GetNativePcOffset(kRuntimeQuickCodeISA);
   }
   if (abort_on_failure) {
     ScopedObjectAccess soa(Thread::Current());
@@ -102,7 +103,7 @@ uintptr_t OatQuickMethodHeader::ToNativeQuickPcForCatchHandlers(
   *stack_map_row = stack_map.Row();
   if (stack_map.IsValid()) {
     return reinterpret_cast<uintptr_t>(entry_point) +
-           stack_map.GetNativePcOffset(kRuntimeISA);
+           stack_map.GetNativePcOffset(kRuntimeQuickCodeISA);
   }
   if (abort_on_failure) {
     std::stringstream ss;
diff --git a/runtime/oat/oat_quick_method_header.h b/runtime/oat/oat_quick_method_header.h
index c32eb7f41a..e9f8c6f142 100644
--- a/runtime/oat/oat_quick_method_header.h
+++ b/runtime/oat/oat_quick_method_header.h
@@ -56,8 +56,8 @@ class PACKED(4) OatQuickMethodHeader {
   static OatQuickMethodHeader* FromCodePointer(const void* code_ptr) {
     uintptr_t code = reinterpret_cast<uintptr_t>(code_ptr);
     uintptr_t header = code - OFFSETOF_MEMBER(OatQuickMethodHeader, code_);
-    DCHECK(IsAlignedParam(code, GetInstructionSetCodeAlignment(kRuntimeISA)) ||
-           IsAlignedParam(header, GetInstructionSetCodeAlignment(kRuntimeISA)))
+    DCHECK(IsAlignedParam(code, GetInstructionSetCodeAlignment(kRuntimeQuickCodeISA)) ||
+           IsAlignedParam(header, GetInstructionSetCodeAlignment(kRuntimeQuickCodeISA)))
         << std::hex << code << " " << std::hex << header;
     return reinterpret_cast<OatQuickMethodHeader*>(header);
   }
@@ -67,7 +67,8 @@ class PACKED(4) OatQuickMethodHeader {
   }
 
   static size_t InstructionAlignedSize() {
-    return RoundUp(sizeof(OatQuickMethodHeader), GetInstructionSetCodeAlignment(kRuntimeISA));
+    return RoundUp(sizeof(OatQuickMethodHeader),
+                   GetInstructionSetCodeAlignment(kRuntimeQuickCodeISA));
   }
 
   OatQuickMethodHeader(const OatQuickMethodHeader&) = default;
@@ -131,8 +132,9 @@ class PACKED(4) OatQuickMethodHeader {
     // mspace_memalign or memory mapped from a file, neither of which is tagged by MTE/HWASan.
     DCHECK_EQ(code_start, reinterpret_cast<uintptr_t>(code_start) & ((UINT64_C(1) << 56) - 1));
 #endif
-    static_assert(kRuntimeISA != InstructionSet::kThumb2, "kThumb2 cannot be a runtime ISA");
-    if (kRuntimeISA == InstructionSet::kArm) {
+    static_assert(kRuntimeQuickCodeISA != InstructionSet::kThumb2,
+                  "kThumb2 cannot be a runtime ISA");
+    if (kRuntimeQuickCodeISA == InstructionSet::kArm) {
       // On Thumb-2, the pc is offset by one.
       code_start++;
     }
@@ -140,12 +142,13 @@ class PACKED(4) OatQuickMethodHeader {
   }
 
   const uint8_t* GetEntryPoint() const {
-    // When the runtime architecture is ARM, `kRuntimeISA` is set to `kArm`
+    // When the runtime architecture is ARM, `kRuntimeQuickCodeISA` is set to `kArm`
     // (not `kThumb2`), *but* we always generate code for the Thumb-2
     // instruction set anyway. Thumb-2 requires the entrypoint to be of
     // offset 1.
-    static_assert(kRuntimeISA != InstructionSet::kThumb2, "kThumb2 cannot be a runtime ISA");
-    return (kRuntimeISA == InstructionSet::kArm)
+    static_assert(kRuntimeQuickCodeISA != InstructionSet::kThumb2,
+                  "kThumb2 cannot be a runtime ISA");
+    return (kRuntimeQuickCodeISA == InstructionSet::kArm)
         ? reinterpret_cast<uint8_t*>(reinterpret_cast<uintptr_t>(code_) | 1)
         : code_;
   }
@@ -169,9 +172,9 @@ class PACKED(4) OatQuickMethodHeader {
     QuickMethodFrameInfo frame_info = GetFrameInfo();
     size_t frame_size = frame_info.FrameSizeInBytes();
     size_t core_spill_size =
-        POPCOUNT(frame_info.CoreSpillMask()) * GetBytesPerGprSpillLocation(kRuntimeISA);
+        POPCOUNT(frame_info.CoreSpillMask()) * GetBytesPerGprSpillLocation(kRuntimeQuickCodeISA);
     size_t fpu_spill_size =
-        POPCOUNT(frame_info.FpSpillMask()) * GetBytesPerFprSpillLocation(kRuntimeISA);
+        POPCOUNT(frame_info.FpSpillMask()) * GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA);
     return frame_size - core_spill_size - fpu_spill_size - kShouldDeoptimizeFlagSize;
   }
 
diff --git a/runtime/oat/stack_map.h b/runtime/oat/stack_map.h
index 07f393aa9d..68c2f08b93 100644
--- a/runtime/oat/stack_map.h
+++ b/runtime/oat/stack_map.h
@@ -469,7 +469,7 @@ class CodeInfo {
   }
 
   EXPORT StackMap GetStackMapForNativePcOffset(uintptr_t pc,
-                                               InstructionSet isa = kRuntimeISA) const;
+                                               InstructionSet isa = kRuntimeQuickCodeISA) const;
 
   // Dump this CodeInfo object on `vios`.
   // `code_offset` is the (absolute) native PC of the compiled method.
diff --git a/runtime/parsed_options.cc b/runtime/parsed_options.cc
index d241ebe690..ab07ea0f02 100644
--- a/runtime/parsed_options.cc
+++ b/runtime/parsed_options.cc
@@ -169,12 +169,6 @@ std::unique_ptr<RuntimeParser> ParsedOptions::MakeParser(bool ignore_unrecognize
           .IntoKey(M::ForegroundHeapGrowthMultiplier)
       .Define("-XX:LowMemoryMode")
           .IntoKey(M::LowMemoryMode)
-      .Define("-Xprofile:_")
-          .WithType<TraceClockSource>()
-          .WithValueMap({{"threadcpuclock", TraceClockSource::kThreadCpu},
-                         {"wallclock",      TraceClockSource::kWall},
-                         {"dualclock",      TraceClockSource::kDual}})
-          .IntoKey(M::ProfileClock)
       .Define("-Xjitthreshold:_")
           .WithType<unsigned int>()
           .IntoKey(M::JITOptimizeThreshold)
@@ -516,7 +510,8 @@ std::unique_ptr<RuntimeParser> ParsedOptions::MakeParser(bool ignore_unrecognize
                 "-Xjitprofile",
                 "-Xjitdisableopt",
                 "-Xjitsuspendpoll",
-                "-XX:mainThreadStackSize=_"})
+                "-XX:mainThreadStackSize=_",
+                "-Xprofile:_"})
       .IgnoreUnrecognized(ignore_unrecognized)
       .OrderCategories({"standard", "extended", "Dalvik", "ART"});
 
@@ -730,9 +725,6 @@ bool ParsedOptions::DoParse(const RuntimeOptions& options,
 
   SetRuntimeDebugFlagsEnabled(args.GetOrDefault(M::SlowDebug));
 
-  // -Xprofile:
-  Trace::SetDefaultClockSource(args.GetOrDefault(M::ProfileClock));
-
   if (!ProcessSpecialOptions(options, &args, nullptr)) {
       return false;
   }
diff --git a/runtime/proxy_test.cc b/runtime/proxy_test.cc
index fb877d3ec5..f9bf31bedd 100644
--- a/runtime/proxy_test.cc
+++ b/runtime/proxy_test.cc
@@ -43,10 +43,8 @@ TEST_F(ProxyTest, ProxyClassHelper) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
-  Handle<mirror::Class> I(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LInterfaces$I;", class_loader)));
-  Handle<mirror::Class> J(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LInterfaces$J;", class_loader)));
+  Handle<mirror::Class> I = hs.NewHandle(FindClass("LInterfaces$I;", class_loader));
+  Handle<mirror::Class> J = hs.NewHandle(FindClass("LInterfaces$J;", class_loader));
   ASSERT_TRUE(I != nullptr);
   ASSERT_TRUE(J != nullptr);
 
@@ -77,10 +75,8 @@ TEST_F(ProxyTest, ProxyFieldHelper) {
   Handle<mirror::ClassLoader> class_loader(
       hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
-  Handle<mirror::Class> I(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LInterfaces$I;", class_loader)));
-  Handle<mirror::Class> J(hs.NewHandle(
-      class_linker_->FindClass(soa.Self(), "LInterfaces$J;", class_loader)));
+  Handle<mirror::Class> I = hs.NewHandle(FindClass("LInterfaces$I;", class_loader));
+  Handle<mirror::Class> J = hs.NewHandle(FindClass("LInterfaces$J;", class_loader));
   ASSERT_TRUE(I != nullptr);
   ASSERT_TRUE(J != nullptr);
 
diff --git a/runtime/quick_exception_handler.cc b/runtime/quick_exception_handler.cc
index beb42a6a05..09bbb2ab9e 100644
--- a/runtime/quick_exception_handler.cc
+++ b/runtime/quick_exception_handler.cc
@@ -798,7 +798,8 @@ void QuickExceptionHandler::DeoptimizeSingleFrame(DeoptimizationKind kind) {
 void QuickExceptionHandler::DeoptimizePartialFragmentFixup() {
   CHECK(handler_quick_frame_ != nullptr);
   // Architecture-dependent work. This is to get the LR right for x86 and x86-64.
-  if (kRuntimeISA == InstructionSet::kX86 || kRuntimeISA == InstructionSet::kX86_64) {
+  if (kRuntimeQuickCodeISA == InstructionSet::kX86 ||
+      kRuntimeQuickCodeISA == InstructionSet::kX86_64) {
     // On x86, the return address is on the stack, so just reuse it. Otherwise we would have to
     // change how longjump works.
     handler_quick_frame_ = reinterpret_cast<ArtMethod**>(
diff --git a/runtime/reference_table_test.cc b/runtime/reference_table_test.cc
index af8f4e50bc..40c22c8a3e 100644
--- a/runtime/reference_table_test.cc
+++ b/runtime/reference_table_test.cc
@@ -45,10 +45,12 @@ class ReferenceTableTest : public CommonRuntimeTest {
   ReferenceTableTest() {
     use_boot_image_ = true;  // Make the Runtime creation cheaper.
   }
+
+  ObjPtr<mirror::Object> CreateWeakReference(ObjPtr<mirror::Object> referent)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-static ObjPtr<mirror::Object> CreateWeakReference(ObjPtr<mirror::Object> referent)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
+ObjPtr<mirror::Object> ReferenceTableTest::CreateWeakReference(ObjPtr<mirror::Object> referent) {
   Thread* self = Thread::Current();
   ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
 
@@ -56,9 +58,7 @@ static ObjPtr<mirror::Object> CreateWeakReference(ObjPtr<mirror::Object> referen
   Handle<mirror::Object> h_referent(scope.NewHandle<mirror::Object>(referent));
 
   Handle<mirror::Class> h_ref_class(scope.NewHandle<mirror::Class>(
-      class_linker->FindClass(self,
-                              "Ljava/lang/ref/WeakReference;",
-                              ScopedNullHandle<mirror::ClassLoader>())));
+      FindClass("Ljava/lang/ref/WeakReference;", ScopedNullHandle<mirror::ClassLoader>())));
   CHECK(h_ref_class != nullptr);
   CHECK(class_linker->EnsureInitialized(self, h_ref_class, true, true));
 
diff --git a/runtime/reflection.cc b/runtime/reflection.cc
index 5c394b136a..8ebbeddcb1 100644
--- a/runtime/reflection.cc
+++ b/runtime/reflection.cc
@@ -532,8 +532,8 @@ JValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable& soa,
   // We want to make sure that the stack is not within a small distance from the
   // protected region in case we are calling into a leaf function whose stack
   // check has been elided.
-  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd())) {
-    ThrowStackOverflowError(soa.Self());
+  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd<kNativeStackType>())) {
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return JValue();
   }
   bool is_string_init = method->IsStringConstructor();
@@ -574,8 +574,8 @@ JValue InvokeWithJValues(const ScopedObjectAccessAlreadyRunnable& soa,
   // We want to make sure that the stack is not within a small distance from the
   // protected region in case we are calling into a leaf function whose stack
   // check has been elided.
-  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd())) {
-    ThrowStackOverflowError(soa.Self());
+  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd<kNativeStackType>())) {
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return JValue();
   }
   bool is_string_init = method->IsStringConstructor();
@@ -615,8 +615,8 @@ JValue InvokeVirtualOrInterfaceWithJValues(const ScopedObjectAccessAlreadyRunnab
   // We want to make sure that the stack is not within a small distance from the
   // protected region in case we are calling into a leaf function whose stack
   // check has been elided.
-  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd())) {
-    ThrowStackOverflowError(soa.Self());
+  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd<kNativeStackType>())) {
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return JValue();
   }
   ObjPtr<mirror::Object> receiver = soa.Decode<mirror::Object>(obj);
@@ -658,8 +658,8 @@ JValue InvokeVirtualOrInterfaceWithVarArgs(const ScopedObjectAccessAlreadyRunnab
   // We want to make sure that the stack is not within a small distance from the
   // protected region in case we are calling into a leaf function whose stack
   // check has been elided.
-  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd())) {
-    ThrowStackOverflowError(soa.Self());
+  if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEnd<kNativeStackType>())) {
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return JValue();
   }
 
@@ -702,7 +702,7 @@ jobject InvokeMethod(const ScopedObjectAccessAlreadyRunnable& soa, jobject javaM
   // check has been elided.
   if (UNLIKELY(__builtin_frame_address(0) <
                soa.Self()->GetStackEndForInterpreter(true))) {
-    ThrowStackOverflowError(soa.Self());
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return nullptr;
   }
 
@@ -797,7 +797,7 @@ void InvokeConstructor(const ScopedObjectAccessAlreadyRunnable& soa,
   // protected region in case we are calling into a leaf function whose stack
   // check has been elided.
   if (UNLIKELY(__builtin_frame_address(0) < soa.Self()->GetStackEndForInterpreter(true))) {
-    ThrowStackOverflowError(soa.Self());
+    ThrowStackOverflowError<kNativeStackType>(soa.Self());
     return;
   }
 
diff --git a/runtime/reflection_test.cc b/runtime/reflection_test.cc
index d307ba0cca..f65a244fef 100644
--- a/runtime/reflection_test.cc
+++ b/runtime/reflection_test.cc
@@ -103,9 +103,7 @@ class ReflectionTest : public CommonRuntimeTest {
       MakeInterpreted(class_linker_->FindSystemClass(self, "Ljava/lang/Object;"));
     }
 
-    ObjPtr<mirror::Class> c = class_linker_->FindClass(self,
-                                                       DotToDescriptor(class_name).c_str(),
-                                                       class_loader);
+    ObjPtr<mirror::Class> c = FindClass(DotToDescriptor(class_name).c_str(), class_loader);
     CHECK(c != nullptr);
     MakeInterpreted(c);
 
diff --git a/runtime/runtime-inl.h b/runtime/runtime-inl.h
index f90dcd1d30..03108046a6 100644
--- a/runtime/runtime-inl.h
+++ b/runtime/runtime-inl.h
@@ -43,7 +43,7 @@ inline mirror::Object* Runtime::GetClearedJniWeakGlobal() {
 
 inline QuickMethodFrameInfo Runtime::GetRuntimeMethodFrameInfo(ArtMethod* method) {
   DCHECK(method != nullptr);
-  DCHECK_EQ(instruction_set_, kRuntimeISA);
+  DCHECK_EQ(instruction_set_, kRuntimeQuickCodeISA);
   // Cannot be imt-conflict-method or resolution-method.
   DCHECK_NE(method, GetImtConflictMethod());
   DCHECK_NE(method, GetResolutionMethod());
diff --git a/runtime/runtime.cc b/runtime/runtime.cc
index 53c1cb152f..b1e71d3bb1 100644
--- a/runtime/runtime.cc
+++ b/runtime/runtime.cc
@@ -1324,6 +1324,7 @@ void Runtime::InitNonZygoteOrPostFork(
       LOG(WARNING) << "Failed to upload odrefresh metrics: " << err;
     }
     metrics::SetupCallbackForDeviceStatus();
+    metrics::ReportDeviceMetrics();
   }
 
   if (LIKELY(automatically_set_jni_ids_indirection_) && CanSetJniIdType()) {
@@ -1870,7 +1871,7 @@ bool Runtime::Init(RuntimeArgumentMap&& runtime_options_in) {
   InitPlatformSignalHandlers();
 
   // Change the implicit checks flags based on runtime architecture.
-  switch (kRuntimeISA) {
+  switch (kRuntimeQuickCodeISA) {
     case InstructionSet::kArm64:
       implicit_suspend_checks_ = true;
       FALLTHROUGH_INTENDED;
@@ -2050,9 +2051,6 @@ bool Runtime::Init(RuntimeArgumentMap&& runtime_options_in) {
     trace_config_->clock_source = runtime_options.GetOrDefault(Opt::MethodTraceClock);
   }
 
-  // TODO: Remove this in a follow up CL. This isn't used anywhere.
-  Trace::SetDefaultClockSource(runtime_options.GetOrDefault(Opt::ProfileClock));
-
   if (GetHeap()->HasBootImageSpace()) {
     const ImageHeader& image_header = GetHeap()->GetBootImageSpaces()[0]->GetImageHeader();
     ObjPtr<mirror::ObjectArray<mirror::Object>> boot_image_live_objects =
@@ -2923,7 +2921,10 @@ void Runtime::RegisterAppInfo(const std::string& package_name,
     return;
   }
 
-  jit_->StartProfileSaver(profile_output_filename, code_paths, ref_profile_filename);
+  jit_->StartProfileSaver(profile_output_filename,
+                          code_paths,
+                          ref_profile_filename,
+                          AppInfo::FromVMRuntimeConstants(code_type));
 }
 
 void Runtime::SetFaultMessage(const std::string& message) {
@@ -2960,7 +2961,8 @@ void Runtime::AddCurrentRuntimeFeaturesAsDex2OatArguments(std::vector<std::strin
   // architecture support, dex2oat may be compiled as a different instruction-set than that
   // currently being executed.
   std::string instruction_set("--instruction-set=");
-  instruction_set += GetInstructionSetString(kRuntimeISA);
+  // The dex2oat instruction set should match the runtime's target ISA.
+  instruction_set += GetInstructionSetString(kRuntimeQuickCodeISA);
   argv->push_back(instruction_set);
 
   if (InstructionSetFeatures::IsRuntimeDetectionSupported()) {
@@ -3503,4 +3505,10 @@ void Runtime::DCheckNoTransactionCheckAllowed() {
   }
 }
 
+NO_INLINE void Runtime::AllowPageSizeAccess() {
+#ifdef ART_PAGE_SIZE_AGNOSTIC
+  gPageSize.AllowAccess();
+#endif
+}
+
 }  // namespace art
diff --git a/runtime/runtime.h b/runtime/runtime.h
index e43d1d3432..97eac64fa1 100644
--- a/runtime/runtime.h
+++ b/runtime/runtime.h
@@ -1134,6 +1134,9 @@ class Runtime {
 
   bool AreMetricsInitialized() const { return metrics_reporter_ != nullptr; }
 
+  // For `artd` only.
+  EXPORT static void AllowPageSizeAccess();
+
  private:
   static void InitPlatformSignalHandlers();
 
diff --git a/runtime/runtime_callbacks_test.cc b/runtime/runtime_callbacks_test.cc
index 719cae5e3c..053d4eaaf5 100644
--- a/runtime/runtime_callbacks_test.cc
+++ b/runtime/runtime_callbacks_test.cc
@@ -303,8 +303,7 @@ TEST_F(ClassLoadCallbackRuntimeCallbacksTest, ClassLoadCallback) {
       soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
   const char* descriptor_y = "LY;";
-  Handle<mirror::Class> h_Y(
-      hs.NewHandle(class_linker_->FindClass(soa.Self(), descriptor_y, class_loader)));
+  Handle<mirror::Class> h_Y = hs.NewHandle(FindClass(descriptor_y, class_loader));
   ASSERT_TRUE(h_Y != nullptr);
 
   bool expect1 = Expect({ "PreDefine:LY; <art-gtest-jars-XandY.jar>",
diff --git a/runtime/runtime_image.cc b/runtime/runtime_image.cc
index fdba92e67f..c73810de59 100644
--- a/runtime/runtime_image.cc
+++ b/runtime/runtime_image.cc
@@ -1143,7 +1143,7 @@ class RuntimeImageHelper {
     std::unique_ptr<const InstructionSetFeatures> isa_features =
         InstructionSetFeatures::FromCppDefines();
     std::unique_ptr<OatHeader> oat_header(
-        OatHeader::Create(kRuntimeISA,
+        OatHeader::Create(kRuntimeQuickCodeISA,
                           isa_features.get(),
                           number_of_dex_files,
                           &key_value_store));
@@ -1848,7 +1848,7 @@ std::string RuntimeImage::GetRuntimeImagePath(const std::string& app_data_dir,
                                               const std::string& dex_location,
                                               const std::string& isa) {
   std::string basename = android::base::Basename(dex_location);
-  std::string filename = ReplaceFileExtension(basename, "art");
+  std::string filename = ReplaceFileExtension(basename, kArtExtension);
 
   return GetRuntimeImageDir(app_data_dir) + isa + "/" + filename;
 }
@@ -1856,7 +1856,7 @@ std::string RuntimeImage::GetRuntimeImagePath(const std::string& app_data_dir,
 std::string RuntimeImage::GetRuntimeImagePath(const std::string& dex_location) {
   return GetRuntimeImagePath(Runtime::Current()->GetProcessDataDirectory(),
                              dex_location,
-                             GetInstructionSetString(kRuntimeISA));
+                             GetInstructionSetString(kRuntimeQuickCodeISA));
 }
 
 static bool EnsureDirectoryExists(const std::string& directory, std::string* error_msg) {
@@ -1872,6 +1872,11 @@ static bool EnsureDirectoryExists(const std::string& directory, std::string* err
 }
 
 bool RuntimeImage::WriteImageToDisk(std::string* error_msg) {
+  if (gPageSize != kMinPageSize) {
+    *error_msg = "Writing runtime image is only supported on devices with 4K page size";
+    return false;
+  }
+
   gc::Heap* heap = Runtime::Current()->GetHeap();
   if (!heap->HasBootImageSpace()) {
     *error_msg = "Cannot generate an app image without a boot image";
diff --git a/runtime/runtime_options.def b/runtime/runtime_options.def
index e82f6566b2..010dc04c70 100644
--- a/runtime/runtime_options.def
+++ b/runtime/runtime_options.def
@@ -127,7 +127,6 @@ RUNTIME_OPTIONS_KEY (std::string,         MethodTraceFile,                "/data
 RUNTIME_OPTIONS_KEY (unsigned int,        MethodTraceFileSize,            10 * MB)
 RUNTIME_OPTIONS_KEY (Unit,                MethodTraceStreaming)
 RUNTIME_OPTIONS_KEY (TraceClockSource,    MethodTraceClock,               kDefaultTraceClockSource)
-RUNTIME_OPTIONS_KEY (TraceClockSource,    ProfileClock,                   kDefaultTraceClockSource)  // -Xprofile:
 RUNTIME_OPTIONS_KEY (ProfileSaverOptions, ProfileSaverOpts)  // -Xjitsaveprofilinginfo, -Xps-*
 RUNTIME_OPTIONS_KEY (std::string,         Compiler)
 RUNTIME_OPTIONS_KEY (std::vector<std::string>, \
diff --git a/runtime/runtime_test.cc b/runtime/runtime_test.cc
index 1faecf36a8..182a992434 100644
--- a/runtime/runtime_test.cc
+++ b/runtime/runtime_test.cc
@@ -95,7 +95,8 @@ TEST_F(RuntimeTest, ElfAlignmentMismatch) {
   }
 #endif
   // Determine the alignment of the ART APEX by reading the alignment of boot.oat.
-  std::string core_oat_location = GetSystemImageFilename(GetCoreOatLocation().c_str(), kRuntimeISA);
+  std::string core_oat_location = GetSystemImageFilename(GetCoreOatLocation().c_str(),
+                                                         kRuntimeQuickCodeISA);
   std::unique_ptr<File> core_oat_file(OS::OpenFileForReading(core_oat_location.c_str()));
   ASSERT_TRUE(core_oat_file.get() != nullptr) << core_oat_location;
 
diff --git a/runtime/stack.cc b/runtime/stack.cc
index 5670b12415..c3130b3ff8 100644
--- a/runtime/stack.cc
+++ b/runtime/stack.cc
@@ -136,7 +136,7 @@ uint32_t StackVisitor::GetDexPc(bool abort_on_failure) const {
         CodeInfo code_info(cur_oat_quick_method_header_);
         std::stringstream os;
         VariableIndentationOutputStream vios(&os);
-        code_info.Dump(&vios, /* code_offset= */ 0u, /* verbose= */ true, kRuntimeISA);
+        code_info.Dump(&vios, /* code_offset= */ 0u, /* verbose= */ true, kRuntimeQuickCodeISA);
         LOG(FATAL) << os.str() << '\n'
                    << "StackMap not found for "
                    << std::hex << cur_quick_frame_pc_ << " in "
@@ -407,7 +407,7 @@ bool StackVisitor::GetRegisterIfAccessible(uint32_t reg,
   const bool is_float = (location_kind == DexRegisterLocation::Kind::kInFpuRegister) ||
                         (location_kind == DexRegisterLocation::Kind::kInFpuRegisterHigh);
 
-  if (kRuntimeISA == InstructionSet::kX86 && is_float) {
+  if (kRuntimeQuickCodeISA == InstructionSet::kX86 && is_float) {
     // X86 float registers are 64-bit and each XMM register is provided as two separate
     // 32-bit registers by the context.
     reg = (location_kind == DexRegisterLocation::Kind::kInFpuRegisterHigh)
@@ -419,7 +419,7 @@ bool StackVisitor::GetRegisterIfAccessible(uint32_t reg,
     return false;
   }
   uintptr_t ptr_val = GetRegister(reg, is_float);
-  const bool target64 = Is64BitInstructionSet(kRuntimeISA);
+  const bool target64 = Is64BitInstructionSet(kRuntimeQuickCodeISA);
   if (target64) {
     const bool is_high = (location_kind == DexRegisterLocation::Kind::kInRegisterHigh) ||
                          (location_kind == DexRegisterLocation::Kind::kInFpuRegisterHigh);
@@ -803,9 +803,9 @@ uint8_t* StackVisitor::GetShouldDeoptimizeFlagAddr() const REQUIRES_SHARED(Locks
   size_t frame_size = frame_info.FrameSizeInBytes();
   uint8_t* sp = reinterpret_cast<uint8_t*>(GetCurrentQuickFrame());
   size_t core_spill_size =
-      POPCOUNT(frame_info.CoreSpillMask()) * GetBytesPerGprSpillLocation(kRuntimeISA);
+      POPCOUNT(frame_info.CoreSpillMask()) * GetBytesPerGprSpillLocation(kRuntimeQuickCodeISA);
   size_t fpu_spill_size =
-      POPCOUNT(frame_info.FpSpillMask()) * GetBytesPerFprSpillLocation(kRuntimeISA);
+      POPCOUNT(frame_info.FpSpillMask()) * GetBytesPerFprSpillLocation(kRuntimeQuickCodeISA);
   size_t offset = frame_size - core_spill_size - fpu_spill_size - kShouldDeoptimizeFlagSize;
   uint8_t* should_deoptimize_addr = sp + offset;
   DCHECK_EQ(*should_deoptimize_addr & ~static_cast<uint8_t>(DeoptimizeFlagValue::kAll), 0);
diff --git a/runtime/thread-inl.h b/runtime/thread-inl.h
index 66771230fe..432453e311 100644
--- a/runtime/thread-inl.h
+++ b/runtime/thread-inl.h
@@ -572,24 +572,66 @@ inline ShadowFrame* Thread::PopShadowFrame() {
   return tlsPtr_.managed_stack.PopShadowFrame();
 }
 
+template <>
+inline uint8_t* Thread::GetStackEnd<StackType::kHardware>() const {
+  return tlsPtr_.stack_end;
+}
+template <>
+inline void Thread::SetStackEnd<StackType::kHardware>(uint8_t* new_stack_end) {
+  tlsPtr_.stack_end = new_stack_end;
+}
+template <>
+inline uint8_t* Thread::GetStackBegin<StackType::kHardware>() const {
+  return tlsPtr_.stack_begin;
+}
+template <>
+inline void Thread::SetStackBegin<StackType::kHardware>(uint8_t* new_stack_begin) {
+  tlsPtr_.stack_begin = new_stack_begin;
+}
+template <>
+inline size_t Thread::GetStackSize<StackType::kHardware>() const {
+  return tlsPtr_.stack_size;
+}
+template <>
+inline void Thread::SetStackSize<StackType::kHardware>(size_t new_stack_size) {
+  tlsPtr_.stack_size = new_stack_size;
+}
+
 inline uint8_t* Thread::GetStackEndForInterpreter(bool implicit_overflow_check) const {
-  uint8_t* end = tlsPtr_.stack_end + (implicit_overflow_check
-      ? GetStackOverflowReservedBytes(kRuntimeISA)
+  uint8_t* end = GetStackEnd<kNativeStackType>() + (implicit_overflow_check
+      ? GetStackOverflowReservedBytes(kRuntimeQuickCodeISA)
           : 0);
   if (kIsDebugBuild) {
     // In a debuggable build, but especially under ASAN, the access-checks interpreter has a
     // potentially humongous stack size. We don't want to take too much of the stack regularly,
     // so do not increase the regular reserved size (for compiled code etc) and only report the
     // virtually smaller stack to the interpreter here.
-    end += GetStackOverflowReservedBytes(kRuntimeISA);
+    end += GetStackOverflowReservedBytes(kRuntimeQuickCodeISA);
   }
   return end;
 }
 
+template <StackType stack_type>
 inline void Thread::ResetDefaultStackEnd() {
   // Our stacks grow down, so we want stack_end_ to be near there, but reserving enough room
   // to throw a StackOverflowError.
-  tlsPtr_.stack_end = tlsPtr_.stack_begin + GetStackOverflowReservedBytes(kRuntimeISA);
+  SetStackEnd<stack_type>(
+      GetStackBegin<stack_type>() + GetStackOverflowReservedBytes(kRuntimeQuickCodeISA));
+}
+
+template <StackType stack_type>
+inline void Thread::SetStackEndForStackOverflow()
+    REQUIRES_SHARED(Locks::mutator_lock_) {
+  // During stack overflow we allow use of the full stack.
+  if (GetStackEnd<stack_type>() == GetStackBegin<stack_type>()) {
+    // However, we seem to have already extended to use the full stack.
+    LOG(ERROR) << "Need to increase kStackOverflowReservedBytes (currently "
+               << GetStackOverflowReservedBytes(kRuntimeQuickCodeISA) << ")?";
+    DumpStack(LOG_STREAM(ERROR));
+    LOG(FATAL) << "Recursive stack overflow.";
+  }
+
+  SetStackEnd<stack_type>(GetStackBegin<stack_type>());
 }
 
 inline void Thread::NotifyOnThreadExit(ThreadExitFlag* tef) {
diff --git a/runtime/thread.cc b/runtime/thread.cc
index dcbe1382e0..5bd97eb59a 100644
--- a/runtime/thread.cc
+++ b/runtime/thread.cc
@@ -56,6 +56,7 @@
 #include "base/utils.h"
 #include "class_linker-inl.h"
 #include "class_root-inl.h"
+#include "com_android_art_flags.h"
 #include "debugger.h"
 #include "dex/descriptors_names.h"
 #include "dex/dex_file-inl.h"
@@ -63,6 +64,7 @@
 #include "dex/dex_file_types.h"
 #include "entrypoints/entrypoint_utils.h"
 #include "entrypoints/quick/quick_alloc_entrypoints.h"
+#include "entrypoints/quick/runtime_entrypoints_list.h"
 #include "gc/accounting/card_table-inl.h"
 #include "gc/accounting/heap_bitmap-inl.h"
 #include "gc/allocator/rosalloc.h"
@@ -110,6 +112,7 @@
 #include "thread-inl.h"
 #include "thread_list.h"
 #include "trace.h"
+#include "trace_profile.h"
 #include "verify_object.h"
 #include "well_known_classes-inl.h"
 
@@ -128,6 +131,8 @@
 extern "C" __attribute__((weak)) void* __hwasan_tag_pointer(const volatile void* p,
                                                             unsigned char tag);
 
+namespace art_flags = com::android::art::flags;
+
 namespace art HIDDEN {
 
 using android::base::StringAppendV;
@@ -136,7 +141,8 @@ using android::base::StringPrintf;
 bool Thread::is_started_ = false;
 pthread_key_t Thread::pthread_key_self_;
 ConditionVariable* Thread::resume_cond_ = nullptr;
-const size_t Thread::kStackOverflowImplicitCheckSize = GetStackOverflowReservedBytes(kRuntimeISA);
+const size_t Thread::kStackOverflowImplicitCheckSize =
+    GetStackOverflowReservedBytes(kRuntimeQuickCodeISA);
 bool (*Thread::is_sensitive_thread_hook_)() = nullptr;
 Thread* Thread::jit_sensitive_thread_ = nullptr;
 std::atomic<Mutex*> Thread::cp_placeholder_mutex_(nullptr);
@@ -160,6 +166,11 @@ void InitEntryPoints(JniEntryPoints* jpoints,
                      QuickEntryPoints* qpoints,
                      bool monitor_jni_entry_exit);
 void UpdateReadBarrierEntrypoints(QuickEntryPoints* qpoints, bool is_active);
+void UpdateLowOverheadTraceEntrypoints(QuickEntryPoints* qpoints, bool enable);
+
+void Thread::UpdateTlsLowOverheadTraceEntrypoints(bool enable) {
+  UpdateLowOverheadTraceEntrypoints(&tlsPtr_.quick_entrypoints, enable);
+}
 
 void Thread::SetIsGcMarkingAndUpdateEntrypoints(bool is_marking) {
   CHECK(gUseReadBarrier);
@@ -622,7 +633,7 @@ void* Thread::CreateCallback(void* arg) {
     // while threads are being born).
     CHECK(!runtime->IsShuttingDownLocked());
     // Note: given that the JNIEnv is created in the parent thread, the only failure point here is
-    //       a mess in InitStackHwm. We do not have a reasonable way to recover from that, so abort
+    //       a mess in InitStack. We do not have a reasonable way to recover from that, so abort
     //       the runtime in such a case. In case this ever changes, we need to make sure here to
     //       delete the tmp_jni_env, as we own it at this point.
     CHECK(self->Init(runtime->GetThreadList(), runtime->GetJavaVM(), self->tlsPtr_.tmp_jni_env));
@@ -715,12 +726,12 @@ static size_t FixStackSize(size_t stack_size) {
     // If we are going to use implicit stack checks, allocate space for the protected
     // region at the bottom of the stack.
     stack_size += Thread::kStackOverflowImplicitCheckSize +
-        GetStackOverflowReservedBytes(kRuntimeISA);
+        GetStackOverflowReservedBytes(kRuntimeQuickCodeISA);
   } else {
     // It's likely that callers are trying to ensure they have at least a certain amount of
     // stack space, so we should add our reserved space on top of what they requested, rather
     // than implicitly take it away from them.
-    stack_size += GetStackOverflowReservedBytes(kRuntimeISA);
+    stack_size += GetStackOverflowReservedBytes(kRuntimeQuickCodeISA);
   }
 
   // Some systems require the stack size to be a multiple of the system page size, so round up.
@@ -729,26 +740,26 @@ static size_t FixStackSize(size_t stack_size) {
   return stack_size;
 }
 
-// Return the nearest page-aligned address below the current stack top.
-NO_INLINE
-static uint8_t* FindStackTop() {
+template <>
+NO_INLINE uint8_t* Thread::FindStackTop<StackType::kHardware>() {
   return reinterpret_cast<uint8_t*>(
       AlignDown(__builtin_frame_address(0), gPageSize));
 }
 
 // Install a protected region in the stack.  This is used to trigger a SIGSEGV if a stack
 // overflow is detected.  It is located right below the stack_begin_.
+template <StackType stack_type>
 ATTRIBUTE_NO_SANITIZE_ADDRESS
 void Thread::InstallImplicitProtection() {
-  uint8_t* pregion = tlsPtr_.stack_begin - GetStackOverflowProtectedSize();
+  uint8_t* pregion = GetStackBegin<stack_type>() - GetStackOverflowProtectedSize();
   // Page containing current top of stack.
-  uint8_t* stack_top = FindStackTop();
+  uint8_t* stack_top = FindStackTop<stack_type>();
 
   // Try to directly protect the stack.
   VLOG(threads) << "installing stack protected region at " << std::hex <<
         static_cast<void*>(pregion) << " to " <<
         static_cast<void*>(pregion + GetStackOverflowProtectedSize() - 1);
-  if (ProtectStack(/* fatal_on_error= */ false)) {
+  if (ProtectStack<stack_type>(/* fatal_on_error= */ false)) {
     // Tell the kernel that we won't be needing these pages any more.
     // NB. madvise will probably write zeroes into the memory (on linux it does).
     size_t unwanted_size =
@@ -778,7 +789,7 @@ void Thread::InstallImplicitProtection() {
 
   // (Defensively) first remove the protection on the protected region as we'll want to read
   // and write it. Ignore errors.
-  UnprotectStack();
+  UnprotectStack<stack_type>();
 
   VLOG(threads) << "Need to map in stack for thread at " << std::hex <<
       static_cast<void*>(pregion);
@@ -821,7 +832,7 @@ void Thread::InstallImplicitProtection() {
       static_cast<void*>(pregion + GetStackOverflowProtectedSize() - 1);
 
   // Protect the bottom of the stack to prevent read/write to it.
-  ProtectStack(/* fatal_on_error= */ true);
+  ProtectStack<stack_type>(/* fatal_on_error= */ true);
 
   // Tell the kernel that we won't be needing these pages any more.
   // NB. madvise will probably write zeroes into the memory (on linux it does).
@@ -948,6 +959,62 @@ void Thread::CreateNativeThread(JNIEnv* env, jobject java_peer, size_t stack_siz
   }
 }
 
+static void GetThreadStack(pthread_t thread,
+                           void** stack_base,
+                           size_t* stack_size,
+                           size_t* guard_size) {
+#if defined(__APPLE__)
+  *stack_size = pthread_get_stacksize_np(thread);
+  void* stack_addr = pthread_get_stackaddr_np(thread);
+
+  // Check whether stack_addr is the base or end of the stack.
+  // (On Mac OS 10.7, it's the end.)
+  int stack_variable;
+  if (stack_addr > &stack_variable) {
+    *stack_base = reinterpret_cast<uint8_t*>(stack_addr) - *stack_size;
+  } else {
+    *stack_base = stack_addr;
+  }
+
+  // This is wrong, but there doesn't seem to be a way to get the actual value on the Mac.
+  pthread_attr_t attributes;
+  CHECK_PTHREAD_CALL(pthread_attr_init, (&attributes), __FUNCTION__);
+  CHECK_PTHREAD_CALL(pthread_attr_getguardsize, (&attributes, guard_size), __FUNCTION__);
+  CHECK_PTHREAD_CALL(pthread_attr_destroy, (&attributes), __FUNCTION__);
+#else
+  pthread_attr_t attributes;
+  CHECK_PTHREAD_CALL(pthread_getattr_np, (thread, &attributes), __FUNCTION__);
+  CHECK_PTHREAD_CALL(pthread_attr_getstack, (&attributes, stack_base, stack_size), __FUNCTION__);
+  CHECK_PTHREAD_CALL(pthread_attr_getguardsize, (&attributes, guard_size), __FUNCTION__);
+  CHECK_PTHREAD_CALL(pthread_attr_destroy, (&attributes), __FUNCTION__);
+
+#if defined(__GLIBC__)
+  // If we're the main thread, check whether we were run with an unlimited stack. In that case,
+  // glibc will have reported a 2GB stack for our 32-bit process, and our stack overflow detection
+  // will be broken because we'll die long before we get close to 2GB.
+  bool is_main_thread = (::art::GetTid() == static_cast<uint32_t>(getpid()));
+  if (is_main_thread) {
+    rlimit stack_limit;
+    if (getrlimit(RLIMIT_STACK, &stack_limit) == -1) {
+      PLOG(FATAL) << "getrlimit(RLIMIT_STACK) failed";
+    }
+    if (stack_limit.rlim_cur == RLIM_INFINITY) {
+      size_t old_stack_size = *stack_size;
+
+      // Use the kernel default limit as our size, and adjust the base to match.
+      *stack_size = 8 * MB;
+      *stack_base = reinterpret_cast<uint8_t*>(*stack_base) + (old_stack_size - *stack_size);
+
+      VLOG(threads) << "Limiting unlimited stack (reported as " << PrettySize(old_stack_size) << ")"
+                    << " to " << PrettySize(*stack_size)
+                    << " with base " << *stack_base;
+    }
+  }
+#endif
+
+#endif
+}
+
 bool Thread::Init(ThreadList* thread_list, JavaVMExt* java_vm, JNIEnvExt* jni_env_ext) {
   // This function does all the initialization that must be run by the native thread it applies to.
   // (When we create a new thread from managed code, we allocate the Thread* in Thread::Create so
@@ -963,7 +1030,14 @@ bool Thread::Init(ThreadList* thread_list, JavaVMExt* java_vm, JNIEnvExt* jni_en
   ScopedTrace trace("Thread::Init");
 
   SetUpAlternateSignalStack();
-  if (!InitStackHwm()) {
+
+  void* read_stack_base = nullptr;
+  size_t read_stack_size = 0;
+  size_t read_guard_size = 0;
+  GetThreadStack(tlsPtr_.pthread_self, &read_stack_base, &read_stack_size, &read_guard_size);
+  if (!InitStack<kNativeStackType>(reinterpret_cast<uint8_t*>(read_stack_base),
+                                   read_stack_size,
+                                   read_guard_size)) {
     return false;
   }
   InitCpu();
@@ -997,6 +1071,9 @@ bool Thread::Init(ThreadList* thread_list, JavaVMExt* java_vm, JNIEnvExt* jni_en
 
   ScopedTrace trace3("ThreadList::Register");
   thread_list->Register(this);
+  if (art_flags::always_enable_profile_code()) {
+    UpdateTlsLowOverheadTraceEntrypoints(!Trace::IsTracingEnabled());
+  }
   return true;
 }
 
@@ -1054,6 +1131,7 @@ Thread* Thread::Attach(const char* thread_name,
     self->Dump(LOG_STREAM(INFO));
   }
 
+  TraceProfiler::AllocateBuffer(self);
   if (should_run_callbacks) {
     ScopedObjectAccess soa(self);
     runtime->GetRuntimeCallbacks()->ThreadStart(self);
@@ -1275,71 +1353,12 @@ void Thread::SetThreadName(const char* name) {
   Dbg::DdmSendThreadNotification(this, CHUNK_TYPE("THNM"));
 }
 
-static void GetThreadStack(pthread_t thread,
-                           void** stack_base,
-                           size_t* stack_size,
-                           size_t* guard_size) {
-#if defined(__APPLE__)
-  *stack_size = pthread_get_stacksize_np(thread);
-  void* stack_addr = pthread_get_stackaddr_np(thread);
+template <StackType stack_type>
+bool Thread::InitStack(uint8_t* read_stack_base, size_t read_stack_size, size_t read_guard_size) {
+  ScopedTrace trace("InitStack");
 
-  // Check whether stack_addr is the base or end of the stack.
-  // (On Mac OS 10.7, it's the end.)
-  int stack_variable;
-  if (stack_addr > &stack_variable) {
-    *stack_base = reinterpret_cast<uint8_t*>(stack_addr) - *stack_size;
-  } else {
-    *stack_base = stack_addr;
-  }
-
-  // This is wrong, but there doesn't seem to be a way to get the actual value on the Mac.
-  pthread_attr_t attributes;
-  CHECK_PTHREAD_CALL(pthread_attr_init, (&attributes), __FUNCTION__);
-  CHECK_PTHREAD_CALL(pthread_attr_getguardsize, (&attributes, guard_size), __FUNCTION__);
-  CHECK_PTHREAD_CALL(pthread_attr_destroy, (&attributes), __FUNCTION__);
-#else
-  pthread_attr_t attributes;
-  CHECK_PTHREAD_CALL(pthread_getattr_np, (thread, &attributes), __FUNCTION__);
-  CHECK_PTHREAD_CALL(pthread_attr_getstack, (&attributes, stack_base, stack_size), __FUNCTION__);
-  CHECK_PTHREAD_CALL(pthread_attr_getguardsize, (&attributes, guard_size), __FUNCTION__);
-  CHECK_PTHREAD_CALL(pthread_attr_destroy, (&attributes), __FUNCTION__);
-
-#if defined(__GLIBC__)
-  // If we're the main thread, check whether we were run with an unlimited stack. In that case,
-  // glibc will have reported a 2GB stack for our 32-bit process, and our stack overflow detection
-  // will be broken because we'll die long before we get close to 2GB.
-  bool is_main_thread = (::art::GetTid() == static_cast<uint32_t>(getpid()));
-  if (is_main_thread) {
-    rlimit stack_limit;
-    if (getrlimit(RLIMIT_STACK, &stack_limit) == -1) {
-      PLOG(FATAL) << "getrlimit(RLIMIT_STACK) failed";
-    }
-    if (stack_limit.rlim_cur == RLIM_INFINITY) {
-      size_t old_stack_size = *stack_size;
-
-      // Use the kernel default limit as our size, and adjust the base to match.
-      *stack_size = 8 * MB;
-      *stack_base = reinterpret_cast<uint8_t*>(*stack_base) + (old_stack_size - *stack_size);
-
-      VLOG(threads) << "Limiting unlimited stack (reported as " << PrettySize(old_stack_size) << ")"
-                    << " to " << PrettySize(*stack_size)
-                    << " with base " << *stack_base;
-    }
-  }
-#endif
-
-#endif
-}
-
-bool Thread::InitStackHwm() {
-  ScopedTrace trace("InitStackHwm");
-  void* read_stack_base;
-  size_t read_stack_size;
-  size_t read_guard_size;
-  GetThreadStack(tlsPtr_.pthread_self, &read_stack_base, &read_stack_size, &read_guard_size);
-
-  tlsPtr_.stack_begin = reinterpret_cast<uint8_t*>(read_stack_base);
-  tlsPtr_.stack_size = read_stack_size;
+  SetStackBegin<stack_type>(read_stack_base);
+  SetStackSize<stack_type>(read_stack_size);
 
   // The minimum stack size we can cope with is the protected region size + stack overflow check
   // region size + some memory for normal stack usage.
@@ -1362,7 +1381,7 @@ bool Thread::InitStackHwm() {
   DCHECK_ALIGNED_PARAM(static_cast<size_t>(GetStackOverflowProtectedSize()),
                        static_cast<int32_t>(gPageSize));
   size_t min_stack = GetStackOverflowProtectedSize() +
-      RoundUp(GetStackOverflowReservedBytes(kRuntimeISA) + 4 * KB, gPageSize);
+      RoundUp(GetStackOverflowReservedBytes(kRuntimeQuickCodeISA) + 4 * KB, gPageSize);
   if (read_stack_size <= min_stack) {
     // Note, as we know the stack is small, avoid operations that could use a lot of stack.
     LogHelper::LogLineLowStack(__PRETTY_FUNCTION__,
@@ -1372,8 +1391,16 @@ bool Thread::InitStackHwm() {
     return false;
   }
 
+  const char* stack_type_str = "";
+  if constexpr (stack_type == kNativeStackType) {
+    stack_type_str = "Native";
+  } else if constexpr (stack_type == kQuickStackType) {
+    stack_type_str = "Quick";
+  }
+
   // This is included in the SIGQUIT output, but it's useful here for thread debugging.
-  VLOG(threads) << StringPrintf("Native stack is at %p (%s with %s guard)",
+  VLOG(threads) << StringPrintf("%s stack is at %p (%s with %s guard)",
+                                stack_type_str,
                                 read_stack_base,
                                 PrettySize(read_stack_size).c_str(),
                                 PrettySize(read_guard_size).c_str());
@@ -1384,7 +1411,7 @@ bool Thread::InitStackHwm() {
   bool implicit_stack_check =
       runtime->GetImplicitStackOverflowChecks() && !runtime->IsAotCompiler();
 
-  ResetDefaultStackEnd();
+  ResetDefaultStackEnd<stack_type>();
 
   // Install the protected region if we are doing implicit overflow checks.
   if (implicit_stack_check) {
@@ -1392,15 +1419,18 @@ bool Thread::InitStackHwm() {
     // to install our own region so we need to move the limits
     // of the stack to make room for it.
 
-    tlsPtr_.stack_begin += read_guard_size + GetStackOverflowProtectedSize();
-    tlsPtr_.stack_end += read_guard_size + GetStackOverflowProtectedSize();
-    tlsPtr_.stack_size -= read_guard_size + GetStackOverflowProtectedSize();
+    SetStackBegin<stack_type>(
+        GetStackBegin<stack_type>() + read_guard_size + GetStackOverflowProtectedSize());
+    SetStackEnd<stack_type>(
+        GetStackEnd<stack_type>() + read_guard_size + GetStackOverflowProtectedSize());
+    SetStackSize<stack_type>(
+        GetStackSize<stack_type>() - (read_guard_size + GetStackOverflowProtectedSize()));
 
-    InstallImplicitProtection();
+    InstallImplicitProtection<stack_type>();
   }
 
   // Consistency check.
-  CHECK_GT(FindStackTop(), reinterpret_cast<void*>(tlsPtr_.stack_end));
+  CHECK_GT(FindStackTop<stack_type>(), reinterpret_cast<void*>(GetStackEnd<stack_type>()));
 
   return true;
 }
@@ -2115,9 +2145,10 @@ void Thread::DumpState(std::ostream& os, const Thread* thread, pid_t tid) {
      << " core=" << task_cpu
      << " HZ=" << sysconf(_SC_CLK_TCK) << "\n";
   if (thread != nullptr) {
-    os << "  | stack=" << reinterpret_cast<void*>(thread->tlsPtr_.stack_begin) << "-"
-        << reinterpret_cast<void*>(thread->tlsPtr_.stack_end) << " stackSize="
-        << PrettySize(thread->tlsPtr_.stack_size) << "\n";
+    // TODO(Simulator): Also dump the simulated stack if one exists.
+    os << "  | stack=" << reinterpret_cast<void*>(thread->GetStackBegin<kNativeStackType>())
+        << "-" << reinterpret_cast<void*>(thread->GetStackEnd<kNativeStackType>())
+        << " stackSize=" << PrettySize(thread->GetStackSize<kNativeStackType>()) << "\n";
     // Dump the held mutexes.
     os << "  | held mutexes=";
     for (size_t i = 0; i < kLockLevelCount; ++i) {
@@ -2804,12 +2835,17 @@ class JniTransitionReferenceVisitor : public StackVisitor {
   bool found_;
 };
 
+bool Thread::IsRawObjOnQuickStack(uint8_t* raw_obj) const {
+  return (static_cast<size_t>(raw_obj - GetStackBegin<kQuickStackType>()) <
+          GetStackSize<kQuickStackType>());
+}
+
 bool Thread::IsJniTransitionReference(jobject obj) const {
   DCHECK(obj != nullptr);
   // We need a non-const pointer for stack walk even if we're not modifying the thread state.
   Thread* thread = const_cast<Thread*>(this);
   uint8_t* raw_obj = reinterpret_cast<uint8_t*>(obj);
-  if (static_cast<size_t>(raw_obj - tlsPtr_.stack_begin) < tlsPtr_.stack_size) {
+  if (IsRawObjOnQuickStack(raw_obj)) {
     JniTransitionReferenceVisitor</*kPointsToStack=*/ true> visitor(thread, raw_obj);
     visitor.WalkStack();
     return visitor.Found();
@@ -3606,7 +3642,8 @@ void Thread::ThrowNewWrappedException(const char* exception_class_descriptor,
   Runtime* runtime = Runtime::Current();
   auto* cl = runtime->GetClassLinker();
   Handle<mirror::Class> exception_class(
-      hs.NewHandle(cl->FindClass(this, exception_class_descriptor, class_loader)));
+      hs.NewHandle(cl->FindClass(
+          this, exception_class_descriptor, strlen(exception_class_descriptor), class_loader)));
   if (UNLIKELY(exception_class == nullptr)) {
     CHECK(IsExceptionPending());
     LOG(ERROR) << "No exception class " << PrettyDescriptor(exception_class_descriptor);
@@ -4622,28 +4659,6 @@ void Thread::VerifyStackImpl() {
   }
 }
 
-// Set the stack end to that to be used during a stack overflow
-void Thread::SetStackEndForStackOverflow() {
-  // During stack overflow we allow use of the full stack.
-  if (tlsPtr_.stack_end == tlsPtr_.stack_begin) {
-    // However, we seem to have already extended to use the full stack.
-    LOG(ERROR) << "Need to increase kStackOverflowReservedBytes (currently "
-               << GetStackOverflowReservedBytes(kRuntimeISA) << ")?";
-    DumpStack(LOG_STREAM(ERROR));
-    LOG(FATAL) << "Recursive stack overflow.";
-  }
-
-  tlsPtr_.stack_end = tlsPtr_.stack_begin;
-
-  // Remove the stack overflow protection if is it set up.
-  bool implicit_stack_check = Runtime::Current()->GetImplicitStackOverflowChecks();
-  if (implicit_stack_check) {
-    if (!UnprotectStack()) {
-      LOG(ERROR) << "Unable to remove stack protection for stack overflow";
-    }
-  }
-}
-
 void Thread::SetTlab(uint8_t* start, uint8_t* end, uint8_t* limit) {
   DCHECK_LE(start, end);
   DCHECK_LE(end, limit);
@@ -4691,8 +4706,9 @@ std::ostream& operator<<(std::ostream& os, const Thread& thread) {
   return os;
 }
 
+template <StackType stack_type>
 bool Thread::ProtectStack(bool fatal_on_error) {
-  void* pregion = tlsPtr_.stack_begin - GetStackOverflowProtectedSize();
+  void* pregion = GetStackBegin<stack_type>() - GetStackOverflowProtectedSize();
   VLOG(threads) << "Protecting stack at " << pregion;
   if (mprotect(pregion, GetStackOverflowProtectedSize(), PROT_NONE) == -1) {
     if (fatal_on_error) {
@@ -4707,8 +4723,9 @@ bool Thread::ProtectStack(bool fatal_on_error) {
   return true;
 }
 
+template <StackType stack_type>
 bool Thread::UnprotectStack() {
-  void* pregion = tlsPtr_.stack_begin - GetStackOverflowProtectedSize();
+  void* pregion = GetStackBegin<stack_type>() - GetStackOverflowProtectedSize();
   VLOG(threads) << "Unprotecting stack at " << pregion;
   return mprotect(pregion, GetStackOverflowProtectedSize(), PROT_READ|PROT_WRITE) == 0;
 }
diff --git a/runtime/thread.h b/runtime/thread.h
index da9a70d8b1..8ce9854212 100644
--- a/runtime/thread.h
+++ b/runtime/thread.h
@@ -198,9 +198,48 @@ enum class WeakRefAccessState : int32_t {
   kDisabled
 };
 
+// ART uses two types of ABI/code: quick and native.
+//
+// Quick code includes:
+// - The code that ART compiles to, e.g: Java/dex code compiled to Arm64.
+// - Quick assembly entrypoints.
+//
+// Native code includes:
+// - Interpreter.
+// - GC.
+// - JNI.
+// - Runtime methods, i.e.: all ART C++ code.
+//
+// In regular (non-simulator) mode, both native and quick code are of the same ISA and will operate
+// on the hardware stack. The hardware stack is allocated by the kernel to ART and grows down in
+// memory.
+//
+// In simulator mode, native and quick code use different ISA's and will use different stacks.
+// Native code will use the hardware stack while quick code will use the simulated stack. The
+// simulated stack is a simple buffer in the native heap owned by the Simulator class.
+//
+// The StackType enum reflects the underlying type of stack in use by any given function while two
+// constexpr StackTypes (kNativeStackType and kQuickStackType) indicate which type of stack is used
+// for native and quick code. Whenever possible kNativeStackType and kQuickStackType should be used
+// instead of using the StackType directly.
+enum class StackType {
+  kHardware,
+  kSimulated
+};
+
+// The type of stack used when executing native code, i.e.: runtime helpers, interpreter, JNI, etc.
+// This stack is the native machine's call stack and so should be used when comparing against
+// values returned from builtin functions such as __builtin_frame_address.
+static constexpr StackType kNativeStackType = StackType::kHardware;
+
+// The type of stack used when executing quick code, i.e.: compiled dex code and quick entrypoints.
+// For simulator builds this is the kSimulated stack and for non-simulator builds this is the
+// kHardware stack.
+static constexpr StackType kQuickStackType = StackType::kHardware;
+
 // See Thread.tlsPtr_.active_suspend1_barriers below for explanation.
 struct WrappedSuspend1Barrier {
-  // TODO(b/23668816): At least weaken CHECKs to DCHECKs once the bug is fixed.
+  // TODO(b/323668816): At least weaken CHECKs to DCHECKs once the bug is fixed.
   static constexpr int kMagic = 0xba8;
   WrappedSuspend1Barrier() : magic_(kMagic), barrier_(1), next_(nullptr) {}
   int magic_;
@@ -1109,24 +1148,29 @@ class EXPORT Thread {
   }
 
   // Size of stack less any space reserved for stack overflow
-  size_t GetStackSize() const {
-    return tlsPtr_.stack_size - (tlsPtr_.stack_end - tlsPtr_.stack_begin);
+  template <StackType stack_type>
+  size_t GetUsableStackSize() const {
+    return GetStackSize<stack_type>() - static_cast<size_t>(
+        GetStackEnd<stack_type>() - GetStackBegin<stack_type>());
   }
 
-  ALWAYS_INLINE uint8_t* GetStackEndForInterpreter(bool implicit_overflow_check) const;
+  template <StackType stack_type>
+  ALWAYS_INLINE uint8_t* GetStackEnd() const;
 
-  uint8_t* GetStackEnd() const {
-    return tlsPtr_.stack_end;
-  }
+  ALWAYS_INLINE uint8_t* GetStackEndForInterpreter(bool implicit_overflow_check) const;
 
   // Set the stack end to that to be used during a stack overflow
-  void SetStackEndForStackOverflow() REQUIRES_SHARED(Locks::mutator_lock_);
+  template <StackType stack_type>
+  ALWAYS_INLINE void SetStackEndForStackOverflow()
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Set the stack end to that to be used during regular execution
+  template <StackType stack_type>
   ALWAYS_INLINE void ResetDefaultStackEnd();
 
+  template <StackType stack_type>
   bool IsHandlingStackOverflow() const {
-    return tlsPtr_.stack_end == tlsPtr_.stack_begin;
+    return GetStackEnd<stack_type>() == GetStackBegin<stack_type>();
   }
 
   template<PointerSize pointer_size>
@@ -1170,6 +1214,9 @@ class EXPORT Thread {
         ManagedStack::TopShadowFrameOffset());
   }
 
+  // Is the given object on the quick stack?
+  bool IsRawObjOnQuickStack(uint8_t* raw_obj) const;
+
   // Is the given obj in one of this thread's JNI transition frames?
   bool IsJniTransitionReference(jobject obj) const REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -1379,6 +1426,8 @@ class EXPORT Thread {
     }
   }
 
+  void UpdateTlsLowOverheadTraceEntrypoints(bool enable);
+
   uint64_t GetTraceClockBase() const {
     return tls64_.trace_clock_base;
   }
@@ -1499,7 +1548,9 @@ class EXPORT Thread {
     tlsPtr_.rosalloc_runs[index] = run;
   }
 
+  template <StackType stack_type>
   bool ProtectStack(bool fatal_on_error = true);
+  template <StackType stack_type>
   bool UnprotectStack();
 
   uint32_t DecrementForceInterpreterCount() REQUIRES(Locks::thread_list_lock_) {
@@ -1762,7 +1813,8 @@ class EXPORT Thread {
   void InitTlsEntryPoints();
   void InitTid();
   void InitPthreadKeySelf();
-  bool InitStackHwm();
+  template <StackType stack_type>
+  bool InitStack(uint8_t* read_stack_base, size_t read_stack_size, size_t read_guard_size);
 
   void SetUpAlternateSignalStack();
   void TearDownAlternateSignalStack();
@@ -1825,7 +1877,12 @@ class EXPORT Thread {
       REQUIRES_SHARED(Locks::mutator_lock_);
   void RunEmptyCheckpoint();
 
+  // Return the nearest page-aligned address below the current stack top.
+  template <StackType>
+  NO_INLINE uint8_t* FindStackTop();
+
   // Install the protected region for implicit stack checks.
+  template <StackType>
   void InstallImplicitProtection();
 
   template <bool kPrecise>
@@ -1835,6 +1892,22 @@ class EXPORT Thread {
 
   void SetCachedThreadName(const char* name);
 
+  // Helper functions to get/set the tls stack pointer variables.
+  template <StackType stack_type>
+  ALWAYS_INLINE void SetStackEnd(uint8_t* new_stack_end);
+
+  template <StackType stack_type>
+  ALWAYS_INLINE uint8_t* GetStackBegin() const;
+
+  template <StackType stack_type>
+  ALWAYS_INLINE void SetStackBegin(uint8_t* new_stack_begin);
+
+  template <StackType stack_type>
+  ALWAYS_INLINE size_t GetStackSize() const;
+
+  template <StackType stack_type>
+  ALWAYS_INLINE void SetStackSize(size_t new_stack_size);
+
   // Helper class for manipulating the 32 bits of atomically changed state and flags.
   class StateAndFlags {
    public:
@@ -2173,6 +2246,7 @@ class EXPORT Thread {
 
     // The end of this thread's stack. This is the lowest safely-addressable address on the stack.
     // We leave extra space so there's room for the code that throws StackOverflowError.
+    // Note: do not use directly, instead use GetStackEnd/SetStackEnd template function instead.
     uint8_t* stack_end;
 
     // The top of the managed stack often manipulated directly by compiler generated code.
@@ -2204,9 +2278,11 @@ class EXPORT Thread {
     jobject jpeer;
 
     // The "lowest addressable byte" of the stack.
+    // Note: do not use directly, instead use GetStackBegin/SetStackBegin template function instead.
     uint8_t* stack_begin;
 
     // Size of the stack.
+    // Note: do not use directly, instead use GetStackSize/SetStackSize template function instead.
     size_t stack_size;
 
     // Sampling profiler and AOT verification cannot happen on the same run, so we share
diff --git a/runtime/thread_suspension_timeouts.md b/runtime/thread_suspension_timeouts.md
new file mode 100644
index 0000000000..ca0efa183f
--- /dev/null
+++ b/runtime/thread_suspension_timeouts.md
@@ -0,0 +1,80 @@
+Thread Suspension timeouts in ART
+---------------------------------
+ART occasionally needs to "suspend" threads for a variety of reasons. "Suspended" threads may
+continue to run, but may not access data structures related to the Java heap. Please see
+`mutator_gc_coord.md` for details.
+
+The suspension process usually involves setting a flag for the thread to be "suspended", possibly
+causing the thread being "suspended" to generate a SIGSEGV at an opportune point, so that it
+notices the flag, and then having it acknowledge that it is now "suspended".
+
+This process is time-limited so that it does not hang a misbehaving process indefinitely. A
+timeout crashes the process with an abort message indicating a timeout in one of `SuspendAll`,
+`SuspendThreadByPeer`, or `SuspendThreadByThreadId`. It will normally occur after 4 seconds if the
+thread requesting the suspension has high priority, and either 8 or 12 seconds otherwise.
+
+Any such timeout has the inherent downside that it may occur on a sufficiently overcommitted
+device even when there is no deadlock or similar bug involved. Clearly this should be
+extremely rare.
+
+Android 15 changed the handling of such timeouts in several ways:
+
+1) The underlying suspension code was changed to improve correctness and better report timeouts.
+This included reducing the timeout in some cases to avoid the danger of reporting such timeouts as
+hard-to-analyze ANRs.
+
+2) When such a timeout is encountered, we now aggressively try to abort the thread refusing to
+suspend, so that the main reported stack trace gives a better indication of what went wrong. The
+thread originating the suspension request will still abort if this failed or took too long.
+
+3) The timeout abort message should contain a fair amount of information about the thread failing
+to abort, including two prefixes of the `/proc/<pid>/task/<tid>/stat` for the offending thread,
+taken a second or more apart. These snapshots contain several bits of useful information, such as
+kernel process states, the thread priority, and the `utime` and `stime` fields indicating the
+amount of time for which the thread was scheduled. See `man proc`, and look for `/proc/pid/stat`.
+(Initial Android 15 versions reported `/proc/<tid>/stat` instead, which includes process rather
+than thread cpu time.)
+
+This has been known to fail for several reasons:
+
+1) A deadlock involving thread suspension. The issues here are discussed in `mutator_gc_coord.md`.
+A common cause of these appear to be "native" C++ locks that are both held while executing Java
+code, and acquired in `@CriticalNative` or `@FastNative` JNI calls. These are clear bugs that,
+once identified, usually have a fairly clear-cut fix.
+
+2) Overcommitting the cores, so that the thread being "suspended" just does not get a chance to
+run within the timeout of 4 or more seconds.
+
+3) Either ART or `@CriticalNative`/`@FastNative` code that continues in Java `kRunnable` state for
+too long without checking suspension requests.
+
+4) The thread being suspended is either itself running at a low thread priority, or is waiting for
+a thread at low thread priority. A Java priority 10 thread has Linux niceness -8, but a priority 1
+thread has niceness 20. This means the former gets roughly 1.25^28. or more than 500, times the
+cpu share of the latter when the device's cores are overcommitted. It is worth noting that
+priority 5 (NORMAL) corresponds to niceness 0, while priority 4 corresponds to niceness 10, which
+is already almost a factor of 10 difference.
+
+When we do see such timeouts, they are often a combination of the last 3. The fixes in such a case
+tend to be less clear. Cores may become significantly overcommitted due to attempts to avoid
+unused cores, particularly during startup. There are currently times when ART needs to perform IO
+or paging operations while the Java heap is not in a consistent state. Priority issues can be
+difficult to address, since temporary priority changes may race with other priority changes.
+
+Different suspension timeout failures will usually need to be addressed individually.
+There is no single "silver bullet" fix for all of them. There is ongoing work
+to improve the tools available for handling priority issues. Currently the possible fixes
+include:
+
+- Remove any newly discovered deadlocks, e.g. by removing an `@FastNative` annotation to prevent
+  a lock from being acquired while the thread already has Java heap access. Or no longer
+  hold native locks across calls to Java.
+- Reduce the amount of time spent continuously in Java runnable state. For application code, that
+  may again involve removing `@FastNative` or `@CriticalNative` annotations. For ART internal
+  code, break up `ScopedObjectAccess` sections or the like, being careful to not hold native
+  pointers to Java heap objects across such sections.
+- Avoid excessive parallelism that is causing some threads to starve.
+- Reduce differences in thread priorities and, if necessary, avoid very low priority threads, for
+  the same reason.
+- On slow devices, if you are in a position to do so, consider setting `ro.hw_timeout_multiplier`
+  to a value greater than one.
diff --git a/runtime/trace.cc b/runtime/trace.cc
index c3fc6fd138..0fc41b6886 100644
--- a/runtime/trace.cc
+++ b/runtime/trace.cc
@@ -33,6 +33,7 @@
 #include "base/utils.h"
 #include "class_linker.h"
 #include "common_throws.h"
+#include "com_android_art_flags.h"
 #include "debugger.h"
 #include "dex/descriptors_names.h"
 #include "dex/dex_file-inl.h"
@@ -52,6 +53,8 @@
 #include "thread_list.h"
 #include "trace_profile.h"
 
+namespace art_flags = com::android::art::flags;
+
 namespace art HIDDEN {
 
 struct MethodTraceRecord {
@@ -88,14 +91,13 @@ static_assert(kPerThreadBufSize > kMinBufSize);
 // entries in per-thread buffer, the scaling factor is 6.
 static constexpr size_t kScalingFactorEncodedEntries = 6;
 
-TraceClockSource Trace::default_clock_source_ = kDefaultTraceClockSource;
+// The key identifying the tracer to update instrumentation.
+static constexpr const char* kTracerInstrumentationKey = "Tracer";
 
-Trace* volatile Trace::the_trace_ = nullptr;
+Trace* Trace::the_trace_ = nullptr;
 pthread_t Trace::sampling_pthread_ = 0U;
 std::unique_ptr<std::vector<ArtMethod*>> Trace::temp_stack_trace_;
 
-// The key identifying the tracer to update instrumentation.
-static constexpr const char* kTracerInstrumentationKey = "Tracer";
 
 static TraceAction DecodeTraceAction(uint32_t tmid) {
   return static_cast<TraceAction>(tmid & kTraceMethodActionMask);
@@ -361,16 +363,6 @@ void Trace::FreeStackTrace(std::vector<ArtMethod*>* stack_trace) {
   temp_stack_trace_.reset(stack_trace);
 }
 
-void Trace::SetDefaultClockSource(TraceClockSource clock_source) {
-#if defined(__linux__)
-  default_clock_source_ = clock_source;
-#else
-  if (clock_source != TraceClockSource::kWall) {
-    LOG(WARNING) << "Ignoring tracing request to use CPU time.";
-  }
-#endif
-}
-
 static uint16_t GetTraceVersion(TraceClockSource clock_source, int version) {
   if (version == Trace::kFormatV1) {
     return (clock_source == TraceClockSource::kDual) ? kTraceVersionDualClock :
@@ -846,6 +838,14 @@ void Trace::Start(std::unique_ptr<File>&& trace_file_in,
                                                          the_trace_,
                                                          /*needs_interpreter=*/false);
     }
+
+    if (art_flags::always_enable_profile_code()) {
+      // Reset the trace low overhead trace entry points to be a nop.
+      MutexLock thread_list_mutex(self, *Locks::thread_list_lock_);
+      for (Thread* thread : Runtime::Current()->GetThreadList()->GetList()) {
+        thread->UpdateTlsLowOverheadTraceEntrypoints(/*enable= */ false);
+      }
+    }
   }
 
   // Can't call this when holding the mutator lock.
@@ -925,6 +925,10 @@ void Trace::StopTracing(bool flush_entries) {
           the_trace->trace_writer_->FlushBuffer(
               thread, /* is_sync= */ false, /* free_buffer= */ true);
         }
+
+        if (art_flags::always_enable_profile_code()) {
+          thread->UpdateTlsLowOverheadTraceEntrypoints(/*enable= */ true);
+        }
       }
       the_trace_ = nullptr;
       sampling_pthread_ = 0U;
@@ -964,6 +968,9 @@ void Trace::FlushThreadBuffer(Thread* self) {
   // Check if we still need to flush inside the trace_lock_. If we are stopping tracing it is
   // possible we already deleted the trace and flushed the buffer too.
   if (the_trace_ == nullptr) {
+    if (art_flags::always_enable_profile_code()) {
+      TraceProfiler::ReleaseThreadBuffer(self);
+    }
     DCHECK_EQ(self->GetMethodTraceBuffer(), nullptr);
     return;
   }
@@ -975,6 +982,9 @@ void Trace::ReleaseThreadBuffer(Thread* self) {
   // Check if we still need to flush inside the trace_lock_. If we are stopping tracing it is
   // possible we already deleted the trace and flushed the buffer too.
   if (the_trace_ == nullptr) {
+    if (art_flags::always_enable_profile_code()) {
+      TraceProfiler::ReleaseThreadBuffer(self);
+    }
     DCHECK_EQ(self->GetMethodTraceBuffer(), nullptr);
     return;
   }
diff --git a/runtime/trace.h b/runtime/trace.h
index 445cd7e3af..ffd70aa8e6 100644
--- a/runtime/trace.h
+++ b/runtime/trace.h
@@ -615,7 +615,7 @@ class Trace final : public instrumentation::InstrumentationListener, public Clas
                            uint64_t timestamp_counter) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Singleton instance of the Trace or null when no method tracing is active.
-  static Trace* volatile the_trace_ GUARDED_BY(Locks::trace_lock_);
+  static Trace* the_trace_ GUARDED_BY(Locks::trace_lock_);
 
   // The default profiler clock source.
   static TraceClockSource default_clock_source_;
diff --git a/runtime/trace_profile.cc b/runtime/trace_profile.cc
index c1000d2095..6907e28972 100644
--- a/runtime/trace_profile.cc
+++ b/runtime/trace_profile.cc
@@ -16,10 +16,13 @@
 
 #include "trace_profile.h"
 
+#include "android-base/stringprintf.h"
+#include "art_method-inl.h"
 #include "base/leb128.h"
 #include "base/mutex.h"
 #include "base/unix_file/fd_file.h"
 #include "com_android_art_flags.h"
+#include "dex/descriptors_names.h"
 #include "runtime.h"
 #include "thread-current-inl.h"
 #include "thread.h"
@@ -30,6 +33,8 @@ namespace art_flags = com::android::art::flags;
 
 namespace art HIDDEN {
 
+using android::base::StringPrintf;
+
 // This specifies the maximum number of bits we need for encoding one entry. Each entry just
 // consists of a SLEB encoded value of method and action encodig which is a maximum of
 // sizeof(uintptr_t).
@@ -41,6 +46,8 @@ static constexpr size_t kMaxBytesPerTraceEntry = sizeof(uintptr_t);
 // bytes free space in the buffer.
 static constexpr size_t kMinBufSizeForEncodedData = kAlwaysOnTraceBufSize * kMaxBytesPerTraceEntry;
 
+static constexpr size_t kProfileMagicValue = 0x4C4F4D54;
+
 // TODO(mythria): 10 is a randomly chosen value. Tune it if required.
 static constexpr size_t kBufSizeForEncodedData = kMinBufSizeForEncodedData * 10;
 
@@ -48,6 +55,22 @@ static constexpr size_t kAlwaysOnTraceHeaderSize = 8;
 
 bool TraceProfiler::profile_in_progress_ = false;
 
+void TraceProfiler::AllocateBuffer(Thread* thread) {
+  if (!art_flags::always_enable_profile_code()) {
+    return;
+  }
+
+  Thread* self = Thread::Current();
+  MutexLock mu(self, *Locks::trace_lock_);
+  if (!profile_in_progress_) {
+    return;
+  }
+
+  auto buffer = new uintptr_t[kAlwaysOnTraceBufSize];
+  memset(buffer, 0, kAlwaysOnTraceBufSize * sizeof(uintptr_t));
+  thread->SetMethodTraceBuffer(buffer, kAlwaysOnTraceBufSize);
+}
+
 void TraceProfiler::Start() {
   if (!art_flags::always_enable_profile_code()) {
     LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
@@ -112,20 +135,35 @@ uint8_t* TraceProfiler::DumpBuffer(uint32_t thread_id,
 
   int num_records = 0;
   uintptr_t prev_method_action_encoding = 0;
-  for (size_t i = 0; i < kAlwaysOnTraceBufSize; i++) {
-    uintptr_t method_action_encoding = method_trace_entries[num_records];
+  int prev_action = -1;
+  for (size_t i = kAlwaysOnTraceBufSize - 1; i > 0; i-=1) {
+    uintptr_t method_action_encoding = method_trace_entries[i];
     // 0 value indicates the rest of the entries are empty.
     if (method_action_encoding == 0) {
       break;
     }
 
-    int64_t method_diff = method_action_encoding - prev_method_action_encoding;
-    curr_buffer_ptr = EncodeSignedLeb128(curr_buffer_ptr, method_diff);
-
-    ArtMethod* method = reinterpret_cast<ArtMethod*>(method_action_encoding & kMaskTraceAction);
-    methods.insert(method);
+    int action = method_action_encoding & ~kMaskTraceAction;
+    int64_t diff;
+    if (action == TraceAction::kTraceMethodEnter) {
+      diff = method_action_encoding - prev_method_action_encoding;
+
+      ArtMethod* method = reinterpret_cast<ArtMethod*>(method_action_encoding & kMaskTraceAction);
+      methods.insert(method);
+    } else {
+      // On a method exit, we don't record the information about method. We just need a 1 in the
+      // lsb and the method information can be derived from the last method that entered. To keep
+      // the encoded value small just add the smallest value to make the lsb one.
+      if (prev_action == TraceAction::kTraceMethodExit) {
+        diff = 0;
+      } else {
+        diff = 1;
+      }
+    }
+    curr_buffer_ptr = EncodeSignedLeb128(curr_buffer_ptr, diff);
     num_records++;
     prev_method_action_encoding = method_action_encoding;
+    prev_action = action;
   }
 
   // Fill in header information:
@@ -148,6 +186,14 @@ void TraceProfiler::Dump(int fd) {
   Dump(std::move(trace_file));
 }
 
+std::string TraceProfiler::GetMethodInfoLine(ArtMethod* method) {
+  return StringPrintf("%s\t%s\t%s\t%s\n",
+                      PrettyDescriptor(method->GetDeclaringClassDescriptor()).c_str(),
+                      method->GetName(),
+                      method->GetSignature().ToString().c_str(),
+                      method->GetDeclaringClassSourceFile());
+}
+
 void TraceProfiler::Dump(const char* filename) {
   if (!art_flags::always_enable_profile_code()) {
     LOG(ERROR) << "Feature not supported. Please build with ART_ALWAYS_ENABLE_PROFILE_CODE.";
@@ -166,22 +212,33 @@ void TraceProfiler::Dump(const char* filename) {
 void TraceProfiler::Dump(std::unique_ptr<File>&& trace_file) {
   Thread* self = Thread::Current();
   std::unordered_set<ArtMethod*> traced_methods;
+  std::unordered_map<size_t, std::string> traced_threads;
   MutexLock mu(self, *Locks::trace_lock_);
   if (!profile_in_progress_) {
     LOG(ERROR) << "No Profile in progress. Nothing to dump.";
     return;
   }
 
-  ScopedSuspendAll ssa(__FUNCTION__);
-  MutexLock tl(self, *Locks::thread_list_lock_);
   uint8_t* buffer_ptr = new uint8_t[kBufSizeForEncodedData];
   uint8_t* curr_buffer_ptr = buffer_ptr;
+
+  // Add a header for the trace: 4-bits of magic value and 2-bits for the version.
+  Append4LE(curr_buffer_ptr, kProfileMagicValue);
+  Append2LE(curr_buffer_ptr + 4, /*trace_version=*/ 1);
+  curr_buffer_ptr += 6;
+
+  ScopedSuspendAll ssa(__FUNCTION__);
+  MutexLock tl(self, *Locks::thread_list_lock_);
   for (Thread* thread : Runtime::Current()->GetThreadList()->GetList()) {
     auto method_trace_entries = thread->GetMethodTraceBuffer();
     if (method_trace_entries == nullptr) {
       continue;
     }
 
+    std::string thread_name;
+    thread->GetThreadName(thread_name);
+    traced_threads.emplace(thread->GetThreadId(), thread_name);
+
     size_t offset = curr_buffer_ptr - buffer_ptr;
     if (offset >= kMinBufSizeForEncodedData) {
       if (!trace_file->WriteFully(buffer_ptr, offset)) {
@@ -198,6 +255,49 @@ void TraceProfiler::Dump(std::unique_ptr<File>&& trace_file) {
     // Reset the current pointer.
     thread->SetMethodTraceBufferCurrentEntry(kAlwaysOnTraceBufSize);
   }
+
+  // Write any remaining data to file and close the file.
+  if (curr_buffer_ptr != buffer_ptr) {
+    if (!trace_file->WriteFully(buffer_ptr, curr_buffer_ptr - buffer_ptr)) {
+      PLOG(WARNING) << "Failed streaming a tracing event.";
+    }
+  }
+
+  std::ostringstream os;
+  // Dump data about thread information.
+  os << "\n*threads\n";
+  for (const auto& it : traced_threads) {
+    os << it.first << "\t" << it.second << "\n";
+  }
+
+  // Dump data about method information.
+  os << "*methods\n";
+  for (ArtMethod* method : traced_methods) {
+    uint64_t method_id = reinterpret_cast<uint64_t>(method);
+    os << method_id << "\t" << GetMethodInfoLine(method);
+  }
+
+  os << "*end";
+
+  std::string info = os.str();
+  if (!trace_file->WriteFully(info.c_str(), info.length())) {
+    PLOG(WARNING) << "Failed writing information to file";
+  }
+
+  if (!trace_file->Close()) {
+    PLOG(WARNING) << "Failed to close file.";
+  }
+}
+
+void TraceProfiler::ReleaseThreadBuffer(Thread* self) {
+  if (!IsTraceProfileInProgress()) {
+    return;
+  }
+  // TODO(mythria): Maybe it's good to cache these and dump them when requested. For now just
+  // relese the buffer when a thread is exiting.
+  auto buffer = self->GetMethodTraceBuffer();
+  delete[] buffer;
+  self->SetMethodTraceBuffer(nullptr, 0);
 }
 
 bool TraceProfiler::IsTraceProfileInProgress() {
diff --git a/runtime/trace_profile.h b/runtime/trace_profile.h
index 7118cd5882..694eb7ac99 100644
--- a/runtime/trace_profile.h
+++ b/runtime/trace_profile.h
@@ -49,8 +49,14 @@ class TraceProfiler {
   static void Dump(int fd);
   static void Dump(const char* trace_filename);
 
+  // Called when thread is exiting to release the allocated buffer.
+  static void ReleaseThreadBuffer(Thread* self) REQUIRES(Locks::trace_lock_);
+
   static bool IsTraceProfileInProgress() REQUIRES(Locks::trace_lock_);
 
+  // Allocates a buffer for the specified thread.
+  static void AllocateBuffer(Thread* thread);
+
  private:
   // Dumps the events from all threads into the trace_file.
   static void Dump(std::unique_ptr<File>&& trace_file);
@@ -65,6 +71,8 @@ class TraceProfiler {
                              uint8_t* buffer /* out */,
                              std::unordered_set<ArtMethod*>& methods /* out */);
 
+  static std::string GetMethodInfoLine(ArtMethod* method) REQUIRES(Locks::mutator_lock_);
+
   static bool profile_in_progress_ GUARDED_BY(Locks::trace_lock_);
   DISALLOW_COPY_AND_ASSIGN(TraceProfiler);
 };
diff --git a/runtime/vdex_file.cc b/runtime/vdex_file.cc
index 6702970c68..db2a976c22 100644
--- a/runtime/vdex_file.cc
+++ b/runtime/vdex_file.cc
@@ -392,10 +392,12 @@ bool VdexFile::HasOnlyStandardDexFiles() const {
 
 static ObjPtr<mirror::Class> FindClassAndClearException(ClassLinker* class_linker,
                                                         Thread* self,
-                                                        const char* name,
+                                                        const char* descriptor,
+                                                        size_t descriptor_length,
                                                         Handle<mirror::ClassLoader> class_loader)
     REQUIRES_SHARED(Locks::mutator_lock_) {
-  ObjPtr<mirror::Class> result = class_linker->FindClass(self, name, class_loader);
+  ObjPtr<mirror::Class> result =
+      class_linker->FindClass(self, descriptor, descriptor_length, class_loader);
   if (result == nullptr) {
     DCHECK(self->IsExceptionPending());
     self->ClearException();
@@ -403,18 +405,24 @@ static ObjPtr<mirror::Class> FindClassAndClearException(ClassLinker* class_linke
   return result;
 }
 
-static const char* GetStringFromId(const DexFile& dex_file,
-                                   dex::StringIndex string_id,
-                                   uint32_t number_of_extra_strings,
-                                   const uint32_t* extra_strings_offsets,
-                                   const uint8_t* verifier_deps) {
+static const char* GetStringFromIndex(const DexFile& dex_file,
+                                      dex::StringIndex string_id,
+                                      uint32_t number_of_extra_strings,
+                                      const uint32_t* extra_strings_offsets,
+                                      const uint8_t* verifier_deps,
+                                      /*out*/ size_t* utf8_length) {
   uint32_t num_ids_in_dex = dex_file.NumStringIds();
   if (string_id.index_ < num_ids_in_dex) {
-    return dex_file.GetStringData(string_id);
+    uint32_t utf16_length;
+    const char* str = dex_file.GetStringDataAndUtf16Length(string_id, &utf16_length);
+    *utf8_length = DexFile::Utf8Length(str, utf16_length);
+    return str;
   } else {
     CHECK_LT(string_id.index_ - num_ids_in_dex, number_of_extra_strings);
     uint32_t offset = extra_strings_offsets[string_id.index_ - num_ids_in_dex];
-    return reinterpret_cast<const char*>(verifier_deps) + offset;
+    const char* str = reinterpret_cast<const char*>(verifier_deps) + offset;
+    *utf8_length = strlen(str);
+    return str;
   }
 }
 
@@ -499,20 +507,25 @@ ClassStatus VdexFile::ComputeClassStatus(Thread* self, Handle<mirror::Class> cls
       // Error parsing the data, just return that we are not verified.
       return ClassStatus::kResolved;
     }
-    const char* destination_desc = GetStringFromId(dex_file,
-                                                   dex::StringIndex(destination_index),
-                                                   number_of_extra_strings,
-                                                   extra_strings_offsets,
-                                                   verifier_deps);
-    destination.Assign(
-        FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-
-    const char* source_desc = GetStringFromId(dex_file,
-                                              dex::StringIndex(source_index),
-                                              number_of_extra_strings,
-                                              extra_strings_offsets,
-                                              verifier_deps);
-    source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
+    size_t destination_desc_length;
+    const char* destination_desc = GetStringFromIndex(dex_file,
+                                                      dex::StringIndex(destination_index),
+                                                      number_of_extra_strings,
+                                                      extra_strings_offsets,
+                                                      verifier_deps,
+                                                      &destination_desc_length);
+    destination.Assign(FindClassAndClearException(
+        class_linker, self, destination_desc, destination_desc_length, class_loader));
+
+    size_t source_desc_length;
+    const char* source_desc = GetStringFromIndex(dex_file,
+                                                 dex::StringIndex(source_index),
+                                                 number_of_extra_strings,
+                                                 extra_strings_offsets,
+                                                 verifier_deps,
+                                                 &source_desc_length);
+    source.Assign(FindClassAndClearException(
+        class_linker, self, source_desc, source_desc_length, class_loader));
 
     if (destination == nullptr || source == nullptr) {
       // The interpreter / compiler can handle a missing class.
diff --git a/runtime/verifier/class_verifier.cc b/runtime/verifier/class_verifier.cc
index eea737608b..07202901fc 100644
--- a/runtime/verifier/class_verifier.cc
+++ b/runtime/verifier/class_verifier.cc
@@ -111,65 +111,67 @@ FailureKind ClassVerifier::VerifyClass(Thread* self,
   MethodVerifier::FailureData failure_data;
   ClassLinker* const linker = Runtime::Current()->GetClassLinker();
 
-  for (const ClassAccessor::Method& method : accessor.GetMethods()) {
-    int64_t* previous_idx = &previous_method_idx[method.IsStaticOrDirect() ? 0u : 1u];
-    self->AllowThreadSuspension();
-    const uint32_t method_idx = method.GetIndex();
-    if (method_idx == *previous_idx) {
-      // smali can create dex files with two encoded_methods sharing the same method_idx
-      // http://code.google.com/p/smali/issues/detail?id=119
-      continue;
-    }
-    *previous_idx = method_idx;
-    std::string hard_failure_msg;
-    MethodVerifier::FailureData result =
-        MethodVerifier::VerifyMethod(self,
-                                     linker,
-                                     Runtime::Current()->GetArenaPool(),
-                                     verifier_deps,
-                                     method_idx,
-                                     dex_file,
-                                     dex_cache,
-                                     class_loader,
-                                     class_def,
-                                     method.GetCodeItem(),
-                                     method.GetAccessFlags(),
-                                     log_level,
-                                     api_level,
-                                     Runtime::Current()->IsAotCompiler(),
-                                     &hard_failure_msg);
-    if (result.kind == FailureKind::kHardFailure) {
-      if (failure_data.kind == FailureKind::kHardFailure) {
-        // If we logged an error before, we need a newline.
-        *error += "\n";
-      } else {
-        // If we didn't log a hard failure before, print the header of the message.
-        *error += "Verifier rejected class ";
-        *error += PrettyDescriptor(dex_file->GetClassDescriptor(class_def));
-        *error += ":";
+  if (accessor.NumMethods() != 0u) {
+    ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
+    RegTypeCache reg_types(self, linker, arena_pool, class_loader, dex_file);
+    for (const ClassAccessor::Method& method : accessor.GetMethods()) {
+      int64_t* previous_idx = &previous_method_idx[method.IsStaticOrDirect() ? 0u : 1u];
+      self->AllowThreadSuspension();
+      const uint32_t method_idx = method.GetIndex();
+      if (method_idx == *previous_idx) {
+        // smali can create dex files with two encoded_methods sharing the same method_idx
+        // http://code.google.com/p/smali/issues/detail?id=119
+        continue;
       }
-      *error += " ";
-      *error += hard_failure_msg;
-    } else if (result.kind != FailureKind::kNoFailure) {
-      UpdateMethodFlags(method.GetIndex(), klass, dex_cache, callbacks, result.types);
-      if ((result.types & VerifyError::VERIFY_ERROR_LOCKING) != 0) {
-        // Print a warning about expected slow-down.
-        // Use a string temporary to print one contiguous warning.
-        std::string tmp =
-            StringPrintf("Method %s failed lock verification and will run slower.",
-                         dex_file->PrettyMethod(method.GetIndex()).c_str());
-        if (!gPrintedDxMonitorText) {
-          tmp +=
-              "\nCommon causes for lock verification issues are non-optimized dex code\n"
-              "and incorrect proguard optimizations.";
-          gPrintedDxMonitorText = true;
+      *previous_idx = method_idx;
+      std::string hard_failure_msg;
+      MethodVerifier::FailureData result =
+          MethodVerifier::VerifyMethod(self,
+                                       arena_pool,
+                                       &reg_types,
+                                       verifier_deps,
+                                       method_idx,
+                                       dex_cache,
+                                       class_def,
+                                       method.GetCodeItem(),
+                                       method.GetAccessFlags(),
+                                       log_level,
+                                       api_level,
+                                       Runtime::Current()->IsAotCompiler(),
+                                       &hard_failure_msg);
+      if (result.kind == FailureKind::kHardFailure) {
+        if (failure_data.kind == FailureKind::kHardFailure) {
+          // If we logged an error before, we need a newline.
+          *error += "\n";
+        } else {
+          // If we didn't log a hard failure before, print the header of the message.
+          *error += "Verifier rejected class ";
+          *error += PrettyDescriptor(dex_file->GetClassDescriptor(class_def));
+          *error += ":";
+        }
+        *error += " ";
+        *error += hard_failure_msg;
+      } else if (result.kind != FailureKind::kNoFailure) {
+        UpdateMethodFlags(method.GetIndex(), klass, dex_cache, callbacks, result.types);
+        if ((result.types & VerifyError::VERIFY_ERROR_LOCKING) != 0) {
+          // Print a warning about expected slow-down.
+          // Use a string temporary to print one contiguous warning.
+          std::string tmp =
+              StringPrintf("Method %s failed lock verification and will run slower.",
+                           dex_file->PrettyMethod(method.GetIndex()).c_str());
+          if (!gPrintedDxMonitorText) {
+            tmp +=
+                "\nCommon causes for lock verification issues are non-optimized dex code\n"
+                "and incorrect proguard optimizations.";
+            gPrintedDxMonitorText = true;
+          }
+          LOG(WARNING) << tmp;
         }
-        LOG(WARNING) << tmp;
       }
-    }
 
-    // Merge the result for the method into the global state for the class.
-    failure_data.Merge(result);
+      // Merge the result for the method into the global state for the class.
+      failure_data.Merge(result);
+    }
   }
   uint64_t elapsed_time_microseconds = timer.Stop();
   VLOG(verifier) << "VerifyClass took " << PrettyDuration(UsToNs(elapsed_time_microseconds))
diff --git a/runtime/verifier/class_verifier.h b/runtime/verifier/class_verifier.h
index 75a5a35b7e..b49e6182a1 100644
--- a/runtime/verifier/class_verifier.h
+++ b/runtime/verifier/class_verifier.h
@@ -27,7 +27,6 @@
 #include "handle.h"
 #include "obj_ptr.h"
 #include "verifier/method_verifier.h"
-#include "verifier/reg_type_cache.h"
 #include "verifier_enums.h"
 
 namespace art HIDDEN {
diff --git a/runtime/verifier/instruction_flags.cc b/runtime/verifier/instruction_flags.cc
index 73fb375731..a95e5b1f17 100644
--- a/runtime/verifier/instruction_flags.cc
+++ b/runtime/verifier/instruction_flags.cc
@@ -22,17 +22,16 @@ namespace art HIDDEN {
 namespace verifier {
 
 std::string InstructionFlags::ToString() const {
-  char encoding[8];
+  char encoding[7];
   if (!IsOpcode()) {
-    strncpy(encoding, "XXXXXXX", sizeof(encoding));
+    strncpy(encoding, "XXXXXX", sizeof(encoding));
   } else {
-    strncpy(encoding, "-------", sizeof(encoding));
+    strncpy(encoding, "------", sizeof(encoding));
     if (IsVisited())               encoding[kVisited] = 'V';
     if (IsChanged())               encoding[kChanged] = 'C';
     if (IsOpcode())                encoding[kOpcode] = 'O';
     if (IsInTry())                 encoding[kInTry] = 'T';
     if (IsBranchTarget())          encoding[kBranchTarget] = 'B';
-    if (IsCompileTimeInfoPoint())  encoding[kCompileTimeInfoPoint] = 'G';
     if (IsReturn())                encoding[kReturn] = 'R';
   }
   return encoding;
diff --git a/runtime/verifier/instruction_flags.h b/runtime/verifier/instruction_flags.h
index da5e2cd178..60a58b696b 100644
--- a/runtime/verifier/instruction_flags.h
+++ b/runtime/verifier/instruction_flags.h
@@ -58,15 +58,6 @@ class InstructionFlags final {
   bool IsBranchTarget() const {
     return (flags_ & (1 << kBranchTarget)) != 0;
   }
-  void SetCompileTimeInfoPoint() {
-    flags_ |= 1 << kCompileTimeInfoPoint;
-  }
-  void ClearCompileTimeInfoPoint() {
-    flags_ &= ~(1 << kCompileTimeInfoPoint);
-  }
-  bool IsCompileTimeInfoPoint() const {
-    return (flags_ & (1 << kCompileTimeInfoPoint)) != 0;
-  }
 
   void SetVisited() {
     flags_ |= 1 << kVisited;
@@ -104,6 +95,10 @@ class InstructionFlags final {
 
   std::string ToString() const;
 
+  bool Equals(const InstructionFlags& other) const {
+    return flags_ == other.flags_;
+  }
+
  private:
   enum {
     // The instruction has been visited and unless IsChanged() verified.
@@ -117,10 +112,8 @@ class InstructionFlags final {
     kInTry = 3,
     // Instruction is the target of a branch (ie the start of a basic block).
     kBranchTarget = 4,
-    // Location of interest to the compiler for GC maps and verifier based method sharpening.
-    kCompileTimeInfoPoint = 5,
     // A return instruction.
-    kReturn = 6,
+    kReturn = 5,
   };
   uint8_t flags_;
 };
diff --git a/runtime/verifier/method_verifier.cc b/runtime/verifier/method_verifier.cc
index fccb60b3e6..74ea53b3f3 100644
--- a/runtime/verifier/method_verifier.cc
+++ b/runtime/verifier/method_verifier.cc
@@ -40,6 +40,7 @@
 #include "dex/dex_file-inl.h"
 #include "dex/dex_file_exception_helpers.h"
 #include "dex/dex_instruction-inl.h"
+#include "dex/dex_instruction_list.h"
 #include "dex/dex_instruction_utils.h"
 #include "experimental_flags.h"
 #include "gc/accounting/card_table-inl.h"
@@ -56,6 +57,7 @@
 #include "mirror/var_handle.h"
 #include "obj_ptr-inl.h"
 #include "reg_type-inl.h"
+#include "reg_type_cache.h"
 #include "register_line-inl.h"
 #include "runtime.h"
 #include "scoped_newline.h"
@@ -72,13 +74,13 @@ using android::base::StringPrintf;
 
 static constexpr bool kTimeVerifyMethod = !kIsDebugBuild;
 
-PcToRegisterLineTable::PcToRegisterLineTable(ScopedArenaAllocator& allocator)
+PcToRegisterLineTable::PcToRegisterLineTable(ArenaAllocator& allocator)
     : register_lines_(allocator.Adapter(kArenaAllocVerifier)) {}
 
 void PcToRegisterLineTable::Init(InstructionFlags* flags,
                                  uint32_t insns_size,
                                  uint16_t registers_size,
-                                 ScopedArenaAllocator& allocator,
+                                 ArenaAllocator& allocator,
                                  RegTypeCache* reg_types,
                                  uint32_t interesting_dex_pc) {
   DCHECK_GT(insns_size, 0U);
@@ -125,64 +127,66 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
     return IsConstructor() && !IsStatic();
   }
 
-  const RegType& ResolveCheckedClass(dex::TypeIndex class_idx) override
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(!HasFailures());
-    const RegType& result = ResolveClass<CheckAccess::kYes>(class_idx);
-    DCHECK(!HasFailures());
-    return result;
-  }
-
   void FindLocksAtDexPc() REQUIRES_SHARED(Locks::mutator_lock_);
 
  private:
   MethodVerifier(Thread* self,
-                 ClassLinker* class_linker,
                  ArenaPool* arena_pool,
+                 RegTypeCache* reg_types,
                  VerifierDeps* verifier_deps,
-                 const DexFile* dex_file,
                  const dex::CodeItem* code_item,
                  uint32_t method_idx,
-                 bool can_load_classes,
-                 bool allow_thread_suspension,
                  bool aot_mode,
                  Handle<mirror::DexCache> dex_cache,
-                 Handle<mirror::ClassLoader> class_loader,
                  const dex::ClassDef& class_def,
                  uint32_t access_flags,
                  bool verify_to_dump,
                  uint32_t api_level) REQUIRES_SHARED(Locks::mutator_lock_)
      : art::verifier::MethodVerifier(self,
-                                     class_linker,
                                      arena_pool,
+                                     reg_types,
                                      verifier_deps,
-                                     dex_file,
                                      class_def,
                                      code_item,
                                      method_idx,
-                                     can_load_classes,
-                                     allow_thread_suspension,
                                      aot_mode),
        method_access_flags_(access_flags),
        return_type_(nullptr),
        dex_cache_(dex_cache),
-       class_loader_(class_loader),
+       class_loader_(reg_types->GetClassLoader()),
        declaring_class_(nullptr),
        interesting_dex_pc_(-1),
        monitor_enter_dex_pcs_(nullptr),
        verify_to_dump_(verify_to_dump),
-       allow_thread_suspension_(allow_thread_suspension),
+       allow_thread_suspension_(reg_types->CanSuspend()),
        is_constructor_(false),
        api_level_(api_level == 0 ? std::numeric_limits<uint32_t>::max() : api_level) {
+    DCHECK_EQ(dex_cache->GetDexFile(), reg_types->GetDexFile())
+        << dex_cache->GetDexFile()->GetLocation() << " / "
+        << reg_types->GetDexFile()->GetLocation();
   }
 
-  void UninstantiableError(const char* descriptor) {
-    Fail(VerifyError::VERIFY_ERROR_NO_CLASS) << "Could not create precise reference for "
-                                             << "non-instantiable klass " << descriptor;
+  void FinalAbstractClassError(ObjPtr<mirror::Class> klass) REQUIRES_SHARED(Locks::mutator_lock_) {
+    // Note: We reuse NO_CLASS as the instruction we're checking shall throw an exception at
+    // runtime if executed. A final abstract class shall fail verification, so no instances can
+    // be created and therefore instance field or method access can be reached only for a null
+    // reference and throw NPE. All other instructions where we check for final abstract class
+    // shall throw `VerifyError`. (But we can also hit OOME/SOE while creating the exception.)
+    std::string temp;
+    const char* descriptor = klass->GetDescriptor(&temp);
+    Fail(VerifyError::VERIFY_ERROR_NO_CLASS)
+        << "Final abstract class used in a context that requires a verified class: " << descriptor;
   }
-  static bool IsInstantiableOrPrimitive(ObjPtr<mirror::Class> klass)
+
+  void CheckForFinalAbstractClass(ObjPtr<mirror::Class> klass)
       REQUIRES_SHARED(Locks::mutator_lock_) {
-    return klass->IsInstantiable() || klass->IsPrimitive();
+    if (UNLIKELY(klass->IsFinal() &&
+                 klass->IsAbstract() &&
+                 !klass->IsInterface() &&
+                 !klass->IsPrimitive() &&
+                 !klass->IsArrayClass())) {
+      FinalAbstractClassError(klass);
+    }
   }
 
   // Is the method being verified a constructor? See the comment on the field.
@@ -246,7 +250,6 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
    *
    * Walks through instructions in a method calling VerifyInstruction on each.
    */
-  template <bool kAllowRuntimeOnlyInstructions>
   bool VerifyInstructions();
 
   /*
@@ -282,8 +285,10 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
    * - (earlier) for each exception handler, the handler must start at a valid
    *   instruction
    */
-  template <bool kAllowRuntimeOnlyInstructions>
-  bool VerifyInstruction(const Instruction* inst, uint32_t code_offset);
+  template <Instruction::Code kDispatchOpcode>
+  ALWAYS_INLINE bool VerifyInstruction(const Instruction* inst,
+                                       uint32_t code_offset,
+                                       uint16_t inst_data);
 
   /* Ensure that the register index is valid for this code item. */
   bool CheckRegisterIndex(uint32_t idx) {
@@ -317,12 +322,96 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
     return true;
   }
 
-  // Perform static checks on a field Get or set instruction. All we do here is ensure that the
-  // field index is in the valid range.
-  bool CheckFieldIndex(uint32_t idx) {
-    if (UNLIKELY(idx >= dex_file_->GetHeader().field_ids_size_)) {
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "bad field index " << idx << " (max "
-                                        << dex_file_->GetHeader().field_ids_size_ << ")";
+  // Perform static checks on a field Get or set instruction. We ensure that the field index
+  // is in the valid range and we check that the field descriptor matches the instruction.
+  ALWAYS_INLINE bool CheckFieldIndex(const Instruction* inst,
+                                     uint16_t inst_data,
+                                     uint32_t field_idx) {
+    if (UNLIKELY(field_idx >= dex_file_->NumFieldIds())) {
+      FailBadFieldIndex(field_idx);
+      return false;
+    }
+
+    // Prepare a table with permitted descriptors, evaluated at compile time.
+    static constexpr uint32_t kVerifyFieldIndexFlags =
+        Instruction::kVerifyRegBField | Instruction::kVerifyRegCField;
+    static constexpr uint32_t kMinFieldAccessOpcode = []() constexpr {
+      for (uint32_t opcode = 0u; opcode != 256u; ++opcode) {
+        uint32_t verify_flags = Instruction::VerifyFlagsOf(enum_cast<Instruction::Code>(opcode));
+        if ((verify_flags & kVerifyFieldIndexFlags) != 0u) {
+          return opcode;
+        }
+      }
+      LOG(FATAL) << "Compile time error if we reach this.";
+      return 0u;
+    }();
+    static constexpr uint32_t kMaxFieldAccessOpcode = []() constexpr {
+      for (uint32_t opcode = 256u; opcode != 0u; ) {
+        --opcode;
+        uint32_t verify_flags = Instruction::VerifyFlagsOf(enum_cast<Instruction::Code>(opcode));
+        if ((verify_flags & kVerifyFieldIndexFlags) != 0u) {
+          return opcode;
+        }
+      }
+      LOG(FATAL) << "Compile time error if we reach this.";
+      return 0u;
+    }();
+    static constexpr uint32_t kArraySize = kMaxFieldAccessOpcode + 1u - kMinFieldAccessOpcode;
+    using PermittedDescriptorArray = std::array<std::pair<char, char>, kArraySize>;
+    static constexpr PermittedDescriptorArray kPermittedDescriptors = []() constexpr {
+      PermittedDescriptorArray result;
+      for (uint32_t index = 0u; index != kArraySize; ++index) {
+        Instruction::Code opcode = enum_cast<Instruction::Code>(index + kMinFieldAccessOpcode);
+        DexMemAccessType access_type;
+        if (IsInstructionIGet(opcode) || IsInstructionIPut(opcode)) {
+          access_type = IGetOrIPutMemAccessType(opcode);
+        } else {
+          // `iget*`, `iput*`, `sget*` and `sput*` instructions form a contiguous range.
+          CHECK(IsInstructionSGet(opcode) || IsInstructionSPut(opcode));
+          access_type = SGetOrSPutMemAccessType(opcode);
+        }
+        switch (access_type) {
+          case DexMemAccessType::kDexMemAccessWord:
+            result[index] = { 'I', 'F' };
+            break;
+          case DexMemAccessType::kDexMemAccessWide:
+            result[index] = { 'J', 'D' };
+            break;
+          case DexMemAccessType::kDexMemAccessObject:
+            result[index] = { 'L', '[' };
+            break;
+          case DexMemAccessType::kDexMemAccessBoolean:
+            result[index] = { 'Z', 'Z' };  // Only one character is permitted.
+            break;
+          case DexMemAccessType::kDexMemAccessByte:
+            result[index] = { 'B', 'B' };  // Only one character is permitted.
+            break;
+          case DexMemAccessType::kDexMemAccessChar:
+            result[index] = { 'C', 'C' };  // Only one character is permitted.
+            break;
+          case DexMemAccessType::kDexMemAccessShort:
+            result[index] = { 'S', 'S' };  // Only one character is permitted.
+            break;
+          default:
+            LOG(FATAL) << "Compile time error if we reach this.";
+            break;
+        }
+      }
+      return result;
+    }();
+
+    // Check the first character of the field type descriptor.
+    Instruction::Code opcode = inst->Opcode(inst_data);
+    DCHECK_GE(opcode, kMinFieldAccessOpcode);
+    DCHECK_LE(opcode, kMaxFieldAccessOpcode);
+    std::pair<char, char> permitted = kPermittedDescriptors[opcode - kMinFieldAccessOpcode];
+    const char* descriptor = dex_file_->GetFieldTypeDescriptor(field_idx);
+    if (UNLIKELY(descriptor[0] != permitted.first && descriptor[0] != permitted.second)) {
+      Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+          << "expected field " << dex_file_->PrettyField(field_idx)
+          << " to have type descritor starting with '" << permitted.first
+          << (permitted.second != permitted.first ? std::string("' or '") + permitted.second : "")
+          << "' but found '" << descriptor[0] << "' in " << opcode;
       return false;
     }
     return true;
@@ -330,10 +419,9 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
 
   // Perform static checks on a method invocation instruction. All we do here is ensure that the
   // method index is in the valid range.
-  bool CheckMethodIndex(uint32_t idx) {
-    if (UNLIKELY(idx >= dex_file_->GetHeader().method_ids_size_)) {
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "bad method index " << idx << " (max "
-                                        << dex_file_->GetHeader().method_ids_size_ << ")";
+  ALWAYS_INLINE bool CheckMethodIndex(uint32_t method_idx) {
+    if (UNLIKELY(method_idx >= dex_file_->NumMethodIds())) {
+      FailBadMethodIndex(method_idx);
       return false;
     }
     return true;
@@ -407,20 +495,29 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
 
   // Check the register indices used in a "vararg" instruction, such as invoke-virtual or
   // filled-new-array.
-  // - vA holds word count (0-5), args[] have values.
+  // - inst is the instruction from which we retrieve the arguments
+  // - vA holds the argument count (0-5)
   // There are some tests we don't do here, e.g. we don't try to verify that invoking a method that
   // takes a double is done with consecutive registers. This requires parsing the target method
   // signature, which we will be doing later on during the code flow analysis.
-  bool CheckVarArgRegs(uint32_t vA, uint32_t arg[]) {
+  bool CheckVarArgRegs(const Instruction* inst, uint32_t vA) {
     uint16_t registers_size = code_item_accessor_.RegistersSize();
-    for (uint32_t idx = 0; idx < vA; idx++) {
-      if (UNLIKELY(arg[idx] >= registers_size)) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invalid reg index (" << arg[idx]
-                                          << ") in non-range invoke (>= " << registers_size << ")";
-        return false;
+    // All args are 4-bit and therefore under 16. We do not need to check args for
+    // `registers_size >= 16u` but let's check them anyway in debug builds.
+    if (registers_size < 16u || kIsDebugBuild) {
+      uint32_t args[Instruction::kMaxVarArgRegs];
+      inst->GetVarArgs(args);
+      for (uint32_t idx = 0; idx < vA; idx++) {
+        DCHECK_LT(args[idx], 16u);
+        if (UNLIKELY(args[idx] >= registers_size)) {
+          DCHECK_LT(registers_size, 16u);
+          Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+              << "invalid reg index (" << args[idx]
+              << ") in non-range invoke (>= " << registers_size << ")";
+          return false;
+        }
       }
     }
-
     return true;
   }
 
@@ -523,8 +620,8 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Helper to perform verification on puts of primitive type.
-  void VerifyPrimitivePut(const RegType& target_type, const RegType& insn_type,
-                          const uint32_t vregA) REQUIRES_SHARED(Locks::mutator_lock_);
+  void VerifyPrimitivePut(const RegType& target_type, uint32_t vregA)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Perform verification of an aget instruction. The destination register's type will be set to
   // be that of component type of the array unless the array type is unknown, in which case a
@@ -538,16 +635,18 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
                   bool is_primitive) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Lookup instance field and fail for resolution violations
-  ArtField* GetInstanceField(const RegType& obj_type, int field_idx)
+  ArtField* GetInstanceField(uint32_t vregB, uint32_t field_idx, bool is_put)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Lookup static field and fail for resolution violations
-  ArtField* GetStaticField(int field_idx) REQUIRES_SHARED(Locks::mutator_lock_);
+  ArtField* GetStaticField(uint32_t field_idx, bool is_put) REQUIRES_SHARED(Locks::mutator_lock_);
+
+  // Common checks for `GetInstanceField()` and `GetStaticField()`.
+  ArtField* GetISFieldCommon(ArtField* field, bool is_put) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Perform verification of an iget/sget/iput/sput instruction.
   template <FieldAccessType kAccType>
-  void VerifyISFieldAccess(const Instruction* inst, const RegType& insn_type,
-                           bool is_primitive, bool is_static)
+  void VerifyISFieldAccess(const Instruction* inst, bool is_primitive, bool is_static)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Resolves a class based on an index and, if C is kYes, performs access checks to ensure
@@ -668,36 +767,368 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
   const RegType& GetDeclaringClass() REQUIRES_SHARED(Locks::mutator_lock_) {
     if (declaring_class_ == nullptr) {
       const dex::MethodId& method_id = dex_file_->GetMethodId(dex_method_idx_);
-      const char* descriptor
-          = dex_file_->GetTypeDescriptor(dex_file_->GetTypeId(method_id.class_idx_));
-      declaring_class_ = &reg_types_.FromDescriptor(class_loader_, descriptor);
+      declaring_class_ = &reg_types_.FromTypeIndex(method_id.class_idx_);
     }
     return *declaring_class_;
   }
 
-  InstructionFlags* CurrentInsnFlags() {
-    return &GetModifiableInstructionFlags(work_insn_idx_);
+  ObjPtr<mirror::Class> GetRegTypeClass(const RegType& reg_type)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(reg_type.IsJavaLangObject() || reg_type.IsReference()) << reg_type;
+    return reg_type.IsJavaLangObject() ? GetClassRoot<mirror::Object>(GetClassLinker())
+                                       : reg_type.GetClass();
   }
 
-  const RegType& DetermineCat1Constant(int32_t value)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+  bool CanAccess(const RegType& other) REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(other.IsJavaLangObject() || other.IsReference() || other.IsUnresolvedReference());
+    const RegType& declaring_class = GetDeclaringClass();
+    if (declaring_class.Equals(other)) {
+      return true;  // Trivial accessibility.
+    } else if (other.IsUnresolvedReference()) {
+      return false;  // More complicated test not possible on unresolved types, be conservative.
+    } else if (declaring_class.IsUnresolvedReference()) {
+      // Be conservative, only allow if `other` is public.
+      return other.IsJavaLangObject() || (other.IsReference() && other.GetClass()->IsPublic());
+    } else {
+      return GetRegTypeClass(declaring_class)->CanAccess(GetRegTypeClass(other));
+    }
+  }
+
+  bool CanAccessMember(ObjPtr<mirror::Class> klass, uint32_t access_flags)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    const RegType& declaring_class = GetDeclaringClass();
+    if (declaring_class.IsUnresolvedReference()) {
+      return false;  // More complicated test not possible on unresolved types, be conservative.
+    } else {
+      return GetRegTypeClass(declaring_class)->CanAccessMember(klass, access_flags);
+    }
+  }
+
+  NO_INLINE void FailInvalidArgCount(const Instruction* inst, uint32_t arg_count) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "invalid arg count (" << arg_count << ") in " << inst->Name();
+  }
+
+  NO_INLINE void FailUnexpectedOpcode(const Instruction* inst) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "unexpected opcode " << inst->Name();
+  }
+
+  NO_INLINE void FailBadFieldIndex(uint32_t field_idx) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "bad field index " << field_idx << " (max " << dex_file_->NumFieldIds() << ")";
+  }
+
+  NO_INLINE void FailBadMethodIndex(uint32_t method_idx) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "bad method index " << method_idx << " (max " << dex_file_->NumMethodIds() << ")";
+  }
+
+  NO_INLINE void FailForRegisterType(uint32_t vsrc,
+                                     const RegType& check_type,
+                                     const RegType& src_type,
+                                     VerifyError fail_type = VERIFY_ERROR_BAD_CLASS_HARD)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    Fail(fail_type)
+        << "register v" << vsrc << " has type " << src_type << " but expected " << check_type;
+  }
+
+  NO_INLINE void FailForRegisterType(uint32_t vsrc,
+                                     RegType::Kind check_kind,
+                                     uint16_t src_type_id)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    FailForRegisterType(
+        vsrc, reg_types_.GetFromRegKind(check_kind), reg_types_.GetFromId(src_type_id));
+  }
+
+  NO_INLINE void FailForRegisterTypeWide(uint32_t vsrc,
+                                         const RegType& src_type,
+                                         const RegType& src_type_h)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "wide register v" << vsrc << " has type " << src_type << "/" << src_type_h;
+  }
+
+  NO_INLINE void FailForRegisterTypeWide(uint32_t vsrc,
+                                         uint16_t src_type_id,
+                                         uint16_t src_type_id_h)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    FailForRegisterTypeWide(
+        vsrc, reg_types_.GetFromId(src_type_id), reg_types_.GetFromId(src_type_id_h));
+  }
+
+  ALWAYS_INLINE inline bool VerifyRegisterType(uint32_t vsrc, const RegType& check_type)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    // Verify the src register type against the check type refining the type of the register
+    const RegType& src_type = work_line_->GetRegisterType(this, vsrc);
+    if (UNLIKELY(!IsAssignableFrom(check_type, src_type))) {
+      enum VerifyError fail_type;
+      if (!check_type.IsNonZeroReferenceTypes() || !src_type.IsNonZeroReferenceTypes()) {
+        // Hard fail if one of the types is primitive, since they are concretely known.
+        fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
+      } else if (check_type.IsUninitializedTypes() || src_type.IsUninitializedTypes()) {
+        // Hard fail for uninitialized types, which don't match anything but themselves.
+        fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
+      } else if (check_type.IsUnresolvedTypes() || src_type.IsUnresolvedTypes()) {
+        fail_type = VERIFY_ERROR_UNRESOLVED_TYPE_CHECK;
+      } else {
+        fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
+      }
+      FailForRegisterType(vsrc, check_type, src_type, fail_type);
+      return false;
+    }
+    if (check_type.IsLowHalf()) {
+      const RegType& src_type_h = work_line_->GetRegisterType(this, vsrc + 1);
+      if (UNLIKELY(!src_type.CheckWidePair(src_type_h))) {
+        FailForRegisterTypeWide(vsrc, src_type, src_type_h);
+        return false;
+      }
+    }
+    // The register at vsrc has a defined type, we know the lower-upper-bound, but this is less
+    // precise than the subtype in vsrc so leave it for reference types. For primitive types if
+    // they are a defined type then they are as precise as we can get, however, for constant types
+    // we may wish to refine them. Unfortunately constant propagation has rendered this useless.
+    return true;
+  }
+
+  ALWAYS_INLINE inline bool VerifyRegisterType(uint32_t vsrc, RegType::Kind check_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(check_kind == RegType::Kind::kInteger || check_kind == RegType::Kind::kFloat);
+    // Verify the src register type against the check type refining the type of the register
+    uint16_t src_type_id = work_line_->GetRegisterTypeId(vsrc);
+    if (UNLIKELY(src_type_id >= RegTypeCache::NumberOfRegKindCacheIds()) ||
+        UNLIKELY(RegType::AssignabilityFrom(check_kind, RegTypeCache::RegKindForId(src_type_id)) !=
+                     RegType::Assignability::kAssignable)) {
+      // Integer or float assignability is never a `kNarrowingConversion` or `kReference`.
+      DCHECK_EQ(
+          RegType::AssignabilityFrom(check_kind, reg_types_.GetFromId(src_type_id).GetKind()),
+          RegType::Assignability::kNotAssignable);
+      FailForRegisterType(vsrc, check_kind, src_type_id);
+      return false;
+    }
+    return true;
+  }
+
+  bool VerifyRegisterTypeWide(uint32_t vsrc, RegType::Kind check_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(check_kind == RegType::Kind::kLongLo || check_kind == RegType::Kind::kDoubleLo);
+    // Verify the src register type against the check type refining the type of the register
+    uint16_t src_type_id = work_line_->GetRegisterTypeId(vsrc);
+    if (UNLIKELY(src_type_id >= RegTypeCache::NumberOfRegKindCacheIds()) ||
+        UNLIKELY(RegType::AssignabilityFrom(check_kind, RegTypeCache::RegKindForId(src_type_id)) !=
+                     RegType::Assignability::kAssignable)) {
+      // Wide assignability is never a `kNarrowingConversion` or `kReference`.
+      DCHECK_EQ(
+          RegType::AssignabilityFrom(check_kind, reg_types_.GetFromId(src_type_id).GetKind()),
+          RegType::Assignability::kNotAssignable);
+      FailForRegisterType(vsrc, check_kind, src_type_id);
+      return false;
+    }
+    uint16_t src_type_id_h = work_line_->GetRegisterTypeId(vsrc + 1);
+    uint16_t expected_src_type_id_h =
+        RegTypeCache::IdForRegKind(RegType::ToHighHalf(RegTypeCache::RegKindForId(src_type_id)));
+    DCHECK_EQ(src_type_id_h == expected_src_type_id_h,
+              reg_types_.GetFromId(src_type_id).CheckWidePair(reg_types_.GetFromId(src_type_id_h)));
+    if (UNLIKELY(src_type_id_h != expected_src_type_id_h)) {
+      FailForRegisterTypeWide(vsrc, src_type_id, src_type_id_h);
+      return false;
+    }
+    // The register at vsrc has a defined type, we know the lower-upper-bound, but this is less
+    // precise than the subtype in vsrc so leave it for reference types. For primitive types if
+    // they are a defined type then they are as precise as we can get, however, for constant types
+    // we may wish to refine them. Unfortunately constant propagation has rendered this useless.
+    return true;
+  }
+
+  /*
+   * Verify types for a simple two-register instruction (e.g. "neg-int").
+   * "dst_type" is stored into vA, and "src_type" is verified against vB.
+   */
+  void CheckUnaryOp(const Instruction* inst, RegType::Kind dst_kind, RegType::Kind src_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterType(inst->VRegB_12x(), src_kind)) {
+      work_line_->SetRegisterType(inst->VRegA_12x(), dst_kind);
+    }
+  }
+
+  void CheckUnaryOpWide(const Instruction* inst,
+                        RegType::Kind dst_kind,
+                        RegType::Kind src_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterTypeWide(inst->VRegB_12x(), src_kind)) {
+      work_line_->SetRegisterTypeWide(inst->VRegA_12x(), dst_kind, RegType::ToHighHalf(dst_kind));
+    }
+  }
+
+  void CheckUnaryOpToWide(const Instruction* inst,
+                          RegType::Kind dst_kind,
+                          RegType::Kind src_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterType(inst->VRegB_12x(), src_kind)) {
+      work_line_->SetRegisterTypeWide(inst->VRegA_12x(), dst_kind, RegType::ToHighHalf(dst_kind));
+    }
+  }
+
+  void CheckUnaryOpFromWide(const Instruction* inst,
+                            RegType::Kind dst_kind,
+                            RegType::Kind src_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterTypeWide(inst->VRegB_12x(), src_kind)) {
+      work_line_->SetRegisterType(inst->VRegA_12x(), dst_kind);
+    }
+  }
+
+  /*
+   * Verify types for a simple three-register instruction (e.g. "add-int").
+   * "dst_type" is stored into vA, and "src_type1"/"src_type2" are verified
+   * against vB/vC.
+   */
+  void CheckBinaryOp(const Instruction* inst,
+                     RegType::Kind dst_kind,
+                     RegType::Kind src_kind1,
+                     RegType::Kind src_kind2,
+                     bool check_boolean_op)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    const uint32_t vregA = inst->VRegA_23x();
+    const uint32_t vregB = inst->VRegB_23x();
+    const uint32_t vregC = inst->VRegC_23x();
+    if (VerifyRegisterType(vregB, src_kind1) &&
+        VerifyRegisterType(vregC, src_kind2)) {
+      if (check_boolean_op) {
+        DCHECK_EQ(dst_kind, RegType::Kind::kInteger);
+        if (RegType::IsBooleanTypes(
+                RegTypeCache::RegKindForId(work_line_->GetRegisterTypeId(vregB))) &&
+            RegType::IsBooleanTypes(
+                RegTypeCache::RegKindForId(work_line_->GetRegisterTypeId(vregC)))) {
+          work_line_->SetRegisterType(vregA, RegType::Kind::kBoolean);
+          return;
+        }
+      }
+      work_line_->SetRegisterType(vregA, dst_kind);
+    }
+  }
+
+  void CheckBinaryOpWide(const Instruction* inst,
+                         RegType::Kind dst_kind,
+                         RegType::Kind src_kind1,
+                         RegType::Kind src_kind2)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterTypeWide(inst->VRegB_23x(), src_kind1) &&
+        VerifyRegisterTypeWide(inst->VRegC_23x(), src_kind2)) {
+      work_line_->SetRegisterTypeWide(inst->VRegA_23x(), dst_kind, RegType::ToHighHalf(dst_kind));
+    }
+  }
+
+  void CheckBinaryOpWideCmp(const Instruction* inst,
+                            RegType::Kind dst_kind,
+                            RegType::Kind src_kind1,
+                            RegType::Kind src_kind2)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterTypeWide(inst->VRegB_23x(), src_kind1) &&
+        VerifyRegisterTypeWide(inst->VRegC_23x(), src_kind2)) {
+      work_line_->SetRegisterType(inst->VRegA_23x(), dst_kind);
+    }
+  }
+
+  void CheckBinaryOpWideShift(const Instruction* inst,
+                              RegType::Kind long_lo_kind,
+                              RegType::Kind int_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    if (VerifyRegisterTypeWide(inst->VRegB_23x(), long_lo_kind) &&
+        VerifyRegisterType(inst->VRegC_23x(), int_kind)) {
+      RegType::Kind long_hi_kind = RegType::ToHighHalf(long_lo_kind);
+      work_line_->SetRegisterTypeWide(inst->VRegA_23x(), long_lo_kind, long_hi_kind);
+    }
+  }
+
+  /*
+   * Verify types for a binary "2addr" operation. "src_type1"/"src_type2"
+   * are verified against vA/vB, then "dst_type" is stored into vA.
+   */
+  void CheckBinaryOp2addr(const Instruction* inst,
+                          RegType::Kind dst_kind,
+                          RegType::Kind src_kind1,
+                          RegType::Kind src_kind2,
+                          bool check_boolean_op)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    const uint32_t vregA = inst->VRegA_12x();
+    const uint32_t vregB = inst->VRegB_12x();
+    if (VerifyRegisterType(vregA, src_kind1) &&
+        VerifyRegisterType(vregB, src_kind2)) {
+      if (check_boolean_op) {
+        DCHECK_EQ(dst_kind, RegType::Kind::kInteger);
+        if (RegType::IsBooleanTypes(
+                RegTypeCache::RegKindForId(work_line_->GetRegisterTypeId(vregA))) &&
+            RegType::IsBooleanTypes(
+                RegTypeCache::RegKindForId(work_line_->GetRegisterTypeId(vregB)))) {
+          work_line_->SetRegisterType(vregA, RegType::Kind::kBoolean);
+          return;
+        }
+      }
+      work_line_->SetRegisterType(vregA, dst_kind);
+    }
+  }
 
-  // Try to create a register type from the given class. In case a precise type is requested, but
-  // the class is not instantiable, a soft error (of type NO_CLASS) will be enqueued and a
-  // non-precise reference will be returned.
-  // Note: we reuse NO_CLASS as this will throw an exception at runtime, when the failing class is
-  //       actually touched.
-  const RegType& FromClass(const char* descriptor, ObjPtr<mirror::Class> klass, bool precise)
+  void CheckBinaryOp2addrWide(const Instruction* inst,
+                              RegType::Kind dst_kind,
+                              RegType::Kind src_kind1,
+                              RegType::Kind src_kind2)
       REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(klass != nullptr);
-    if (precise && !klass->IsInstantiable() && !klass->IsPrimitive()) {
-      Fail(VerifyError::VERIFY_ERROR_NO_CLASS) << "Could not create precise reference for "
-          << "non-instantiable klass " << descriptor;
-      precise = false;
+    const uint32_t vregA = inst->VRegA_12x();
+    const uint32_t vregB = inst->VRegB_12x();
+    if (VerifyRegisterTypeWide(vregA, src_kind1) &&
+        VerifyRegisterTypeWide(vregB, src_kind2)) {
+      work_line_->SetRegisterTypeWide(vregA, dst_kind, RegType::ToHighHalf(dst_kind));
     }
-    return reg_types_.FromClass(descriptor, klass, precise);
   }
 
+  void CheckBinaryOp2addrWideShift(const Instruction* inst,
+                                   RegType::Kind long_lo_kind,
+                                   RegType::Kind int_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    const uint32_t vregA = inst->VRegA_12x();
+    const uint32_t vregB = inst->VRegB_12x();
+    if (VerifyRegisterTypeWide(vregA, long_lo_kind) &&
+        VerifyRegisterType(vregB, int_kind)) {
+      RegType::Kind long_hi_kind = RegType::ToHighHalf(long_lo_kind);
+      work_line_->SetRegisterTypeWide(vregA, long_lo_kind, long_hi_kind);
+    }
+  }
+
+  /*
+   * Verify types for A two-register instruction with a literal constant (e.g. "add-int/lit8").
+   * "dst_type" is stored into vA, and "src_type" is verified against vB.
+   *
+   * If "check_boolean_op" is set, we use the constant value in vC.
+   */
+  void CheckLiteralOp(const Instruction* inst,
+                      RegType::Kind dst_kind,
+                      RegType::Kind src_kind,
+                      bool check_boolean_op,
+                      bool is_lit16)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    const uint32_t vregA = is_lit16 ? inst->VRegA_22s() : inst->VRegA_22b();
+    const uint32_t vregB = is_lit16 ? inst->VRegB_22s() : inst->VRegB_22b();
+    if (VerifyRegisterType(vregB, src_kind)) {
+      if (check_boolean_op) {
+        DCHECK_EQ(dst_kind, RegType::Kind::kInteger);
+        /* check vB with the call, then check the constant manually */
+        const uint32_t val = is_lit16 ? inst->VRegC_22s() : inst->VRegC_22b();
+        if (work_line_->GetRegisterType(this, vregB).IsBooleanTypes() && (val == 0 || val == 1)) {
+          work_line_->SetRegisterType(vregA, RegType::Kind::kBoolean);
+          return;
+        }
+      }
+      work_line_->SetRegisterType(vregA, dst_kind);
+    }
+  }
+
+  InstructionFlags* CurrentInsnFlags() {
+    return &GetModifiableInstructionFlags(work_insn_idx_);
+  }
+
+  RegType::Kind DetermineCat1Constant(int32_t value)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   ALWAYS_INLINE bool FailOrAbort(bool condition, const char* error_msg, uint32_t work_insn_idx);
 
   ALWAYS_INLINE InstructionFlags& GetModifiableInstructionFlags(size_t index) {
@@ -705,9 +1136,30 @@ class MethodVerifier final : public ::art::verifier::MethodVerifier {
   }
 
   // Returns the method index of an invoke instruction.
-  uint16_t GetMethodIdxOfInvoke(const Instruction* inst)
+  static uint16_t GetMethodIdxOfInvoke(const Instruction* inst)
       REQUIRES_SHARED(Locks::mutator_lock_) {
-    return inst->VRegB();
+    // Note: This is compiled to a single load in release mode.
+    Instruction::Code opcode = inst->Opcode();
+    if (opcode == Instruction::INVOKE_VIRTUAL ||
+        opcode == Instruction::INVOKE_SUPER ||
+        opcode == Instruction::INVOKE_DIRECT ||
+        opcode == Instruction::INVOKE_STATIC ||
+        opcode == Instruction::INVOKE_INTERFACE ||
+        opcode == Instruction::INVOKE_CUSTOM) {
+      return inst->VRegB_35c();
+    } else if (opcode == Instruction::INVOKE_VIRTUAL_RANGE ||
+               opcode == Instruction::INVOKE_SUPER_RANGE ||
+               opcode == Instruction::INVOKE_DIRECT_RANGE ||
+               opcode == Instruction::INVOKE_STATIC_RANGE ||
+               opcode == Instruction::INVOKE_INTERFACE_RANGE ||
+               opcode == Instruction::INVOKE_CUSTOM_RANGE) {
+      return inst->VRegB_3rc();
+    } else if (opcode == Instruction::INVOKE_POLYMORPHIC) {
+      return inst->VRegB_45cc();
+    } else {
+      DCHECK_EQ(opcode, Instruction::INVOKE_POLYMORPHIC_RANGE);
+      return inst->VRegB_4rcc();
+    }
   }
   // Returns the field index of a field access instruction.
   uint16_t GetFieldIdxOfFieldAccess(const Instruction* inst, bool is_static)
@@ -848,50 +1300,32 @@ void MethodVerifier<kVerifierDebug>::FindLocksAtDexPc() {
 
 template <bool kVerifierDebug>
 bool MethodVerifier<kVerifierDebug>::Verify() {
-  // Some older code doesn't correctly mark constructors as such. Test for this case by looking at
-  // the name.
-  const dex::MethodId& method_id = dex_file_->GetMethodId(dex_method_idx_);
-  const std::string_view method_name = dex_file_->GetStringView(method_id.name_idx_);
-  bool instance_constructor_by_name = method_name == "<init>";
-  bool static_constructor_by_name = method_name == "<clinit>";
-  bool constructor_by_name = instance_constructor_by_name || static_constructor_by_name;
-  // Check that only constructors are tagged, and check for bad code that doesn't tag constructors.
+  // Some older code doesn't correctly mark constructors as such, so we need look
+  // at the name if the constructor flag is not present.
   if ((method_access_flags_ & kAccConstructor) != 0) {
-    if (!constructor_by_name) {
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD)
-            << "method is marked as constructor, but not named accordingly";
-      return false;
-    }
+    // `DexFileVerifier` rejects methods with the constructor flag without a constructor name.
+    DCHECK(dex_file_->GetMethodNameView(dex_method_idx_) == "<init>" ||
+           dex_file_->GetMethodNameView(dex_method_idx_) == "<clinit>");
     is_constructor_ = true;
-  } else if (constructor_by_name) {
+  } else if (dex_file_->GetMethodName(dex_method_idx_)[0] == '<') {
+    // `DexFileVerifier` rejects method names starting with '<' other than constructors.
+    DCHECK(dex_file_->GetMethodNameView(dex_method_idx_) == "<init>" ||
+           dex_file_->GetMethodNameView(dex_method_idx_) == "<clinit>");
     LOG(WARNING) << "Method " << dex_file_->PrettyMethod(dex_method_idx_)
                  << " not marked as constructor.";
     is_constructor_ = true;
   }
-  // If it's a constructor, check whether IsStatic() matches the name.
-  // This should have been rejected by the dex file verifier. Only do in debug build.
-  if (kIsDebugBuild) {
-    if (IsConstructor()) {
-      if (IsStatic() ^ static_constructor_by_name) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD)
-              << "constructor name doesn't match static flag";
-        return false;
-      }
-    }
+  // If it's a constructor, check whether IsStatic() matches the name for newer dex files.
+  // This should be rejected by the `DexFileVerifier` but it's  accepted for older dex files.
+  if (kIsDebugBuild && IsConstructor() && dex_file_->SupportsDefaultMethods()) {
+    CHECK_EQ(IsStatic(), dex_file_->GetMethodNameView(dex_method_idx_) == "<clinit>");
   }
 
   // Methods may only have one of public/protected/private.
   // This should have been rejected by the dex file verifier. Only do in debug build.
-  if (kIsDebugBuild) {
-    size_t access_mod_count =
-        (((method_access_flags_ & kAccPublic) == 0) ? 0 : 1) +
-        (((method_access_flags_ & kAccProtected) == 0) ? 0 : 1) +
-        (((method_access_flags_ & kAccPrivate) == 0) ? 0 : 1);
-    if (access_mod_count > 1) {
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "method has more than one of public/protected/private";
-      return false;
-    }
-  }
+  constexpr uint32_t kAccPublicProtectedPrivate = kAccPublic | kAccProtected | kAccPrivate;
+  DCHECK_IMPLIES((method_access_flags_ & kAccPublicProtectedPrivate) != 0u,
+                 IsPowerOfTwo(method_access_flags_ & kAccPublicProtectedPrivate));
 
   // If there aren't any instructions, make sure that's expected, then exit successfully.
   if (!code_item_accessor_.HasCodeItem()) {
@@ -923,7 +1357,7 @@ bool MethodVerifier<kVerifierDebug>::Verify() {
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "critical native methods must be static";
           return false;
         }
-        const char* shorty = dex_file_->GetMethodShorty(method_id);
+        const char* shorty = dex_file_->GetMethodShorty(dex_method_idx_);
         for (size_t i = 0, len = strlen(shorty); i < len; ++i) {
           if (Primitive::GetType(shorty[i]) == Primitive::kPrimNot) {
             Fail(VERIFY_ERROR_BAD_CLASS_HARD) <<
@@ -1031,18 +1465,18 @@ bool MethodVerifier<kVerifierDebug>::Verify() {
   insn_flags_.reset(allocator_.AllocArray<InstructionFlags>(
       code_item_accessor_.InsnsSizeInCodeUnits()));
   DCHECK(insn_flags_ != nullptr);
-  std::uninitialized_fill_n(insn_flags_.get(),
-                            code_item_accessor_.InsnsSizeInCodeUnits(),
-                            InstructionFlags());
+  // `ArenaAllocator` guarantees zero-initialization.
+  static_assert(std::is_same_v<decltype(allocator_), ArenaAllocator>);
+  DCHECK(std::all_of(
+      insn_flags_.get(),
+      insn_flags_.get() + code_item_accessor_.InsnsSizeInCodeUnits(),
+      [](const InstructionFlags& flags) { return flags.Equals(InstructionFlags()); }));
   // Run through the instructions and see if the width checks out.
   bool result = ComputeWidthsAndCountOps();
-  bool allow_runtime_only_instructions = !IsAotMode() || verify_to_dump_;
   // Flag instructions guarded by a "try" block and check exception handlers.
   result = result && ScanTryCatchBlocks();
   // Perform static instruction verification.
-  result = result && (allow_runtime_only_instructions
-                          ? VerifyInstructions<true>()
-                          : VerifyInstructions<false>());
+  result = result && VerifyInstructions();
   // Perform code-flow analysis and return.
   result = result && VerifyCodeFlow();
 
@@ -1140,95 +1574,174 @@ bool MethodVerifier<kVerifierDebug>::ScanTryCatchBlocks() {
 }
 
 template <bool kVerifierDebug>
-template <bool kAllowRuntimeOnlyInstructions>
 bool MethodVerifier<kVerifierDebug>::VerifyInstructions() {
   // Flag the start of the method as a branch target.
   GetModifiableInstructionFlags(0).SetBranchTarget();
-  for (const DexInstructionPcPair& inst : code_item_accessor_) {
-    const uint32_t dex_pc = inst.DexPc();
-    if (!VerifyInstruction<kAllowRuntimeOnlyInstructions>(&inst.Inst(), dex_pc)) {
-      DCHECK_NE(failures_.size(), 0U);
-      return false;
+  const Instruction* inst = Instruction::At(code_item_accessor_.Insns());
+  uint32_t dex_pc = 0u;
+  const uint32_t end_dex_pc = code_item_accessor_.InsnsSizeInCodeUnits();
+  while (dex_pc != end_dex_pc) {
+    auto find_dispatch_opcode = [](Instruction::Code opcode) constexpr {
+      // NOP needs its own dipatch because it needs special code for instruction size.
+      if (opcode == Instruction::NOP) {
+        return opcode;
+      }
+      DCHECK_GT(Instruction::SizeInCodeUnits(Instruction::FormatOf(opcode)), 0u);
+      for (uint32_t raw_other = 0; raw_other != opcode; ++raw_other) {
+        Instruction::Code other = enum_cast<Instruction::Code>(raw_other);
+        if (other == Instruction::NOP) {
+          continue;
+        }
+        // We dispatch to `VerifyInstruction()` based on the format and verify flags but
+        // we also treat return instructions separately to update instruction flags.
+        if (Instruction::FormatOf(opcode) == Instruction::FormatOf(other) &&
+            Instruction::VerifyFlagsOf(opcode) == Instruction::VerifyFlagsOf(other) &&
+            Instruction::IsReturn(opcode) == Instruction::IsReturn(other)) {
+          return other;
+        }
+      }
+      return opcode;
+    };
+
+    uint16_t inst_data = inst->Fetch16(0);
+    Instruction::Code dispatch_opcode = Instruction::NOP;
+    switch (inst->Opcode(inst_data)) {
+#define DEFINE_CASE(opcode, c, p, format, index, flags, eflags, vflags) \
+      case opcode: {                                                    \
+        /* Enforce compile-time evaluation. */                          \
+        constexpr Instruction::Code kDispatchOpcode =                   \
+            find_dispatch_opcode(enum_cast<Instruction::Code>(opcode)); \
+        dispatch_opcode = kDispatchOpcode;                              \
+        break;                                                          \
+      }
+      DEX_INSTRUCTION_LIST(DEFINE_CASE)
+#undef DEFINE_CASE
+    }
+    bool is_return = false;
+    uint32_t instruction_size = 0u;
+    switch (dispatch_opcode) {
+#define DEFINE_CASE(opcode, c, p, format, index, flags, eflags, vflags)             \
+      case opcode: {                                                                \
+        constexpr Instruction::Code kOpcode = enum_cast<Instruction::Code>(opcode); \
+        if (!VerifyInstruction<kOpcode>(inst, dex_pc, inst_data)) {                 \
+          DCHECK_NE(failures_.size(), 0U);                                          \
+          return false;                                                             \
+        }                                                                           \
+        is_return = Instruction::IsReturn(kOpcode);                                 \
+        instruction_size = (opcode == Instruction::NOP)                             \
+            ? inst->SizeInCodeUnitsComplexOpcode()                                  \
+            : Instruction::SizeInCodeUnits(Instruction::FormatOf(kOpcode));         \
+        DCHECK_EQ(instruction_size, inst->SizeInCodeUnits());                       \
+        break;                                                                      \
+      }
+      DEX_INSTRUCTION_LIST(DEFINE_CASE)
+#undef DEFINE_CASE
     }
     // Flag some interesting instructions.
-    if (inst->IsReturn()) {
+    if (is_return) {
       GetModifiableInstructionFlags(dex_pc).SetReturn();
-    } else if (inst->Opcode() == Instruction::CHECK_CAST) {
-      // The dex-to-dex compiler wants type information to elide check-casts.
-      GetModifiableInstructionFlags(dex_pc).SetCompileTimeInfoPoint();
     }
+    DCHECK_NE(instruction_size, 0u);
+    DCHECK_LE(instruction_size, end_dex_pc - dex_pc);
+    dex_pc += instruction_size;
+    inst = inst->RelativeAt(instruction_size);
   }
   return true;
 }
 
 template <bool kVerifierDebug>
-template <bool kAllowRuntimeOnlyInstructions>
-bool MethodVerifier<kVerifierDebug>::VerifyInstruction(const Instruction* inst,
-                                                       uint32_t code_offset) {
+template <Instruction::Code kDispatchOpcode>
+inline bool MethodVerifier<kVerifierDebug>::VerifyInstruction(const Instruction* inst,
+                                                              uint32_t code_offset,
+                                                              uint16_t inst_data) {
+  // The `kDispatchOpcode` may differ from the actual opcode but it shall have the
+  // same verification flags and format. We explicitly `DCHECK` these below and
+  // the format is also `DCHECK`ed in VReg getters that take it as an argument.
+  constexpr Instruction::Format kFormat = Instruction::FormatOf(kDispatchOpcode);
+  DCHECK_EQ(kFormat, Instruction::FormatOf(inst->Opcode()));
+
   bool result = true;
-  switch (inst->GetVerifyTypeArgumentA()) {
+  constexpr uint32_t kVerifyA = Instruction::GetVerifyTypeArgumentAOf(kDispatchOpcode);
+  DCHECK_EQ(kVerifyA, inst->GetVerifyTypeArgumentA());
+  switch (kVerifyA) {
     case Instruction::kVerifyRegA:
-      result = result && CheckRegisterIndex(inst->VRegA());
+      result = result && CheckRegisterIndex(inst->VRegA(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegAWide:
-      result = result && CheckWideRegisterIndex(inst->VRegA());
+      result = result && CheckWideRegisterIndex(inst->VRegA(kFormat, inst_data));
+      break;
+    case Instruction::kVerifyNothing:
       break;
   }
-  switch (inst->GetVerifyTypeArgumentB()) {
+  constexpr uint32_t kVerifyB = Instruction::GetVerifyTypeArgumentBOf(kDispatchOpcode);
+  DCHECK_EQ(kVerifyB, inst->GetVerifyTypeArgumentB());
+  switch (kVerifyB) {
     case Instruction::kVerifyRegB:
-      result = result && CheckRegisterIndex(inst->VRegB());
+      result = result && CheckRegisterIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBField:
-      result = result && CheckFieldIndex(inst->VRegB());
+      result = result && CheckFieldIndex(inst, inst_data, inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBMethod:
-      result = result && CheckMethodIndex(inst->VRegB());
+      result = result && CheckMethodIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBNewInstance:
-      result = result && CheckNewInstance(dex::TypeIndex(inst->VRegB()));
+      result = result && CheckNewInstance(dex::TypeIndex(inst->VRegB(kFormat, inst_data)));
       break;
     case Instruction::kVerifyRegBString:
-      result = result && CheckStringIndex(inst->VRegB());
+      result = result && CheckStringIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBType:
-      result = result && CheckTypeIndex(dex::TypeIndex(inst->VRegB()));
+      result = result && CheckTypeIndex(dex::TypeIndex(inst->VRegB(kFormat, inst_data)));
       break;
     case Instruction::kVerifyRegBWide:
-      result = result && CheckWideRegisterIndex(inst->VRegB());
+      result = result && CheckWideRegisterIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBCallSite:
-      result = result && CheckCallSiteIndex(inst->VRegB());
+      result = result && CheckCallSiteIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBMethodHandle:
-      result = result && CheckMethodHandleIndex(inst->VRegB());
+      result = result && CheckMethodHandleIndex(inst->VRegB(kFormat, inst_data));
       break;
     case Instruction::kVerifyRegBPrototype:
-      result = result && CheckPrototypeIndex(inst->VRegB());
+      result = result && CheckPrototypeIndex(inst->VRegB(kFormat, inst_data));
+      break;
+    case Instruction::kVerifyNothing:
       break;
   }
-  switch (inst->GetVerifyTypeArgumentC()) {
+  constexpr uint32_t kVerifyC = Instruction::GetVerifyTypeArgumentCOf(kDispatchOpcode);
+  DCHECK_EQ(kVerifyC, inst->GetVerifyTypeArgumentC());
+  switch (kVerifyC) {
     case Instruction::kVerifyRegC:
-      result = result && CheckRegisterIndex(inst->VRegC());
+      result = result && CheckRegisterIndex(inst->VRegC(kFormat));
       break;
     case Instruction::kVerifyRegCField:
-      result = result && CheckFieldIndex(inst->VRegC());
+      result = result && CheckFieldIndex(inst, inst_data, inst->VRegC(kFormat));
       break;
     case Instruction::kVerifyRegCNewArray:
-      result = result && CheckNewArray(dex::TypeIndex(inst->VRegC()));
+      result = result && CheckNewArray(dex::TypeIndex(inst->VRegC(kFormat)));
       break;
     case Instruction::kVerifyRegCType:
-      result = result && CheckTypeIndex(dex::TypeIndex(inst->VRegC()));
+      result = result && CheckTypeIndex(dex::TypeIndex(inst->VRegC(kFormat)));
       break;
     case Instruction::kVerifyRegCWide:
-      result = result && CheckWideRegisterIndex(inst->VRegC());
+      result = result && CheckWideRegisterIndex(inst->VRegC(kFormat));
+      break;
+    case Instruction::kVerifyNothing:
       break;
   }
-  switch (inst->GetVerifyTypeArgumentH()) {
+  constexpr uint32_t kVerifyH = Instruction::GetVerifyTypeArgumentHOf(kDispatchOpcode);
+  DCHECK_EQ(kVerifyH, inst->GetVerifyTypeArgumentH());
+  switch (kVerifyH) {
     case Instruction::kVerifyRegHPrototype:
-      result = result && CheckPrototypeIndex(inst->VRegH());
+      result = result && CheckPrototypeIndex(inst->VRegH(kFormat));
+      break;
+    case Instruction::kVerifyNothing:
       break;
   }
-  switch (inst->GetVerifyExtraFlags()) {
+  constexpr uint32_t kVerifyExtra = Instruction::GetVerifyExtraFlagsOf(kDispatchOpcode);
+  DCHECK_EQ(kVerifyExtra, inst->GetVerifyExtraFlags());
+  switch (kVerifyExtra) {
     case Instruction::kVerifyArrayData:
       result = result && CheckArrayData(code_offset);
       break;
@@ -1242,38 +1755,33 @@ bool MethodVerifier<kVerifierDebug>::VerifyInstruction(const Instruction* inst,
       // Fall-through.
     case Instruction::kVerifyVarArg: {
       // Instructions that can actually return a negative value shouldn't have this flag.
-      uint32_t v_a = dchecked_integral_cast<uint32_t>(inst->VRegA());
-      if ((inst->GetVerifyExtraFlags() == Instruction::kVerifyVarArgNonZero && v_a == 0) ||
+      uint32_t v_a = dchecked_integral_cast<uint32_t>(inst->VRegA(kFormat, inst_data));
+      if ((kVerifyExtra == Instruction::kVerifyVarArgNonZero && v_a == 0) ||
           v_a > Instruction::kMaxVarArgRegs) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invalid arg count (" << v_a << ") in "
-                                             "non-range invoke";
+        FailInvalidArgCount(inst, v_a);
         return false;
       }
 
-      uint32_t args[Instruction::kMaxVarArgRegs];
-      inst->GetVarArgs(args);
-      result = result && CheckVarArgRegs(v_a, args);
+      result = result && CheckVarArgRegs(inst, v_a);
       break;
     }
     case Instruction::kVerifyVarArgRangeNonZero:
       // Fall-through.
-    case Instruction::kVerifyVarArgRange:
-      if (inst->GetVerifyExtraFlags() == Instruction::kVerifyVarArgRangeNonZero &&
-          inst->VRegA() <= 0) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invalid arg count (" << inst->VRegA() << ") in "
-                                             "range invoke";
+    case Instruction::kVerifyVarArgRange: {
+      uint32_t v_a = inst->VRegA(kFormat, inst_data);
+      if (inst->GetVerifyExtraFlags() == Instruction::kVerifyVarArgRangeNonZero && v_a == 0) {
+        FailInvalidArgCount(inst, v_a);
         return false;
       }
-      result = result && CheckVarArgRangeRegs(inst->VRegA(), inst->VRegC());
+      result = result && CheckVarArgRangeRegs(v_a, inst->VRegC(kFormat));
       break;
+    }
     case Instruction::kVerifyError:
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "unexpected opcode " << inst->Name();
+      FailUnexpectedOpcode(inst);
       result = false;
       break;
-  }
-  if (!kAllowRuntimeOnlyInstructions && inst->GetVerifyIsRuntimeOnly()) {
-    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "opcode only expected at runtime " << inst->Name();
-    result = false;
+    case Instruction::kVerifyNothing:
+      break;
   }
   return result;
 }
@@ -1625,22 +2133,6 @@ void MethodVerifier<kVerifierDebug>::Dump(VariableIndentationOutputStream* vios)
   }
 }
 
-static bool IsPrimitiveDescriptor(char descriptor) {
-  switch (descriptor) {
-    case 'I':
-    case 'C':
-    case 'S':
-    case 'B':
-    case 'Z':
-    case 'F':
-    case 'D':
-    case 'J':
-      return true;
-    default:
-      return false;
-  }
-}
-
 template <bool kVerifierDebug>
 bool MethodVerifier<kVerifierDebug>::SetTypesFromSignature() {
   RegisterLine* reg_line = reg_table_.GetLine(0);
@@ -1713,22 +2205,22 @@ bool MethodVerifier<kVerifierDebug>::SetTypesFromSignature() {
         }
         break;
       case 'Z':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Boolean());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kBoolean);
         break;
       case 'C':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Char());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kChar);
         break;
       case 'B':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Byte());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kByte);
         break;
       case 'I':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Integer());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kInteger);
         break;
       case 'S':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Short());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kShort);
         break;
       case 'F':
-        reg_line->SetRegisterType<LockOp::kClear>(arg_start + cur_arg, reg_types_.Float());
+        reg_line->SetRegisterType(arg_start + cur_arg, RegType::Kind::kFloat);
         break;
       case 'J':
       case 'D': {
@@ -1763,40 +2255,9 @@ bool MethodVerifier<kVerifierDebug>::SetTypesFromSignature() {
                                       << " arguments, found " << cur_arg;
     return false;
   }
-  const char* descriptor = dex_file_->GetReturnTypeDescriptor(proto_id);
-  // Validate return type. We don't do the type lookup; just want to make sure that it has the right
-  // format. Only major difference from the method argument format is that 'V' is supported.
-  bool result;
-  if (IsPrimitiveDescriptor(descriptor[0]) || descriptor[0] == 'V') {
-    result = descriptor[1] == '\0';
-  } else if (descriptor[0] == '[') {  // single/multi-dimensional array of object/primitive
-    size_t i = 0;
-    do {
-      i++;
-    } while (descriptor[i] == '[');  // process leading [
-    if (descriptor[i] == 'L') {  // object array
-      do {
-        i++;  // find closing ;
-      } while (descriptor[i] != ';' && descriptor[i] != '\0');
-      result = descriptor[i] == ';';
-    } else {  // primitive array
-      result = IsPrimitiveDescriptor(descriptor[i]) && descriptor[i + 1] == '\0';
-    }
-  } else if (descriptor[0] == 'L') {
-    // could be more thorough here, but shouldn't be required
-    size_t i = 0;
-    do {
-      i++;
-    } while (descriptor[i] != ';' && descriptor[i] != '\0');
-    result = descriptor[i] == ';';
-  } else {
-    result = false;
-  }
-  if (!result) {
-    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "unexpected char in return type descriptor '"
-                                      << descriptor << "'";
-  }
-  return result;
+  // Dex file verifier ensures that all valid type indexes reference valid descriptors.
+  DCHECK(IsValidDescriptor(dex_file_->GetReturnTypeDescriptor(proto_id)));
+  return true;
 }
 
 COLD_ATTR
@@ -1870,7 +2331,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyMethod() {
       if (register_line != nullptr) {
         if (work_line_->CompareLine(register_line) != 0) {
           Dump(LOG_STREAM(FATAL_WITHOUT_ABORT));
-          LOG(FATAL_WITHOUT_ABORT) << info_messages_.str();
+          LOG(FATAL_WITHOUT_ABORT) << InfoMessages().str();
           LOG(FATAL) << "work_line diverged in " << dex_file_->PrettyMethod(dex_method_idx_)
                      << "@" << reinterpret_cast<void*>(work_insn_idx_) << "\n"
                      << " work_line=" << work_line_->Dump(this) << "\n"
@@ -1943,7 +2404,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyMethod() {
     // To dump the state of the verify after a method, do something like:
     // if (dex_file_->PrettyMethod(dex_method_idx_) ==
     //     "boolean java.lang.String.equals(java.lang.Object)") {
-    //   LOG(INFO) << info_messages_.str();
+    //   LOG(INFO) << InfoMessages().str();
     // }
   }
   return true;
@@ -2036,6 +2497,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
   RegisterLineArenaUniquePtr branch_line;
   RegisterLineArenaUniquePtr fallthrough_line;
 
+  using enum RegType::Kind;
   switch (inst->Opcode()) {
     case Instruction::NOP:
       /*
@@ -2127,8 +2589,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
                            return_type.IsShort() || return_type.IsChar()) &&
                            src_type.IsInteger()));
           /* check the register contents */
-          bool success =
-              work_line_->VerifyRegisterType(this, vregA, use_src ? src_type : return_type);
+          bool success = VerifyRegisterType(vregA, use_src ? src_type : return_type);
           if (!success) {
             AppendToLastFailMessage(StringPrintf(" return-1nr on invalid register v%d", vregA));
           }
@@ -2144,7 +2605,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
         } else {
           /* check the register contents */
           const uint32_t vregA = inst->VRegA_11x();
-          bool success = work_line_->VerifyRegisterType(this, vregA, return_type);
+          bool success = VerifyRegisterTypeWide(vregA, return_type.GetKind());
           if (!success) {
             AppendToLastFailMessage(StringPrintf(" return-wide on invalid register v%d", vregA));
           }
@@ -2175,7 +2636,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
             // We really do expect a reference here.
             Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "return-object returns a non-reference type "
                                               << reg_type;
-          } else if (!return_type.IsAssignableFrom(reg_type, this)) {
+          } else if (!IsAssignableFrom(return_type, reg_type)) {
             if (reg_type.IsUnresolvedTypes() || return_type.IsUnresolvedTypes()) {
               Fail(VERIFY_ERROR_UNRESOLVED_TYPE_CHECK)
                   << " can't resolve returned type '" << return_type << "' or '" << reg_type << "'";
@@ -2191,50 +2652,50 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       /* could be boolean, int, float, or a null reference */
     case Instruction::CONST_4: {
       int32_t val = static_cast<int32_t>(inst->VRegB_11n() << 28) >> 28;
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_11n(), DetermineCat1Constant(val));
+      work_line_->SetRegisterType(inst->VRegA_11n(), DetermineCat1Constant(val));
       break;
     }
     case Instruction::CONST_16: {
       int16_t val = static_cast<int16_t>(inst->VRegB_21s());
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_21s(), DetermineCat1Constant(val));
+      work_line_->SetRegisterType(inst->VRegA_21s(), DetermineCat1Constant(val));
       break;
     }
     case Instruction::CONST: {
       int32_t val = inst->VRegB_31i();
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_31i(), DetermineCat1Constant(val));
+      work_line_->SetRegisterType(inst->VRegA_31i(), DetermineCat1Constant(val));
       break;
     }
     case Instruction::CONST_HIGH16: {
       int32_t val = static_cast<int32_t>(inst->VRegB_21h() << 16);
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_21h(), DetermineCat1Constant(val));
+      work_line_->SetRegisterType(inst->VRegA_21h(), DetermineCat1Constant(val));
       break;
     }
       /* could be long or double; resolved upon use */
     case Instruction::CONST_WIDE_16: {
       int64_t val = static_cast<int16_t>(inst->VRegB_21s());
-      const RegType& lo = reg_types_.FromCat2ConstLo(static_cast<int32_t>(val), true);
-      const RegType& hi = reg_types_.FromCat2ConstHi(static_cast<int32_t>(val >> 32), true);
+      const RegType& lo = reg_types_.ConstantLo();
+      const RegType& hi = reg_types_.ConstantHi();
       work_line_->SetRegisterTypeWide(inst->VRegA_21s(), lo, hi);
       break;
     }
     case Instruction::CONST_WIDE_32: {
       int64_t val = static_cast<int32_t>(inst->VRegB_31i());
-      const RegType& lo = reg_types_.FromCat2ConstLo(static_cast<int32_t>(val), true);
-      const RegType& hi = reg_types_.FromCat2ConstHi(static_cast<int32_t>(val >> 32), true);
+      const RegType& lo = reg_types_.ConstantLo();
+      const RegType& hi = reg_types_.ConstantHi();
       work_line_->SetRegisterTypeWide(inst->VRegA_31i(), lo, hi);
       break;
     }
     case Instruction::CONST_WIDE: {
       int64_t val = inst->VRegB_51l();
-      const RegType& lo = reg_types_.FromCat2ConstLo(static_cast<int32_t>(val), true);
-      const RegType& hi = reg_types_.FromCat2ConstHi(static_cast<int32_t>(val >> 32), true);
+      const RegType& lo = reg_types_.ConstantLo();
+      const RegType& hi = reg_types_.ConstantHi();
       work_line_->SetRegisterTypeWide(inst->VRegA_51l(), lo, hi);
       break;
     }
     case Instruction::CONST_WIDE_HIGH16: {
       int64_t val = static_cast<uint64_t>(inst->VRegB_21h()) << 48;
-      const RegType& lo = reg_types_.FromCat2ConstLo(static_cast<int32_t>(val), true);
-      const RegType& hi = reg_types_.FromCat2ConstHi(static_cast<int32_t>(val >> 32), true);
+      const RegType& lo = reg_types_.ConstantLo();
+      const RegType& hi = reg_types_.ConstantHi();
       work_line_->SetRegisterTypeWide(inst->VRegA_21h(), lo, hi);
       break;
     }
@@ -2379,7 +2840,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
 
         DCHECK_NE(failures_.size(), 0U);
         if (!is_checkcast) {
-          work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_22c(), reg_types_.Boolean());
+          work_line_->SetRegisterType(inst->VRegA_22c(), kBoolean);
         }
         break;  // bad class
       }
@@ -2410,7 +2871,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
         if (is_checkcast) {
           work_line_->SetRegisterType<LockOp::kKeep>(inst->VRegA_21c(), res_type);
         } else {
-          work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_22c(), reg_types_.Boolean());
+          work_line_->SetRegisterType(inst->VRegA_22c(), kBoolean);
         }
       }
       break;
@@ -2422,7 +2883,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
           // ie not an array or null
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "array-length on non-array " << res_type;
         } else {
-          work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_12x(), reg_types_.Integer());
+          work_line_->SetRegisterType(inst->VRegA_12x(), kInteger);
         }
       } else {
         Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "array-length on non-array " << res_type;
@@ -2431,10 +2892,12 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     }
     case Instruction::NEW_INSTANCE: {
       const RegType& res_type = ResolveClass<CheckAccess::kYes>(dex::TypeIndex(inst->VRegB_21c()));
-      if (res_type.IsConflict()) {
-        DCHECK_NE(failures_.size(), 0U);
-        break;  // bad class
-      }
+      // Dex file verifier ensures that all valid type indexes reference valid descriptors and the
+      // `CheckNewInstance()` ensures that the descriptor starts with an `L` before we get to the
+      // code flow verification. So, we should not see a conflict (void) or a primitive type here.
+      DCHECK(res_type.IsJavaLangObject() ||
+             res_type.IsReference() ||
+             res_type.IsUnresolvedReference()) << res_type;
       // TODO: check Compiler::CanAccessTypeWithoutChecks returns false when res_type is unresolved
       // can't create an instance of an interface or abstract class */
       if (!res_type.IsInstantiableTypes()) {
@@ -2442,12 +2905,11 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
             << "new-instance on primitive, interface or abstract class" << res_type;
         // Soft failure so carry on to set register type.
       }
-      const RegType& uninit_type = reg_types_.Uninitialized(res_type, work_insn_idx_);
-      // Any registers holding previous allocations from this address that have not yet been
-      // initialized must be marked invalid.
-      work_line_->MarkUninitRefsAsInvalid(this, uninit_type);
-      // add the new uninitialized reference to the register state
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_21c(), uninit_type);
+      const RegType& uninit_type = reg_types_.Uninitialized(res_type);
+      // Add the new uninitialized reference to the register state and record the allocation dex pc.
+      uint32_t vA = inst->VRegA_21c();
+      work_line_->DCheckUniqueNewInstanceDexPc(this, work_insn_idx_);
+      work_line_->SetRegisterTypeForNewInstance(vA, uninit_type, work_insn_idx_);
       break;
     }
     case Instruction::NEW_ARRAY:
@@ -2463,40 +2925,18 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       break;
     case Instruction::CMPL_FLOAT:
     case Instruction::CMPG_FLOAT:
-      if (!work_line_->VerifyRegisterType(this, inst->VRegB_23x(), reg_types_.Float())) {
-        break;
-      }
-      if (!work_line_->VerifyRegisterType(this, inst->VRegC_23x(), reg_types_.Float())) {
-        break;
-      }
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), reg_types_.Integer());
+      CheckBinaryOp(inst, kInteger, kFloat, kFloat, /*check_boolean_op=*/ false);
       break;
     case Instruction::CMPL_DOUBLE:
     case Instruction::CMPG_DOUBLE:
-      if (!work_line_->VerifyRegisterTypeWide(this, inst->VRegB_23x(), reg_types_.DoubleLo(),
-                                              reg_types_.DoubleHi())) {
-        break;
-      }
-      if (!work_line_->VerifyRegisterTypeWide(this, inst->VRegC_23x(), reg_types_.DoubleLo(),
-                                              reg_types_.DoubleHi())) {
-        break;
-      }
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), reg_types_.Integer());
+      CheckBinaryOpWideCmp(inst, kInteger, kDoubleLo, kDoubleLo);
       break;
     case Instruction::CMP_LONG:
-      if (!work_line_->VerifyRegisterTypeWide(this, inst->VRegB_23x(), reg_types_.LongLo(),
-                                              reg_types_.LongHi())) {
-        break;
-      }
-      if (!work_line_->VerifyRegisterTypeWide(this, inst->VRegC_23x(), reg_types_.LongLo(),
-                                              reg_types_.LongHi())) {
-        break;
-      }
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), reg_types_.Integer());
+      CheckBinaryOpWideCmp(inst, kInteger, kLongLo, kLongLo);
       break;
     case Instruction::THROW: {
       const RegType& res_type = work_line_->GetRegisterType(this, inst->VRegA_11x());
-      if (!reg_types_.JavaLangThrowable().IsAssignableFrom(res_type, this)) {
+      if (!IsAssignableFrom(reg_types_.JavaLangThrowable(), res_type)) {
         if (res_type.IsUninitializedTypes()) {
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "thrown exception not initialized";
         } else if (!res_type.IsReferenceTypes()) {
@@ -2518,7 +2958,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::PACKED_SWITCH:
     case Instruction::SPARSE_SWITCH:
       /* verify that vAA is an integer, or can be converted to one */
-      work_line_->VerifyRegisterType(this, inst->VRegA_31t(), reg_types_.Integer());
+      VerifyRegisterType(inst->VRegA_31t(), kInteger);
       break;
 
     case Instruction::FILL_ARRAY_DATA: {
@@ -2534,7 +2974,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invalid fill-array-data for array of type "
                                             << array_type;
         } else {
-          const RegType& component_type = reg_types_.GetComponentType(array_type, class_loader_);
+          const RegType& component_type = reg_types_.GetComponentType(array_type);
           DCHECK(!component_type.IsConflict());
           if (component_type.IsNonZeroReferenceTypes()) {
             Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invalid fill-array-data with component type "
@@ -2649,8 +3089,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
             cast_type.HasClass() &&             // Could be conflict type, make sure it has a class.
             !cast_type.GetClass()->IsInterface() &&
             !orig_type.IsZeroOrNull() &&
-            orig_type.IsStrictlyAssignableFrom(
-                cast_type.Merge(orig_type, &reg_types_, this), this)) {
+            IsStrictlyAssignableFrom(orig_type, cast_type.Merge(orig_type, &reg_types_, this))) {
           RegisterLine* update_line = RegisterLine::Create(code_item_accessor_.RegistersSize(),
                                                            allocator_,
                                                            GetRegTypeCache());
@@ -2730,7 +3169,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       VerifyAGet(inst, reg_types_.LongLo(), true);
       break;
     case Instruction::AGET_OBJECT:
-      VerifyAGet(inst, reg_types_.JavaLangObject(false), false);
+      VerifyAGet(inst, reg_types_.JavaLangObject(), false);
       break;
 
     case Instruction::APUT_BOOLEAN:
@@ -2752,99 +3191,95 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       VerifyAPut(inst, reg_types_.LongLo(), true);
       break;
     case Instruction::APUT_OBJECT:
-      VerifyAPut(inst, reg_types_.JavaLangObject(false), false);
+      VerifyAPut(inst, reg_types_.JavaLangObject(), false);
       break;
 
     case Instruction::IGET_BOOLEAN:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Boolean(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET_BYTE:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Byte(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET_CHAR:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Char(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET_SHORT:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Short(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Integer(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET_WIDE:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.LongLo(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, false);
       break;
     case Instruction::IGET_OBJECT:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.JavaLangObject(false), false,
-                                                    false);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, false, false);
       break;
 
     case Instruction::IPUT_BOOLEAN:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Boolean(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT_BYTE:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Byte(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT_CHAR:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Char(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT_SHORT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Short(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Integer(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT_WIDE:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.LongLo(), true, false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, false);
       break;
     case Instruction::IPUT_OBJECT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.JavaLangObject(false), false,
-                                                    false);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, false, false);
       break;
 
     case Instruction::SGET_BOOLEAN:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Boolean(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET_BYTE:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Byte(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET_CHAR:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Char(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET_SHORT:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Short(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.Integer(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET_WIDE:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.LongLo(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, true, true);
       break;
     case Instruction::SGET_OBJECT:
-      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, reg_types_.JavaLangObject(false), false,
-                                                    true);
+      VerifyISFieldAccess<FieldAccessType::kAccGet>(inst, false, true);
       break;
 
     case Instruction::SPUT_BOOLEAN:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Boolean(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT_BYTE:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Byte(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT_CHAR:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Char(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT_SHORT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Short(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.Integer(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT_WIDE:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.LongLo(), true, true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, true, true);
       break;
     case Instruction::SPUT_OBJECT:
-      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, reg_types_.JavaLangObject(false), false,
-                                                    true);
+      VerifyISFieldAccess<FieldAccessType::kAccPut>(inst, false, true);
       break;
 
     case Instruction::INVOKE_VIRTUAL:
@@ -2857,32 +3292,17 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
                        inst->Opcode() == Instruction::INVOKE_SUPER_RANGE);
       MethodType type = is_super ? METHOD_SUPER : METHOD_VIRTUAL;
       ArtMethod* called_method = VerifyInvocationArgs(inst, type, is_range);
-      const RegType* return_type = nullptr;
-      if (called_method != nullptr) {
-        ObjPtr<mirror::Class> return_type_class = CanLoadClasses()
-            ? called_method->ResolveReturnType()
-            : called_method->LookupResolvedReturnType();
-        if (return_type_class != nullptr) {
-          return_type = &FromClass(called_method->GetReturnTypeDescriptor(),
-                                   return_type_class,
-                                   return_type_class->CannotBeAssignedFromOtherTypes());
-        } else {
-          DCHECK_IMPLIES(CanLoadClasses(), self_->IsExceptionPending());
-          self_->ClearException();
-        }
-      }
-      if (return_type == nullptr) {
-        uint32_t method_idx = GetMethodIdxOfInvoke(inst);
-        const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
-        dex::TypeIndex return_type_idx =
-            dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
-        const char* descriptor = dex_file_->GetTypeDescriptor(return_type_idx);
-        return_type = &reg_types_.FromDescriptor(class_loader_, descriptor);
-      }
-      if (!return_type->IsLowHalf()) {
-        work_line_->SetResultRegisterType(this, *return_type);
+      uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
+      const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
+      dex::TypeIndex return_type_idx = dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
+      DCHECK_IMPLIES(called_method != nullptr,
+                     called_method->GetReturnTypeDescriptorView() ==
+                         dex_file_->GetTypeDescriptorView(return_type_idx));
+      const RegType& return_type = reg_types_.FromTypeIndex(return_type_idx);
+      if (!return_type.IsLowHalf()) {
+        work_line_->SetResultRegisterType(this, return_type);
       } else {
-        work_line_->SetResultRegisterTypeWide(*return_type, return_type->HighHalf(&reg_types_));
+        work_line_->SetResultRegisterTypeWide(return_type, return_type.HighHalf(&reg_types_));
       }
       just_set_result = true;
       break;
@@ -2891,31 +3311,15 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::INVOKE_DIRECT_RANGE: {
       bool is_range = (inst->Opcode() == Instruction::INVOKE_DIRECT_RANGE);
       ArtMethod* called_method = VerifyInvocationArgs(inst, METHOD_DIRECT, is_range);
-      const char* return_type_descriptor;
-      bool is_constructor;
-      const RegType* return_type = nullptr;
-      if (called_method == nullptr) {
-        uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
-        const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
-        is_constructor = dex_file_->GetStringView(method_id.name_idx_) == "<init>";
-        dex::TypeIndex return_type_idx =
-            dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
-        return_type_descriptor =  dex_file_->GetTypeDescriptor(return_type_idx);
-      } else {
-        is_constructor = called_method->IsConstructor();
-        return_type_descriptor = called_method->GetReturnTypeDescriptor();
-        ObjPtr<mirror::Class> return_type_class = CanLoadClasses()
-            ? called_method->ResolveReturnType()
-            : called_method->LookupResolvedReturnType();
-        if (return_type_class != nullptr) {
-          return_type = &FromClass(return_type_descriptor,
-                                   return_type_class,
-                                   return_type_class->CannotBeAssignedFromOtherTypes());
-        } else {
-          DCHECK_IMPLIES(CanLoadClasses(), self_->IsExceptionPending());
-          self_->ClearException();
-        }
-      }
+      uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
+      const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
+      dex::TypeIndex return_type_idx = dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
+      DCHECK_IMPLIES(called_method != nullptr,
+                     called_method->GetReturnTypeDescriptorView() ==
+                         dex_file_->GetTypeDescriptorView(return_type_idx));
+      bool is_constructor = (called_method != nullptr)
+          ? called_method->IsConstructor()
+          : dex_file_->GetStringView(method_id.name_idx_) == "<init>";
       if (is_constructor) {
         /*
          * Some additional checks when calling a constructor. We know from the invocation arg check
@@ -2924,7 +3328,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
          * allowing the latter only if the "this" argument is the same as the "this" argument to
          * this method (which implies that we're in a constructor ourselves).
          */
-        const RegType& this_type = work_line_->GetInvocationThis(this, inst);
+        const RegType& this_type = GetInvocationThis(inst);
         if (this_type.IsConflict())  // failure.
           break;
 
@@ -2934,15 +3338,6 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
           break;
         }
 
-        /* must be in same class or in superclass */
-        // const RegType& this_super_klass = this_type.GetSuperClass(&reg_types_);
-        // TODO: re-enable constructor type verification
-        // if (this_super_klass.IsConflict()) {
-          // Unknown super class, fail so we re-check at runtime.
-          // Fail(VERIFY_ERROR_BAD_CLASS_SOFT) << "super class unknown for '" << this_type << "'";
-          // break;
-        // }
-
         /* arg must be an uninitialized reference */
         if (!this_type.IsUninitializedTypes()) {
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "Expected initialization on uninitialized reference "
@@ -2950,46 +3345,50 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
           break;
         }
 
+        // Note: According to JLS, constructors are never inherited. Therefore the target
+        // constructor should be defined exactly by the `this_type`, or by the direct
+        // superclass in the case of a constructor calling the superclass constructor.
+        // However, ART had this check commented out for a very long time and this has
+        // allowed bytecode optimizers such as R8 to inline constructors, often calling
+        // `j.l.Object.<init>` directly without any intermediate constructor. Since this
+        // optimization allows eliminating constructor methods, this often results in a
+        // significant dex size reduction. Therefore it is undesirable to reinstate this
+        // check and ART deliberately remains permissive here and diverges from the RI.
+
         /*
          * Replace the uninitialized reference with an initialized one. We need to do this for all
          * registers that have the same object instance in them, not just the "this" register.
          */
-        work_line_->MarkRefsAsInitialized(this, this_type);
-      }
-      if (return_type == nullptr) {
-        return_type = &reg_types_.FromDescriptor(class_loader_, return_type_descriptor);
+        work_line_->MarkRefsAsInitialized(this, inst->VRegC());
       }
-      if (!return_type->IsLowHalf()) {
-        work_line_->SetResultRegisterType(this, *return_type);
+      const RegType& return_type = reg_types_.FromTypeIndex(return_type_idx);
+      if (!return_type.IsLowHalf()) {
+        work_line_->SetResultRegisterType(this, return_type);
       } else {
-        work_line_->SetResultRegisterTypeWide(*return_type, return_type->HighHalf(&reg_types_));
+        work_line_->SetResultRegisterTypeWide(return_type, return_type.HighHalf(&reg_types_));
       }
       just_set_result = true;
       break;
     }
     case Instruction::INVOKE_STATIC:
     case Instruction::INVOKE_STATIC_RANGE: {
-        bool is_range = (inst->Opcode() == Instruction::INVOKE_STATIC_RANGE);
-        ArtMethod* called_method = VerifyInvocationArgs(inst, METHOD_STATIC, is_range);
-        const char* descriptor;
-        if (called_method == nullptr) {
-          uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
-          const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
-          dex::TypeIndex return_type_idx =
-              dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
-          descriptor = dex_file_->GetTypeDescriptor(return_type_idx);
-        } else {
-          descriptor = called_method->GetReturnTypeDescriptor();
-        }
-        const RegType& return_type = reg_types_.FromDescriptor(class_loader_, descriptor);
-        if (!return_type.IsLowHalf()) {
-          work_line_->SetResultRegisterType(this, return_type);
-        } else {
-          work_line_->SetResultRegisterTypeWide(return_type, return_type.HighHalf(&reg_types_));
-        }
-        just_set_result = true;
+      bool is_range = (inst->Opcode() == Instruction::INVOKE_STATIC_RANGE);
+      ArtMethod* called_method = VerifyInvocationArgs(inst, METHOD_STATIC, is_range);
+      uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
+      const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
+      dex::TypeIndex return_type_idx = dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
+      DCHECK_IMPLIES(called_method != nullptr,
+                     called_method->GetReturnTypeDescriptorView() ==
+                         dex_file_->GetTypeDescriptorView(return_type_idx));
+      const RegType& return_type = reg_types_.FromTypeIndex(return_type_idx);
+      if (!return_type.IsLowHalf()) {
+        work_line_->SetResultRegisterType(this, return_type);
+      } else {
+        work_line_->SetResultRegisterTypeWide(return_type, return_type.HighHalf(&reg_types_));
       }
+      just_set_result = true;
       break;
+    }
     case Instruction::INVOKE_INTERFACE:
     case Instruction::INVOKE_INTERFACE_RANGE: {
       bool is_range =  (inst->Opcode() == Instruction::INVOKE_INTERFACE_RANGE);
@@ -3005,7 +3404,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       /* Get the type of the "this" arg, which should either be a sub-interface of called
        * interface or Object (see comments in RegType::JoinClass).
        */
-      const RegType& this_type = work_line_->GetInvocationThis(this, inst);
+      const RegType& this_type = GetInvocationThis(inst);
       if (this_type.IsZeroOrNull()) {
         /* null pointer always passes (and always fails at runtime) */
       } else {
@@ -3026,17 +3425,13 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
        * We don't have an object instance, so we can't find the concrete method. However, all of
        * the type information is in the abstract method, so we're good.
        */
-      const char* descriptor;
-      if (abs_method == nullptr) {
-        uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
-        const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
-        dex::TypeIndex return_type_idx =
-            dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
-        descriptor = dex_file_->GetTypeDescriptor(return_type_idx);
-      } else {
-        descriptor = abs_method->GetReturnTypeDescriptor();
-      }
-      const RegType& return_type = reg_types_.FromDescriptor(class_loader_, descriptor);
+      uint32_t method_idx = (is_range) ? inst->VRegB_3rc() : inst->VRegB_35c();
+      const dex::MethodId& method_id = dex_file_->GetMethodId(method_idx);
+      dex::TypeIndex return_type_idx = dex_file_->GetProtoId(method_id.proto_idx_).return_type_idx_;
+      DCHECK_IMPLIES(abs_method != nullptr,
+                     abs_method->GetReturnTypeDescriptorView() ==
+                         dex_file_->GetTypeDescriptorView(return_type_idx));
+      const RegType& return_type = reg_types_.FromTypeIndex(return_type_idx);
       if (!return_type.IsLowHalf()) {
         work_line_->SetResultRegisterType(this, return_type);
       } else {
@@ -3064,12 +3459,9 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
         DCHECK(HasFailures());
         break;
       }
-      const uint16_t vRegH = (is_range) ? inst->VRegH_4rcc() : inst->VRegH_45cc();
-      const dex::ProtoIndex proto_idx(vRegH);
-      const char* return_descriptor =
-          dex_file_->GetReturnTypeDescriptor(dex_file_->GetProtoId(proto_idx));
+      const dex::ProtoIndex proto_idx((is_range) ? inst->VRegH_4rcc() : inst->VRegH_45cc());
       const RegType& return_type =
-          reg_types_.FromDescriptor(class_loader_, return_descriptor);
+          reg_types_.FromTypeIndex(dex_file_->GetProtoId(proto_idx).return_type_idx_);
       if (!return_type.IsLowHalf()) {
         work_line_->SetResultRegisterType(this, return_type);
       } else {
@@ -3098,11 +3490,9 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       DexFileParameterIterator param_it(*dex_file_, proto_id);
       // Treat method as static as it has yet to be determined.
       VerifyInvocationArgsFromIterator(&param_it, inst, METHOD_STATIC, is_range, nullptr);
-      const char* return_descriptor = dex_file_->GetReturnTypeDescriptor(proto_id);
 
       // Step 3. Propagate return type information
-      const RegType& return_type =
-          reg_types_.FromDescriptor(class_loader_, return_descriptor);
+      const RegType& return_type = reg_types_.FromTypeIndex(proto_id.return_type_idx_);
       if (!return_type.IsLowHalf()) {
         work_line_->SetResultRegisterType(this, return_type);
       } else {
@@ -3113,74 +3503,62 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     }
     case Instruction::NEG_INT:
     case Instruction::NOT_INT:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Integer(), reg_types_.Integer());
+      CheckUnaryOp(inst, kInteger, kInteger);
       break;
     case Instruction::NEG_LONG:
     case Instruction::NOT_LONG:
-      work_line_->CheckUnaryOpWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                   reg_types_.LongLo(), reg_types_.LongHi());
+      CheckUnaryOpWide(inst, kLongLo, kLongLo);
       break;
     case Instruction::NEG_FLOAT:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Float(), reg_types_.Float());
+      CheckUnaryOp(inst, kFloat, kFloat);
       break;
     case Instruction::NEG_DOUBLE:
-      work_line_->CheckUnaryOpWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                   reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckUnaryOpWide(inst, kDoubleLo, kDoubleLo);
       break;
     case Instruction::INT_TO_LONG:
-      work_line_->CheckUnaryOpToWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                     reg_types_.Integer());
+      CheckUnaryOpToWide(inst, kLongLo, kInteger);
       break;
     case Instruction::INT_TO_FLOAT:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Float(), reg_types_.Integer());
+      CheckUnaryOp(inst, kFloat, kInteger);
       break;
     case Instruction::INT_TO_DOUBLE:
-      work_line_->CheckUnaryOpToWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                     reg_types_.Integer());
+      CheckUnaryOpToWide(inst, kDoubleLo, kInteger);
       break;
     case Instruction::LONG_TO_INT:
-      work_line_->CheckUnaryOpFromWide(this, inst, reg_types_.Integer(),
-                                       reg_types_.LongLo(), reg_types_.LongHi());
+      CheckUnaryOpFromWide(inst, kInteger, kLongLo);
       break;
     case Instruction::LONG_TO_FLOAT:
-      work_line_->CheckUnaryOpFromWide(this, inst, reg_types_.Float(),
-                                       reg_types_.LongLo(), reg_types_.LongHi());
+      CheckUnaryOpFromWide(inst, kFloat, kLongLo);
       break;
     case Instruction::LONG_TO_DOUBLE:
-      work_line_->CheckUnaryOpWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                   reg_types_.LongLo(), reg_types_.LongHi());
+      CheckUnaryOpWide(inst, kDoubleLo, kLongLo);
       break;
     case Instruction::FLOAT_TO_INT:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Integer(), reg_types_.Float());
+      CheckUnaryOp(inst, kInteger, kFloat);
       break;
     case Instruction::FLOAT_TO_LONG:
-      work_line_->CheckUnaryOpToWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                     reg_types_.Float());
+      CheckUnaryOpToWide(inst, kLongLo, kFloat);
       break;
     case Instruction::FLOAT_TO_DOUBLE:
-      work_line_->CheckUnaryOpToWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                     reg_types_.Float());
+      CheckUnaryOpToWide(inst, kDoubleLo, kFloat);
       break;
     case Instruction::DOUBLE_TO_INT:
-      work_line_->CheckUnaryOpFromWide(this, inst, reg_types_.Integer(),
-                                       reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckUnaryOpFromWide(inst, kInteger, kDoubleLo);
       break;
     case Instruction::DOUBLE_TO_LONG:
-      work_line_->CheckUnaryOpWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                   reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckUnaryOpWide(inst, kLongLo, kDoubleLo);
       break;
     case Instruction::DOUBLE_TO_FLOAT:
-      work_line_->CheckUnaryOpFromWide(this, inst, reg_types_.Float(),
-                                       reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckUnaryOpFromWide(inst, kFloat, kDoubleLo);
       break;
     case Instruction::INT_TO_BYTE:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Byte(), reg_types_.Integer());
+      CheckUnaryOp(inst, kByte, kInteger);
       break;
     case Instruction::INT_TO_CHAR:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Char(), reg_types_.Integer());
+      CheckUnaryOp(inst, kChar, kInteger);
       break;
     case Instruction::INT_TO_SHORT:
-      work_line_->CheckUnaryOp(this, inst, reg_types_.Short(), reg_types_.Integer());
+      CheckUnaryOp(inst, kShort, kInteger);
       break;
 
     case Instruction::ADD_INT:
@@ -3191,14 +3569,12 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::SHL_INT:
     case Instruction::SHR_INT:
     case Instruction::USHR_INT:
-      work_line_->CheckBinaryOp(this, inst, reg_types_.Integer(), reg_types_.Integer(),
-                                reg_types_.Integer(), false);
+      CheckBinaryOp(inst, kInteger, kInteger, kInteger, /*check_boolean_op=*/ false);
       break;
     case Instruction::AND_INT:
     case Instruction::OR_INT:
     case Instruction::XOR_INT:
-      work_line_->CheckBinaryOp(this, inst, reg_types_.Integer(), reg_types_.Integer(),
-                                reg_types_.Integer(), true);
+      CheckBinaryOp(inst, kInteger, kInteger, kInteger, /*check_boolean_op=*/ true);
       break;
     case Instruction::ADD_LONG:
     case Instruction::SUB_LONG:
@@ -3208,33 +3584,27 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::AND_LONG:
     case Instruction::OR_LONG:
     case Instruction::XOR_LONG:
-      work_line_->CheckBinaryOpWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                    reg_types_.LongLo(), reg_types_.LongHi(),
-                                    reg_types_.LongLo(), reg_types_.LongHi());
+      CheckBinaryOpWide(inst, kLongLo, kLongLo, kLongLo);
       break;
     case Instruction::SHL_LONG:
     case Instruction::SHR_LONG:
     case Instruction::USHR_LONG:
       /* shift distance is Int, making these different from other binary operations */
-      work_line_->CheckBinaryOpWideShift(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                         reg_types_.Integer());
+      CheckBinaryOpWideShift(inst, kLongLo, kInteger);
       break;
     case Instruction::ADD_FLOAT:
     case Instruction::SUB_FLOAT:
     case Instruction::MUL_FLOAT:
     case Instruction::DIV_FLOAT:
     case Instruction::REM_FLOAT:
-      work_line_->CheckBinaryOp(this, inst, reg_types_.Float(), reg_types_.Float(),
-                                reg_types_.Float(), false);
+      CheckBinaryOp(inst, kFloat, kFloat, kFloat, /*check_boolean_op=*/ false);
       break;
     case Instruction::ADD_DOUBLE:
     case Instruction::SUB_DOUBLE:
     case Instruction::MUL_DOUBLE:
     case Instruction::DIV_DOUBLE:
     case Instruction::REM_DOUBLE:
-      work_line_->CheckBinaryOpWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                    reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                    reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckBinaryOpWide(inst, kDoubleLo, kDoubleLo, kDoubleLo);
       break;
     case Instruction::ADD_INT_2ADDR:
     case Instruction::SUB_INT_2ADDR:
@@ -3243,18 +3613,15 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::SHL_INT_2ADDR:
     case Instruction::SHR_INT_2ADDR:
     case Instruction::USHR_INT_2ADDR:
-      work_line_->CheckBinaryOp2addr(this, inst, reg_types_.Integer(), reg_types_.Integer(),
-                                     reg_types_.Integer(), false);
+      CheckBinaryOp2addr(inst, kInteger, kInteger, kInteger, /*check_boolean_op=*/ false);
       break;
     case Instruction::AND_INT_2ADDR:
     case Instruction::OR_INT_2ADDR:
     case Instruction::XOR_INT_2ADDR:
-      work_line_->CheckBinaryOp2addr(this, inst, reg_types_.Integer(), reg_types_.Integer(),
-                                     reg_types_.Integer(), true);
+      CheckBinaryOp2addr(inst, kInteger, kInteger, kInteger, /*check_boolean_op=*/ true);
       break;
     case Instruction::DIV_INT_2ADDR:
-      work_line_->CheckBinaryOp2addr(this, inst, reg_types_.Integer(), reg_types_.Integer(),
-                                     reg_types_.Integer(), false);
+      CheckBinaryOp2addr(inst, kInteger, kInteger, kInteger, /*check_boolean_op=*/ false);
       break;
     case Instruction::ADD_LONG_2ADDR:
     case Instruction::SUB_LONG_2ADDR:
@@ -3264,46 +3631,38 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::AND_LONG_2ADDR:
     case Instruction::OR_LONG_2ADDR:
     case Instruction::XOR_LONG_2ADDR:
-      work_line_->CheckBinaryOp2addrWide(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                         reg_types_.LongLo(), reg_types_.LongHi(),
-                                         reg_types_.LongLo(), reg_types_.LongHi());
+      CheckBinaryOp2addrWide(inst, kLongLo, kLongLo, kLongLo);
       break;
     case Instruction::SHL_LONG_2ADDR:
     case Instruction::SHR_LONG_2ADDR:
     case Instruction::USHR_LONG_2ADDR:
-      work_line_->CheckBinaryOp2addrWideShift(this, inst, reg_types_.LongLo(), reg_types_.LongHi(),
-                                              reg_types_.Integer());
+      CheckBinaryOp2addrWideShift(inst, kLongLo, kInteger);
       break;
     case Instruction::ADD_FLOAT_2ADDR:
     case Instruction::SUB_FLOAT_2ADDR:
     case Instruction::MUL_FLOAT_2ADDR:
     case Instruction::DIV_FLOAT_2ADDR:
     case Instruction::REM_FLOAT_2ADDR:
-      work_line_->CheckBinaryOp2addr(this, inst, reg_types_.Float(), reg_types_.Float(),
-                                     reg_types_.Float(), false);
+      CheckBinaryOp2addr(inst, kFloat, kFloat, kFloat, /*check_boolean_op=*/ false);
       break;
     case Instruction::ADD_DOUBLE_2ADDR:
     case Instruction::SUB_DOUBLE_2ADDR:
     case Instruction::MUL_DOUBLE_2ADDR:
     case Instruction::DIV_DOUBLE_2ADDR:
     case Instruction::REM_DOUBLE_2ADDR:
-      work_line_->CheckBinaryOp2addrWide(this, inst, reg_types_.DoubleLo(), reg_types_.DoubleHi(),
-                                         reg_types_.DoubleLo(),  reg_types_.DoubleHi(),
-                                         reg_types_.DoubleLo(), reg_types_.DoubleHi());
+      CheckBinaryOp2addrWide(inst, kDoubleLo, kDoubleLo, kDoubleLo);
       break;
     case Instruction::ADD_INT_LIT16:
     case Instruction::RSUB_INT_LIT16:
     case Instruction::MUL_INT_LIT16:
     case Instruction::DIV_INT_LIT16:
     case Instruction::REM_INT_LIT16:
-      work_line_->CheckLiteralOp(this, inst, reg_types_.Integer(), reg_types_.Integer(), false,
-                                 true);
+      CheckLiteralOp(inst, kInteger, kInteger, /*check_boolean_op=*/ false, /*is_lit16=*/ true);
       break;
     case Instruction::AND_INT_LIT16:
     case Instruction::OR_INT_LIT16:
     case Instruction::XOR_INT_LIT16:
-      work_line_->CheckLiteralOp(this, inst, reg_types_.Integer(), reg_types_.Integer(), true,
-                                 true);
+      CheckLiteralOp(inst, kInteger, kInteger, /*check_boolean_op=*/ true, /*is_lit16=*/ true);
       break;
     case Instruction::ADD_INT_LIT8:
     case Instruction::RSUB_INT_LIT8:
@@ -3313,14 +3672,12 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
     case Instruction::SHL_INT_LIT8:
     case Instruction::SHR_INT_LIT8:
     case Instruction::USHR_INT_LIT8:
-      work_line_->CheckLiteralOp(this, inst, reg_types_.Integer(), reg_types_.Integer(), false,
-                                 false);
+      CheckLiteralOp(inst, kInteger, kInteger, /*check_boolean_op=*/ false, /*is_lit16=*/ false);
       break;
     case Instruction::AND_INT_LIT8:
     case Instruction::OR_INT_LIT8:
     case Instruction::XOR_INT_LIT8:
-      work_line_->CheckLiteralOp(this, inst, reg_types_.Integer(), reg_types_.Integer(), true,
-                                 false);
+      CheckLiteralOp(inst, kInteger, kInteger, /*check_boolean_op=*/ true, /*is_lit16=*/ false);
       break;
 
     /* These should never appear during verification. */
@@ -3353,7 +3710,7 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
       }
     }
     /* immediate failure, reject class */
-    info_messages_ << "Rejecting opcode " << inst->DumpString(dex_file_);
+    InfoMessages() << "Rejecting opcode " << inst->DumpString(dex_file_);
     return false;
   } else if (flags_.have_pending_runtime_throw_failure_) {
     LogVerifyInfo() << "Elevating opcode flags from " << opcode_flags << " to Throw";
@@ -3588,37 +3945,31 @@ bool MethodVerifier<kVerifierDebug>::CodeFlowVerifyInstruction(uint32_t* start_g
 template <bool kVerifierDebug>
 template <CheckAccess C>
 const RegType& MethodVerifier<kVerifierDebug>::ResolveClass(dex::TypeIndex class_idx) {
-  ClassLinker* linker = GetClassLinker();
-  ObjPtr<mirror::Class> klass = CanLoadClasses()
-      ? linker->ResolveType(class_idx, dex_cache_, class_loader_)
-      : linker->LookupResolvedType(class_idx, dex_cache_.Get(), class_loader_.Get());
-  if (CanLoadClasses() && klass == nullptr) {
-    DCHECK(self_->IsExceptionPending());
-    self_->ClearException();
-  }
-  const RegType* result = nullptr;
-  if (klass != nullptr) {
-    bool precise = klass->CannotBeAssignedFromOtherTypes();
-    if (precise && !IsInstantiableOrPrimitive(klass)) {
-      const char* descriptor = dex_file_->GetTypeDescriptor(class_idx);
-      UninstantiableError(descriptor);
-      precise = false;
-    }
-    result = reg_types_.FindClass(klass, precise);
-    if (result == nullptr) {
-      const char* descriptor = dex_file_->GetTypeDescriptor(class_idx);
-      result = reg_types_.InsertClass(descriptor, klass, precise);
+  // FIXME: `RegTypeCache` can currently return a few fundamental classes such as j.l.Object
+  // or j.l.Class without resolving them using the current class loader and recording them
+  // in the corresponding `ClassTable`. The subsequent method and field lookup by callers of
+  // `ResolveClass<>()` can then put their methods and fields to the `DexCache` which should
+  // not be done for classes that are not in the `ClassTable`, potentially leading to crashes.
+  // For now, we force the class resolution here to avoid the inconsistency.
+  // Note that there's nothing we can do if we cannot load classes. (The only code path that
+  // does not allow loading classes is `FindLocksAtDexPc()` which should really need only to
+  // distinguish between reference and non-reference types and track locking. All the other
+  // work, including class lookup, is unnecessary as the class has already been verified.)
+  if (CanLoadClasses()) {
+    ClassLinker* linker = GetClassLinker();
+    ObjPtr<mirror::Class> klass =  linker->ResolveType(class_idx, dex_cache_, class_loader_);
+    if (klass == nullptr) {
+      DCHECK(self_->IsExceptionPending());
+      self_->ClearException();
     }
-  } else {
-    const char* descriptor = dex_file_->GetTypeDescriptor(class_idx);
-    result = &reg_types_.FromDescriptor(class_loader_, descriptor);
   }
-  DCHECK(result != nullptr);
-  if (result->IsConflict()) {
+
+  const RegType& result = reg_types_.FromTypeIndex(class_idx);
+  if (result.IsConflict()) {
     const char* descriptor = dex_file_->GetTypeDescriptor(class_idx);
     Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "accessing broken descriptor '" << descriptor
         << "' in " << GetDeclaringClass();
-    return *result;
+    return result;
   }
 
   // If requested, check if access is allowed. Unresolved types are included in this check, as the
@@ -3627,23 +3978,23 @@ const RegType& MethodVerifier<kVerifierDebug>::ResolveClass(dex::TypeIndex class
   //
   // Note: we do this for unresolved classes to trigger re-verification at runtime.
   if (C != CheckAccess::kNo &&
-      result->IsNonZeroReferenceTypes() &&
+      result.IsNonZeroReferenceTypes() &&
       ((C == CheckAccess::kYes && IsSdkVersionSetAndAtLeast(api_level_, SdkVersion::kP))
-          || !result->IsUnresolvedTypes())) {
+          || !result.IsUnresolvedTypes())) {
     const RegType& referrer = GetDeclaringClass();
     if ((IsSdkVersionSetAndAtLeast(api_level_, SdkVersion::kP) || !referrer.IsUnresolvedTypes()) &&
-        !referrer.CanAccess(*result)) {
+        !CanAccess(result)) {
       if (IsAotMode()) {
         Fail(VERIFY_ERROR_ACCESS_CLASS);
         VLOG(verifier)
-            << "(possibly) illegal class access: '" << referrer << "' -> '" << *result << "'";
+            << "(possibly) illegal class access: '" << referrer << "' -> '" << result << "'";
       } else {
         Fail(VERIFY_ERROR_ACCESS_CLASS)
-            << "(possibly) illegal class access: '" << referrer << "' -> '" << *result << "'";
+            << "(possibly) illegal class access: '" << referrer << "' -> '" << result << "'";
       }
     }
   }
-  return *result;
+  return result;
 }
 
 template <bool kVerifierDebug>
@@ -3675,7 +4026,7 @@ bool MethodVerifier<kVerifierDebug>::HandleMoveException(const Instruction* inst
               // Do access checks only on resolved exception classes.
               const RegType& exception =
                   ResolveClass<CheckAccess::kOnResolvedClass>(iterator.GetHandlerTypeIndex());
-              if (!reg_types_.JavaLangThrowable().IsAssignableFrom(exception, this)) {
+              if (!IsAssignableFrom(reg_types_.JavaLangThrowable(), exception)) {
                 DCHECK(!exception.IsUninitializedTypes());  // Comes from dex, shouldn't be uninit.
                 if (exception.IsUnresolvedTypes()) {
                   if (unresolved == nullptr) {
@@ -3694,10 +4045,9 @@ bool MethodVerifier<kVerifierDebug>::HandleMoveException(const Instruction* inst
                 // odd case, but nothing to do
               } else {
                 common_super = &common_super->Merge(exception, &reg_types_, this);
-                if (FailOrAbort(reg_types_.JavaLangThrowable().IsAssignableFrom(
-                    *common_super, this),
-                    "java.lang.Throwable is not assignable-from common_super at ",
-                    work_insn_idx_)) {
+                if (FailOrAbort(IsAssignableFrom(reg_types_.JavaLangThrowable(), *common_super),
+                                "java.lang.Throwable is not assignable-from common_super at ",
+                                work_insn_idx_)) {
                   break;
                 }
               }
@@ -3724,6 +4074,8 @@ bool MethodVerifier<kVerifierDebug>::HandleMoveException(const Instruction* inst
       Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "unable to find exception handler";
       return std::make_pair(true, &reg_types_.Conflict());
     }
+    DCHECK(common_super->HasClass());
+    CheckForFinalAbstractClass(common_super->GetClass());
     return std::make_pair(true, common_super);
   };
   auto result = caught_exc_type_fn();
@@ -3745,9 +4097,8 @@ ArtMethod* MethodVerifier<kVerifierDebug>::ResolveMethodAndCheckAccess(
   if (klass_type.IsUnresolvedTypes()) {
     return nullptr;  // Can't resolve Class so no more to do here
   }
-  ObjPtr<mirror::Class> klass = klass_type.GetClass();
-  const RegType& referrer = GetDeclaringClass();
   ClassLinker* class_linker = GetClassLinker();
+  ObjPtr<mirror::Class> klass = GetRegTypeClass(klass_type);
 
   ArtMethod* res_method = dex_cache_->GetResolvedMethod(dex_method_idx);
   if (res_method == nullptr) {
@@ -3833,10 +4184,10 @@ ArtMethod* MethodVerifier<kVerifierDebug>::ResolveMethodAndCheckAccess(
     return nullptr;
   }
   // Check if access is allowed.
-  if (!referrer.CanAccessMember(res_method->GetDeclaringClass(), res_method->GetAccessFlags())) {
+  if (!CanAccessMember(res_method->GetDeclaringClass(), res_method->GetAccessFlags())) {
     Fail(VERIFY_ERROR_ACCESS_METHOD) << "illegal method access (call "
                                      << res_method->PrettyMethod()
-                                     << " from " << referrer << ")";
+                                     << " from " << GetDeclaringClass() << ")";
     return res_method;
   }
   // Check that invoke-virtual and invoke-super are not used on private methods of the same class.
@@ -3896,7 +4247,7 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgsFromIterator(
    * rigorous check here (which is okay since we have to do it at runtime).
    */
   if (method_type != METHOD_STATIC) {
-    const RegType& actual_arg_type = work_line_->GetInvocationThis(this, inst);
+    const RegType& actual_arg_type = GetInvocationThis(inst);
     if (actual_arg_type.IsConflict()) {  // GetInvocationThis failed.
       CHECK(flags_.have_pending_hard_failure_);
       return nullptr;
@@ -3922,22 +4273,26 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgsFromIterator(
                                        ? GetRegTypeCache()->FromUninitialized(actual_arg_type)
                                        : actual_arg_type;
     if (method_type != METHOD_INTERFACE && !adjusted_type.IsZeroOrNull()) {
-      const RegType* res_method_class;
+      // Get the referenced class first. This is fast because it's already cached by the type
+      // index due to method resolution. It is usually the resolved method's declaring class.
+      const uint32_t method_idx = GetMethodIdxOfInvoke(inst);
+      const dex::TypeIndex class_idx = dex_file_->GetMethodId(method_idx).class_idx_;
+      const RegType* res_method_class = &reg_types_.FromTypeIndex(class_idx);
+      DCHECK_IMPLIES(res_method != nullptr,
+                     res_method_class->IsJavaLangObject() || res_method_class->IsReference());
+      DCHECK_IMPLIES(res_method != nullptr && res_method_class->IsJavaLangObject(),
+                     res_method->GetDeclaringClass()->IsObjectClass());
       // Miranda methods have the declaring interface as their declaring class, not the abstract
       // class. It would be wrong to use this for the type check (interface type checks are
       // postponed to runtime).
-      if (res_method != nullptr && !res_method->IsMiranda()) {
+      if (res_method != nullptr && res_method_class->IsReference() && !res_method->IsMiranda()) {
         ObjPtr<mirror::Class> klass = res_method->GetDeclaringClass();
-        std::string temp;
-        res_method_class = &FromClass(klass->GetDescriptor(&temp), klass,
-                                      klass->CannotBeAssignedFromOtherTypes());
-      } else {
-        const uint32_t method_idx = GetMethodIdxOfInvoke(inst);
-        const dex::TypeIndex class_idx = dex_file_->GetMethodId(method_idx).class_idx_;
-        res_method_class =
-            &reg_types_.FromDescriptor(class_loader_, dex_file_->GetTypeDescriptor(class_idx));
+        if (res_method_class->GetClass() != klass) {
+          // The resolved method is in a superclass, not directly in the referenced class.
+          res_method_class = &reg_types_.FromClass(klass);
+        }
       }
-      if (!res_method_class->IsAssignableFrom(adjusted_type, this)) {
+      if (!IsAssignableFrom(*res_method_class, adjusted_type)) {
         Fail(adjusted_type.IsUnresolvedTypes()
                  ? VERIFY_ERROR_UNRESOLVED_TYPE_CHECK
                  : VERIFY_ERROR_BAD_CLASS_HARD)
@@ -3964,15 +4319,7 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgsFromIterator(
       return nullptr;
     }
 
-    const char* param_descriptor = it->GetDescriptor();
-
-    if (param_descriptor == nullptr) {
-      Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "Rejecting invocation because of missing signature "
-          "component";
-      return nullptr;
-    }
-
-    const RegType& reg_type = reg_types_.FromDescriptor(class_loader_, param_descriptor);
+    const RegType& reg_type = reg_types_.FromTypeIndex(it->GetTypeIdx());
     uint32_t get_reg = is_range ? inst->VRegC() + static_cast<uint32_t>(sig_registers) :
         arg[sig_registers];
     if (reg_type.IsIntegralTypes()) {
@@ -3983,7 +4330,7 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgsFromIterator(
         return nullptr;
       }
     } else {
-      if (!work_line_->VerifyRegisterType(this, get_reg, reg_type)) {
+      if (!VerifyRegisterType(get_reg, reg_type)) {
         // Continue on soft failures. We need to find possible hard failures to avoid problems in
         // the compiler.
         if (flags_.have_pending_hard_failure_) {
@@ -4083,32 +4430,6 @@ bool MethodVerifier<kVerifierDebug>::CheckCallSite(uint32_t call_site_idx) {
   return true;
 }
 
-class MethodParamListDescriptorIterator {
- public:
-  explicit MethodParamListDescriptorIterator(ArtMethod* res_method) :
-      res_method_(res_method), pos_(0), params_(res_method->GetParameterTypeList()),
-      params_size_(params_ == nullptr ? 0 : params_->Size()) {
-  }
-
-  bool HasNext() {
-    return pos_ < params_size_;
-  }
-
-  void Next() {
-    ++pos_;
-  }
-
-  const char* GetDescriptor() REQUIRES_SHARED(Locks::mutator_lock_) {
-    return res_method_->GetTypeDescriptorFromTypeIdx(params_->GetTypeItem(pos_).type_idx_);
-  }
-
- private:
-  ArtMethod* res_method_;
-  size_t pos_;
-  const dex::TypeList* params_;
-  const size_t params_size_;
-};
-
 template <bool kVerifierDebug>
 ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
     const Instruction* inst, MethodType method_type, bool is_range) {
@@ -4128,8 +4449,7 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
   // has a vtable entry for the target method. Or the target is on a interface.
   if (method_type == METHOD_SUPER) {
     dex::TypeIndex class_idx = dex_file_->GetMethodId(method_idx).class_idx_;
-    const RegType& reference_type =
-        reg_types_.FromDescriptor(class_loader_, dex_file_->GetTypeDescriptor(class_idx));
+    const RegType& reference_type = reg_types_.FromTypeIndex(class_idx);
     if (reference_type.IsUnresolvedTypes()) {
       // We cannot differentiate on whether this is a class change error or just
       // a missing method. This will be handled at runtime.
@@ -4137,13 +4457,14 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
       VerifyInvocationArgsUnresolvedMethod(inst, method_type, is_range);
       return nullptr;
     }
-    if (reference_type.GetClass()->IsInterface()) {
+    DCHECK(reference_type.IsJavaLangObject() || reference_type.IsReference());
+    if (reference_type.IsReference() && reference_type.GetClass()->IsInterface()) {
       if (!GetDeclaringClass().HasClass()) {
         Fail(VERIFY_ERROR_NO_CLASS) << "Unable to resolve the full class of 'this' used in an"
                                     << "interface invoke-super";
         VerifyInvocationArgsUnresolvedMethod(inst, method_type, is_range);
         return nullptr;
-      } else if (!reference_type.IsStrictlyAssignableFrom(GetDeclaringClass(), this)) {
+      } else if (!IsStrictlyAssignableFrom(reference_type, GetDeclaringClass())) {
         Fail(VERIFY_ERROR_CLASS_CHANGE)
             << "invoke-super in " << mirror::Class::PrettyClass(GetDeclaringClass().GetClass())
             << " in method "
@@ -4154,7 +4475,15 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
         return nullptr;
       }
     } else {
-      const RegType& super = GetDeclaringClass().GetSuperClass(&reg_types_);
+      if (UNLIKELY(!class_def_.superclass_idx_.IsValid())) {
+        // Verification error in `j.l.Object` leads to a hang while trying to verify
+        // the exception class. It is better to crash directly.
+        LOG(FATAL) << "No superclass for invoke-super from "
+                   << dex_file_->PrettyMethod(dex_method_idx_)
+                   << " to super " << res_method->PrettyMethod() << ".";
+        UNREACHABLE();
+      }
+      const RegType& super = reg_types_.FromTypeIndex(class_def_.superclass_idx_);
       if (super.IsUnresolvedTypes()) {
         Fail(VERIFY_ERROR_NO_METHOD) << "unknown super class in invoke-super from "
                                     << dex_file_->PrettyMethod(dex_method_idx_)
@@ -4162,8 +4491,8 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
         VerifyInvocationArgsUnresolvedMethod(inst, method_type, is_range);
         return nullptr;
       }
-      if (!reference_type.IsStrictlyAssignableFrom(GetDeclaringClass(), this) ||
-          (res_method->GetMethodIndex() >= super.GetClass()->GetVTableLength())) {
+      if (!IsStrictlyAssignableFrom(reference_type, GetDeclaringClass()) ||
+          (res_method->GetMethodIndex() >= GetRegTypeClass(super)->GetVTableLength())) {
         Fail(VERIFY_ERROR_NO_METHOD) << "invalid invoke-super from "
                                     << dex_file_->PrettyMethod(dex_method_idx_)
                                     << " to super " << super
@@ -4175,16 +4504,23 @@ ArtMethod* MethodVerifier<kVerifierDebug>::VerifyInvocationArgs(
     }
   }
 
+  dex::ProtoIndex proto_idx;
   if (UNLIKELY(method_type == METHOD_POLYMORPHIC)) {
     // Process the signature of the calling site that is invoking the method handle.
-    dex::ProtoIndex proto_idx(inst->VRegH());
-    DexFileParameterIterator it(*dex_file_, dex_file_->GetProtoId(proto_idx));
-    return VerifyInvocationArgsFromIterator(&it, inst, method_type, is_range, res_method);
+    proto_idx = dex::ProtoIndex(inst->VRegH());
   } else {
     // Process the target method's signature.
-    MethodParamListDescriptorIterator it(res_method);
-    return VerifyInvocationArgsFromIterator(&it, inst, method_type, is_range, res_method);
+    proto_idx = dex_file_->GetMethodId(method_idx).proto_idx_;
   }
+  DexFileParameterIterator it(*dex_file_, dex_file_->GetProtoId(proto_idx));
+  ArtMethod* verified_method =
+      VerifyInvocationArgsFromIterator(&it, inst, method_type, is_range, res_method);
+
+  if (verified_method != nullptr && !verified_method->GetDeclaringClass()->IsInterface()) {
+    CheckForFinalAbstractClass(res_method->GetDeclaringClass());
+  }
+
+  return verified_method;
 }
 
 template <bool kVerifierDebug>
@@ -4238,7 +4574,7 @@ bool MethodVerifier<kVerifierDebug>::CheckSignaturePolymorphicMethod(ArtMethod*
 
 template <bool kVerifierDebug>
 bool MethodVerifier<kVerifierDebug>::CheckSignaturePolymorphicReceiver(const Instruction* inst) {
-  const RegType& this_type = work_line_->GetInvocationThis(this, inst);
+  const RegType& this_type = GetInvocationThis(inst);
   if (this_type.IsZeroOrNull()) {
     /* null pointer always passes (and always fails at run time) */
     return true;
@@ -4294,15 +4630,14 @@ void MethodVerifier<kVerifierDebug>::VerifyNewArray(const Instruction* inst,
       Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "new-array on non-array class " << res_type;
     } else if (!is_filled) {
       /* make sure "size" register is valid type */
-      work_line_->VerifyRegisterType(this, inst->VRegB_22c(), reg_types_.Integer());
+      VerifyRegisterType(inst->VRegB_22c(), RegType::Kind::kInteger);
       /* set register type to array class */
-      const RegType& precise_type = reg_types_.FromUninitialized(res_type);
-      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_22c(), precise_type);
+      work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_22c(), res_type);
     } else {
       DCHECK(!res_type.IsUnresolvedMergedReference());
       // Verify each register. If "arg_count" is bad, VerifyRegisterType() will run off the end of
       // the list and fail. It's legal, if silly, for arg_count to be zero.
-      const RegType& expected_type = reg_types_.GetComponentType(res_type, class_loader_);
+      const RegType& expected_type = reg_types_.GetComponentType(res_type);
       uint32_t arg_count = (is_range) ? inst->VRegA_3rc() : inst->VRegA_35c();
       uint32_t arg[5];
       if (!is_range) {
@@ -4310,15 +4645,14 @@ void MethodVerifier<kVerifierDebug>::VerifyNewArray(const Instruction* inst,
       }
       for (size_t ui = 0; ui < arg_count; ui++) {
         uint32_t get_reg = is_range ? inst->VRegC_3rc() + ui : arg[ui];
-        work_line_->VerifyRegisterType(this, get_reg, expected_type);
+        VerifyRegisterType(get_reg, expected_type);
         if (flags_.have_pending_hard_failure_) {
           // Don't continue on hard failures.
           return;
         }
       }
       // filled-array result goes into "result" register
-      const RegType& precise_type = reg_types_.FromUninitialized(res_type);
-      work_line_->SetResultRegisterType(this, precise_type);
+      work_line_->SetResultRegisterType(this, res_type);
     }
   }
 }
@@ -4340,7 +4674,7 @@ void MethodVerifier<kVerifierDebug>::VerifyAGet(const Instruction* inst,
       } else if (insn_type.IsInteger()) {
         // Pick a non-zero constant (to distinguish with null) that can fit in any primitive.
         // We cannot use 'insn_type' as it could be a float array or an int array.
-        work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), DetermineCat1Constant(1));
+        work_line_->SetRegisterType(inst->VRegA_23x(), DetermineCat1Constant(1));
       } else if (insn_type.IsCategory1Types()) {
         // Category 1
         // The 'insn_type' is exactly the type we need.
@@ -4348,8 +4682,8 @@ void MethodVerifier<kVerifierDebug>::VerifyAGet(const Instruction* inst,
       } else {
         // Category 2
         work_line_->SetRegisterTypeWide(inst->VRegA_23x(),
-                                        reg_types_.FromCat2ConstLo(0, false),
-                                        reg_types_.FromCat2ConstHi(0, false));
+                                        reg_types_.ConstantLo(),
+                                        reg_types_.ConstantHi());
       }
     } else if (!array_type.IsArrayTypes()) {
       Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "not array type " << array_type << " with aget";
@@ -4362,12 +4696,11 @@ void MethodVerifier<kVerifierDebug>::VerifyAGet(const Instruction* inst,
         Fail(VERIFY_ERROR_NO_CLASS) << "cannot verify aget for " << array_type
             << " because of missing class";
         // Approximate with java.lang.Object[].
-        work_line_->SetRegisterType<LockOp::kClear>(inst->VRegA_23x(),
-                                                    reg_types_.JavaLangObject(false));
+        work_line_->SetRegisterType(inst->VRegA_23x(), RegType::Kind::kJavaLangObject);
       }
     } else {
       /* verify the class */
-      const RegType& component_type = reg_types_.GetComponentType(array_type, class_loader_);
+      const RegType& component_type = reg_types_.GetComponentType(array_type);
       if (!component_type.IsReferenceTypes() && !is_primitive) {
         Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "primitive array type " << array_type
             << " source for aget-object";
@@ -4376,7 +4709,7 @@ void MethodVerifier<kVerifierDebug>::VerifyAGet(const Instruction* inst,
             << " source for category 1 aget";
       } else if (is_primitive && !insn_type.Equals(component_type) &&
                  !((insn_type.IsInteger() && component_type.IsFloat()) ||
-                 (insn_type.IsLong() && component_type.IsDouble()))) {
+                 (insn_type.IsLongLo() && component_type.IsDoubleLo()))) {
         Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "array type " << array_type
             << " incompatible with aget of type " << insn_type;
       } else {
@@ -4396,50 +4729,25 @@ void MethodVerifier<kVerifierDebug>::VerifyAGet(const Instruction* inst,
 
 template <bool kVerifierDebug>
 void MethodVerifier<kVerifierDebug>::VerifyPrimitivePut(const RegType& target_type,
-                                                        const RegType& insn_type,
-                                                        const uint32_t vregA) {
+                                                        uint32_t vregA) {
   // Primitive assignability rules are weaker than regular assignability rules.
-  bool instruction_compatible;
   bool value_compatible;
   const RegType& value_type = work_line_->GetRegisterType(this, vregA);
   if (target_type.IsIntegralTypes()) {
-    instruction_compatible = target_type.Equals(insn_type);
     value_compatible = value_type.IsIntegralTypes();
   } else if (target_type.IsFloat()) {
-    instruction_compatible = insn_type.IsInteger();  // no put-float, so expect put-int
     value_compatible = value_type.IsFloatTypes();
-  } else if (target_type.IsLong()) {
-    instruction_compatible = insn_type.IsLong();
-    // Additional register check: this is not checked statically (as part of VerifyInstructions),
-    // as target_type depends on the resolved type of the field.
-    if (instruction_compatible && work_line_->NumRegs() > vregA + 1) {
-      const RegType& value_type_hi = work_line_->GetRegisterType(this, vregA + 1);
-      value_compatible = value_type.IsLongTypes() && value_type.CheckWidePair(value_type_hi);
-    } else {
-      value_compatible = false;
-    }
-  } else if (target_type.IsDouble()) {
-    instruction_compatible = insn_type.IsLong();  // no put-double, so expect put-long
-    // Additional register check: this is not checked statically (as part of VerifyInstructions),
-    // as target_type depends on the resolved type of the field.
-    if (instruction_compatible && work_line_->NumRegs() > vregA + 1) {
-      const RegType& value_type_hi = work_line_->GetRegisterType(this, vregA + 1);
-      value_compatible = value_type.IsDoubleTypes() && value_type.CheckWidePair(value_type_hi);
-    } else {
-      value_compatible = false;
-    }
+  } else if (target_type.IsLongLo()) {
+    DCHECK_LT(vregA + 1, work_line_->NumRegs());
+    const RegType& value_type_hi = work_line_->GetRegisterType(this, vregA + 1);
+    value_compatible = value_type.IsLongTypes() && value_type.CheckWidePair(value_type_hi);
+  } else if (target_type.IsDoubleLo()) {
+    DCHECK_LT(vregA + 1, work_line_->NumRegs());
+    const RegType& value_type_hi = work_line_->GetRegisterType(this, vregA + 1);
+    value_compatible = value_type.IsDoubleTypes() && value_type.CheckWidePair(value_type_hi);
   } else {
-    instruction_compatible = false;  // reference with primitive store
     value_compatible = false;  // unused
   }
-  if (!instruction_compatible) {
-    // This is a global failure rather than a class change failure as the instructions and
-    // the descriptors for the type should have been consistent within the same file at
-    // compile time.
-    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "put insn has type '" << insn_type
-        << "' but expected type '" << target_type << "'";
-    return;
-  }
   if (!value_compatible) {
     Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "unexpected value in v" << vregA
         << " of type " << value_type << " but expected " << target_type << " for put";
@@ -4476,23 +4784,43 @@ void MethodVerifier<kVerifierDebug>::VerifyAPut(const Instruction* inst,
           }
         }
       }
-      work_line_->VerifyRegisterType(this, inst->VRegA_23x(), *modified_reg_type);
+      VerifyRegisterType(inst->VRegA_23x(), *modified_reg_type);
     } else if (!array_type.IsArrayTypes()) {
       Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "not array type " << array_type << " with aput";
     } else if (array_type.IsUnresolvedMergedReference()) {
       // Unresolved array types must be reference array types.
       if (is_primitive) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "put insn has type '" << insn_type
+        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "aput insn has type '" << insn_type
                                           << "' but unresolved type '" << array_type << "'";
       } else {
         Fail(VERIFY_ERROR_NO_CLASS) << "cannot verify aput for " << array_type
                                     << " because of missing class";
       }
     } else {
-      const RegType& component_type = reg_types_.GetComponentType(array_type, class_loader_);
+      const RegType& component_type = reg_types_.GetComponentType(array_type);
       const uint32_t vregA = inst->VRegA_23x();
       if (is_primitive) {
-        VerifyPrimitivePut(component_type, insn_type, vregA);
+        bool instruction_compatible;
+        if (component_type.IsIntegralTypes()) {
+          instruction_compatible = component_type.Equals(insn_type);
+        } else if (component_type.IsFloat()) {
+          instruction_compatible = insn_type.IsInteger();  // no put-float, so expect put-int
+        } else if (component_type.IsLongLo()) {
+          instruction_compatible = insn_type.IsLongLo();
+        } else if (component_type.IsDoubleLo()) {
+          instruction_compatible = insn_type.IsLongLo();  // no put-double, so expect put-long
+        } else {
+          instruction_compatible = false;  // reference with primitive store
+        }
+        if (!instruction_compatible) {
+          // This is a global failure rather than a class change failure as the instructions and
+          // the descriptors for the type should have been consistent within the same file at
+          // compile time.
+          Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "aput insn has type '" << insn_type
+              << "' but expected type '" << component_type << "'";
+          return;
+        }
+        VerifyPrimitivePut(component_type, vregA);
       } else {
         if (!component_type.IsReferenceTypes()) {
           Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "primitive array type " << array_type
@@ -4501,7 +4829,7 @@ void MethodVerifier<kVerifierDebug>::VerifyAPut(const Instruction* inst,
           // The instruction agrees with the type of array, confirm the value to be stored does too
           // Note: we use the instruction type (rather than the component type) for aput-object as
           // incompatible classes will be caught at runtime as an array store exception
-          work_line_->VerifyRegisterType(this, vregA, insn_type);
+          VerifyRegisterType(vregA, insn_type);
         }
       }
     }
@@ -4509,295 +4837,218 @@ void MethodVerifier<kVerifierDebug>::VerifyAPut(const Instruction* inst,
 }
 
 template <bool kVerifierDebug>
-ArtField* MethodVerifier<kVerifierDebug>::GetStaticField(int field_idx) {
+ArtField* MethodVerifier<kVerifierDebug>::GetStaticField(uint32_t field_idx, bool is_put) {
   const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
   // Check access to class
   const RegType& klass_type = ResolveClass<CheckAccess::kYes>(field_id.class_idx_);
-  if (klass_type.IsConflict()) {  // bad class
-    AppendToLastFailMessage(StringPrintf(" in attempt to access static field %d (%s) in %s",
-                                         field_idx, dex_file_->GetFieldName(field_id),
-                                         dex_file_->GetFieldDeclaringClassDescriptor(field_id)));
-    return nullptr;
-  }
-  if (klass_type.IsUnresolvedTypes()) {
+  // Dex file verifier ensures that field ids reference valid descriptors starting with `L`.
+  DCHECK(klass_type.IsJavaLangObject() ||
+         klass_type.IsReference() ||
+         klass_type.IsUnresolvedReference());
+  if (klass_type.IsUnresolvedReference()) {
     // Accessibility checks depend on resolved fields.
     DCHECK(klass_type.Equals(GetDeclaringClass()) ||
            !failures_.empty() ||
            IsSdkVersionSetAndLessThan(api_level_, SdkVersion::kP));
-
     return nullptr;  // Can't resolve Class so no more to do here, will do checking at runtime.
   }
   ClassLinker* class_linker = GetClassLinker();
   ArtField* field = class_linker->ResolveFieldJLS(field_idx, dex_cache_, class_loader_);
-
   if (field == nullptr) {
     VLOG(verifier) << "Unable to resolve static field " << field_idx << " ("
               << dex_file_->GetFieldName(field_id) << ") in "
               << dex_file_->GetFieldDeclaringClassDescriptor(field_id);
     DCHECK(self_->IsExceptionPending());
     self_->ClearException();
-    return nullptr;
-  } else if (!GetDeclaringClass().CanAccessMember(field->GetDeclaringClass(),
-                                                  field->GetAccessFlags())) {
-    Fail(VERIFY_ERROR_ACCESS_FIELD) << "cannot access static field " << field->PrettyField()
-                                    << " from " << GetDeclaringClass();
+    Fail(VERIFY_ERROR_NO_FIELD)
+        << "field " << dex_file_->PrettyField(field_idx)
+        << " not found in the resolved type " << klass_type;
     return nullptr;
   } else if (!field->IsStatic()) {
     Fail(VERIFY_ERROR_CLASS_CHANGE) << "expected field " << field->PrettyField() << " to be static";
     return nullptr;
   }
-  return field;
+
+  return GetISFieldCommon(field, is_put);
 }
 
 template <bool kVerifierDebug>
-ArtField* MethodVerifier<kVerifierDebug>::GetInstanceField(const RegType& obj_type, int field_idx) {
-  if (!obj_type.IsZeroOrNull() && !obj_type.IsReferenceTypes()) {
+ArtField* MethodVerifier<kVerifierDebug>::GetInstanceField(uint32_t vregB,
+                                                           uint32_t field_idx,
+                                                           bool is_put) {
+  const RegType& obj_type = work_line_->GetRegisterType(this, vregB);
+  if (!obj_type.IsReferenceTypes()) {
     // Trying to read a field from something that isn't a reference.
-    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "instance field access on object that has "
-        << "non-reference type " << obj_type;
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "instance field access on object that has non-reference type " << obj_type;
     return nullptr;
   }
   const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
   // Check access to class.
   const RegType& klass_type = ResolveClass<CheckAccess::kYes>(field_id.class_idx_);
-  if (klass_type.IsConflict()) {
-    AppendToLastFailMessage(StringPrintf(" in attempt to access instance field %d (%s) in %s",
-                                         field_idx, dex_file_->GetFieldName(field_id),
-                                         dex_file_->GetFieldDeclaringClassDescriptor(field_id)));
+  // Dex file verifier ensures that field ids reference valid descriptors starting with `L`.
+  DCHECK(klass_type.IsJavaLangObject() ||
+         klass_type.IsReference() ||
+         klass_type.IsUnresolvedReference());
+  ArtField* field = nullptr;
+  if (!klass_type.IsUnresolvedReference()) {
+    ClassLinker* class_linker = GetClassLinker();
+    field = class_linker->ResolveFieldJLS(field_idx, dex_cache_, class_loader_);
+    if (field == nullptr) {
+      VLOG(verifier) << "Unable to resolve instance field " << field_idx << " ("
+                     << dex_file_->GetFieldName(field_id) << ") in "
+                     << dex_file_->GetFieldDeclaringClassDescriptor(field_id);
+      DCHECK(self_->IsExceptionPending());
+      self_->ClearException();
+    }
+  }
+
+  if (obj_type.IsUninitializedTypes()) {
+    // One is not allowed to access fields on uninitialized references, except to write to
+    // fields in the constructor (before calling another constructor). We strictly check
+    // that the field id references the class directly instead of some subclass.
+    if (is_put && field_id.class_idx_ == GetClassDef().class_idx_) {
+      if (obj_type.IsUnresolvedUninitializedThisReference()) {
+        DCHECK(GetDeclaringClass().IsUnresolvedReference());
+        DCHECK(GetDeclaringClass().Equals(reg_types_.FromUninitialized(obj_type)));
+        ClassAccessor accessor(*dex_file_, GetClassDef());
+        auto it = std::find_if(
+            accessor.GetInstanceFields().begin(),
+            accessor.GetInstanceFields().end(),
+            [field_idx] (const ClassAccessor::Field& f) { return f.GetIndex() == field_idx; });
+        if (it != accessor.GetInstanceFields().end()) {
+          // There are no soft failures to report anymore, other than the class being unresolved.
+          return nullptr;
+        }
+      } else if (obj_type.IsUninitializedThisReference()) {
+        DCHECK(GetDeclaringClass().IsJavaLangObject() || GetDeclaringClass().IsReference());
+        DCHECK(GetDeclaringClass().Equals(reg_types_.FromUninitialized(obj_type)));
+        if (field != nullptr &&
+            field->GetDeclaringClass() == GetDeclaringClass().GetClass() &&
+            !field->IsStatic()) {
+          // The field is now fully verified against the `obj_type`.
+          return field;
+        }
+      }
+    }
+    // Allow `iget` on resolved uninitialized `this` for app compatibility.
+    // This is rejected by the RI but there are Android apps that actually have such `iget`s.
+    // TODO: Should we start rejecting such bytecode based on the SDK level?
+    if (!is_put &&
+        obj_type.IsUninitializedThisReference() &&
+        field != nullptr &&
+        field->GetDeclaringClass() == GetDeclaringClass().GetClass()) {
+      return field;
+    }
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "cannot access instance field " << dex_file_->PrettyField(field_idx)
+        << " of a not fully initialized object within the context of "
+        << dex_file_->PrettyMethod(dex_method_idx_);
     return nullptr;
   }
-  if (klass_type.IsUnresolvedTypes()) {
+
+  if (klass_type.IsUnresolvedReference()) {
     // Accessibility checks depend on resolved fields.
     DCHECK(klass_type.Equals(GetDeclaringClass()) ||
            !failures_.empty() ||
            IsSdkVersionSetAndLessThan(api_level_, SdkVersion::kP));
-
-    return nullptr;  // Can't resolve Class so no more to do here
-  }
-  ClassLinker* class_linker = GetClassLinker();
-  ArtField* field = class_linker->ResolveFieldJLS(field_idx, dex_cache_, class_loader_);
-
-  if (field == nullptr) {
-    VLOG(verifier) << "Unable to resolve instance field " << field_idx << " ("
-              << dex_file_->GetFieldName(field_id) << ") in "
-              << dex_file_->GetFieldDeclaringClassDescriptor(field_id);
-    DCHECK(self_->IsExceptionPending());
-    self_->ClearException();
+    return nullptr;  // Can't resolve Class so no more to do here, will do checking at runtime.
+  } else if (field == nullptr) {
+    Fail(VERIFY_ERROR_NO_FIELD)
+        << "field " << dex_file_->PrettyField(field_idx)
+        << " not found in the resolved type " << klass_type;
     return nullptr;
   } else if (obj_type.IsZeroOrNull()) {
     // Cannot infer and check type, however, access will cause null pointer exception.
     // Fall through into a few last soft failure checks below.
   } else {
-    std::string temp;
     ObjPtr<mirror::Class> klass = field->GetDeclaringClass();
+    DCHECK_IMPLIES(klass_type.IsJavaLangObject(), klass->IsObjectClass());
     const RegType& field_klass =
-        FromClass(klass->GetDescriptor(&temp), klass, klass->CannotBeAssignedFromOtherTypes());
-    if (obj_type.IsUninitializedTypes()) {
-      // Field accesses through uninitialized references are only allowable for constructors where
-      // the field is declared in this class.
-      // Note: this IsConstructor check is technically redundant, as UninitializedThis should only
-      //       appear in constructors.
-      if (!obj_type.IsUninitializedThisReference() ||
-          !IsConstructor() ||
-          !field_klass.Equals(GetDeclaringClass())) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "cannot access instance field " << field->PrettyField()
-                                          << " of a not fully initialized object within the context"
-                                          << " of " << dex_file_->PrettyMethod(dex_method_idx_);
-        return nullptr;
-      }
-    } else if (!field_klass.IsAssignableFrom(obj_type, this)) {
+        LIKELY(klass_type.IsJavaLangObject() || klass_type.GetClass() == klass)
+            ? klass_type
+            : reg_types_.FromClass(klass);
+    DCHECK(!obj_type.IsUninitializedTypes());
+    if (!IsAssignableFrom(field_klass, obj_type)) {
       // Trying to access C1.field1 using reference of type C2, which is neither C1 or a sub-class
       // of C1. For resolution to occur the declared class of the field must be compatible with
       // obj_type, we've discovered this wasn't so, so report the field didn't exist.
-      VerifyError type;
-      bool is_aot = IsAotMode();
-      if (is_aot && (field_klass.IsUnresolvedTypes() || obj_type.IsUnresolvedTypes())) {
-        // Compiler & unresolved types involved, retry at runtime.
-        type = VerifyError::VERIFY_ERROR_UNRESOLVED_TYPE_CHECK;
-      } else {
-        // Classes known (resolved; and thus assignability check is precise), or we are at runtime
-        // and still missing classes. This is a hard failure.
-        type = VerifyError::VERIFY_ERROR_BAD_CLASS_HARD;
-      }
-      Fail(type) << "cannot access instance field " << field->PrettyField()
-                 << " from object of type " << obj_type;
+      DCHECK(!field_klass.IsUnresolvedTypes());
+      Fail(obj_type.IsUnresolvedTypes()
+                 ? VERIFY_ERROR_UNRESOLVED_TYPE_CHECK
+                 : VERIFY_ERROR_BAD_CLASS_HARD)
+          << "cannot access instance field " << field->PrettyField()
+          << " from object of type " << obj_type;
       return nullptr;
     }
   }
 
   // Few last soft failure checks.
-  if (!GetDeclaringClass().CanAccessMember(field->GetDeclaringClass(),
-                                           field->GetAccessFlags())) {
-    Fail(VERIFY_ERROR_ACCESS_FIELD) << "cannot access instance field " << field->PrettyField()
-                                    << " from " << GetDeclaringClass();
-    return nullptr;
-  } else if (field->IsStatic()) {
+  if (field->IsStatic()) {
     Fail(VERIFY_ERROR_CLASS_CHANGE) << "expected field " << field->PrettyField()
                                     << " to not be static";
     return nullptr;
   }
 
+  return GetISFieldCommon(field, is_put);
+}
+
+template <bool kVerifierDebug>
+ArtField* MethodVerifier<kVerifierDebug>::GetISFieldCommon(ArtField* field, bool is_put) {
+  DCHECK(field != nullptr);
+  if (!CanAccessMember(field->GetDeclaringClass(), field->GetAccessFlags())) {
+    Fail(VERIFY_ERROR_ACCESS_FIELD)
+        << "cannot access " << (field->IsStatic() ? "static" : "instance") << " field "
+        << field->PrettyField() << " from " << GetDeclaringClass();
+    return nullptr;
+  }
+  if (is_put && field->IsFinal() && field->GetDeclaringClass() != GetDeclaringClass().GetClass()) {
+    Fail(VERIFY_ERROR_ACCESS_FIELD)
+        << "cannot modify final field " << field->PrettyField()
+        << " from other class " << GetDeclaringClass();
+    return nullptr;
+  }
+  CheckForFinalAbstractClass(field->GetDeclaringClass());
   return field;
 }
 
 template <bool kVerifierDebug>
 template <FieldAccessType kAccType>
 void MethodVerifier<kVerifierDebug>::VerifyISFieldAccess(const Instruction* inst,
-                                                         const RegType& insn_type,
                                                          bool is_primitive,
                                                          bool is_static) {
   uint32_t field_idx = GetFieldIdxOfFieldAccess(inst, is_static);
+  DCHECK(!flags_.have_pending_hard_failure_);
   ArtField* field;
   if (is_static) {
-    field = GetStaticField(field_idx);
+    field = GetStaticField(field_idx, kAccType == FieldAccessType::kAccPut);
   } else {
-    const RegType& object_type = work_line_->GetRegisterType(this, inst->VRegB_22c());
-
-    // One is not allowed to access fields on uninitialized references, except to write to
-    // fields in the constructor (before calling another constructor).
-    // GetInstanceField does an assignability check which will fail for uninitialized types.
-    // We thus modify the type if the uninitialized reference is a "this" reference (this also
-    // checks at the same time that we're verifying a constructor).
-    bool should_adjust = (kAccType == FieldAccessType::kAccPut) &&
-                         (object_type.IsUninitializedThisReference() ||
-                          object_type.IsUnresolvedAndUninitializedThisReference());
-    const RegType& adjusted_type = should_adjust
-                                       ? GetRegTypeCache()->FromUninitialized(object_type)
-                                       : object_type;
-    field = GetInstanceField(adjusted_type, field_idx);
+    field = GetInstanceField(inst->VRegB_22c(), field_idx, kAccType == FieldAccessType::kAccPut);
     if (UNLIKELY(flags_.have_pending_hard_failure_)) {
       return;
     }
-    if (should_adjust) {
-      bool illegal_field_access = false;
-      if (field == nullptr) {
-        const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
-        if (field_id.class_idx_ != GetClassDef().class_idx_) {
-          illegal_field_access = true;
-        } else {
-          ClassAccessor accessor(*dex_file_, GetClassDef());
-          illegal_field_access = (accessor.GetInstanceFields().end() ==
-              std::find_if(accessor.GetInstanceFields().begin(),
-                           accessor.GetInstanceFields().end(),
-                           [field_idx] (const ClassAccessor::Field& f) {
-                             return f.GetIndex() == field_idx;
-                           }));
-        }
-      } else if (field->GetDeclaringClass() != GetDeclaringClass().GetClass()) {
-        illegal_field_access = true;
-      }
-      if (illegal_field_access) {
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "cannot access instance field "
-                                          << dex_file_->PrettyField(field_idx)
-                                          << " of a not fully initialized "
-                                          << "object within the context of "
-                                          << dex_file_->PrettyMethod(dex_method_idx_);
-        return;
-      }
-    }
-  }
-  const RegType* field_type = nullptr;
-  if (field != nullptr) {
-    if (kAccType == FieldAccessType::kAccPut) {
-      if (field->IsFinal() && field->GetDeclaringClass() != GetDeclaringClass().GetClass()) {
-        Fail(VERIFY_ERROR_ACCESS_FIELD) << "cannot modify final field " << field->PrettyField()
-                                        << " from other class " << GetDeclaringClass();
-        // Keep hunting for possible hard fails.
-      }
-    }
-
-    ObjPtr<mirror::Class> field_type_class =
-        CanLoadClasses() ? field->ResolveType() : field->LookupResolvedType();
-    if (field_type_class != nullptr) {
-      field_type = &FromClass(field->GetTypeDescriptor(),
-                              field_type_class,
-                              field_type_class->CannotBeAssignedFromOtherTypes());
-    } else {
-      DCHECK_IMPLIES(CanLoadClasses(), self_->IsExceptionPending());
-      self_->ClearException();
-    }
-  } else if (IsSdkVersionSetAndAtLeast(api_level_, SdkVersion::kP)) {
-    // If we don't have the field (it seems we failed resolution) and this is a PUT, we need to
-    // redo verification at runtime as the field may be final, unless the field id shows it's in
-    // the same class.
-    //
-    // For simplicity, it is OK to not distinguish compile-time vs runtime, and post this an
-    // ACCESS_FIELD failure at runtime. This has the same effect as NO_FIELD - punting the class
-    // to the access-checks interpreter.
-    //
-    // Note: see b/34966607. This and above may be changed in the future.
-    if (kAccType == FieldAccessType::kAccPut) {
-      const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
-      const char* field_class_descriptor = dex_file_->GetFieldDeclaringClassDescriptor(field_id);
-      const RegType* field_class_type =
-          &reg_types_.FromDescriptor(class_loader_, field_class_descriptor);
-      if (!field_class_type->Equals(GetDeclaringClass())) {
-        Fail(VERIFY_ERROR_ACCESS_FIELD) << "could not check field put for final field modify of "
-                                        << field_class_descriptor
-                                        << "."
-                                        << dex_file_->GetFieldName(field_id)
-                                        << " from other class "
-                                        << GetDeclaringClass();
-      }
-    }
-  }
-  if (field_type == nullptr) {
-    const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
-    const char* descriptor = dex_file_->GetFieldTypeDescriptor(field_id);
-    field_type = &reg_types_.FromDescriptor(class_loader_, descriptor);
   }
-  DCHECK(field_type != nullptr);
+  DCHECK(!flags_.have_pending_hard_failure_);
+  const dex::FieldId& field_id = dex_file_->GetFieldId(field_idx);
+  DCHECK_IMPLIES(field == nullptr && IsSdkVersionSetAndAtLeast(api_level_, SdkVersion::kP),
+                 field_id.class_idx_ == class_def_.class_idx_ || !failures_.empty());
+  const RegType& field_type = reg_types_.FromTypeIndex(field_id.type_idx_);
   const uint32_t vregA = (is_static) ? inst->VRegA_21c() : inst->VRegA_22c();
   static_assert(kAccType == FieldAccessType::kAccPut || kAccType == FieldAccessType::kAccGet,
                 "Unexpected third access type");
   if (kAccType == FieldAccessType::kAccPut) {
     // sput or iput.
     if (is_primitive) {
-      VerifyPrimitivePut(*field_type, insn_type, vregA);
+      VerifyPrimitivePut(field_type, vregA);
     } else {
-      DCHECK(insn_type.IsJavaLangObject());
-      if (!insn_type.IsAssignableFrom(*field_type, this)) {
-        DCHECK(!field_type->IsReferenceTypes());
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "expected field " << ArtField::PrettyField(field)
-                                          << " to be compatible with type '" << insn_type
-                                          << "' but found type '" << *field_type
-                                          << "' in put-object";
-        return;
-      }
-      work_line_->VerifyRegisterType(this, vregA, *field_type);
+      VerifyRegisterType(vregA, field_type);
     }
   } else if (kAccType == FieldAccessType::kAccGet) {
     // sget or iget.
-    if (is_primitive) {
-      if (field_type->Equals(insn_type) ||
-          (field_type->IsFloat() && insn_type.IsInteger()) ||
-          (field_type->IsDouble() && insn_type.IsLong())) {
-        // expected that read is of the correct primitive type or that int reads are reading
-        // floats or long reads are reading doubles
-      } else {
-        // This is a global failure rather than a class change failure as the instructions and
-        // the descriptors for the type should have been consistent within the same file at
-        // compile time
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "expected field " << ArtField::PrettyField(field)
-                                          << " to be of type '" << insn_type
-                                          << "' but found type '" << *field_type << "' in get";
-        return;
-      }
+    if (!field_type.IsLowHalf()) {
+      work_line_->SetRegisterType<LockOp::kClear>(vregA, field_type);
     } else {
-      DCHECK(insn_type.IsJavaLangObject());
-      if (!insn_type.IsAssignableFrom(*field_type, this)) {
-        DCHECK(!field_type->IsReferenceTypes());
-        Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "expected field " << ArtField::PrettyField(field)
-                                          << " to be compatible with type '" << insn_type
-                                          << "' but found type '" << *field_type
-                                          << "' in get-object";
-        return;
-      }
-    }
-    if (!field_type->IsLowHalf()) {
-      work_line_->SetRegisterType<LockOp::kClear>(vregA, *field_type);
-    } else {
-      work_line_->SetRegisterTypeWide(vregA, *field_type, field_type->HighHalf(&reg_types_));
+      work_line_->SetRegisterTypeWide(vregA, field_type, field_type.HighHalf(&reg_types_));
     }
   } else {
     LOG(FATAL) << "Unexpected case.";
@@ -4862,34 +5113,32 @@ const RegType& MethodVerifier<kVerifierDebug>::GetMethodReturnType() {
   if (return_type_ == nullptr) {
     const dex::MethodId& method_id = dex_file_->GetMethodId(dex_method_idx_);
     const dex::ProtoId& proto_id = dex_file_->GetMethodPrototype(method_id);
-    dex::TypeIndex return_type_idx = proto_id.return_type_idx_;
-    const char* descriptor = dex_file_->GetTypeDescriptor(dex_file_->GetTypeId(return_type_idx));
-    return_type_ = &reg_types_.FromDescriptor(class_loader_, descriptor);
+    return_type_ = &reg_types_.FromTypeIndex(proto_id.return_type_idx_);
   }
   return *return_type_;
 }
 
 template <bool kVerifierDebug>
-const RegType& MethodVerifier<kVerifierDebug>::DetermineCat1Constant(int32_t value) {
+RegType::Kind MethodVerifier<kVerifierDebug>::DetermineCat1Constant(int32_t value) {
   // Imprecise constant type.
   if (value < -32768) {
-    return reg_types_.IntConstant();
+    return RegType::Kind::kIntegerConstant;
   } else if (value < -128) {
-    return reg_types_.ShortConstant();
+    return RegType::Kind::kShortConstant;
   } else if (value < 0) {
-    return reg_types_.ByteConstant();
+    return RegType::Kind::kByteConstant;
   } else if (value == 0) {
-    return reg_types_.Zero();
+    return RegType::Kind::kZero;
   } else if (value == 1) {
-    return reg_types_.One();
+    return RegType::Kind::kBooleanConstant;
   } else if (value < 128) {
-    return reg_types_.PosByteConstant();
+    return RegType::Kind::kPositiveByteConstant;
   } else if (value < 32768) {
-    return reg_types_.PosShortConstant();
+    return RegType::Kind::kPositiveShortConstant;
   } else if (value < 65536) {
-    return reg_types_.CharConstant();
+    return RegType::Kind::kCharConstant;
   } else {
-    return reg_types_.IntConstant();
+    return RegType::Kind::kIntegerConstant;
   }
 }
 
@@ -4933,31 +5182,31 @@ bool MethodVerifier<kVerifierDebug>::PotentiallyMarkRuntimeThrow() {
 }  // namespace
 }  // namespace impl
 
+inline ClassLinker* MethodVerifier::GetClassLinker() const {
+  return reg_types_.GetClassLinker();
+}
+
 MethodVerifier::MethodVerifier(Thread* self,
-                               ClassLinker* class_linker,
                                ArenaPool* arena_pool,
+                               RegTypeCache* reg_types,
                                VerifierDeps* verifier_deps,
-                               const DexFile* dex_file,
                                const dex::ClassDef& class_def,
                                const dex::CodeItem* code_item,
                                uint32_t dex_method_idx,
-                               bool can_load_classes,
-                               bool allow_thread_suspension,
                                bool aot_mode)
     : self_(self),
-      arena_stack_(arena_pool),
-      allocator_(&arena_stack_),
-      reg_types_(self, class_linker, can_load_classes, allocator_, allow_thread_suspension),
+      allocator_(arena_pool),
+      reg_types_(*reg_types),
       reg_table_(allocator_),
       work_insn_idx_(dex::kDexNoIndex),
       dex_method_idx_(dex_method_idx),
-      dex_file_(dex_file),
+      dex_file_(reg_types->GetDexFile()),
       class_def_(class_def),
-      code_item_accessor_(*dex_file, code_item),
-      // TODO: make it designated initialization when we compile as C++20.
-      flags_({false, false}),
-      const_flags_({aot_mode, can_load_classes}),
+      code_item_accessor_(*dex_file_, code_item),
+      flags_{ .have_pending_hard_failure_ = false, .have_pending_runtime_throw_failure_ = false },
+      const_flags_{ .aot_mode_ = aot_mode, .can_load_classes_ = reg_types->CanLoadClasses() },
       encountered_failure_types_(0),
+      info_messages_(std::nullopt),
       verifier_deps_(verifier_deps),
       link_(nullptr) {
 }
@@ -4967,13 +5216,11 @@ MethodVerifier::~MethodVerifier() {
 }
 
 MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
-                                                         ClassLinker* class_linker,
                                                          ArenaPool* arena_pool,
+                                                         RegTypeCache* reg_types,
                                                          VerifierDeps* verifier_deps,
                                                          uint32_t method_idx,
-                                                         const DexFile* dex_file,
                                                          Handle<mirror::DexCache> dex_cache,
-                                                         Handle<mirror::ClassLoader> class_loader,
                                                          const dex::ClassDef& class_def,
                                                          const dex::CodeItem* code_item,
                                                          uint32_t method_access_flags,
@@ -4983,13 +5230,11 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
                                                          std::string* hard_failure_msg) {
   if (VLOG_IS_ON(verifier_debug)) {
     return VerifyMethod<true>(self,
-                              class_linker,
                               arena_pool,
+                              reg_types,
                               verifier_deps,
                               method_idx,
-                              dex_file,
                               dex_cache,
-                              class_loader,
                               class_def,
                               code_item,
                               method_access_flags,
@@ -4999,13 +5244,11 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
                               hard_failure_msg);
   } else {
     return VerifyMethod<false>(self,
-                               class_linker,
                                arena_pool,
+                               reg_types,
                                verifier_deps,
                                method_idx,
-                               dex_file,
                                dex_cache,
-                               class_loader,
                                class_def,
                                code_item,
                                method_access_flags,
@@ -5028,6 +5271,7 @@ static inline bool CanRuntimeHandleVerificationFailure(uint32_t encountered_fail
       verifier::VerifyError::VERIFY_ERROR_ACCESS_CLASS |
       verifier::VerifyError::VERIFY_ERROR_ACCESS_FIELD |
       verifier::VerifyError::VERIFY_ERROR_NO_METHOD |
+      verifier::VerifyError::VERIFY_ERROR_NO_FIELD |
       verifier::VerifyError::VERIFY_ERROR_ACCESS_METHOD |
       verifier::VerifyError::VERIFY_ERROR_RUNTIME_THROW;
   return (encountered_failure_types & (~unresolved_mask)) == 0;
@@ -5035,13 +5279,11 @@ static inline bool CanRuntimeHandleVerificationFailure(uint32_t encountered_fail
 
 template <bool kVerifierDebug>
 MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
-                                                         ClassLinker* class_linker,
                                                          ArenaPool* arena_pool,
+                                                         RegTypeCache* reg_types,
                                                          VerifierDeps* verifier_deps,
                                                          uint32_t method_idx,
-                                                         const DexFile* dex_file,
                                                          Handle<mirror::DexCache> dex_cache,
-                                                         Handle<mirror::ClassLoader> class_loader,
                                                          const dex::ClassDef& class_def,
                                                          const dex::CodeItem* code_item,
                                                          uint32_t method_access_flags,
@@ -5053,20 +5295,16 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
   uint64_t start_ns = kTimeVerifyMethod ? NanoTime() : 0;
 
   impl::MethodVerifier<kVerifierDebug> verifier(self,
-                                                class_linker,
                                                 arena_pool,
+                                                reg_types,
                                                 verifier_deps,
-                                                dex_file,
                                                 code_item,
                                                 method_idx,
-                                                /* can_load_classes= */ true,
-                                                /* allow_thread_suspension= */ true,
                                                 aot_mode,
                                                 dex_cache,
-                                                class_loader,
                                                 class_def,
                                                 method_access_flags,
-                                                /* verify to dump */ false,
+                                                /* verify_to_dump= */ false,
                                                 api_level);
   if (verifier.Verify()) {
     // Verification completed, however failures may be pending that didn't cause the verification
@@ -5075,11 +5313,12 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
 
     if (verifier.failures_.size() != 0) {
       if (VLOG_IS_ON(verifier)) {
-        verifier.DumpFailures(VLOG_STREAM(verifier) << "Soft verification failures in "
-                                                    << dex_file->PrettyMethod(method_idx) << "\n");
+        verifier.DumpFailures(VLOG_STREAM(verifier)
+            << "Soft verification failures in "
+            << reg_types->GetDexFile()->PrettyMethod(method_idx) << "\n");
       }
       if (kVerifierDebug) {
-        LOG(INFO) << verifier.info_messages_.str();
+        LOG(INFO) << verifier.InfoMessages().str();
         verifier.Dump(LOG_STREAM(INFO));
       }
       if (CanRuntimeHandleVerificationFailure(verifier.encountered_failure_types_)) {
@@ -5115,9 +5354,9 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
           LOG(FATAL) << "Unsupported log-level " << static_cast<uint32_t>(log_level);
           UNREACHABLE();
       }
-      verifier.DumpFailures(LOG_STREAM(severity) << "Verification error in "
-                                                 << dex_file->PrettyMethod(method_idx)
-                                                 << "\n");
+      verifier.DumpFailures(LOG_STREAM(severity)
+          << "Verification error in "
+          << reg_types->GetDexFile()->PrettyMethod(method_idx) << "\n");
     }
     if (hard_failure_msg != nullptr) {
       CHECK(!verifier.failure_messages_.empty());
@@ -5127,13 +5366,13 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
     result.kind = FailureKind::kHardFailure;
 
     if (kVerifierDebug || VLOG_IS_ON(verifier)) {
-      LOG(ERROR) << verifier.info_messages_.str();
+      LOG(ERROR) << verifier.InfoMessages().str();
       verifier.Dump(LOG_STREAM(ERROR));
     }
     // Under verifier-debug, dump the complete log into the error message.
     if (kVerifierDebug && hard_failure_msg != nullptr) {
       hard_failure_msg->append("\n");
-      hard_failure_msg->append(verifier.info_messages_.str());
+      hard_failure_msg->append(verifier.InfoMessages().str());
       hard_failure_msg->append("\n");
       std::ostringstream oss;
       verifier.Dump(oss);
@@ -5145,12 +5384,11 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
     if (duration_ns > MsToNs(Runtime::Current()->GetVerifierLoggingThresholdMs())) {
       double bytecodes_per_second =
           verifier.code_item_accessor_.InsnsSizeInCodeUnits() / (duration_ns * 1e-9);
-      LOG(WARNING) << "Verification of " << dex_file->PrettyMethod(method_idx)
+      LOG(WARNING) << "Verification of " << reg_types->GetDexFile()->PrettyMethod(method_idx)
                    << " took " << PrettyDuration(duration_ns)
                    << (impl::IsLargeMethod(verifier.CodeItem()) ? " (large method)" : "")
                    << " (" << StringPrintf("%.2f", bytecodes_per_second) << " bytecodes/s)"
-                   << " (" << verifier.allocator_.ApproximatePeakBytes()
-                   << "B approximate peak alloc)";
+                   << " (" << verifier.allocator_.BytesAllocated() << "B arena alloc)";
     }
   }
   result.types = verifier.encountered_failure_types_;
@@ -5159,35 +5397,32 @@ MethodVerifier::FailureData MethodVerifier::VerifyMethod(Thread* self,
 
 MethodVerifier* MethodVerifier::CalculateVerificationInfo(
       Thread* self,
+      RegTypeCache* reg_types,
       ArtMethod* method,
       Handle<mirror::DexCache> dex_cache,
-      Handle<mirror::ClassLoader> class_loader,
       uint32_t dex_pc) {
+  Runtime* runtime = Runtime::Current();
   std::unique_ptr<impl::MethodVerifier<false>> verifier(
       new impl::MethodVerifier<false>(self,
-                                      Runtime::Current()->GetClassLinker(),
-                                      Runtime::Current()->GetArenaPool(),
+                                      runtime->GetArenaPool(),
+                                      reg_types,
                                       /* verifier_deps= */ nullptr,
-                                      method->GetDexFile(),
                                       method->GetCodeItem(),
                                       method->GetDexMethodIndex(),
-                                      /* can_load_classes= */ false,
-                                      /* allow_thread_suspension= */ false,
-                                      Runtime::Current()->IsAotCompiler(),
+                                      runtime->IsAotCompiler(),
                                       dex_cache,
-                                      class_loader,
                                       *method->GetDeclaringClass()->GetClassDef(),
                                       method->GetAccessFlags(),
                                       /* verify_to_dump= */ false,
                                       // Just use the verifier at the current skd-version.
                                       // This might affect what soft-verifier errors are reported.
                                       // Callers can then filter out relevant errors if needed.
-                                      Runtime::Current()->GetTargetSdkVersion()));
+                                      runtime->GetTargetSdkVersion()));
   verifier->interesting_dex_pc_ = dex_pc;
   verifier->Verify();
   if (VLOG_IS_ON(verifier)) {
     verifier->DumpFailures(VLOG_STREAM(verifier));
-    VLOG(verifier) << verifier->info_messages_.str();
+    VLOG(verifier) << verifier->InfoMessages().str();
     verifier->Dump(VLOG_STREAM(verifier));
   }
   if (verifier->flags_.have_pending_hard_failure_) {
@@ -5197,44 +5432,40 @@ MethodVerifier* MethodVerifier::CalculateVerificationInfo(
   }
 }
 
-MethodVerifier* MethodVerifier::VerifyMethodAndDump(Thread* self,
-                                                    VariableIndentationOutputStream* vios,
-                                                    uint32_t dex_method_idx,
-                                                    const DexFile* dex_file,
-                                                    Handle<mirror::DexCache> dex_cache,
-                                                    Handle<mirror::ClassLoader> class_loader,
-                                                    const dex::ClassDef& class_def,
-                                                    const dex::CodeItem* code_item,
-                                                    uint32_t method_access_flags,
-                                                    uint32_t api_level) {
-  impl::MethodVerifier<false>* verifier = new impl::MethodVerifier<false>(
+void MethodVerifier::VerifyMethodAndDump(Thread* self,
+                                         VariableIndentationOutputStream* vios,
+                                         uint32_t dex_method_idx,
+                                         const DexFile* dex_file,
+                                         Handle<mirror::DexCache> dex_cache,
+                                         Handle<mirror::ClassLoader> class_loader,
+                                         const dex::ClassDef& class_def,
+                                         const dex::CodeItem* code_item,
+                                         uint32_t method_access_flags,
+                                         uint32_t api_level) {
+  Runtime* runtime = Runtime::Current();
+  ClassLinker* class_linker = runtime->GetClassLinker();
+  ArenaPool* arena_pool = runtime->GetArenaPool();
+  RegTypeCache reg_types(self, class_linker, arena_pool, class_loader, dex_file);
+  impl::MethodVerifier<false> verifier(
       self,
-      Runtime::Current()->GetClassLinker(),
-      Runtime::Current()->GetArenaPool(),
+      arena_pool,
+      &reg_types,
       /* verifier_deps= */ nullptr,
-      dex_file,
       code_item,
       dex_method_idx,
-      /* can_load_classes= */ true,
-      /* allow_thread_suspension= */ true,
-      Runtime::Current()->IsAotCompiler(),
+      runtime->IsAotCompiler(),
       dex_cache,
-      class_loader,
       class_def,
       method_access_flags,
       /* verify_to_dump= */ true,
       api_level);
-  verifier->Verify();
-  verifier->DumpFailures(vios->Stream());
-  vios->Stream() << verifier->info_messages_.str();
-  // Only dump and return if no hard failures. Otherwise the verifier may be not fully initialized
+  verifier.Verify();
+  verifier.DumpFailures(vios->Stream());
+  vios->Stream() << verifier.InfoMessages().str();
+  // Only dump if no hard failures. Otherwise the verifier may be not fully initialized
   // and querying any info is dangerous/can abort.
-  if (verifier->flags_.have_pending_hard_failure_) {
-    delete verifier;
-    return nullptr;
-  } else {
-    verifier->Dump(vios);
-    return verifier;
+  if (!verifier.flags_.have_pending_hard_failure_) {
+    verifier.Dump(vios);
   }
 }
 
@@ -5243,21 +5474,28 @@ void MethodVerifier::FindLocksAtDexPc(
     uint32_t dex_pc,
     std::vector<MethodVerifier::DexLockInfo>* monitor_enter_dex_pcs,
     uint32_t api_level) {
-  StackHandleScope<2> hs(Thread::Current());
+  Thread* self = Thread::Current();
+  StackHandleScope<2> hs(self);
   Handle<mirror::DexCache> dex_cache(hs.NewHandle(m->GetDexCache()));
   Handle<mirror::ClassLoader> class_loader(hs.NewHandle(m->GetClassLoader()));
-  impl::MethodVerifier<false> verifier(hs.Self(),
-                                       Runtime::Current()->GetClassLinker(),
-                                       Runtime::Current()->GetArenaPool(),
+  Runtime* runtime = Runtime::Current();
+  ClassLinker* class_linker = runtime->GetClassLinker();
+  ArenaPool* arena_pool = runtime->GetArenaPool();
+  RegTypeCache reg_types(self,
+                         class_linker,
+                         arena_pool,
+                         class_loader,
+                         dex_cache->GetDexFile(),
+                         /* can_load_classes= */ false,
+                         /* can_suspend= */ false);
+  impl::MethodVerifier<false> verifier(self,
+                                       arena_pool,
+                                       &reg_types,
                                        /* verifier_deps= */ nullptr,
-                                       m->GetDexFile(),
                                        m->GetCodeItem(),
                                        m->GetDexMethodIndex(),
-                                       /* can_load_classes= */ false,
-                                       /* allow_thread_suspension= */ false,
-                                       Runtime::Current()->IsAotCompiler(),
+                                       runtime->IsAotCompiler(),
                                        dex_cache,
-                                       class_loader,
                                        m->GetClassDef(),
                                        m->GetAccessFlags(),
                                        /* verify_to_dump= */ false,
@@ -5268,30 +5506,23 @@ void MethodVerifier::FindLocksAtDexPc(
 }
 
 MethodVerifier* MethodVerifier::CreateVerifier(Thread* self,
+                                               RegTypeCache* reg_types,
                                                VerifierDeps* verifier_deps,
-                                               const DexFile* dex_file,
                                                Handle<mirror::DexCache> dex_cache,
-                                               Handle<mirror::ClassLoader> class_loader,
                                                const dex::ClassDef& class_def,
                                                const dex::CodeItem* code_item,
                                                uint32_t method_idx,
                                                uint32_t access_flags,
-                                               bool can_load_classes,
                                                bool verify_to_dump,
-                                               bool allow_thread_suspension,
                                                uint32_t api_level) {
   return new impl::MethodVerifier<false>(self,
-                                         Runtime::Current()->GetClassLinker(),
                                          Runtime::Current()->GetArenaPool(),
+                                         reg_types,
                                          verifier_deps,
-                                         dex_file,
                                          code_item,
                                          method_idx,
-                                         can_load_classes,
-                                         allow_thread_suspension,
                                          Runtime::Current()->IsAotCompiler(),
                                          dex_cache,
-                                         class_loader,
                                          class_def,
                                          access_flags,
                                          verify_to_dump,
@@ -5307,6 +5538,7 @@ std::ostream& MethodVerifier::Fail(VerifyError error, bool pending_exc) {
       case VERIFY_ERROR_NO_CLASS:
       case VERIFY_ERROR_UNRESOLVED_TYPE_CHECK:
       case VERIFY_ERROR_NO_METHOD:
+      case VERIFY_ERROR_NO_FIELD:
       case VERIFY_ERROR_ACCESS_CLASS:
       case VERIFY_ERROR_ACCESS_FIELD:
       case VERIFY_ERROR_ACCESS_METHOD:
@@ -5345,7 +5577,7 @@ std::ostream& MethodVerifier::Fail(VerifyError error, bool pending_exc) {
 }
 
 ScopedNewLine MethodVerifier::LogVerifyInfo() {
-  ScopedNewLine ret{info_messages_};
+  ScopedNewLine ret{InfoMessages()};
   ret << "VFY: " << dex_file_->PrettyMethod(dex_method_idx_)
       << '[' << reinterpret_cast<void*>(work_insn_idx_) << "] : ";
   return ret;
@@ -5363,5 +5595,98 @@ void MethodVerifier::FailureData::Merge(const MethodVerifier::FailureData& fd) {
   types |= fd.types;
 }
 
+const RegType& MethodVerifier::GetInvocationThis(const Instruction* inst) {
+  DCHECK(inst->IsInvoke());
+  const size_t args_count = inst->VRegA();
+  if (args_count < 1) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invoke lacks 'this'";
+    return reg_types_.Conflict();
+  }
+  const uint32_t this_reg = inst->VRegC();
+  const RegType& this_type = work_line_->GetRegisterType(this, this_reg);
+  if (!this_type.IsReferenceTypes()) {
+    Fail(VERIFY_ERROR_BAD_CLASS_HARD)
+        << "tried to get class from non-reference register v" << this_reg
+        << " (type=" << this_type << ")";
+    return reg_types_.Conflict();
+  }
+  return this_type;
+}
+
+bool MethodVerifier::AssignableFrom(const RegType& lhs, const RegType& rhs, bool strict) const {
+  if (lhs.Equals(rhs)) {
+    return true;
+  }
+
+  RegType::Assignability assignable = RegType::AssignabilityFrom(lhs.GetKind(), rhs.GetKind());
+  DCHECK(assignable != RegType::Assignability::kInvalid)
+      << "Unexpected register type in IsAssignableFrom: '" << lhs << "' := '" << rhs << "'";
+  if (assignable == RegType::Assignability::kAssignable) {
+    return true;
+  } else if (assignable == RegType::Assignability::kNotAssignable) {
+    return false;
+  } else if (assignable == RegType::Assignability::kNarrowingConversion) {
+    // FIXME: The `MethodVerifier` is mostly doing a category check and avoiding
+    // assignability checks that would expose narrowing conversions. However, for
+    // the `return` instruction, it explicitly allows certain narrowing conversions
+    // and prohibits others by doing a modified assignability check. Without strict
+    // enforcement in all cases, this can compromise compiler optimizations that
+    // rely on knowing the range of the values. Bug: 270660613
+    return false;
+  } else {
+    DCHECK(assignable == RegType::Assignability::kReference);
+    DCHECK(lhs.IsNonZeroReferenceTypes());
+    DCHECK(rhs.IsNonZeroReferenceTypes());
+    DCHECK(!lhs.IsUninitializedTypes());
+    DCHECK(!rhs.IsUninitializedTypes());
+    DCHECK(!lhs.IsJavaLangObject());
+    if (!strict && !lhs.IsUnresolvedTypes() && lhs.GetClass()->IsInterface()) {
+      // If we're not strict allow assignment to any interface, see comment in ClassJoin.
+      return true;
+    } else if (lhs.IsJavaLangObjectArray()) {
+      return rhs.IsObjectArrayTypes();  // All reference arrays may be assigned to Object[]
+    } else if (lhs.HasClass() && rhs.IsJavaLangObject()) {
+      return false;  // Note: Non-strict check for interface `lhs` is handled above.
+    } else if (lhs.HasClass() && rhs.HasClass()) {
+      // Test assignability from the Class point-of-view.
+      bool result = lhs.GetClass()->IsAssignableFrom(rhs.GetClass());
+      // Record assignability dependency. The `verifier` is null during unit tests and
+      // VerifiedMethod::GenerateSafeCastSet.
+      if (result) {
+        VerifierDeps::MaybeRecordAssignability(GetVerifierDeps(),
+                                               GetDexFile(),
+                                               GetClassDef(),
+                                               lhs.GetClass(),
+                                               rhs.GetClass());
+      }
+      return result;
+    } else {
+      // For unresolved types, we don't know if they are assignable, and the
+      // verifier will continue assuming they are. We need to record that.
+      //
+      // Note that if `rhs` is an interface type, `lhs` may be j.l.Object
+      // and if the assignability check is not strict, then this should be
+      // OK. However we don't encode strictness in the verifier deps, and
+      // such a situation will force a full verification.
+      VerifierDeps::MaybeRecordAssignability(GetVerifierDeps(),
+                                             GetDexFile(),
+                                             GetClassDef(),
+                                             lhs,
+                                             rhs);
+      // Unresolved types are only assignable for null and equality.
+      // Null cannot be the left-hand side.
+      return false;
+    }
+  }
+}
+
+inline bool MethodVerifier::IsAssignableFrom(const RegType& lhs, const RegType& rhs) const {
+  return AssignableFrom(lhs, rhs, false);
+}
+
+inline bool MethodVerifier::IsStrictlyAssignableFrom(const RegType& lhs, const RegType& rhs) const {
+  return AssignableFrom(lhs, rhs, true);
+}
+
 }  // namespace verifier
 }  // namespace art
diff --git a/runtime/verifier/method_verifier.h b/runtime/verifier/method_verifier.h
index ef6fb42785..13631850b7 100644
--- a/runtime/verifier/method_verifier.h
+++ b/runtime/verifier/method_verifier.h
@@ -24,15 +24,14 @@
 #include <android-base/logging.h>
 
 #include "base/arena_allocator.h"
+#include "base/arena_containers.h"
 #include "base/macros.h"
-#include "base/scoped_arena_containers.h"
 #include "base/value_object.h"
 #include "dex/code_item_accessors.h"
 #include "dex/dex_file_types.h"
 #include "dex/method_reference.h"
 #include "handle.h"
 #include "instruction_flags.h"
-#include "reg_type_cache.h"
 #include "register_line.h"
 #include "verifier_enums.h"
 
@@ -51,15 +50,15 @@ struct CodeItem;
 }  // namespace dex
 
 namespace mirror {
+class ClassLoader;
 class DexCache;
 }  // namespace mirror
 
 namespace verifier {
 
 class MethodVerifier;
-class RegisterLine;
-using RegisterLineArenaUniquePtr = std::unique_ptr<RegisterLine, RegisterLineArenaDelete>;
 class RegType;
+class RegTypeCache;
 struct ScopedNewLine;
 class VerifierDeps;
 
@@ -67,7 +66,7 @@ class VerifierDeps;
 // execution of that instruction.
 class PcToRegisterLineTable {
  public:
-  explicit PcToRegisterLineTable(ScopedArenaAllocator& allocator);
+  explicit PcToRegisterLineTable(ArenaAllocator& allocator);
   ~PcToRegisterLineTable();
 
   // Initialize the RegisterTable. Every instruction address can have a different set of information
@@ -76,7 +75,7 @@ class PcToRegisterLineTable {
   void Init(InstructionFlags* flags,
             uint32_t insns_size,
             uint16_t registers_size,
-            ScopedArenaAllocator& allocator,
+            ArenaAllocator& allocator,
             RegTypeCache* reg_types,
             uint32_t interesting_dex_pc);
 
@@ -89,7 +88,7 @@ class PcToRegisterLineTable {
   }
 
  private:
-  ScopedArenaVector<RegisterLineArenaUniquePtr> register_lines_;
+  ArenaVector<RegisterLineArenaUniquePtr> register_lines_;
 
   DISALLOW_COPY_AND_ASSIGN(PcToRegisterLineTable);
 };
@@ -97,24 +96,24 @@ class PcToRegisterLineTable {
 // The verifier
 class MethodVerifier {
  public:
-  EXPORT static MethodVerifier* VerifyMethodAndDump(Thread* self,
-                                                    VariableIndentationOutputStream* vios,
-                                                    uint32_t method_idx,
-                                                    const DexFile* dex_file,
-                                                    Handle<mirror::DexCache> dex_cache,
-                                                    Handle<mirror::ClassLoader> class_loader,
-                                                    const dex::ClassDef& class_def,
-                                                    const dex::CodeItem* code_item,
-                                                    uint32_t method_access_flags,
-                                                    uint32_t api_level)
+  EXPORT static void VerifyMethodAndDump(Thread* self,
+                                         VariableIndentationOutputStream* vios,
+                                         uint32_t method_idx,
+                                         const DexFile* dex_file,
+                                         Handle<mirror::DexCache> dex_cache,
+                                         Handle<mirror::ClassLoader> class_loader,
+                                         const dex::ClassDef& class_def,
+                                         const dex::CodeItem* code_item,
+                                         uint32_t method_access_flags,
+                                         uint32_t api_level)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Calculates the type information at the given `dex_pc`.
   // No classes will be loaded.
   EXPORT static MethodVerifier* CalculateVerificationInfo(Thread* self,
+                                                          RegTypeCache* reg_types,
                                                           ArtMethod* method,
                                                           Handle<mirror::DexCache> dex_cache,
-                                                          Handle<mirror::ClassLoader> class_loader,
                                                           uint32_t dex_pc)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -171,16 +170,11 @@ class MethodVerifier {
     return (encountered_failure_types_ & VERIFY_ERROR_RUNTIME_THROW) != 0;
   }
 
-  virtual const RegType& ResolveCheckedClass(dex::TypeIndex class_idx)
-      REQUIRES_SHARED(Locks::mutator_lock_) = 0;
-
   uint32_t GetEncounteredFailureTypes() const {
     return encountered_failure_types_;
   }
 
-  ClassLinker* GetClassLinker() const {
-    return reg_types_.GetClassLinker();
-  }
+  ClassLinker* GetClassLinker() const;
 
   bool IsAotMode() const {
     return const_flags_.aot_mode_;
@@ -196,15 +190,12 @@ class MethodVerifier {
 
  protected:
   MethodVerifier(Thread* self,
-                 ClassLinker* class_linker,
                  ArenaPool* arena_pool,
+                 RegTypeCache* reg_types,
                  VerifierDeps* verifier_deps,
-                 const DexFile* dex_file,
                  const dex::ClassDef& class_def,
                  const dex::CodeItem* code_item,
                  uint32_t dex_method_idx,
-                 bool can_load_classes,
-                 bool allow_thread_suspension,
                  bool aot_mode)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -230,13 +221,11 @@ class MethodVerifier {
    *      for code flow problems.
    */
   static FailureData VerifyMethod(Thread* self,
-                                  ClassLinker* class_linker,
                                   ArenaPool* arena_pool,
+                                  RegTypeCache* reg_types,
                                   VerifierDeps* verifier_deps,
                                   uint32_t method_idx,
-                                  const DexFile* dex_file,
                                   Handle<mirror::DexCache> dex_cache,
-                                  Handle<mirror::ClassLoader> class_loader,
                                   const dex::ClassDef& class_def_idx,
                                   const dex::CodeItem* code_item,
                                   uint32_t method_access_flags,
@@ -248,13 +237,11 @@ class MethodVerifier {
 
   template <bool kVerifierDebug>
   static FailureData VerifyMethod(Thread* self,
-                                  ClassLinker* class_linker,
                                   ArenaPool* arena_pool,
+                                  RegTypeCache* reg_types,
                                   VerifierDeps* verifier_deps,
                                   uint32_t method_idx,
-                                  const DexFile* dex_file,
                                   Handle<mirror::DexCache> dex_cache,
-                                  Handle<mirror::ClassLoader> class_loader,
                                   const dex::ClassDef& class_def_idx,
                                   const dex::CodeItem* code_item,
                                   uint32_t method_access_flags,
@@ -264,36 +251,64 @@ class MethodVerifier {
                                   std::string* hard_failure_msg)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
+  /*
+   * Get the "this" pointer from a non-static method invocation. This returns the RegType so the
+   * caller can decide whether it needs the reference to be initialized or not.
+   *
+   * The argument count is in vA, and the first argument is in vC, for both "simple" and "range"
+   * versions. We just need to make sure vA is >= 1 and then return vC.
+   */
+  const RegType& GetInvocationThis(const Instruction* inst)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  // Can a variable with type `lhs` be assigned a value with type `rhs`?
+  // Note: Object and interface types may always be assigned to one another, see
+  // comment on `ClassJoin()`.
+  bool IsAssignableFrom(const RegType& lhs, const RegType& rhs) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  // Can a variable with type `lhs` be assigned a value with type `rhs`?
+  // Variant of IsAssignableFrom that doesn't allow assignment to an interface from an Object.
+  bool IsStrictlyAssignableFrom(const RegType& lhs, const RegType& rhs) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  // Implementation helper for `IsAssignableFrom()` and `IsStrictlyAssignableFrom()`.
+  bool AssignableFrom(const RegType& lhs, const RegType& rhs, bool strict) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   // For VerifierDepsTest. TODO: Refactor.
 
   // Run verification on the method. Returns true if verification completes and false if the input
   // has an irrecoverable corruption.
   virtual bool Verify() REQUIRES_SHARED(Locks::mutator_lock_) = 0;
   static MethodVerifier* CreateVerifier(Thread* self,
+                                        RegTypeCache* reg_types,
                                         VerifierDeps* verifier_deps,
-                                        const DexFile* dex_file,
                                         Handle<mirror::DexCache> dex_cache,
-                                        Handle<mirror::ClassLoader> class_loader,
                                         const dex::ClassDef& class_def,
                                         const dex::CodeItem* code_item,
                                         uint32_t method_idx,
                                         uint32_t access_flags,
-                                        bool can_load_classes,
                                         bool verify_to_dump,
-                                        bool allow_thread_suspension,
                                         uint32_t api_level)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   virtual bool PotentiallyMarkRuntimeThrow() = 0;
 
+  std::ostringstream& InfoMessages() {
+    if (!info_messages_.has_value()) {
+      info_messages_.emplace();
+    }
+    return info_messages_.value();
+  }
+
   // The thread we're verifying on.
   Thread* const self_;
 
   // Arena allocator.
-  ArenaStack arena_stack_;
-  ScopedArenaAllocator allocator_;
+  ArenaAllocator allocator_;
 
-  RegTypeCache reg_types_;
+  RegTypeCache& reg_types_;  // TODO: Change to a pointer in a separate CL.
 
   PcToRegisterLineTable reg_table_;
 
@@ -345,7 +360,7 @@ class MethodVerifier {
   uint32_t encountered_failure_types_;
 
   // Info message log use primarily for verifier diagnostics.
-  std::ostringstream info_messages_;
+  std::optional<std::ostringstream> info_messages_;
 
   // The verifier deps object we are going to report type assigability
   // constraints to. Can be null for runtime verification.
@@ -356,6 +371,7 @@ class MethodVerifier {
 
   friend class art::Thread;
   friend class ClassVerifier;
+  friend class RegisterLineTest;
   friend class VerifierDepsTest;
 
   DISALLOW_COPY_AND_ASSIGN(MethodVerifier);
diff --git a/runtime/verifier/reg_type-inl.h b/runtime/verifier/reg_type-inl.h
index c5311e6e62..770989c654 100644
--- a/runtime/verifier/reg_type-inl.h
+++ b/runtime/verifier/reg_type-inl.h
@@ -19,8 +19,8 @@
 
 #include "reg_type.h"
 
+#include "base/arena_allocator.h"
 #include "base/casts.h"
-#include "base/scoped_arena_allocator.h"
 #include "method_verifier.h"
 #include "mirror/class.h"
 #include "verifier_deps.h"
@@ -28,137 +28,101 @@
 namespace art HIDDEN {
 namespace verifier {
 
-inline bool RegType::CanAccess(const RegType& other) const {
-  DCHECK(IsReferenceTypes());
-  DCHECK(!IsNull());
-  if (Equals(other)) {
-    return true;  // Trivial accessibility.
-  } else {
-    bool this_unresolved = IsUnresolvedTypes();
-    bool other_unresolved = other.IsUnresolvedTypes();
-    if (!this_unresolved && !other_unresolved) {
-      return GetClass()->CanAccess(other.GetClass());
-    } else if (!other_unresolved) {
-      return other.GetClass()->IsPublic();  // Be conservative, only allow if other is public.
-    } else {
-      return false;  // More complicated test not possible on unresolved types, be conservative.
-    }
-  }
+inline ObjPtr<mirror::Class> RegType::GetClass() const {
+  DCHECK(IsReference()) << Dump();
+  return down_cast<const ReferenceType&>(*this).GetClassImpl();
 }
 
-inline bool RegType::CanAccessMember(ObjPtr<mirror::Class> klass, uint32_t access_flags) const {
-  DCHECK(IsReferenceTypes());
-  if (IsNull()) {
-    return true;
-  }
-  if (!IsUnresolvedTypes()) {
-    return GetClass()->CanAccessMember(klass, access_flags);
-  } else {
-    return false;  // More complicated test not possible on unresolved types, be conservative.
-  }
+inline Handle<mirror::Class> RegType::GetClassHandle() const {
+  DCHECK(IsReference()) << Dump();
+  return down_cast<const ReferenceType&>(*this).GetClassHandleImpl();
 }
 
-inline bool RegType::IsConstantBoolean() const {
-  if (!IsConstant()) {
-    return false;
-  } else {
-    const ConstantType* const_val = down_cast<const ConstantType*>(this);
-    return const_val->ConstantValue() >= 0 && const_val->ConstantValue() <= 1;
-  }
-}
+namespace detail {
 
-inline bool RegType::AssignableFrom(const RegType& lhs,
-                                    const RegType& rhs,
-                                    bool strict,
-                                    MethodVerifier* verifier) {
-  if (lhs.Equals(rhs)) {
-    return true;
-  } else {
-    switch (lhs.GetAssignmentType()) {
-      case AssignmentType::kBoolean:
-        return rhs.IsBooleanTypes();
-      case AssignmentType::kByte:
-        return rhs.IsByteTypes();
-      case AssignmentType::kShort:
-        return rhs.IsShortTypes();
-      case AssignmentType::kChar:
-        return rhs.IsCharTypes();
-      case AssignmentType::kInteger:
-        return rhs.IsIntegralTypes();
-      case AssignmentType::kFloat:
-        return rhs.IsFloatTypes();
-      case AssignmentType::kLongLo:
-        return rhs.IsLongTypes();
-      case AssignmentType::kDoubleLo:
-        return rhs.IsDoubleTypes();
-      case AssignmentType::kConflict:
-        LOG(WARNING) << "RegType::AssignableFrom lhs is Conflict!";
-        return false;
-      case AssignmentType::kReference:
-        if (rhs.IsZeroOrNull()) {
-          return true;  // All reference types can be assigned null.
-        } else if (!rhs.IsReferenceTypes()) {
-          return false;  // Expect rhs to be a reference type.
-        } else if (lhs.IsUninitializedTypes() || rhs.IsUninitializedTypes()) {
-          // Uninitialized types are only allowed to be assigned to themselves.
-          // TODO: Once we have a proper "reference" super type, this needs to be extended.
-          return false;
-        } else if (lhs.IsJavaLangObject()) {
-          return true;  // All reference types can be assigned to Object.
-        } else if (!strict && !lhs.IsUnresolvedTypes() && lhs.GetClass()->IsInterface()) {
-          // If we're not strict allow assignment to any interface, see comment in ClassJoin.
-          return true;
-        } else if (lhs.IsJavaLangObjectArray()) {
-          return rhs.IsObjectArrayTypes();  // All reference arrays may be assigned to Object[]
-        } else if (lhs.HasClass() && rhs.HasClass()) {
-          // Test assignability from the Class point-of-view.
-          bool result = lhs.GetClass()->IsAssignableFrom(rhs.GetClass());
-          // Record assignability dependency. The `verifier` is null during unit tests and
-          // VerifiedMethod::GenerateSafeCastSet.
-          if (verifier != nullptr && result) {
-            VerifierDeps::MaybeRecordAssignability(verifier->GetVerifierDeps(),
-                                                   verifier->GetDexFile(),
-                                                   verifier->GetClassDef(),
-                                                   lhs.GetClass(),
-                                                   rhs.GetClass());
-          }
-          return result;
-        } else {
-          // For unresolved types, we don't know if they are assignable, and the
-          // verifier will continue assuming they are. We need to record that.
-          if (verifier != nullptr) {
-            // Note that if `rhs` is an interface type, `lhs` may be j.l.Object
-            // and if the assignability check is not strict, then this should be
-            // OK. However we don't encode strictness in the verifier deps, and
-            // such a situation will force a full verification.
-            VerifierDeps::MaybeRecordAssignability(verifier->GetVerifierDeps(),
-                                                   verifier->GetDexFile(),
-                                                   verifier->GetClassDef(),
-                                                   lhs,
-                                                   rhs);
-          }
-          // Unresolved types are only assignable for null and equality.
-          // Null cannot be the left-hand side.
-          return false;
-        }
-      case AssignmentType::kNotAssignable:
-        break;
+class RegTypeAssignabilityImpl final : RegType {
+ public:
+  explicit constexpr RegTypeAssignabilityImpl(RegType::Kind kind)
+      : RegType("", /* unused cache id */ 0, kind) {}
+
+  static constexpr Assignability AssignabilityFrom(RegType::Kind lhs_kind, RegType::Kind rhs_kind);
+};
+
+constexpr RegType::Assignability RegTypeAssignabilityImpl::AssignabilityFrom(
+    RegType::Kind lhs_kind, RegType::Kind rhs_kind) {
+  RegTypeAssignabilityImpl lhs(lhs_kind);
+  RegTypeAssignabilityImpl rhs(rhs_kind);
+  auto maybe_narrowing_conversion = [&rhs]() constexpr {
+    return rhs.IsIntegralTypes() ? Assignability::kNarrowingConversion
+                                 : Assignability::kNotAssignable;
+  };
+  if (lhs.IsBoolean()) {
+    return rhs.IsBooleanTypes() ? Assignability::kAssignable : maybe_narrowing_conversion();
+  } else if (lhs.IsByte()) {
+    return rhs.IsByteTypes() ? Assignability::kAssignable : maybe_narrowing_conversion();
+  } else if (lhs.IsShort()) {
+    return rhs.IsShortTypes() ? Assignability::kAssignable : maybe_narrowing_conversion();
+  } else if (lhs.IsChar()) {
+    return rhs.IsCharTypes() ? Assignability::kAssignable : maybe_narrowing_conversion();
+  } else if (lhs.IsInteger()) {
+    return rhs.IsIntegralTypes() ? Assignability::kAssignable : Assignability::kNotAssignable;
+  } else if (lhs.IsFloat()) {
+    return rhs.IsFloatTypes() ? Assignability::kAssignable : Assignability::kNotAssignable;
+  } else if (lhs.IsLongLo()) {
+    return rhs.IsLongTypes() ? Assignability::kAssignable : Assignability::kNotAssignable;
+  } else if (lhs.IsDoubleLo()) {
+    return rhs.IsDoubleTypes() ? Assignability::kAssignable : Assignability::kNotAssignable;
+  } else if (lhs.IsConflict()) {
+    // TODO: The `MethodVerifier` is doing a `lhs` category check for `return{,-wide,-object}`
+    // before the assignability check, so a `Conflict` (`void`) is not a valid `lhs`. We could
+    // speed up the verification by removing the category check and relying on the assignability
+    // check. Then we would need to return `NotAssignable` here as the result would be used
+    // if a value is returned from a `void` method.
+    return Assignability::kInvalid;
+  } else if (lhs.IsUninitializedTypes() || lhs.IsUnresolvedMergedReference()) {
+    // These reference kinds are not valid `lhs`.
+    return Assignability::kInvalid;
+  } else if (lhs.IsNonZeroReferenceTypes()) {
+    if (rhs.IsZeroOrNull()) {
+      return Assignability::kAssignable;  // All reference types can be assigned null.
+    } else if (!rhs.IsNonZeroReferenceTypes()) {
+      return Assignability::kNotAssignable;  // Expect rhs to be a reference type.
+    } else if (rhs.IsUninitializedTypes()) {
+      // References of uninitialized types can be copied but not assigned.
+      return Assignability::kNotAssignable;
+    } else if (lhs.IsJavaLangObject()) {
+      return Assignability::kAssignable;  // All reference types can be assigned to Object.
+    } else {
+      // Use `Reference` to tell the caller to process a reference assignability check.
+      // This check requires more information than the kinds available here.
+      return Assignability::kReference;
     }
-    LOG(FATAL) << "Unexpected register type in IsAssignableFrom: '"
-               << lhs << "' := '" << rhs << "'";
-    UNREACHABLE();
+  } else {
+    DCHECK(lhs.IsUndefined() || lhs.IsHighHalf() || lhs.IsConstantTypes());
+    return Assignability::kInvalid;
   }
 }
 
-inline bool RegType::IsAssignableFrom(const RegType& src, MethodVerifier* verifier) const {
-  return AssignableFrom(*this, src, false, verifier);
-}
+}  // namespace detail
+
+inline RegType::Assignability RegType::AssignabilityFrom(Kind lhs, Kind rhs) {
+  static constexpr size_t kNumKinds = NumberOfKinds();
+  using AssignabilityTable = std::array<std::array<Assignability, kNumKinds>, kNumKinds>;
+  static constexpr AssignabilityTable kAssignabilityTable = []() constexpr {
+    AssignabilityTable result;
+    for (size_t lhs = 0u; lhs != kNumKinds; ++lhs) {
+      for (size_t rhs = 0u; rhs != kNumKinds; ++rhs) {
+        result[lhs][rhs] = detail::RegTypeAssignabilityImpl::AssignabilityFrom(
+            enum_cast<RegType::Kind>(lhs), enum_cast<RegType::Kind>(rhs));
+      }
+    }
+    return result;
+  }();
 
-inline bool RegType::IsStrictlyAssignableFrom(const RegType& src, MethodVerifier* verifier) const {
-  return AssignableFrom(*this, src, true, verifier);
+  return kAssignabilityTable[lhs][rhs];
 }
 
-inline void* RegType::operator new(size_t size, ScopedArenaAllocator* allocator) {
+inline void* RegType::operator new(size_t size, ArenaAllocator* allocator) {
   return allocator->Alloc(size, kArenaAllocMisc);
 }
 
diff --git a/runtime/verifier/reg_type.cc b/runtime/verifier/reg_type.cc
index 845bcdc087..a2b52f4f87 100644
--- a/runtime/verifier/reg_type.cc
+++ b/runtime/verifier/reg_type.cc
@@ -40,102 +40,102 @@ namespace verifier {
 
 using android::base::StringPrintf;
 
-PrimitiveType::PrimitiveType(Handle<mirror::Class> klass,
-                             const std::string_view& descriptor,
-                             uint16_t cache_id)
-    : RegType(klass, descriptor, cache_id) {
-  CHECK(klass != nullptr);
-  CHECK(!descriptor.empty());
-}
-
-Cat1Type::Cat1Type(Handle<mirror::Class> klass,
-                   const std::string_view& descriptor,
-                   uint16_t cache_id)
-    : PrimitiveType(klass, descriptor, cache_id) {
-}
-
-Cat2Type::Cat2Type(Handle<mirror::Class> klass,
-                   const std::string_view& descriptor,
-                   uint16_t cache_id)
-    : PrimitiveType(klass, descriptor, cache_id) {
-}
-
-std::string PreciseConstType::Dump() const {
-  std::stringstream result;
-  uint32_t val = ConstantValue();
-  if (val == 0) {
-    CHECK(IsPreciseConstant());
-    result << "Zero/null";
-  } else {
-    result << "Precise ";
-    if (IsConstantShort()) {
-      result << StringPrintf("Constant: %d", val);
-    } else {
-      result << StringPrintf("Constant: 0x%x", val);
-    }
+std::ostream& operator<<(std::ostream& os, RegType::Kind kind) {
+  const char* kind_name;
+  switch (kind) {
+#define DEFINE_REG_TYPE_CASE(name) \
+    case RegType::Kind::k##name:   \
+      kind_name = #name;           \
+      break;
+    FOR_EACH_CONCRETE_REG_TYPE(DEFINE_REG_TYPE_CASE)
+#undef DEFINE_REG_TYPE_CASE
+    default:
+      return os << "Corrupted RegType::Kind: " << static_cast<uint32_t>(kind);
   }
-  return result.str();
-}
-
-std::string BooleanType::Dump() const {
-  return "Boolean";
-}
-
-std::string ConflictType::Dump() const {
-    return "Conflict";
-}
-
-std::string ByteType::Dump() const {
-  return "Byte";
-}
-
-std::string ShortType::Dump() const {
-  return "Short";
-}
-
-std::string CharType::Dump() const {
-  return "Char";
-}
-
-std::string FloatType::Dump() const {
-  return "Float";
-}
-
-std::string LongLoType::Dump() const {
-  return "Long (Low Half)";
-}
-
-std::string LongHiType::Dump() const {
-  return "Long (High Half)";
-}
-
-std::string DoubleLoType::Dump() const {
-  return "Double (Low Half)";
-}
-
-std::string DoubleHiType::Dump() const {
-  return "Double (High Half)";
-}
-
-std::string IntegerType::Dump() const {
-  return "Integer";
-}
-
-std::string UndefinedType::Dump() const REQUIRES_SHARED(Locks::mutator_lock_) {
-  return "Undefined";
-}
-
-PreciseReferenceType::PreciseReferenceType(Handle<mirror::Class> klass,
-                                           const std::string_view& descriptor,
-                                           uint16_t cache_id)
-    : RegType(klass, descriptor, cache_id) {
-  // Note: no check for IsInstantiable() here. We may produce this in case an InstantiationError
-  //       would be thrown at runtime, but we need to continue verification and *not* create a
-  //       hard failure or abort.
-  CheckConstructorInvariants(this);
+  return os << kind_name;
+}
+
+std::ostream& operator<<(std::ostream& os, RegType::Assignability assignability) {
+  const char* assignability_name;
+  switch (assignability) {
+    case RegType::Assignability::kAssignable:
+      assignability_name = "Assignable";
+      break;
+    case RegType::Assignability::kNotAssignable:
+      assignability_name = "NotAssignable";
+      break;
+    case RegType::Assignability::kNarrowingConversion:
+      assignability_name = "NarrowingConversion";
+      break;
+    case RegType::Assignability::kReference:
+      assignability_name = "Reference";
+      break;
+    case RegType::Assignability::kInvalid:
+      assignability_name = "Invalid";
+      break;
+    default:
+      return os << "Corrupted RegType::Assignability: " << static_cast<uint32_t>(assignability);
+  }
+  return os << assignability_name;
+}
+
+std::string RegType::Dump() const {
+  std::string_view reference_tag;
+  switch (GetKind()) {
+    case Kind::kUndefined: return "Undefined";
+    case Kind::kConflict: return "Conflict";
+    case Kind::kBoolean: return "Boolean";
+    case Kind::kByte: return "Byte";
+    case Kind::kShort: return "Short";
+    case Kind::kChar: return "Char";
+    case Kind::kInteger: return "Integer";
+    case Kind::kLongLo: return "Long (Low Half)";
+    case Kind::kLongHi: return "Long (High Half)";
+    case Kind::kFloat: return "Float";
+    case Kind::kDoubleLo: return "Double (Low Half)";
+    case Kind::kDoubleHi: return "Double (High Half)";
+    case Kind::kZero: return "Zero/null";
+    case Kind::kBooleanConstant: return "BooleanConstant";
+    case Kind::kPositiveByteConstant: return "PositiveByteConstant";
+    case Kind::kPositiveShortConstant: return "PositiveShortConstant";
+    case Kind::kCharConstant: return "CharConstant";
+    case Kind::kByteConstant: return "ByteConstant";
+    case Kind::kShortConstant: return "ShortConstant";
+    case Kind::kIntegerConstant: return "IntegerConstant";
+    case Kind::kConstantLo: return "Low-half Constant";
+    case Kind::kConstantHi: return "High-half Constant";
+    case Kind::kNull: return "null";
+    case Kind::kJavaLangObject: return "Reference java.lang.Object";
+
+    case Kind::kUnresolvedReference:
+      reference_tag = "Unresolved Reference: ";
+      break;
+    case Kind::kUninitializedReference:
+      reference_tag = "Uninitialized Reference: ";
+      break;
+    case Kind::kUninitializedThisReference:
+      reference_tag = "Uninitialized This Reference: ";
+      break;
+    case Kind::kUnresolvedUninitializedReference:
+      reference_tag = "Unresolved And Uninitialized Reference: ";
+      break;
+    case Kind::kUnresolvedUninitializedThisReference:
+      reference_tag = "Unresolved And Uninitialized This Reference: ";
+      break;
+    case Kind::kReference:
+      reference_tag = "Reference: ";
+      break;
+
+    case Kind::kUnresolvedMergedReference:
+      return down_cast<const UnresolvedMergedReferenceType&>(*this).DumpImpl();
+  }
+  DCHECK(!reference_tag.empty());
+  std::string result(reference_tag);
+  AppendPrettyDescriptor(std::string(GetDescriptor()).c_str(), &result);
+  return result;
 }
 
-std::string UnresolvedMergedType::Dump() const {
+std::string UnresolvedMergedReferenceType::DumpImpl() const {
   std::stringstream result;
   result << "UnresolvedMergedReferences(" << GetResolvedPart().Dump() << " | ";
   const BitVector& types = GetUnresolvedTypes();
@@ -153,129 +153,6 @@ std::string UnresolvedMergedType::Dump() const {
   return result.str();
 }
 
-std::string UnresolvedSuperClass::Dump() const {
-  std::stringstream result;
-  uint16_t super_type_id = GetUnresolvedSuperClassChildId();
-  result << "UnresolvedSuperClass(" << reg_type_cache_->GetFromId(super_type_id).Dump() << ")";
-  return result.str();
-}
-
-std::string UnresolvedReferenceType::Dump() const {
-  std::stringstream result;
-  result << "Unresolved Reference: " << PrettyDescriptor(std::string(GetDescriptor()).c_str());
-  return result.str();
-}
-
-std::string UnresolvedUninitializedRefType::Dump() const {
-  std::stringstream result;
-  result << "Unresolved And Uninitialized Reference: "
-      << PrettyDescriptor(std::string(GetDescriptor()).c_str())
-      << " Allocation PC: " << GetAllocationPc();
-  return result.str();
-}
-
-std::string UnresolvedUninitializedThisRefType::Dump() const {
-  std::stringstream result;
-  result << "Unresolved And Uninitialized This Reference: "
-      << PrettyDescriptor(std::string(GetDescriptor()).c_str());
-  return result.str();
-}
-
-std::string ReferenceType::Dump() const {
-  std::stringstream result;
-  result << "Reference: " << mirror::Class::PrettyDescriptor(GetClass());
-  return result.str();
-}
-
-std::string PreciseReferenceType::Dump() const {
-  std::stringstream result;
-  result << "Precise Reference: " << mirror::Class::PrettyDescriptor(GetClass());
-  return result.str();
-}
-
-std::string UninitializedReferenceType::Dump() const {
-  std::stringstream result;
-  result << "Uninitialized Reference: " << mirror::Class::PrettyDescriptor(GetClass());
-  result << " Allocation PC: " << GetAllocationPc();
-  return result.str();
-}
-
-std::string UninitializedThisReferenceType::Dump() const {
-  std::stringstream result;
-  result << "Uninitialized This Reference: " << mirror::Class::PrettyDescriptor(GetClass());
-  result << "Allocation PC: " << GetAllocationPc();
-  return result.str();
-}
-
-std::string ImpreciseConstType::Dump() const {
-  std::stringstream result;
-  uint32_t val = ConstantValue();
-  if (val == 0) {
-    result << "Zero/null";
-  } else {
-    result << "Imprecise ";
-    if (IsConstantShort()) {
-      result << StringPrintf("Constant: %d", val);
-    } else {
-      result << StringPrintf("Constant: 0x%x", val);
-    }
-  }
-  return result.str();
-}
-std::string PreciseConstLoType::Dump() const {
-  std::stringstream result;
-
-  int32_t val = ConstantValueLo();
-  result << "Precise ";
-  if (val >= std::numeric_limits<jshort>::min() &&
-      val <= std::numeric_limits<jshort>::max()) {
-    result << StringPrintf("Low-half Constant: %d", val);
-  } else {
-    result << StringPrintf("Low-half Constant: 0x%x", val);
-  }
-  return result.str();
-}
-
-std::string ImpreciseConstLoType::Dump() const {
-  std::stringstream result;
-
-  int32_t val = ConstantValueLo();
-  result << "Imprecise ";
-  if (val >= std::numeric_limits<jshort>::min() &&
-      val <= std::numeric_limits<jshort>::max()) {
-    result << StringPrintf("Low-half Constant: %d", val);
-  } else {
-    result << StringPrintf("Low-half Constant: 0x%x", val);
-  }
-  return result.str();
-}
-
-std::string PreciseConstHiType::Dump() const {
-  std::stringstream result;
-  int32_t val = ConstantValueHi();
-  result << "Precise ";
-  if (val >= std::numeric_limits<jshort>::min() &&
-      val <= std::numeric_limits<jshort>::max()) {
-    result << StringPrintf("High-half Constant: %d", val);
-  } else {
-    result << StringPrintf("High-half Constant: 0x%x", val);
-  }
-  return result.str();
-}
-
-std::string ImpreciseConstHiType::Dump() const {
-  std::stringstream result;
-  int32_t val = ConstantValueHi();
-  result << "Imprecise ";
-  if (val >= std::numeric_limits<jshort>::min() &&
-      val <= std::numeric_limits<jshort>::max()) {
-    result << StringPrintf("High-half Constant: %d", val);
-  } else {
-    result << StringPrintf("High-half Constant: 0x%x", val);
-  }
-  return result.str();
-}
-
 const RegType& RegType::HighHalf(RegTypeCache* cache) const {
   DCHECK(IsLowHalf());
   if (IsLongLo()) {
@@ -283,9 +160,8 @@ const RegType& RegType::HighHalf(RegTypeCache* cache) const {
   } else if (IsDoubleLo()) {
     return cache->DoubleHi();
   } else {
-    DCHECK(IsImpreciseConstantLo());
-    const ConstantType* const_val = down_cast<const ConstantType*>(this);
-    return cache->FromCat2ConstHi(const_val->ConstantValue(), false);
+    DCHECK(IsConstantLo());
+    return cache->ConstantHi();
   }
 }
 
@@ -312,54 +188,10 @@ Primitive::Type RegType::GetPrimitiveType() const {
   }
 }
 
-bool UninitializedType::IsUninitializedTypes() const {
-  return true;
-}
-
-bool UninitializedType::IsNonZeroReferenceTypes() const {
-  return true;
-}
-
-bool UnresolvedType::IsNonZeroReferenceTypes() const {
-  return true;
-}
-
-const RegType& RegType::GetSuperClass(RegTypeCache* cache) const {
-  if (!IsUnresolvedTypes()) {
-    ObjPtr<mirror::Class> super_klass = GetClass()->GetSuperClass();
-    if (super_klass != nullptr) {
-      // A super class of a precise type isn't precise as a precise type indicates the register
-      // holds exactly that type.
-      std::string temp;
-      return cache->FromClass(super_klass->GetDescriptor(&temp), super_klass, false);
-    } else {
-      return cache->Zero();
-    }
-  } else {
-    if (!IsUnresolvedMergedReference() && !IsUnresolvedSuperClass() &&
-        GetDescriptor()[0] == '[') {
-      // Super class of all arrays is Object.
-      return cache->JavaLangObject(true);
-    } else {
-      return cache->FromUnresolvedSuperClass(*this);
-    }
-  }
-}
-
-bool RegType::IsJavaLangObject() const REQUIRES_SHARED(Locks::mutator_lock_) {
-  return IsReference() && GetClass()->IsObjectClass();
-}
-
-bool RegType::IsObjectArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_) {
-  if (IsUnresolvedTypes()) {
-    DCHECK(!IsUnresolvedMergedReference());
-
-    if (IsUnresolvedSuperClass()) {
-      // Cannot be an array, as the superclass of arrays is java.lang.Object (which cannot be
-      // unresolved).
-      return false;
-    }
-
+bool RegType::IsObjectArrayTypes() const {
+  if (IsUnresolvedMergedReference()) {
+    return down_cast<const UnresolvedMergedReferenceType&>(*this).IsObjectArrayTypesImpl();
+  } else if (IsUnresolvedTypes()) {
     // Primitive arrays will always resolve.
     DCHECK(descriptor_[1] == 'L' || descriptor_[1] == '[');
     return descriptor_[0] == '[';
@@ -371,15 +203,10 @@ bool RegType::IsObjectArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_) {
   }
 }
 
-bool RegType::IsArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_) {
-  if (IsUnresolvedTypes()) {
-    DCHECK(!IsUnresolvedMergedReference());
-
-    if (IsUnresolvedSuperClass()) {
-      // Cannot be an array, as the superclass of arrays is java.lang.Object (which cannot be
-      // unresolved).
-      return false;
-    }
+bool RegType::IsArrayTypes() const {
+  if (IsUnresolvedMergedReference()) {
+    return down_cast<const UnresolvedMergedReferenceType&>(*this).IsArrayTypesImpl();
+  } else if (IsUnresolvedTypes()) {
     return descriptor_[0] == '[';
   } else if (HasClass()) {
     return GetClass()->IsArrayClass();
@@ -397,10 +224,11 @@ bool RegType::IsJavaLangObjectArray() const {
 }
 
 bool RegType::IsInstantiableTypes() const {
-  return IsUnresolvedTypes() || (IsNonZeroReferenceTypes() && GetClass()->IsInstantiable());
+  DCHECK(IsJavaLangObject() || IsReference() || IsUnresolvedReference()) << *this;
+  return !IsReference() || GetClass()->IsInstantiable();
 }
 
-static const RegType& SelectNonConstant(const RegType& a, const RegType& b) {
+static constexpr const RegType& SelectNonConstant(const RegType& a, const RegType& b) {
   return a.IsConstantTypes() ? b : a;
 }
 
@@ -408,7 +236,6 @@ static const RegType& SelectNonConstant2(const RegType& a, const RegType& b) {
   return a.IsConstantTypes() ? (b.IsZero() ? a : b) : a;
 }
 
-
 namespace {
 
 ObjPtr<mirror::Class> ArrayClassJoin(ObjPtr<mirror::Class> s,
@@ -548,107 +375,78 @@ ObjPtr<mirror::Class> InterfaceClassJoin(ObjPtr<mirror::Class> s, ObjPtr<mirror:
   return obj_class;
 }
 
-}  // namespace
+class RegTypeMergeImpl final : public RegType {
+ public:
+  explicit constexpr RegTypeMergeImpl(RegType::Kind kind)
+      : RegType("", /* unused cache id */ 0, kind) {}
 
-const RegType& RegType::Merge(const RegType& incoming_type,
-                              RegTypeCache* reg_types,
-                              MethodVerifier* verifier) const {
-  DCHECK(!Equals(incoming_type));  // Trivial equality handled by caller
-  // Perform pointer equality tests for undefined and conflict to avoid virtual method dispatch.
-  const UndefinedType& undefined = reg_types->Undefined();
-  const ConflictType& conflict = reg_types->Conflict();
-  DCHECK_EQ(this == &undefined, IsUndefined());
-  DCHECK_EQ(&incoming_type == &undefined, incoming_type.IsUndefined());
-  DCHECK_EQ(this == &conflict, IsConflict());
-  DCHECK_EQ(&incoming_type == &conflict, incoming_type.IsConflict());
-  if (this == &undefined || &incoming_type == &undefined) {
+  constexpr RegType::Kind MergeKind(RegType::Kind incoming_kind) const;
+};
+
+constexpr RegType::Kind RegTypeMergeImpl::MergeKind(RegType::Kind incoming_kind) const {
+  const RegTypeMergeImpl incoming_type(incoming_kind);
+  if (IsUndefined() || incoming_type.IsUndefined()) {
     // There is a difference between undefined and conflict. Conflicts may be copied around, but
     // not used. Undefined registers must not be copied. So any merge with undefined should return
     // undefined.
-    return undefined;
-  } else if (this == &conflict || &incoming_type == &conflict) {
-    return conflict;  // (Conflict MERGE *) or (* MERGE Conflict) => Conflict
+    return Kind::kUndefined;
+  } else if (IsConflict() || incoming_type.IsConflict()) {
+    return Kind::kConflict;  // (Conflict MERGE *) or (* MERGE Conflict) => Conflict
   } else if (IsConstant() && incoming_type.IsConstant()) {
-    const ConstantType& type1 = *down_cast<const ConstantType*>(this);
-    const ConstantType& type2 = *down_cast<const ConstantType*>(&incoming_type);
-    int32_t val1 = type1.ConstantValue();
-    int32_t val2 = type2.ConstantValue();
-    if (val1 >= 0 && val2 >= 0) {
-      // +ve1 MERGE +ve2 => MAX(+ve1, +ve2)
-      if (val1 >= val2) {
-        if (!type1.IsPreciseConstant()) {
-          return *this;
-        } else {
-          return reg_types->FromCat1Const(val1, false);
-        }
-      } else {
-        if (!type2.IsPreciseConstant()) {
-          return type2;
-        } else {
-          return reg_types->FromCat1Const(val2, false);
-        }
-      }
-    } else if (val1 < 0 && val2 < 0) {
-      // -ve1 MERGE -ve2 => MIN(-ve1, -ve2)
-      if (val1 <= val2) {
-        if (!type1.IsPreciseConstant()) {
-          return *this;
-        } else {
-          return reg_types->FromCat1Const(val1, false);
-        }
-      } else {
-        if (!type2.IsPreciseConstant()) {
-          return type2;
-        } else {
-          return reg_types->FromCat1Const(val2, false);
-        }
-      }
+    // Kind enumerator values within the non-negative and can-be-negative constant groups are
+    // ordered by increasing range, so the type with the higher kind can be used within these
+    // groups as the merged kind and merging across the groups is also quite simple.
+    static_assert(Kind::kZero < Kind::kBooleanConstant);
+    static_assert(Kind::kBooleanConstant < Kind::kPositiveByteConstant);
+    static_assert(Kind::kPositiveByteConstant < Kind::kPositiveShortConstant);
+    static_assert(Kind::kPositiveShortConstant < Kind::kCharConstant);
+    static_assert(Kind::kByteConstant < Kind::kShortConstant);
+    static_assert(Kind::kShortConstant < Kind::kIntegerConstant);
+
+    auto is_non_negative = [](const RegType& reg_type) constexpr {
+      bool result = reg_type.IsZero() ||
+                    reg_type.IsBooleanConstant() ||
+                    reg_type.IsPositiveByteConstant() ||
+                    reg_type.IsPositiveShortConstant() ||
+                    reg_type.IsCharConstant();
+      DCHECK_NE(
+          result,
+          reg_type.IsByteConstant() || reg_type.IsShortConstant() || reg_type.IsIntegerConstant());
+      return result;
+    };
+
+    bool is_non_negative_this = is_non_negative(*this);
+    if (is_non_negative_this == is_non_negative(incoming_type)) {
+      return GetKind() >= incoming_type.GetKind() ? GetKind() : incoming_type.GetKind();
+    }
+    Kind non_negative_kind = is_non_negative_this ? GetKind() : incoming_type.GetKind();
+    Kind can_be_negative_kind = is_non_negative_this ? incoming_type.GetKind() : GetKind();
+    if (can_be_negative_kind == Kind::kByteConstant &&
+        non_negative_kind <= Kind::kPositiveByteConstant) {
+      return Kind::kByteConstant;
+    } else if (can_be_negative_kind <= Kind::kShortConstant &&
+               non_negative_kind <= Kind::kPositiveShortConstant) {
+      return Kind::kShortConstant;
     } else {
-      // Values are +ve and -ve, choose smallest signed type in which they both fit
-      if (type1.IsConstantByte()) {
-        if (type2.IsConstantByte()) {
-          return reg_types->ByteConstant();
-        } else if (type2.IsConstantShort()) {
-          return reg_types->ShortConstant();
-        } else {
-          return reg_types->IntConstant();
-        }
-      } else if (type1.IsConstantShort()) {
-        if (type2.IsConstantShort()) {
-          return reg_types->ShortConstant();
-        } else {
-          return reg_types->IntConstant();
-        }
-      } else {
-        return reg_types->IntConstant();
-      }
+      return Kind::kIntegerConstant;
     }
-  } else if (IsConstantLo() && incoming_type.IsConstantLo()) {
-    const ConstantType& type1 = *down_cast<const ConstantType*>(this);
-    const ConstantType& type2 = *down_cast<const ConstantType*>(&incoming_type);
-    int32_t val1 = type1.ConstantValueLo();
-    int32_t val2 = type2.ConstantValueLo();
-    return reg_types->FromCat2ConstLo(val1 | val2, false);
-  } else if (IsConstantHi() && incoming_type.IsConstantHi()) {
-    const ConstantType& type1 = *down_cast<const ConstantType*>(this);
-    const ConstantType& type2 = *down_cast<const ConstantType*>(&incoming_type);
-    int32_t val1 = type1.ConstantValueHi();
-    int32_t val2 = type2.ConstantValueHi();
-    return reg_types->FromCat2ConstHi(val1 | val2, false);
+  } else if ((IsConstantLo() && incoming_type.IsConstantLo()) ||
+             (IsConstantHi() && incoming_type.IsConstantHi())) {
+    return GetKind();
   } else if (IsIntegralTypes() && incoming_type.IsIntegralTypes()) {
     if (IsBooleanTypes() && incoming_type.IsBooleanTypes()) {
-      return reg_types->Boolean();  // boolean MERGE boolean => boolean
+      return Kind::kBoolean;  // boolean MERGE boolean => boolean
     }
     if (IsByteTypes() && incoming_type.IsByteTypes()) {
-      return reg_types->Byte();  // byte MERGE byte => byte
+      return Kind::kByte;  // byte MERGE byte => byte
     }
     if (IsShortTypes() && incoming_type.IsShortTypes()) {
-      return reg_types->Short();  // short MERGE short => short
+      return Kind::kShort;  // short MERGE short => short
     }
     if (IsCharTypes() && incoming_type.IsCharTypes()) {
-      return reg_types->Char();  // char MERGE char => char
+      return Kind::kChar;  // char MERGE char => char
     }
-    return reg_types->Integer();  // int MERGE * => int
+    return Kind::kInteger;  // int MERGE * => int
   } else if ((IsFloatTypes() && incoming_type.IsFloatTypes()) ||
              (IsLongTypes() && incoming_type.IsLongTypes()) ||
              (IsLongHighTypes() && incoming_type.IsLongHighTypes()) ||
@@ -657,17 +455,59 @@ const RegType& RegType::Merge(const RegType& incoming_type,
     // check constant case was handled prior to entry
     DCHECK_IMPLIES(IsConstant(), !incoming_type.IsConstant());
     // float/long/double MERGE float/long/double_constant => float/long/double
-    return SelectNonConstant(*this, incoming_type);
+    return SelectNonConstant(*this, incoming_type).GetKind();
   } else if (IsReferenceTypes() && incoming_type.IsReferenceTypes()) {
     if (IsUninitializedTypes() || incoming_type.IsUninitializedTypes()) {
       // Something that is uninitialized hasn't had its constructor called. Unitialized types are
       // special. They may only ever be merged with themselves (must be taken care of by the
       // caller of Merge(), see the DCHECK on entry). So mark any other merge as conflicting here.
-      return conflict;
-    } else if (IsZeroOrNull() || incoming_type.IsZeroOrNull()) {
-      return SelectNonConstant2(*this, incoming_type);  // 0 MERGE ref => ref
+      return Kind::kConflict;
     } else if (IsJavaLangObject() || incoming_type.IsJavaLangObject()) {
-      return reg_types->JavaLangObject(false);  // Object MERGE ref => Object
+      return Kind::kJavaLangObject;
+    } else {
+      // Use `UnresolvedMergedReference` to tell the caller to process a reference merge.
+      // This does not mean that the actual merged kind must be `UnresolvedMergedReference`.
+      return Kind::kUnresolvedMergedReference;
+    }
+  } else {
+    return Kind::kConflict;  // Unexpected types => Conflict
+  }
+}
+
+}  // namespace
+
+const RegType& RegType::Merge(const RegType& incoming_type,
+                              RegTypeCache* reg_types,
+                              MethodVerifier* verifier) const {
+  DCHECK(!Equals(incoming_type));  // Trivial equality handled by caller
+
+  static constexpr size_t kNumKinds = NumberOfKinds();
+  using MergeTable = std::array<std::array<Kind, kNumKinds>, kNumKinds>;
+  static constexpr MergeTable kMergeTable = []() constexpr {
+    MergeTable result;
+    for (size_t lhs = 0u; lhs != kNumKinds; ++lhs) {
+      for (size_t rhs = 0u; rhs != kNumKinds; ++rhs) {
+        RegTypeMergeImpl lhs_impl(enum_cast<RegType::Kind>(lhs));
+        result[lhs][rhs] = lhs_impl.MergeKind(enum_cast<RegType::Kind>(rhs));
+      }
+    }
+    return result;
+  }();
+
+  Kind merge_kind = kMergeTable[GetKind()][incoming_type.GetKind()];
+  if (merge_kind != Kind::kUnresolvedMergedReference) {
+    return reg_types->GetFromRegKind(merge_kind);
+  } else {
+    // The `UnresolvedMergedReference` tells us to do non-trivial reference merging which
+    // requires more information than the two kinds used for the lookup in `kMergeTable`.
+    DCHECK(IsReferenceTypes()) << *this;
+    DCHECK(incoming_type.IsReferenceTypes()) << incoming_type;
+    DCHECK(!IsUninitializedTypes()) << *this;
+    DCHECK(!incoming_type.IsUninitializedTypes());
+    DCHECK(!IsJavaLangObject());
+    DCHECK(!incoming_type.IsJavaLangObject());
+    if (IsZeroOrNull() || incoming_type.IsZeroOrNull()) {
+      return SelectNonConstant2(*this, incoming_type);  // 0 MERGE ref => ref
     } else if (IsUnresolvedTypes() || incoming_type.IsUnresolvedTypes()) {
       // We know how to merge an unresolved type with itself, 0 or Object. In this case we
       // have two sub-classes and don't know how to merge. Create a new string-based unresolved
@@ -718,59 +558,40 @@ const RegType& RegType::Merge(const RegType& incoming_type,
                                                join_class,
                                                incoming_type.GetClass());
       }
-      if (GetClass() == join_class && !IsPreciseReference()) {
+      if (GetClass() == join_class) {
         return *this;
-      } else if (incoming_type.GetClass() == join_class && !incoming_type.IsPreciseReference()) {
+      } else if (incoming_type.GetClass() == join_class) {
         return incoming_type;
       } else {
-        std::string temp;
-        const char* descriptor = join_class->GetDescriptor(&temp);
-        return reg_types->FromClass(descriptor, join_class, /* precise= */ false);
+        return reg_types->FromClass(join_class);
       }
     }
-  } else {
-    return conflict;  // Unexpected types => Conflict
-  }
-}
-
-void RegType::CheckInvariants() const {
-  if (IsConstant() || IsConstantLo() || IsConstantHi()) {
-    CHECK(descriptor_.empty()) << *this;
-    CHECK(klass_.IsNull()) << *this;
-  }
-  if (!klass_.IsNull()) {
-    CHECK(!descriptor_.empty()) << *this;
-    std::string temp;
-    CHECK_EQ(descriptor_, klass_->GetDescriptor(&temp)) << *this;
   }
 }
 
-void UninitializedThisReferenceType::CheckInvariants() const {
-  CHECK_EQ(GetAllocationPc(), 0U) << *this;
-}
-
-void UnresolvedUninitializedThisRefType::CheckInvariants() const {
-  CHECK_EQ(GetAllocationPc(), 0U) << *this;
-  CHECK(!descriptor_.empty()) << *this;
-  CHECK(!HasClass()) << *this;
-}
-
-void UnresolvedUninitializedRefType::CheckInvariants() const {
+void ReferenceType::CheckClassDescriptor() const {
+  CHECK(IsReference());
+  CHECK(!klass_.IsNull());
   CHECK(!descriptor_.empty()) << *this;
-  CHECK(!HasClass()) << *this;
+  std::string temp;
+  CHECK_EQ(descriptor_, klass_->GetDescriptor(&temp)) << *this;
 }
 
-UnresolvedMergedType::UnresolvedMergedType(const RegType& resolved,
-                                           const BitVector& unresolved,
-                                           const RegTypeCache* reg_type_cache,
-                                           uint16_t cache_id)
-    : UnresolvedType(reg_type_cache->GetNullHandle(), "", cache_id),
+UnresolvedMergedReferenceType::UnresolvedMergedReferenceType(const RegType& resolved,
+                                                             const BitVector& unresolved,
+                                                             const RegTypeCache* reg_type_cache,
+                                                             uint16_t cache_id)
+    : UnresolvedType("", cache_id, Kind::kUnresolvedMergedReference),
       reg_type_cache_(reg_type_cache),
       resolved_part_(resolved),
       unresolved_types_(unresolved, false, unresolved.GetAllocator()) {
   CheckConstructorInvariants(this);
+  if (kIsDebugBuild) {
+    CheckInvariants();
+  }
 }
-void UnresolvedMergedType::CheckInvariants() const {
+
+void UnresolvedMergedReferenceType::CheckInvariants() const {
   CHECK(reg_type_cache_ != nullptr);
 
   // Unresolved merged types: merged types should be defined.
@@ -797,7 +618,7 @@ void UnresolvedMergedType::CheckInvariants() const {
   }
 }
 
-bool UnresolvedMergedType::IsArrayTypes() const {
+bool UnresolvedMergedReferenceType::IsArrayTypesImpl() const {
   // For a merge to be an array, both the resolved and the unresolved part need to be object
   // arrays.
   // (Note: we encode a missing resolved part [which doesn't need to be an array] as zero.)
@@ -812,23 +633,11 @@ bool UnresolvedMergedType::IsArrayTypes() const {
   const RegType& unresolved = reg_type_cache_->GetFromId(idx);
   return unresolved.IsArrayTypes();
 }
-bool UnresolvedMergedType::IsObjectArrayTypes() const {
+bool UnresolvedMergedReferenceType::IsObjectArrayTypesImpl() const {
   // Same as IsArrayTypes, as primitive arrays are always resolved.
   return IsArrayTypes();
 }
 
-void UnresolvedReferenceType::CheckInvariants() const {
-  CHECK(!descriptor_.empty()) << *this;
-  CHECK(!HasClass()) << *this;
-}
-
-void UnresolvedSuperClass::CheckInvariants() const {
-  // Unresolved merged types: merged types should be defined.
-  CHECK(descriptor_.empty()) << *this;
-  CHECK(!HasClass()) << *this;
-  CHECK_NE(unresolved_child_id_, 0U) << *this;
-}
-
 std::ostream& operator<<(std::ostream& os, const RegType& rhs) {
   os << rhs.Dump();
   return os;
diff --git a/runtime/verifier/reg_type.h b/runtime/verifier/reg_type.h
index 66f075e73f..a8f31c523c 100644
--- a/runtime/verifier/reg_type.h
+++ b/runtime/verifier/reg_type.h
@@ -26,6 +26,7 @@
 #include "base/arena_object.h"
 #include "base/bit_vector.h"
 #include "base/locks.h"
+#include "base/logging.h"
 #include "base/macros.h"
 #include "dex/primitive.h"
 #include "gc_root.h"
@@ -39,198 +40,205 @@ class Class;
 class ClassLoader;
 }  // namespace mirror
 
+class ArenaAllocator;
 class ArenaBitVector;
-class ScopedArenaAllocator;
 
 namespace verifier {
 
 class MethodVerifier;
 class RegTypeCache;
 
+#define FOR_EACH_CONCRETE_REG_TYPE(V)                                         \
+  V(Undefined)                                                                \
+  V(Conflict)                                                                 \
+  V(Boolean)                                                                  \
+  V(Byte)                                                                     \
+  V(Char)                                                                     \
+  V(Short)                                                                    \
+  V(Integer)                                                                  \
+  V(LongLo)                                                                   \
+  V(LongHi)                                                                   \
+  V(Float)                                                                    \
+  V(DoubleLo)                                                                 \
+  V(DoubleHi)                                                                 \
+  /* Category 1 groups of constant types are ordered by increasing range */   \
+  /* within the non-negative and can-be-negative groups, so that merging */   \
+  /* can simply use the type with the higher kind value. */                   \
+  V(Zero)                                                                     \
+  V(BooleanConstant)                                                          \
+  V(PositiveByteConstant)                                                     \
+  V(PositiveShortConstant)                                                    \
+  V(CharConstant)                                                             \
+  V(ByteConstant)                                                             \
+  V(ShortConstant)                                                            \
+  V(IntegerConstant)                                                          \
+  V(ConstantLo)                                                               \
+  V(ConstantHi)                                                               \
+  V(Null)                                                                     \
+  V(JavaLangObject)                                                           \
+  V(UnresolvedReference)                                                      \
+  V(UninitializedReference)                                                   \
+  V(UninitializedThisReference)                                               \
+  V(UnresolvedUninitializedReference)                                         \
+  V(UnresolvedUninitializedThisReference)                                     \
+  V(UnresolvedMergedReference)                                                \
+  V(Reference)                                                                \
+
+#define FORWARD_DECLARE_REG_TYPE(name) class name##Type;
+FOR_EACH_CONCRETE_REG_TYPE(FORWARD_DECLARE_REG_TYPE)
+#undef FORWARD_DECLARE_REG_TYPE
+
 /*
  * RegType holds information about the "type" of data held in a register.
  */
 class RegType {
  public:
-  virtual bool IsUndefined() const { return false; }
-  virtual bool IsConflict() const { return false; }
-  virtual bool IsBoolean() const { return false; }
-  virtual bool IsByte() const { return false; }
-  virtual bool IsChar() const { return false; }
-  virtual bool IsShort() const { return false; }
-  virtual bool IsInteger() const { return false; }
-  virtual bool IsLongLo() const { return false; }
-  virtual bool IsLongHi() const { return false; }
-  virtual bool IsFloat() const { return false; }
-  virtual bool IsDouble() const { return false; }
-  virtual bool IsDoubleLo() const { return false; }
-  virtual bool IsDoubleHi() const { return false; }
-  virtual bool IsUnresolvedReference() const { return false; }
-  virtual bool IsUninitializedReference() const { return false; }
-  virtual bool IsUninitializedThisReference() const { return false; }
-  virtual bool IsUnresolvedAndUninitializedReference() const { return false; }
-  virtual bool IsUnresolvedAndUninitializedThisReference() const {
-    return false;
+  enum Kind : uint8_t {
+#define DEFINE_REG_TYPE_ENUMERATOR(name) \
+    k##name,
+    FOR_EACH_CONCRETE_REG_TYPE(DEFINE_REG_TYPE_ENUMERATOR)
+#undef DEFINE_REG_TYPE_ENUMERATOR
+  };
+
+  static constexpr size_t NumberOfKinds() {
+#define ADD_ONE_FOR_CONCRETE_REG_TYPE(name) + 1
+    return 0 FOR_EACH_CONCRETE_REG_TYPE(ADD_ONE_FOR_CONCRETE_REG_TYPE);
+#undef ADD_ONE_FOR_CONCRETE_REG_TYPE
   }
-  virtual bool IsUnresolvedMergedReference() const { return false; }
-  virtual bool IsUnresolvedSuperClass() const { return false; }
-  virtual bool IsReference() const { return false; }
-  virtual bool IsPreciseReference() const { return false; }
-  virtual bool IsPreciseConstant() const { return false; }
-  virtual bool IsPreciseConstantLo() const { return false; }
-  virtual bool IsPreciseConstantHi() const { return false; }
-  virtual bool IsImpreciseConstantLo() const { return false; }
-  virtual bool IsImpreciseConstantHi() const { return false; }
-  virtual bool IsImpreciseConstant() const { return false; }
-  virtual bool IsConstantTypes() const { return false; }
-  bool IsConstant() const {
-    return IsImpreciseConstant() || IsPreciseConstant();
+
+  constexpr Kind GetKind() const { return kind_; }
+
+#define DEFINE_IS_CONCRETE_REG_TYPE(name) \
+  constexpr bool Is##name() const { return GetKind() == Kind::k##name; }
+  FOR_EACH_CONCRETE_REG_TYPE(DEFINE_IS_CONCRETE_REG_TYPE)
+#undef DEFINE_IS_CONCRETE_REG_TYPE
+
+  constexpr bool IsConstantTypes() const {
+    return IsConstant() || IsConstantLo() || IsConstantHi() || IsNull();
   }
-  bool IsConstantLo() const {
-    return IsImpreciseConstantLo() || IsPreciseConstantLo();
+  constexpr bool IsConstant() const {
+    return IsZero() ||
+           IsBooleanConstant() ||
+           IsPositiveByteConstant() ||
+           IsPositiveShortConstant() ||
+           IsCharConstant() ||
+           IsByteConstant() ||
+           IsShortConstant() ||
+           IsIntegerConstant();
   }
-  bool IsPrecise() const {
-    return IsPreciseConstantLo() || IsPreciseConstant() ||
-           IsPreciseConstantHi();
+
+  constexpr bool IsNonZeroReferenceTypes() const;
+  constexpr bool IsUninitializedTypes() const;
+  constexpr bool IsUnresolvedTypes() const;
+
+  static constexpr bool IsLowHalf(Kind kind) {
+    return kind == Kind::kLongLo || kind == Kind::kDoubleLo || kind == Kind::kConstantLo;
   }
-  bool IsLongConstant() const { return IsConstantLo(); }
-  bool IsConstantHi() const {
-    return (IsPreciseConstantHi() || IsImpreciseConstantHi());
+  static constexpr bool IsHighHalf(Kind kind) {
+    return kind == Kind::kLongHi || kind == Kind::kDoubleHi || kind == Kind::kConstantHi;
   }
-  bool IsLongConstantHigh() const { return IsConstantHi(); }
-  virtual bool IsUninitializedTypes() const { return false; }
-  virtual bool IsUnresolvedTypes() const { return false; }
 
-  bool IsLowHalf() const {
-    return (IsLongLo() || IsDoubleLo() || IsPreciseConstantLo() || IsImpreciseConstantLo());
+  constexpr bool IsLowHalf() const { return IsLowHalf(GetKind()); }
+  constexpr bool IsHighHalf() const { return IsHighHalf(GetKind()); }
+  constexpr bool IsLongOrDoubleTypes() const { return IsLowHalf(); }
+
+  static constexpr Kind ToHighHalf(Kind low) {
+    static_assert(Kind::kConstantLo + 1 == Kind::kConstantHi);
+    static_assert(Kind::kDoubleLo + 1 == Kind::kDoubleHi);
+    static_assert(Kind::kLongLo + 1 == Kind::kLongHi);
+    DCHECK(low == Kind::kConstantLo || low == Kind::kDoubleLo || low == Kind::kLongLo);
+    return enum_cast<Kind>(low + 1);
   }
-  bool IsHighHalf() const {
-    return (IsLongHi() || IsDoubleHi() || IsPreciseConstantHi() || IsImpreciseConstantHi());
+
+  // Check that `low` is the low half, and that `high` is its matching high-half.
+  static inline bool CheckWidePair(Kind low, Kind high) {
+    return (low == Kind::kConstantLo || low == Kind::kDoubleLo || low == Kind::kLongLo) &&
+           high == ToHighHalf(low);
   }
-  bool IsLongOrDoubleTypes() const { return IsLowHalf(); }
   // Check this is the low half, and that type_h is its matching high-half.
   inline bool CheckWidePair(const RegType& type_h) const {
-    if (IsLowHalf()) {
-      return ((IsImpreciseConstantLo() && type_h.IsPreciseConstantHi()) ||
-              (IsImpreciseConstantLo() && type_h.IsImpreciseConstantHi()) ||
-              (IsPreciseConstantLo() && type_h.IsPreciseConstantHi()) ||
-              (IsPreciseConstantLo() && type_h.IsImpreciseConstantHi()) ||
-              (IsDoubleLo() && type_h.IsDoubleHi()) ||
-              (IsLongLo() && type_h.IsLongHi()));
-    }
-    return false;
+    return CheckWidePair(GetKind(), type_h.GetKind());
   }
+
   // The high half that corresponds to this low half
   const RegType& HighHalf(RegTypeCache* cache) const
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  bool IsConstantBoolean() const;
-  virtual bool IsConstantChar() const { return false; }
-  virtual bool IsConstantByte() const { return false; }
-  virtual bool IsConstantShort() const { return false; }
-  virtual bool IsOne() const { return false; }
-  virtual bool IsZero() const { return false; }
-  virtual bool IsNull() const { return false; }
-  bool IsReferenceTypes() const {
+  constexpr bool IsReferenceTypes() const {
     return IsNonZeroReferenceTypes() || IsZero() || IsNull();
   }
-  bool IsZeroOrNull() const {
+  constexpr bool IsZeroOrNull() const {
     return IsZero() || IsNull();
   }
-  virtual bool IsNonZeroReferenceTypes() const { return false; }
   bool IsCategory1Types() const {
-    return IsChar() || IsInteger() || IsFloat() || IsConstant() || IsByte() ||
-           IsShort() || IsBoolean();
+    return IsIntegralTypes() || IsFloat();
   }
   bool IsCategory2Types() const {
     return IsLowHalf();  // Don't expect explicit testing of high halves
   }
-  bool IsBooleanTypes() const { return IsBoolean() || IsConstantBoolean(); }
-  bool IsByteTypes() const {
-    return IsConstantByte() || IsByte() || IsBoolean();
+  static constexpr bool IsBooleanTypes(Kind kind) {
+    return kind == Kind::kBoolean || kind == Kind::kZero || kind == Kind::kBooleanConstant;
+  }
+  constexpr bool IsBooleanTypes() const { return IsBooleanTypes(GetKind()); }
+  constexpr bool IsByteTypes() const {
+    return IsByte() || IsPositiveByteConstant() || IsByteConstant() || IsBooleanTypes();
   }
-  bool IsShortTypes() const {
-    return IsShort() || IsByte() || IsBoolean() || IsConstantShort();
+  constexpr bool IsShortTypes() const {
+    return IsShort() || IsPositiveShortConstant() || IsShortConstant() || IsByteTypes();
   }
-  bool IsCharTypes() const {
-    return IsChar() || IsBooleanTypes() || IsConstantChar();
+  constexpr bool IsCharTypes() const {
+    return IsChar() ||
+           IsCharConstant() ||
+           IsPositiveShortConstant() ||
+           IsPositiveByteConstant() ||
+           IsBooleanTypes();
   }
-  bool IsIntegralTypes() const {
-    return IsInteger() || IsConstant() || IsByte() || IsShort() || IsChar() ||
-           IsBoolean();
+  constexpr bool IsIntegralTypes() const {
+    return IsInteger() || IsIntegerConstant() || IsChar() || IsCharConstant() || IsShortTypes();
   }
   // Give the constant value encoded, but this shouldn't be called in the
   // general case.
   bool IsArrayIndexTypes() const { return IsIntegralTypes(); }
   // Float type may be derived from any constant type
-  bool IsFloatTypes() const { return IsFloat() || IsConstant(); }
-  bool IsLongTypes() const { return IsLongLo() || IsLongConstant(); }
-  bool IsLongHighTypes() const {
-    return (IsLongHi() || IsPreciseConstantHi() || IsImpreciseConstantHi());
-  }
-  bool IsDoubleTypes() const { return IsDoubleLo() || IsLongConstant(); }
-  bool IsDoubleHighTypes() const {
-    return (IsDoubleHi() || IsPreciseConstantHi() || IsImpreciseConstantHi());
-  }
-  virtual bool IsLong() const { return false; }
+  constexpr bool IsFloatTypes() const { return IsFloat() || IsConstant(); }
+  constexpr bool IsLongTypes() const { return IsLongLo() || IsConstantLo(); }
+  constexpr bool IsLongHighTypes() const { return (IsLongHi() || IsConstantHi()); }
+  constexpr bool IsDoubleTypes() const { return IsDoubleLo() || IsConstantLo(); }
+  constexpr bool IsDoubleHighTypes() const { return (IsDoubleHi() || IsConstantHi()); }
   bool HasClass() const {
-    bool result = !klass_.IsNull();
-    DCHECK_EQ(result, HasClassVirtual());
-    return result;
+    // The only type with a class is `ReferenceType`. There is no class for
+    // unresolved types and we do not record the class in uninitialized types.
+    // We do not need the class for primitive types.
+    return IsReference();
   }
-  virtual bool HasClassVirtual() const { return false; }
-  bool IsJavaLangObject() const REQUIRES_SHARED(Locks::mutator_lock_);
-  virtual bool IsArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_);
-  virtual bool IsObjectArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_);
+  bool IsArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_);
+  bool IsObjectArrayTypes() const REQUIRES_SHARED(Locks::mutator_lock_);
   Primitive::Type GetPrimitiveType() const;
   bool IsJavaLangObjectArray() const
       REQUIRES_SHARED(Locks::mutator_lock_);
   bool IsInstantiableTypes() const REQUIRES_SHARED(Locks::mutator_lock_);
-  const std::string_view& GetDescriptor() const {
-    DCHECK(HasClass() ||
-           (IsUnresolvedTypes() && !IsUnresolvedMergedReference() &&
-            !IsUnresolvedSuperClass()));
+  constexpr const std::string_view& GetDescriptor() const {
+    DCHECK(IsJavaLangObject() ||
+           IsReference() ||
+           IsUninitializedTypes() ||
+           (IsUnresolvedTypes() && !IsUnresolvedMergedReference()));
     return descriptor_;
   }
-  ObjPtr<mirror::Class> GetClass() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(!IsUnresolvedReference());
-    DCHECK(!klass_.IsNull());
-    DCHECK(HasClass());
-    return klass_.Get();
-  }
-  Handle<mirror::Class> GetClassHandle() const REQUIRES_SHARED(Locks::mutator_lock_) {
-    DCHECK(!IsUnresolvedReference());
-    DCHECK(!klass_.IsNull()) << Dump();
-    DCHECK(HasClass()) << Dump();
-    return klass_;
-  }
+  ObjPtr<mirror::Class> GetClass() const REQUIRES_SHARED(Locks::mutator_lock_);
+  Handle<mirror::Class> GetClassHandle() const REQUIRES_SHARED(Locks::mutator_lock_);
   uint16_t GetId() const { return cache_id_; }
-  const RegType& GetSuperClass(RegTypeCache* cache) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
 
-  virtual std::string Dump() const
-      REQUIRES_SHARED(Locks::mutator_lock_) = 0;
+  std::string Dump() const REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Can this type access other?
-  bool CanAccess(const RegType& other) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  // Can this type access a member with the given properties?
-  bool CanAccessMember(ObjPtr<mirror::Class> klass, uint32_t access_flags) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
+  enum class Assignability : uint8_t {
+    kAssignable,
+    kNotAssignable,
+    kNarrowingConversion,
+    kReference,
+    kInvalid,
+  };
 
-  // Can this type be assigned by src?
-  // Note: Object and interface types may always be assigned to one another, see
-  // comment on
-  // ClassJoin.
-  bool IsAssignableFrom(const RegType& src, MethodVerifier* verifier) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  // Can this type be assigned by src? Variant of IsAssignableFrom that doesn't
-  // allow assignment to
-  // an interface from an Object.
-  bool IsStrictlyAssignableFrom(const RegType& src, MethodVerifier* verifier) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
+  ALWAYS_INLINE static inline Assignability AssignabilityFrom(Kind lhs, Kind rhs);
 
   // Are these RegTypes the same?
   bool Equals(const RegType& other) const { return GetId() == other.GetId(); }
@@ -252,116 +260,44 @@ class RegType {
     return Merge(incoming_type, reg_types, verifier);
   }
 
-  virtual ~RegType() {}
+  constexpr ~RegType() {}
 
   static void* operator new(size_t size) noexcept {
     return ::operator new(size);
   }
 
-  static void* operator new(size_t size, ArenaAllocator* allocator) = delete;
-  static void* operator new(size_t size, ScopedArenaAllocator* allocator);
-
-  enum class AssignmentType {
-    kBoolean,
-    kByte,
-    kShort,
-    kChar,
-    kInteger,
-    kFloat,
-    kLongLo,
-    kDoubleLo,
-    kConflict,
-    kReference,
-    kNotAssignable,
-  };
-
-  ALWAYS_INLINE
-  inline AssignmentType GetAssignmentType() const {
-    AssignmentType t = GetAssignmentTypeImpl();
-    if (kIsDebugBuild) {
-      if (IsBoolean()) {
-        CHECK(AssignmentType::kBoolean == t);
-      } else if (IsByte()) {
-        CHECK(AssignmentType::kByte == t);
-      } else if (IsShort()) {
-        CHECK(AssignmentType::kShort == t);
-      } else if (IsChar()) {
-        CHECK(AssignmentType::kChar == t);
-      } else if (IsInteger()) {
-        CHECK(AssignmentType::kInteger == t);
-      } else if (IsFloat()) {
-        CHECK(AssignmentType::kFloat == t);
-      } else if (IsLongLo()) {
-        CHECK(AssignmentType::kLongLo == t);
-      } else if (IsDoubleLo()) {
-        CHECK(AssignmentType::kDoubleLo == t);
-      } else if (IsConflict()) {
-        CHECK(AssignmentType::kConflict == t);
-      } else if (IsReferenceTypes()) {
-        CHECK(AssignmentType::kReference == t);
-      } else {
-        LOG(FATAL) << "Unreachable";
-        UNREACHABLE();
-      }
-    }
-    return t;
-  }
+  static void* operator new(size_t size, ArenaAllocator* allocator);
+  static void* operator new(size_t size, ScopedArenaAllocator* allocator) = delete;
 
  protected:
-  RegType(Handle<mirror::Class> klass,
-          const std::string_view& descriptor,
-          uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
+  constexpr RegType(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
+      REQUIRES_SHARED(Locks::mutator_lock_)
       : descriptor_(descriptor),
-        klass_(klass),
-        cache_id_(cache_id) {}
+        cache_id_(cache_id),
+        kind_(kind) {}
 
   template <typename Class>
-  void CheckConstructorInvariants([[maybe_unused]] Class* this_) const
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    static_assert(std::is_final<Class>::value, "Class must be final.");
-    if (kIsDebugBuild) {
-      CheckInvariants();
-    }
-  }
-
-  virtual AssignmentType GetAssignmentTypeImpl() const = 0;
+  constexpr void CheckConstructorInvariants([[maybe_unused]] Class* this_) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   const std::string_view descriptor_;
-  const Handle<mirror::Class> klass_;
   const uint16_t cache_id_;
+  const Kind kind_;
 
   friend class RegTypeCache;
 
  private:
-  virtual void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_);
-
-
-  static bool AssignableFrom(const RegType& lhs,
-                             const RegType& rhs,
-                             bool strict,
-                             MethodVerifier* verifier)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   DISALLOW_COPY_AND_ASSIGN(RegType);
 };
 
+std::ostream& operator<<(std::ostream& os, RegType::Kind kind);
+std::ostream& operator<<(std::ostream& os, RegType::Assignability assignability);
+
 // Bottom type.
 class ConflictType final : public RegType {
  public:
-  bool IsConflict() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kConflict;
-  }
-
-  ConflictType(Handle<mirror::Class> klass,
-               const std::string_view& descriptor,
-               uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr ConflictType(uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 // A variant of the bottom type used to specify an undefined value in the
@@ -369,507 +305,193 @@ class ConflictType final : public RegType {
 // Merging with UndefinedType yields ConflictType which is the true bottom.
 class UndefinedType final : public RegType {
  public:
-  bool IsUndefined() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
-
-  UndefinedType(Handle<mirror::Class> klass,
-                const std::string_view& descriptor,
-                uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr UndefinedType(uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class PrimitiveType : public RegType {
  public:
-  PrimitiveType(Handle<mirror::Class> klass,
-                const std::string_view& descriptor,
-                uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
-
-  bool HasClassVirtual() const override { return true; }
+  constexpr PrimitiveType(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : RegType(descriptor, cache_id, kind) {
+    DCHECK_EQ(descriptor.length(), 1u);
+  }
 };
 
 class Cat1Type : public PrimitiveType {
  public:
-  Cat1Type(Handle<mirror::Class> klass,
-           const std::string_view& descriptor,
-           uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
+  constexpr Cat1Type(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : PrimitiveType(descriptor, cache_id, kind) {}
 };
 
 class IntegerType final : public Cat1Type {
  public:
-  bool IsInteger() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kInteger;
-  }
-
-  IntegerType(Handle<mirror::Class> klass,
-              const std::string_view& descriptor,
-              uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr IntegerType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class BooleanType final : public Cat1Type {
  public:
-  bool IsBoolean() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kBoolean;
-  }
-
-  BooleanType(Handle<mirror::Class> klass,
-              const std::string_view& descriptor,
-              uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr BooleanType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class ByteType final : public Cat1Type {
  public:
-  bool IsByte() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kByte;
-  }
-
-  ByteType(Handle<mirror::Class> klass,
-           const std::string_view& descriptor,
-           uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr ByteType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class ShortType final : public Cat1Type {
  public:
-  bool IsShort() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kShort;
-  }
-
-  ShortType(Handle<mirror::Class> klass,
-            const std::string_view& descriptor,
-            uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr ShortType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class CharType final : public Cat1Type {
  public:
-  bool IsChar() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kChar;
-  }
-
-  CharType(Handle<mirror::Class> klass,
-           const std::string_view& descriptor,
-           uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr CharType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class FloatType final : public Cat1Type {
  public:
-  bool IsFloat() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kFloat;
-  }
-
-  FloatType(Handle<mirror::Class> klass,
-            const std::string_view& descriptor,
-            uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat1Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr FloatType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class Cat2Type : public PrimitiveType {
  public:
-  Cat2Type(Handle<mirror::Class> klass,
-           const std::string_view& descriptor,
-           uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
+  constexpr Cat2Type(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : PrimitiveType(descriptor, cache_id, kind) {}
 };
 
 class LongLoType final : public Cat2Type {
  public:
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-  bool IsLongLo() const override { return true; }
-  bool IsLong() const override { return true; }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kLongLo;
-  }
-
-  LongLoType(Handle<mirror::Class> klass,
-             const std::string_view& descriptor,
-             uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat2Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr LongLoType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class LongHiType final : public Cat2Type {
  public:
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-  bool IsLongHi() const override { return true; }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
-
-  LongHiType(Handle<mirror::Class> klass,
-             const std::string_view& descriptor,
-             uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat2Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr LongHiType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class DoubleLoType final : public Cat2Type {
  public:
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-  bool IsDoubleLo() const override { return true; }
-  bool IsDouble() const override { return true; }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kDoubleLo;
-  }
-
-  DoubleLoType(Handle<mirror::Class> klass,
-               const std::string_view& descriptor,
-               uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat2Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr DoubleLoType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class DoubleHiType final : public Cat2Type {
  public:
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-  bool IsDoubleHi() const override { return true; }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
-
-  DoubleHiType(Handle<mirror::Class> klass,
-               const std::string_view& descriptor,
-               uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : Cat2Type(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr DoubleHiType(const std::string_view& descriptor, uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
 class ConstantType : public RegType {
  public:
-  ConstantType(Handle<mirror::Class> klass,
-               uint32_t constant,
-               uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, "", cache_id), constant_(constant) {
-  }
-
-
-  // If this is a 32-bit constant, what is the value? This value may be
-  // imprecise in which case
-  // the value represents part of the integer range of values that may be held
-  // in the register.
-  int32_t ConstantValue() const {
-    DCHECK(IsConstantTypes());
-    return constant_;
-  }
-
-  int32_t ConstantValueLo() const {
-    DCHECK(IsConstantLo());
-    return constant_;
-  }
-
-  int32_t ConstantValueHi() const {
-    if (IsConstantHi() || IsPreciseConstantHi() || IsImpreciseConstantHi()) {
-      return constant_;
-    } else {
-      DCHECK(false);
-      return 0;
-    }
-  }
-
-  bool IsZero() const override {
-    return IsPreciseConstant() && ConstantValue() == 0;
-  }
-  bool IsOne() const override {
-    return IsPreciseConstant() && ConstantValue() == 1;
-  }
-
-  bool IsConstantChar() const override {
-    return IsConstant() && ConstantValue() >= 0 &&
-           ConstantValue() <= std::numeric_limits<uint16_t>::max();
-  }
-  bool IsConstantByte() const override {
-    return IsConstant() &&
-           ConstantValue() >= std::numeric_limits<int8_t>::min() &&
-           ConstantValue() <= std::numeric_limits<int8_t>::max();
-  }
-  bool IsConstantShort() const override {
-    return IsConstant() &&
-           ConstantValue() >= std::numeric_limits<int16_t>::min() &&
-           ConstantValue() <= std::numeric_limits<int16_t>::max();
-  }
-  bool IsConstantTypes() const override { return true; }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
-
- private:
-  const uint32_t constant_;
+  constexpr ConstantType(uint16_t cache_id, Kind kind)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : RegType("", cache_id, kind) {}
 };
 
-class PreciseConstType final : public ConstantType {
+// Constant 0, or merged constants 0. Can be interpreted as `null`.
+class ZeroType final : public ConstantType {
  public:
-  PreciseConstType(Handle<mirror::Class> cls, uint32_t constant, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : ConstantType(cls, constant, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-
-  bool IsPreciseConstant() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit ZeroType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-class PreciseConstLoType final : public ConstantType {
+// Constant 1, or merged constants 0 - 1.
+class BooleanConstantType final : public ConstantType {
  public:
-  PreciseConstLoType(Handle<mirror::Class> cls, uint32_t constant, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : ConstantType(cls, constant, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-  bool IsPreciseConstantLo() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit BooleanConstantType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-class PreciseConstHiType final : public ConstantType {
+// Constants 2 - 0x7f, or merged constants 0 - 0x7f.
+class PositiveByteConstantType final : public ConstantType {
  public:
-  PreciseConstHiType(Handle<mirror::Class> cls, uint32_t constant, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : ConstantType(cls, constant, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-  bool IsPreciseConstantHi() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit PositiveByteConstantType(uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-class ImpreciseConstType final : public ConstantType {
+// Constants 0x80 - 0x7fff, or merged constants 0 - 0x7fff.
+class PositiveShortConstantType final : public ConstantType {
  public:
-  ImpreciseConstType(Handle<mirror::Class> cls, uint32_t constat, uint16_t cache_id)
-       REQUIRES_SHARED(Locks::mutator_lock_)
-       : ConstantType(cls, constat, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-  bool IsImpreciseConstant() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit PositiveShortConstantType(uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-class ImpreciseConstLoType final : public ConstantType {
+// Constants 0x8000 - 0xffff, or merged constants 0 - 0xffff.
+class CharConstantType final : public ConstantType {
  public:
-  ImpreciseConstLoType(Handle<mirror::Class> cls, uint32_t constant, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : ConstantType(cls, constant, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-  bool IsImpreciseConstantLo() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit CharConstantType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-class ImpreciseConstHiType final : public ConstantType {
+// Constants -0x80 - -1, or merged constants -x80 - 0x7f.
+class ByteConstantType final : public ConstantType {
  public:
-  ImpreciseConstHiType(Handle<mirror::Class> cls, uint32_t constant, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : ConstantType(cls, constant, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-  bool IsImpreciseConstantHi() const override { return true; }
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kNotAssignable;
-  }
+  constexpr explicit ByteConstantType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-// Special "null" type that captures the semantics of null / bottom.
-class NullType final : public RegType {
+// Constants -0x8000 - -0x81, or merged constants -x8000 - 0x7fff.
+class ShortConstantType final : public ConstantType {
  public:
-  bool IsNull() const override {
-    return true;
-  }
-
-  std::string Dump() const override {
-    return "null";
-  }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kReference;
-  }
-
-  bool IsConstantTypes() const override {
-    return true;
-  }
-
-  NullType(Handle<mirror::Class> klass, const std::string_view& descriptor, uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, descriptor, cache_id) {
-    CheckConstructorInvariants(this);
-  }
+  constexpr explicit ShortConstantType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-// Common parent of all uninitialized types. Uninitialized types are created by
-// "new" dex
-// instructions and must be passed to a constructor.
-class UninitializedType : public RegType {
+// Constants -0x80000000 - -0x8001, or merged constants -0x80000000 - 0x7fffffff.
+class IntegerConstantType final : public ConstantType {
  public:
-  UninitializedType(Handle<mirror::Class> klass,
-                    const std::string_view& descriptor,
-                    uint32_t allocation_pc,
-                    uint16_t cache_id)
-      : RegType(klass, descriptor, cache_id), allocation_pc_(allocation_pc) {}
-
-  bool IsUninitializedTypes() const override;
-  bool IsNonZeroReferenceTypes() const override;
-
-  uint32_t GetAllocationPc() const {
-    DCHECK(IsUninitializedTypes());
-    return allocation_pc_;
-  }
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kReference;
-  }
-
- private:
-  const uint32_t allocation_pc_;
+  constexpr explicit IntegerConstantType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-// Similar to ReferenceType but not yet having been passed to a constructor.
-class UninitializedReferenceType final : public UninitializedType {
+class ConstantLoType final : public ConstantType {
  public:
-  UninitializedReferenceType(Handle<mirror::Class> klass,
-                             const std::string_view& descriptor,
-                             uint32_t allocation_pc,
-                             uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : UninitializedType(klass, descriptor, allocation_pc, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-
-  bool IsUninitializedReference() const override { return true; }
-
-  bool HasClassVirtual() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  constexpr explicit ConstantLoType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-// Similar to UnresolvedReferenceType but not yet having been passed to a
-// constructor.
-class UnresolvedUninitializedRefType final : public UninitializedType {
+class ConstantHiType final : public ConstantType {
  public:
-  UnresolvedUninitializedRefType(Handle<mirror::Class> klass,
-                                 const std::string_view& descriptor,
-                                 uint32_t allocation_pc,
-                                 uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : UninitializedType(klass, descriptor, allocation_pc, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-
-  bool IsUnresolvedAndUninitializedReference() const override { return true; }
-
-  bool IsUnresolvedTypes() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
- private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
+  constexpr explicit ConstantHiType(uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_);
 };
 
-// Similar to UninitializedReferenceType but special case for the this argument
-// of a constructor.
-class UninitializedThisReferenceType final : public UninitializedType {
+// Special "null" type that captures the semantics of null / bottom.
+class NullType final : public ConstantType {
  public:
-  UninitializedThisReferenceType(Handle<mirror::Class> klass,
-                                 const std::string_view& descriptor,
-                                 uint16_t cache_id)
-      REQUIRES_SHARED(Locks::mutator_lock_)
-      : UninitializedType(klass, descriptor, 0, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-
-  bool IsUninitializedThisReference() const override { return true; }
+  constexpr NullType(uint16_t cache_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+};
 
-  bool HasClassVirtual() const override { return true; }
+// The reference type for `java.lang.Object` class is specialized to allow compile-time
+// evaluation of merged types and assignablility. Note that we do not record the trivial
+// assignability for `java.lang.Object` in the `VerifierDeps`.
+class JavaLangObjectType final : public RegType {
+ public:
+  constexpr JavaLangObjectType(std::string_view descriptor,
+                               uint16_t cache_id,
+                               const UninitializedReferenceType* uninitialized_type)
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  const UninitializedReferenceType* GetUninitializedType() const {
+    return uninitialized_type_;
+  }
 
  private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
+  const UninitializedReferenceType* const uninitialized_type_;
 };
 
-class UnresolvedUninitializedThisRefType final : public UninitializedType {
+// Common parent of all uninitialized types. Uninitialized types are created by
+// "new" dex
+// instructions and must be passed to a constructor.
+class UninitializedType : public RegType {
  public:
-  UnresolvedUninitializedThisRefType(Handle<mirror::Class> klass,
-                                     const std::string_view& descriptor,
-                                     uint16_t cache_id)
+  constexpr UninitializedType(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
       REQUIRES_SHARED(Locks::mutator_lock_)
-      : UninitializedType(klass, descriptor, 0, cache_id) {
-    CheckConstructorInvariants(this);
-  }
-
-  bool IsUnresolvedAndUninitializedThisReference() const override { return true; }
-
-  bool IsUnresolvedTypes() const override { return true; }
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
- private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
+      : RegType(descriptor, cache_id, kind) {}
 };
 
 // A type of register holding a reference to an Object of type GetClass or a
@@ -879,60 +501,83 @@ class ReferenceType final : public RegType {
   ReferenceType(Handle<mirror::Class> klass,
                 const std::string_view& descriptor,
                 uint16_t cache_id) REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, descriptor, cache_id) {
+      : RegType(descriptor, cache_id, Kind::kReference),
+        klass_(klass),
+        uninitialized_type_(nullptr) {
     CheckConstructorInvariants(this);
   }
 
-  bool IsReference() const override { return true; }
-
-  bool IsNonZeroReferenceTypes() const override { return true; }
+  ObjPtr<mirror::Class> GetClassImpl() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(!klass_.IsNull());
+    return klass_.Get();
+  }
 
-  bool HasClassVirtual() const override { return true; }
+  Handle<mirror::Class> GetClassHandleImpl() const REQUIRES_SHARED(Locks::mutator_lock_) {
+    DCHECK(!klass_.IsNull());
+    return klass_;
+  }
 
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  const UninitializedReferenceType* GetUninitializedType() const {
+    return uninitialized_type_;
+  }
 
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kReference;
+  void SetUninitializedType(const UninitializedReferenceType* uninitialized_type) const {
+    uninitialized_type_ = uninitialized_type;
   }
+
+  void CheckClassDescriptor() const REQUIRES_SHARED(Locks::mutator_lock_);
+
+ private:
+  const Handle<mirror::Class> klass_;
+
+  // The corresponding uninitialized type created from this type for a `new-instance` instruction.
+  // This member is mutable because it's a part of the type cache, not part of the type itself.
+  mutable const UninitializedReferenceType* uninitialized_type_;
 };
 
-// A type of register holding a reference to an Object of type GetClass and only
-// an object of that
-// type.
-class PreciseReferenceType final : public RegType {
+// Similar to ReferenceType but not yet having been passed to a constructor.
+class UninitializedReferenceType final : public UninitializedType {
  public:
-  PreciseReferenceType(Handle<mirror::Class> klass,
-                       const std::string_view& descriptor,
-                       uint16_t cache_id)
+  constexpr UninitializedReferenceType(uint16_t cache_id, const RegType* initialized_type)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  bool IsPreciseReference() const override { return true; }
-
-  bool IsNonZeroReferenceTypes() const override { return true; }
+  const RegType* GetInitializedType() const {
+    return initialized_type_;
+  }
 
-  bool HasClassVirtual() const override { return true; }
+ private:
+  // The corresponding initialized type to transition to after a constructor call.
+  const RegType* const initialized_type_;
+};
 
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+// Similar to UninitializedReferenceType but special case for the this argument
+// of a constructor.
+class UninitializedThisReferenceType final : public UninitializedType {
+ public:
+  UninitializedThisReferenceType(uint16_t cache_id, const ReferenceType* initialized_type)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : UninitializedType(initialized_type->GetDescriptor(),
+                          cache_id,
+                          Kind::kUninitializedThisReference),
+        initialized_type_(initialized_type) {
+    CheckConstructorInvariants(this);
+  }
 
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kReference;
+  const ReferenceType* GetInitializedType() const {
+    return initialized_type_;
   }
+
+ private:
+  // The corresponding initialized type to transition to after a constructor call.
+  const ReferenceType* initialized_type_;
 };
 
 // Common parent of unresolved types.
 class UnresolvedType : public RegType {
  public:
-  UnresolvedType(Handle<mirror::Class> klass,
-                 const std::string_view& descriptor,
-                 uint16_t cache_id)
+  UnresolvedType(const std::string_view& descriptor, uint16_t cache_id, Kind kind)
       REQUIRES_SHARED(Locks::mutator_lock_)
-      : RegType(klass, descriptor, cache_id) {}
-
-  bool IsNonZeroReferenceTypes() const override;
-
-  AssignmentType GetAssignmentTypeImpl() const override {
-    return AssignmentType::kReference;
-  }
+      : RegType(descriptor, cache_id, kind) {}
 };
 
 // Similar to ReferenceType except the Class couldn't be loaded. Assignability
@@ -940,65 +585,80 @@ class UnresolvedType : public RegType {
 // of this type must be conservative.
 class UnresolvedReferenceType final : public UnresolvedType {
  public:
-  UnresolvedReferenceType(Handle<mirror::Class> cls,
-                          const std::string_view& descriptor,
-                          uint16_t cache_id)
+  UnresolvedReferenceType(const std::string_view& descriptor, uint16_t cache_id)
       REQUIRES_SHARED(Locks::mutator_lock_)
-      : UnresolvedType(cls, descriptor, cache_id) {
+      : UnresolvedType(descriptor, cache_id, Kind::kUnresolvedReference),
+        uninitialized_type_(nullptr) {
     CheckConstructorInvariants(this);
   }
 
-  bool IsUnresolvedReference() const override { return true; }
-
-  bool IsUnresolvedTypes() const override { return true; }
+  const UnresolvedUninitializedReferenceType* GetUninitializedType() const {
+    return uninitialized_type_;
+  }
 
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  void SetUninitializedType(const UnresolvedUninitializedReferenceType* uninitialized_type) const {
+    uninitialized_type_ = uninitialized_type;
+  }
 
  private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
+  // The corresponding uninitialized type created from this type for a `new-instance` instruction.
+  // This member is mutable because it's a part of the type cache, not part of the type itself.
+  mutable const UnresolvedUninitializedReferenceType* uninitialized_type_;
 };
 
-// Type representing the super-class of an unresolved type.
-class UnresolvedSuperClass final : public UnresolvedType {
+// Similar to UnresolvedReferenceType but not yet having been passed to a
+// constructor.
+class UnresolvedUninitializedReferenceType final : public UninitializedType {
  public:
-  UnresolvedSuperClass(Handle<mirror::Class> cls,
-                       uint16_t child_id,
-                       RegTypeCache* reg_type_cache,
-                       uint16_t cache_id)
+  UnresolvedUninitializedReferenceType(uint16_t cache_id,
+                                       const UnresolvedReferenceType* initialized_type)
       REQUIRES_SHARED(Locks::mutator_lock_)
-      : UnresolvedType(cls, "", cache_id),
-        unresolved_child_id_(child_id),
-        reg_type_cache_(reg_type_cache) {
+      : UninitializedType(initialized_type->GetDescriptor(),
+                          cache_id,
+                          Kind::kUnresolvedUninitializedReference),
+        initialized_type_(initialized_type) {
     CheckConstructorInvariants(this);
   }
 
-  bool IsUnresolvedSuperClass() const override { return true; }
+  const UnresolvedReferenceType* GetInitializedType() const {
+    return initialized_type_;
+  }
 
-  bool IsUnresolvedTypes() const override { return true; }
+ private:
+  // The corresponding initialized type to transition to after a constructor call.
+  const UnresolvedReferenceType* const initialized_type_;
+};
 
-  uint16_t GetUnresolvedSuperClassChildId() const {
-    DCHECK(IsUnresolvedSuperClass());
-    return static_cast<uint16_t>(unresolved_child_id_ & 0xFFFF);
+class UnresolvedUninitializedThisReferenceType final : public UninitializedType {
+ public:
+  UnresolvedUninitializedThisReferenceType(uint16_t cache_id,
+                                           const UnresolvedReferenceType* initialized_type)
+      REQUIRES_SHARED(Locks::mutator_lock_)
+      : UninitializedType(initialized_type->GetDescriptor(),
+                          cache_id,
+                          Kind::kUnresolvedUninitializedThisReference),
+        initialized_type_(initialized_type) {
+    CheckConstructorInvariants(this);
   }
 
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  const UnresolvedReferenceType* GetInitializedType() const {
+    return initialized_type_;
+  }
 
  private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
-
-  const uint16_t unresolved_child_id_;
-  const RegTypeCache* const reg_type_cache_;
+  // The corresponding initialized type to transition to after a constructor call.
+  const UnresolvedReferenceType* initialized_type_;
 };
 
 // A merge of unresolved (and resolved) types. If the types were resolved this may be
 // Conflict or another known ReferenceType.
-class UnresolvedMergedType final : public UnresolvedType {
+class UnresolvedMergedReferenceType final : public UnresolvedType {
  public:
   // Note: the constructor will copy the unresolved BitVector, not use it directly.
-  UnresolvedMergedType(const RegType& resolved,
-                       const BitVector& unresolved,
-                       const RegTypeCache* reg_type_cache,
-                       uint16_t cache_id)
+  UnresolvedMergedReferenceType(const RegType& resolved,
+                                const BitVector& unresolved,
+                                const RegTypeCache* reg_type_cache,
+                                uint16_t cache_id)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // The resolved part. See description below.
@@ -1010,19 +670,14 @@ class UnresolvedMergedType final : public UnresolvedType {
     return unresolved_types_;
   }
 
-  bool IsUnresolvedMergedReference() const override { return true; }
-
-  bool IsUnresolvedTypes() const override { return true; }
-
-  bool IsArrayTypes() const override REQUIRES_SHARED(Locks::mutator_lock_);
-  bool IsObjectArrayTypes() const override REQUIRES_SHARED(Locks::mutator_lock_);
-
-  std::string Dump() const override REQUIRES_SHARED(Locks::mutator_lock_);
+  bool IsArrayTypesImpl() const REQUIRES_SHARED(Locks::mutator_lock_);
+  bool IsObjectArrayTypesImpl() const REQUIRES_SHARED(Locks::mutator_lock_);
+  std::string DumpImpl() const REQUIRES_SHARED(Locks::mutator_lock_);
 
   const RegTypeCache* GetRegTypeCache() const { return reg_type_cache_; }
 
  private:
-  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_) override;
+  void CheckInvariants() const REQUIRES_SHARED(Locks::mutator_lock_);
 
   const RegTypeCache* const reg_type_cache_;
 
@@ -1040,6 +695,220 @@ class UnresolvedMergedType final : public UnresolvedType {
 std::ostream& operator<<(std::ostream& os, const RegType& rhs)
     REQUIRES_SHARED(Locks::mutator_lock_);
 
+namespace detail {
+
+template <class ConcreteRegType>
+struct RegTypeToKind { /* No `kind` defined in unspecialized template. */ };
+
+#define DEFINE_REG_TYPE_TO_KIND(name) \
+  template<> struct RegTypeToKind<name##Type> { \
+    static constexpr RegType::Kind kind = RegType::Kind::k##name; \
+  };
+FOR_EACH_CONCRETE_REG_TYPE(DEFINE_REG_TYPE_TO_KIND);
+#undef DEFINE_REG_TYPE_TO_KIND
+
+template <template <class ConcreteRegType> class Traits>
+constexpr bool EvaluateTrait(RegType::Kind kind) {
+  switch (kind) {
+#define DEFINE_EVALUATE_TRAIT_CASE(name) \
+    case RegType::Kind::k##name:         \
+      return Traits<name##Type>::value;
+    FOR_EACH_CONCRETE_REG_TYPE(DEFINE_EVALUATE_TRAIT_CASE);
+#undef DEFINE_EVALUATE_TRAIT_CASE
+  }
+}
+
+template <class ConcreteRegType>
+struct IsUninitializedTypes
+    : std::bool_constant<std::is_base_of_v<UninitializedType, ConcreteRegType>> {};
+
+template <class ConcreteRegType>
+struct IsUnresolvedTypes : std::bool_constant<
+    std::is_base_of_v<UnresolvedType, ConcreteRegType> ||
+    // Unresolved uninitialized types do not inherit `UnresolvedType`.
+    // (We're using single-inheritance and they inherit `UninitializedType`.)
+    std::is_same_v<UnresolvedUninitializedReferenceType, ConcreteRegType> ||
+    std::is_same_v<UnresolvedUninitializedThisReferenceType, ConcreteRegType>> {};
+
+template <class ConcreteRegType>
+struct IsNonZeroReferenceTypes
+    : std::bool_constant<std::is_same_v<JavaLangObjectType, ConcreteRegType> ||
+                         std::is_same_v<ReferenceType, ConcreteRegType> ||
+                         std::is_base_of_v<UnresolvedType, ConcreteRegType> ||
+                         std::is_base_of_v<UninitializedType, ConcreteRegType>> {};
+
+}  // namespace detail
+
+template <typename Class>
+inline constexpr void RegType::CheckConstructorInvariants([[maybe_unused]] Class* this_) const {
+  static_assert(std::is_final<Class>::value, "Class must be final.");
+  DCHECK_EQ(GetKind(), detail::RegTypeToKind<Class>::kind);
+  if constexpr (std::is_same_v<Class, UndefinedType> ||
+                std::is_same_v<Class, ConflictType> ||
+                std::is_same_v<Class, NullType> ||
+                std::is_base_of_v<ConstantType, Class>) {
+    DCHECK(descriptor_.empty()) << *this;
+  } else if constexpr (std::is_base_of_v<PrimitiveType, Class>) {
+    DCHECK_EQ(descriptor_.length(), 1u) << *this;
+  } else if constexpr (std::is_same_v<Class, JavaLangObjectType>) {
+    DCHECK(!descriptor_.empty()) << *this;
+  } else if constexpr (std::is_same_v<Class, UnresolvedMergedReferenceType>) {
+    // `UnresolvedMergedReferenceType` is an unresolved type but it has an empty descriptor.
+    DCHECK(descriptor_.empty()) << *this;
+  } else if constexpr (detail::IsUnresolvedTypes<Class>::value ||  // NOLINT
+                       std::is_base_of_v<UninitializedType, Class>) {
+    DCHECK(!descriptor_.empty()) << *this;
+  } else if (kIsDebugBuild) {
+    CHECK(IsReference());
+    down_cast<const ReferenceType&>(*this).CheckClassDescriptor();
+  }
+}
+
+constexpr UndefinedType::UndefinedType(uint16_t cache_id)
+    : RegType("", cache_id, Kind::kUndefined) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ConflictType::ConflictType(uint16_t cache_id)
+    : RegType("", cache_id, Kind::kConflict) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr IntegerType::IntegerType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kInteger) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr BooleanType::BooleanType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kBoolean) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ByteType::ByteType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kByte) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ShortType::ShortType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kShort) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr CharType::CharType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kChar) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr FloatType::FloatType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat1Type(descriptor, cache_id, Kind::kFloat) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr LongLoType::LongLoType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat2Type(descriptor, cache_id, Kind::kLongLo) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr LongHiType::LongHiType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat2Type(descriptor, cache_id, Kind::kLongHi) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr DoubleLoType::DoubleLoType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat2Type(descriptor, cache_id, Kind::kDoubleLo) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr DoubleHiType::DoubleHiType(const std::string_view& descriptor, uint16_t cache_id)
+    : Cat2Type(descriptor, cache_id, Kind::kDoubleHi) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ZeroType::ZeroType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kZero) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr BooleanConstantType::BooleanConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kBooleanConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr PositiveByteConstantType::PositiveByteConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kPositiveByteConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr PositiveShortConstantType::PositiveShortConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kPositiveShortConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr CharConstantType::CharConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kCharConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ByteConstantType::ByteConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kByteConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ShortConstantType::ShortConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kShortConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr IntegerConstantType::IntegerConstantType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kIntegerConstant) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ConstantLoType::ConstantLoType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kConstantLo) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr ConstantHiType::ConstantHiType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kConstantHi) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr NullType::NullType(uint16_t cache_id)
+    : ConstantType(cache_id, Kind::kNull) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr JavaLangObjectType::JavaLangObjectType(
+    std::string_view descriptor,
+    uint16_t cache_id,
+    const UninitializedReferenceType* uninitialized_type)
+    : RegType(descriptor, cache_id, Kind::kJavaLangObject),
+      uninitialized_type_(uninitialized_type) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr UninitializedReferenceType::UninitializedReferenceType(uint16_t cache_id,
+                                                                 const RegType* initialized_type)
+    : UninitializedType(initialized_type->GetDescriptor(),
+                        cache_id,
+                        Kind::kUninitializedReference),
+      initialized_type_(initialized_type) {
+  CheckConstructorInvariants(this);
+}
+
+constexpr bool RegType::IsNonZeroReferenceTypes() const {
+  return detail::EvaluateTrait<detail::IsNonZeroReferenceTypes>(GetKind());
+}
+
+constexpr bool RegType::IsUninitializedTypes() const {
+  return detail::EvaluateTrait<detail::IsUninitializedTypes>(GetKind());
+}
+
+constexpr bool RegType::IsUnresolvedTypes() const {
+  return detail::EvaluateTrait<detail::IsUnresolvedTypes>(GetKind());
+}
+
 }  // namespace verifier
 }  // namespace art
 
diff --git a/runtime/verifier/reg_type_cache-inl.h b/runtime/verifier/reg_type_cache-inl.h
index addf958472..10114c2f0f 100644
--- a/runtime/verifier/reg_type_cache-inl.h
+++ b/runtime/verifier/reg_type_cache-inl.h
@@ -18,8 +18,8 @@
 #define ART_RUNTIME_VERIFIER_REG_TYPE_CACHE_INL_H_
 
 #include "base/bit_vector-inl.h"
-#include "class_linker.h"
 #include "class_root-inl.h"
+#include "dex/dex_file.h"
 #include "mirror/class-inl.h"
 #include "mirror/method_handle_impl.h"
 #include "mirror/method_type.h"
@@ -38,143 +38,191 @@ inline const art::verifier::RegType& RegTypeCache::GetFromId(uint16_t id) const
   return *result;
 }
 
-inline const ConstantType& RegTypeCache::FromCat1Const(int32_t value, bool precise) {
-  // We only expect 0 to be a precise constant.
-  DCHECK_IMPLIES(value == 0, precise);
-  if (precise && (value >= kMinSmallConstant) && (value <= kMaxSmallConstant)) {
-    return *down_cast<const ConstantType*>(entries_[value - kMinSmallConstant]);
+namespace detail {
+
+struct RegKindToCacheId : RegTypeCache {
+  // Inherit fixed cache ids from `RegTypeCache` and add fake non-fixed cache ids so that
+  // we can use `FOR_EACH_CONCRETE_REG_TYPE` to check the fixed cache ids.
+#define DEFINE_FAKE_CACHE_ID(name)                                    \
+  static_assert(RegType::Kind::k##name >= kNumberOfRegKindCacheIds);  \
+  static constexpr uint32_t k##name##CacheId = RegType::Kind::k##name;
+  DEFINE_FAKE_CACHE_ID(UnresolvedReference)
+  DEFINE_FAKE_CACHE_ID(UninitializedReference)
+  DEFINE_FAKE_CACHE_ID(UninitializedThisReference)
+  DEFINE_FAKE_CACHE_ID(UnresolvedUninitializedReference)
+  DEFINE_FAKE_CACHE_ID(UnresolvedUninitializedThisReference)
+  DEFINE_FAKE_CACHE_ID(UnresolvedMergedReference)
+  DEFINE_FAKE_CACHE_ID(Reference)
+#undef DEFINE_FAKE_CACHE_ID
+
+#define ASSERT_CACHE_ID_EQUALS_KIND(name) \
+  static_assert(k##name##CacheId == RegType::Kind::k##name);
+  FOR_EACH_CONCRETE_REG_TYPE(ASSERT_CACHE_ID_EQUALS_KIND);
+#undef ASSERT_CACHE_ID_EQUALS_KIND
+
+  static constexpr uint16_t Translate(RegType::Kind kind) {
+    DCHECK_LT(kind, kNumberOfRegKindCacheIds);
+    return kind;
   }
-  return FromCat1NonSmallConstant(value, precise);
+};
+
+}  // namespace detail
+
+constexpr uint16_t RegTypeCache::IdForRegKind(RegType::Kind kind) {
+  return detail::RegKindToCacheId::Translate(kind);
+}
+
+constexpr RegType::Kind RegTypeCache::RegKindForId(uint16_t id) {
+  DCHECK_LT(id, NumberOfRegKindCacheIds());
+  RegType::Kind kind = enum_cast<RegType::Kind>(id);
+  DCHECK_EQ(id, IdForRegKind(kind));
+  return kind;
+}
+
+inline const RegType& RegTypeCache::GetFromRegKind(RegType::Kind kind) const {
+  return GetFromId(IdForRegKind(kind));
 }
 
-inline const BooleanType& RegTypeCache::Boolean() {
+inline const RegType& RegTypeCache::FromTypeIndex(dex::TypeIndex type_index) {
+  DCHECK_LT(type_index.index_, dex_file_->NumTypeIds());
+  if (ids_for_type_index_[type_index.index_] != kNoIdForTypeIndex) {
+    return GetFromId(ids_for_type_index_[type_index.index_]);
+  }
+  return FromTypeIndexUncached(type_index);
+}
+
+inline const BooleanType& RegTypeCache::Boolean() const {
   return *down_cast<const BooleanType*>(entries_[kBooleanCacheId]);
 }
-inline const ByteType& RegTypeCache::Byte() {
+
+inline const ByteType& RegTypeCache::Byte() const {
   return *down_cast<const ByteType*>(entries_[kByteCacheId]);
 }
-inline const CharType& RegTypeCache::Char() {
+
+inline const CharType& RegTypeCache::Char() const {
   return *down_cast<const CharType*>(entries_[kCharCacheId]);
 }
-inline const ShortType& RegTypeCache::Short() {
+
+inline const ShortType& RegTypeCache::Short() const {
   return *down_cast<const ShortType*>(entries_[kShortCacheId]);
 }
-inline const IntegerType& RegTypeCache::Integer() {
-  return *down_cast<const IntegerType*>(entries_[kIntCacheId]);
+
+inline const IntegerType& RegTypeCache::Integer() const {
+  return *down_cast<const IntegerType*>(entries_[kIntegerCacheId]);
 }
-inline const FloatType& RegTypeCache::Float() {
+
+inline const FloatType& RegTypeCache::Float() const {
   return *down_cast<const FloatType*>(entries_[kFloatCacheId]);
 }
-inline const LongLoType& RegTypeCache::LongLo() {
+
+inline const LongLoType& RegTypeCache::LongLo() const {
   return *down_cast<const LongLoType*>(entries_[kLongLoCacheId]);
 }
-inline const LongHiType& RegTypeCache::LongHi() {
+
+inline const LongHiType& RegTypeCache::LongHi() const {
   return *down_cast<const LongHiType*>(entries_[kLongHiCacheId]);
 }
-inline const DoubleLoType& RegTypeCache::DoubleLo() {
+
+inline const DoubleLoType& RegTypeCache::DoubleLo() const {
   return *down_cast<const DoubleLoType*>(entries_[kDoubleLoCacheId]);
 }
-inline const DoubleHiType& RegTypeCache::DoubleHi() {
+
+inline const DoubleHiType& RegTypeCache::DoubleHi() const {
   return *down_cast<const DoubleHiType*>(entries_[kDoubleHiCacheId]);
 }
-inline const UndefinedType& RegTypeCache::Undefined() {
+
+inline const UndefinedType& RegTypeCache::Undefined() const {
   return *down_cast<const UndefinedType*>(entries_[kUndefinedCacheId]);
 }
-inline const ConflictType& RegTypeCache::Conflict() {
+
+inline const ConflictType& RegTypeCache::Conflict() const {
   return *down_cast<const ConflictType*>(entries_[kConflictCacheId]);
 }
-inline const NullType& RegTypeCache::Null() {
+
+inline const NullType& RegTypeCache::Null() const {
   return *down_cast<const NullType*>(entries_[kNullCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::ByteConstant() {
-  const ConstantType& result = FromCat1Const(std::numeric_limits<jbyte>::min(), false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const ZeroType& RegTypeCache::Zero() const {
+  return *down_cast<const ZeroType*>(entries_[kZeroCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::CharConstant() {
-  int32_t jchar_max = static_cast<int32_t>(std::numeric_limits<jchar>::max());
-  const ConstantType& result =  FromCat1Const(jchar_max, false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const BooleanConstantType& RegTypeCache::BooleanConstant() const {
+  return *down_cast<const BooleanConstantType*>(entries_[kBooleanConstantCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::ShortConstant() {
-  const ConstantType& result =  FromCat1Const(std::numeric_limits<jshort>::min(), false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const ByteConstantType& RegTypeCache::ByteConstant() const {
+  return *down_cast<const ByteConstantType*>(entries_[kByteConstantCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::IntConstant() {
-  const ConstantType& result = FromCat1Const(std::numeric_limits<jint>::max(), false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const CharConstantType& RegTypeCache::CharConstant() const {
+  return *down_cast<const CharConstantType*>(entries_[kCharConstantCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::PosByteConstant() {
-  const ConstantType& result = FromCat1Const(std::numeric_limits<jbyte>::max(), false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const ShortConstantType& RegTypeCache::ShortConstant() const {
+  return *down_cast<const ShortConstantType*>(entries_[kShortConstantCacheId]);
 }
 
-inline const ImpreciseConstType& RegTypeCache::PosShortConstant() {
-  const ConstantType& result =  FromCat1Const(std::numeric_limits<jshort>::max(), false);
-  DCHECK(result.IsImpreciseConstant());
-  return *down_cast<const ImpreciseConstType*>(&result);
+inline const IntegerConstantType& RegTypeCache::IntegerConstant() const {
+  return *down_cast<const IntegerConstantType*>(entries_[kIntegerConstantCacheId]);
 }
 
-inline const PreciseReferenceType& RegTypeCache::JavaLangClass() {
-  const RegType* result = &FromClass("Ljava/lang/Class;",
-                                     GetClassRoot<mirror::Class>(),
-                                     /* precise= */ true);
-  DCHECK(result->IsPreciseReference());
-  return *down_cast<const PreciseReferenceType*>(result);
+inline const PositiveByteConstantType& RegTypeCache::PositiveByteConstant() const {
+  return *down_cast<const PositiveByteConstantType*>(entries_[kPositiveByteConstantCacheId]);
 }
 
-inline const PreciseReferenceType& RegTypeCache::JavaLangString() {
-  // String is final and therefore always precise.
-  const RegType* result = &FromClass("Ljava/lang/String;",
-                                     GetClassRoot<mirror::String>(),
-                                     /* precise= */ true);
-  DCHECK(result->IsPreciseReference());
-  return *down_cast<const PreciseReferenceType*>(result);
+inline const PositiveShortConstantType& RegTypeCache::PositiveShortConstant() const {
+  return *down_cast<const PositiveShortConstantType*>(entries_[kPositiveShortConstantCacheId]);
 }
 
-inline const PreciseReferenceType& RegTypeCache::JavaLangInvokeMethodHandle() {
-  const RegType* result = &FromClass("Ljava/lang/invoke/MethodHandle;",
-                                     GetClassRoot<mirror::MethodHandle>(),
-                                     /* precise= */ true);
-  DCHECK(result->IsPreciseReference());
-  return *down_cast<const PreciseReferenceType*>(result);
+inline const ConstantLoType& RegTypeCache::ConstantLo() const {
+  return *down_cast<const ConstantLoType*>(entries_[kConstantLoCacheId]);
 }
 
-inline const PreciseReferenceType& RegTypeCache::JavaLangInvokeMethodType() {
-  const RegType* result = &FromClass("Ljava/lang/invoke/MethodType;",
-                                     GetClassRoot<mirror::MethodType>(),
-                                     /* precise= */ true);
-  DCHECK(result->IsPreciseReference());
-  return *down_cast<const PreciseReferenceType*>(result);
+inline const ConstantHiType& RegTypeCache::ConstantHi() const {
+  return *down_cast<const ConstantHiType*>(entries_[kConstantHiCacheId]);
 }
 
-inline const RegType& RegTypeCache::JavaLangThrowable() {
-  const RegType* result = &FromClass("Ljava/lang/Throwable;",
-                                     GetClassRoot<mirror::Throwable>(),
-                                     /* precise= */ false);
+inline const ReferenceType& RegTypeCache::JavaLangClass() {
+  const RegType* result = &FromClass(GetClassRoot<mirror::Class>());
+  DCHECK(result->GetClass()->DescriptorEquals("Ljava/lang/Class;"));
   DCHECK(result->IsReference());
-  DCHECK(!result->IsPreciseReference());
   return *down_cast<const ReferenceType*>(result);
 }
 
-inline const RegType& RegTypeCache::JavaLangObject(bool precise) {
-  const RegType* result = &FromClass("Ljava/lang/Object;", GetClassRoot<mirror::Object>(), precise);
-  if (precise) {
-    DCHECK(result->IsPreciseReference());
-    return *down_cast<const PreciseReferenceType*>(result);
-  } else {
-    DCHECK(result->IsReference());
-    return *down_cast<const ReferenceType*>(result);
-  }
+inline const ReferenceType& RegTypeCache::JavaLangString() {
+  const RegType* result = &FromClass(GetClassRoot<mirror::String>());
+  DCHECK(result->GetClass()->DescriptorEquals("Ljava/lang/String;"));
+  DCHECK(result->IsReference());
+  return *down_cast<const ReferenceType*>(result);
+}
+
+inline const ReferenceType& RegTypeCache::JavaLangInvokeMethodHandle() {
+  const RegType* result = &FromClass(GetClassRoot<mirror::MethodHandle>());
+  DCHECK(result->GetClass()->DescriptorEquals("Ljava/lang/invoke/MethodHandle;"));
+  DCHECK(result->IsReference());
+  return *down_cast<const ReferenceType*>(result);
+}
+
+inline const ReferenceType& RegTypeCache::JavaLangInvokeMethodType() {
+  const RegType* result = &FromClass(GetClassRoot<mirror::MethodType>());
+  DCHECK(result->GetClass()->DescriptorEquals("Ljava/lang/invoke/MethodType;"));
+  DCHECK(result->IsReference());
+  return *down_cast<const ReferenceType*>(result);
+}
+
+inline const ReferenceType& RegTypeCache::JavaLangThrowable() {
+  const RegType* result = &FromClass(GetClassRoot<mirror::Throwable>());
+  DCHECK(result->GetClass()->DescriptorEquals("Ljava/lang/Throwable;"));
+  DCHECK(result->IsReference());
+  return *down_cast<const ReferenceType*>(result);
+}
+
+inline const JavaLangObjectType& RegTypeCache::JavaLangObject() {
+  const RegType& result = GetFromId(kJavaLangObjectCacheId);
+  DCHECK_EQ(result.GetDescriptor(), "Ljava/lang/Object;");
+  DCHECK(result.IsJavaLangObject());
+  return down_cast<const JavaLangObjectType&>(result);
 }
 
 template <class RegTypeType>
diff --git a/runtime/verifier/reg_type_cache.cc b/runtime/verifier/reg_type_cache.cc
index 71a6f3f318..3b69307468 100644
--- a/runtime/verifier/reg_type_cache.cc
+++ b/runtime/verifier/reg_type_cache.cc
@@ -35,57 +35,60 @@
 namespace art HIDDEN {
 namespace verifier {
 
-ALWAYS_INLINE static inline bool MatchingPrecisionForClass(const RegType* entry, bool precise)
-    REQUIRES_SHARED(Locks::mutator_lock_) {
-  if (entry->IsPreciseReference() == precise) {
-    // We were or weren't looking for a precise reference and we found what we need.
-    return true;
-  } else {
-    if (!precise && entry->GetClass()->CannotBeAssignedFromOtherTypes()) {
-      // We weren't looking for a precise reference, as we're looking up based on a descriptor, but
-      // we found a matching entry based on the descriptor. Return the precise entry in that case.
-      return true;
-    }
-    return false;
-  }
-}
-
-void RegTypeCache::FillPrimitiveAndSmallConstantTypes() {
-  entries_.resize(kNumPrimitivesAndSmallConstants);
-  for (int32_t value = kMinSmallConstant; value <= kMaxSmallConstant; ++value) {
-    int32_t i = value - kMinSmallConstant;
-    entries_[i] = new (&allocator_) PreciseConstType(null_handle_, value, i);
-  }
-
-#define CREATE_PRIMITIVE_TYPE(type, class_root, descriptor, id) \
-  entries_[id] = new (&allocator_) type( \
-        handles_.NewHandle(GetClassRoot(class_root, class_linker_)), \
-        descriptor, \
-        id); \
-
-  CREATE_PRIMITIVE_TYPE(BooleanType, ClassRoot::kPrimitiveBoolean, "Z", kBooleanCacheId);
-  CREATE_PRIMITIVE_TYPE(ByteType, ClassRoot::kPrimitiveByte, "B", kByteCacheId);
-  CREATE_PRIMITIVE_TYPE(ShortType, ClassRoot::kPrimitiveShort, "S", kShortCacheId);
-  CREATE_PRIMITIVE_TYPE(CharType, ClassRoot::kPrimitiveChar, "C", kCharCacheId);
-  CREATE_PRIMITIVE_TYPE(IntegerType, ClassRoot::kPrimitiveInt, "I", kIntCacheId);
-  CREATE_PRIMITIVE_TYPE(LongLoType, ClassRoot::kPrimitiveLong, "J", kLongLoCacheId);
-  CREATE_PRIMITIVE_TYPE(LongHiType, ClassRoot::kPrimitiveLong, "J", kLongHiCacheId);
-  CREATE_PRIMITIVE_TYPE(FloatType, ClassRoot::kPrimitiveFloat, "F", kFloatCacheId);
-  CREATE_PRIMITIVE_TYPE(DoubleLoType, ClassRoot::kPrimitiveDouble, "D", kDoubleLoCacheId);
-  CREATE_PRIMITIVE_TYPE(DoubleHiType, ClassRoot::kPrimitiveDouble, "D", kDoubleHiCacheId);
-
+void RegTypeCache::FillPrimitiveAndConstantTypes() {
+  entries_.resize(kNumberOfFixedCacheIds);
+  ArrayRef<const RegType*> entries(entries_);
+
+  static constexpr UndefinedType constUndefinedType(kUndefinedCacheId);
+  entries[kUndefinedCacheId] = &constUndefinedType;
+  static constexpr ConflictType constConflictType(kConflictCacheId);
+  entries[kConflictCacheId] = &constConflictType;
+
+#define CREATE_PRIMITIVE_TYPE(name, descriptor) \
+  static constexpr name##Type const##name(descriptor, k##name##CacheId); \
+  entries[k##name##CacheId] = &const##name;
+  CREATE_PRIMITIVE_TYPE(Boolean, "Z");
+  CREATE_PRIMITIVE_TYPE(Byte, "B");
+  CREATE_PRIMITIVE_TYPE(Short, "S");
+  CREATE_PRIMITIVE_TYPE(Char, "C");
+  CREATE_PRIMITIVE_TYPE(Integer, "I");
+  CREATE_PRIMITIVE_TYPE(LongLo, "J");
+  CREATE_PRIMITIVE_TYPE(LongHi, "J");
+  CREATE_PRIMITIVE_TYPE(Float, "F");
+  CREATE_PRIMITIVE_TYPE(DoubleLo, "D");
+  CREATE_PRIMITIVE_TYPE(DoubleHi, "D");
 #undef CREATE_PRIMITIVE_TYPE
 
-  entries_[kUndefinedCacheId] =
-      new (&allocator_) UndefinedType(null_handle_, "", kUndefinedCacheId);
-  entries_[kConflictCacheId] =
-      new (&allocator_) ConflictType(null_handle_, "", kConflictCacheId);
-  entries_[kNullCacheId] =
-      new (&allocator_) NullType(null_handle_, "", kNullCacheId);
+#define CREATE_CONSTANT_TYPE(name) \
+  static constexpr name##Type const##name(k##name##CacheId); \
+  entries[k##name##CacheId] = &const##name;
+  CREATE_CONSTANT_TYPE(Zero);
+  CREATE_CONSTANT_TYPE(BooleanConstant);
+  CREATE_CONSTANT_TYPE(PositiveByteConstant);
+  CREATE_CONSTANT_TYPE(PositiveShortConstant);
+  CREATE_CONSTANT_TYPE(CharConstant);
+  CREATE_CONSTANT_TYPE(ByteConstant);
+  CREATE_CONSTANT_TYPE(ShortConstant);
+  CREATE_CONSTANT_TYPE(IntegerConstant);
+  CREATE_CONSTANT_TYPE(ConstantLo);
+  CREATE_CONSTANT_TYPE(ConstantHi);
+  CREATE_CONSTANT_TYPE(Null);
+#undef CREATE_CONSTANT_TYPE
+
+  // `JavaLangObjectType` must be initialized together with its uninitialized type.
+  struct JavaLangObjectPair {
+    constexpr JavaLangObjectPair()
+        : initialized("Ljava/lang/Object;", kJavaLangObjectCacheId, &uninitialized),
+          uninitialized(kUninitializedJavaLangObjectCacheId, &initialized) {}
+    JavaLangObjectType initialized;
+    UninitializedReferenceType uninitialized;
+  };
+  static constexpr JavaLangObjectPair constJavaLangObject;
+  entries[kJavaLangObjectCacheId] = &constJavaLangObject.initialized;
+  entries[kUninitializedJavaLangObjectCacheId] = &constJavaLangObject.uninitialized;
 }
 
-const RegType& RegTypeCache::FromDescriptor(Handle<mirror::ClassLoader> loader,
-                                            const char* descriptor) {
+const RegType& RegTypeCache::FromDescriptor(const char* descriptor) {
   if (descriptor[1] == '\0') {
     switch (descriptor[0]) {
       case 'Z':
@@ -109,61 +112,64 @@ const RegType& RegTypeCache::FromDescriptor(Handle<mirror::ClassLoader> loader,
         return Conflict();
     }
   } else if (descriptor[0] == 'L' || descriptor[0] == '[') {
-    return From(loader, descriptor);
+    return From(descriptor);
   } else {
     return Conflict();
   }
 }
 
+const RegType& RegTypeCache::FromTypeIndexUncached(dex::TypeIndex type_index) {
+  DCHECK_EQ(ids_for_type_index_[type_index.index_], kNoIdForTypeIndex);
+  const char* descriptor = dex_file_->GetTypeDescriptor(type_index);
+  const RegType& reg_type = FromDescriptor(descriptor);
+  DCHECK_NE(reg_type.GetId(), kNoIdForTypeIndex);
+  ids_for_type_index_[type_index.index_] = reg_type.GetId();
+  return reg_type;
+}
 
 const RegType& RegTypeCache::RegTypeFromPrimitiveType(Primitive::Type prim_type) const {
   switch (prim_type) {
     case Primitive::kPrimBoolean:
-      return *entries_[kBooleanCacheId];
+      return Boolean();
     case Primitive::kPrimByte:
-      return *entries_[kByteCacheId];
+      return Byte();
     case Primitive::kPrimShort:
-      return *entries_[kShortCacheId];
+      return Short();
     case Primitive::kPrimChar:
-      return *entries_[kCharCacheId];
+      return Char();
     case Primitive::kPrimInt:
-      return *entries_[kIntCacheId];
+      return Integer();
     case Primitive::kPrimLong:
-      return *entries_[kLongLoCacheId];
+      return LongLo();
     case Primitive::kPrimFloat:
-      return *entries_[kFloatCacheId];
+      return Float();
     case Primitive::kPrimDouble:
-      return *entries_[kDoubleLoCacheId];
+      return DoubleLo();
     case Primitive::kPrimVoid:
     default:
       return *entries_[kConflictCacheId];
   }
 }
 
-bool RegTypeCache::MatchDescriptor(size_t idx, const std::string_view& descriptor, bool precise) {
+bool RegTypeCache::MatchDescriptor(size_t idx, const std::string_view& descriptor) {
   const RegType* entry = entries_[idx];
   if (descriptor != entry->descriptor_) {
     return false;
   }
-  if (entry->HasClass()) {
-    return MatchingPrecisionForClass(entry, precise);
-  }
-  // There is no notion of precise unresolved references, the precise information is just dropped
-  // on the floor.
-  DCHECK(entry->IsUnresolvedReference());
+  DCHECK(entry->IsJavaLangObject() || entry->IsReference() || entry->IsUnresolvedReference());
   return true;
 }
 
-ObjPtr<mirror::Class> RegTypeCache::ResolveClass(const char* descriptor,
-                                                 Handle<mirror::ClassLoader> loader) {
+ObjPtr<mirror::Class> RegTypeCache::ResolveClass(const char* descriptor, size_t descriptor_length) {
   // Class was not found, must create new type.
   // Try resolving class
   Thread* self = Thread::Current();
   ObjPtr<mirror::Class> klass = nullptr;
   if (can_load_classes_) {
-    klass = class_linker_->FindClass(self, descriptor, loader);
+    klass = class_linker_->FindClass(self, descriptor, descriptor_length, class_loader_);
   } else {
-    klass = class_linker_->LookupClass(self, descriptor, loader.Get());
+    std::string_view sv_descriptor(descriptor, descriptor_length);
+    klass = class_linker_->LookupClass(self, sv_descriptor, class_loader_.Get());
     if (klass != nullptr && !klass->IsResolved()) {
       // We found the class but without it being loaded its not safe for use.
       klass = nullptr;
@@ -178,37 +184,31 @@ std::string_view RegTypeCache::AddString(const std::string_view& str) {
   return std::string_view(ptr, str.length());
 }
 
-const RegType& RegTypeCache::From(Handle<mirror::ClassLoader> loader, const char* descriptor) {
+const RegType& RegTypeCache::From(const char* descriptor) {
+  // TODO: Avoid the implicit `strlen()` call for ASCII descriptors from the dex file.
   std::string_view sv_descriptor(descriptor);
   // Try looking up the class in the cache first. We use a std::string_view to avoid
   // repeated strlen operations on the descriptor.
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-    if (MatchDescriptor(i, sv_descriptor, /* precise= */ false)) {
+  if (MatchDescriptor(kJavaLangObjectCacheId, sv_descriptor)) {
+    return *(entries_[kJavaLangObjectCacheId]);
+  }
+  for (size_t i = kNumberOfFixedCacheIds; i < entries_.size(); i++) {
+    if (MatchDescriptor(i, sv_descriptor)) {
       return *(entries_[i]);
     }
   }
   // Class not found in the cache, will create a new type for that.
   // Try resolving class.
-  ObjPtr<mirror::Class> klass = ResolveClass(descriptor, loader);
+  ObjPtr<mirror::Class> klass = ResolveClass(descriptor, sv_descriptor.length());
+  // TODO: Avoid copying the `descriptor` with `AddString()` below if the `descriptor`
+  // comes from the dex file, for example through `FromTypeIndex()`.
   if (klass != nullptr) {
-    // Create a precise type if the class cannot be assigned from other types
-    // (final classes, arrays of final classes and primitive arrays, see
-    // `Class::CannotBeAssignedFromOtherTypes()`; primitive types should not
-    // reach this code).
     DCHECK(!klass->IsPrimitive());
-    RegType* entry;
-    // Create an imprecise type if we can't tell for a fact that it is precise.
-    if (klass->CannotBeAssignedFromOtherTypes()) {
-      DCHECK_IMPLIES(klass->IsAbstract(), klass->IsArrayClass());
-      DCHECK(!klass->IsInterface());
-      entry = new (&allocator_) PreciseReferenceType(handles_.NewHandle(klass),
-                                                     AddString(sv_descriptor),
-                                                     entries_.size());
-    } else {
-      entry = new (&allocator_) ReferenceType(handles_.NewHandle(klass),
-                                              AddString(sv_descriptor),
-                                              entries_.size());
+    if (klass->IsObjectClass()) {
+      return JavaLangObject();
     }
+    const RegType* entry = new (&allocator_) ReferenceType(
+        handles_.NewHandle(klass), AddString(sv_descriptor), entries_.size());
     return AddEntry(entry);
   } else {  // Class not resolved.
     // We tried loading the class and failed, this might get an exception raised
@@ -220,8 +220,7 @@ const RegType& RegTypeCache::From(Handle<mirror::ClassLoader> loader, const char
       DCHECK(!Thread::Current()->IsExceptionPending());
     }
     if (IsValidDescriptor(descriptor)) {
-      return AddEntry(new (&allocator_) UnresolvedReferenceType(null_handle_,
-                                                                AddString(sv_descriptor),
+      return AddEntry(new (&allocator_) UnresolvedReferenceType(AddString(sv_descriptor),
                                                                 entries_.size()));
     } else {
       // The descriptor is broken return the unknown type as there's nothing sensible that
@@ -233,76 +232,89 @@ const RegType& RegTypeCache::From(Handle<mirror::ClassLoader> loader, const char
 
 const RegType& RegTypeCache::MakeUnresolvedReference() {
   // The descriptor is intentionally invalid so nothing else will match this type.
-  return AddEntry(new (&allocator_) UnresolvedReferenceType(
-      null_handle_, AddString("a"), entries_.size()));
+  return AddEntry(new (&allocator_) UnresolvedReferenceType(AddString("a"), entries_.size()));
 }
 
-const RegType* RegTypeCache::FindClass(ObjPtr<mirror::Class> klass, bool precise) const {
+const RegType& RegTypeCache::FromClass(ObjPtr<mirror::Class> klass) {
   DCHECK(klass != nullptr);
+  DCHECK(!klass->IsProxyClass());
+
   if (klass->IsPrimitive()) {
-    // Note: precise isn't used for primitive classes. A char is assignable to an int. All
-    // primitive classes are final.
-    return &RegTypeFromPrimitiveType(klass->GetPrimitiveType());
+    return RegTypeFromPrimitiveType(klass->GetPrimitiveType());
+  }
+  if (klass->IsObjectClass()) {
+    return JavaLangObject();
+  }
+  if (!klass->IsArrayClass() && &klass->GetDexFile() == dex_file_) {
+    // Go through the `TypeIndex`-based cache. If the entry is not there yet, we shall
+    // fill it in now to make sure it's available for subsequent lookups.
+    std::optional<StackHandleScope<1u>> hs(std::nullopt);
+    if (kIsDebugBuild) {
+      hs.emplace(Thread::Current());
+    }
+    Handle<mirror::Class> h_class =
+        kIsDebugBuild ? hs->NewHandle(klass) : Handle<mirror::Class>();
+    const RegType& reg_type = FromTypeIndex(klass->GetDexTypeIndex());
+    DCHECK(reg_type.IsReference());
+    DCHECK(reg_type.GetClass() == h_class.Get());
+    return reg_type;
   }
   for (auto& pair : klass_entries_) {
-    const Handle<mirror::Class> reg_klass = pair.first;
-    if (reg_klass.Get() == klass) {
-      const RegType* reg_type = pair.second;
-      if (MatchingPrecisionForClass(reg_type, precise)) {
-        return reg_type;
-      }
+    const Handle<mirror::Class> entry_klass = pair.first;
+    const RegType* entry_reg_type = pair.second;
+    if (entry_klass.Get() == klass) {
+      return *entry_reg_type;
     }
   }
-  return nullptr;
-}
 
-const RegType* RegTypeCache::InsertClass(const std::string_view& descriptor,
-                                         ObjPtr<mirror::Class> klass,
-                                         bool precise) {
   // No reference to the class was found, create new reference.
-  DCHECK(FindClass(klass, precise) == nullptr);
-  RegType* const reg_type = precise
-      ? static_cast<RegType*>(
-          new (&allocator_) PreciseReferenceType(handles_.NewHandle(klass),
-                                                 descriptor,
-                                                 entries_.size()))
-      : new (&allocator_) ReferenceType(handles_.NewHandle(klass), descriptor, entries_.size());
-  return &AddEntry(reg_type);
-}
-
-const RegType& RegTypeCache::FromClass(const char* descriptor,
-                                       ObjPtr<mirror::Class> klass,
-                                       bool precise) {
-  DCHECK(klass != nullptr);
-  const RegType* reg_type = FindClass(klass, precise);
-  if (reg_type == nullptr) {
-    reg_type = InsertClass(AddString(std::string_view(descriptor)), klass, precise);
+  std::string_view descriptor;
+  if (klass->IsArrayClass()) {
+    std::string temp;
+    descriptor = AddString(std::string_view(klass->GetDescriptor(&temp)));
+  } else {
+    // Point `descriptor` to the string data in the dex file that defines the `klass`.
+    // That dex file cannot be unloaded while we hold a `Handle<>` to that `klass`.
+    descriptor = klass->GetDescriptorView();
   }
-  return *reg_type;
+  Handle<mirror::Class> h_klass = handles_.NewHandle(klass);
+  const RegType* reg_type = new (&allocator_) ReferenceType(h_klass, descriptor, entries_.size());
+  return AddEntry(reg_type);
 }
 
 RegTypeCache::RegTypeCache(Thread* self,
                            ClassLinker* class_linker,
+                           ArenaPool* arena_pool,
+                           Handle<mirror::ClassLoader> class_loader,
+                           const DexFile* dex_file,
                            bool can_load_classes,
-                           ScopedArenaAllocator& allocator,
                            bool can_suspend)
-    : entries_(allocator.Adapter(kArenaAllocVerifier)),
-      klass_entries_(allocator.Adapter(kArenaAllocVerifier)),
-      allocator_(allocator),
+    : allocator_(arena_pool),
+      entries_(allocator_.Adapter(kArenaAllocVerifier)),
+      klass_entries_(allocator_.Adapter(kArenaAllocVerifier)),
       handles_(self),
       class_linker_(class_linker),
-      can_load_classes_(can_load_classes) {
+      class_loader_(class_loader),
+      dex_file_(dex_file),
+      ids_for_type_index_(allocator_.AllocArray<uint16_t>(dex_file->NumTypeIds())),
+      last_uninitialized_this_type_(nullptr),
+      can_load_classes_(can_load_classes),
+      can_suspend_(can_suspend) {
   DCHECK(can_suspend || !can_load_classes) << "Cannot load classes if suspension is disabled!";
   if (kIsDebugBuild && can_suspend) {
     Thread::Current()->AssertThreadSuspensionIsAllowable(gAborting == 0);
   }
-  // The klass_entries_ array does not have primitives or small constants.
+  // `ArenaAllocator` guarantees zero-initialization.
+  static_assert(kNoIdForTypeIndex == 0u);
+  DCHECK(std::all_of(ids_for_type_index_,
+                     ids_for_type_index_ + dex_file->NumTypeIds(),
+                     [](uint16_t id) { return id == kNoIdForTypeIndex; }));
+  // The klass_entries_ array does not have primitives or constants.
   static constexpr size_t kNumReserveEntries = 32;
   klass_entries_.reserve(kNumReserveEntries);
-  // We want to have room for additional entries after inserting primitives and small
-  // constants.
-  entries_.reserve(kNumReserveEntries + kNumPrimitivesAndSmallConstants);
-  FillPrimitiveAndSmallConstantTypes();
+  // We want to have room for additional entries after inserting primitives and constants.
+  entries_.reserve(kNumReserveEntries + kNumberOfFixedCacheIds);
+  FillPrimitiveAndConstantTypes();
 }
 
 const RegType& RegTypeCache::FromUnresolvedMerge(const RegType& left,
@@ -314,7 +326,8 @@ const RegType& RegTypeCache::FromUnresolvedMerge(const RegType& left,
   const RegType* left_resolved;
   bool left_unresolved_is_array;
   if (left.IsUnresolvedMergedReference()) {
-    const UnresolvedMergedType& left_merge = *down_cast<const UnresolvedMergedType*>(&left);
+    const UnresolvedMergedReferenceType& left_merge =
+        *down_cast<const UnresolvedMergedReferenceType*>(&left);
 
     types.Copy(&left_merge.GetUnresolvedTypes());
     left_resolved = &left_merge.GetResolvedPart();
@@ -331,7 +344,8 @@ const RegType& RegTypeCache::FromUnresolvedMerge(const RegType& left,
   const RegType* right_resolved;
   bool right_unresolved_is_array;
   if (right.IsUnresolvedMergedReference()) {
-    const UnresolvedMergedType& right_merge = *down_cast<const UnresolvedMergedType*>(&right);
+    const UnresolvedMergedReferenceType& right_merge =
+        *down_cast<const UnresolvedMergedReferenceType*>(&right);
 
     types.Union(&right_merge.GetUnresolvedTypes());
     right_resolved = &right_merge.GetResolvedPart();
@@ -361,22 +375,23 @@ const RegType& RegTypeCache::FromUnresolvedMerge(const RegType& left,
 
     // Is the resolved part a primitive array?
     if (resolved_merged_is_array && !resolved_parts_merged.IsObjectArrayTypes()) {
-      return JavaLangObject(/* precise= */ false);
+      return JavaLangObject();
     }
 
     // Is any part not an array (but exists)?
     if ((!left_unresolved_is_array && left_resolved != &left) ||
         (!right_unresolved_is_array && right_resolved != &right) ||
         !resolved_merged_is_array) {
-      return JavaLangObject(/* precise= */ false);
+      return JavaLangObject();
     }
   }
 
   // Check if entry already exists.
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
+  for (size_t i = kNumberOfFixedCacheIds; i < entries_.size(); i++) {
     const RegType* cur_entry = entries_[i];
     if (cur_entry->IsUnresolvedMergedReference()) {
-      const UnresolvedMergedType* cmp_type = down_cast<const UnresolvedMergedType*>(cur_entry);
+      const UnresolvedMergedReferenceType* cmp_type =
+          down_cast<const UnresolvedMergedReferenceType*>(cur_entry);
       const RegType& resolved_part = cmp_type->GetResolvedPart();
       const BitVector& unresolved_part = cmp_type->GetUnresolvedTypes();
       // Use SameBitsSet. "types" is expandable to allow merging in the components, but the
@@ -386,217 +401,112 @@ const RegType& RegTypeCache::FromUnresolvedMerge(const RegType& left,
       }
     }
   }
-  return AddEntry(new (&allocator_) UnresolvedMergedType(resolved_parts_merged,
-                                                         types,
-                                                         this,
-                                                         entries_.size()));
+  return AddEntry(new (&allocator_) UnresolvedMergedReferenceType(resolved_parts_merged,
+                                                                  types,
+                                                                  this,
+                                                                  entries_.size()));
 }
 
-const RegType& RegTypeCache::FromUnresolvedSuperClass(const RegType& child) {
-  // Check if entry already exists.
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-    const RegType* cur_entry = entries_[i];
-    if (cur_entry->IsUnresolvedSuperClass()) {
-      const UnresolvedSuperClass* tmp_entry =
-          down_cast<const UnresolvedSuperClass*>(cur_entry);
-      uint16_t unresolved_super_child_id =
-          tmp_entry->GetUnresolvedSuperClassChildId();
-      if (unresolved_super_child_id == child.GetId()) {
-        return *cur_entry;
+const UninitializedType& RegTypeCache::Uninitialized(const RegType& type) {
+  auto get_or_create_uninitialized_type =
+    [&](auto& ref_type) REQUIRES_SHARED(Locks::mutator_lock_) {
+      using RefType = std::remove_const_t<std::remove_reference_t<decltype(ref_type)>>;
+      static_assert(std::is_same_v<RefType, ReferenceType> ||
+                    std::is_same_v<RefType, UnresolvedReferenceType>);
+      using UninitRefType =
+          std::remove_const_t<std::remove_pointer_t<decltype(ref_type.GetUninitializedType())>>;
+      static_assert(std::is_same_v<RefType, ReferenceType>
+          ? std::is_same_v<UninitRefType, UninitializedReferenceType>
+          : std::is_same_v<UninitRefType, UnresolvedUninitializedReferenceType>);
+      const UninitRefType* uninit_ref_type = ref_type.GetUninitializedType();
+      if (uninit_ref_type == nullptr) {
+        uninit_ref_type = new (&allocator_) UninitRefType(entries_.size(), &ref_type);
+        AddEntry(uninit_ref_type);
+        ref_type.SetUninitializedType(uninit_ref_type);
       }
-    }
-  }
-  return AddEntry(new (&allocator_) UnresolvedSuperClass(
-      null_handle_, child.GetId(), this, entries_.size()));
-}
+      return uninit_ref_type;
+    };
 
-const UninitializedType& RegTypeCache::Uninitialized(const RegType& type, uint32_t allocation_pc) {
-  UninitializedType* entry = nullptr;
-  const std::string_view& descriptor(type.GetDescriptor());
-  if (type.IsUnresolvedTypes()) {
-    for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-      const RegType* cur_entry = entries_[i];
-      if (cur_entry->IsUnresolvedAndUninitializedReference() &&
-          down_cast<const UnresolvedUninitializedRefType*>(cur_entry)->GetAllocationPc()
-              == allocation_pc &&
-          (cur_entry->GetDescriptor() == descriptor)) {
-        return *down_cast<const UnresolvedUninitializedRefType*>(cur_entry);
-      }
-    }
-    entry = new (&allocator_) UnresolvedUninitializedRefType(null_handle_,
-                                                             descriptor,
-                                                             allocation_pc,
-                                                             entries_.size());
+  if (type.IsReference()) {
+    return *get_or_create_uninitialized_type(down_cast<const ReferenceType&>(type));
+  } else if (type.IsUnresolvedReference()) {
+    return *get_or_create_uninitialized_type(down_cast<const UnresolvedReferenceType&>(type));
   } else {
-    ObjPtr<mirror::Class> klass = type.GetClass();
-    for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-      const RegType* cur_entry = entries_[i];
-      if (cur_entry->IsUninitializedReference() &&
-          down_cast<const UninitializedReferenceType*>(cur_entry)
-              ->GetAllocationPc() == allocation_pc &&
-          cur_entry->GetClass() == klass) {
-        return *down_cast<const UninitializedReferenceType*>(cur_entry);
-      }
-    }
-    entry = new (&allocator_) UninitializedReferenceType(handles_.NewHandle(klass),
-                                                         descriptor,
-                                                         allocation_pc,
-                                                         entries_.size());
+    DCHECK(type.IsJavaLangObject());
+    return *down_cast<const JavaLangObjectType&>(type).GetUninitializedType();
   }
-  return AddEntry(entry);
 }
 
 const RegType& RegTypeCache::FromUninitialized(const RegType& uninit_type) {
-  RegType* entry;
-
-  if (uninit_type.IsUnresolvedTypes()) {
-    const std::string_view& descriptor(uninit_type.GetDescriptor());
-    for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-      const RegType* cur_entry = entries_[i];
-      if (cur_entry->IsUnresolvedReference() &&
-          cur_entry->GetDescriptor() == descriptor) {
-        return *cur_entry;
-      }
-    }
-    entry = new (&allocator_) UnresolvedReferenceType(null_handle_, descriptor, entries_.size());
+  if (uninit_type.IsUninitializedReference()) {
+    return *down_cast<const UninitializedReferenceType&>(uninit_type).GetInitializedType();
+  } else if (uninit_type.IsUnresolvedUninitializedReference()) {
+    return *down_cast<const UnresolvedUninitializedReferenceType&>(
+        uninit_type).GetInitializedType();
+  } else if (uninit_type.IsUninitializedThisReference()) {
+    return *down_cast<const UninitializedThisReferenceType&>(uninit_type).GetInitializedType();
   } else {
-    ObjPtr<mirror::Class> klass = uninit_type.GetClass();
-    if (uninit_type.IsUninitializedThisReference() && !klass->IsFinal()) {
-      // For uninitialized "this reference" look for reference types that are not precise.
-      for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-        const RegType* cur_entry = entries_[i];
-        if (cur_entry->IsReference() && cur_entry->GetClass() == klass) {
-          return *cur_entry;
-        }
-      }
-      entry = new (&allocator_) ReferenceType(handles_.NewHandle(klass), "", entries_.size());
-    } else if (!klass->IsPrimitive()) {
-      // We're uninitialized because of allocation, look or create a precise type as allocations
-      // may only create objects of that type.
-      // Note: we do not check whether the given klass is actually instantiable (besides being
-      //       primitive), that is, we allow interfaces and abstract classes here. The reasoning is
-      //       twofold:
-      //       1) The "new-instance" instruction to generate the uninitialized type will already
-      //          queue an instantiation error. This is a soft error that must be thrown at runtime,
-      //          and could potentially change if the class is resolved differently at runtime.
-      //       2) Checking whether the klass is instantiable and using conflict may produce a hard
-      //          error when the value is used, which leads to a VerifyError, which is not the
-      //          correct semantics.
-      for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-        const RegType* cur_entry = entries_[i];
-        if (cur_entry->IsPreciseReference() && cur_entry->GetClass() == klass) {
-          return *cur_entry;
-        }
-      }
-      entry = new (&allocator_) PreciseReferenceType(handles_.NewHandle(klass),
-                                                     uninit_type.GetDescriptor(),
-                                                     entries_.size());
-    } else {
-      return Conflict();
-    }
+    DCHECK(uninit_type.IsUnresolvedUninitializedThisReference()) << uninit_type;
+    return *down_cast<const UnresolvedUninitializedThisReferenceType&>(
+        uninit_type).GetInitializedType();
   }
-  return AddEntry(entry);
 }
 
 const UninitializedType& RegTypeCache::UninitializedThisArgument(const RegType& type) {
+  if (last_uninitialized_this_type_ != nullptr && last_uninitialized_this_type_->Equals(type)) {
+    return *last_uninitialized_this_type_;
+  }
+
   UninitializedType* entry;
   const std::string_view& descriptor(type.GetDescriptor());
-  if (type.IsUnresolvedTypes()) {
-    for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
+  if (type.IsUnresolvedReference()) {
+    for (size_t i = kNumberOfFixedCacheIds; i < entries_.size(); i++) {
       const RegType* cur_entry = entries_[i];
-      if (cur_entry->IsUnresolvedAndUninitializedThisReference() &&
-          cur_entry->GetDescriptor() == descriptor) {
+      if (cur_entry->IsUnresolvedUninitializedThisReference() &&
+          down_cast<const UnresolvedUninitializedThisReferenceType*>(cur_entry)
+              ->GetInitializedType() == &type) {
+        DCHECK_EQ(cur_entry->GetDescriptor(), type.GetDescriptor());
         return *down_cast<const UninitializedType*>(cur_entry);
       }
     }
-    entry = new (&allocator_) UnresolvedUninitializedThisRefType(
-        null_handle_, descriptor, entries_.size());
+    entry = new (&allocator_) UnresolvedUninitializedThisReferenceType(
+        entries_.size(), down_cast<const UnresolvedReferenceType*>(&type));
   } else {
-    ObjPtr<mirror::Class> klass = type.GetClass();
-    for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
+    DCHECK(type.IsJavaLangObject() || type.IsReference());
+    for (size_t i = kNumberOfFixedCacheIds; i < entries_.size(); i++) {
       const RegType* cur_entry = entries_[i];
-      if (cur_entry->IsUninitializedThisReference() && cur_entry->GetClass() == klass) {
+      if (cur_entry->IsUninitializedThisReference() &&
+          down_cast<const UninitializedThisReferenceType*>(cur_entry)
+              ->GetInitializedType() == &type) {
+        DCHECK_EQ(cur_entry->GetDescriptor(), type.GetDescriptor());
         return *down_cast<const UninitializedType*>(cur_entry);
       }
     }
-    entry = new (&allocator_) UninitializedThisReferenceType(handles_.NewHandle(klass),
-                                                             descriptor,
-                                                             entries_.size());
-  }
-  return AddEntry(entry);
-}
-
-const ConstantType& RegTypeCache::FromCat1NonSmallConstant(int32_t value, bool precise) {
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-    const RegType* cur_entry = entries_[i];
-    if (!cur_entry->HasClass() && cur_entry->IsConstant() &&
-        cur_entry->IsPreciseConstant() == precise &&
-        (down_cast<const ConstantType*>(cur_entry))->ConstantValue() == value) {
-      return *down_cast<const ConstantType*>(cur_entry);
-    }
-  }
-  ConstantType* entry;
-  if (precise) {
-    entry = new (&allocator_) PreciseConstType(null_handle_, value, entries_.size());
-  } else {
-    entry = new (&allocator_) ImpreciseConstType(null_handle_, value, entries_.size());
-  }
-  return AddEntry(entry);
-}
-
-const ConstantType& RegTypeCache::FromCat2ConstLo(int32_t value, bool precise) {
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-    const RegType* cur_entry = entries_[i];
-    if (cur_entry->IsConstantLo() && (cur_entry->IsPrecise() == precise) &&
-        (down_cast<const ConstantType*>(cur_entry))->ConstantValueLo() == value) {
-      return *down_cast<const ConstantType*>(cur_entry);
-    }
-  }
-  ConstantType* entry;
-  if (precise) {
-    entry = new (&allocator_) PreciseConstLoType(null_handle_, value, entries_.size());
-  } else {
-    entry = new (&allocator_) ImpreciseConstLoType(null_handle_, value, entries_.size());
+    entry = new (&allocator_) UninitializedThisReferenceType(
+        entries_.size(), down_cast<const ReferenceType*>(&type));
   }
+  last_uninitialized_this_type_ = entry;
   return AddEntry(entry);
 }
 
-const ConstantType& RegTypeCache::FromCat2ConstHi(int32_t value, bool precise) {
-  for (size_t i = kNumPrimitivesAndSmallConstants; i < entries_.size(); i++) {
-    const RegType* cur_entry = entries_[i];
-    if (cur_entry->IsConstantHi() && (cur_entry->IsPrecise() == precise) &&
-        (down_cast<const ConstantType*>(cur_entry))->ConstantValueHi() == value) {
-      return *down_cast<const ConstantType*>(cur_entry);
-    }
-  }
-  ConstantType* entry;
-  if (precise) {
-    entry = new (&allocator_) PreciseConstHiType(null_handle_, value, entries_.size());
-  } else {
-    entry = new (&allocator_) ImpreciseConstHiType(null_handle_, value, entries_.size());
-  }
-  return AddEntry(entry);
-}
-
-const RegType& RegTypeCache::GetComponentType(const RegType& array,
-                                              Handle<mirror::ClassLoader> loader) {
+const RegType& RegTypeCache::GetComponentType(const RegType& array) {
   if (!array.IsArrayTypes()) {
     return Conflict();
   } else if (array.IsUnresolvedTypes()) {
     DCHECK(!array.IsUnresolvedMergedReference());  // Caller must make sure not to ask for this.
     const std::string descriptor(array.GetDescriptor());
-    return FromDescriptor(loader, descriptor.c_str() + 1);
+    return FromDescriptor(descriptor.c_str() + 1);
   } else {
     ObjPtr<mirror::Class> klass = array.GetClass()->GetComponentType();
-    std::string temp;
-    const char* descriptor = klass->GetDescriptor(&temp);
     if (klass->IsErroneous()) {
       // Arrays may have erroneous component types, use unresolved in that case.
       // We assume that the primitive classes are not erroneous, so we know it is a
       // reference type.
-      return FromDescriptor(loader, descriptor);
+      std::string temp;
+      const char* descriptor = klass->GetDescriptor(&temp);
+      return FromDescriptor(descriptor);
     } else {
-      return FromClass(descriptor, klass, klass->CannotBeAssignedFromOtherTypes());
+      return FromClass(klass);
     }
   }
 }
diff --git a/runtime/verifier/reg_type_cache.h b/runtime/verifier/reg_type_cache.h
index d9d3ddc2a2..a78ad587f2 100644
--- a/runtime/verifier/reg_type_cache.h
+++ b/runtime/verifier/reg_type_cache.h
@@ -21,12 +21,13 @@
 #include <string_view>
 #include <vector>
 
+#include "base/arena_containers.h"
 #include "base/casts.h"
 #include "base/macros.h"
-#include "base/scoped_arena_containers.h"
 #include "dex/primitive.h"
 #include "gc_root.h"
 #include "handle_scope.h"
+#include "reg_type.h"
 
 namespace art HIDDEN {
 
@@ -36,155 +37,173 @@ class ClassLoader;
 }  // namespace mirror
 
 class ClassLinker;
-class ScopedArenaAllocator;
+class DexFile;
 
 namespace verifier {
 
-class BooleanType;
-class ByteType;
-class CharType;
-class ConflictType;
-class ConstantType;
-class DoubleHiType;
-class DoubleLoType;
-class FloatType;
-class ImpreciseConstType;
-class IntegerType;
-class LongHiType;
-class LongLoType;
 class MethodVerifier;
-class NullType;
-class PreciseConstType;
-class PreciseReferenceType;
-class RegType;
-class ShortType;
-class UndefinedType;
-class UninitializedType;
 
 // Use 8 bytes since that is the default arena allocator alignment.
 static constexpr size_t kDefaultArenaBitVectorBytes = 8;
 
 class RegTypeCache {
  public:
-  RegTypeCache(Thread* self,
-               ClassLinker* class_linker,
-               bool can_load_classes,
-               ScopedArenaAllocator& allocator,
-               bool can_suspend = true);
-  const art::verifier::RegType& GetFromId(uint16_t id) const;
-  // Find a RegType, returns null if not found.
-  const RegType* FindClass(ObjPtr<mirror::Class> klass, bool precise) const
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  // Insert a new class with a specified descriptor, must not already be in the cache.
-  const RegType* InsertClass(const std::string_view& descriptor,
-                             ObjPtr<mirror::Class> klass,
-                             bool precise)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  // Get or insert a reg type for a description, klass, and precision.
-  const RegType& FromClass(const char* descriptor, ObjPtr<mirror::Class> klass, bool precise)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  const ConstantType& FromCat1Const(int32_t value, bool precise)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  const ConstantType& FromCat2ConstLo(int32_t value, bool precise)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-  const ConstantType& FromCat2ConstHi(int32_t value, bool precise)
+  EXPORT RegTypeCache(Thread* self,
+                      ClassLinker* class_linker,
+                      ArenaPool* arena_pool,
+                      Handle<mirror::ClassLoader> class_loader,
+                      const DexFile* dex_file,
+                      bool can_load_classes = true,
+                      bool can_suspend = true);
+
+  Handle<mirror::ClassLoader> GetClassLoader() const {
+    return class_loader_;
+  }
+
+  const DexFile* GetDexFile() const {
+    return dex_file_;
+  }
+
+  bool CanLoadClasses() const {
+    return can_load_classes_;
+  }
+
+  bool CanSuspend() const {
+    return can_suspend_;
+  }
+
+  static constexpr uint32_t NumberOfRegKindCacheIds() { return kNumberOfRegKindCacheIds; }
+
+  // Translate `RegType::Kind` to id for a pre-initialized register type.
+  // Cannot be used for non-zero reference kinds other than `JavaLangObject()`; all other
+  // kinds (undefined, conflict, primitive and constant kinds) have pre-initialized types.
+  static constexpr uint16_t IdForRegKind(RegType::Kind kind);
+
+  // Translate `id` to `RegType::Kind`.
+  // The `id` must be lower than `NumberOfRegKindCacheIds()`.
+  static constexpr RegType::Kind RegKindForId(uint16_t id);
+
+  // Get register type for a `RegType::Kind` with the same restrictions as `IdForRegKind()`.
+  const RegType& GetFromRegKind(RegType::Kind kind) const;
+
+  const RegType& GetFromId(uint16_t id) const;
+  // Get or insert a reg type for a klass.
+  const RegType& FromClass(ObjPtr<mirror::Class> klass)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& FromDescriptor(Handle<mirror::ClassLoader> loader, const char* descriptor)
+  const RegType& FromDescriptor(const char* descriptor)
       REQUIRES_SHARED(Locks::mutator_lock_);
   const RegType& FromUnresolvedMerge(const RegType& left,
                                      const RegType& right,
                                      MethodVerifier* verifier)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& FromUnresolvedSuperClass(const RegType& child)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  const RegType& FromTypeIndex(dex::TypeIndex type_index) REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Note: this should not be used outside of RegType::ClassJoin!
   const RegType& MakeUnresolvedReference() REQUIRES_SHARED(Locks::mutator_lock_);
 
-  const ConstantType& Zero() REQUIRES_SHARED(Locks::mutator_lock_) {
-    return FromCat1Const(0, true);
-  }
-  const ConstantType& One() REQUIRES_SHARED(Locks::mutator_lock_) {
-    return FromCat1Const(1, true);
-  }
   size_t GetCacheSize() {
     return entries_.size();
   }
-  const BooleanType& Boolean() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ByteType& Byte() REQUIRES_SHARED(Locks::mutator_lock_);
-  const CharType& Char() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ShortType& Short() REQUIRES_SHARED(Locks::mutator_lock_);
-  const IntegerType& Integer() REQUIRES_SHARED(Locks::mutator_lock_);
-  const FloatType& Float() REQUIRES_SHARED(Locks::mutator_lock_);
-  const LongLoType& LongLo() REQUIRES_SHARED(Locks::mutator_lock_);
-  const LongHiType& LongHi() REQUIRES_SHARED(Locks::mutator_lock_);
-  const DoubleLoType& DoubleLo() REQUIRES_SHARED(Locks::mutator_lock_);
-  const DoubleHiType& DoubleHi() REQUIRES_SHARED(Locks::mutator_lock_);
-  const UndefinedType& Undefined() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ConflictType& Conflict();
-  const NullType& Null();
-
-  const PreciseReferenceType& JavaLangClass() REQUIRES_SHARED(Locks::mutator_lock_);
-  const PreciseReferenceType& JavaLangString() REQUIRES_SHARED(Locks::mutator_lock_);
-  const PreciseReferenceType& JavaLangInvokeMethodHandle() REQUIRES_SHARED(Locks::mutator_lock_);
-  const PreciseReferenceType& JavaLangInvokeMethodType() REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& JavaLangThrowable() REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& JavaLangObject(bool precise) REQUIRES_SHARED(Locks::mutator_lock_);
-
-  const UninitializedType& Uninitialized(const RegType& type, uint32_t allocation_pc)
+
+  const UndefinedType& Undefined() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ConflictType& Conflict() const;
+  const NullType& Null() const;
+
+  const BooleanType& Boolean() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ByteType& Byte() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const CharType& Char() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ShortType& Short() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const IntegerType& Integer() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const FloatType& Float() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const LongLoType& LongLo() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const LongHiType& LongHi() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const DoubleLoType& DoubleLo() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const DoubleHiType& DoubleHi() const REQUIRES_SHARED(Locks::mutator_lock_);
+
+  const ZeroType& Zero() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const BooleanConstantType& BooleanConstant() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ByteConstantType& ByteConstant() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const CharConstantType& CharConstant() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ShortConstantType& ShortConstant() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const IntegerConstantType& IntegerConstant() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const PositiveByteConstantType& PositiveByteConstant() const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+  const PositiveShortConstantType& PositiveShortConstant() const
+      REQUIRES_SHARED(Locks::mutator_lock_);
+  const ConstantLoType& ConstantLo() const REQUIRES_SHARED(Locks::mutator_lock_);
+  const ConstantHiType& ConstantHi() const REQUIRES_SHARED(Locks::mutator_lock_);
+
+  const ReferenceType& JavaLangClass() REQUIRES_SHARED(Locks::mutator_lock_);
+  const ReferenceType& JavaLangString() REQUIRES_SHARED(Locks::mutator_lock_);
+  const ReferenceType& JavaLangInvokeMethodHandle() REQUIRES_SHARED(Locks::mutator_lock_);
+  const ReferenceType& JavaLangInvokeMethodType() REQUIRES_SHARED(Locks::mutator_lock_);
+  const ReferenceType& JavaLangThrowable() REQUIRES_SHARED(Locks::mutator_lock_);
+  const JavaLangObjectType& JavaLangObject() REQUIRES_SHARED(Locks::mutator_lock_);
+
+  const UninitializedType& Uninitialized(const RegType& type)
       REQUIRES_SHARED(Locks::mutator_lock_);
   // Create an uninitialized 'this' argument for the given type.
   const UninitializedType& UninitializedThisArgument(const RegType& type)
       REQUIRES_SHARED(Locks::mutator_lock_);
   const RegType& FromUninitialized(const RegType& uninit_type)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& ByteConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& CharConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& ShortConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& IntConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& PosByteConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const ImpreciseConstType& PosShortConstant() REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& GetComponentType(const RegType& array, Handle<mirror::ClassLoader> loader)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+
+  const RegType& GetComponentType(const RegType& array) REQUIRES_SHARED(Locks::mutator_lock_);
   void Dump(std::ostream& os) REQUIRES_SHARED(Locks::mutator_lock_);
-  const RegType& RegTypeFromPrimitiveType(Primitive::Type) const;
+  const RegType& RegTypeFromPrimitiveType(Primitive::Type) const
+      REQUIRES_SHARED(Locks::mutator_lock_);
 
   ClassLinker* GetClassLinker() const {
     return class_linker_;
   }
 
-  Handle<mirror::Class> GetNullHandle() const {
-    return null_handle_;
-  }
-
-  static constexpr int32_t kMinSmallConstant = -1;
-  static constexpr int32_t kMaxSmallConstant = 4;
-  static constexpr int32_t kNumSmallConstants = kMaxSmallConstant - kMinSmallConstant + 1;
-  static constexpr size_t kNumPrimitivesAndSmallConstants = 13 + kNumSmallConstants;
-  static constexpr int32_t kBooleanCacheId = kNumSmallConstants;
-  static constexpr int32_t kByteCacheId = kNumSmallConstants + 1;
-  static constexpr int32_t kShortCacheId = kNumSmallConstants + 2;
-  static constexpr int32_t kCharCacheId = kNumSmallConstants + 3;
-  static constexpr int32_t kIntCacheId = kNumSmallConstants + 4;
-  static constexpr int32_t kLongLoCacheId = kNumSmallConstants + 5;
-  static constexpr int32_t kLongHiCacheId = kNumSmallConstants + 6;
-  static constexpr int32_t kFloatCacheId = kNumSmallConstants + 7;
-  static constexpr int32_t kDoubleLoCacheId = kNumSmallConstants + 8;
-  static constexpr int32_t kDoubleHiCacheId = kNumSmallConstants + 9;
-  static constexpr int32_t kUndefinedCacheId = kNumSmallConstants + 10;
-  static constexpr int32_t kConflictCacheId = kNumSmallConstants + 11;
-  static constexpr int32_t kNullCacheId = kNumSmallConstants + 12;
+  static constexpr uint32_t kUndefinedCacheId = 0;
+  static constexpr uint32_t kConflictCacheId = kUndefinedCacheId + 1u;
+  static constexpr uint32_t kBooleanCacheId = kConflictCacheId + 1u;
+  static constexpr uint32_t kByteCacheId = kBooleanCacheId + 1u;
+  static constexpr uint32_t kCharCacheId = kByteCacheId + 1u;
+  static constexpr uint32_t kShortCacheId = kCharCacheId + 1u;
+  static constexpr uint32_t kIntegerCacheId = kShortCacheId + 1u;
+  static constexpr uint32_t kLongLoCacheId = kIntegerCacheId + 1u;
+  static constexpr uint32_t kLongHiCacheId = kLongLoCacheId + 1u;
+  static constexpr uint32_t kFloatCacheId = kLongHiCacheId + 1u;
+  static constexpr uint32_t kDoubleLoCacheId = kFloatCacheId + 1u;
+  static constexpr uint32_t kDoubleHiCacheId = kDoubleLoCacheId + 1u;
+  static constexpr uint32_t kZeroCacheId = kDoubleHiCacheId + 1u;
+  static constexpr uint32_t kBooleanConstantCacheId = kZeroCacheId + 1u;
+  static constexpr uint32_t kPositiveByteConstantCacheId = kBooleanConstantCacheId + 1u;
+  static constexpr uint32_t kPositiveShortConstantCacheId = kPositiveByteConstantCacheId + 1u;
+  static constexpr uint32_t kCharConstantCacheId = kPositiveShortConstantCacheId + 1u;
+  static constexpr uint32_t kByteConstantCacheId = kCharConstantCacheId + 1u;
+  static constexpr uint32_t kShortConstantCacheId = kByteConstantCacheId + 1u;
+  static constexpr uint32_t kIntegerConstantCacheId = kShortConstantCacheId + 1u;
+  static constexpr uint32_t kConstantLoCacheId = kIntegerConstantCacheId + 1u;
+  static constexpr uint32_t kConstantHiCacheId = kConstantLoCacheId + 1u;
+  static constexpr uint32_t kNullCacheId = kConstantHiCacheId + 1u;
+  static constexpr uint32_t kJavaLangObjectCacheId = kNullCacheId + 1u;
+  static constexpr uint32_t kNumberOfRegKindCacheIds = kJavaLangObjectCacheId + 1u;
+
+  static constexpr uint32_t kUninitializedJavaLangObjectCacheId = kNumberOfRegKindCacheIds;
+  static constexpr uint32_t kNumberOfFixedCacheIds = kUninitializedJavaLangObjectCacheId + 1u;
 
  private:
-  void FillPrimitiveAndSmallConstantTypes() REQUIRES_SHARED(Locks::mutator_lock_);
-  ObjPtr<mirror::Class> ResolveClass(const char* descriptor, Handle<mirror::ClassLoader> loader)
+  // We want 0 to mean an empty slot in `ids_for_type_index_`, so that we do not need to fill
+  // the array after allocaing zero-initialized storage. This needs to correspond to a fixed
+  // cache id that cannot be returned for a type index, such as `kUndefinedCacheId`.
+  static constexpr uint32_t kNoIdForTypeIndex = 0u;
+  static_assert(kNoIdForTypeIndex == kUndefinedCacheId);
+
+  void FillPrimitiveAndConstantTypes() REQUIRES_SHARED(Locks::mutator_lock_);
+  ObjPtr<mirror::Class> ResolveClass(const char* descriptor, size_t descriptor_length)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  bool MatchDescriptor(size_t idx, const std::string_view& descriptor, bool precise)
+  bool MatchDescriptor(size_t idx, const std::string_view& descriptor)
       REQUIRES_SHARED(Locks::mutator_lock_);
-  const ConstantType& FromCat1NonSmallConstant(int32_t value, bool precise)
+
+  const RegType& From(const char* descriptor)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  const RegType& From(Handle<mirror::ClassLoader> loader, const char* descriptor)
+  const RegType& FromTypeIndexUncached(dex::TypeIndex type_index)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Returns the pass in RegType.
@@ -195,24 +214,34 @@ class RegTypeCache {
   // verifier and return a string view.
   std::string_view AddString(const std::string_view& str);
 
+  // Arena allocator.
+  ArenaAllocator allocator_;
+
   // The actual storage for the RegTypes.
-  ScopedArenaVector<const RegType*> entries_;
+  ArenaVector<const RegType*> entries_;
 
   // Fast lookup for quickly finding entries that have a matching class.
-  ScopedArenaVector<std::pair<Handle<mirror::Class>, const RegType*>> klass_entries_;
-
-  // Arena allocator.
-  ScopedArenaAllocator& allocator_;
+  ArenaVector<std::pair<Handle<mirror::Class>, const RegType*>> klass_entries_;
 
   // Handle scope containing classes.
   VariableSizedHandleScope handles_;
-  ScopedNullHandle<mirror::Class> null_handle_;
 
   ClassLinker* class_linker_;
+  Handle<mirror::ClassLoader> class_loader_;
+  const DexFile* const dex_file_;
+
+  // Fast lookup by type index.
+  uint16_t* const ids_for_type_index_;
+
+  // Cache last uninitialized "this" type used for constructors.
+  const UninitializedType* last_uninitialized_this_type_;
 
   // Whether or not we're allowed to load classes.
   const bool can_load_classes_;
 
+  // Whether or not we're allowed to suspend.
+  const bool can_suspend_;
+
   DISALLOW_COPY_AND_ASSIGN(RegTypeCache);
 };
 
diff --git a/runtime/verifier/reg_type_test.cc b/runtime/verifier/reg_type_test.cc
index b9d618f16e..4c249a6659 100644
--- a/runtime/verifier/reg_type_test.cc
+++ b/runtime/verifier/reg_type_test.cc
@@ -23,8 +23,10 @@
 #include "base/scoped_arena_allocator.h"
 #include "common_runtime_test.h"
 #include "compiler_callbacks.h"
+#include "dex/test_dex_file_builder.h"
 #include "reg_type-inl.h"
 #include "reg_type_cache-inl.h"
+#include "reg_type_test_utils.h"
 #include "scoped_thread_state_change-inl.h"
 #include "thread-current-inl.h"
 
@@ -37,94 +39,136 @@ class RegTypeTest : public CommonRuntimeTest {
     use_boot_image_ = true;  // Make the Runtime creation cheaper.
   }
 
-  static const RegType& PreciseJavaLangObjectFromDescriptor(RegTypeCache* cache,
-                                                            Handle<mirror::ClassLoader> loader)
-      REQUIRES_SHARED(Locks::mutator_lock_) {
-    // To create a precise `java.lang.Object` reference from a descriptor, go through
-    // `Uninitialized()` and `FromUninitialized()` as we would for `new Object()`.
-    const RegType& imprecise_obj = cache->FromDescriptor(loader, "Ljava/lang/Object;");
-    CHECK(!imprecise_obj.IsPreciseReference());
-    const RegType& precise_obj =
-        cache->FromUninitialized(cache->Uninitialized(imprecise_obj, /* allocation_pc= */ 0u));
-    CHECK(precise_obj.IsPreciseReference());
-    return precise_obj;
+  void SetUp() override {
+    CommonRuntimeTest::SetUp();
+
+    // Build a fake `DexFile` with some descriptors.
+    static const char* const descriptors[] = {
+      // References.
+      "Ljava/lang/Object;", "Ljava/lang/String;", "LNonExistent;",
+      // Primitives and `void`.
+      "Z", "B", "C", "S", "I", "J", "F", "D", "V"
+    };
+    TestDexFileBuilder builder;
+    for (const char* descriptor : descriptors) {
+      builder.AddType(descriptor);
+    }
+    dex_file_ = builder.Build("arbitrary-location");
   }
+
+  static constexpr size_t kNumConstTypes = RegType::Kind::kNull - RegType::Kind::kZero + 1;
+
+  std::array<const RegType*, kNumConstTypes> GetConstRegTypes(const RegTypeCache& cache)
+      REQUIRES_SHARED(Locks::mutator_lock_) {
+    return {
+      &cache.Zero(),
+      &cache.BooleanConstant(),
+      &cache.PositiveByteConstant(),
+      &cache.PositiveShortConstant(),
+      &cache.CharConstant(),
+      &cache.ByteConstant(),
+      &cache.ShortConstant(),
+      &cache.IntegerConstant(),
+      &cache.ConstantLo(),
+      &cache.ConstantHi(),
+      &cache.Null(),
+    };
+  };
+
+  std::unique_ptr<const DexFile> dex_file_;
 };
 
-TEST_F(RegTypeTest, ConstLoHi) {
-  // Tests creating primitive types types.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+TEST_F(RegTypeTest, Constants) {
+  // Tests creating constant types.
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& ref_type_const_0 = cache.FromCat1Const(10, true);
-  const RegType& ref_type_const_1 = cache.FromCat1Const(10, true);
-  const RegType& ref_type_const_2 = cache.FromCat1Const(30, true);
-  const RegType& ref_type_const_3 = cache.FromCat1Const(30, false);
-  EXPECT_TRUE(ref_type_const_0.Equals(ref_type_const_1));
-  EXPECT_FALSE(ref_type_const_0.Equals(ref_type_const_2));
-  EXPECT_FALSE(ref_type_const_0.Equals(ref_type_const_3));
-
-  const RegType& ref_type_const_wide_0 = cache.FromCat2ConstHi(50, true);
-  const RegType& ref_type_const_wide_1 = cache.FromCat2ConstHi(50, true);
-  EXPECT_TRUE(ref_type_const_wide_0.Equals(ref_type_const_wide_1));
-
-  const RegType& ref_type_const_wide_2 = cache.FromCat2ConstLo(50, true);
-  const RegType& ref_type_const_wide_3 = cache.FromCat2ConstLo(50, true);
-  const RegType& ref_type_const_wide_4 = cache.FromCat2ConstLo(55, true);
-  EXPECT_TRUE(ref_type_const_wide_2.Equals(ref_type_const_wide_3));
-  EXPECT_FALSE(ref_type_const_wide_2.Equals(ref_type_const_wide_4));
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  std::array<const RegType*, kNumConstTypes> const_reg_types = GetConstRegTypes(cache);
+
+  for (size_t i = 0; i != kNumConstTypes; ++i) {
+    EXPECT_TRUE(const_reg_types[i]->IsConstantTypes());
+  }
+
+  for (size_t i = 0; i != kNumConstTypes; ++i) {
+    for (size_t j = 0; j != kNumConstTypes; ++j) {
+      EXPECT_EQ(i == j, const_reg_types[i]->Equals(*(const_reg_types[j]))) << i << " " << j;
+    }
+  }
 }
 
 TEST_F(RegTypeTest, Pairs) {
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
   int64_t val = static_cast<int32_t>(1234);
-  const RegType& precise_lo = cache.FromCat2ConstLo(static_cast<int32_t>(val), true);
-  const RegType& precise_hi = cache.FromCat2ConstHi(static_cast<int32_t>(val >> 32), true);
-  const RegType& precise_const = cache.FromCat1Const(static_cast<int32_t>(val >> 32), true);
+  const RegType& const_lo = cache.ConstantLo();
+  const RegType& const_hi = cache.ConstantHi();
   const RegType& long_lo = cache.LongLo();
   const RegType& long_hi = cache.LongHi();
+  const RegType& int_const = cache.IntegerConstant();
   // Check the expectations for types.
-  EXPECT_TRUE(precise_lo.IsLowHalf());
-  EXPECT_FALSE(precise_hi.IsLowHalf());
-  EXPECT_FALSE(precise_lo.IsHighHalf());
-  EXPECT_TRUE(precise_hi.IsHighHalf());
+  EXPECT_TRUE(const_lo.IsLowHalf());
+  EXPECT_FALSE(const_hi.IsLowHalf());
+  EXPECT_FALSE(const_lo.IsHighHalf());
+  EXPECT_TRUE(const_hi.IsHighHalf());
+  EXPECT_TRUE(const_lo.IsLongTypes());
+  EXPECT_FALSE(const_hi.IsLongTypes());
+  EXPECT_FALSE(const_lo.IsLongHighTypes());
+  EXPECT_TRUE(const_hi.IsLongHighTypes());
+  EXPECT_TRUE(long_lo.IsLowHalf());
+  EXPECT_FALSE(long_hi.IsLowHalf());
+  EXPECT_FALSE(long_lo.IsHighHalf());
+  EXPECT_TRUE(long_hi.IsHighHalf());
+  EXPECT_TRUE(long_lo.IsLongTypes());
+  EXPECT_FALSE(long_hi.IsLongTypes());
+  EXPECT_FALSE(long_lo.IsLongHighTypes());
   EXPECT_TRUE(long_hi.IsLongHighTypes());
-  EXPECT_TRUE(precise_hi.IsLongHighTypes());
   // Check Pairing.
-  EXPECT_FALSE(precise_lo.CheckWidePair(precise_const));
-  EXPECT_TRUE(precise_lo.CheckWidePair(precise_hi));
+  EXPECT_FALSE(const_lo.CheckWidePair(const_lo));
+  EXPECT_TRUE(const_lo.CheckWidePair(const_hi));
+  EXPECT_FALSE(const_lo.CheckWidePair(long_lo));
+  EXPECT_FALSE(const_lo.CheckWidePair(long_hi));
+  EXPECT_FALSE(const_lo.CheckWidePair(int_const));
+  EXPECT_FALSE(const_hi.CheckWidePair(const_lo));
+  EXPECT_FALSE(const_hi.CheckWidePair(const_hi));
+  EXPECT_FALSE(const_hi.CheckWidePair(long_lo));
+  EXPECT_FALSE(const_hi.CheckWidePair(long_hi));
+  EXPECT_FALSE(const_hi.CheckWidePair(int_const));
+  EXPECT_FALSE(long_lo.CheckWidePair(const_lo));
+  EXPECT_FALSE(long_lo.CheckWidePair(const_hi));
+  EXPECT_FALSE(long_lo.CheckWidePair(long_lo));
+  EXPECT_TRUE(long_lo.CheckWidePair(long_hi));
+  EXPECT_FALSE(long_lo.CheckWidePair(int_const));
+  EXPECT_FALSE(long_hi.CheckWidePair(const_lo));
+  EXPECT_FALSE(long_hi.CheckWidePair(const_hi));
+  EXPECT_FALSE(long_hi.CheckWidePair(long_lo));
+  EXPECT_FALSE(long_hi.CheckWidePair(long_hi));
+  EXPECT_FALSE(long_hi.CheckWidePair(int_const));
   // Test Merging.
-  EXPECT_TRUE((long_lo.Merge(precise_lo, &cache, /* verifier= */ nullptr)).IsLongTypes());
-  EXPECT_TRUE((long_hi.Merge(precise_hi, &cache, /* verifier= */ nullptr)).IsLongHighTypes());
+  EXPECT_TRUE((long_lo.Merge(const_lo, &cache, /* verifier= */ nullptr)).IsLongTypes());
+  EXPECT_TRUE((long_hi.Merge(const_hi, &cache, /* verifier= */ nullptr)).IsLongHighTypes());
 }
 
 TEST_F(RegTypeTest, Primitives) {
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
 
   const RegType& bool_reg_type = cache.Boolean();
   EXPECT_FALSE(bool_reg_type.IsUndefined());
   EXPECT_FALSE(bool_reg_type.IsConflict());
-  EXPECT_FALSE(bool_reg_type.IsZero());
-  EXPECT_FALSE(bool_reg_type.IsOne());
-  EXPECT_FALSE(bool_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_TRUE(bool_reg_type.IsBoolean());
   EXPECT_FALSE(bool_reg_type.IsByte());
   EXPECT_FALSE(bool_reg_type.IsChar());
   EXPECT_FALSE(bool_reg_type.IsShort());
   EXPECT_FALSE(bool_reg_type.IsInteger());
-  EXPECT_FALSE(bool_reg_type.IsLong());
+  EXPECT_FALSE(bool_reg_type.IsLongLo());
   EXPECT_FALSE(bool_reg_type.IsFloat());
-  EXPECT_FALSE(bool_reg_type.IsDouble());
+  EXPECT_FALSE(bool_reg_type.IsDoubleLo());
   EXPECT_FALSE(bool_reg_type.IsReference());
   EXPECT_FALSE(bool_reg_type.IsLowHalf());
   EXPECT_FALSE(bool_reg_type.IsHighHalf());
@@ -142,22 +186,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(bool_reg_type.IsDoubleTypes());
   EXPECT_TRUE(bool_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(bool_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(bool_reg_type.HasClass());
+  EXPECT_FALSE(bool_reg_type.HasClass());
 
   const RegType& byte_reg_type = cache.Byte();
   EXPECT_FALSE(byte_reg_type.IsUndefined());
   EXPECT_FALSE(byte_reg_type.IsConflict());
-  EXPECT_FALSE(byte_reg_type.IsZero());
-  EXPECT_FALSE(byte_reg_type.IsOne());
-  EXPECT_FALSE(byte_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(byte_reg_type.IsBoolean());
   EXPECT_TRUE(byte_reg_type.IsByte());
   EXPECT_FALSE(byte_reg_type.IsChar());
   EXPECT_FALSE(byte_reg_type.IsShort());
   EXPECT_FALSE(byte_reg_type.IsInteger());
-  EXPECT_FALSE(byte_reg_type.IsLong());
+  EXPECT_FALSE(byte_reg_type.IsLongLo());
   EXPECT_FALSE(byte_reg_type.IsFloat());
-  EXPECT_FALSE(byte_reg_type.IsDouble());
+  EXPECT_FALSE(byte_reg_type.IsDoubleLo());
   EXPECT_FALSE(byte_reg_type.IsReference());
   EXPECT_FALSE(byte_reg_type.IsLowHalf());
   EXPECT_FALSE(byte_reg_type.IsHighHalf());
@@ -175,22 +217,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(byte_reg_type.IsDoubleTypes());
   EXPECT_TRUE(byte_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(byte_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(byte_reg_type.HasClass());
+  EXPECT_FALSE(byte_reg_type.HasClass());
 
   const RegType& char_reg_type = cache.Char();
   EXPECT_FALSE(char_reg_type.IsUndefined());
   EXPECT_FALSE(char_reg_type.IsConflict());
-  EXPECT_FALSE(char_reg_type.IsZero());
-  EXPECT_FALSE(char_reg_type.IsOne());
-  EXPECT_FALSE(char_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(char_reg_type.IsBoolean());
   EXPECT_FALSE(char_reg_type.IsByte());
   EXPECT_TRUE(char_reg_type.IsChar());
   EXPECT_FALSE(char_reg_type.IsShort());
   EXPECT_FALSE(char_reg_type.IsInteger());
-  EXPECT_FALSE(char_reg_type.IsLong());
+  EXPECT_FALSE(char_reg_type.IsLongLo());
   EXPECT_FALSE(char_reg_type.IsFloat());
-  EXPECT_FALSE(char_reg_type.IsDouble());
+  EXPECT_FALSE(char_reg_type.IsDoubleLo());
   EXPECT_FALSE(char_reg_type.IsReference());
   EXPECT_FALSE(char_reg_type.IsLowHalf());
   EXPECT_FALSE(char_reg_type.IsHighHalf());
@@ -208,22 +248,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(char_reg_type.IsDoubleTypes());
   EXPECT_TRUE(char_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(char_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(char_reg_type.HasClass());
+  EXPECT_FALSE(char_reg_type.HasClass());
 
   const RegType& short_reg_type = cache.Short();
   EXPECT_FALSE(short_reg_type.IsUndefined());
   EXPECT_FALSE(short_reg_type.IsConflict());
-  EXPECT_FALSE(short_reg_type.IsZero());
-  EXPECT_FALSE(short_reg_type.IsOne());
-  EXPECT_FALSE(short_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(short_reg_type.IsBoolean());
   EXPECT_FALSE(short_reg_type.IsByte());
   EXPECT_FALSE(short_reg_type.IsChar());
   EXPECT_TRUE(short_reg_type.IsShort());
   EXPECT_FALSE(short_reg_type.IsInteger());
-  EXPECT_FALSE(short_reg_type.IsLong());
+  EXPECT_FALSE(short_reg_type.IsLongLo());
   EXPECT_FALSE(short_reg_type.IsFloat());
-  EXPECT_FALSE(short_reg_type.IsDouble());
+  EXPECT_FALSE(short_reg_type.IsDoubleLo());
   EXPECT_FALSE(short_reg_type.IsReference());
   EXPECT_FALSE(short_reg_type.IsLowHalf());
   EXPECT_FALSE(short_reg_type.IsHighHalf());
@@ -241,22 +279,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(short_reg_type.IsDoubleTypes());
   EXPECT_TRUE(short_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(short_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(short_reg_type.HasClass());
+  EXPECT_FALSE(short_reg_type.HasClass());
 
   const RegType& int_reg_type = cache.Integer();
   EXPECT_FALSE(int_reg_type.IsUndefined());
   EXPECT_FALSE(int_reg_type.IsConflict());
-  EXPECT_FALSE(int_reg_type.IsZero());
-  EXPECT_FALSE(int_reg_type.IsOne());
-  EXPECT_FALSE(int_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(int_reg_type.IsBoolean());
   EXPECT_FALSE(int_reg_type.IsByte());
   EXPECT_FALSE(int_reg_type.IsChar());
   EXPECT_FALSE(int_reg_type.IsShort());
   EXPECT_TRUE(int_reg_type.IsInteger());
-  EXPECT_FALSE(int_reg_type.IsLong());
+  EXPECT_FALSE(int_reg_type.IsLongLo());
   EXPECT_FALSE(int_reg_type.IsFloat());
-  EXPECT_FALSE(int_reg_type.IsDouble());
+  EXPECT_FALSE(int_reg_type.IsDoubleLo());
   EXPECT_FALSE(int_reg_type.IsReference());
   EXPECT_FALSE(int_reg_type.IsLowHalf());
   EXPECT_FALSE(int_reg_type.IsHighHalf());
@@ -274,22 +310,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(int_reg_type.IsDoubleTypes());
   EXPECT_TRUE(int_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(int_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(int_reg_type.HasClass());
+  EXPECT_FALSE(int_reg_type.HasClass());
 
   const RegType& long_reg_type = cache.LongLo();
   EXPECT_FALSE(long_reg_type.IsUndefined());
   EXPECT_FALSE(long_reg_type.IsConflict());
-  EXPECT_FALSE(long_reg_type.IsZero());
-  EXPECT_FALSE(long_reg_type.IsOne());
-  EXPECT_FALSE(long_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(long_reg_type.IsBoolean());
   EXPECT_FALSE(long_reg_type.IsByte());
   EXPECT_FALSE(long_reg_type.IsChar());
   EXPECT_FALSE(long_reg_type.IsShort());
   EXPECT_FALSE(long_reg_type.IsInteger());
-  EXPECT_TRUE(long_reg_type.IsLong());
+  EXPECT_TRUE(long_reg_type.IsLongLo());
   EXPECT_FALSE(long_reg_type.IsFloat());
-  EXPECT_FALSE(long_reg_type.IsDouble());
+  EXPECT_FALSE(long_reg_type.IsDoubleLo());
   EXPECT_FALSE(long_reg_type.IsReference());
   EXPECT_TRUE(long_reg_type.IsLowHalf());
   EXPECT_FALSE(long_reg_type.IsHighHalf());
@@ -307,22 +341,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(long_reg_type.IsDoubleTypes());
   EXPECT_FALSE(long_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(long_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(long_reg_type.HasClass());
+  EXPECT_FALSE(long_reg_type.HasClass());
 
   const RegType& float_reg_type = cache.Float();
   EXPECT_FALSE(float_reg_type.IsUndefined());
   EXPECT_FALSE(float_reg_type.IsConflict());
-  EXPECT_FALSE(float_reg_type.IsZero());
-  EXPECT_FALSE(float_reg_type.IsOne());
-  EXPECT_FALSE(float_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(float_reg_type.IsBoolean());
   EXPECT_FALSE(float_reg_type.IsByte());
   EXPECT_FALSE(float_reg_type.IsChar());
   EXPECT_FALSE(float_reg_type.IsShort());
   EXPECT_FALSE(float_reg_type.IsInteger());
-  EXPECT_FALSE(float_reg_type.IsLong());
+  EXPECT_FALSE(float_reg_type.IsLongLo());
   EXPECT_TRUE(float_reg_type.IsFloat());
-  EXPECT_FALSE(float_reg_type.IsDouble());
+  EXPECT_FALSE(float_reg_type.IsDoubleLo());
   EXPECT_FALSE(float_reg_type.IsReference());
   EXPECT_FALSE(float_reg_type.IsLowHalf());
   EXPECT_FALSE(float_reg_type.IsHighHalf());
@@ -340,22 +372,20 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_FALSE(float_reg_type.IsDoubleTypes());
   EXPECT_FALSE(float_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(float_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(float_reg_type.HasClass());
+  EXPECT_FALSE(float_reg_type.HasClass());
 
   const RegType& double_reg_type = cache.DoubleLo();
   EXPECT_FALSE(double_reg_type.IsUndefined());
   EXPECT_FALSE(double_reg_type.IsConflict());
-  EXPECT_FALSE(double_reg_type.IsZero());
-  EXPECT_FALSE(double_reg_type.IsOne());
-  EXPECT_FALSE(double_reg_type.IsLongConstant());
+  EXPECT_FALSE(bool_reg_type.IsConstantTypes());
   EXPECT_FALSE(double_reg_type.IsBoolean());
   EXPECT_FALSE(double_reg_type.IsByte());
   EXPECT_FALSE(double_reg_type.IsChar());
   EXPECT_FALSE(double_reg_type.IsShort());
   EXPECT_FALSE(double_reg_type.IsInteger());
-  EXPECT_FALSE(double_reg_type.IsLong());
+  EXPECT_FALSE(double_reg_type.IsLongLo());
   EXPECT_FALSE(double_reg_type.IsFloat());
-  EXPECT_TRUE(double_reg_type.IsDouble());
+  EXPECT_TRUE(double_reg_type.IsDoubleLo());
   EXPECT_FALSE(double_reg_type.IsReference());
   EXPECT_TRUE(double_reg_type.IsLowHalf());
   EXPECT_FALSE(double_reg_type.IsHighHalf());
@@ -373,102 +403,68 @@ TEST_F(RegTypeTest, Primitives) {
   EXPECT_TRUE(double_reg_type.IsDoubleTypes());
   EXPECT_FALSE(double_reg_type.IsArrayIndexTypes());
   EXPECT_FALSE(double_reg_type.IsNonZeroReferenceTypes());
-  EXPECT_TRUE(double_reg_type.HasClass());
+  EXPECT_FALSE(double_reg_type.HasClass());
 }
 
 class RegTypeReferenceTest : public RegTypeTest {};
 
-TEST_F(RegTypeReferenceTest, JavaLangObjectImprecise) {
-  // Tests matching precisions. A reference type that was created precise doesn't
-  // match the one that is imprecise.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
-  ScopedObjectAccess soa(Thread::Current());
-  ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& imprecise_obj = cache.JavaLangObject(false);
-  const RegType& precise_obj = cache.JavaLangObject(true);
-  const RegType& precise_obj_2 = PreciseJavaLangObjectFromDescriptor(&cache, loader);
-
-  EXPECT_TRUE(precise_obj.Equals(precise_obj_2));
-  EXPECT_FALSE(imprecise_obj.Equals(precise_obj));
-  EXPECT_FALSE(imprecise_obj.Equals(precise_obj));
-  EXPECT_FALSE(imprecise_obj.Equals(precise_obj_2));
-}
-
 TEST_F(RegTypeReferenceTest, UnresolvedType) {
   // Tests creating unresolved types. Miss for the first time asking the cache and
   // a hit second time.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& ref_type_0 = cache.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  const RegType& ref_type_0 = cache.FromDescriptor("Ljava/lang/DoesNotExist;");
   EXPECT_TRUE(ref_type_0.IsUnresolvedReference());
   EXPECT_TRUE(ref_type_0.IsNonZeroReferenceTypes());
 
-  const RegType& ref_type_1 = cache.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
+  const RegType& ref_type_1 = cache.FromDescriptor("Ljava/lang/DoesNotExist;");
   EXPECT_TRUE(ref_type_0.Equals(ref_type_1));
-
-  const RegType& unresolved_super_class =  cache.FromUnresolvedSuperClass(ref_type_0);
-  EXPECT_TRUE(unresolved_super_class.IsUnresolvedSuperClass());
-  EXPECT_TRUE(unresolved_super_class.IsNonZeroReferenceTypes());
 }
 
 TEST_F(RegTypeReferenceTest, UnresolvedUnintializedType) {
   // Tests creating types uninitialized types from unresolved types.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& ref_type_0 = cache.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  const RegType& ref_type_0 = cache.FromDescriptor("Ljava/lang/DoesNotExist;");
   EXPECT_TRUE(ref_type_0.IsUnresolvedReference());
-  const RegType& ref_type = cache.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
+  const RegType& ref_type = cache.FromDescriptor("Ljava/lang/DoesNotExist;");
   EXPECT_TRUE(ref_type_0.Equals(ref_type));
-  // Create an uninitialized type of this unresolved type
-  const RegType& unresolved_unintialised = cache.Uninitialized(ref_type, 1101ull);
-  EXPECT_TRUE(unresolved_unintialised.IsUnresolvedAndUninitializedReference());
-  EXPECT_TRUE(unresolved_unintialised.IsUninitializedTypes());
-  EXPECT_TRUE(unresolved_unintialised.IsNonZeroReferenceTypes());
-  // Create an uninitialized type of this unresolved type with different  PC
-  const RegType& ref_type_unresolved_unintialised_1 =  cache.Uninitialized(ref_type, 1102ull);
-  EXPECT_TRUE(unresolved_unintialised.IsUnresolvedAndUninitializedReference());
-  EXPECT_FALSE(unresolved_unintialised.Equals(ref_type_unresolved_unintialised_1));
-  // Create an uninitialized type of this unresolved type with the same PC
-  const RegType& unresolved_unintialised_2 = cache.Uninitialized(ref_type, 1101ull);
-  EXPECT_TRUE(unresolved_unintialised.Equals(unresolved_unintialised_2));
+  // Create an uninitialized type of this unresolved type.
+  const RegType& unresolved_uninitialized = cache.Uninitialized(ref_type);
+  EXPECT_TRUE(unresolved_uninitialized.IsUnresolvedUninitializedReference());
+  EXPECT_TRUE(unresolved_uninitialized.IsUninitializedTypes());
+  EXPECT_TRUE(unresolved_uninitialized.IsNonZeroReferenceTypes());
+  // Create an another uninitialized type of this unresolved type.
+  const RegType& unresolved_uninitialized_2 = cache.Uninitialized(ref_type);
+  EXPECT_TRUE(unresolved_uninitialized.Equals(unresolved_uninitialized_2));
 }
 
 TEST_F(RegTypeReferenceTest, Dump) {
   // Tests types for proper Dump messages.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& unresolved_ref = cache.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
-  const RegType& unresolved_ref_another =
-      cache.FromDescriptor(loader, "Ljava/lang/DoesNotExistEither;");
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  const RegType& unresolved_ref = cache.FromDescriptor("Ljava/lang/DoesNotExist;");
+  const RegType& unresolved_ref_another = cache.FromDescriptor("Ljava/lang/DoesNotExistEither;");
   const RegType& resolved_ref = cache.JavaLangString();
-  const RegType& resolved_unintialiesd = cache.Uninitialized(resolved_ref, 10);
-  const RegType& unresolved_unintialized = cache.Uninitialized(unresolved_ref, 12);
+  const RegType& resolved_uninitialized = cache.Uninitialized(resolved_ref);
+  const RegType& unresolved_uninitialized = cache.Uninitialized(unresolved_ref);
   const RegType& unresolved_merged = cache.FromUnresolvedMerge(
       unresolved_ref, unresolved_ref_another, /* verifier= */ nullptr);
 
   std::string expected = "Unresolved Reference: java.lang.DoesNotExist";
   EXPECT_EQ(expected, unresolved_ref.Dump());
-  expected = "Precise Reference: java.lang.String";
+  expected = "Reference: java.lang.String";
   EXPECT_EQ(expected, resolved_ref.Dump());
-  expected ="Uninitialized Reference: java.lang.String Allocation PC: 10";
-  EXPECT_EQ(expected, resolved_unintialiesd.Dump());
-  expected = "Unresolved And Uninitialized Reference: java.lang.DoesNotExist Allocation PC: 12";
-  EXPECT_EQ(expected, unresolved_unintialized.Dump());
+  expected ="Uninitialized Reference: java.lang.String";
+  EXPECT_EQ(expected, resolved_uninitialized .Dump());
+  expected = "Unresolved And Uninitialized Reference: java.lang.DoesNotExist";
+  EXPECT_EQ(expected, unresolved_uninitialized.Dump());
   expected = "UnresolvedMergedReferences(Zero/null | Unresolved Reference: java.lang.DoesNotExist, Unresolved Reference: java.lang.DoesNotExistEither)";
   EXPECT_EQ(expected, unresolved_merged.Dump());
 }
@@ -477,60 +473,55 @@ TEST_F(RegTypeReferenceTest, JavalangString) {
   // Add a class to the cache then look for the same class and make sure it is  a
   // Hit the second time. Then check for the same effect when using
   // The JavaLangObject method instead of FromDescriptor. String class is final.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
   const RegType& ref_type = cache.JavaLangString();
   const RegType& ref_type_2 = cache.JavaLangString();
-  const RegType& ref_type_3 = cache.FromDescriptor(loader, "Ljava/lang/String;");
+  const RegType& ref_type_3 = cache.FromDescriptor("Ljava/lang/String;");
 
   EXPECT_TRUE(ref_type.Equals(ref_type_2));
   EXPECT_TRUE(ref_type_2.Equals(ref_type_3));
-  EXPECT_TRUE(ref_type.IsPreciseReference());
+  EXPECT_TRUE(ref_type.IsReference());
 
   // Create an uninitialized type out of this:
-  const RegType& ref_type_unintialized = cache.Uninitialized(ref_type, 0110ull);
-  EXPECT_TRUE(ref_type_unintialized.IsUninitializedReference());
-  EXPECT_FALSE(ref_type_unintialized.IsUnresolvedAndUninitializedReference());
+  const RegType& ref_type_uninitialized = cache.Uninitialized(ref_type);
+  EXPECT_TRUE(ref_type_uninitialized.IsUninitializedReference());
+  EXPECT_FALSE(ref_type_uninitialized.IsUnresolvedUninitializedReference());
 }
 
 TEST_F(RegTypeReferenceTest, JavalangObject) {
   // Add a class to the cache then look for the same class and make sure it is  a
   // Hit the second time. Then I am checking for the same effect when using
   // The JavaLangObject method instead of FromDescriptor. Object Class in not final.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& ref_type = cache.JavaLangObject(true);
-  const RegType& ref_type_2 = cache.JavaLangObject(true);
-  const RegType& ref_type_3 = PreciseJavaLangObjectFromDescriptor(&cache, loader);
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  const RegType& ref_type = cache.JavaLangObject();
+  const RegType& ref_type_2 = cache.JavaLangObject();
+  const RegType& ref_type_3 = cache.FromDescriptor("Ljava/lang/Object;");
 
   EXPECT_TRUE(ref_type.Equals(ref_type_2));
   EXPECT_TRUE(ref_type_3.Equals(ref_type_2));
   EXPECT_EQ(ref_type.GetId(), ref_type_3.GetId());
 }
+
 TEST_F(RegTypeReferenceTest, Merging) {
   // Tests merging logic
   // String and object , LUB is object.
   ScopedObjectAccess soa(Thread::Current());
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache_new(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
+  RegTypeCache cache_new(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
   const RegType& string = cache_new.JavaLangString();
-  const RegType& Object = cache_new.JavaLangObject(true);
+  const RegType& Object = cache_new.JavaLangObject();
   EXPECT_TRUE(string.Merge(Object, &cache_new, /* verifier= */ nullptr).IsJavaLangObject());
   // Merge two unresolved types.
-  const RegType& ref_type_0 = cache_new.FromDescriptor(loader, "Ljava/lang/DoesNotExist;");
+  const RegType& ref_type_0 = cache_new.FromDescriptor("Ljava/lang/DoesNotExist;");
   EXPECT_TRUE(ref_type_0.IsUnresolvedReference());
-  const RegType& ref_type_1 = cache_new.FromDescriptor(loader, "Ljava/lang/DoesNotExistToo;");
+  const RegType& ref_type_1 = cache_new.FromDescriptor("Ljava/lang/DoesNotExistToo;");
   EXPECT_FALSE(ref_type_0.Equals(ref_type_1));
 
   const RegType& merged = ref_type_1.Merge(ref_type_0, &cache_new, /* verifier= */ nullptr);
@@ -538,168 +529,135 @@ TEST_F(RegTypeReferenceTest, Merging) {
   RegType& merged_nonconst = const_cast<RegType&>(merged);
 
   const BitVector& unresolved_parts =
-      down_cast<UnresolvedMergedType*>(&merged_nonconst)->GetUnresolvedTypes();
+      down_cast<UnresolvedMergedReferenceType*>(&merged_nonconst)->GetUnresolvedTypes();
   EXPECT_TRUE(unresolved_parts.IsBitSet(ref_type_0.GetId()));
   EXPECT_TRUE(unresolved_parts.IsBitSet(ref_type_1.GetId()));
 }
 
 TEST_F(RegTypeTest, MergingFloat) {
   // Testing merging logic with float and float constants.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache_new(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-
-  constexpr int32_t kTestConstantValue = 10;
-  const RegType& float_type = cache_new.Float();
-  const RegType& precise_cst = cache_new.FromCat1Const(kTestConstantValue, true);
-  const RegType& imprecise_cst = cache_new.FromCat1Const(kTestConstantValue, false);
-  {
-    // float MERGE precise cst => float.
-    const RegType& merged = float_type.Merge(precise_cst, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsFloat());
-  }
-  {
-    // precise cst MERGE float => float.
-    const RegType& merged = precise_cst.Merge(float_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsFloat());
-  }
-  {
-    // float MERGE imprecise cst => float.
-    const RegType& merged = float_type.Merge(imprecise_cst, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsFloat());
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  std::array<const RegType*, kNumConstTypes> const_reg_types = GetConstRegTypes(cache);
+
+  const RegType& float_type = cache.Float();
+  for (const RegType* const_type : const_reg_types) {
+    // float MERGE cst => float.
+    const RegType& merged = float_type.Merge(*const_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstant()) {
+      EXPECT_TRUE(merged.IsFloat()) << RegTypeWrapper(*const_type);
+    } else {
+      DCHECK(const_type->IsConstantLo() || const_type->IsConstantHi() || const_type->IsNull());
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // imprecise cst MERGE float => float.
-    const RegType& merged = imprecise_cst.Merge(float_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsFloat());
+  for (const RegType* const_type : const_reg_types) {
+    // cst MERGE float => float.
+    const RegType& merged = const_type->Merge(float_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstant()) {
+      EXPECT_TRUE(merged.IsFloat()) << RegTypeWrapper(*const_type);
+    } else {
+      DCHECK(const_type->IsConstantLo() || const_type->IsConstantHi() || const_type->IsNull());
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
 }
 
 TEST_F(RegTypeTest, MergingLong) {
   // Testing merging logic with long and long constants.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache_new(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-
-  constexpr int32_t kTestConstantValue = 10;
-  const RegType& long_lo_type = cache_new.LongLo();
-  const RegType& long_hi_type = cache_new.LongHi();
-  const RegType& precise_cst_lo = cache_new.FromCat2ConstLo(kTestConstantValue, true);
-  const RegType& imprecise_cst_lo = cache_new.FromCat2ConstLo(kTestConstantValue, false);
-  const RegType& precise_cst_hi = cache_new.FromCat2ConstHi(kTestConstantValue, true);
-  const RegType& imprecise_cst_hi = cache_new.FromCat2ConstHi(kTestConstantValue, false);
-  {
-    // lo MERGE precise cst lo => lo.
-    const RegType& merged = long_lo_type.Merge(precise_cst_lo, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongLo());
-  }
-  {
-    // precise cst lo MERGE lo => lo.
-    const RegType& merged = precise_cst_lo.Merge(long_lo_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongLo());
-  }
-  {
-    // lo MERGE imprecise cst lo => lo.
-    const RegType& merged = long_lo_type.Merge(
-        imprecise_cst_lo, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongLo());
-  }
-  {
-    // imprecise cst lo MERGE lo => lo.
-    const RegType& merged = imprecise_cst_lo.Merge(
-        long_lo_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongLo());
-  }
-  {
-    // hi MERGE precise cst hi => hi.
-    const RegType& merged = long_hi_type.Merge(precise_cst_hi, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongHi());
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  std::array<const RegType*, kNumConstTypes> const_reg_types = GetConstRegTypes(cache);
+
+  const RegType& long_lo_type = cache.LongLo();
+  const RegType& long_hi_type = cache.LongHi();
+  for (const RegType* const_type : const_reg_types) {
+    // lo MERGE cst lo => lo.
+    const RegType& merged = long_lo_type.Merge(*const_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantLo()) {
+      EXPECT_TRUE(merged.IsLongLo()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // precise cst hi MERGE hi => hi.
-    const RegType& merged = precise_cst_hi.Merge(long_hi_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongHi());
+  for (const RegType* const_type : const_reg_types) {
+    // cst lo MERGE lo => lo.
+    const RegType& merged = const_type->Merge(long_lo_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantLo()) {
+      EXPECT_TRUE(merged.IsLongLo()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // hi MERGE imprecise cst hi => hi.
-    const RegType& merged = long_hi_type.Merge(
-        imprecise_cst_hi, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongHi());
+  for (const RegType* const_type : const_reg_types) {
+    // hi MERGE cst hi => hi.
+    const RegType& merged = long_hi_type.Merge(*const_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantHi()) {
+      EXPECT_TRUE(merged.IsLongHi()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // imprecise cst hi MERGE hi => hi.
-    const RegType& merged = imprecise_cst_hi.Merge(
-        long_hi_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsLongHi());
+  for (const RegType* const_type : const_reg_types) {
+    // cst hi MERGE hi => hi.
+    const RegType& merged = const_type->Merge(long_hi_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantHi()) {
+      EXPECT_TRUE(merged.IsLongHi()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
 }
 
 TEST_F(RegTypeTest, MergingDouble) {
   // Testing merging logic with double and double constants.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache_new(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-
-  constexpr int32_t kTestConstantValue = 10;
-  const RegType& double_lo_type = cache_new.DoubleLo();
-  const RegType& double_hi_type = cache_new.DoubleHi();
-  const RegType& precise_cst_lo = cache_new.FromCat2ConstLo(kTestConstantValue, true);
-  const RegType& imprecise_cst_lo = cache_new.FromCat2ConstLo(kTestConstantValue, false);
-  const RegType& precise_cst_hi = cache_new.FromCat2ConstHi(kTestConstantValue, true);
-  const RegType& imprecise_cst_hi = cache_new.FromCat2ConstHi(kTestConstantValue, false);
-  {
-    // lo MERGE precise cst lo => lo.
-    const RegType& merged = double_lo_type.Merge(
-        precise_cst_lo, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleLo());
-  }
-  {
-    // precise cst lo MERGE lo => lo.
-    const RegType& merged = precise_cst_lo.Merge(
-        double_lo_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleLo());
-  }
-  {
-    // lo MERGE imprecise cst lo => lo.
-    const RegType& merged = double_lo_type.Merge(
-        imprecise_cst_lo, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleLo());
-  }
-  {
-    // imprecise cst lo MERGE lo => lo.
-    const RegType& merged = imprecise_cst_lo.Merge(
-        double_lo_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleLo());
-  }
-  {
-    // hi MERGE precise cst hi => hi.
-    const RegType& merged = double_hi_type.Merge(
-        precise_cst_hi, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleHi());
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  std::array<const RegType*, kNumConstTypes> const_reg_types = GetConstRegTypes(cache);
+
+  const RegType& double_lo_type = cache.DoubleLo();
+  const RegType& double_hi_type = cache.DoubleHi();
+  for (const RegType* const_type : const_reg_types) {
+    // lo MERGE cst lo => lo.
+    const RegType& merged = double_lo_type.Merge(*const_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantLo()) {
+      EXPECT_TRUE(merged.IsDoubleLo()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // precise cst hi MERGE hi => hi.
-    const RegType& merged = precise_cst_hi.Merge(
-        double_hi_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleHi());
+  for (const RegType* const_type : const_reg_types) {
+    // cst lo MERGE lo => lo.
+    const RegType& merged = const_type->Merge(double_lo_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantLo()) {
+      EXPECT_TRUE(merged.IsDoubleLo()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // hi MERGE imprecise cst hi => hi.
-    const RegType& merged = double_hi_type.Merge(
-        imprecise_cst_hi, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleHi());
+  for (const RegType* const_type : const_reg_types) {
+    // hi MERGE cst hi => hi.
+    const RegType& merged = double_hi_type.Merge(*const_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantHi()) {
+      EXPECT_TRUE(merged.IsDoubleHi()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
-  {
-    // imprecise cst hi MERGE hi => hi.
-    const RegType& merged = imprecise_cst_hi.Merge(
-        double_hi_type, &cache_new, /* verifier= */ nullptr);
-    EXPECT_TRUE(merged.IsDoubleHi());
+  for (const RegType* const_type : const_reg_types) {
+    // cst hi MERGE hi => hi.
+    const RegType& merged = const_type->Merge(double_hi_type, &cache, /* verifier= */ nullptr);
+    if (const_type->IsConstantHi()) {
+      EXPECT_TRUE(merged.IsDoubleHi()) << RegTypeWrapper(*const_type);
+    } else {
+      EXPECT_TRUE(merged.IsConflict()) << RegTypeWrapper(*const_type);
+    }
   }
 }
 
@@ -752,59 +710,56 @@ TEST_F(RegTypeTest, MergeSemiLatticeRef) {
   //                                 |
   //                                 0
 
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
 
   ScopedDisableMovingGC no_gc(soa.Self());
 
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
 
   const RegType& conflict = cache.Conflict();
   const RegType& zero = cache.Zero();
   const RegType& null = cache.Null();
   const RegType& int_type = cache.Integer();
 
-  const RegType& obj = cache.JavaLangObject(false);
-  const RegType& obj_arr = cache.FromDescriptor(loader, "[Ljava/lang/Object;");
+  const RegType& obj = cache.JavaLangObject();
+  const RegType& obj_arr = cache.FromDescriptor("[Ljava/lang/Object;");
   ASSERT_FALSE(obj_arr.IsUnresolvedReference());
 
-  const RegType& unresolved_a = cache.FromDescriptor(loader, "Ldoes/not/resolve/A;");
+  const RegType& unresolved_a = cache.FromDescriptor("Ldoes/not/resolve/A;");
   ASSERT_TRUE(unresolved_a.IsUnresolvedReference());
-  const RegType& unresolved_b = cache.FromDescriptor(loader, "Ldoes/not/resolve/B;");
+  const RegType& unresolved_b = cache.FromDescriptor("Ldoes/not/resolve/B;");
   ASSERT_TRUE(unresolved_b.IsUnresolvedReference());
   const RegType& unresolved_ab = cache.FromUnresolvedMerge(unresolved_a, unresolved_b, nullptr);
   ASSERT_TRUE(unresolved_ab.IsUnresolvedMergedReference());
 
   const RegType& uninit_this = cache.UninitializedThisArgument(obj);
-  const RegType& uninit_obj_0 = cache.Uninitialized(obj, 0u);
-  const RegType& uninit_obj_1 = cache.Uninitialized(obj, 1u);
+  const RegType& uninit_obj = cache.Uninitialized(obj);
 
   const RegType& uninit_unres_this = cache.UninitializedThisArgument(unresolved_a);
-  const RegType& uninit_unres_a_0 = cache.Uninitialized(unresolved_a, 0);
-  const RegType& uninit_unres_b_0 = cache.Uninitialized(unresolved_b, 0);
+  const RegType& uninit_unres_a = cache.Uninitialized(unresolved_a);
+  const RegType& uninit_unres_b = cache.Uninitialized(unresolved_b);
 
-  const RegType& number = cache.FromDescriptor(loader, "Ljava/lang/Number;");
+  const RegType& number = cache.FromDescriptor("Ljava/lang/Number;");
   ASSERT_FALSE(number.IsUnresolvedReference());
-  const RegType& integer = cache.FromDescriptor(loader, "Ljava/lang/Integer;");
+  const RegType& integer = cache.FromDescriptor("Ljava/lang/Integer;");
   ASSERT_FALSE(integer.IsUnresolvedReference());
 
-  const RegType& uninit_number_0 = cache.Uninitialized(number, 0u);
-  const RegType& uninit_integer_0 = cache.Uninitialized(integer, 0u);
+  const RegType& uninit_number = cache.Uninitialized(number);
+  const RegType& uninit_integer = cache.Uninitialized(integer);
 
-  const RegType& number_arr = cache.FromDescriptor(loader, "[Ljava/lang/Number;");
+  const RegType& number_arr = cache.FromDescriptor("[Ljava/lang/Number;");
   ASSERT_FALSE(number_arr.IsUnresolvedReference());
-  const RegType& integer_arr = cache.FromDescriptor(loader, "[Ljava/lang/Integer;");
+  const RegType& integer_arr = cache.FromDescriptor("[Ljava/lang/Integer;");
   ASSERT_FALSE(integer_arr.IsUnresolvedReference());
 
-  const RegType& number_arr_arr = cache.FromDescriptor(loader, "[[Ljava/lang/Number;");
+  const RegType& number_arr_arr = cache.FromDescriptor("[[Ljava/lang/Number;");
   ASSERT_FALSE(number_arr_arr.IsUnresolvedReference());
 
-  const RegType& char_arr = cache.FromDescriptor(loader, "[C");
+  const RegType& char_arr = cache.FromDescriptor("[C");
   ASSERT_FALSE(char_arr.IsUnresolvedReference());
-  const RegType& byte_arr = cache.FromDescriptor(loader, "[B");
+  const RegType& byte_arr = cache.FromDescriptor("[B");
   ASSERT_FALSE(byte_arr.IsUnresolvedReference());
 
   const RegType& unresolved_a_num = cache.FromUnresolvedMerge(unresolved_a, number, nullptr);
@@ -821,7 +776,7 @@ TEST_F(RegTypeTest, MergeSemiLatticeRef) {
   const RegType& unresolved_ab_int = cache.FromUnresolvedMerge(unresolved_ab, integer, nullptr);
   ASSERT_TRUE(unresolved_ab_int.IsUnresolvedMergedReference());
   std::vector<const RegType*> uninitialized_types = {
-      &uninit_this, &uninit_obj_0, &uninit_obj_1, &uninit_number_0, &uninit_integer_0
+      &uninit_this, &uninit_obj, &uninit_number, &uninit_integer
   };
   std::vector<const RegType*> unresolved_types = {
       &unresolved_a,
@@ -835,7 +790,7 @@ TEST_F(RegTypeTest, MergeSemiLatticeRef) {
       &unresolved_ab_int
   };
   std::vector<const RegType*> uninit_unresolved_types = {
-      &uninit_unres_this, &uninit_unres_a_0, &uninit_unres_b_0
+      &uninit_unres_this, &uninit_unres_a, &uninit_unres_b
   };
   std::vector<const RegType*> plain_nonobj_classes = { &number, &integer };
   std::vector<const RegType*> plain_nonobj_arr_classes = {
@@ -1079,21 +1034,6 @@ TEST_F(RegTypeTest, MergeSemiLatticeRef) {
   }
 }
 
-TEST_F(RegTypeTest, ConstPrecision) {
-  // Tests creating primitive types types.
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
-  ScopedObjectAccess soa(Thread::Current());
-  RegTypeCache cache_new(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& imprecise_const = cache_new.FromCat1Const(10, false);
-  const RegType& precise_const = cache_new.FromCat1Const(10, true);
-
-  EXPECT_TRUE(imprecise_const.IsImpreciseConstant());
-  EXPECT_TRUE(precise_const.IsPreciseConstant());
-  EXPECT_FALSE(imprecise_const.Equals(precise_const));
-}
-
 class RegTypeOOMTest : public RegTypeTest {
  protected:
   void SetUpRuntimeOptions(RuntimeOptions *options) override {
@@ -1110,8 +1050,7 @@ TEST_F(RegTypeOOMTest, ClassJoinOOM) {
 
   // Tests that we don't abort with OOMs.
 
-  ArenaStack stack(Runtime::Current()->GetArenaPool());
-  ScopedArenaAllocator allocator(&stack);
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
   ScopedObjectAccess soa(Thread::Current());
 
   ScopedDisableMovingGC no_gc(soa.Self());
@@ -1125,21 +1064,19 @@ TEST_F(RegTypeOOMTest, ClassJoinOOM) {
   constexpr const char* kNumberArrayFive = "[[[[[Ljava/lang/Number;";
 
   ScopedNullHandle<mirror::ClassLoader> loader;
-  RegTypeCache cache(
-      soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-  const RegType& int_array_array = cache.FromDescriptor(loader, kIntArrayFive);
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+  const RegType& int_array_array = cache.FromDescriptor(kIntArrayFive);
   ASSERT_TRUE(int_array_array.HasClass());
-  const RegType& float_array_array = cache.FromDescriptor(loader, kFloatArrayFive);
+  const RegType& float_array_array = cache.FromDescriptor(kFloatArrayFive);
   ASSERT_TRUE(float_array_array.HasClass());
 
   // Check assumptions: the joined classes don't exist, yet.
-  ClassLinker* class_linker = Runtime::Current()->GetClassLinker();
-  ASSERT_TRUE(class_linker->LookupClass(soa.Self(), kNumberArrayFour, nullptr) == nullptr);
-  ASSERT_TRUE(class_linker->LookupClass(soa.Self(), kNumberArrayFive, nullptr) == nullptr);
+  ASSERT_TRUE(class_linker_->LookupClass(soa.Self(), kNumberArrayFour, nullptr) == nullptr);
+  ASSERT_TRUE(class_linker_->LookupClass(soa.Self(), kNumberArrayFive, nullptr) == nullptr);
 
   // Fill the heap.
   VariableSizedHandleScope hs(soa.Self());
-  FillHeap(soa.Self(), class_linker, &hs);
+  FillHeap(soa.Self(), class_linker_, &hs);
 
   const RegType& join_type = int_array_array.Merge(float_array_array, &cache, nullptr);
   ASSERT_TRUE(join_type.IsUnresolvedReference());
@@ -1148,8 +1085,7 @@ TEST_F(RegTypeOOMTest, ClassJoinOOM) {
 class RegTypeClassJoinTest : public RegTypeTest {
  protected:
   void TestClassJoin(const char* in1, const char* in2, const char* out) {
-    ArenaStack stack(Runtime::Current()->GetArenaPool());
-    ScopedArenaAllocator allocator(&stack);
+    ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
 
     ScopedObjectAccess soa(Thread::Current());
     jobject jclass_loader = LoadDex("Interfaces");
@@ -1157,22 +1093,29 @@ class RegTypeClassJoinTest : public RegTypeTest {
     Handle<mirror::ClassLoader> class_loader(
         hs.NewHandle(soa.Decode<mirror::ClassLoader>(jclass_loader)));
 
-    Handle<mirror::Class> c1(hs.NewHandle(
-        class_linker_->FindClass(soa.Self(), in1, class_loader)));
-    Handle<mirror::Class> c2(hs.NewHandle(
-        class_linker_->FindClass(soa.Self(), in2, class_loader)));
+    Handle<mirror::Class> c1 = hs.NewHandle(FindClass(in1, class_loader));
+    Handle<mirror::Class> c2 = hs.NewHandle(FindClass(in2, class_loader));
     ASSERT_TRUE(c1 != nullptr);
     ASSERT_TRUE(c2 != nullptr);
+    const DexFile* dex_file = &c1->GetDexFile();
+    ASSERT_EQ(dex_file, &c2->GetDexFile());
 
     ScopedDisableMovingGC no_gc(soa.Self());
 
-    RegTypeCache cache(
-        soa.Self(), Runtime::Current()->GetClassLinker(), /* can_load_classes= */ true, allocator);
-    const RegType& c1_reg_type = *cache.InsertClass(in1, c1.Get(), false);
-    const RegType& c2_reg_type = *cache.InsertClass(in2, c2.Get(), false);
+    RegTypeCache cache(soa.Self(), class_linker_, arena_pool, class_loader, dex_file);
+    const RegType& c1_reg_type = cache.FromClass(c1.Get());
+    if (!c1_reg_type.IsJavaLangObject()) {
+      ASSERT_TRUE(c1_reg_type.HasClass());
+      ASSERT_TRUE(c1_reg_type.GetClass() == c1.Get());
+    }
+    const RegType& c2_reg_type = cache.FromClass(c2.Get());
+    if (!c2_reg_type.IsJavaLangObject()) {
+      ASSERT_TRUE(c2_reg_type.HasClass());
+      ASSERT_TRUE(c2_reg_type.GetClass() == c2.Get());
+    }
 
     const RegType& join_type = c1_reg_type.Merge(c2_reg_type, &cache, nullptr);
-    EXPECT_TRUE(join_type.HasClass());
+    EXPECT_TRUE(join_type.IsJavaLangObject() || join_type.HasClass());
     EXPECT_EQ(join_type.GetDescriptor(), std::string_view(out));
   }
 };
@@ -1191,5 +1134,28 @@ TEST_F(RegTypeClassJoinTest, ClassJoinClassClass) {
   TestClassJoin("LInterfaces$A;", "LInterfaces$B;", "Ljava/lang/Object;");
 }
 
+TEST_F(RegTypeClassJoinTest, LookupByTypeIndex) {
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
+  ScopedObjectAccess soa(Thread::Current());
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache cache(soa.Self(), class_linker_, arena_pool, loader, dex_file_.get());
+
+  auto get_type_index = [&](std::string_view descriptor) {
+    const dex::TypeId* type_id = dex_file_->FindTypeId(descriptor);
+    CHECK(type_id != nullptr);
+    return dex_file_->GetIndexForTypeId(*type_id);
+  };
+
+  ASSERT_EQ(&cache.Boolean(), &cache.FromTypeIndex(get_type_index("Z")));
+  ASSERT_EQ(&cache.Byte(), &cache.FromTypeIndex(get_type_index("B")));
+  ASSERT_EQ(&cache.Char(), &cache.FromTypeIndex(get_type_index("C")));
+  ASSERT_EQ(&cache.Short(), &cache.FromTypeIndex(get_type_index("S")));
+  ASSERT_EQ(&cache.Integer(), &cache.FromTypeIndex(get_type_index("I")));
+  ASSERT_EQ(&cache.LongLo(), &cache.FromTypeIndex(get_type_index("J")));
+  ASSERT_EQ(&cache.Float(), &cache.FromTypeIndex(get_type_index("F")));
+  ASSERT_EQ(&cache.DoubleLo(), &cache.FromTypeIndex(get_type_index("D")));
+  ASSERT_EQ(&cache.Conflict(), &cache.FromTypeIndex(get_type_index("V")));
+}
+
 }  // namespace verifier
 }  // namespace art
diff --git a/runtime/verifier/reg_type_test_utils.h b/runtime/verifier/reg_type_test_utils.h
new file mode 100644
index 0000000000..b5370a1f47
--- /dev/null
+++ b/runtime/verifier/reg_type_test_utils.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ART_RUNTIME_VERIFIER_REG_TYPE_TEST_UTILS_H_
+#define ART_RUNTIME_VERIFIER_REG_TYPE_TEST_UTILS_H_
+
+#include "reg_type.h"
+
+namespace art HIDDEN {
+namespace verifier {
+
+// Helper class to avoid thread safety analysis errors from gtest's `operator<<`
+// instantiation for `RegType` not being marked as holding the mutator lock.
+class RegTypeWrapper {
+ public:
+  explicit RegTypeWrapper(const RegType& reg_type) : reg_type_(reg_type) {}
+ private:
+  const RegType& reg_type_;
+  friend std::ostream& operator<<(std::ostream& os, const RegTypeWrapper& rtw);
+};
+
+inline std::ostream& operator<<(std::ostream& os, const RegTypeWrapper& rtw)
+    NO_THREAD_SAFETY_ANALYSIS {
+  return os << rtw.reg_type_;
+}
+
+}  // namespace verifier
+}  // namespace art
+
+#endif  // ART_RUNTIME_VERIFIER_REG_TYPE_TEST_UTILS_H_
diff --git a/runtime/verifier/register_line-inl.h b/runtime/verifier/register_line-inl.h
index 3967aaa88e..a775ac5561 100644
--- a/runtime/verifier/register_line-inl.h
+++ b/runtime/verifier/register_line-inl.h
@@ -30,44 +30,73 @@ namespace verifier {
 // developers that their code will be slow.
 static constexpr bool kDumpLockFailures = true;
 
-inline const RegType& RegisterLine::GetRegisterType(MethodVerifier* verifier, uint32_t vsrc) const {
+inline uint16_t RegisterLine::GetRegisterTypeId(uint32_t vsrc) const {
   // The register index was validated during the static pass, so we don't need to check it here.
   DCHECK_LT(vsrc, num_regs_);
-  return verifier->GetRegTypeCache()->GetFromId(line_[vsrc]);
+  return line_[vsrc];
+}
+
+inline const RegType& RegisterLine::GetRegisterType(MethodVerifier* verifier, uint32_t vsrc) const {
+  return verifier->GetRegTypeCache()->GetFromId(GetRegisterTypeId(vsrc));
 }
 
 template <LockOp kLockOp>
-inline void RegisterLine::SetRegisterType(uint32_t vdst, const RegType& new_type) {
+inline void RegisterLine::SetRegisterTypeImpl(uint32_t vdst, uint16_t new_id) {
   DCHECK_LT(vdst, num_regs_);
-  DCHECK(!new_type.IsLowHalf());
-  DCHECK(!new_type.IsHighHalf());
   // Note: previously we failed when asked to set a conflict. However, conflicts are OK as long
   //       as they are not accessed, and our backends can handle this nowadays.
-  line_[vdst] = new_type.GetId();
+  line_[vdst] = new_id;
   switch (kLockOp) {
     case LockOp::kClear:
       // Clear the monitor entry bits for this register.
       ClearAllRegToLockDepths(vdst);
       break;
     case LockOp::kKeep:
-      // Should only be doing this with reference types.
-      DCHECK(new_type.IsReferenceTypes());
       break;
   }
 }
 
-inline void RegisterLine::SetRegisterTypeWide(uint32_t vdst,
-                                              const RegType& new_type1,
-                                              const RegType& new_type2) {
+inline void RegisterLine::SetRegisterType(uint32_t vdst, RegType::Kind new_kind) {
+  DCHECK(!RegType::IsLowHalf(new_kind));
+  DCHECK(!RegType::IsHighHalf(new_kind));
+  SetRegisterTypeImpl<LockOp::kClear>(vdst, RegTypeCache::IdForRegKind(new_kind));
+}
+
+template <LockOp kLockOp>
+inline void RegisterLine::SetRegisterType(uint32_t vdst, const RegType& new_type) {
+  DCHECK(!new_type.IsLowHalf());
+  DCHECK(!new_type.IsHighHalf());
+  // Should only keep locks for reference types.
+  DCHECK_IMPLIES(kLockOp == LockOp::kKeep, new_type.IsReferenceTypes());
+  SetRegisterTypeImpl<kLockOp>(vdst, new_type.GetId());
+}
+
+inline void RegisterLine::SetRegisterTypeWideImpl(uint32_t vdst,
+                                                  uint16_t new_id1,
+                                                  uint16_t new_id2) {
   DCHECK_LT(vdst + 1, num_regs_);
-  DCHECK(new_type1.CheckWidePair(new_type2));
-  line_[vdst] = new_type1.GetId();
-  line_[vdst + 1] = new_type2.GetId();
+  line_[vdst] = new_id1;
+  line_[vdst + 1] = new_id2;
   // Clear the monitor entry bits for this register.
   ClearAllRegToLockDepths(vdst);
   ClearAllRegToLockDepths(vdst + 1);
 }
 
+inline void RegisterLine::SetRegisterTypeWide(uint32_t vdst,
+                                              RegType::Kind new_kind1,
+                                              RegType::Kind new_kind2) {
+  DCHECK(RegType::CheckWidePair(new_kind1, new_kind2));
+  SetRegisterTypeWideImpl(
+      vdst, RegTypeCache::IdForRegKind(new_kind1), RegTypeCache::IdForRegKind(new_kind2));
+}
+
+inline void RegisterLine::SetRegisterTypeWide(uint32_t vdst,
+                                              const RegType& new_type1,
+                                              const RegType& new_type2) {
+  DCHECK(new_type1.CheckWidePair(new_type2));
+  SetRegisterTypeWideImpl(vdst, new_type1.GetId(), new_type2.GetId());
+}
+
 inline void RegisterLine::SetResultTypeToUnknown(RegTypeCache* reg_types) {
   result_[0] = reg_types->Undefined().GetId();
   result_[1] = result_[0];
@@ -87,6 +116,16 @@ inline void RegisterLine::SetResultRegisterTypeWide(const RegType& new_type1,
   result_[1] = new_type2.GetId();
 }
 
+inline void RegisterLine::SetRegisterTypeForNewInstance(uint32_t vdst,
+                                                        const RegType& uninit_type,
+                                                        uint32_t dex_pc) {
+  DCHECK_LT(vdst, num_regs_);
+  DCHECK(NeedsAllocationDexPc(uninit_type));
+  SetRegisterType<LockOp::kClear>(vdst, uninit_type);
+  EnsureAllocationDexPcsAvailable();
+  allocation_dex_pcs_[vdst] = dex_pc;
+}
+
 inline void RegisterLine::CopyRegister1(MethodVerifier* verifier, uint32_t vdst, uint32_t vsrc,
                                  TypeCategory cat) {
   DCHECK(cat == kTypeCategory1nr || cat == kTypeCategoryRef);
@@ -96,6 +135,8 @@ inline void RegisterLine::CopyRegister1(MethodVerifier* verifier, uint32_t vdst,
         << type << "'";
     return;
   }
+  // FIXME: If `vdst == vsrc`, we clear locking information before we try to copy it below. Adding
+  // `move-object v1, v1` to the middle of `OK.runStraightLine()` in run-test 088 makes it fail.
   SetRegisterType<LockOp::kClear>(vdst, type);
   if (!type.IsConflict() &&                                  // Allow conflicts to be copied around.
       ((cat == kTypeCategory1nr && !type.IsCategory1Types()) ||
@@ -104,6 +145,10 @@ inline void RegisterLine::CopyRegister1(MethodVerifier* verifier, uint32_t vdst,
                                                  << " cat=" << static_cast<int>(cat);
   } else if (cat == kTypeCategoryRef) {
     CopyRegToLockDepth(vdst, vsrc);
+    if (allocation_dex_pcs_ != nullptr) {
+      // Copy allocation dex pc for uninitialized types. (Copy unused value for other types.)
+      allocation_dex_pcs_[vdst] = allocation_dex_pcs_[vsrc];
+    }
   }
 }
 
@@ -119,40 +164,32 @@ inline void RegisterLine::CopyRegister2(MethodVerifier* verifier, uint32_t vdst,
   }
 }
 
-inline bool RegisterLine::VerifyRegisterType(MethodVerifier* verifier, uint32_t vsrc,
-                                             const RegType& check_type) {
-  // Verify the src register type against the check type refining the type of the register
-  const RegType& src_type = GetRegisterType(verifier, vsrc);
-  if (UNLIKELY(!check_type.IsAssignableFrom(src_type, verifier))) {
-    enum VerifyError fail_type;
-    if (!check_type.IsNonZeroReferenceTypes() || !src_type.IsNonZeroReferenceTypes()) {
-      // Hard fail if one of the types is primitive, since they are concretely known.
-      fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
-    } else if (check_type.IsUninitializedTypes() || src_type.IsUninitializedTypes()) {
-      // Hard fail for uninitialized types, which don't match anything but themselves.
-      fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
-    } else if (check_type.IsUnresolvedTypes() || src_type.IsUnresolvedTypes()) {
-      fail_type = VERIFY_ERROR_UNRESOLVED_TYPE_CHECK;
-    } else {
-      fail_type = VERIFY_ERROR_BAD_CLASS_HARD;
+inline bool RegisterLine::NeedsAllocationDexPc(const RegType& reg_type) {
+  return reg_type.IsUninitializedReference() || reg_type.IsUnresolvedUninitializedReference();
+}
+
+inline void RegisterLine::DCheckUniqueNewInstanceDexPc(MethodVerifier* verifier, uint32_t dex_pc) {
+  if (kIsDebugBuild && allocation_dex_pcs_ != nullptr) {
+    // Note: We do not clear the `allocation_dex_pcs_` entries when copying data from
+    // a register line without `allocation_dex_pcs_`, or when we merge types and find
+    // a conflict, so the same dex pc can remain in the `allocation_dex_pcs_` array
+    // but it cannot be recorded for a `new-instance` uninitialized type.
+    RegTypeCache* reg_types = verifier->GetRegTypeCache();
+    for (uint32_t i = 0; i != num_regs_; ++i) {
+      if (NeedsAllocationDexPc(reg_types->GetFromId(line_[i]))) {
+        CHECK_NE(allocation_dex_pcs_[i], dex_pc) << i << " " << reg_types->GetFromId(line_[i]);
+      }
     }
-    verifier->Fail(fail_type) << "register v" << vsrc << " has type "
-                               << src_type << " but expected " << check_type;
-    return false;
   }
-  if (check_type.IsLowHalf()) {
-    const RegType& src_type_h = GetRegisterType(verifier, vsrc + 1);
-    if (UNLIKELY(!src_type.CheckWidePair(src_type_h))) {
-      verifier->Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "wide register v" << vsrc << " has type "
-                                                   << src_type << "/" << src_type_h;
-      return false;
-    }
+}
+
+inline void RegisterLine::EnsureAllocationDexPcsAvailable() {
+  DCHECK_NE(num_regs_, 0u);
+  if (allocation_dex_pcs_ == nullptr) {
+    ArenaAllocatorAdapter<uint32_t> allocator(monitors_.get_allocator());
+    allocation_dex_pcs_ = allocator.allocate(num_regs_);
+    std::fill_n(allocation_dex_pcs_, num_regs_, kNoDexPc);
   }
-  // The register at vsrc has a defined type, we know the lower-upper-bound, but this is less
-  // precise than the subtype in vsrc so leave it for reference types. For primitive types
-  // if they are a defined type then they are as precise as we can get, however, for constant
-  // types we may wish to refine them. Unfortunately constant propagation has rendered this useless.
-  return true;
 }
 
 inline void RegisterLine::VerifyMonitorStackEmpty(MethodVerifier* verifier) const {
@@ -170,21 +207,26 @@ inline size_t RegisterLine::ComputeSize(size_t num_regs) {
 }
 
 inline RegisterLine* RegisterLine::Create(size_t num_regs,
-                                          ScopedArenaAllocator& allocator,
+                                          ArenaAllocator& allocator,
                                           RegTypeCache* reg_types) {
   void* memory = allocator.Alloc(ComputeSize(num_regs));
   return new (memory) RegisterLine(num_regs, allocator, reg_types);
 }
 
 inline RegisterLine::RegisterLine(size_t num_regs,
-                                  ScopedArenaAllocator& allocator,
+                                  ArenaAllocator& allocator,
                                   RegTypeCache* reg_types)
     : num_regs_(num_regs),
+      allocation_dex_pcs_(nullptr),
       monitors_(allocator.Adapter(kArenaAllocVerifier)),
       reg_to_lock_depths_(std::less<uint32_t>(),
                           allocator.Adapter(kArenaAllocVerifier)),
       this_initialized_(false) {
-  std::uninitialized_fill_n(line_, num_regs_, RegTypeCache::kUndefinedCacheId);
+  // `ArenaAllocator` guarantees zero-initialization.
+  static_assert(RegTypeCache::kUndefinedCacheId == 0u);
+  DCHECK(std::all_of(line_,
+                     line_ + num_regs_,
+                     [](auto id) { return id == RegTypeCache::kUndefinedCacheId;}));
   SetResultTypeToUnknown(reg_types);
 }
 
@@ -211,8 +253,18 @@ inline void RegisterLine::ClearRegToLockDepth(size_t reg, size_t depth) {
 
 inline void RegisterLineArenaDelete::operator()(RegisterLine* ptr) const {
   if (ptr != nullptr) {
+    uint32_t num_regs = ptr->NumRegs();
+    uint32_t* allocation_dex_pcs = ptr->allocation_dex_pcs_;
     ptr->~RegisterLine();
-    ProtectMemory(ptr, RegisterLine::ComputeSize(ptr->NumRegs()));
+    ProtectMemory(ptr, RegisterLine::ComputeSize(num_regs));
+    if (allocation_dex_pcs != nullptr) {
+      struct AllocationDexPcsDelete : ArenaDelete<uint32_t> {
+        void operator()(uint32_t* ptr, size_t size) {
+          ProtectMemory(ptr, size);
+        }
+      };
+      AllocationDexPcsDelete()(allocation_dex_pcs, num_regs * sizeof(*allocation_dex_pcs));
+    }
   }
 }
 
diff --git a/runtime/verifier/register_line.cc b/runtime/verifier/register_line.cc
index 62f2eb3ec0..6c4227cf8e 100644
--- a/runtime/verifier/register_line.cc
+++ b/runtime/verifier/register_line.cc
@@ -34,7 +34,7 @@ bool RegisterLine::CheckConstructorReturn(MethodVerifier* verifier) const {
     for (size_t i = 0; i < num_regs_; i++) {
       const RegType& type = GetRegisterType(verifier, i);
       CHECK(!type.IsUninitializedThisReference() &&
-            !type.IsUnresolvedAndUninitializedThisReference())
+            !type.IsUnresolvedUninitializedThisReference())
           << i << ": " << type.IsUninitializedThisReference() << " in "
           << verifier->GetMethodReference().PrettyMethod();
     }
@@ -46,68 +46,47 @@ bool RegisterLine::CheckConstructorReturn(MethodVerifier* verifier) const {
   return this_initialized_;
 }
 
-const RegType& RegisterLine::GetInvocationThis(MethodVerifier* verifier, const Instruction* inst,
-                                               bool allow_failure) {
-  DCHECK(inst->IsInvoke());
-  const size_t args_count = inst->VRegA();
-  if (args_count < 1) {
-    if (!allow_failure) {
-      verifier->Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "invoke lacks 'this'";
-    }
-    return verifier->GetRegTypeCache()->Conflict();
-  }
-  /* Get the element type of the array held in vsrc */
-  const uint32_t this_reg = inst->VRegC();
-  const RegType& this_type = GetRegisterType(verifier, this_reg);
-  if (!this_type.IsReferenceTypes()) {
-    if (!allow_failure) {
-      verifier->Fail(VERIFY_ERROR_BAD_CLASS_HARD)
-          << "tried to get class from non-reference register v" << this_reg
-          << " (type=" << this_type << ")";
-    }
-    return verifier->GetRegTypeCache()->Conflict();
-  }
-  return this_type;
-}
-
-bool RegisterLine::VerifyRegisterTypeWide(MethodVerifier* verifier, uint32_t vsrc,
-                                          const RegType& check_type1,
-                                          const RegType& check_type2) {
-  DCHECK(check_type1.CheckWidePair(check_type2));
-  // Verify the src register type against the check type refining the type of the register
-  const RegType& src_type = GetRegisterType(verifier, vsrc);
-  if (!check_type1.IsAssignableFrom(src_type, verifier)) {
-    verifier->Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "register v" << vsrc << " has type " << src_type
-                               << " but expected " << check_type1;
-    return false;
-  }
-  const RegType& src_type_h = GetRegisterType(verifier, vsrc + 1);
-  if (!src_type.CheckWidePair(src_type_h)) {
-    verifier->Fail(VERIFY_ERROR_BAD_CLASS_HARD) << "wide register v" << vsrc << " has type "
-        << src_type << "/" << src_type_h;
-    return false;
-  }
-  // The register at vsrc has a defined type, we know the lower-upper-bound, but this is less
-  // precise than the subtype in vsrc so leave it for reference types. For primitive types
-  // if they are a defined type then they are as precise as we can get, however, for constant
-  // types we may wish to refine them. Unfortunately constant propagation has rendered this useless.
-  return true;
+void RegisterLine::CopyFromLine(const RegisterLine* src) {
+  DCHECK_EQ(num_regs_, src->num_regs_);
+  memcpy(&line_, &src->line_, num_regs_ * sizeof(uint16_t));
+  // Copy `allocation_dex_pcs_`. Note that if the `src` does not have `allocation_dex_pcs_`
+  // allocated, we retain the array allocated for this register line to avoid wasting
+  // memory by allocating a new array later. This means that the `allocation_dex_pcs_` can
+  // be filled with bogus values not tied to a `new-instance` uninitialized type.
+  if (src->allocation_dex_pcs_ != nullptr) {
+    EnsureAllocationDexPcsAvailable();
+    memcpy(allocation_dex_pcs_, src->allocation_dex_pcs_, num_regs_ * sizeof(uint32_t));
+  }
+  monitors_ = src->monitors_;
+  reg_to_lock_depths_ = src->reg_to_lock_depths_;
+  this_initialized_ = src->this_initialized_;
 }
 
-void RegisterLine::MarkRefsAsInitialized(MethodVerifier* verifier, const RegType& uninit_type) {
+void RegisterLine::MarkRefsAsInitialized(MethodVerifier* verifier, uint32_t vsrc) {
+  const RegType& uninit_type = GetRegisterType(verifier, vsrc);
   DCHECK(uninit_type.IsUninitializedTypes());
   const RegType& init_type = verifier->GetRegTypeCache()->FromUninitialized(uninit_type);
   size_t changed = 0;
-  for (uint32_t i = 0; i < num_regs_; i++) {
-    if (GetRegisterType(verifier, i).Equals(uninit_type)) {
-      line_[i] = init_type.GetId();
-      changed++;
-    }
-  }
   // Is this initializing "this"?
   if (uninit_type.IsUninitializedThisReference() ||
-      uninit_type.IsUnresolvedAndUninitializedThisReference()) {
+      uninit_type.IsUnresolvedUninitializedThisReference()) {
     this_initialized_ = true;
+    for (uint32_t i = 0; i < num_regs_; i++) {
+      if (GetRegisterType(verifier, i).Equals(uninit_type)) {
+        line_[i] = init_type.GetId();
+        changed++;
+      }
+    }
+  } else {
+    DCHECK(NeedsAllocationDexPc(uninit_type));
+    DCHECK(allocation_dex_pcs_ != nullptr);
+    uint32_t dex_pc = allocation_dex_pcs_[vsrc];
+    for (uint32_t i = 0; i < num_regs_; i++) {
+      if (GetRegisterType(verifier, i).Equals(uninit_type) && allocation_dex_pcs_[i] == dex_pc) {
+        line_[i] = init_type.GetId();
+        changed++;
+      }
+    }
   }
   DCHECK_GT(changed, 0u);
 }
@@ -155,15 +134,6 @@ std::string RegisterLine::Dump(MethodVerifier* verifier) const {
   return result;
 }
 
-void RegisterLine::MarkUninitRefsAsInvalid(MethodVerifier* verifier, const RegType& uninit_type) {
-  for (size_t i = 0; i < num_regs_; i++) {
-    if (GetRegisterType(verifier, i).Equals(uninit_type)) {
-      line_[i] = verifier->GetRegTypeCache()->Conflict().GetId();
-      ClearAllRegToLockDepths(i);
-    }
-  }
-}
-
 void RegisterLine::CopyResultRegister1(MethodVerifier* verifier, uint32_t vdst, bool is_reference) {
   const RegType& type = verifier->GetRegTypeCache()->GetFromId(result_[0]);
   if ((!is_reference && !type.IsCategory1Types()) ||
@@ -195,137 +165,6 @@ void RegisterLine::CopyResultRegister2(MethodVerifier* verifier, uint32_t vdst)
   }
 }
 
-void RegisterLine::CheckUnaryOp(MethodVerifier* verifier, const Instruction* inst,
-                                const RegType& dst_type, const RegType& src_type) {
-  if (VerifyRegisterType(verifier, inst->VRegB_12x(), src_type)) {
-    SetRegisterType<LockOp::kClear>(inst->VRegA_12x(), dst_type);
-  }
-}
-
-void RegisterLine::CheckUnaryOpWide(MethodVerifier* verifier, const Instruction* inst,
-                                    const RegType& dst_type1, const RegType& dst_type2,
-                                    const RegType& src_type1, const RegType& src_type2) {
-  if (VerifyRegisterTypeWide(verifier, inst->VRegB_12x(), src_type1, src_type2)) {
-    SetRegisterTypeWide(inst->VRegA_12x(), dst_type1, dst_type2);
-  }
-}
-
-void RegisterLine::CheckUnaryOpToWide(MethodVerifier* verifier, const Instruction* inst,
-                                      const RegType& dst_type1, const RegType& dst_type2,
-                                      const RegType& src_type) {
-  if (VerifyRegisterType(verifier, inst->VRegB_12x(), src_type)) {
-    SetRegisterTypeWide(inst->VRegA_12x(), dst_type1, dst_type2);
-  }
-}
-
-void RegisterLine::CheckUnaryOpFromWide(MethodVerifier* verifier, const Instruction* inst,
-                                        const RegType& dst_type,
-                                        const RegType& src_type1, const RegType& src_type2) {
-  if (VerifyRegisterTypeWide(verifier, inst->VRegB_12x(), src_type1, src_type2)) {
-    SetRegisterType<LockOp::kClear>(inst->VRegA_12x(), dst_type);
-  }
-}
-
-void RegisterLine::CheckBinaryOp(MethodVerifier* verifier, const Instruction* inst,
-                                 const RegType& dst_type,
-                                 const RegType& src_type1, const RegType& src_type2,
-                                 bool check_boolean_op) {
-  const uint32_t vregB = inst->VRegB_23x();
-  const uint32_t vregC = inst->VRegC_23x();
-  if (VerifyRegisterType(verifier, vregB, src_type1) &&
-      VerifyRegisterType(verifier, vregC, src_type2)) {
-    if (check_boolean_op) {
-      DCHECK(dst_type.IsInteger());
-      if (GetRegisterType(verifier, vregB).IsBooleanTypes() &&
-          GetRegisterType(verifier, vregC).IsBooleanTypes()) {
-        SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), verifier->GetRegTypeCache()->Boolean());
-        return;
-      }
-    }
-    SetRegisterType<LockOp::kClear>(inst->VRegA_23x(), dst_type);
-  }
-}
-
-void RegisterLine::CheckBinaryOpWide(MethodVerifier* verifier, const Instruction* inst,
-                                     const RegType& dst_type1, const RegType& dst_type2,
-                                     const RegType& src_type1_1, const RegType& src_type1_2,
-                                     const RegType& src_type2_1, const RegType& src_type2_2) {
-  if (VerifyRegisterTypeWide(verifier, inst->VRegB_23x(), src_type1_1, src_type1_2) &&
-      VerifyRegisterTypeWide(verifier, inst->VRegC_23x(), src_type2_1, src_type2_2)) {
-    SetRegisterTypeWide(inst->VRegA_23x(), dst_type1, dst_type2);
-  }
-}
-
-void RegisterLine::CheckBinaryOpWideShift(MethodVerifier* verifier, const Instruction* inst,
-                                          const RegType& long_lo_type, const RegType& long_hi_type,
-                                          const RegType& int_type) {
-  if (VerifyRegisterTypeWide(verifier, inst->VRegB_23x(), long_lo_type, long_hi_type) &&
-      VerifyRegisterType(verifier, inst->VRegC_23x(), int_type)) {
-    SetRegisterTypeWide(inst->VRegA_23x(), long_lo_type, long_hi_type);
-  }
-}
-
-void RegisterLine::CheckBinaryOp2addr(MethodVerifier* verifier, const Instruction* inst,
-                                      const RegType& dst_type, const RegType& src_type1,
-                                      const RegType& src_type2, bool check_boolean_op) {
-  const uint32_t vregA = inst->VRegA_12x();
-  const uint32_t vregB = inst->VRegB_12x();
-  if (VerifyRegisterType(verifier, vregA, src_type1) &&
-      VerifyRegisterType(verifier, vregB, src_type2)) {
-    if (check_boolean_op) {
-      DCHECK(dst_type.IsInteger());
-      if (GetRegisterType(verifier, vregA).IsBooleanTypes() &&
-          GetRegisterType(verifier, vregB).IsBooleanTypes()) {
-        SetRegisterType<LockOp::kClear>(vregA, verifier->GetRegTypeCache()->Boolean());
-        return;
-      }
-    }
-    SetRegisterType<LockOp::kClear>(vregA, dst_type);
-  }
-}
-
-void RegisterLine::CheckBinaryOp2addrWide(MethodVerifier* verifier, const Instruction* inst,
-                                          const RegType& dst_type1, const RegType& dst_type2,
-                                          const RegType& src_type1_1, const RegType& src_type1_2,
-                                          const RegType& src_type2_1, const RegType& src_type2_2) {
-  const uint32_t vregA = inst->VRegA_12x();
-  const uint32_t vregB = inst->VRegB_12x();
-  if (VerifyRegisterTypeWide(verifier, vregA, src_type1_1, src_type1_2) &&
-      VerifyRegisterTypeWide(verifier, vregB, src_type2_1, src_type2_2)) {
-    SetRegisterTypeWide(vregA, dst_type1, dst_type2);
-  }
-}
-
-void RegisterLine::CheckBinaryOp2addrWideShift(MethodVerifier* verifier, const Instruction* inst,
-                                               const RegType& long_lo_type, const RegType& long_hi_type,
-                                               const RegType& int_type) {
-  const uint32_t vregA = inst->VRegA_12x();
-  const uint32_t vregB = inst->VRegB_12x();
-  if (VerifyRegisterTypeWide(verifier, vregA, long_lo_type, long_hi_type) &&
-      VerifyRegisterType(verifier, vregB, int_type)) {
-    SetRegisterTypeWide(vregA, long_lo_type, long_hi_type);
-  }
-}
-
-void RegisterLine::CheckLiteralOp(MethodVerifier* verifier, const Instruction* inst,
-                                  const RegType& dst_type, const RegType& src_type,
-                                  bool check_boolean_op, bool is_lit16) {
-  const uint32_t vregA = is_lit16 ? inst->VRegA_22s() : inst->VRegA_22b();
-  const uint32_t vregB = is_lit16 ? inst->VRegB_22s() : inst->VRegB_22b();
-  if (VerifyRegisterType(verifier, vregB, src_type)) {
-    if (check_boolean_op) {
-      DCHECK(dst_type.IsInteger());
-      /* check vB with the call, then check the constant manually */
-      const uint32_t val = is_lit16 ? inst->VRegC_22s() : inst->VRegC_22b();
-      if (GetRegisterType(verifier, vregB).IsBooleanTypes() && (val == 0 || val == 1)) {
-        SetRegisterType<LockOp::kClear>(vregA, verifier->GetRegTypeCache()->Boolean());
-        return;
-      }
-    }
-    SetRegisterType<LockOp::kClear>(vregA, dst_type);
-  }
-}
-
 static constexpr uint32_t kVirtualNullRegister = std::numeric_limits<uint32_t>::max();
 
 void RegisterLine::PushMonitor(MethodVerifier* verifier, uint32_t reg_idx, int32_t insn_idx) {
@@ -432,6 +271,20 @@ bool RegisterLine::MergeRegisters(MethodVerifier* verifier, const RegisterLine*
           incoming_reg_type, verifier->GetRegTypeCache(), verifier);
       changed = changed || !cur_type.Equals(new_type);
       line_[idx] = new_type.GetId();
+    } else {
+      auto needs_allocation_dex_pc = [&]() {
+        return NeedsAllocationDexPc(verifier->GetRegTypeCache()->GetFromId(line_[idx]));
+      };
+      DCHECK_IMPLIES(needs_allocation_dex_pc(), allocation_dex_pcs_ != nullptr);
+      DCHECK_IMPLIES(needs_allocation_dex_pc(), incoming_line->allocation_dex_pcs_ != nullptr);
+      // Check for allocation dex pc mismatch first to try and avoid costly virtual calls.
+      // For methods without any `new-instance` instructions, the `allocation_dex_pcs_` is null.
+      if (allocation_dex_pcs_ != nullptr &&
+          incoming_line->allocation_dex_pcs_ != nullptr &&
+          allocation_dex_pcs_[idx] != incoming_line->allocation_dex_pcs_[idx] &&
+          needs_allocation_dex_pc()) {
+        line_[idx] = verifier->GetRegTypeCache()->Conflict().GetId();
+      }
     }
   }
   if (monitors_.size() > 0 || incoming_line->monitors_.size() > 0) {
diff --git a/runtime/verifier/register_line.h b/runtime/verifier/register_line.h
index fc8c4cbc6c..19c2e2084f 100644
--- a/runtime/verifier/register_line.h
+++ b/runtime/verifier/register_line.h
@@ -23,10 +23,11 @@
 
 #include <android-base/logging.h>
 
+#include "base/arena_containers.h"
 #include "base/locks.h"
 #include "base/macros.h"
 #include "base/safe_map.h"
-#include "base/scoped_arena_containers.h"
+#include "reg_type.h"
 
 namespace art HIDDEN {
 
@@ -67,7 +68,7 @@ class RegisterLine {
  public:
   using RegisterStackMask = uint32_t;
   // A map from register to a bit vector of indices into the monitors_ stack.
-  using RegToLockDepthsMap = ScopedArenaSafeMap<uint32_t, RegisterStackMask>;
+  using RegToLockDepthsMap = ArenaSafeMap<uint32_t, RegisterStackMask>;
 
   // Maximum number of nested monitors to track before giving up and
   // taking the slow path.
@@ -75,9 +76,7 @@ class RegisterLine {
       std::numeric_limits<RegisterStackMask>::digits;
 
   // Create a register line of num_regs registers.
-  static RegisterLine* Create(size_t num_regs,
-                              ScopedArenaAllocator& allocator,
-                              RegTypeCache* reg_types);
+  static RegisterLine* Create(size_t num_regs, ArenaAllocator& allocator, RegTypeCache* reg_types);
 
   // Implement category-1 "move" instructions. Copy a 32-bit value from "vsrc" to "vdst".
   void CopyRegister1(MethodVerifier* verifier, uint32_t vdst, uint32_t vsrc, TypeCategory cat)
@@ -112,13 +111,15 @@ class RegisterLine {
   // is typical when the underlying value did not change, but we have "different" type information
   // available now. An example is sharpening types after a check-cast. Note that when given kKeep,
   // the new_type is dchecked to be a reference type.
+  ALWAYS_INLINE void SetRegisterType(uint32_t vdst, RegType::Kind new_kind)
+      REQUIRES_SHARED(Locks::mutator_lock_);
   template <LockOp kLockOp>
   ALWAYS_INLINE void SetRegisterType(uint32_t vdst, const RegType& new_type)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  void SetRegisterTypeWide(uint32_t vdst,
-                           const RegType& new_type1,
-                           const RegType& new_type2)
+  void SetRegisterTypeWide(uint32_t vdst, RegType::Kind new_kind1, RegType::Kind new_kind2)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+  void SetRegisterTypeWide(uint32_t vdst, const RegType& new_type1, const RegType& new_type2)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   /* Set the type of the "result" register. */
@@ -128,27 +129,22 @@ class RegisterLine {
   void SetResultRegisterTypeWide(const RegType& new_type1, const RegType& new_type2)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  // Get the type of register vsrc.
-  const RegType& GetRegisterType(MethodVerifier* verifier, uint32_t vsrc) const;
-
-  ALWAYS_INLINE bool VerifyRegisterType(MethodVerifier* verifier,
-                                        uint32_t vsrc,
-                                        const RegType& check_type)
+  /*
+   * Set register type for a `new-instance` instruction.
+   * For `new-instance`, we additionally record the allocation dex pc for vreg `vdst`.
+   * This is used to keep track of registers that hold the same uninitialized reference,
+   * so that we can update them all when a constructor is called on any of them.
+   */
+  void SetRegisterTypeForNewInstance(uint32_t vdst, const RegType& uninit_type, uint32_t dex_pc)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
-  bool VerifyRegisterTypeWide(MethodVerifier* verifier,
-                              uint32_t vsrc,
-                              const RegType& check_type1,
-                              const RegType& check_type2)
-      REQUIRES_SHARED(Locks::mutator_lock_);
+  // Get the id of the register tyoe of register vsrc.
+  uint16_t GetRegisterTypeId(uint32_t vsrc) const;
 
-  void CopyFromLine(const RegisterLine* src) {
-    DCHECK_EQ(num_regs_, src->num_regs_);
-    memcpy(&line_, &src->line_, num_regs_ * sizeof(uint16_t));
-    monitors_ = src->monitors_;
-    reg_to_lock_depths_ = src->reg_to_lock_depths_;
-    this_initialized_ = src->this_initialized_;
-  }
+  // Get the type of register vsrc.
+  const RegType& GetRegisterType(MethodVerifier* verifier, uint32_t vsrc) const;
+
+  void CopyFromLine(const RegisterLine* src);
 
   std::string Dump(MethodVerifier* verifier) const REQUIRES_SHARED(Locks::mutator_lock_);
 
@@ -159,20 +155,19 @@ class RegisterLine {
   }
 
   /*
-   * We're creating a new instance of class C at address A. Any registers holding instances
-   * previously created at address A must be initialized by now. If not, we mark them as "conflict"
-   * to prevent them from being used (otherwise, MarkRefsAsInitialized would mark the old ones and
-   * the new ones at the same time).
+   * In debug mode, assert that the register line does not contain an uninitialized register
+   * type for a `new-instance` allocation at a specific dex pc. We do this check before recording
+   * the uninitialized register type and dex pc for a `new-instance` instruction.
    */
-  void MarkUninitRefsAsInvalid(MethodVerifier* verifier, const RegType& uninit_type)
+  void DCheckUniqueNewInstanceDexPc(MethodVerifier* verifier, uint32_t dex_pc)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   /*
-   * Update all registers holding "uninit_type" to instead hold the corresponding initialized
-   * reference type. This is called when an appropriate constructor is invoked -- all copies of
-   * the reference must be marked as initialized.
+   * Update all registers holding the uninitialized type currently recorded for vreg `vsrc` to
+   * instead hold the corresponding initialized reference type. This is called when an appropriate
+   * constructor is invoked -- all copies of the reference must be marked as initialized.
    */
-  void MarkRefsAsInitialized(MethodVerifier* verifier, const RegType& uninit_type)
+  void MarkRefsAsInitialized(MethodVerifier* verifier, uint32_t vsrc)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   /*
@@ -216,126 +211,6 @@ class RegisterLine {
   // Return how many bytes of memory a register line uses.
   ALWAYS_INLINE static size_t ComputeSize(size_t num_regs);
 
-  /*
-   * Get the "this" pointer from a non-static method invocation. This returns the RegType so the
-   * caller can decide whether it needs the reference to be initialized or not. (Can also return
-   * kRegTypeZero if the reference can only be zero at this point.)
-   *
-   * The argument count is in vA, and the first argument is in vC, for both "simple" and "range"
-   * versions. We just need to make sure vA is >= 1 and then return vC.
-   * allow_failure will return Conflict() instead of causing a verification failure if there is an
-   * error.
-   */
-  const RegType& GetInvocationThis(MethodVerifier* verifier,
-                                   const Instruction* inst,
-                                   bool allow_failure = false)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  /*
-   * Verify types for a simple two-register instruction (e.g. "neg-int").
-   * "dst_type" is stored into vA, and "src_type" is verified against vB.
-   */
-  void CheckUnaryOp(MethodVerifier* verifier,
-                    const Instruction* inst,
-                    const RegType& dst_type,
-                    const RegType& src_type)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckUnaryOpWide(MethodVerifier* verifier,
-                        const Instruction* inst,
-                        const RegType& dst_type1,
-                        const RegType& dst_type2,
-                        const RegType& src_type1,
-                        const RegType& src_type2)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckUnaryOpToWide(MethodVerifier* verifier,
-                          const Instruction* inst,
-                          const RegType& dst_type1,
-                          const RegType& dst_type2,
-                          const RegType& src_type)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckUnaryOpFromWide(MethodVerifier* verifier,
-                            const Instruction* inst,
-                            const RegType& dst_type,
-                            const RegType& src_type1,
-                            const RegType& src_type2)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  /*
-   * Verify types for a simple three-register instruction (e.g. "add-int").
-   * "dst_type" is stored into vA, and "src_type1"/"src_type2" are verified
-   * against vB/vC.
-   */
-  void CheckBinaryOp(MethodVerifier* verifier,
-                     const Instruction* inst,
-                     const RegType& dst_type,
-                     const RegType& src_type1,
-                     const RegType& src_type2,
-                     bool check_boolean_op)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckBinaryOpWide(MethodVerifier* verifier,
-                         const Instruction* inst,
-                         const RegType& dst_type1,
-                         const RegType& dst_type2,
-                         const RegType& src_type1_1,
-                         const RegType& src_type1_2,
-                         const RegType& src_type2_1,
-                         const RegType& src_type2_2)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckBinaryOpWideShift(MethodVerifier* verifier,
-                              const Instruction* inst,
-                              const RegType& long_lo_type,
-                              const RegType& long_hi_type,
-                              const RegType& int_type)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  /*
-   * Verify types for a binary "2addr" operation. "src_type1"/"src_type2"
-   * are verified against vA/vB, then "dst_type" is stored into vA.
-   */
-  void CheckBinaryOp2addr(MethodVerifier* verifier,
-                          const Instruction* inst,
-                          const RegType& dst_type,
-                          const RegType& src_type1,
-                          const RegType& src_type2,
-                          bool check_boolean_op)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckBinaryOp2addrWide(MethodVerifier* verifier,
-                              const Instruction* inst,
-                              const RegType& dst_type1,
-                              const RegType& dst_type2,
-                              const RegType& src_type1_1,
-                              const RegType& src_type1_2,
-                              const RegType& src_type2_1,
-                              const RegType& src_type2_2)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  void CheckBinaryOp2addrWideShift(MethodVerifier* verifier,
-                                   const Instruction* inst,
-                                   const RegType& long_lo_type,
-                                   const RegType& long_hi_type,
-                                   const RegType& int_type)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
-  /*
-   * Verify types for A two-register instruction with a literal constant (e.g. "add-int/lit8").
-   * "dst_type" is stored into vA, and "src_type" is verified against vB.
-   *
-   * If "check_boolean_op" is set, we use the constant value in vC.
-   */
-  void CheckLiteralOp(MethodVerifier* verifier,
-                      const Instruction* inst,
-                      const RegType& dst_type,
-                      const RegType& src_type,
-                      bool check_boolean_op,
-                      bool is_lit16)
-      REQUIRES_SHARED(Locks::mutator_lock_);
-
   // Verify/push monitor onto the monitor stack, locking the value in reg_idx at location insn_idx.
   void PushMonitor(MethodVerifier* verifier, uint32_t reg_idx, int32_t insn_idx)
       REQUIRES_SHARED(Locks::mutator_lock_);
@@ -382,6 +257,18 @@ class RegisterLine {
   }
 
  private:
+  // For uninitialized types we need to check for allocation dex pc mismatch when merging.
+  // This does not apply to uninitialized "this" reference types.
+  static bool NeedsAllocationDexPc(const RegType& reg_type);
+
+  void EnsureAllocationDexPcsAvailable();
+
+  template <LockOp kLockOp>
+  ALWAYS_INLINE void SetRegisterTypeImpl(uint32_t vdst, uint16_t new_id)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+  void SetRegisterTypeWideImpl(uint32_t vdst, uint16_t new_id1, uint16_t new_id2)
+      REQUIRES_SHARED(Locks::mutator_lock_);
+
   void CopyRegToLockDepth(size_t dst, size_t src) {
     auto it = reg_to_lock_depths_.find(src);
     if (it != reg_to_lock_depths_.end()) {
@@ -418,16 +305,21 @@ class RegisterLine {
     reg_to_lock_depths_.erase(reg);
   }
 
-  RegisterLine(size_t num_regs, ScopedArenaAllocator& allocator, RegTypeCache* reg_types);
+  RegisterLine(size_t num_regs, ArenaAllocator& allocator, RegTypeCache* reg_types);
 
-  // Storage for the result register's type, valid after an invocation.
-  uint16_t result_[2];
+  static constexpr uint32_t kNoDexPc = static_cast<uint32_t>(-1);
 
   // Length of reg_types_
   const uint32_t num_regs_;
 
+  // Storage for the result register's type, valid after an invocation.
+  uint16_t result_[2];
+
+  // Track allocation dex pcs for `new-instance` results moved to other registers.
+  uint32_t* allocation_dex_pcs_;
+
   // A stack of monitor enter locations.
-  ScopedArenaVector<uint32_t> monitors_;
+  ArenaVector<uint32_t> monitors_;
 
   // A map from register to a bit vector of indices into the monitors_ stack. As we pop the monitor
   // stack we verify that monitor-enter/exit are correctly nested. That is, if there was a
@@ -440,6 +332,8 @@ class RegisterLine {
   // An array of RegType Ids associated with each dex register.
   uint16_t line_[1];
 
+  friend class RegisterLineArenaDelete;
+
   DISALLOW_COPY_AND_ASSIGN(RegisterLine);
 };
 
@@ -448,6 +342,8 @@ class RegisterLineArenaDelete : public ArenaDelete<RegisterLine> {
   void operator()(RegisterLine* ptr) const;
 };
 
+using RegisterLineArenaUniquePtr = std::unique_ptr<RegisterLine, RegisterLineArenaDelete>;
+
 }  // namespace verifier
 }  // namespace art
 
diff --git a/runtime/verifier/register_line_test.cc b/runtime/verifier/register_line_test.cc
new file mode 100644
index 0000000000..4d0f0c20cd
--- /dev/null
+++ b/runtime/verifier/register_line_test.cc
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "register_line-inl.h"
+
+#include "common_runtime_test.h"
+#include "method_verifier.h"
+#include "reg_type_cache-inl.h"
+#include "reg_type_test_utils.h"
+
+namespace art HIDDEN {
+namespace verifier {
+
+class RegisterLineTest : public CommonRuntimeTest {
+ protected:
+  RegisterLineTest() {
+    use_boot_image_ = true;  // Make the Runtime creation cheaper.
+  }
+
+  MethodVerifier* CreateVerifier(Thread* self,
+                                 RegTypeCache* reg_types,
+                                 Handle<mirror::DexCache> dex_cache,
+                                 ArtMethod* method) REQUIRES_SHARED(Locks::mutator_lock_) {
+    return MethodVerifier::CreateVerifier(
+        self,
+        reg_types,
+        /*verifier_deps=*/ nullptr,
+        dex_cache,
+        *method->GetDeclaringClass()->GetClassDef(),
+        method->GetCodeItem(),
+        method->GetDexMethodIndex(),
+        method->GetAccessFlags(),
+        /*verify_to_dump=*/ false,
+        /*api_level=*/ 0u);
+  }
+
+  ArenaAllocator& GetArenaAllocator(MethodVerifier* verifier) {
+    return verifier->allocator_;
+  }
+};
+
+TEST_F(RegisterLineTest, NewInstanceDexPcsMerging) {
+  ArenaPool* arena_pool = Runtime::Current()->GetArenaPool();
+  ScopedObjectAccess soa(Thread::Current());
+  StackHandleScope<2u> hs(soa.Self());
+  Handle<mirror::Class> object_class = hs.NewHandle(GetClassRoot<mirror::Object>());
+  Handle<mirror::DexCache> dex_cache = hs.NewHandle(object_class->GetDexCache());
+  const DexFile* dex_file = dex_cache->GetDexFile();
+  ScopedNullHandle<mirror::ClassLoader> loader;
+  RegTypeCache reg_types(soa.Self(), class_linker_, arena_pool, loader, dex_file);
+  ArtMethod* method = object_class->FindClassMethod("wait", "()V", kRuntimePointerSize);
+  ASSERT_TRUE(method != nullptr);
+  std::unique_ptr<MethodVerifier> verifier(
+      CreateVerifier(soa.Self(), &reg_types, dex_cache, method));
+  const RegType& resolved_type1 = reg_types.FromDescriptor("Ljava/lang/Object;");
+  const RegType& resolved_type2 = reg_types.FromDescriptor("Ljava/lang/String;");
+  const RegType& unresolved_type1 = reg_types.FromDescriptor("Ljava/lang/DoesNotExist;");
+  const RegType& unresolved_type2 = reg_types.FromDescriptor("Ljava/lang/DoesNotExistEither;");
+  const RegType& uninit_resolved_type1 = reg_types.Uninitialized(resolved_type1);
+  const RegType& uninit_resolved_type2 = reg_types.Uninitialized(resolved_type2);
+  const RegType& uninit_unresolved_type1 = reg_types.Uninitialized(unresolved_type1);
+  const RegType& uninit_unresolved_type2 = reg_types.Uninitialized(unresolved_type2);
+  const RegType& conflict = reg_types.Conflict();
+
+  struct TestCase {
+    const RegType& reg_type1;
+    uint32_t dex_pc1;
+    const RegType& reg_type2;
+    uint32_t dex_pc2;
+    const RegType& expected;
+  };
+  const TestCase test_cases[] = {
+    // Merge the same uninitialized type and allocation dex pc.
+    {uninit_resolved_type1, 1u, uninit_resolved_type1, 1u, uninit_resolved_type1},
+    {uninit_resolved_type2, 1u, uninit_resolved_type2, 1u, uninit_resolved_type2},
+    {uninit_unresolved_type1, 1u, uninit_unresolved_type1, 1u, uninit_unresolved_type1},
+    {uninit_unresolved_type2, 1u, uninit_unresolved_type2, 1u, uninit_unresolved_type2},
+    // Merge the same uninitialized type and different allocation dex pcs.
+    {uninit_resolved_type1, 1u, uninit_resolved_type1, 2u, conflict},
+    {uninit_resolved_type2, 1u, uninit_resolved_type2, 2u, conflict},
+    {uninit_unresolved_type1, 1u, uninit_unresolved_type1, 2u, conflict},
+    {uninit_unresolved_type2, 1u, uninit_unresolved_type2, 2u, conflict},
+    // Merge different uninitialized types and the same allocation dex pc.
+    {uninit_resolved_type1, 1u, uninit_resolved_type2, 1u, conflict},
+    {uninit_resolved_type1, 1u, uninit_unresolved_type1, 1u, conflict},
+    {uninit_resolved_type1, 1u, uninit_unresolved_type2, 1u, conflict},
+    {uninit_resolved_type2, 1u, uninit_resolved_type1, 1u, conflict},
+    {uninit_resolved_type2, 1u, uninit_unresolved_type1, 1u, conflict},
+    {uninit_resolved_type2, 1u, uninit_unresolved_type2, 1u, conflict},
+    {uninit_unresolved_type1, 1u, uninit_resolved_type1, 1u, conflict},
+    {uninit_unresolved_type1, 1u, uninit_resolved_type2, 1u, conflict},
+    {uninit_unresolved_type1, 1u, uninit_unresolved_type2, 1u, conflict},
+    {uninit_unresolved_type2, 1u, uninit_resolved_type1, 1u, conflict},
+    {uninit_unresolved_type2, 1u, uninit_resolved_type2, 1u, conflict},
+    {uninit_unresolved_type2, 1u, uninit_unresolved_type1, 1u, conflict},
+    // Merge uninitialized types with their initialized counterparts.
+    {uninit_resolved_type1, 1u, resolved_type1, 1u, conflict},
+    {uninit_resolved_type2, 1u, resolved_type2, 1u, conflict},
+    {uninit_unresolved_type1, 1u, unresolved_type1, 1u, conflict},
+    {uninit_unresolved_type2, 1u, unresolved_type2, 1u, conflict},
+    {resolved_type1, 1u, uninit_resolved_type1, 1u, conflict},
+    {resolved_type2, 1u, uninit_resolved_type2, 1u, conflict},
+    {unresolved_type1, 1u, uninit_unresolved_type1, 1u, conflict},
+    {unresolved_type2, 1u, uninit_unresolved_type2, 1u, conflict},
+  };
+
+  constexpr size_t kNumRegs = 1u;
+  constexpr uint32_t kVReg = 0u;
+  ArenaAllocator& allocator = GetArenaAllocator(verifier.get());
+  RegisterLineArenaUniquePtr line1(RegisterLine::Create(kNumRegs, allocator, &reg_types));
+  RegisterLineArenaUniquePtr line2(RegisterLine::Create(kNumRegs, allocator, &reg_types));
+  for (const TestCase& test_case : test_cases) {
+    ASSERT_TRUE(test_case.reg_type1.IsUninitializedTypes() ||
+                test_case.reg_type2.IsUninitializedTypes());
+    auto set_reg_type_and_dex_pc = [&](RegisterLine* line,
+                                       const RegType& reg_type,
+                                       uint32_t dex_pc,
+                                       const RegType& other_reg_type)
+        REQUIRES_SHARED(Locks::mutator_lock_) {
+      if (reg_type.IsUninitializedTypes()) {
+        line->SetRegisterTypeForNewInstance(kVReg, reg_type, dex_pc);
+      } else {
+        // Initialize the allocation dex pc using the `other_reg_type`, then set the `reg_type`.
+        line->SetRegisterTypeForNewInstance(kVReg, other_reg_type, dex_pc);
+        line->SetRegisterType<LockOp::kClear>(kVReg, reg_type);
+      }
+    };
+    set_reg_type_and_dex_pc(
+        line1.get(), test_case.reg_type1, test_case.dex_pc1, test_case.reg_type2);
+    set_reg_type_and_dex_pc(
+        line2.get(), test_case.reg_type2, test_case.dex_pc2, test_case.reg_type1);
+    line1->MergeRegisters(verifier.get(), line2.get());
+    const RegType& result = line1->GetRegisterType(verifier.get(), kVReg);
+    ASSERT_TRUE(result.Equals(test_case.expected))
+        << RegTypeWrapper(test_case.reg_type1) << " @" << test_case.dex_pc1 << " merge with "
+        << RegTypeWrapper(test_case.reg_type2) << " @" << test_case.dex_pc2 << " yielded "
+        << RegTypeWrapper(result) << " but we expected " << RegTypeWrapper(test_case.expected);
+  }
+}
+
+}  // namespace verifier
+}  // namespace art
diff --git a/runtime/verifier/verifier_compiler_binding.h b/runtime/verifier/verifier_compiler_binding.h
index f94ea02109..dd96a75975 100644
--- a/runtime/verifier/verifier_compiler_binding.h
+++ b/runtime/verifier/verifier_compiler_binding.h
@@ -27,14 +27,16 @@ namespace verifier {
 
 ALWAYS_INLINE
 static inline bool CanCompilerHandleVerificationFailure(uint32_t encountered_failure_types) {
-  constexpr uint32_t unresolved_mask = verifier::VerifyError::VERIFY_ERROR_NO_CLASS
-      | verifier::VerifyError::VERIFY_ERROR_UNRESOLVED_TYPE_CHECK
-      | verifier::VerifyError::VERIFY_ERROR_CLASS_CHANGE
-      | verifier::VerifyError::VERIFY_ERROR_NO_METHOD
-      | verifier::VerifyError::VERIFY_ERROR_INSTANTIATION
-      | verifier::VerifyError::VERIFY_ERROR_ACCESS_CLASS
-      | verifier::VerifyError::VERIFY_ERROR_ACCESS_FIELD
-      | verifier::VerifyError::VERIFY_ERROR_ACCESS_METHOD;
+  constexpr uint32_t unresolved_mask =
+      verifier::VerifyError::VERIFY_ERROR_NO_CLASS |
+      verifier::VerifyError::VERIFY_ERROR_UNRESOLVED_TYPE_CHECK |
+      verifier::VerifyError::VERIFY_ERROR_CLASS_CHANGE |
+      verifier::VerifyError::VERIFY_ERROR_NO_METHOD |
+      verifier::VerifyError::VERIFY_ERROR_NO_FIELD |
+      verifier::VerifyError::VERIFY_ERROR_INSTANTIATION |
+      verifier::VerifyError::VERIFY_ERROR_ACCESS_CLASS |
+      verifier::VerifyError::VERIFY_ERROR_ACCESS_FIELD |
+      verifier::VerifyError::VERIFY_ERROR_ACCESS_METHOD;
   return (encountered_failure_types & (~unresolved_mask)) == 0;
 }
 
diff --git a/runtime/verifier/verifier_deps.cc b/runtime/verifier/verifier_deps.cc
index f5df8ddf72..ed7629f805 100644
--- a/runtime/verifier/verifier_deps.cc
+++ b/runtime/verifier/verifier_deps.cc
@@ -167,22 +167,32 @@ dex::StringIndex VerifierDeps::GetIdFromString(const DexFile& dex_file, const st
     deps->strings_.push_back(str);
     dex::StringIndex new_id(num_ids_in_dex + deps->strings_.size() - 1);
     CHECK_GE(new_id.index_, num_ids_in_dex);  // check for overflows
-    DCHECK_EQ(str, singleton->GetStringFromId(dex_file, new_id));
+    DCHECK_EQ(str, singleton->GetStringFromIndex(dex_file, new_id));
     return new_id;
   }
 }
 
-std::string VerifierDeps::GetStringFromId(const DexFile& dex_file,
-                                          dex::StringIndex string_id) const {
+const char* VerifierDeps::GetStringFromIndex(const DexFile& dex_file,
+                                             dex::StringIndex string_idx,
+                                             /*out*/ size_t* utf8_length) const {
   uint32_t num_ids_in_dex = dex_file.NumStringIds();
-  if (string_id.index_ < num_ids_in_dex) {
-    return std::string(dex_file.GetStringView(string_id));
+  if (string_idx.index_ < num_ids_in_dex) {
+    uint32_t utf16_length;
+    const char* str = dex_file.GetStringDataAndUtf16Length(string_idx, &utf16_length);
+    if (utf8_length != nullptr) {
+      *utf8_length = DexFile::Utf8Length(str, utf16_length);
+    }
+    return str;
   } else {
     const DexFileDeps* deps = GetDexFileDeps(dex_file);
     DCHECK(deps != nullptr);
-    string_id.index_ -= num_ids_in_dex;
-    CHECK_LT(string_id.index_, deps->strings_.size());
-    return deps->strings_[string_id.index_];
+    size_t index = string_idx.index_ - num_ids_in_dex;
+    CHECK_LT(index, deps->strings_.size());
+    const std::string& str = deps->strings_[index];
+    if (utf8_length != nullptr) {
+      *utf8_length = str.length();
+    }
+    return str.c_str();
   }
 }
 
@@ -253,7 +263,8 @@ void VerifierDeps::AddAssignability(const DexFile& dex_file,
   CHECK(destination.IsUnresolvedReference() || destination.HasClass());
   CHECK(!destination.IsUnresolvedMergedReference());
 
-  if (source.IsUnresolvedReference() || source.HasClass()) {
+  if (source.IsUnresolvedReference() || source.IsJavaLangObject() || source.HasClass()) {
+    DCHECK_IMPLIES(source.IsJavaLangObject(), destination.IsUnresolvedReference());
     // Get string IDs for both descriptors and store in the appropriate set.
     dex::StringIndex destination_id =
         GetIdFromString(dex_file, std::string(destination.GetDescriptor()));
@@ -264,7 +275,8 @@ void VerifierDeps::AddAssignability(const DexFile& dex_file,
     // Nothing to record, null is always assignable.
   } else {
     CHECK(source.IsUnresolvedMergedReference()) << source.Dump();
-    const UnresolvedMergedType& merge = *down_cast<const UnresolvedMergedType*>(&source);
+    const UnresolvedMergedReferenceType& merge =
+        *down_cast<const UnresolvedMergedReferenceType*>(&source);
     AddAssignability(dex_file, class_def, destination, merge.GetResolvedPart());
     for (uint32_t idx : merge.GetUnresolvedTypes().Indexes()) {
       AddAssignability(dex_file, class_def, destination, merge.GetRegTypeCache()->GetFromId(idx));
@@ -659,8 +671,9 @@ void VerifierDeps::Dump(VariableIndentationOutputStream* vios) const {
       vios->Stream() << "Dependencies of " << dex_file.GetClassDescriptor(dex_file.GetClassDef(idx))
                      << ":\n";
       for (const TypeAssignability& entry : dep.second->assignable_types_[idx]) {
-        vios->Stream() << GetStringFromId(dex_file, entry.GetSource()) << " must be assignable to "
-                       << GetStringFromId(dex_file, entry.GetDestination()) << "\n";
+        vios->Stream() << GetStringFromIndex(dex_file, entry.GetSource())
+                       << " must be assignable to "
+                       << GetStringFromIndex(dex_file, entry.GetDestination()) << "\n";
       }
     }
 
@@ -691,10 +704,12 @@ bool VerifierDeps::ValidateDependenciesAndUpdateStatus(
 // the same lookup pattern.
 static ObjPtr<mirror::Class> FindClassAndClearException(ClassLinker* class_linker,
                                                         Thread* self,
-                                                        const std::string& name,
+                                                        const char* descriptor,
+                                                        size_t descriptor_length,
                                                         Handle<mirror::ClassLoader> class_loader)
     REQUIRES_SHARED(Locks::mutator_lock_) {
-  ObjPtr<mirror::Class> result = class_linker->FindClass(self, name.c_str(), class_loader);
+  ObjPtr<mirror::Class> result =
+      class_linker->FindClass(self, descriptor, descriptor_length, class_loader);
   if (result == nullptr) {
     DCHECK(self->IsExceptionPending());
     self->ClearException();
@@ -719,11 +734,16 @@ bool VerifierDeps::VerifyDexFileAndUpdateStatus(
   static constexpr uint32_t kMaxWarnings = 5;
   for (const auto& vec : assignables) {
     for (const auto& entry : vec) {
-      const std::string& destination_desc = GetStringFromId(dex_file, entry.GetDestination());
-      destination.Assign(
-          FindClassAndClearException(class_linker, self, destination_desc, class_loader));
-      const std::string& source_desc = GetStringFromId(dex_file, entry.GetSource());
-      source.Assign(FindClassAndClearException(class_linker, self, source_desc, class_loader));
+      size_t destination_desc_length;
+      const char* destination_desc =
+          GetStringFromIndex(dex_file, entry.GetDestination(), &destination_desc_length);
+      destination.Assign(FindClassAndClearException(
+          class_linker, self, destination_desc, destination_desc_length, class_loader));
+      size_t source_desc_length;
+      const char* source_desc =
+          GetStringFromIndex(dex_file, entry.GetSource(), &source_desc_length);
+      source.Assign(FindClassAndClearException(
+          class_linker, self, source_desc, source_desc_length, class_loader));
 
       if (destination == nullptr || source == nullptr) {
         // We currently don't use assignability information for unresolved
diff --git a/runtime/verifier/verifier_deps.h b/runtime/verifier/verifier_deps.h
index 5e3fb63c2d..293a6d99b3 100644
--- a/runtime/verifier/verifier_deps.h
+++ b/runtime/verifier/verifier_deps.h
@@ -207,8 +207,10 @@ class VerifierDeps {
   dex::StringIndex GetIdFromString(const DexFile& dex_file, const std::string& str)
       REQUIRES(!Locks::verifier_deps_lock_);
 
-  // Returns the string represented by `id`.
-  std::string GetStringFromId(const DexFile& dex_file, dex::StringIndex string_id) const;
+  // Returns the string represented by `string_idx`.
+  const char* GetStringFromIndex(const DexFile& dex_file,
+                                 dex::StringIndex string_idx,
+                                 /*out*/ size_t* utf8_length = nullptr) const;
 
   // Returns a string ID of the descriptor of the class.
   dex::StringIndex GetClassDescriptorStringId(const DexFile& dex_file, ObjPtr<mirror::Class> klass)
diff --git a/runtime/verifier/verifier_enums.h b/runtime/verifier/verifier_enums.h
index 57994581db..86775ff56d 100644
--- a/runtime/verifier/verifier_enums.h
+++ b/runtime/verifier/verifier_enums.h
@@ -75,14 +75,15 @@ enum VerifyError : uint32_t {
   VERIFY_ERROR_NO_CLASS =          1 << 1,   // NoClassDefFoundError.
   VERIFY_ERROR_UNRESOLVED_TYPE_CHECK = 1 << 2,   // Missing class for doing a type check
   VERIFY_ERROR_NO_METHOD =         1 << 3,   // NoSuchMethodError.
-  VERIFY_ERROR_ACCESS_CLASS =      1 << 4,   // IllegalAccessError.
-  VERIFY_ERROR_ACCESS_FIELD =      1 << 5,   // IllegalAccessError.
-  VERIFY_ERROR_ACCESS_METHOD =     1 << 6,   // IllegalAccessError.
-  VERIFY_ERROR_CLASS_CHANGE =      1 << 7,   // IncompatibleClassChangeError.
-  VERIFY_ERROR_INSTANTIATION =     1 << 8,   // InstantiationError.
-  VERIFY_ERROR_LOCKING =           1 << 9,  // Could not guarantee balanced locking. This should be
-                                             // punted to the interpreter with access checks.
-  VERIFY_ERROR_RUNTIME_THROW =     1 << 10,  // The interpreter found an instruction that will
+  VERIFY_ERROR_NO_FIELD =          1 << 4,   // NoSuchFieldError.
+  VERIFY_ERROR_ACCESS_CLASS =      1 << 5,   // IllegalAccessError.
+  VERIFY_ERROR_ACCESS_FIELD =      1 << 6,   // IllegalAccessError.
+  VERIFY_ERROR_ACCESS_METHOD =     1 << 7,   // IllegalAccessError.
+  VERIFY_ERROR_CLASS_CHANGE =      1 << 8,   // IncompatibleClassChangeError.
+  VERIFY_ERROR_INSTANTIATION =     1 << 9,   // InstantiationError.
+  VERIFY_ERROR_LOCKING =           1 << 10,  // Could not guarantee balanced locking. This should
+                                             // be punted to the interpreter with access checks.
+  VERIFY_ERROR_RUNTIME_THROW =     1 << 11,  // The interpreter found an instruction that will
                                              // throw. Used for app compatibility for apps < T.
 };
 std::ostream& operator<<(std::ostream& os, VerifyError rhs);
diff --git a/sigchainlib/sigchain.h b/sigchainlib/sigchain.h
index 13ec85de78..9c24a6fc02 100644
--- a/sigchainlib/sigchain.h
+++ b/sigchainlib/sigchain.h
@@ -17,10 +17,6 @@
 #ifndef ART_SIGCHAINLIB_SIGCHAIN_H_
 #define ART_SIGCHAINLIB_SIGCHAIN_H_
 
-// TODO(b/142944043): Symbol changes here currently need to be reflected in
-// version scripts in frameworks/base/cmds/app_process. The plan is to convert
-// libsigchain to a shared lib to get rid of them.
-
 #include <signal.h>
 #include <stdint.h>
 
diff --git a/simulator/code_simulator_arm64.cc b/simulator/code_simulator_arm64.cc
index 32ca005a76..08a5deae1f 100644
--- a/simulator/code_simulator_arm64.cc
+++ b/simulator/code_simulator_arm64.cc
@@ -47,6 +47,7 @@ CodeSimulatorArm64::CodeSimulatorArm64()
   SimStack::Allocated stack = stack_builder.Allocate();
 
   simulator_ = new Simulator(decoder_, stdout, std::move(stack));
+  simulator_->SetVectorLengthInBits(kArm64DefaultSVEVectorLength);
 }
 
 CodeSimulatorArm64::~CodeSimulatorArm64() {
diff --git a/test/001-HelloWorld/Android.bp b/test/001-HelloWorld/Android.bp
index 15f4f58ed7..2afb6a6c44 100644
--- a/test/001-HelloWorld/Android.bp
+++ b/test/001-HelloWorld/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-001-HelloWorld-expected-stdout",
         ":art-run-test-001-HelloWorld-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/001-Main/Android.bp b/test/001-Main/Android.bp
index 450e4af421..89f263f0f0 100644
--- a/test/001-Main/Android.bp
+++ b/test/001-Main/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-001-Main-expected-stdout",
         ":art-run-test-001-Main-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/002-sleep/Android.bp b/test/002-sleep/Android.bp
index ce16240ff5..7a0586087e 100644
--- a/test/002-sleep/Android.bp
+++ b/test/002-sleep/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-002-sleep-expected-stdout",
         ":art-run-test-002-sleep-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/004-InterfaceTest/Android.bp b/test/004-InterfaceTest/Android.bp
index 4ba1240517..5060dae4a5 100644
--- a/test/004-InterfaceTest/Android.bp
+++ b/test/004-InterfaceTest/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-004-InterfaceTest-expected-stdout",
         ":art-run-test-004-InterfaceTest-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/004-UnsafeTest/src/Main.java b/test/004-UnsafeTest/src/Main.java
index cfa36918b3..7031df027f 100644
--- a/test/004-UnsafeTest/src/Main.java
+++ b/test/004-UnsafeTest/src/Main.java
@@ -260,6 +260,26 @@ public class Main {
           "Unsafe.getObjectVolatile(Object, long)");
   }
 
+  private static void testGetAndPutAbsoluteAddress(Unsafe unsafe) throws NoSuchFieldException {
+    long address = 0;
+    try {
+        address = unsafe.allocateMemory(8);
+
+        unsafe.putByte(address, (byte) 17);
+        check(unsafe.getByte(address), (byte) 17, "Unsafe.getByte(long)");
+
+        unsafe.putInt(address, 0xDEADBEEF);
+        check(unsafe.getInt(address), 0xDEADBEEF, "Unsafe.getInt(long)");
+
+        unsafe.putLong(address, 0xFEEDFACEDECAFBADL);
+        check(unsafe.getInt(address), 0xFEEDFACEDECAFBADL, "Unsafe.getLong(long)");
+    } finally {
+        if (address != 0) {
+            unsafe.freeMemory(address);
+        }
+    }
+  }
+
   // Regression test for "copyMemory" operations hitting a DCHECK() for float/double arrays.
   private static void testCopyMemoryPrimitiveArrays(Unsafe unsafe) {
     int size = 4 * 1024;
diff --git a/test/004-checker-UnsafeTest18/Android.bp b/test/004-checker-UnsafeTest18/Android.bp
index 627084000e..b392bbefac 100644
--- a/test/004-checker-UnsafeTest18/Android.bp
+++ b/test/004-checker-UnsafeTest18/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-004-checker-UnsafeTest18-expected-stdout",
         ":art-run-test-004-checker-UnsafeTest18-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/006-args/Android.bp b/test/006-args/Android.bp
index dc56f814c5..2a369cb9cf 100644
--- a/test/006-args/Android.bp
+++ b/test/006-args/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-006-args-expected-stdout",
         ":art-run-test-006-args-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/007-count10/Android.bp b/test/007-count10/Android.bp
index 36e15df701..7bb855ecc6 100644
--- a/test/007-count10/Android.bp
+++ b/test/007-count10/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-007-count10-expected-stdout",
         ":art-run-test-007-count10-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/009-instanceof/Android.bp b/test/009-instanceof/Android.bp
index 5dcfc446ef..ab2799f731 100644
--- a/test/009-instanceof/Android.bp
+++ b/test/009-instanceof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-009-instanceof-expected-stdout",
         ":art-run-test-009-instanceof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/010-instance/Android.bp b/test/010-instance/Android.bp
index f7515f8b1a..a5cf1eb36d 100644
--- a/test/010-instance/Android.bp
+++ b/test/010-instance/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-010-instance-expected-stdout",
         ":art-run-test-010-instance-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/011-array-copy/Android.bp b/test/011-array-copy/Android.bp
index b0f0b904b9..6f19cb05e8 100644
--- a/test/011-array-copy/Android.bp
+++ b/test/011-array-copy/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-011-array-copy-expected-stdout",
         ":art-run-test-011-array-copy-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/011-array-copy2/Android.bp b/test/011-array-copy2/Android.bp
index d223d7ea61..e61bec8fb8 100644
--- a/test/011-array-copy2/Android.bp
+++ b/test/011-array-copy2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-011-array-copy2-expected-stdout",
         ":art-run-test-011-array-copy2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/012-math/Android.bp b/test/012-math/Android.bp
index 0e249b9584..235338f71e 100644
--- a/test/012-math/Android.bp
+++ b/test/012-math/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-012-math-expected-stdout",
         ":art-run-test-012-math-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/013-math2/Android.bp b/test/013-math2/Android.bp
index ea74045a7b..8a39ff0795 100644
--- a/test/013-math2/Android.bp
+++ b/test/013-math2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-013-math2-expected-stdout",
         ":art-run-test-013-math2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/014-math3/Android.bp b/test/014-math3/Android.bp
index 83624bd519..8a6f9a4db3 100644
--- a/test/014-math3/Android.bp
+++ b/test/014-math3/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-014-math3-expected-stdout",
         ":art-run-test-014-math3-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/015-checker-switch/Android.bp b/test/015-checker-switch/Android.bp
index 110dcac490..e498579008 100644
--- a/test/015-checker-switch/Android.bp
+++ b/test/015-checker-switch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-015-checker-switch-expected-stdout",
         ":art-run-test-015-checker-switch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/016-intern/Android.bp b/test/016-intern/Android.bp
index ca6e73f6b3..0a2ca6f146 100644
--- a/test/016-intern/Android.bp
+++ b/test/016-intern/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-016-intern-expected-stdout",
         ":art-run-test-016-intern-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/017-float/Android.bp b/test/017-float/Android.bp
index 87e4ba8e45..74f49ef961 100644
--- a/test/017-float/Android.bp
+++ b/test/017-float/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-017-float-expected-stdout",
         ":art-run-test-017-float-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/018-stack-overflow/Android.bp b/test/018-stack-overflow/Android.bp
index d5bb932c5d..b7b2445cc3 100644
--- a/test/018-stack-overflow/Android.bp
+++ b/test/018-stack-overflow/Android.bp
@@ -24,6 +24,7 @@ java_test {
     test_suites: [
         "cts",
         "mcts-art",
+        "mts-art",
     ],
     sdk_version: "test_current",
 }
diff --git a/test/019-wrong-array-type/Android.bp b/test/019-wrong-array-type/Android.bp
index 51db2d3d34..f63ec22e34 100644
--- a/test/019-wrong-array-type/Android.bp
+++ b/test/019-wrong-array-type/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-019-wrong-array-type-expected-stdout",
         ":art-run-test-019-wrong-array-type-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/020-string/Android.bp b/test/020-string/Android.bp
index e588f2f694..5addf57a7c 100644
--- a/test/020-string/Android.bp
+++ b/test/020-string/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-020-string-expected-stdout",
         ":art-run-test-020-string-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/021-string2/Android.bp b/test/021-string2/Android.bp
index 7a6183c0a2..c89ba17d47 100644
--- a/test/021-string2/Android.bp
+++ b/test/021-string2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-021-string2-expected-stdout",
         ":art-run-test-021-string2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/022-interface/Android.bp b/test/022-interface/Android.bp
index 765527965c..6ab1577ac2 100644
--- a/test/022-interface/Android.bp
+++ b/test/022-interface/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-022-interface-expected-stdout",
         ":art-run-test-022-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/024-illegal-access/Android.bp b/test/024-illegal-access/Android.bp
index 956f7992bf..d37b9ee25e 100644
--- a/test/024-illegal-access/Android.bp
+++ b/test/024-illegal-access/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-024-illegal-access-expected-stdout",
         ":art-run-test-024-illegal-access-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/025-access-controller/Android.bp b/test/025-access-controller/Android.bp
index b02cf03567..5bb297ff5b 100644
--- a/test/025-access-controller/Android.bp
+++ b/test/025-access-controller/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-025-access-controller-expected-stdout",
         ":art-run-test-025-access-controller-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/026-access/Android.bp b/test/026-access/Android.bp
index 74153c47f8..7abae5fe45 100644
--- a/test/026-access/Android.bp
+++ b/test/026-access/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-026-access-expected-stdout",
         ":art-run-test-026-access-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/027-arithmetic/Android.bp b/test/027-arithmetic/Android.bp
index bd16e9d7e1..21a5ee5a38 100644
--- a/test/027-arithmetic/Android.bp
+++ b/test/027-arithmetic/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-027-arithmetic-expected-stdout",
         ":art-run-test-027-arithmetic-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/028-array-write/Android.bp b/test/028-array-write/Android.bp
index 1375c6e587..db03096aa3 100644
--- a/test/028-array-write/Android.bp
+++ b/test/028-array-write/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-028-array-write-expected-stdout",
         ":art-run-test-028-array-write-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/029-assert/Android.bp b/test/029-assert/Android.bp
index 466f134e1c..094c7dab95 100644
--- a/test/029-assert/Android.bp
+++ b/test/029-assert/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-029-assert-expected-stdout",
         ":art-run-test-029-assert-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/032-concrete-sub/Android.bp b/test/032-concrete-sub/Android.bp
index 236137efa6..7164328260 100644
--- a/test/032-concrete-sub/Android.bp
+++ b/test/032-concrete-sub/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-032-concrete-sub-expected-stdout",
         ":art-run-test-032-concrete-sub-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/033-class-init-deadlock/Android.bp b/test/033-class-init-deadlock/Android.bp
index 5aae481ac7..1ac60db488 100644
--- a/test/033-class-init-deadlock/Android.bp
+++ b/test/033-class-init-deadlock/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-033-class-init-deadlock-expected-stdout",
         ":art-run-test-033-class-init-deadlock-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/035-enum/Android.bp b/test/035-enum/Android.bp
index 4041fea014..5d7ea94a56 100644
--- a/test/035-enum/Android.bp
+++ b/test/035-enum/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-035-enum-expected-stdout",
         ":art-run-test-035-enum-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/036-finalizer/Android.bp b/test/036-finalizer/Android.bp
index 6e2ca7a739..88bc0cf621 100644
--- a/test/036-finalizer/Android.bp
+++ b/test/036-finalizer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-036-finalizer-expected-stdout",
         ":art-run-test-036-finalizer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/037-inherit/Android.bp b/test/037-inherit/Android.bp
index fc11a8ebb1..c59bbb8308 100644
--- a/test/037-inherit/Android.bp
+++ b/test/037-inherit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-037-inherit-expected-stdout",
         ":art-run-test-037-inherit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/039-join-main/Android.bp b/test/039-join-main/Android.bp
index a6f9df4797..49a853956e 100644
--- a/test/039-join-main/Android.bp
+++ b/test/039-join-main/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-039-join-main-expected-stdout",
         ":art-run-test-039-join-main-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/040-miranda/Android.bp b/test/040-miranda/Android.bp
index ca965abc51..09be267b9f 100644
--- a/test/040-miranda/Android.bp
+++ b/test/040-miranda/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-040-miranda-expected-stdout",
         ":art-run-test-040-miranda-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/041-narrowing/Android.bp b/test/041-narrowing/Android.bp
index 4ad0b9c576..8df065bea7 100644
--- a/test/041-narrowing/Android.bp
+++ b/test/041-narrowing/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-041-narrowing-expected-stdout",
         ":art-run-test-041-narrowing-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/042-new-instance/Android.bp b/test/042-new-instance/Android.bp
index c2c40dd5c8..a345a8ef8c 100644
--- a/test/042-new-instance/Android.bp
+++ b/test/042-new-instance/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-042-new-instance-expected-stdout",
         ":art-run-test-042-new-instance-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/043-privates/Android.bp b/test/043-privates/Android.bp
index dd5b476a0d..2764f5f61c 100644
--- a/test/043-privates/Android.bp
+++ b/test/043-privates/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-043-privates-expected-stdout",
         ":art-run-test-043-privates-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/045-reflect-array/Android.bp b/test/045-reflect-array/Android.bp
index c10758c3a8..5c1ce62007 100644
--- a/test/045-reflect-array/Android.bp
+++ b/test/045-reflect-array/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-045-reflect-array-expected-stdout",
         ":art-run-test-045-reflect-array-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/046-reflect/Android.bp b/test/046-reflect/Android.bp
index 4dcf475af8..907f4fbaa8 100644
--- a/test/046-reflect/Android.bp
+++ b/test/046-reflect/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-046-reflect-expected-stdout",
         ":art-run-test-046-reflect-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/047-returns/Android.bp b/test/047-returns/Android.bp
index f6a3312841..e6142e39a3 100644
--- a/test/047-returns/Android.bp
+++ b/test/047-returns/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-047-returns-expected-stdout",
         ":art-run-test-047-returns-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/048-reflect-v8/Android.bp b/test/048-reflect-v8/Android.bp
index 778e3d6deb..008e613155 100644
--- a/test/048-reflect-v8/Android.bp
+++ b/test/048-reflect-v8/Android.bp
@@ -24,6 +24,7 @@ java_test {
     test_suites: [
         "cts",
         "mcts-art",
+        "mts-art",
     ],
     sdk_version: "test_current",
 }
diff --git a/test/049-show-object/Android.bp b/test/049-show-object/Android.bp
index 75bda84b2f..beeb29f67f 100644
--- a/test/049-show-object/Android.bp
+++ b/test/049-show-object/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-049-show-object-expected-stdout",
         ":art-run-test-049-show-object-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/050-sync-test/Android.bp b/test/050-sync-test/Android.bp
index 6959b05d76..c315837c74 100644
--- a/test/050-sync-test/Android.bp
+++ b/test/050-sync-test/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-050-sync-test-expected-stdout",
         ":art-run-test-050-sync-test-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/052-verifier-fun/Android.bp b/test/052-verifier-fun/Android.bp
index 8c3da44123..715fdf8e9a 100644
--- a/test/052-verifier-fun/Android.bp
+++ b/test/052-verifier-fun/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-052-verifier-fun-expected-stdout",
         ":art-run-test-052-verifier-fun-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/053-wait-some/Android.bp b/test/053-wait-some/Android.bp
index 210cecbf91..973b83e9c0 100644
--- a/test/053-wait-some/Android.bp
+++ b/test/053-wait-some/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-053-wait-some-expected-stdout",
         ":art-run-test-053-wait-some-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/055-enum-performance/Android.bp b/test/055-enum-performance/Android.bp
index 57f353429f..b56c8d7db7 100644
--- a/test/055-enum-performance/Android.bp
+++ b/test/055-enum-performance/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-055-enum-performance-expected-stdout",
         ":art-run-test-055-enum-performance-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/057-math-intrinsics/Android.bp b/test/057-math-intrinsics/Android.bp
index a48b868e95..77bbe2ee2c 100644
--- a/test/057-math-intrinsics/Android.bp
+++ b/test/057-math-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-057-math-intrinsics-expected-stdout",
         ":art-run-test-057-math-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/058-enum-order/Android.bp b/test/058-enum-order/Android.bp
index 7ee529e3b5..0392437e06 100644
--- a/test/058-enum-order/Android.bp
+++ b/test/058-enum-order/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-058-enum-order-expected-stdout",
         ":art-run-test-058-enum-order-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/059-finalizer-throw/Android.bp b/test/059-finalizer-throw/Android.bp
index 5bbac4b76d..4367eba156 100644
--- a/test/059-finalizer-throw/Android.bp
+++ b/test/059-finalizer-throw/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-059-finalizer-throw-expected-stdout",
         ":art-run-test-059-finalizer-throw-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/061-out-of-memory/Android.bp b/test/061-out-of-memory/Android.bp
index 9e2431432f..ed709e17aa 100644
--- a/test/061-out-of-memory/Android.bp
+++ b/test/061-out-of-memory/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-061-out-of-memory-expected-stdout",
         ":art-run-test-061-out-of-memory-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/062-character-encodings/Android.bp b/test/062-character-encodings/Android.bp
index 413313b026..c825f42380 100644
--- a/test/062-character-encodings/Android.bp
+++ b/test/062-character-encodings/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-062-character-encodings-expected-stdout",
         ":art-run-test-062-character-encodings-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/063-process-manager/Android.bp b/test/063-process-manager/Android.bp
index 5992a62ac2..18cddfa8de 100644
--- a/test/063-process-manager/Android.bp
+++ b/test/063-process-manager/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-063-process-manager-expected-stdout",
         ":art-run-test-063-process-manager-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/064-field-access/expected-stdout.txt b/test/064-field-access/expected-stdout.txt
index 59694a1972..3f62cafea4 100644
--- a/test/064-field-access/expected-stdout.txt
+++ b/test/064-field-access/expected-stdout.txt
@@ -2,3 +2,5 @@ JNI_OnLoad called
 good
 Got expected failure
 Got expected failure
+GetInstanceFieldOnUninitializedThis allowed for app compat
+Got expected failure
diff --git a/test/064-field-access/jasmin/GetInstanceFieldOnUninitializedThis.j b/test/064-field-access/jasmin/GetInstanceFieldOnUninitializedThis.j
new file mode 100644
index 0000000000..813a97b90f
--- /dev/null
+++ b/test/064-field-access/jasmin/GetInstanceFieldOnUninitializedThis.j
@@ -0,0 +1,33 @@
+; Copyright (C) 2024 The Android Open Source Project
+;
+; Licensed under the Apache License, Version 2.0 (the "License");
+; you may not use this file except in compliance with the License.
+; You may obtain a copy of the License at
+;
+;      http://www.apache.org/licenses/LICENSE-2.0
+;
+; Unless required by applicable law or agreed to in writing, software
+; distributed under the License is distributed on an "AS IS" BASIS,
+; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+; See the License for the specific language governing permissions and
+; limitations under the License.
+
+.class public GetInstanceFieldOnUninitializedThis
+.super java/lang/Object
+
+.field public intField I
+
+.method public <init>()V
+   .limit stack 2
+   .limit locals 1
+   aload_0
+   getfield GetInstanceFieldOnUninitializedThis/intField I
+   aload_0
+   invokespecial java/lang/Object.<init>()V
+   ; Avoid `getfield` elimination (DCE) by the dexer.
+   aload_0
+   swap
+   putfield GetInstanceFieldOnUninitializedThis/intField I
+   return
+.end method
+
diff --git a/test/064-field-access/jasmin/PutInstanceFieldOnUninitializedThisViaSubClass.j b/test/064-field-access/jasmin/PutInstanceFieldOnUninitializedThisViaSubClass.j
new file mode 100644
index 0000000000..2d3822d273
--- /dev/null
+++ b/test/064-field-access/jasmin/PutInstanceFieldOnUninitializedThisViaSubClass.j
@@ -0,0 +1,30 @@
+; Copyright (C) 2024 The Android Open Source Project
+;
+; Licensed under the Apache License, Version 2.0 (the "License");
+; you may not use this file except in compliance with the License.
+; You may obtain a copy of the License at
+;
+;      http://www.apache.org/licenses/LICENSE-2.0
+;
+; Unless required by applicable law or agreed to in writing, software
+; distributed under the License is distributed on an "AS IS" BASIS,
+; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+; See the License for the specific language governing permissions and
+; limitations under the License.
+
+.class public PutInstanceFieldOnUninitializedThisViaSubClass
+.super java/lang/Object
+
+.field public intField I
+
+.method public <init>()V
+   .limit stack 2
+   .limit locals 1
+   aload_0
+   iconst_1
+   putfield SubClassOfPutInstanceFieldOnUninitializedThisViaSubClass/intField I
+   aload_0
+   invokespecial java/lang/Object.<init>()V
+   return
+.end method
+
diff --git a/test/064-field-access/jasmin/SubClassOfPutInstanceFieldOnUninitializedThisViaSubClass.j b/test/064-field-access/jasmin/SubClassOfPutInstanceFieldOnUninitializedThisViaSubClass.j
new file mode 100644
index 0000000000..82cca75fe8
--- /dev/null
+++ b/test/064-field-access/jasmin/SubClassOfPutInstanceFieldOnUninitializedThisViaSubClass.j
@@ -0,0 +1,17 @@
+; Copyright (C) 2024 The Android Open Source Project
+;
+; Licensed under the Apache License, Version 2.0 (the "License");
+; you may not use this file except in compliance with the License.
+; You may obtain a copy of the License at
+;
+;      http://www.apache.org/licenses/LICENSE-2.0
+;
+; Unless required by applicable law or agreed to in writing, software
+; distributed under the License is distributed on an "AS IS" BASIS,
+; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+; See the License for the specific language governing permissions and
+; limitations under the License.
+
+.class public SubClassOfPutInstanceFieldOnUninitializedThisViaSubClass
+.super PutInstanceFieldOnUninitializedThisViaSubClass
+
diff --git a/test/064-field-access/src/Main.java b/test/064-field-access/src/Main.java
index 9f383caade..9f1bdfedfd 100644
--- a/test/064-field-access/src/Main.java
+++ b/test/064-field-access/src/Main.java
@@ -53,6 +53,26 @@ public class Main {
       System.out.println("Got unexpected failure " + e);
     }
 
+    try {
+      new GetInstanceFieldOnUninitializedThis();
+      // We actually allow this for app compat.
+      // System.out.println("Unexpectedly constructed GetInstanceFieldOnUninitializedThis");
+      System.out.println("GetInstanceFieldOnUninitializedThis allowed for app compat");
+    } catch (VerifyError expected) {
+      System.out.println("Got the correct but unexpected failure (should allow for app compat)");
+    } catch (Exception e) {
+      System.out.println("Got unexpected failure " + e);
+    }
+
+    try {
+      new PutInstanceFieldOnUninitializedThisViaSubClass();
+      System.out.println("Unexpectedly constructed PutInstanceFieldOnUninitializedThisViaSubClass");
+    } catch (VerifyError expected) {
+      System.out.println("Got expected failure");
+    } catch (Exception e) {
+      System.out.println("Got unexpected failure " + e);
+    }
+
     OOMEOnNullAccess.main(args);
   }
 
diff --git a/test/067-preemptive-unpark/Android.bp b/test/067-preemptive-unpark/Android.bp
index 26a62f8b48..b641360b1a 100644
--- a/test/067-preemptive-unpark/Android.bp
+++ b/test/067-preemptive-unpark/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-067-preemptive-unpark-expected-stdout",
         ":art-run-test-067-preemptive-unpark-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/069-field-type/Android.bp b/test/069-field-type/Android.bp
index 4f7acf7546..3240e98cad 100644
--- a/test/069-field-type/Android.bp
+++ b/test/069-field-type/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-069-field-type-expected-stdout",
         ":art-run-test-069-field-type-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/070-nio-buffer/Android.bp b/test/070-nio-buffer/Android.bp
index cc2b763378..b626ec9f76 100644
--- a/test/070-nio-buffer/Android.bp
+++ b/test/070-nio-buffer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-070-nio-buffer-expected-stdout",
         ":art-run-test-070-nio-buffer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/072-precise-gc/Android.bp b/test/072-precise-gc/Android.bp
index 4ea8c2b8af..0c3e7b32f2 100644
--- a/test/072-precise-gc/Android.bp
+++ b/test/072-precise-gc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-072-precise-gc-expected-stdout",
         ":art-run-test-072-precise-gc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/072-reachability-fence/Android.bp b/test/072-reachability-fence/Android.bp
index f079377a5f..4eef0c3416 100644
--- a/test/072-reachability-fence/Android.bp
+++ b/test/072-reachability-fence/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-072-reachability-fence-expected-stdout",
         ":art-run-test-072-reachability-fence-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/073-mismatched-field/Android.bp b/test/073-mismatched-field/Android.bp
index 83f9d6d376..68cdf9cdfd 100644
--- a/test/073-mismatched-field/Android.bp
+++ b/test/073-mismatched-field/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-073-mismatched-field-expected-stdout",
         ":art-run-test-073-mismatched-field-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/074-gc-thrash/Android.bp b/test/074-gc-thrash/Android.bp
index b6b99dbbdc..102ae0176e 100644
--- a/test/074-gc-thrash/Android.bp
+++ b/test/074-gc-thrash/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-074-gc-thrash-expected-stdout",
         ":art-run-test-074-gc-thrash-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/075-verification-error/Android.bp b/test/075-verification-error/Android.bp
index 6d024a9d40..2e43e013b5 100644
--- a/test/075-verification-error/Android.bp
+++ b/test/075-verification-error/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-075-verification-error-expected-stdout",
         ":art-run-test-075-verification-error-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/076-boolean-put/Android.bp b/test/076-boolean-put/Android.bp
index 5fa8baf044..c3f0f1a1fb 100644
--- a/test/076-boolean-put/Android.bp
+++ b/test/076-boolean-put/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-076-boolean-put-expected-stdout",
         ":art-run-test-076-boolean-put-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/077-method-override/Android.bp b/test/077-method-override/Android.bp
index 0bf8ecc7e0..267ca19a5f 100644
--- a/test/077-method-override/Android.bp
+++ b/test/077-method-override/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-077-method-override-expected-stdout",
         ":art-run-test-077-method-override-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/078-polymorphic-virtual/Android.bp b/test/078-polymorphic-virtual/Android.bp
index e71ab37543..6968bb626c 100644
--- a/test/078-polymorphic-virtual/Android.bp
+++ b/test/078-polymorphic-virtual/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-078-polymorphic-virtual-expected-stdout",
         ":art-run-test-078-polymorphic-virtual-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/079-phantom/Android.bp b/test/079-phantom/Android.bp
index 11c978bd9b..5d684be047 100644
--- a/test/079-phantom/Android.bp
+++ b/test/079-phantom/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-079-phantom-expected-stdout",
         ":art-run-test-079-phantom-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/080-oom-fragmentation/Android.bp b/test/080-oom-fragmentation/Android.bp
index c81f798e05..02868f87c9 100644
--- a/test/080-oom-fragmentation/Android.bp
+++ b/test/080-oom-fragmentation/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-080-oom-fragmentation-expected-stdout",
         ":art-run-test-080-oom-fragmentation-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/080-oom-throw-with-finalizer/Android.bp b/test/080-oom-throw-with-finalizer/Android.bp
index 7f7668e97f..53a9d581f2 100644
--- a/test/080-oom-throw-with-finalizer/Android.bp
+++ b/test/080-oom-throw-with-finalizer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-080-oom-throw-with-finalizer-expected-stdout",
         ":art-run-test-080-oom-throw-with-finalizer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/080-oom-throw/Android.bp b/test/080-oom-throw/Android.bp
index 6e07adcd9f..4281be8ff5 100644
--- a/test/080-oom-throw/Android.bp
+++ b/test/080-oom-throw/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-080-oom-throw-expected-stdout",
         ":art-run-test-080-oom-throw-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/081-hot-exceptions/Android.bp b/test/081-hot-exceptions/Android.bp
index 4d4bb04704..e82ed96890 100644
--- a/test/081-hot-exceptions/Android.bp
+++ b/test/081-hot-exceptions/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-081-hot-exceptions-expected-stdout",
         ":art-run-test-081-hot-exceptions-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/082-inline-execute/Android.bp b/test/082-inline-execute/Android.bp
index 492bbffac8..0b7a41a123 100644
--- a/test/082-inline-execute/Android.bp
+++ b/test/082-inline-execute/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-082-inline-execute-expected-stdout",
         ":art-run-test-082-inline-execute-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/083-compiler-regressions/Android.bp b/test/083-compiler-regressions/Android.bp
index cd985731ab..bb6676c950 100644
--- a/test/083-compiler-regressions/Android.bp
+++ b/test/083-compiler-regressions/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-083-compiler-regressions-expected-stdout",
         ":art-run-test-083-compiler-regressions-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/084-class-init/Android.bp b/test/084-class-init/Android.bp
index dd89fda639..95bbe91c33 100644
--- a/test/084-class-init/Android.bp
+++ b/test/084-class-init/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-084-class-init-expected-stdout",
         ":art-run-test-084-class-init-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/090-loop-formation/Android.bp b/test/090-loop-formation/Android.bp
index 7e908c7531..b1d5f4be93 100644
--- a/test/090-loop-formation/Android.bp
+++ b/test/090-loop-formation/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-090-loop-formation-expected-stdout",
         ":art-run-test-090-loop-formation-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/092-locale/Android.bp b/test/092-locale/Android.bp
index cc3f6f2b71..397f6db51d 100644
--- a/test/092-locale/Android.bp
+++ b/test/092-locale/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-092-locale-expected-stdout",
         ":art-run-test-092-locale-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/093-serialization/Android.bp b/test/093-serialization/Android.bp
index 83ae42a401..d58741dcf0 100644
--- a/test/093-serialization/Android.bp
+++ b/test/093-serialization/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-093-serialization-expected-stdout",
         ":art-run-test-093-serialization-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/094-pattern/Android.bp b/test/094-pattern/Android.bp
index 892154c5fb..06c9f0f4f2 100644
--- a/test/094-pattern/Android.bp
+++ b/test/094-pattern/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-094-pattern-expected-stdout",
         ":art-run-test-094-pattern-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/095-switch-MAX_INT/Android.bp b/test/095-switch-MAX_INT/Android.bp
index 0210d4f6e2..01739c2a97 100644
--- a/test/095-switch-MAX_INT/Android.bp
+++ b/test/095-switch-MAX_INT/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-095-switch-MAX_INT-expected-stdout",
         ":art-run-test-095-switch-MAX_INT-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/096-array-copy-concurrent-gc/Android.bp b/test/096-array-copy-concurrent-gc/Android.bp
index e65cdfbd8b..7036f71d4d 100644
--- a/test/096-array-copy-concurrent-gc/Android.bp
+++ b/test/096-array-copy-concurrent-gc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-096-array-copy-concurrent-gc-expected-stdout",
         ":art-run-test-096-array-copy-concurrent-gc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/099-vmdebug/Android.bp b/test/099-vmdebug/Android.bp
index a2ba9b40cc..e27ac5a5e4 100644
--- a/test/099-vmdebug/Android.bp
+++ b/test/099-vmdebug/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-099-vmdebug-expected-stdout",
         ":art-run-test-099-vmdebug-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/100-reflect2/Android.bp b/test/100-reflect2/Android.bp
index c2ed58f99c..facfb01bcd 100644
--- a/test/100-reflect2/Android.bp
+++ b/test/100-reflect2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-100-reflect2-expected-stdout",
         ":art-run-test-100-reflect2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/1000-non-moving-space-stress/Android.bp b/test/1000-non-moving-space-stress/Android.bp
index 976780a467..d80b3008bf 100644
--- a/test/1000-non-moving-space-stress/Android.bp
+++ b/test/1000-non-moving-space-stress/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-1000-non-moving-space-stress-expected-stdout",
         ":art-run-test-1000-non-moving-space-stress-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/1004-checker-volatile-ref-load/Android.bp b/test/1004-checker-volatile-ref-load/Android.bp
index 6c524d0926..42e5568232 100644
--- a/test/1004-checker-volatile-ref-load/Android.bp
+++ b/test/1004-checker-volatile-ref-load/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-1004-checker-volatile-ref-load-expected-stdout",
         ":art-run-test-1004-checker-volatile-ref-load-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/101-fibonacci/Android.bp b/test/101-fibonacci/Android.bp
index 3a37d1fc85..9cb2eabb66 100644
--- a/test/101-fibonacci/Android.bp
+++ b/test/101-fibonacci/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-101-fibonacci-expected-stdout",
         ":art-run-test-101-fibonacci-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/102-concurrent-gc/Android.bp b/test/102-concurrent-gc/Android.bp
index 2409aef091..fe1ff5615c 100644
--- a/test/102-concurrent-gc/Android.bp
+++ b/test/102-concurrent-gc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-102-concurrent-gc-expected-stdout",
         ":art-run-test-102-concurrent-gc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/103-string-append/Android.bp b/test/103-string-append/Android.bp
index ccef18ae3a..77b27a4639 100644
--- a/test/103-string-append/Android.bp
+++ b/test/103-string-append/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-103-string-append-expected-stdout",
         ":art-run-test-103-string-append-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/104-growth-limit/Android.bp b/test/104-growth-limit/Android.bp
index 88204726f8..f557a8b860 100644
--- a/test/104-growth-limit/Android.bp
+++ b/test/104-growth-limit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-104-growth-limit-expected-stdout",
         ":art-run-test-104-growth-limit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/105-invoke/Android.bp b/test/105-invoke/Android.bp
index 89c9bdf235..6d5d339b10 100644
--- a/test/105-invoke/Android.bp
+++ b/test/105-invoke/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-105-invoke-expected-stdout",
         ":art-run-test-105-invoke-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/106-exceptions2/Android.bp b/test/106-exceptions2/Android.bp
index e5c3427eef..ecdc165b47 100644
--- a/test/106-exceptions2/Android.bp
+++ b/test/106-exceptions2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-106-exceptions2-expected-stdout",
         ":art-run-test-106-exceptions2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/107-int-math2/Android.bp b/test/107-int-math2/Android.bp
index 930909f010..a63917e8a6 100644
--- a/test/107-int-math2/Android.bp
+++ b/test/107-int-math2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-107-int-math2-expected-stdout",
         ":art-run-test-107-int-math2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/108-check-cast/Android.bp b/test/108-check-cast/Android.bp
index fa5d730440..48926c4cb2 100644
--- a/test/108-check-cast/Android.bp
+++ b/test/108-check-cast/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-108-check-cast-expected-stdout",
         ":art-run-test-108-check-cast-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/109-suspend-check/Android.bp b/test/109-suspend-check/Android.bp
index 4312e151c9..ee5e3d40bd 100644
--- a/test/109-suspend-check/Android.bp
+++ b/test/109-suspend-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-109-suspend-check-expected-stdout",
         ":art-run-test-109-suspend-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/110-field-access/Android.bp b/test/110-field-access/Android.bp
index 3e67facc97..a5c1099ae8 100644
--- a/test/110-field-access/Android.bp
+++ b/test/110-field-access/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-110-field-access-expected-stdout",
         ":art-run-test-110-field-access-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/112-double-math/Android.bp b/test/112-double-math/Android.bp
index 2c16776006..6f8e666469 100644
--- a/test/112-double-math/Android.bp
+++ b/test/112-double-math/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-112-double-math-expected-stdout",
         ":art-run-test-112-double-math-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/114-ParallelGC/Android.bp b/test/114-ParallelGC/Android.bp
index bae03cc3a6..0d875b0d85 100644
--- a/test/114-ParallelGC/Android.bp
+++ b/test/114-ParallelGC/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-114-ParallelGC-expected-stdout",
         ":art-run-test-114-ParallelGC-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/120-hashcode/Android.bp b/test/120-hashcode/Android.bp
index 453893ab0d..df9f0c3f6c 100644
--- a/test/120-hashcode/Android.bp
+++ b/test/120-hashcode/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-120-hashcode-expected-stdout",
         ":art-run-test-120-hashcode-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/121-simple-suspend-check/Android.bp b/test/121-simple-suspend-check/Android.bp
index 22821fe0d5..2806d02421 100644
--- a/test/121-simple-suspend-check/Android.bp
+++ b/test/121-simple-suspend-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-121-simple-suspend-check-expected-stdout",
         ":art-run-test-121-simple-suspend-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/122-npe/Android.bp b/test/122-npe/Android.bp
index fba593ddc4..afa5a3bcfa 100644
--- a/test/122-npe/Android.bp
+++ b/test/122-npe/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-122-npe-expected-stdout",
         ":art-run-test-122-npe-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/123-compiler-regressions-mt/Android.bp b/test/123-compiler-regressions-mt/Android.bp
index 7c50958a69..b6e4e72de2 100644
--- a/test/123-compiler-regressions-mt/Android.bp
+++ b/test/123-compiler-regressions-mt/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-123-compiler-regressions-mt-expected-stdout",
         ":art-run-test-123-compiler-regressions-mt-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/123-inline-execute2/Android.bp b/test/123-inline-execute2/Android.bp
index 146d9c245c..56bcf03e51 100644
--- a/test/123-inline-execute2/Android.bp
+++ b/test/123-inline-execute2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-123-inline-execute2-expected-stdout",
         ":art-run-test-123-inline-execute2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/125-gc-and-classloading/Android.bp b/test/125-gc-and-classloading/Android.bp
index 64a7a55006..bdc3b45900 100644
--- a/test/125-gc-and-classloading/Android.bp
+++ b/test/125-gc-and-classloading/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-125-gc-and-classloading-expected-stdout",
         ":art-run-test-125-gc-and-classloading-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/128-reg-spill-on-implicit-nullcheck/Android.bp b/test/128-reg-spill-on-implicit-nullcheck/Android.bp
index 2dea4ad8fc..693b91d53f 100644
--- a/test/128-reg-spill-on-implicit-nullcheck/Android.bp
+++ b/test/128-reg-spill-on-implicit-nullcheck/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-128-reg-spill-on-implicit-nullcheck-expected-stdout",
         ":art-run-test-128-reg-spill-on-implicit-nullcheck-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/129-ThreadGetId/Android.bp b/test/129-ThreadGetId/Android.bp
index 85f64002e4..f64ef97288 100644
--- a/test/129-ThreadGetId/Android.bp
+++ b/test/129-ThreadGetId/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-129-ThreadGetId-expected-stdout",
         ":art-run-test-129-ThreadGetId-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/132-daemon-locks-shutdown/Android.bp b/test/132-daemon-locks-shutdown/Android.bp
index e4421818db..3884c3b4e2 100644
--- a/test/132-daemon-locks-shutdown/Android.bp
+++ b/test/132-daemon-locks-shutdown/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-132-daemon-locks-shutdown-expected-stdout",
         ":art-run-test-132-daemon-locks-shutdown-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/133-static-invoke-super/Android.bp b/test/133-static-invoke-super/Android.bp
index 5b24c4e135..7dc637b866 100644
--- a/test/133-static-invoke-super/Android.bp
+++ b/test/133-static-invoke-super/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-133-static-invoke-super-expected-stdout",
         ":art-run-test-133-static-invoke-super-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/1338-gc-no-los/Android.bp b/test/1338-gc-no-los/Android.bp
index f1f8344a9e..c8869f1320 100644
--- a/test/1338-gc-no-los/Android.bp
+++ b/test/1338-gc-no-los/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-1338-gc-no-los-expected-stdout",
         ":art-run-test-1338-gc-no-los-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/140-dce-regression/Android.bp b/test/140-dce-regression/Android.bp
index 796fe3c846..f597e7ff30 100644
--- a/test/140-dce-regression/Android.bp
+++ b/test/140-dce-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-140-dce-regression-expected-stdout",
         ":art-run-test-140-dce-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/140-field-packing/Android.bp b/test/140-field-packing/Android.bp
index 82ce2f97fa..611fa9408c 100644
--- a/test/140-field-packing/Android.bp
+++ b/test/140-field-packing/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-140-field-packing-expected-stdout",
         ":art-run-test-140-field-packing-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/143-string-value/Android.bp b/test/143-string-value/Android.bp
index 86d2877556..fa2d4c3ee4 100644
--- a/test/143-string-value/Android.bp
+++ b/test/143-string-value/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-143-string-value-expected-stdout",
         ":art-run-test-143-string-value-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/145-alloc-tracking-stress/Android.bp b/test/145-alloc-tracking-stress/Android.bp
index 5250e5037e..4296ecbfb7 100644
--- a/test/145-alloc-tracking-stress/Android.bp
+++ b/test/145-alloc-tracking-stress/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-145-alloc-tracking-stress-expected-stdout",
         ":art-run-test-145-alloc-tracking-stress-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/152-dead-large-object/Android.bp b/test/152-dead-large-object/Android.bp
index 010deb8304..e7f15bd27a 100644
--- a/test/152-dead-large-object/Android.bp
+++ b/test/152-dead-large-object/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-152-dead-large-object-expected-stdout",
         ":art-run-test-152-dead-large-object-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/153-reference-stress/Android.bp b/test/153-reference-stress/Android.bp
index ec9c6e9c43..3d8c037e7a 100644
--- a/test/153-reference-stress/Android.bp
+++ b/test/153-reference-stress/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-153-reference-stress-expected-stdout",
         ":art-run-test-153-reference-stress-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/156-register-dex-file-multi-loader/Android.bp b/test/156-register-dex-file-multi-loader/Android.bp
index 0f49bfebf2..56bd15eab4 100644
--- a/test/156-register-dex-file-multi-loader/Android.bp
+++ b/test/156-register-dex-file-multi-loader/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-156-register-dex-file-multi-loader-expected-stdout",
         ":art-run-test-156-register-dex-file-multi-loader-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/159-app-image-fields/Android.bp b/test/159-app-image-fields/Android.bp
index 89d35ef6f4..4f730d7d0f 100644
--- a/test/159-app-image-fields/Android.bp
+++ b/test/159-app-image-fields/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-159-app-image-fields-expected-stdout",
         ":art-run-test-159-app-image-fields-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/160-read-barrier-stress/Android.bp b/test/160-read-barrier-stress/Android.bp
index 64b87e6339..231420febd 100644
--- a/test/160-read-barrier-stress/Android.bp
+++ b/test/160-read-barrier-stress/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-160-read-barrier-stress-expected-stdout",
         ":art-run-test-160-read-barrier-stress-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/161-final-abstract-class/smali/TestClass.smali b/test/161-final-abstract-class/smali/TestClass.smali
index fa38f59854..df7fe5d5b3 100644
--- a/test/161-final-abstract-class/smali/TestClass.smali
+++ b/test/161-final-abstract-class/smali/TestClass.smali
@@ -20,3 +20,15 @@
     new-instance v0, LAbstractFinal;
     return-void
 .end method
+
+.method public static test2()V
+    .registers 1
+    const/4 v0, 0
+    invoke-static {v0}, LTestClass;->test2Target(LAbstractFinal;)V
+    return-void
+.end method
+
+.method public static test2Target(LAbstractFinal;)V
+    .registers 1
+    return-void
+.end method
diff --git a/test/162-method-resolution/src/Main.java b/test/162-method-resolution/src/Main.java
index 4b8ee920b7..08d11f5dd8 100644
--- a/test/162-method-resolution/src/Main.java
+++ b/test/162-method-resolution/src/Main.java
@@ -424,8 +424,13 @@ public class Main {
      *     invoke-direct Test11Derived.<init>(Ljava/lang/String;)V from Test11User in first dex
      *         TODO b/183485797 This should throw a NSME (constructors are never inherited, JLS 8.8)
      *                          but actually calls the superclass constructor.
-     *         expected: Throws NoSuchMethodError
-     *         actual: Successful construction of a Test11Derived instance.
+     *         expected: Successful construction of a Test11Derived instance.
+     * According to JLS, constructors are never inherited, so we should throw NoSuchMethodError and
+     * the RI does exactly that. However, ART has been permissive and allowed calling a superclass
+     * constructor directly for a long time and bytecode optimizers such as R8 are now using this
+     * to significantly reduce the dex file size. It is undesirable to implement strict checks now
+     * due to app compatibility issues and dex file size impact. Therefore ART deliberately
+     * diverges from the RI in this case and accepts the call to the superclass constructor.
      *
      * Files:
      *   src/Test11Base.java          - defines Test11Base with <init>(Ljava/lang/String;)V
@@ -434,7 +439,7 @@ public class Main {
      */
     private static void test11() throws Exception {
         if (usingRI) {
-            // For RI, just print the expected output to hide the divergence for now.
+            // For RI, just print the expected output to hide the deliberate divergence.
             System.out.println("Calling Test11User.test():\n" +
                                "Test11Base.<init>(\"Test\")");
         } else {
diff --git a/test/163-app-image-methods/Android.bp b/test/163-app-image-methods/Android.bp
index 57376629cd..a0a6f7f7bd 100644
--- a/test/163-app-image-methods/Android.bp
+++ b/test/163-app-image-methods/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-163-app-image-methods-expected-stdout",
         ":art-run-test-163-app-image-methods-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/165-lock-owner-proxy/Android.bp b/test/165-lock-owner-proxy/Android.bp
index dc30150fcc..a57d32815e 100644
--- a/test/165-lock-owner-proxy/Android.bp
+++ b/test/165-lock-owner-proxy/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-165-lock-owner-proxy-expected-stdout",
         ":art-run-test-165-lock-owner-proxy-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/168-vmstack-annotated/Android.bp b/test/168-vmstack-annotated/Android.bp
index 34f22d8dd2..441472be89 100644
--- a/test/168-vmstack-annotated/Android.bp
+++ b/test/168-vmstack-annotated/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-168-vmstack-annotated-expected-stdout",
         ":art-run-test-168-vmstack-annotated-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/170-interface-init/Android.bp b/test/170-interface-init/Android.bp
index 60d5e49f4d..d2aa5c8736 100644
--- a/test/170-interface-init/Android.bp
+++ b/test/170-interface-init/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-170-interface-init-expected-stdout",
         ":art-run-test-170-interface-init-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/174-escaping-instance-of-bad-class/Android.bp b/test/174-escaping-instance-of-bad-class/Android.bp
index f31993099c..ba22bbcb5d 100644
--- a/test/174-escaping-instance-of-bad-class/Android.bp
+++ b/test/174-escaping-instance-of-bad-class/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-174-escaping-instance-of-bad-class-expected-stdout",
         ":art-run-test-174-escaping-instance-of-bad-class-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/175-alloc-big-bignums/Android.bp b/test/175-alloc-big-bignums/Android.bp
index 77fdb12c4e..fde9021265 100644
--- a/test/175-alloc-big-bignums/Android.bp
+++ b/test/175-alloc-big-bignums/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-175-alloc-big-bignums-expected-stdout",
         ":art-run-test-175-alloc-big-bignums-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/176-app-image-string/Android.bp b/test/176-app-image-string/Android.bp
index 3dae355918..10464b7ae0 100644
--- a/test/176-app-image-string/Android.bp
+++ b/test/176-app-image-string/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-176-app-image-string-expected-stdout",
         ":art-run-test-176-app-image-string-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/182-method-linking/Android.bp b/test/182-method-linking/Android.bp
index 699b75b67d..66187ac571 100644
--- a/test/182-method-linking/Android.bp
+++ b/test/182-method-linking/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-182-method-linking-expected-stdout",
         ":art-run-test-182-method-linking-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/1960-checker-bounds-codegen/Android.bp b/test/1960-checker-bounds-codegen/Android.bp
index efb2b490ce..0ecdb0ddee 100644
--- a/test/1960-checker-bounds-codegen/Android.bp
+++ b/test/1960-checker-bounds-codegen/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-1960-checker-bounds-codegen-expected-stdout",
         ":art-run-test-1960-checker-bounds-codegen-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/1961-checker-loop-vectorizer/Android.bp b/test/1961-checker-loop-vectorizer/Android.bp
index 43bb4b9dca..7802a060de 100644
--- a/test/1961-checker-loop-vectorizer/Android.bp
+++ b/test/1961-checker-loop-vectorizer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-1961-checker-loop-vectorizer-expected-stdout",
         ":art-run-test-1961-checker-loop-vectorizer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2001-virtual-structural-multithread/src-art/art/Test2001.java b/test/2001-virtual-structural-multithread/src-art/art/Test2001.java
index 40972db643..87661d05c4 100644
--- a/test/2001-virtual-structural-multithread/src-art/art/Test2001.java
+++ b/test/2001-virtual-structural-multithread/src-art/art/Test2001.java
@@ -17,6 +17,7 @@
 package art;
 
 import dalvik.system.InMemoryDexClassLoader;
+import dalvik.system.VMRuntime;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Base64;
@@ -26,7 +27,7 @@ import java.util.function.Supplier;
 public class Test2001 {
   private static final int NUM_THREADS = 20;
   // Don't perform more than this many repeats per thread to prevent OOMEs
-  private static final int TASK_COUNT_LIMIT = 1000;
+  private static int TASK_COUNT_LIMIT = 1000;
 
   public static class Transform {
     public String greetingEnglish;
@@ -226,6 +227,13 @@ public class Test2001 {
   }
 
   public static void doTest() throws Exception {
+    if (!VMRuntime.getRuntime().is64Bit()) {
+      // Reduce the task count limit on 32-bit VMs. Since we create a class loader for each task,
+      // we create too many linear alloc spaces. On 32-bit systems this might cause an OOM because
+      // we run out of virtual address space.
+      TASK_COUNT_LIMIT = 100;
+    }
+
     MyThread[] threads = startThreads(NUM_THREADS);
     Redefinition.doCommonStructuralClassRedefinition(Transform.class, DEX_BYTES);
     finishThreads(threads);
diff --git a/test/201-built-in-except-detail-messages/Android.bp b/test/201-built-in-except-detail-messages/Android.bp
index 894dfb05db..73f8e55f0b 100644
--- a/test/201-built-in-except-detail-messages/Android.bp
+++ b/test/201-built-in-except-detail-messages/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-201-built-in-except-detail-messages-expected-stdout",
         ":art-run-test-201-built-in-except-detail-messages-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2019-constantcalculationsinking/Android.bp b/test/2019-constantcalculationsinking/Android.bp
index d9b323b5b0..f0fda417c4 100644
--- a/test/2019-constantcalculationsinking/Android.bp
+++ b/test/2019-constantcalculationsinking/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2019-constantcalculationsinking-expected-stdout",
         ":art-run-test-2019-constantcalculationsinking-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/202-thread-oome/Android.bp b/test/202-thread-oome/Android.bp
index d54443223f..f250b8f005 100644
--- a/test/202-thread-oome/Android.bp
+++ b/test/202-thread-oome/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-202-thread-oome-expected-stdout",
         ":art-run-test-202-thread-oome-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2020-InvokeVirtual-Inlining/Android.bp b/test/2020-InvokeVirtual-Inlining/Android.bp
index 2e62ccbe77..04996e0b74 100644
--- a/test/2020-InvokeVirtual-Inlining/Android.bp
+++ b/test/2020-InvokeVirtual-Inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2020-InvokeVirtual-Inlining-expected-stdout",
         ":art-run-test-2020-InvokeVirtual-Inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2021-InvokeStatic-Inlining/Android.bp b/test/2021-InvokeStatic-Inlining/Android.bp
index f9e265fe68..61924ca24c 100644
--- a/test/2021-InvokeStatic-Inlining/Android.bp
+++ b/test/2021-InvokeStatic-Inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2021-InvokeStatic-Inlining-expected-stdout",
         ":art-run-test-2021-InvokeStatic-Inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2022-Invariantloops/Android.bp b/test/2022-Invariantloops/Android.bp
index e477d903aa..14b480ac73 100644
--- a/test/2022-Invariantloops/Android.bp
+++ b/test/2022-Invariantloops/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2022-Invariantloops-expected-stdout",
         ":art-run-test-2022-Invariantloops-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2023-InvariantLoops_typecast/Android.bp b/test/2023-InvariantLoops_typecast/Android.bp
index 27aa9bfa9c..9b09b4399c 100644
--- a/test/2023-InvariantLoops_typecast/Android.bp
+++ b/test/2023-InvariantLoops_typecast/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2023-InvariantLoops_typecast-expected-stdout",
         ":art-run-test-2023-InvariantLoops_typecast-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2024-InvariantNegativeLoop/Android.bp b/test/2024-InvariantNegativeLoop/Android.bp
index 707aab6349..b688502316 100644
--- a/test/2024-InvariantNegativeLoop/Android.bp
+++ b/test/2024-InvariantNegativeLoop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2024-InvariantNegativeLoop-expected-stdout",
         ":art-run-test-2024-InvariantNegativeLoop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2025-ChangedArrayValue/Android.bp b/test/2025-ChangedArrayValue/Android.bp
index 451b86215d..bf3b826dad 100644
--- a/test/2025-ChangedArrayValue/Android.bp
+++ b/test/2025-ChangedArrayValue/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2025-ChangedArrayValue-expected-stdout",
         ":art-run-test-2025-ChangedArrayValue-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2026-DifferentMemoryLSCouples/Android.bp b/test/2026-DifferentMemoryLSCouples/Android.bp
index 1bdad83fb0..1994cbb393 100644
--- a/test/2026-DifferentMemoryLSCouples/Android.bp
+++ b/test/2026-DifferentMemoryLSCouples/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2026-DifferentMemoryLSCouples-expected-stdout",
         ":art-run-test-2026-DifferentMemoryLSCouples-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2027-TwiceTheSameMemoryCouple/Android.bp b/test/2027-TwiceTheSameMemoryCouple/Android.bp
index 1c66124f9f..45a0ac6b0b 100644
--- a/test/2027-TwiceTheSameMemoryCouple/Android.bp
+++ b/test/2027-TwiceTheSameMemoryCouple/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2027-TwiceTheSameMemoryCouple-expected-stdout",
         ":art-run-test-2027-TwiceTheSameMemoryCouple-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2028-MultiBackward/Android.bp b/test/2028-MultiBackward/Android.bp
index 4e031e5c2f..f179060adc 100644
--- a/test/2028-MultiBackward/Android.bp
+++ b/test/2028-MultiBackward/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2028-MultiBackward-expected-stdout",
         ":art-run-test-2028-MultiBackward-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2029-contended-monitors/Android.bp b/test/2029-contended-monitors/Android.bp
index fd27d42af9..3fbf04ae30 100644
--- a/test/2029-contended-monitors/Android.bp
+++ b/test/2029-contended-monitors/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2029-contended-monitors-expected-stdout",
         ":art-run-test-2029-contended-monitors-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2030-long-running-child/Android.bp b/test/2030-long-running-child/Android.bp
index aeba519395..74c11bb3c5 100644
--- a/test/2030-long-running-child/Android.bp
+++ b/test/2030-long-running-child/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2030-long-running-child-expected-stdout",
         ":art-run-test-2030-long-running-child-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2042-checker-dce-always-throw/Android.bp b/test/2042-checker-dce-always-throw/Android.bp
index f991939b27..9475c08de7 100644
--- a/test/2042-checker-dce-always-throw/Android.bp
+++ b/test/2042-checker-dce-always-throw/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2042-checker-dce-always-throw-expected-stdout",
         ":art-run-test-2042-checker-dce-always-throw-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2042-reference-processing/Android.bp b/test/2042-reference-processing/Android.bp
index a73b8d0bd0..0e73d8a87d 100644
--- a/test/2042-reference-processing/Android.bp
+++ b/test/2042-reference-processing/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2042-reference-processing-expected-stdout",
         ":art-run-test-2042-reference-processing-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2043-reference-pauses/Android.bp b/test/2043-reference-pauses/Android.bp
index a84aea25e8..3ae9d8838e 100644
--- a/test/2043-reference-pauses/Android.bp
+++ b/test/2043-reference-pauses/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2043-reference-pauses-expected-stdout",
         ":art-run-test-2043-reference-pauses-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2044-get-stack-traces/Android.bp b/test/2044-get-stack-traces/Android.bp
index 79aea7c7ff..7f216b45fc 100644
--- a/test/2044-get-stack-traces/Android.bp
+++ b/test/2044-get-stack-traces/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2044-get-stack-traces-expected-stdout",
         ":art-run-test-2044-get-stack-traces-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2046-checker-comparison/Android.bp b/test/2046-checker-comparison/Android.bp
index edd776184d..ac5849a8a4 100644
--- a/test/2046-checker-comparison/Android.bp
+++ b/test/2046-checker-comparison/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2046-checker-comparison-expected-stdout",
         ":art-run-test-2046-checker-comparison-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2047-checker-const-string-length/Android.bp b/test/2047-checker-const-string-length/Android.bp
index 41cbfd3b8a..b3df9ee4d7 100644
--- a/test/2047-checker-const-string-length/Android.bp
+++ b/test/2047-checker-const-string-length/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2047-checker-const-string-length-expected-stdout",
         ":art-run-test-2047-checker-const-string-length-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2231-checker-heap-poisoning/Android.bp b/test/2231-checker-heap-poisoning/Android.bp
index b2623e3238..3f8761dc19 100644
--- a/test/2231-checker-heap-poisoning/Android.bp
+++ b/test/2231-checker-heap-poisoning/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2231-checker-heap-poisoning-expected-stdout",
         ":art-run-test-2231-checker-heap-poisoning-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2233-checker-remove-loop-suspend-check/Android.bp b/test/2233-checker-remove-loop-suspend-check/Android.bp
index f581ee34c0..7f59665959 100644
--- a/test/2233-checker-remove-loop-suspend-check/Android.bp
+++ b/test/2233-checker-remove-loop-suspend-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2233-checker-remove-loop-suspend-check-expected-stdout",
         ":art-run-test-2233-checker-remove-loop-suspend-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2234-checker-remove-entry-suspendcheck/Android.bp b/test/2234-checker-remove-entry-suspendcheck/Android.bp
index 31dc1dec3e..5c28b72ffd 100644
--- a/test/2234-checker-remove-entry-suspendcheck/Android.bp
+++ b/test/2234-checker-remove-entry-suspendcheck/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2234-checker-remove-entry-suspendcheck-expected-stdout",
         ":art-run-test-2234-checker-remove-entry-suspendcheck-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2235-JdkUnsafeTest/src/Main.java b/test/2235-JdkUnsafeTest/src/Main.java
index 7cb88b1d76..86ca7af6f4 100644
--- a/test/2235-JdkUnsafeTest/src/Main.java
+++ b/test/2235-JdkUnsafeTest/src/Main.java
@@ -18,6 +18,34 @@ import java.lang.reflect.Field;
 import jdk.internal.misc.Unsafe;
 
 public class Main {
+  private static void check(boolean actual, boolean expected, String msg) {
+    if (actual != expected) {
+      System.out.println(msg + " : " + actual + " != " + expected);
+      System.exit(1);
+    }
+  }
+
+  private static void check(byte actual, byte expected, String msg) {
+    if (actual != expected) {
+      System.out.println(msg + " : " + actual + " != " + expected);
+      System.exit(1);
+    }
+  }
+
+  private static void check(char actual, char expected, String msg) {
+    if (actual != expected) {
+      System.out.println(msg + " : " + actual + " != " + expected);
+      System.exit(1);
+    }
+  }
+
+  private static void check(short actual, short expected, String msg) {
+    if (actual != expected) {
+      System.out.println(msg + " : " + actual + " != " + expected);
+      System.exit(1);
+    }
+  }
+
   private static void check(int actual, int expected, String msg) {
     if (actual != expected) {
       System.out.println(msg + " : " + actual + " != " + expected);
@@ -345,6 +373,54 @@ public class Main {
           intValue,
           "Unsafe.getIntVolatile(Object, long)");
 
+    boolean booleanValue = true;
+    Field volatileBooleanField = TestVolatileClass.class.getDeclaredField("volatileBooleanVar");
+    long volatileBooleanOffset = unsafe.objectFieldOffset(volatileBooleanField);
+    check(unsafe.getBooleanVolatile(tv, volatileBooleanOffset),
+          false,
+          "Unsafe.getBooleanVolatile(Object, long) - initial");
+    unsafe.putBooleanVolatile(tv, volatileBooleanOffset, booleanValue);
+    check(tv.volatileBooleanVar, booleanValue, "Unsafe.putBooleanVolatile(Object, long, boolean)");
+    check(unsafe.getBooleanVolatile(tv, volatileBooleanOffset),
+          booleanValue,
+          "Unsafe.getBooleanVolatile(Object, long)");
+
+    byte byteValue = 125;
+    Field volatileByteField = TestVolatileClass.class.getDeclaredField("volatileByteVar");
+    long volatileByteOffset = unsafe.objectFieldOffset(volatileByteField);
+    check(unsafe.getByteVolatile(tv, volatileByteOffset),
+          0,
+          "Unsafe.getByteVolatile(Object, long) - initial");
+    unsafe.putByteVolatile(tv, volatileByteOffset, byteValue);
+    check(tv.volatileByteVar, byteValue, "Unsafe.putByteVolatile(Object, long, byte)");
+    check(unsafe.getByteVolatile(tv, volatileByteOffset),
+          byteValue,
+          "Unsafe.getByteVolatile(Object, long)");
+
+    char charValue = 'X';
+    Field volatileCharField = TestVolatileClass.class.getDeclaredField("volatileCharVar");
+    long volatileCharOffset = unsafe.objectFieldOffset(volatileCharField);
+    check(unsafe.getCharVolatile(tv, volatileCharOffset),
+          '\0',
+          "Unsafe.getCharVolatile(Object, long) - initial");
+    unsafe.putCharVolatile(tv, volatileCharOffset, charValue);
+    check(tv.volatileCharVar, charValue, "Unsafe.putCharVolatile(Object, long, char)");
+    check(unsafe.getCharVolatile(tv, volatileCharOffset),
+          charValue,
+          "Unsafe.getCharVolatile(Object, long)");
+
+    short shortValue = 32523;
+    Field volatileShortField = TestVolatileClass.class.getDeclaredField("volatileShortVar");
+    long volatileShortOffset = unsafe.objectFieldOffset(volatileShortField);
+    check(unsafe.getShortVolatile(tv, volatileShortOffset),
+          0,
+          "Unsafe.getShortVolatile(Object, long) - initial");
+    unsafe.putShortVolatile(tv, volatileShortOffset, shortValue);
+    check(tv.volatileShortVar, shortValue, "Unsafe.putShortVolatile(Object, long, short)");
+    check(unsafe.getShortVolatile(tv, volatileShortOffset),
+          shortValue,
+          "Unsafe.getShortVolatile(Object, long)");
+
     long longValue = 1234567887654321L;
     Field volatileLongField = TestVolatileClass.class.getDeclaredField("volatileLongVar");
     long volatileLongOffset = unsafe.objectFieldOffset(volatileLongField);
@@ -357,17 +433,41 @@ public class Main {
           longValue,
           "Unsafe.getLongVolatile(Object, long)");
 
+    float floatValue = 123456.7890123f;
+    Field volatileFloatField = TestVolatileClass.class.getDeclaredField("volatileFloatVar");
+    long volatileFloatOffset = unsafe.objectFieldOffset(volatileFloatField);
+    check(unsafe.getFloatVolatile(tv, volatileFloatOffset),
+          0.0f,
+          "Unsafe.getFloatVolatile(Object, long) - initial");
+    unsafe.putFloatVolatile(tv, volatileFloatOffset, floatValue);
+    check(tv.volatileFloatVar, floatValue, "Unsafe.putFloatVolatile(Object, long, float)");
+    check(unsafe.getFloatVolatile(tv, volatileFloatOffset),
+          floatValue,
+          "Unsafe.getFloatVolatile(Object, long)");
+
+    double doubleValue = 654321.7890123d;
+    Field volatileDoubleField = TestVolatileClass.class.getDeclaredField("volatileDoubleVar");
+    long volatileDoubleOffset = unsafe.objectFieldOffset(volatileDoubleField);
+    check(unsafe.getDoubleVolatile(tv, volatileDoubleOffset),
+          0.0d,
+          "Unsafe.getDoubleVolatile(Object, double) - initial");
+    unsafe.putDoubleVolatile(tv, volatileDoubleOffset, doubleValue);
+    check(tv.volatileDoubleVar, doubleValue, "Unsafe.putDoubleVolatile(Object, long, double)");
+    check(unsafe.getDoubleVolatile(tv, volatileDoubleOffset),
+          doubleValue,
+          "Unsafe.getDoubleVolatile(Object, long)");
+
     Object objectValue = new Object();
     Field volatileObjectField = TestVolatileClass.class.getDeclaredField("volatileObjectVar");
     long volatileObjectOffset = unsafe.objectFieldOffset(volatileObjectField);
-    check(unsafe.getObjectVolatile(tv, volatileObjectOffset),
+    check(unsafe.getReferenceVolatile(tv, volatileObjectOffset),
           null,
-          "Unsafe.getObjectVolatile(Object, long) - initial");
-    unsafe.putObjectVolatile(tv, volatileObjectOffset, objectValue);
-    check(tv.volatileObjectVar, objectValue, "Unsafe.putObjectVolatile(Object, long, Object)");
-    check(unsafe.getObjectVolatile(tv, volatileObjectOffset),
+          "Unsafe.getReferenceVolatile(Object, long) - initial");
+    unsafe.putReferenceVolatile(tv, volatileObjectOffset, objectValue);
+    check(tv.volatileObjectVar, objectValue, "Unsafe.putReferenceVolatile(Object, long, Object)");
+    check(unsafe.getReferenceVolatile(tv, volatileObjectOffset),
           objectValue,
-          "Unsafe.getObjectVolatile(Object, long)");
+          "Unsafe.getReferenceVolatile(Object, long)");
   }
 
   private static void testGetAcquireAndPutRelease(Unsafe unsafe) throws NoSuchFieldException {
@@ -513,7 +613,13 @@ public class Main {
 
   private static class TestVolatileClass {
     public volatile int volatileIntVar = 0;
+    public volatile boolean volatileBooleanVar = false;
+    public volatile byte volatileByteVar = 0;
+    public volatile short volatileShortVar = 0;
+    public volatile char volatileCharVar = 0;
     public volatile long volatileLongVar = 0;
+    public volatile float volatileFloatVar = 0.0f;
+    public volatile double volatileDoubleVar = 0.0d;
     public volatile Object volatileObjectVar = null;
   }
 
diff --git a/test/2236-JdkUnsafeGetLong-regression/Android.bp b/test/2236-JdkUnsafeGetLong-regression/Android.bp
index 403cab8608..4f022da0d7 100644
--- a/test/2236-JdkUnsafeGetLong-regression/Android.bp
+++ b/test/2236-JdkUnsafeGetLong-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2236-JdkUnsafeGetLong-regression-expected-stdout",
         ":art-run-test-2236-JdkUnsafeGetLong-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2241-checker-inline-try-catch/Android.bp b/test/2241-checker-inline-try-catch/Android.bp
index 15708d6744..7c6ee45895 100644
--- a/test/2241-checker-inline-try-catch/Android.bp
+++ b/test/2241-checker-inline-try-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2241-checker-inline-try-catch-expected-stdout",
         ":art-run-test-2241-checker-inline-try-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2242-checker-lse-acquire-release-operations/Android.bp b/test/2242-checker-lse-acquire-release-operations/Android.bp
index bb493ce284..1c1c851358 100644
--- a/test/2242-checker-lse-acquire-release-operations/Android.bp
+++ b/test/2242-checker-lse-acquire-release-operations/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2242-checker-lse-acquire-release-operations-expected-stdout",
         ":art-run-test-2242-checker-lse-acquire-release-operations-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2243-checker-not-inline-into-throw/Android.bp b/test/2243-checker-not-inline-into-throw/Android.bp
index 78c5c66336..2e9bf470c7 100644
--- a/test/2243-checker-not-inline-into-throw/Android.bp
+++ b/test/2243-checker-not-inline-into-throw/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2243-checker-not-inline-into-throw-expected-stdout",
         ":art-run-test-2243-checker-not-inline-into-throw-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2244-checker-remove-try-boundary/Android.bp b/test/2244-checker-remove-try-boundary/Android.bp
index 9e03692808..faffd46e8a 100644
--- a/test/2244-checker-remove-try-boundary/Android.bp
+++ b/test/2244-checker-remove-try-boundary/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2244-checker-remove-try-boundary-expected-stdout",
         ":art-run-test-2244-checker-remove-try-boundary-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2246-trace-stream/src/BaseTraceParser.java b/test/2246-trace-stream/src/BaseTraceParser.java
index 80f695a61a..9f0a978ab2 100644
--- a/test/2246-trace-stream/src/BaseTraceParser.java
+++ b/test/2246-trace-stream/src/BaseTraceParser.java
@@ -20,6 +20,7 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.util.HashMap;
+import java.util.Set;
 
 abstract class BaseTraceParser {
     public static final int MAGIC_NUMBER = 0x574f4c53;
@@ -31,12 +32,15 @@ abstract class BaseTraceParser {
     public static final String METHODS_SECTION_ID = "*methods";
     public static final String THREADS_SECTION_ID = "*threads";
     public static final String END_SECTION_ID = "*end";
+    public static final Set<String> ignoredMethods = Set.of(
+        "java.lang.ref.ReferenceQueue add (Ljava/lang/ref/Reference;)V ReferenceQueue.java");
 
     public void InitializeParser(File file) throws IOException {
         dataStream = new DataInputStream(new FileInputStream(file));
         methodIdMap = new HashMap<Integer, String>();
         threadIdMap = new HashMap<Integer, String>();
         nestingLevelMap = new HashMap<Integer, Integer>();
+        ignoredMethodNestingLevelMap = new HashMap<Integer, Integer>();
         threadEventsMap = new HashMap<String, String>();
         threadTimestamp1Map = new HashMap<Integer, Integer>();
         threadTimestamp2Map = new HashMap<Integer, Integer>();
@@ -200,8 +204,36 @@ abstract class BaseTraceParser {
         int methodId = methodAndEvent & ~0x3;
         int eventType = methodAndEvent & 0x3;
 
+        String methodName = methodIdMap.get(methodId);
+        int currNestingLevel = 0;
+        if (nestingLevelMap.containsKey(threadId)) {
+          currNestingLevel = nestingLevelMap.get(threadId);
+        }
+        boolean recordMethodEvent = true;
+        if (!ignoredMethodNestingLevelMap.containsKey(threadId)) {
+          if (ignoredMethods.contains(methodName)) {
+            // This should be an entry event.
+            if (eventType != 0) {
+              throw new Exception("Seeing an exit for an ignored event without an entry");
+            }
+            ignoredMethodNestingLevelMap.put(threadId, currNestingLevel);
+            recordMethodEvent = false;
+          }
+        } else {
+          // We need to ignore all calls until the ignored method exits.
+          int ignoredMethodDepth = ignoredMethodNestingLevelMap.get(threadId);
+          // If this is a method exit and we are at the right depth remove the entry so we start
+          // recording from the next event.
+          if (ignoredMethodDepth == currNestingLevel - 1 && eventType != 0) {
+            ignoredMethodNestingLevelMap.remove(threadId);
+            if (!ignoredMethods.contains(methodName)) {
+              throw new Exception("Unexpected method on exit. Mismatch on method entry and exit");
+            }
+          }
+          recordMethodEvent = false;
+        }
         String str = eventTypeToString(eventType, threadId) + " " + threadIdMap.get(threadId)
-                + " " + methodIdMap.get(methodId);
+                + " " + methodName;
         // Depending on the version skip either one or two timestamps.
         int timestamp1 = readNumber(4);
         CheckTimestamp(timestamp1, threadId, threadTimestamp1Map);
@@ -210,7 +242,7 @@ abstract class BaseTraceParser {
             int timestamp2 = readNumber(4);
             CheckTimestamp(timestamp2, threadId, threadTimestamp2Map);
         }
-        return str;
+        return recordMethodEvent? str : null;
     }
 
     public void UpdateThreadEvents(int threadId, String entry) {
@@ -229,6 +261,7 @@ abstract class BaseTraceParser {
     HashMap<Integer, String> methodIdMap;
     HashMap<Integer, String> threadIdMap;
     HashMap<Integer, Integer> nestingLevelMap;
+    HashMap<Integer, Integer> ignoredMethodNestingLevelMap;
     HashMap<String, String> threadEventsMap;
     HashMap<Integer, Integer> threadTimestamp1Map;
     HashMap<Integer, Integer> threadTimestamp2Map;
diff --git a/test/2246-trace-stream/src/NonStreamTraceParser.java b/test/2246-trace-stream/src/NonStreamTraceParser.java
index f106c49bb8..150831d10b 100644
--- a/test/2246-trace-stream/src/NonStreamTraceParser.java
+++ b/test/2246-trace-stream/src/NonStreamTraceParser.java
@@ -82,6 +82,10 @@ public class NonStreamTraceParser extends BaseTraceParser {
         for (int i = 0; i < numEntries; i++) {
             int threadId = GetThreadID();
             String eventString = ProcessEventEntry(threadId);
+            // This is an event from one of the ignored methods. Don't record this entry.
+            if (eventString == null) {
+              continue;
+            }
             // Ignore daemons (ex: heap task daemon, reference queue daemon) because they may not
             // be deterministic.
             if (!ShouldCheckThread(threadId, threadName)) {
diff --git a/test/2246-trace-stream/src/StreamTraceParser.java b/test/2246-trace-stream/src/StreamTraceParser.java
index 3cad4e9251..1679ef0581 100644
--- a/test/2246-trace-stream/src/StreamTraceParser.java
+++ b/test/2246-trace-stream/src/StreamTraceParser.java
@@ -30,6 +30,10 @@ public class StreamTraceParser extends BaseTraceParser {
             int threadId = GetThreadID();
             if (threadId != 0) {
               String eventString = ProcessEventEntry(threadId);
+              // This is an event from one of the ignored methods. Don't record this entry.
+              if (eventString == null) {
+                continue;
+              }
               if (!ShouldCheckThread(threadId, threadName)) {
                 continue;
               }
diff --git a/test/2247-checker-write-barrier-elimination/Android.bp b/test/2247-checker-write-barrier-elimination/Android.bp
index c9744e9b00..89d1849ebc 100644
--- a/test/2247-checker-write-barrier-elimination/Android.bp
+++ b/test/2247-checker-write-barrier-elimination/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2247-checker-write-barrier-elimination-expected-stdout",
         ":art-run-test-2247-checker-write-barrier-elimination-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2249-checker-return-try-boundary-exit-in-loop/Android.bp b/test/2249-checker-return-try-boundary-exit-in-loop/Android.bp
index 3bc249e501..111f60995e 100644
--- a/test/2249-checker-return-try-boundary-exit-in-loop/Android.bp
+++ b/test/2249-checker-return-try-boundary-exit-in-loop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2249-checker-return-try-boundary-exit-in-loop-expected-stdout",
         ":art-run-test-2249-checker-return-try-boundary-exit-in-loop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2250-inline-throw-into-try/Android.bp b/test/2250-inline-throw-into-try/Android.bp
index 6a0a7d6577..b787d9e846 100644
--- a/test/2250-inline-throw-into-try/Android.bp
+++ b/test/2250-inline-throw-into-try/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2250-inline-throw-into-try-expected-stdout",
         ":art-run-test-2250-inline-throw-into-try-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2252-rem-optimization-dividend-divisor/Android.bp b/test/2252-rem-optimization-dividend-divisor/Android.bp
index 75dad8a44d..f69f29e9eb 100644
--- a/test/2252-rem-optimization-dividend-divisor/Android.bp
+++ b/test/2252-rem-optimization-dividend-divisor/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2252-rem-optimization-dividend-divisor-expected-stdout",
         ":art-run-test-2252-rem-optimization-dividend-divisor-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2253-checker-devirtualize-always-throws/Android.bp b/test/2253-checker-devirtualize-always-throws/Android.bp
index c818281f5e..77bb70e54a 100644
--- a/test/2253-checker-devirtualize-always-throws/Android.bp
+++ b/test/2253-checker-devirtualize-always-throws/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2253-checker-devirtualize-always-throws-expected-stdout",
         ":art-run-test-2253-checker-devirtualize-always-throws-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2254-checker-not-var-analyzed-pathological/Android.bp b/test/2254-checker-not-var-analyzed-pathological/Android.bp
index deb5c93f41..324e17fdd8 100644
--- a/test/2254-checker-not-var-analyzed-pathological/Android.bp
+++ b/test/2254-checker-not-var-analyzed-pathological/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2254-checker-not-var-analyzed-pathological-expected-stdout",
         ":art-run-test-2254-checker-not-var-analyzed-pathological-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2254-class-value-before-and-after-u/Android.bp b/test/2254-class-value-before-and-after-u/Android.bp
index 25c25fb00e..771045d0e8 100644
--- a/test/2254-class-value-before-and-after-u/Android.bp
+++ b/test/2254-class-value-before-and-after-u/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2254-class-value-before-and-after-u-expected-stdout",
         ":art-run-test-2254-class-value-before-and-after-u-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2255-checker-branch-redirection/Android.bp b/test/2255-checker-branch-redirection/Android.bp
index b7ac541472..528956e5f1 100644
--- a/test/2255-checker-branch-redirection/Android.bp
+++ b/test/2255-checker-branch-redirection/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2255-checker-branch-redirection-expected-stdout",
         ":art-run-test-2255-checker-branch-redirection-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2256-checker-vector-replacement/Android.bp b/test/2256-checker-vector-replacement/Android.bp
index b475493523..16432f55e2 100644
--- a/test/2256-checker-vector-replacement/Android.bp
+++ b/test/2256-checker-vector-replacement/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2256-checker-vector-replacement-expected-stdout",
         ":art-run-test-2256-checker-vector-replacement-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2257-checker-constant-folding-before-codegen/Android.bp b/test/2257-checker-constant-folding-before-codegen/Android.bp
index 3326c5f8e6..40fba9c13a 100644
--- a/test/2257-checker-constant-folding-before-codegen/Android.bp
+++ b/test/2257-checker-constant-folding-before-codegen/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2257-checker-constant-folding-before-codegen-expected-stdout",
         ":art-run-test-2257-checker-constant-folding-before-codegen-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2258-checker-valid-rti/Android.bp b/test/2258-checker-valid-rti/Android.bp
index 701835dd34..11e457e1db 100644
--- a/test/2258-checker-valid-rti/Android.bp
+++ b/test/2258-checker-valid-rti/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2258-checker-valid-rti-expected-stdout",
         ":art-run-test-2258-checker-valid-rti-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2259-checker-code-sinking-infinite-try-catch/Android.bp b/test/2259-checker-code-sinking-infinite-try-catch/Android.bp
index ab53ee38ee..28620687d3 100644
--- a/test/2259-checker-code-sinking-infinite-try-catch/Android.bp
+++ b/test/2259-checker-code-sinking-infinite-try-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2259-checker-code-sinking-infinite-try-catch-expected-stdout",
         ":art-run-test-2259-checker-code-sinking-infinite-try-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2260-checker-inline-unimplemented-intrinsics/Android.bp b/test/2260-checker-inline-unimplemented-intrinsics/Android.bp
index 7fca8e3ed7..9b789c7eeb 100644
--- a/test/2260-checker-inline-unimplemented-intrinsics/Android.bp
+++ b/test/2260-checker-inline-unimplemented-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2260-checker-inline-unimplemented-intrinsics-expected-stdout",
         ":art-run-test-2260-checker-inline-unimplemented-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2262-checker-return-sinking/Android.bp b/test/2262-checker-return-sinking/Android.bp
index 1eaadd6dd3..19a65597d4 100644
--- a/test/2262-checker-return-sinking/Android.bp
+++ b/test/2262-checker-return-sinking/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2262-checker-return-sinking-expected-stdout",
         ":art-run-test-2262-checker-return-sinking-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2265-checker-select-binary-unary/Android.bp b/test/2265-checker-select-binary-unary/Android.bp
index 5267b1e07c..cbe3fd6df6 100644
--- a/test/2265-checker-select-binary-unary/Android.bp
+++ b/test/2265-checker-select-binary-unary/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2265-checker-select-binary-unary-expected-stdout",
         ":art-run-test-2265-checker-select-binary-unary-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2266-checker-remove-empty-ifs/Android.bp b/test/2266-checker-remove-empty-ifs/Android.bp
index 197ad300d7..989e4e80d0 100644
--- a/test/2266-checker-remove-empty-ifs/Android.bp
+++ b/test/2266-checker-remove-empty-ifs/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2266-checker-remove-empty-ifs-expected-stdout",
         ":art-run-test-2266-checker-remove-empty-ifs-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2268-checker-remove-dead-phis/Android.bp b/test/2268-checker-remove-dead-phis/Android.bp
index 85d16d151a..5163abcd7e 100644
--- a/test/2268-checker-remove-dead-phis/Android.bp
+++ b/test/2268-checker-remove-dead-phis/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2268-checker-remove-dead-phis-expected-stdout",
         ":art-run-test-2268-checker-remove-dead-phis-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2269-checker-constant-folding-intrinsics/Android.bp b/test/2269-checker-constant-folding-intrinsics/Android.bp
index cc4545f865..ca0d87c262 100644
--- a/test/2269-checker-constant-folding-intrinsics/Android.bp
+++ b/test/2269-checker-constant-folding-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2269-checker-constant-folding-intrinsics-expected-stdout",
         ":art-run-test-2269-checker-constant-folding-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2273-checker-unreachable-intrinsics/Android.bp b/test/2273-checker-unreachable-intrinsics/Android.bp
index be4dd29437..7dd167560d 100644
--- a/test/2273-checker-unreachable-intrinsics/Android.bp
+++ b/test/2273-checker-unreachable-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2273-checker-unreachable-intrinsics-expected-stdout",
         ":art-run-test-2273-checker-unreachable-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2274-checker-bitwise-gvn/Android.bp b/test/2274-checker-bitwise-gvn/Android.bp
index b2d0fd2742..d35f172172 100644
--- a/test/2274-checker-bitwise-gvn/Android.bp
+++ b/test/2274-checker-bitwise-gvn/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2274-checker-bitwise-gvn-expected-stdout",
         ":art-run-test-2274-checker-bitwise-gvn-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2275-checker-empty-loops/Android.bp b/test/2275-checker-empty-loops/Android.bp
index 95c18bd196..686d809eb1 100644
--- a/test/2275-checker-empty-loops/Android.bp
+++ b/test/2275-checker-empty-loops/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2275-checker-empty-loops-expected-stdout",
         ":art-run-test-2275-checker-empty-loops-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/2275-integral-unsigned-arithmetic/Android.bp b/test/2275-integral-unsigned-arithmetic/Android.bp
index 00770c8133..528d2afdf6 100644
--- a/test/2275-integral-unsigned-arithmetic/Android.bp
+++ b/test/2275-integral-unsigned-arithmetic/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2275-integral-unsigned-arithmetic-expected-stdout",
         ":art-run-test-2275-integral-unsigned-arithmetic-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2277-methodhandle-invokeexact/build.py b/test/2277-methodhandle-invokeexact/build.py
index d71324961b..966582b660 100644
--- a/test/2277-methodhandle-invokeexact/build.py
+++ b/test/2277-methodhandle-invokeexact/build.py
@@ -1,4 +1,21 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
 def build(ctx):
+  ctx.bash("./generate-sources")
   # To allow private interface methods.
-  ctx.default_build(javac_source_arg="17",
+  ctx.default_build(api_level="const-method-type",
+                    javac_source_arg="17",
                     javac_target_arg="17")
diff --git a/test/2277-methodhandle-invokeexact/generate-sources b/test/2277-methodhandle-invokeexact/generate-sources
new file mode 100755
index 0000000000..d74ca98a8c
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/generate-sources
@@ -0,0 +1,29 @@
+#!/bin/bash
+#
+# Copyright 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# make us exit on a failure
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Build the transformer to apply to compiled classes.
+mkdir classes
+${JAVAC:-javac} ${JAVAC_ARGS} -cp "${ASM_JAR}" -d classes $(find src-util -name '*.java')
+${SOONG_ZIP} --jar -o transformer.jar -C classes -D classes
+rm -rf classes
+
+# Add annotation src files to our compiler inputs.
+cp -r src-util/annotations src/
diff --git a/test/2277-methodhandle-invokeexact/javac_post.sh b/test/2277-methodhandle-invokeexact/javac_post.sh
new file mode 100755
index 0000000000..2455dd7fb2
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/javac_post.sh
@@ -0,0 +1,36 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Move original classes to intermediate location.
+mv $1 $1-intermediate-classes
+mkdir $1
+
+# Transform intermediate classes.
+transformer_args="-cp ${ASM_JAR}:$PWD/transformer.jar transformer.ConstantTransformer"
+for class in $1-intermediate-classes/*.class ; do
+  if [[ $class == */FooConflict.class ]]
+  then
+    javap -c -v -p $class >> /tmp/2277-javac-output
+  fi
+  transformed_class=$1/$(basename ${class})
+  ${JAVA:-java} ${transformer_args} ${class} ${transformed_class}
+done
+
+rm -fr $1-intermediate-classes
diff --git a/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodHandle.java b/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodHandle.java
new file mode 100644
index 0000000000..ffc88b65fb
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodHandle.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodHandle constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodHandle {
+    /* Method handle kinds */
+    public static final int STATIC_PUT = 0;
+    public static final int STATIC_GET = 1;
+    public static final int INSTANCE_PUT = 2;
+    public static final int INSTANCE_GET = 3;
+    public static final int INVOKE_STATIC = 4;
+    public static final int INVOKE_VIRTUAL = 5;
+    public static final int INVOKE_SPECIAL = 6;
+    public static final int NEW_INVOKE_SPECIAL = 7;
+    public static final int INVOKE_INTERFACE = 8;
+
+    /** Kind of method handle. */
+    int kind();
+
+    /** Class name owning the field or method. */
+    String owner();
+
+    /** The field or method name addressed by the MethodHandle. */
+    String fieldOrMethodName();
+
+    /** Descriptor for the field (type) or method (method-type) */
+    String descriptor();
+
+    /** Whether the owner is an interface. */
+    boolean ownerIsInterface() default false;
+}
diff --git a/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodType.java b/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodType.java
new file mode 100644
index 0000000000..55b1536e6c
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src-util/annotations/ConstantMethodType.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodType constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodType {
+    /** Return type of method() or field getter() */
+    Class<?> returnType() default void.class;
+
+    /** Types of parameters for method or field setter() */
+    Class<?>[] parameterTypes() default {};
+}
diff --git a/test/2277-methodhandle-invokeexact/src-util/transformer/ConstantTransformer.java b/test/2277-methodhandle-invokeexact/src-util/transformer/ConstantTransformer.java
new file mode 100644
index 0000000000..45e7b9ccdb
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src-util/transformer/ConstantTransformer.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package transformer;
+
+import annotations.ConstantMethodHandle;
+import annotations.ConstantMethodType;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Class for transforming invoke static bytecodes into constant method handle loads and constant
+ * method type loads.
+ *
+ * <p>When a parameterless private static method returning a MethodHandle is defined and annotated
+ * with {@code ConstantMethodHandle}, this transformer will replace static invocations of the method
+ * with a load constant bytecode with a method handle in the constant pool.
+ *
+ * <p>Suppose a method is annotated as: <code>
+ *  @ConstantMethodHandle(
+ *      kind = ConstantMethodHandle.STATIC_GET,
+ *      owner = "java/lang/Math",
+ *      fieldOrMethodName = "E",
+ *      descriptor = "D"
+ *  )
+ *  private static MethodHandle getMathE() {
+ *      unreachable();
+ *      return null;
+ *  }
+ * </code> Then invocations of {@code getMathE} will be replaced by a load from the constant pool
+ * with the constant method handle described in the {@code ConstantMethodHandle} annotation.
+ *
+ * <p>Similarly, a parameterless private static method returning a {@code MethodType} and annotated
+ * with {@code ConstantMethodType}, will have invocations replaced by a load constant bytecode with
+ * a method type in the constant pool.
+ */
+class ConstantTransformer {
+    static class ConstantBuilder extends ClassVisitor {
+        private final Map<String, ConstantMethodHandle> constantMethodHandles;
+        private final Map<String, ConstantMethodType> constantMethodTypes;
+
+        ConstantBuilder(
+                int api,
+                ClassVisitor cv,
+                Map<String, ConstantMethodHandle> constantMethodHandles,
+                Map<String, ConstantMethodType> constantMethodTypes) {
+            super(api, cv);
+            this.constantMethodHandles = constantMethodHandles;
+            this.constantMethodTypes = constantMethodTypes;
+        }
+
+        @Override
+        public MethodVisitor visitMethod(
+                int access, String name, String desc, String signature, String[] exceptions) {
+            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
+            return new MethodVisitor(this.api, mv) {
+                @Override
+                public void visitMethodInsn(
+                        int opcode, String owner, String name, String desc, boolean itf) {
+                    if (opcode == org.objectweb.asm.Opcodes.INVOKESTATIC) {
+                        ConstantMethodHandle constantMethodHandle = constantMethodHandles.get(name);
+                        if (constantMethodHandle != null) {
+                            insertConstantMethodHandle(constantMethodHandle);
+                            return;
+                        }
+                        ConstantMethodType constantMethodType = constantMethodTypes.get(name);
+                        if (constantMethodType != null) {
+                            insertConstantMethodType(constantMethodType);
+                            return;
+                        }
+                    }
+                    mv.visitMethodInsn(opcode, owner, name, desc, itf);
+                }
+
+                private Type buildMethodType(Class<?> returnType, Class<?>[] parameterTypes) {
+                    Type rType = Type.getType(returnType);
+                    Type[] pTypes = new Type[parameterTypes.length];
+                    for (int i = 0; i < pTypes.length; ++i) {
+                        pTypes[i] = Type.getType(parameterTypes[i]);
+                    }
+                    return Type.getMethodType(rType, pTypes);
+                }
+
+                private int getHandleTag(int kind) {
+                    switch (kind) {
+                        case ConstantMethodHandle.STATIC_PUT:
+                            return Opcodes.H_PUTSTATIC;
+                        case ConstantMethodHandle.STATIC_GET:
+                            return Opcodes.H_GETSTATIC;
+                        case ConstantMethodHandle.INSTANCE_PUT:
+                            return Opcodes.H_PUTFIELD;
+                        case ConstantMethodHandle.INSTANCE_GET:
+                            return Opcodes.H_GETFIELD;
+                        case ConstantMethodHandle.INVOKE_STATIC:
+                            return Opcodes.H_INVOKESTATIC;
+                        case ConstantMethodHandle.INVOKE_VIRTUAL:
+                            return Opcodes.H_INVOKEVIRTUAL;
+                        case ConstantMethodHandle.INVOKE_SPECIAL:
+                            return Opcodes.H_INVOKESPECIAL;
+                        case ConstantMethodHandle.NEW_INVOKE_SPECIAL:
+                            return Opcodes.H_NEWINVOKESPECIAL;
+                        case ConstantMethodHandle.INVOKE_INTERFACE:
+                            return Opcodes.H_INVOKEINTERFACE;
+                    }
+                    throw new Error("Unhandled kind " + kind);
+                }
+
+                private void insertConstantMethodHandle(ConstantMethodHandle constantMethodHandle) {
+                    Handle handle =
+                            new Handle(
+                                    getHandleTag(constantMethodHandle.kind()),
+                                    constantMethodHandle.owner(),
+                                    constantMethodHandle.fieldOrMethodName(),
+                                    constantMethodHandle.descriptor(),
+                                    constantMethodHandle.ownerIsInterface());
+                    mv.visitLdcInsn(handle);
+                }
+
+                private void insertConstantMethodType(ConstantMethodType constantMethodType) {
+                    Type methodType =
+                            buildMethodType(
+                                    constantMethodType.returnType(),
+                                    constantMethodType.parameterTypes());
+                    mv.visitLdcInsn(methodType);
+                }
+            };
+        }
+    }
+
+    private static void throwAnnotationError(
+            Method method, Class<?> annotationClass, String reason) {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Error in annotation ")
+                .append(annotationClass)
+                .append(" on method ")
+                .append(method)
+                .append(": ")
+                .append(reason);
+        throw new Error(sb.toString());
+    }
+
+    private static void checkMethodToBeReplaced(
+            Method method, Class<?> annotationClass, Class<?> returnType) {
+        final int PRIVATE_STATIC = Modifier.STATIC | Modifier.PRIVATE;
+        if ((method.getModifiers() & PRIVATE_STATIC) != PRIVATE_STATIC) {
+            throwAnnotationError(method, annotationClass, " method is not private and static");
+        }
+        if (method.getTypeParameters().length != 0) {
+            throwAnnotationError(method, annotationClass, " method expects parameters");
+        }
+        if (!method.getReturnType().equals(returnType)) {
+            throwAnnotationError(method, annotationClass, " wrong return type");
+        }
+    }
+
+    private static void transform(Path inputClassPath, Path outputClassPath) throws Throwable {
+        Path classLoadPath = inputClassPath.toAbsolutePath().getParent();
+        URLClassLoader classLoader =
+                new URLClassLoader(new URL[] {classLoadPath.toUri().toURL()},
+                                   ClassLoader.getSystemClassLoader());
+        String inputClassName = inputClassPath.getFileName().toString().replace(".class", "");
+        Class<?> inputClass = classLoader.loadClass(inputClassName);
+
+        final Map<String, ConstantMethodHandle> constantMethodHandles = new HashMap<>();
+        final Map<String, ConstantMethodType> constantMethodTypes = new HashMap<>();
+
+        for (Method m : inputClass.getDeclaredMethods()) {
+            ConstantMethodHandle constantMethodHandle = m.getAnnotation(ConstantMethodHandle.class);
+            if (constantMethodHandle != null) {
+                checkMethodToBeReplaced(m, ConstantMethodHandle.class, MethodHandle.class);
+                constantMethodHandles.put(m.getName(), constantMethodHandle);
+                continue;
+            }
+
+            ConstantMethodType constantMethodType = m.getAnnotation(ConstantMethodType.class);
+            if (constantMethodType != null) {
+                checkMethodToBeReplaced(m, ConstantMethodType.class, MethodType.class);
+                constantMethodTypes.put(m.getName(), constantMethodType);
+                continue;
+            }
+        }
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+        try (InputStream is = Files.newInputStream(inputClassPath)) {
+            ClassReader cr = new ClassReader(is);
+            ConstantBuilder cb =
+                    new ConstantBuilder(
+                            Opcodes.ASM7, cw, constantMethodHandles, constantMethodTypes);
+            cr.accept(cb, 0);
+        }
+        try (OutputStream os = Files.newOutputStream(outputClassPath)) {
+            os.write(cw.toByteArray());
+        }
+    }
+
+    public static void main(String[] args) throws Throwable {
+        transform(Paths.get(args[0]), Paths.get(args[1]));
+    }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/A.java b/test/2277-methodhandle-invokeexact/src/A.java
new file mode 100644
index 0000000000..b6fc317cb0
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/A.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class A extends B implements I {
+  public int field;
+  public void voidMethod() {
+    AbstractInvokeExactTest.STATUS = "A.voidMethod";
+  }
+
+  @Override
+  public void overrideMe() {
+    AbstractInvokeExactTest.STATUS = "A.overrideMe";
+  }
+
+  public void throwException() {
+    AbstractInvokeExactTest.STATUS = "A.throwException";
+    throw new MyRuntimeException();
+  }
+
+  public double returnDouble() {
+    return 42.0d;
+  }
+
+  public int returnInt() {
+    return 42;
+  }
+
+  private int privateReturnInt() {
+    return 1042;
+  }
+
+  public static String staticMethod(A a) {
+    return "staticMethod";
+  }
+
+  public static double staticMethod() {
+    return 41.0d;
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/AbstractInvokeExactTest.java b/test/2277-methodhandle-invokeexact/src/AbstractInvokeExactTest.java
new file mode 100644
index 0000000000..1b5dc4fd03
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/AbstractInvokeExactTest.java
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.WrongMethodTypeException;
+import java.util.Objects;
+
+public abstract class AbstractInvokeExactTest {
+
+  public static String STATUS = "";
+
+  public final void runAll() throws Throwable {
+    STATUS = "";
+    Multi.$noinline$testMHFromMain(optionalGet());
+    $noinline$privateMethods();
+    $noinline$testNoArgsCalls();
+    $noinline$nullchecks();
+    $noinline$testWithArgs();
+    $noinline$interfaceChecks();
+    $noinline$abstractClass();
+  }
+
+  // There is no privateLookupIn for const-method-handle.
+  abstract void $noinline$privateMethods() throws Throwable;
+
+  private void $noinline$testNoArgsCalls() throws Throwable {
+    voidMethod().invokeExact(new A());
+    assertEquals("A.voidMethod", STATUS);
+
+    int returnedInt = (int) returnInt().invokeExact(new A());
+    assertEquals(42, returnedInt);
+
+    double returnedDouble = (double) returnDouble().invokeExact(new A());
+    assertEquals(42.0d, returnedDouble);
+    try {
+      interfaceDefaultMethod().invokeExact(new A());
+      unreachable("MethodHandle's type is (Main$I)V, but callsite is (Main$A)V");
+    } catch (WrongMethodTypeException expected) {}
+
+    interfaceDefaultMethod().invokeExact((I) new A());
+    assertEquals("I.defaultMethod", STATUS);
+
+    overwrittenInterfaceDefaultMethod().invokeExact((I) new A());
+    assertEquals("A.overrideMe", STATUS);
+
+
+    try {
+      exceptionThrowingMethod().invokeExact(new A());
+      unreachable("Target method always throws");
+    } catch (MyRuntimeException expected) {
+      assertEquals("A.throwException", STATUS);
+    }
+
+    try {
+      returnInt().invokeExact(new A());
+      unreachable("MethodHandle's type is (Main$A)I, but callsite type is (Main$A)V");
+    } catch (WrongMethodTypeException expected) {}
+
+    String returnedString = (String) staticMethod().invokeExact(new A());
+    assertEquals("staticMethod", returnedString);
+  }
+
+  private void $noinline$nullchecks() throws Throwable {
+    try {
+      voidMethod().invokeExact((A) null);
+      unreachable("Receiver is null, should throw NPE");
+    } catch (NullPointerException expected) {}
+
+    try {
+      voidMethod().invokeExact((Main) null);
+      unreachable("Should throw WMTE: input is of wrong type");
+    } catch (WrongMethodTypeException expected) {}
+
+    try {
+      interfaceDefaultMethod().invokeExact((I) null);
+      unreachable("Receiver is null, should throw NPE");
+    } catch (NullPointerException expected) {}
+
+    try {
+      interfaceDefaultMethod().invokeExact((A) null);
+      unreachable("Should throw WMTE: input is of wrong type");
+    } catch (WrongMethodTypeException expected) {}
+
+    try {
+      MethodHandle mh = $noinline$nullMethodHandle();
+      mh.invokeExact();
+      unreachable("MethodHandle object is null, should throw NPE");
+    } catch (NullPointerException expected) {}
+  }
+
+  private static MethodHandle $noinline$nullMethodHandle() {
+    return null;
+  }
+
+  private void $noinline$testWithArgs() throws Throwable {
+    int sum = (int) sumI().invokeExact(new Sums(), 1);
+    assertEquals(1, sum);
+
+    sum = (int) sum2I().invokeExact(new Sums(), 1, 2);
+    assertEquals(3, sum);
+
+    sum = (int) sum3I().invokeExact(new Sums(), 1, 2, 3);
+    assertEquals(6, sum);
+
+    sum = (int) sum4I().invokeExact(new Sums(), 1, 2, 3, 4);
+    assertEquals(10, sum);
+
+    sum = (int) sum5I().invokeExact(new Sums(), 1, 2, 3, 4, 5);
+    assertEquals(15, sum);
+
+    sum = (int) sum6I().invokeExact(new Sums(), 1, 2, 3, 4, 5, 6);
+    assertEquals(21, sum);
+
+    sum = (int) sum7I().invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7);
+    assertEquals(28, sum);
+
+    sum = (int) sum8I().invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8);
+    assertEquals(36, sum);
+
+    sum = (int) sum9I().invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9);
+    assertEquals(45, sum);
+
+    sum = (int) sum10I().invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    assertEquals(55, sum);
+
+    long lsum = (long) sumIJ().invokeExact(new Sums(), 1, 2L);
+    assertEquals(3L, lsum);
+
+    lsum = (long) sum2IJ().invokeExact(new Sums(), 1, 2L, 3, 4L);
+    assertEquals(10L, lsum);
+
+    lsum = (long) sum3IJ().invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L);
+    assertEquals(21L, lsum);
+
+    lsum = (long) sum4IJ().invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L);
+    assertEquals(36L, lsum);
+
+    lsum = (long) sum5IJ().invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L, 9, 10L);
+    assertEquals(55L, lsum);
+  }
+
+  private void $noinline$interfaceChecks() throws Throwable {
+    FooBarImpl instance = new FooBarImpl();
+
+    String result = null;
+    result = (String) fooNonDefault().invokeExact((Foo) instance);
+    assertEquals("FooBarImpl.nonDefault", result);
+
+    result = (String) fooBarImplNonDefault().invokeExact(instance);
+    assertEquals("FooBarImpl.nonDefault", result);
+
+    result = (String) barDefault().invokeExact((Bar) instance);
+    assertEquals("Bar.defaultToOverride", result);
+
+    result = (String) fooDefault().invokeExact((Foo) instance);
+    assertEquals("Bar.defaultToOverride", result);
+
+    result = (String) fooBarImplDefault().invokeExact(instance);
+    assertEquals("Bar.defaultToOverride", result);
+
+    result = (String) fooNonOverriddenDefault().invokeExact((Foo) instance);
+    assertEquals("Foo.nonOverriddenDefault", result);
+
+    result = (String) barNonOverriddenDefault().invokeExact((Bar) instance);
+    assertEquals("Foo.nonOverriddenDefault", result);
+
+    ToStringable toStringable = new ToStringableImpl();
+    result = (String) toStringDefinedInAnInterface().invokeExact(toStringable);
+    assertEquals("ToStringableImpl", result);
+
+    try {
+      String ignored = (String) toStringDefinedInAnInterface().invokeExact(instance);
+      unreachable("Should throw WMTE");
+    } catch (WrongMethodTypeException expected) {}
+
+    Impl1 impl1 = new Impl1();
+
+    result = (String) interfaceOneMethod().invokeExact((Interface1) impl1);
+    assertEquals("Impl1.methodOne", result);
+
+    Impl2 impl2 = new Impl2();
+
+    result = (String) interfaceTwoMethod().invokeExact((Interface2) impl2);
+    assertEquals("Impl2.methodTwo", result);
+
+    result = (String) interfaceOneMethod().invokeExact((Interface1) impl2);
+    assertEquals("Impl2.methodOne", result);
+
+    Impl3 impl3 = new Impl3();
+
+    result = (String) interfaceThreeMethod().invokeExact((Interface3) impl3);
+    assertEquals("Impl3.methodThree", result);
+
+    result = (String) interfaceTwoMethod().invokeExact((Interface2) impl3);
+    assertEquals("Impl3.methodTwo", result);
+
+    result = (String) interfaceOneMethod().invokeExact((Interface1) impl3);
+    assertEquals("Impl3.methodOne", result);
+
+    Impl4 impl4 = new Impl4();
+
+    result = (String) interfaceFourMethod().invokeExact((Interface4) impl4);
+    assertEquals("Impl4.methodFour", result);
+
+    result = (String) interfaceThreeMethod().invokeExact((Interface3) impl4);
+    assertEquals("Impl4.methodThree", result);
+
+    result = (String) interfaceTwoMethod().invokeExact((Interface2) impl4);
+    assertEquals("Impl4.methodTwo", result);
+
+    result = (String) interfaceOneMethod().invokeExact((Interface1) impl4);
+    assertEquals("Impl4.methodOne", result);
+
+    FooAndFooConflictImpl conflictImpl = new FooAndFooConflictImpl();
+
+    result = (String) fooDefault().invokeExact((Foo) conflictImpl);
+    assertEquals("DefaultMethodConflictImpl.defaultToOverride", result);
+
+    FooAndFooConflict fooAndFooConflict = new FooAndFooConflict() {
+      public String nonDefault() {
+        throw new UnsupportedOperationException();
+      }
+    };
+
+    // TODO(b/297147201): The RI throws AbsractMethodError in these cases, just like plain
+    // fooAndFooConflict.defaultToOverride() call. So RI's invokeExact follows "equivalent of a
+    // particular bytecode behavior". ART throws ICCE in both cases, so current implementation of
+    // invokeExact does not break "equivalent ..." part of the javadoc.
+    // Need to check what the spec says about the error thrown when a conflicting default method is
+    // attempted to be called.
+    try {
+      String ignored = (String) fooAndFooConflictDefault().invokeExact(fooAndFooConflict);
+      unreachable("Non-overridden default conflict method");
+    } catch (IncompatibleClassChangeError expected) {}
+
+    try {
+      String ignored = (String) fooDefault().invokeExact((Foo) fooAndFooConflict);
+      unreachable("Non-overridden default conflict method");
+    } catch (IncompatibleClassChangeError expected) {}
+
+    BaseInterface baseClassImpl = new BaseClassImpl();
+    try {
+      String ignored = (String) baseInterface().invokeExact(baseClassImpl);
+      unreachable("Calling unimplemented interface method");
+    } catch (AbstractMethodError expected) {}
+  }
+
+  private void $noinline$abstractClass() throws Throwable {
+    FooBarImpl instance = new FooBarImpl();
+
+    String result = null;
+    result = (String) fooBarDefinedInAbstract().invokeExact((FooBar) instance);
+    assertEquals("FooBar.definedInAbstract", result);
+
+    result = (String) fooBarImplDefinedInAbstract().invokeExact(instance);
+    assertEquals("FooBar.definedInAbstract", result);
+
+    FooBar fooBar = new FooBar() {
+      @Override
+      public String nonDefault() {
+        return "anonymous.nonDefault";
+      }
+    };
+
+    result = (String) fooBarDefinedInAbstract().invokeExact(fooBar);
+    assertEquals("FooBar.definedInAbstract", result);
+
+    result = (String) fooBarNonDefault().invokeExact(fooBar);
+    assertEquals("anonymous.nonDefault", result);
+  }
+
+  static void assertEquals(Object expected, Object actual) {
+    if (!Objects.equals(expected, actual)) {
+      throw new AssertionError("Expected: " + expected + ", got: " + actual);
+    }
+  }
+
+  private static void assertEquals(int expected, int actual) {
+    if (expected != actual) {
+      throw new AssertionError("Expected: " + expected + ", got: " + actual);
+    }
+  }
+
+  private static void assertEquals(long expected, long actual) {
+    if (expected != actual) {
+      throw new AssertionError("Expected: " + expected + ", got: " + actual);
+    }
+  }
+
+  private static void assertEquals(double expected, double actual) {
+    if (expected != actual) {
+      throw new AssertionError("Expected: " + expected + ", got: " + actual);
+    }
+  }
+
+  static void unreachable(String msg) {
+    throw new AssertionError("Unexpectedly reached this point, but shouldn't: " + msg);
+  }
+
+  public abstract MethodHandle optionalGet();
+
+  public abstract MethodHandle voidMethod();
+  public abstract MethodHandle returnInt();
+  public abstract MethodHandle returnDouble();
+  public abstract MethodHandle interfaceDefaultMethod();
+  public abstract MethodHandle overwrittenInterfaceDefaultMethod();
+  public abstract MethodHandle exceptionThrowingMethod();
+  public abstract MethodHandle staticMethod();
+
+  public abstract MethodHandle sumI();
+  public abstract MethodHandle sum2I();
+  public abstract MethodHandle sum3I();
+  public abstract MethodHandle sum4I();
+  public abstract MethodHandle sum5I();
+  public abstract MethodHandle sum6I();
+  public abstract MethodHandle sum7I();
+  public abstract MethodHandle sum8I();
+  public abstract MethodHandle sum9I();
+  public abstract MethodHandle sum10I();
+  public abstract MethodHandle sumIJ();
+  public abstract MethodHandle sum2IJ();
+  public abstract MethodHandle sum3IJ();
+  public abstract MethodHandle sum4IJ();
+  public abstract MethodHandle sum5IJ();
+
+  public abstract MethodHandle fooNonDefault();
+  public abstract MethodHandle fooBarImplNonDefault();
+  public abstract MethodHandle barDefault();
+  public abstract MethodHandle fooDefault();
+  public abstract MethodHandle fooBarImplDefault();
+  public abstract MethodHandle fooNonOverriddenDefault();
+  public abstract MethodHandle barNonOverriddenDefault();
+  public abstract MethodHandle toStringDefinedInAnInterface();
+
+  public abstract MethodHandle interfaceOneMethod();
+  public abstract MethodHandle interfaceTwoMethod();
+  public abstract MethodHandle interfaceThreeMethod();
+  public abstract MethodHandle interfaceFourMethod();
+
+  public abstract MethodHandle fooBarDefinedInAbstract();
+  public abstract MethodHandle fooBarImplDefinedInAbstract();
+  public abstract MethodHandle fooBarNonDefault();
+  public abstract MethodHandle fooAndFooConflictDefault();
+  public abstract MethodHandle baseInterface();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/B.java b/test/2277-methodhandle-invokeexact/src/B.java
new file mode 100644
index 0000000000..f398f8ed8e
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/B.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class B {
+  private int privateReturnInt() {
+    return 9999;
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Bar.java b/test/2277-methodhandle-invokeexact/src/Bar.java
new file mode 100644
index 0000000000..b278cd8c52
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Bar.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+interface Bar extends Foo {
+  @Override
+  default String defaultToOverride() {
+    return "Bar.defaultToOverride";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/BaseClass.java b/test/2277-methodhandle-invokeexact/src/BaseClass.java
new file mode 100644
index 0000000000..03bdc16cd9
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/BaseClass.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public abstract class BaseClass implements BaseInterface {
+
+  /* src2/ implementation does not implement this method. */
+  @Override
+  public String method() {
+    return "BaseClass";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/BaseClassImpl.java b/test/2277-methodhandle-invokeexact/src/BaseClassImpl.java
new file mode 100644
index 0000000000..95577ae666
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/BaseClassImpl.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class BaseClassImpl extends BaseClass {}
diff --git a/test/2277-methodhandle-invokeexact/src/BaseInterface.java b/test/2277-methodhandle-invokeexact/src/BaseInterface.java
new file mode 100644
index 0000000000..556f23f674
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/BaseInterface.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface BaseInterface {
+  public String method();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/ConstMethodHandleTest.java b/test/2277-methodhandle-invokeexact/src/ConstMethodHandleTest.java
new file mode 100644
index 0000000000..57b9cb6c4d
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/ConstMethodHandleTest.java
@@ -0,0 +1,643 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import annotations.ConstantMethodHandle;
+
+import java.lang.invoke.MethodHandle;
+
+public class ConstMethodHandleTest extends AbstractInvokeExactTest {
+
+  @Override
+  void $noinline$privateMethods() throws Throwable {
+    // TODO(b/378051428): can't create const-method-handle targeting private methods of
+    // inner classes.
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "java/util/Optional",
+    fieldOrMethodName = "get",
+    descriptor = "()Ljava/lang/Object;")
+  private static MethodHandle constOptionalGet() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle optionalGet() {
+    return constOptionalGet();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "A",
+    fieldOrMethodName = "voidMethod",
+    descriptor = "()V")
+  private static MethodHandle constVoidMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle voidMethod() {
+    return constVoidMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "A",
+    fieldOrMethodName = "returnInt",
+    descriptor = "()I")
+  private static MethodHandle constReturnInt() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle returnInt() {
+    return constReturnInt();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "A",
+    fieldOrMethodName = "returnDouble",
+    descriptor = "()D")
+  private static MethodHandle constReturnDouble() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle returnDouble() {
+    return constReturnDouble();
+  }
+
+   @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "I",
+    fieldOrMethodName = "defaultMethod",
+    descriptor = "()V",
+    ownerIsInterface = true)
+  private static MethodHandle constInterfaceDefaultMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle interfaceDefaultMethod() {
+    return constInterfaceDefaultMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "I",
+    fieldOrMethodName = "overrideMe",
+    descriptor = "()V",
+    ownerIsInterface = true)
+  private static MethodHandle constOverwrittenInterfaceDefaultMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle overwrittenInterfaceDefaultMethod() {
+    return constOverwrittenInterfaceDefaultMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "A",
+    fieldOrMethodName = "throwException",
+    descriptor = "()V")
+  private static MethodHandle constExceptionThrowingMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle exceptionThrowingMethod() {
+    return constExceptionThrowingMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_STATIC,
+    owner = "A",
+    fieldOrMethodName = "staticMethod",
+    descriptor = "(LA;)Ljava/lang/String;")
+  private static MethodHandle constStaticMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle staticMethod() {
+    return constStaticMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(I)I")
+  private static MethodHandle constSumI() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sumI() {
+    return constSumI();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(II)I")
+  private static MethodHandle constSum2I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum2I() {
+    return constSum2I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(III)I")
+  private static MethodHandle constSum3I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum3I() {
+    return constSum3I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIII)I")
+  private static MethodHandle constSum4I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum4I() {
+    return constSum4I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIII)I")
+  private static MethodHandle constSum5I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum5I() {
+    return constSum5I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIIII)I")
+  private static MethodHandle constSum6I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum6I() {
+    return constSum6I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIIIII)I")
+  private static MethodHandle constSum7I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum7I() {
+    return constSum7I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIIIIII)I")
+  private static MethodHandle constSum8I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum8I() {
+    return constSum8I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIIIIIII)I")
+  private static MethodHandle constSum9I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum9I() {
+    return constSum9I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IIIIIIIIII)I")
+  private static MethodHandle constSum10I() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum10I() {
+    return constSum10I();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IJ)J")
+  private static MethodHandle constSumIJ() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sumIJ() {
+    return constSumIJ();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IJIJ)J")
+  private static MethodHandle constSum2IJ() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum2IJ() {
+    return constSum2IJ();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IJIJIJ)J")
+  private static MethodHandle constSum3IJ() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum3IJ() {
+    return constSum3IJ();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IJIJIJIJ)J")
+  private static MethodHandle constSum4IJ() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum4IJ() {
+    return constSum4IJ();
+  }
+
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "Sums",
+    fieldOrMethodName = "sum",
+    descriptor = "(IJIJIJIJIJ)J")
+  private static MethodHandle constSum5IJ() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle sum5IJ() {
+    return constSum5IJ();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Foo",
+    fieldOrMethodName = "nonDefault",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constFooNonDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooNonDefault() {
+    return constFooNonDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "FooBarImpl",
+    fieldOrMethodName = "nonDefault",
+    descriptor = "()Ljava/lang/String;")
+  private static MethodHandle constFooBarImplNonDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooBarImplNonDefault() {
+    return constFooBarImplNonDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Bar",
+    fieldOrMethodName = "defaultToOverride",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constBarDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle barDefault() {
+    return constBarDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Foo",
+    fieldOrMethodName = "defaultToOverride",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constFooDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooDefault() {
+    return constFooDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "FooBarImpl",
+    fieldOrMethodName = "defaultToOverride",
+    descriptor = "()Ljava/lang/String;")
+  private static MethodHandle constFooBarImplDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooBarImplDefault() {
+    return constFooBarImplDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Foo",
+    fieldOrMethodName = "nonOverriddenDefault",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constFooNonOverriddenDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooNonOverriddenDefault() {
+    return constFooNonOverriddenDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Bar",
+    fieldOrMethodName = "nonOverriddenDefault",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constBarNonOverriddenDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle barNonOverriddenDefault() {
+    return constBarNonOverriddenDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "FooBar",
+    fieldOrMethodName = "definedInAbstract",
+    descriptor = "()Ljava/lang/String;")
+  private static MethodHandle constFooBarDefinedInAbstract() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooBarDefinedInAbstract() {
+    return constFooBarDefinedInAbstract();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "FooBarImpl",
+    fieldOrMethodName = "definedInAbstract",
+    descriptor = "()Ljava/lang/String;")
+  private static MethodHandle constFooBarImplDefinedInAbstract() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooBarImplDefinedInAbstract() {
+    return constFooBarImplDefinedInAbstract();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+    owner = "FooBar",
+    fieldOrMethodName = "nonDefault",
+    descriptor = "()Ljava/lang/String;")
+  private static MethodHandle constFooBarNonDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooBarNonDefault() {
+    return constFooBarNonDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "ToStringable",
+    fieldOrMethodName = "toString",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constToStringDefinedInAnInterface() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle toStringDefinedInAnInterface() {
+    return constToStringDefinedInAnInterface();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Interface1",
+    fieldOrMethodName = "methodOne",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constInterfaceOneMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle interfaceOneMethod() {
+    return constInterfaceOneMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Interface2",
+    fieldOrMethodName = "methodTwo",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constInterfaceTwoMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle interfaceTwoMethod() {
+    return constInterfaceTwoMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Interface3",
+    fieldOrMethodName = "methodThree",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constInterfaceThreeMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle interfaceThreeMethod() {
+    return constInterfaceThreeMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "Interface4",
+    fieldOrMethodName = "methodFour",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constInterfaceFourMethod() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle interfaceFourMethod() {
+    return constInterfaceFourMethod();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "FooAndFooConflict",
+    fieldOrMethodName = "defaultToOverride",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constFooAndFooConflictDefault() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle fooAndFooConflictDefault() {
+    return constFooAndFooConflictDefault();
+  }
+
+  @ConstantMethodHandle(
+    kind = ConstantMethodHandle.INVOKE_INTERFACE,
+    owner = "BaseInterface",
+    fieldOrMethodName = "method",
+    descriptor = "()Ljava/lang/String;",
+    ownerIsInterface = true)
+  private static MethodHandle constBaseInterface() {
+    unreachable("should be replaced by const-method-handle");
+    return null;
+  }
+
+  @Override
+  public MethodHandle baseInterface() {
+    return constBaseInterface();
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Foo.java b/test/2277-methodhandle-invokeexact/src/Foo.java
new file mode 100644
index 0000000000..2a79b2175d
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Foo.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+interface Foo {
+  default String defaultToOverride() {
+    return "Foo.defaultToOverride";
+  }
+
+  default String nonOverriddenDefault() {
+    return "Foo.nonOverriddenDefault";
+  }
+
+  String nonDefault();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/FooAndFooConflict.java b/test/2277-methodhandle-invokeexact/src/FooAndFooConflict.java
new file mode 100644
index 0000000000..112d624c7b
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/FooAndFooConflict.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface FooAndFooConflict extends Foo, FooConflict {}
diff --git a/runtime/entrypoints/math_entrypoints.h b/test/2277-methodhandle-invokeexact/src/FooAndFooConflictImpl.java
similarity index 55%
rename from runtime/entrypoints/math_entrypoints.h
rename to test/2277-methodhandle-invokeexact/src/FooAndFooConflictImpl.java
index 717c7349bd..6c6a41a3ff 100644
--- a/runtime/entrypoints/math_entrypoints.h
+++ b/test/2277-methodhandle-invokeexact/src/FooAndFooConflictImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +14,16 @@
  * limitations under the License.
  */
 
-#ifndef ART_RUNTIME_ENTRYPOINTS_MATH_ENTRYPOINTS_H_
-#define ART_RUNTIME_ENTRYPOINTS_MATH_ENTRYPOINTS_H_
+public class FooAndFooConflictImpl implements Foo, FooConflict {
 
-#include <stdint.h>
+  @Override
+  public String defaultToOverride() {
+    return "DefaultMethodConflictImpl.defaultToOverride";
+  }
 
-extern "C" double art_l2d(int64_t l);
-extern "C" float art_l2f(int64_t l);
-extern "C" int64_t art_d2l(double d);
-extern "C" int32_t art_d2i(double d);
-extern "C" int64_t art_f2l(float f);
-extern "C" int32_t art_f2i(float f);
+  @Override
+  public String nonDefault() {
+    throw new UnsupportedOperationException();
+  }
 
-#endif  // ART_RUNTIME_ENTRYPOINTS_MATH_ENTRYPOINTS_H_
+}
diff --git a/test/2277-methodhandle-invokeexact/src/FooBar.java b/test/2277-methodhandle-invokeexact/src/FooBar.java
new file mode 100644
index 0000000000..46372e0f8e
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/FooBar.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+abstract class FooBar implements Foo, Bar {
+  public String definedInAbstract() {
+    return "FooBar.definedInAbstract";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/FooBarImpl.java b/test/2277-methodhandle-invokeexact/src/FooBarImpl.java
new file mode 100644
index 0000000000..19d9a0ae64
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/FooBarImpl.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class FooBarImpl extends FooBar {
+  @Override
+  public String nonDefault() {
+    return "FooBarImpl.nonDefault";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/FooConflict.java b/test/2277-methodhandle-invokeexact/src/FooConflict.java
new file mode 100644
index 0000000000..9318b484d6
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/FooConflict.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface FooConflict {
+  /* src2's implementation.
+  default String defaultToOverride() {
+    return "FooConflict.defaultToOverride";
+  }
+  */
+}
diff --git a/test/2277-methodhandle-invokeexact/src/I.java b/test/2277-methodhandle-invokeexact/src/I.java
new file mode 100644
index 0000000000..eeb41ce2a9
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/I.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface I {
+  public default void defaultMethod() {
+    AbstractInvokeExactTest.STATUS = "I.defaultMethod";
+  }
+
+  public default void overrideMe() {
+    throw new RuntimeException("should be overwritten");
+  }
+
+  private String innerPrivateMethod() {
+    return "boo";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Impl1.java b/test/2277-methodhandle-invokeexact/src/Impl1.java
new file mode 100644
index 0000000000..b9297e0f62
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Impl1.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Impl1 implements Interface1 {
+
+  @Override
+  public String methodOne() {
+    return "Impl1.methodOne";
+  }
+
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Impl2.java b/test/2277-methodhandle-invokeexact/src/Impl2.java
new file mode 100644
index 0000000000..05c5acddf6
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Impl2.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Impl2 implements Interface1, Interface2 {
+
+  @Override
+  public String methodOne() {
+    return "Impl2.methodOne";
+  }
+
+  @Override
+  public String methodTwo() {
+    return "Impl2.methodTwo";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Impl3.java b/test/2277-methodhandle-invokeexact/src/Impl3.java
new file mode 100644
index 0000000000..096c2ddcea
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Impl3.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Impl3 implements Interface1, Interface2, Interface3 {
+
+  @Override
+  public String methodThree() {
+    return "Impl3.methodThree";
+  }
+
+  @Override
+  public String methodTwo() {
+    return "Impl3.methodTwo";
+  }
+
+  @Override
+  public String methodOne() {
+    return "Impl3.methodOne";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Impl4.java b/test/2277-methodhandle-invokeexact/src/Impl4.java
new file mode 100644
index 0000000000..e433acf239
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Impl4.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Impl4 implements Interface1, Interface2, Interface3, Interface4 {
+
+  @Override
+  public String methodFour() {
+    return "Impl4.methodFour";
+  }
+
+  @Override
+  public String methodThree() {
+    return "Impl4.methodThree";
+  }
+
+  @Override
+  public String methodTwo() {
+    return "Impl4.methodTwo";
+  }
+
+  @Override
+  public String methodOne() {
+    return "Impl4.methodOne";
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Interface1.java b/test/2277-methodhandle-invokeexact/src/Interface1.java
new file mode 100644
index 0000000000..1d6c282e0d
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Interface1.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface Interface1 {
+  public String methodOne();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Interface2.java b/test/2277-methodhandle-invokeexact/src/Interface2.java
new file mode 100644
index 0000000000..fd4f25e281
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Interface2.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface Interface2 {
+  public String methodTwo();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Interface3.java b/test/2277-methodhandle-invokeexact/src/Interface3.java
new file mode 100644
index 0000000000..d67c35fb33
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Interface3.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface Interface3 {
+  public String methodThree();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Interface4.java b/test/2277-methodhandle-invokeexact/src/Interface4.java
new file mode 100644
index 0000000000..094bb7cce1
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Interface4.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface Interface4 {
+  public String methodFour();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/JavaApiTest.java b/test/2277-methodhandle-invokeexact/src/JavaApiTest.java
new file mode 100644
index 0000000000..88518eeaa9
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/JavaApiTest.java
@@ -0,0 +1,409 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import static java.lang.invoke.MethodType.methodType;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.util.Arrays;
+import java.util.Optional;
+
+public class JavaApiTest extends AbstractInvokeExactTest {
+
+  private static final MethodHandle OPTIONAL_GET;
+
+  private static final MethodHandle VOID_METHOD;
+  private static final MethodHandle RETURN_INT;
+  private static final MethodHandle RETURN_DOUBLE;
+  private static final MethodHandle PRIVATE_INTERFACE_METHOD;
+  private static final MethodHandle B_PRIVATE_RETURN_INT;
+  private static final MethodHandle A_PRIVATE_RETURN_INT;
+  private static final MethodHandle STATIC_METHOD;
+  private static final MethodHandle EXCEPTION_THROWING_METHOD;
+  private static final MethodHandle INTERFACE_DEFAULT_METHOD;
+  private static final MethodHandle OVERWRITTEN_INTERFACE_DEFAULT_METHOD;
+
+  private static final MethodHandle SUM_I;
+  private static final MethodHandle SUM_2I;
+  private static final MethodHandle SUM_3I;
+  private static final MethodHandle SUM_4I;
+  private static final MethodHandle SUM_5I;
+  private static final MethodHandle SUM_6I;
+  private static final MethodHandle SUM_7I;
+  private static final MethodHandle SUM_8I;
+  private static final MethodHandle SUM_9I;
+  private static final MethodHandle SUM_10I;
+
+  private static final MethodHandle SUM_IJ;
+  private static final MethodHandle SUM_2IJ;
+  private static final MethodHandle SUM_3IJ;
+  private static final MethodHandle SUM_4IJ;
+  private static final MethodHandle SUM_5IJ;
+
+  private static final MethodHandle FOO_NONDEFAULT;
+  private static final MethodHandle FOOBARIMPL_NONDEFAULT;
+  private static final MethodHandle FOO_DEFAULT;
+  private static final MethodHandle BAR_DEFAULT;
+  private static final MethodHandle FOOBAR_DEFINEDINABSTRACT;
+  private static final MethodHandle FOOBAR_NONDEFAULT;
+  private static final MethodHandle FOOBARIMPL_DEFINEDINABSTRACT;
+  private static final MethodHandle FOOBARIMPL_DEFAULT;
+  private static final MethodHandle FOO_NONOVERRIDDEN_DEFAULT;
+  private static final MethodHandle BAR_NONOVERRIDDEN_DEFAULT;
+  private static final MethodHandle TO_STRING_DEFINED_IN_AN_INTERFACE;
+
+  private static final MethodHandle INTERFACE_ONE_METHOD;
+  private static final MethodHandle INTERFACE_TWO_METHOD;
+  private static final MethodHandle INTERFACE_THREE_METHOD;
+  private static final MethodHandle INTERFACE_FOUR_METHOD;
+  private static final MethodHandle FOO_AND_FOO_CONFLICT_DEFAULT;
+  private static final MethodHandle BASE_INTERFACE;
+
+  static {
+    try {
+      OPTIONAL_GET = MethodHandles.lookup()
+          .findVirtual(Optional.class, "get", methodType(Object.class));
+
+      VOID_METHOD = MethodHandles.lookup()
+          .findVirtual(A.class, "voidMethod", methodType(void.class));
+      RETURN_DOUBLE = MethodHandles.lookup()
+          .findVirtual(A.class, "returnDouble", methodType(double.class));
+      RETURN_INT = MethodHandles.lookup()
+          .findVirtual(A.class, "returnInt", methodType(int.class));
+      PRIVATE_INTERFACE_METHOD = MethodHandles.privateLookupIn(I.class, MethodHandles.lookup())
+          .findVirtual(I.class, "innerPrivateMethod", methodType(String.class));
+      A_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(A.class, MethodHandles.lookup())
+          .findVirtual(A.class, "privateReturnInt", methodType(int.class));
+      B_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(B.class, MethodHandles.lookup())
+          .findVirtual(B.class, "privateReturnInt", methodType(int.class));
+      STATIC_METHOD = MethodHandles.lookup()
+          .findStatic(A.class, "staticMethod", methodType(String.class, A.class));
+      EXCEPTION_THROWING_METHOD = MethodHandles.lookup()
+          .findVirtual(A.class, "throwException", methodType(void.class));
+      INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
+          .findVirtual(I.class, "defaultMethod", methodType(void.class));
+      OVERWRITTEN_INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
+          .findVirtual(I.class, "overrideMe", methodType(void.class));
+
+      SUM_I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(1, int.class)));
+      SUM_2I = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(2, int.class)));
+      SUM_3I = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(3, int.class)));
+      SUM_4I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(4, int.class)));
+      SUM_5I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(5, int.class)));
+      SUM_6I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(6, int.class)));
+      SUM_7I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(7, int.class)));
+      SUM_8I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(8, int.class)));
+      SUM_9I  = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(9, int.class)));
+      SUM_10I = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(int.class, repeat(10, int.class)));
+
+      SUM_IJ = MethodHandles.lookup()
+          .findVirtual(Sums.class, "sum", methodType(long.class, int.class, long.class));
+      SUM_2IJ  = MethodHandles.lookup()
+          .findVirtual(Sums.class,
+                       "sum",
+                       methodType(long.class, repeat(2, int.class, long.class)));
+      SUM_3IJ = MethodHandles.lookup()
+          .findVirtual(Sums.class,
+                       "sum",
+                       methodType(long.class, repeat(3, int.class, long.class)));
+      SUM_4IJ = MethodHandles.lookup()
+          .findVirtual(Sums.class,
+                       "sum",
+                       methodType(long.class, repeat(4, int.class, long.class)));
+      SUM_5IJ = MethodHandles.lookup()
+          .findVirtual(Sums.class,
+                       "sum",
+                       methodType(long.class, repeat(5, int.class, long.class)));
+
+      FOO_NONDEFAULT = MethodHandles.lookup()
+          .findVirtual(Foo.class, "nonDefault", methodType(String.class));
+      FOOBARIMPL_NONDEFAULT = MethodHandles.lookup()
+          .findVirtual(FooBarImpl.class, "nonDefault", methodType(String.class));
+      FOO_DEFAULT = MethodHandles.lookup()
+          .findVirtual(Foo.class, "defaultToOverride", methodType(String.class));
+      BAR_DEFAULT = MethodHandles.lookup()
+          .findVirtual(Bar.class, "defaultToOverride", methodType(String.class));
+      FOOBAR_DEFINEDINABSTRACT = MethodHandles.lookup()
+          .findVirtual(FooBar.class, "definedInAbstract", methodType(String.class));
+      FOOBAR_NONDEFAULT = MethodHandles.lookup()
+          .findVirtual(FooBar.class, "nonDefault", methodType(String.class));
+      FOOBARIMPL_DEFINEDINABSTRACT = MethodHandles.lookup()
+          .findVirtual(FooBarImpl.class, "definedInAbstract", methodType(String.class));
+      FOOBARIMPL_DEFAULT = MethodHandles.lookup()
+          .findVirtual(FooBarImpl.class, "defaultToOverride", methodType(String.class));
+      FOO_NONOVERRIDDEN_DEFAULT = MethodHandles.lookup()
+          .findVirtual(Foo.class, "nonOverriddenDefault", methodType(String.class));
+      BAR_NONOVERRIDDEN_DEFAULT = MethodHandles.lookup()
+          .findVirtual(Bar.class, "nonOverriddenDefault", methodType(String.class));
+      TO_STRING_DEFINED_IN_AN_INTERFACE = MethodHandles.lookup()
+          .findVirtual(ToStringable.class, "toString", methodType(String.class));
+
+      INTERFACE_ONE_METHOD = MethodHandles.lookup()
+          .findVirtual(Interface1.class, "methodOne", methodType(String.class));
+      INTERFACE_TWO_METHOD = MethodHandles.lookup()
+          .findVirtual(Interface2.class, "methodTwo", methodType(String.class));
+      INTERFACE_THREE_METHOD = MethodHandles.lookup()
+          .findVirtual(Interface3.class, "methodThree", methodType(String.class));
+      INTERFACE_FOUR_METHOD = MethodHandles.lookup()
+          .findVirtual(Interface4.class, "methodFour", methodType(String.class));
+      FOO_AND_FOO_CONFLICT_DEFAULT = MethodHandles.lookup()
+          .findVirtual(FooAndFooConflict.class, "defaultToOverride", methodType(String.class));
+      BASE_INTERFACE = MethodHandles.lookup()
+          .findVirtual(BaseInterface.class, "method", methodType(String.class));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private static Class<?>[] repeat(int times, Class<?> clazz) {
+    Class<?>[] classes = new Class<?>[times];
+    Arrays.fill(classes, clazz);
+    return classes;
+  }
+
+  private static Class<?>[] repeat(int times, Class<?> first, Class<?> second) {
+    Class<?>[] classes = new Class<?>[times * 2];
+    for (int i = 0; i < 2 * times;) {
+      classes[i++] = first;
+      classes[i++] = second;
+    }
+    return classes;
+  }
+
+  @Override
+  void $noinline$privateMethods() throws Throwable {
+    assertEquals("boo", (String) PRIVATE_INTERFACE_METHOD.invokeExact((I) new A()));
+
+    int privateIntA = (int) A_PRIVATE_RETURN_INT.invokeExact(new A());
+    assertEquals(1042, privateIntA);
+
+    int privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact(new B());
+    assertEquals(9999, privateIntB);
+
+    privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact((B) new A());
+    assertEquals(9999, privateIntB);
+  }
+
+  @Override
+  public MethodHandle voidMethod() {
+    return VOID_METHOD;
+  }
+
+  @Override
+  public MethodHandle returnDouble() {
+    return RETURN_DOUBLE;
+  }
+
+  @Override
+  public MethodHandle returnInt() {
+    return RETURN_INT;
+  }
+
+  @Override
+  public MethodHandle interfaceDefaultMethod() {
+    return INTERFACE_DEFAULT_METHOD;
+  }
+
+  @Override
+  public MethodHandle overwrittenInterfaceDefaultMethod() {
+    return OVERWRITTEN_INTERFACE_DEFAULT_METHOD;
+  }
+
+  @Override
+  public MethodHandle exceptionThrowingMethod() {
+    return EXCEPTION_THROWING_METHOD;
+  }
+
+  @Override
+  public MethodHandle staticMethod() {
+    return STATIC_METHOD;
+  }
+
+  @Override
+  public MethodHandle sumI() {
+    return SUM_I;
+  }
+
+  @Override
+  public MethodHandle sum2I() {
+    return SUM_2I;
+  }
+
+  @Override
+  public MethodHandle sum3I() {
+    return SUM_3I;
+  }
+
+  @Override
+  public MethodHandle sum4I() {
+    return SUM_4I;
+  }
+
+  @Override
+  public MethodHandle sum5I() {
+    return SUM_5I;
+  }
+
+  @Override
+  public MethodHandle sum6I() {
+    return SUM_6I;
+  }
+
+  @Override
+  public MethodHandle sum7I() {
+    return SUM_7I;
+  }
+
+  @Override
+  public MethodHandle sum8I() {
+    return SUM_8I;
+  }
+
+  @Override
+  public MethodHandle sum9I() {
+    return SUM_9I;
+  }
+
+  @Override
+  public MethodHandle sum10I() {
+    return SUM_10I;
+  }
+
+  @Override
+  public MethodHandle sumIJ() {
+    return SUM_IJ;
+  }
+
+  @Override
+  public MethodHandle sum2IJ() {
+    return SUM_2IJ;
+  }
+
+  @Override
+  public MethodHandle sum3IJ() {
+    return SUM_3IJ;
+  }
+
+  @Override
+  public MethodHandle sum4IJ() {
+    return SUM_4IJ;
+  }
+
+  @Override
+  public MethodHandle sum5IJ() {
+    return SUM_5IJ;
+  }
+
+  @Override
+  public MethodHandle fooNonDefault() {
+    return FOO_NONDEFAULT;
+  }
+
+  @Override
+  public MethodHandle fooBarImplNonDefault() {
+    return FOOBARIMPL_NONDEFAULT;
+  }
+
+  @Override
+  public MethodHandle barDefault() {
+    return BAR_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle fooDefault() {
+    return FOO_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle fooBarImplDefault() {
+    return FOOBARIMPL_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle fooNonOverriddenDefault() {
+    return FOO_NONOVERRIDDEN_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle barNonOverriddenDefault() {
+    return BAR_NONOVERRIDDEN_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle fooBarDefinedInAbstract() {
+    return FOOBAR_DEFINEDINABSTRACT;
+  }
+
+  @Override
+  public MethodHandle fooBarImplDefinedInAbstract() {
+    return FOOBARIMPL_DEFINEDINABSTRACT;
+  }
+
+  @Override
+  public MethodHandle fooBarNonDefault() {
+    return FOOBAR_NONDEFAULT;
+  }
+
+  @Override
+  public MethodHandle toStringDefinedInAnInterface() {
+    return TO_STRING_DEFINED_IN_AN_INTERFACE;
+  }
+
+  @Override
+  public MethodHandle optionalGet() {
+    return OPTIONAL_GET;
+  }
+
+  @Override
+  public MethodHandle interfaceOneMethod() {
+    return INTERFACE_ONE_METHOD;
+  }
+
+  @Override
+  public MethodHandle interfaceTwoMethod() {
+    return INTERFACE_TWO_METHOD;
+  }
+
+  @Override
+  public MethodHandle interfaceThreeMethod() {
+    return INTERFACE_THREE_METHOD;
+  }
+
+  @Override
+  public MethodHandle interfaceFourMethod() {
+    return INTERFACE_FOUR_METHOD;
+  }
+
+  @Override
+  public MethodHandle fooAndFooConflictDefault() {
+    return FOO_AND_FOO_CONFLICT_DEFAULT;
+  }
+
+  @Override
+  public MethodHandle baseInterface() {
+    return BASE_INTERFACE;
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/Main.java b/test/2277-methodhandle-invokeexact/src/Main.java
index bb8c5fec01..5d4bfad519 100644
--- a/test/2277-methodhandle-invokeexact/src/Main.java
+++ b/test/2277-methodhandle-invokeexact/src/Main.java
@@ -14,413 +14,39 @@
  * limitations under the License.
  */
 
- import static java.lang.invoke.MethodType.methodType;
-
-import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.WrongMethodTypeException;
-import java.util.Arrays;
 import java.util.Objects;
 import java.util.Optional;
 
 public class Main {
 
-    private static String STATUS = "";
-
-    public static void main(String[] args) throws Throwable {
-      $noinline$testNoArgsCalls();
-      $noinline$testMethodHandleFromOtherDex();
-      Multi.$noinline$testMHFromMain(OPTIONAL_GET);
-      $noinline$testWithArgs();
-      $noinline$nullchecks();
-    }
-
-    private static void $noinline$nullchecks() throws Throwable {
-      try {
-        VOID_METHOD.invokeExact((A) null);
-        unreachable("Receiver is null, should throw NPE");
-      } catch (NullPointerException expected) {}
-
-      try {
-        VOID_METHOD.invokeExact((Main) null);
-        unreachable("Should throw WMTE: input is of wrong type");
-      } catch (WrongMethodTypeException expected) {}
-
-      try {
-        MethodHandle mh = null;
-        mh.invokeExact();
-        unreachable("MethodHandle object is null, should throw NPE");
-      } catch (NullPointerException expected) {}
-    }
-
-    private static void $noinline$testMethodHandleFromOtherDex() throws Throwable {
-      MethodHandle mh = Multi.$noinline$getMethodHandle();
-      Optional<String> nonEmpty = Optional.<String>of("hello");
-      Object returnedObject = mh.invokeExact(nonEmpty);
-      assertEquals("hello", returnedObject);
-
-      try {
-        mh.invokeExact(nonEmpty);
-        unreachable("mh.type() is (Optional)Object, but callsite is (Optional)V");
-      } catch (WrongMethodTypeException expected) {}
-    }
-
-    private static void $noinline$testNoArgsCalls() throws Throwable {
-      VOID_METHOD.invokeExact(new A());
-      assertEquals("A.voidMethod", STATUS);
-
-      int returnedInt = (int) RETURN_INT.invokeExact(new A());
-      assertEquals(42, returnedInt);
-
-      double returnedDouble = (double) RETURN_DOUBLE.invokeExact(new A());
-      assertEquals(42.0d, returnedDouble);
-
-      try {
-        INTERFACE_DEFAULT_METHOD.invokeExact(new A());
-        unreachable("MethodHandle's type is (Main$I)V, but callsite is (Main$A)V");
-      } catch (WrongMethodTypeException expected) {}
-
-      INTERFACE_DEFAULT_METHOD.invokeExact((I) new A());
-      assertEquals("I.defaultMethod", STATUS);
-
-      OVERWRITTEN_INTERFACE_DEFAULT_METHOD.invokeExact((I) new A());
-      assertEquals("A.overrideMe", STATUS);
-
-      assertEquals("boo", (String) PRIVATE_INTERFACE_METHOD.invokeExact((I) new A()));
-
-      int privateIntA = (int) A_PRIVATE_RETURN_INT.invokeExact(new A());
-      assertEquals(1042, privateIntA);
-
-      int privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact(new B());
-      assertEquals(9999, privateIntB);
-
-      privateIntB = (int) B_PRIVATE_RETURN_INT.invokeExact((B) new A());
-      assertEquals(9999, privateIntB);
-
-      try {
-        EXCEPTION_THROWING_METHOD.invokeExact(new A());
-        unreachable("Target method always throws");
-      } catch (MyRuntimeException expected) {
-        assertEquals("A.throwException", STATUS);
-      }
-
-      try {
-        RETURN_INT.invokeExact(new A());
-        unreachable("MethodHandle's type is (Main$A)I, but callsite type is (Main$A)V");
-      } catch (WrongMethodTypeException expected) {}
+  public static void main(String[] args) throws Throwable {
+    $noinline$testMethodHandleFromOtherDex();
 
-      String returnedString = (String) STATIC_METHOD.invokeExact(new A());
-      assertEquals("staticMethod", returnedString);
-    }
-
-    private static void $noinline$testWithArgs() throws Throwable {
-      int sum = (int) SUM_I.invokeExact(new Sums(), 1);
-      assertEquals(1, sum);
-
-      sum = (int) SUM_2I.invokeExact(new Sums(), 1, 2);
-      assertEquals(3, sum);
-
-      sum = (int) SUM_3I.invokeExact(new Sums(), 1, 2, 3);
-      assertEquals(6, sum);
-
-      sum = (int) SUM_4I.invokeExact(new Sums(), 1, 2, 3, 4);
-      assertEquals(10, sum);
-
-      sum = (int) SUM_5I.invokeExact(new Sums(), 1, 2, 3, 4, 5);
-      assertEquals(15, sum);
-
-      sum = (int) SUM_6I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6);
-      assertEquals(21, sum);
-
-      sum = (int) SUM_7I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7);
-      assertEquals(28, sum);
-
-      sum = (int) SUM_8I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8);
-      assertEquals(36, sum);
-
-      sum = (int) SUM_9I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9);
-      assertEquals(45, sum);
-
-      sum = (int) SUM_10I.invokeExact(new Sums(), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
-      assertEquals(55, sum);
+    new ConstMethodHandleTest().runAll();
+    new JavaApiTest().runAll();
+  }
 
-      long lsum = (long) SUM_IJ.invokeExact(new Sums(), 1, 2L);
-      assertEquals(3L, lsum);
+  private static void $noinline$testMethodHandleFromOtherDex() throws Throwable {
+    MethodHandle mh = Multi.$noinline$getMethodHandle();
+    Optional<String> nonEmpty = Optional.<String>of("hello");
+    Object returnedObject = mh.invokeExact(nonEmpty);
+    assertEquals("hello", returnedObject);
 
-      lsum = (long) SUM_2IJ.invokeExact(new Sums(), 1, 2L, 3, 4L);
-      assertEquals(10L, lsum);
+    try {
+      mh.invokeExact(nonEmpty);
+      unreachable("mh.type() is (Optional)Object, but callsite is (Optional)V");
+    } catch (WrongMethodTypeException expected) {}
+  }
 
-      lsum = (long) SUM_3IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L);
-      assertEquals(21L, lsum);
-
-      lsum = (long) SUM_4IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L);
-      assertEquals(36L, lsum);
-
-      lsum = (long) SUM_5IJ.invokeExact(new Sums(), 1, 2L, 3, 4L, 5, 6L, 7, 8L, 9, 10L);
-      assertEquals(55L, lsum);
-    }
-
-    private static void assertEquals(Object expected, Object actual) {
-      if (!Objects.equals(expected, actual)) {
-        throw new AssertionError("Expected: " + expected + ", got: " + actual);
-      }
-    }
-
-    private static void assertEquals(int expected, int actual) {
-      if (expected != actual) {
-        throw new AssertionError("Expected: " + expected + ", got: " + actual);
-      }
+  private static void assertEquals(Object expected, Object actual) {
+    if (!Objects.equals(expected, actual)) {
+      throw new AssertionError("Expected: " + expected + ", got: " + actual);
     }
+  }
 
-    private static void assertEquals(long expected, long actual) {
-      if (expected != actual) {
-        throw new AssertionError("Expected: " + expected + ", got: " + actual);
-      }
-    }
-
-    private static void assertEquals(double expected, double actual) {
-      if (expected != actual) {
-        throw new AssertionError("Expected: " + expected + ", got: " + actual);
-      }
-    }
-
-    private static void unreachable(String msg) {
-      throw new AssertionError("Unexpectedly reached this point, but shouldn't: " + msg);
-    }
-
-    private static final MethodHandle VOID_METHOD;
-    private static final MethodHandle RETURN_DOUBLE;
-    private static final MethodHandle RETURN_INT;
-    private static final MethodHandle PRIVATE_INTERFACE_METHOD;
-    private static final MethodHandle B_PRIVATE_RETURN_INT;
-    private static final MethodHandle A_PRIVATE_RETURN_INT;
-    private static final MethodHandle STATIC_METHOD;
-    private static final MethodHandle EXCEPTION_THROWING_METHOD;
-    private static final MethodHandle INTERFACE_DEFAULT_METHOD;
-    private static final MethodHandle OVERWRITTEN_INTERFACE_DEFAULT_METHOD;
-    private static final MethodHandle OPTIONAL_GET;
-
-    private static final MethodHandle SUM_I;
-    private static final MethodHandle SUM_2I;
-    private static final MethodHandle SUM_3I;
-    private static final MethodHandle SUM_4I;
-    private static final MethodHandle SUM_5I;
-    private static final MethodHandle SUM_6I;
-    private static final MethodHandle SUM_7I;
-    private static final MethodHandle SUM_8I;
-    private static final MethodHandle SUM_9I;
-    private static final MethodHandle SUM_10I;
-
-    private static final MethodHandle SUM_IJ;
-    private static final MethodHandle SUM_2IJ;
-    private static final MethodHandle SUM_3IJ;
-    private static final MethodHandle SUM_4IJ;
-    private static final MethodHandle SUM_5IJ;
-
-    static {
-      try {
-        VOID_METHOD = MethodHandles.lookup()
-            .findVirtual(A.class, "voidMethod", methodType(void.class));
-        RETURN_DOUBLE = MethodHandles.lookup()
-            .findVirtual(A.class, "returnDouble", methodType(double.class));
-        RETURN_INT = MethodHandles.lookup()
-            .findVirtual(A.class, "returnInt", methodType(int.class));
-        PRIVATE_INTERFACE_METHOD = MethodHandles.privateLookupIn(I.class, MethodHandles.lookup())
-            .findVirtual(I.class, "innerPrivateMethod", methodType(String.class));
-        A_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(A.class, MethodHandles.lookup())
-            .findVirtual(A.class, "privateReturnInt", methodType(int.class));
-        B_PRIVATE_RETURN_INT = MethodHandles.privateLookupIn(B.class, MethodHandles.lookup())
-            .findVirtual(B.class, "privateReturnInt", methodType(int.class));
-        STATIC_METHOD = MethodHandles.lookup()
-            .findStatic(A.class, "staticMethod", methodType(String.class, A.class));
-        EXCEPTION_THROWING_METHOD = MethodHandles.lookup()
-            .findVirtual(A.class, "throwException", methodType(void.class));
-        INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
-            .findVirtual(I.class, "defaultMethod", methodType(void.class));
-        OVERWRITTEN_INTERFACE_DEFAULT_METHOD = MethodHandles.lookup()
-            .findVirtual(I.class, "overrideMe", methodType(void.class));
-        OPTIONAL_GET = MethodHandles.lookup()
-            .findVirtual(Optional.class, "get", methodType(Object.class));
-
-        SUM_I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(1, int.class)));
-        SUM_2I = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(2, int.class)));
-        SUM_3I = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(3, int.class)));
-        SUM_4I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(4, int.class)));
-        SUM_5I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(5, int.class)));
-        SUM_6I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(6, int.class)));
-        SUM_7I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(7, int.class)));
-        SUM_8I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(8, int.class)));
-        SUM_9I  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(9, int.class)));
-        SUM_10I = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(int.class, repeat(10, int.class)));
-
-        SUM_IJ  = MethodHandles.lookup()
-            .findVirtual(Sums.class, "sum", methodType(long.class, int.class, long.class));
-        SUM_2IJ  = MethodHandles.lookup()
-            .findVirtual(Sums.class,
-                         "sum",
-                         methodType(long.class, repeat(2, int.class, long.class)));
-        SUM_3IJ  = MethodHandles.lookup()
-            .findVirtual(Sums.class,
-                         "sum",
-                         methodType(long.class, repeat(3, int.class, long.class)));
-        SUM_4IJ  = MethodHandles.lookup()
-            .findVirtual(Sums.class,
-                         "sum",
-                         methodType(long.class, repeat(4, int.class, long.class)));
-        SUM_5IJ  = MethodHandles.lookup()
-            .findVirtual(Sums.class,
-                         "sum",
-                         methodType(long.class, repeat(5, int.class, long.class)));
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static Class<?>[] repeat(int times, Class<?> clazz) {
-      Class<?>[] classes = new Class<?>[times];
-      Arrays.fill(classes, clazz);
-      return classes;
-    }
-
-    private static Class<?>[] repeat(int times, Class<?> first, Class<?> second) {
-      Class<?>[] classes = new Class<?>[times * 2];
-      for (int i = 0; i < 2 * times;) {
-        classes[i++] = first;
-        classes[i++] = second;
-      }
-      return classes;
-    }
-
-    static interface I {
-      public default void defaultMethod() {
-        STATUS = "I.defaultMethod";
-      }
-
-      public default void overrideMe() {
-        throw new RuntimeException("should be overwritten");
-      }
-
-      private String innerPrivateMethod() {
-        return "boo";
-      }
-    }
-
-    static class MyRuntimeException extends RuntimeException {}
-
-    static class A extends B implements I {
-        public int field;
-        public void voidMethod() {
-          STATUS = "A.voidMethod";
-        }
-
-        @Override
-        public void overrideMe() {
-          STATUS = "A.overrideMe";
-        }
-
-        public void throwException() {
-          STATUS = "A.throwException";
-          throw new MyRuntimeException();
-        }
-
-        public double returnDouble() {
-          return 42.0d;
-        }
-
-        public int returnInt() {
-          return 42;
-        }
-
-        private int privateReturnInt() {
-          return 1042;
-        }
-
-        public static String staticMethod(A a) {
-          return "staticMethod";
-        }
-
-        public static double staticMethod() {
-          return 41.0d;
-        }
-    }
-
-    static class B {
-      private int privateReturnInt() {
-        return 9999;
-      }
-    }
-
-    static class Sums {
-        public int sum(int a) {
-          return a;
-        }
-
-        public int sum(int a1, int a2) {
-          return a1 + a2;
-        }
-
-        public int sum(int a1, int a2, int a3) {
-          return a1 + a2 + a3;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4) {
-          return a1 + a2 + a3 + a4;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5) {
-          return a1 + a2 + a3 + a4 + a5;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5, int a6) {
-          return a1 + a2 + a3 + a4 + a5 + a6;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9;
-        }
-
-        public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9,
-                       int a10) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
-        }
-
-        public long sum(int a1, long a2) {
-          return a1 + a2;
-        }
-
-        public long sum(int a1, long a2, int a3, long a4) {
-          return a1 + a2 + a3 + a4;
-        }
-
-        public long sum(int a1, long a2, int a3, long a4, int a5, long a6) {
-          return a1 + a2 + a3 + a4 + a5 + a6;
-        }
-
-        public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
-        }
-
-        public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8, int a9,
-                        long a10) {
-          return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
-        }
-    }
+  private static void unreachable(String msg) {
+    throw new AssertionError("Unexpectedly reached this point, but shouldn't: " + msg);
+  }
 }
diff --git a/test/2277-methodhandle-invokeexact/src/MyRuntimeException.java b/test/2277-methodhandle-invokeexact/src/MyRuntimeException.java
new file mode 100644
index 0000000000..623843d4e6
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/MyRuntimeException.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class MyRuntimeException extends RuntimeException {}
diff --git a/test/2277-methodhandle-invokeexact/src/Sums.java b/test/2277-methodhandle-invokeexact/src/Sums.java
new file mode 100644
index 0000000000..cb5d852d9d
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/Sums.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+public class Sums {
+  public int sum(int a) {
+    return a;
+  }
+
+  public int sum(int a1, int a2) {
+    return a1 + a2;
+  }
+
+  public int sum(int a1, int a2, int a3) {
+    return a1 + a2 + a3;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4) {
+    return a1 + a2 + a3 + a4;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5) {
+    return a1 + a2 + a3 + a4 + a5;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5, int a6) {
+    return a1 + a2 + a3 + a4 + a5 + a6;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9;
+  }
+
+  public int sum(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9,
+                 int a10) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
+  }
+
+  public long sum(int a1, long a2) {
+    return a1 + a2;
+  }
+
+  public long sum(int a1, long a2, int a3, long a4) {
+    return a1 + a2 + a3 + a4;
+  }
+
+  public long sum(int a1, long a2, int a3, long a4, int a5, long a6) {
+    return a1 + a2 + a3 + a4 + a5 + a6;
+  }
+
+  public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
+  }
+
+  public long sum(int a1, long a2, int a3, long a4, int a5, long a6, int a7, long a8, int a9,
+                  long a10) {
+    return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10;
+  }
+}
diff --git a/test/2277-methodhandle-invokeexact/src/ToStringable.java b/test/2277-methodhandle-invokeexact/src/ToStringable.java
new file mode 100644
index 0000000000..5fb466ec8e
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/ToStringable.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface ToStringable {
+    public String toString();
+}
diff --git a/test/2277-methodhandle-invokeexact/src/ToStringableImpl.java b/test/2277-methodhandle-invokeexact/src/ToStringableImpl.java
new file mode 100644
index 0000000000..471b4c465c
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src/ToStringableImpl.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class ToStringableImpl implements ToStringable {
+    @Override
+    public String toString() {
+        return "ToStringableImpl";
+    }
+}
diff --git a/test/2277-methodhandle-invokeexact/src2/BaseClass.java b/test/2277-methodhandle-invokeexact/src2/BaseClass.java
new file mode 100644
index 0000000000..9faab594e5
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src2/BaseClass.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public abstract class BaseClass implements BaseInterface {
+
+  /* Original implementation from src/.
+  @Override
+  public String method() {
+    return "BaseClass";
+  }
+  */
+}
diff --git a/test/2277-methodhandle-invokeexact/src2/FooConflict.java b/test/2277-methodhandle-invokeexact/src2/FooConflict.java
new file mode 100644
index 0000000000..8e0c793263
--- /dev/null
+++ b/test/2277-methodhandle-invokeexact/src2/FooConflict.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface FooConflict {
+  default String defaultToOverride() {
+    return "FooConflict.defaultToOverride";
+  }
+}
diff --git a/test/2278-nested-loops/Android.bp b/test/2278-nested-loops/Android.bp
index 99120fe4fe..b072d73caf 100644
--- a/test/2278-nested-loops/Android.bp
+++ b/test/2278-nested-loops/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2278-nested-loops-expected-stdout",
         ":art-run-test-2278-nested-loops-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2279-aconfig-flags/Android.bp b/test/2279-aconfig-flags/Android.bp
index 6b1fcb49ee..876b0f1f98 100644
--- a/test/2279-aconfig-flags/Android.bp
+++ b/test/2279-aconfig-flags/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2279-aconfig-flags-expected-stdout",
         ":art-run-test-2279-aconfig-flags-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2279-second-inner-loop-references-first/Android.bp b/test/2279-second-inner-loop-references-first/Android.bp
index c9ea73dcf2..2654f6b35c 100644
--- a/test/2279-second-inner-loop-references-first/Android.bp
+++ b/test/2279-second-inner-loop-references-first/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-2279-second-inner-loop-references-first-expected-stdout",
         ":art-run-test-2279-second-inner-loop-references-first-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/2280-const-method-handle-validation/build.py b/test/2280-const-method-handle-validation/build.py
new file mode 100644
index 0000000000..ae1a042d40
--- /dev/null
+++ b/test/2280-const-method-handle-validation/build.py
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def build(ctx):
+  ctx.bash("./generate-sources")
+  # Setting javac_source and javac_target for private interface methods.
+  ctx.default_build(api_level="const-method-type",
+                    javac_source_arg="17",
+                    javac_target_arg="17")
diff --git a/test/2280-const-method-handle-validation/expected-stderr.txt b/test/2280-const-method-handle-validation/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2280-const-method-handle-validation/expected-stdout.txt b/test/2280-const-method-handle-validation/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2280-const-method-handle-validation/generate-sources b/test/2280-const-method-handle-validation/generate-sources
new file mode 100755
index 0000000000..d74ca98a8c
--- /dev/null
+++ b/test/2280-const-method-handle-validation/generate-sources
@@ -0,0 +1,29 @@
+#!/bin/bash
+#
+# Copyright 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# make us exit on a failure
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Build the transformer to apply to compiled classes.
+mkdir classes
+${JAVAC:-javac} ${JAVAC_ARGS} -cp "${ASM_JAR}" -d classes $(find src-util -name '*.java')
+${SOONG_ZIP} --jar -o transformer.jar -C classes -D classes
+rm -rf classes
+
+# Add annotation src files to our compiler inputs.
+cp -r src-util/annotations src/
diff --git a/test/2280-const-method-handle-validation/info.txt b/test/2280-const-method-handle-validation/info.txt
new file mode 100644
index 0000000000..672ec07989
--- /dev/null
+++ b/test/2280-const-method-handle-validation/info.txt
@@ -0,0 +1,2 @@
+Ensures that MethodHandle objects correspoding to invalid const-method-type instructions are not
+created.
diff --git a/test/2280-const-method-handle-validation/javac_post.sh b/test/2280-const-method-handle-validation/javac_post.sh
new file mode 100755
index 0000000000..d0699d3cd7
--- /dev/null
+++ b/test/2280-const-method-handle-validation/javac_post.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -e
+
+export ASM_JAR="${ANDROID_BUILD_TOP}/prebuilts/misc/common/asm/asm-9.6.jar"
+
+# Move original classes to intermediate location.
+mv $1 $1-intermediate-classes
+mkdir $1
+
+# Transform intermediate classes.
+transformer_args="-cp ${ASM_JAR}:$PWD/transformer.jar transformer.ConstantTransformer"
+for class in $1-intermediate-classes/*.class ; do
+  transformed_class=$1/$(basename ${class})
+  ${JAVA:-java} ${transformer_args} ${class} ${transformed_class}
+done
+
diff --git a/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodHandle.java b/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodHandle.java
new file mode 100644
index 0000000000..ffc88b65fb
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodHandle.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodHandle constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodHandle {
+    /* Method handle kinds */
+    public static final int STATIC_PUT = 0;
+    public static final int STATIC_GET = 1;
+    public static final int INSTANCE_PUT = 2;
+    public static final int INSTANCE_GET = 3;
+    public static final int INVOKE_STATIC = 4;
+    public static final int INVOKE_VIRTUAL = 5;
+    public static final int INVOKE_SPECIAL = 6;
+    public static final int NEW_INVOKE_SPECIAL = 7;
+    public static final int INVOKE_INTERFACE = 8;
+
+    /** Kind of method handle. */
+    int kind();
+
+    /** Class name owning the field or method. */
+    String owner();
+
+    /** The field or method name addressed by the MethodHandle. */
+    String fieldOrMethodName();
+
+    /** Descriptor for the field (type) or method (method-type) */
+    String descriptor();
+
+    /** Whether the owner is an interface. */
+    boolean ownerIsInterface() default false;
+}
diff --git a/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodType.java b/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodType.java
new file mode 100644
index 0000000000..55b1536e6c
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src-util/annotations/ConstantMethodType.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package annotations;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This annotation can be set on method to specify that if this method
+ * is statically invoked then the invocation is replaced by a
+ * load-constant bytecode with the MethodType constant described by
+ * the annotation.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ConstantMethodType {
+    /** Return type of method() or field getter() */
+    Class<?> returnType() default void.class;
+
+    /** Types of parameters for method or field setter() */
+    Class<?>[] parameterTypes() default {};
+}
diff --git a/test/2280-const-method-handle-validation/src-util/transformer/ConstantTransformer.java b/test/2280-const-method-handle-validation/src-util/transformer/ConstantTransformer.java
new file mode 100644
index 0000000000..45e7b9ccdb
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src-util/transformer/ConstantTransformer.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package transformer;
+
+import annotations.ConstantMethodHandle;
+import annotations.ConstantMethodType;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+
+/**
+ * Class for transforming invoke static bytecodes into constant method handle loads and constant
+ * method type loads.
+ *
+ * <p>When a parameterless private static method returning a MethodHandle is defined and annotated
+ * with {@code ConstantMethodHandle}, this transformer will replace static invocations of the method
+ * with a load constant bytecode with a method handle in the constant pool.
+ *
+ * <p>Suppose a method is annotated as: <code>
+ *  @ConstantMethodHandle(
+ *      kind = ConstantMethodHandle.STATIC_GET,
+ *      owner = "java/lang/Math",
+ *      fieldOrMethodName = "E",
+ *      descriptor = "D"
+ *  )
+ *  private static MethodHandle getMathE() {
+ *      unreachable();
+ *      return null;
+ *  }
+ * </code> Then invocations of {@code getMathE} will be replaced by a load from the constant pool
+ * with the constant method handle described in the {@code ConstantMethodHandle} annotation.
+ *
+ * <p>Similarly, a parameterless private static method returning a {@code MethodType} and annotated
+ * with {@code ConstantMethodType}, will have invocations replaced by a load constant bytecode with
+ * a method type in the constant pool.
+ */
+class ConstantTransformer {
+    static class ConstantBuilder extends ClassVisitor {
+        private final Map<String, ConstantMethodHandle> constantMethodHandles;
+        private final Map<String, ConstantMethodType> constantMethodTypes;
+
+        ConstantBuilder(
+                int api,
+                ClassVisitor cv,
+                Map<String, ConstantMethodHandle> constantMethodHandles,
+                Map<String, ConstantMethodType> constantMethodTypes) {
+            super(api, cv);
+            this.constantMethodHandles = constantMethodHandles;
+            this.constantMethodTypes = constantMethodTypes;
+        }
+
+        @Override
+        public MethodVisitor visitMethod(
+                int access, String name, String desc, String signature, String[] exceptions) {
+            MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
+            return new MethodVisitor(this.api, mv) {
+                @Override
+                public void visitMethodInsn(
+                        int opcode, String owner, String name, String desc, boolean itf) {
+                    if (opcode == org.objectweb.asm.Opcodes.INVOKESTATIC) {
+                        ConstantMethodHandle constantMethodHandle = constantMethodHandles.get(name);
+                        if (constantMethodHandle != null) {
+                            insertConstantMethodHandle(constantMethodHandle);
+                            return;
+                        }
+                        ConstantMethodType constantMethodType = constantMethodTypes.get(name);
+                        if (constantMethodType != null) {
+                            insertConstantMethodType(constantMethodType);
+                            return;
+                        }
+                    }
+                    mv.visitMethodInsn(opcode, owner, name, desc, itf);
+                }
+
+                private Type buildMethodType(Class<?> returnType, Class<?>[] parameterTypes) {
+                    Type rType = Type.getType(returnType);
+                    Type[] pTypes = new Type[parameterTypes.length];
+                    for (int i = 0; i < pTypes.length; ++i) {
+                        pTypes[i] = Type.getType(parameterTypes[i]);
+                    }
+                    return Type.getMethodType(rType, pTypes);
+                }
+
+                private int getHandleTag(int kind) {
+                    switch (kind) {
+                        case ConstantMethodHandle.STATIC_PUT:
+                            return Opcodes.H_PUTSTATIC;
+                        case ConstantMethodHandle.STATIC_GET:
+                            return Opcodes.H_GETSTATIC;
+                        case ConstantMethodHandle.INSTANCE_PUT:
+                            return Opcodes.H_PUTFIELD;
+                        case ConstantMethodHandle.INSTANCE_GET:
+                            return Opcodes.H_GETFIELD;
+                        case ConstantMethodHandle.INVOKE_STATIC:
+                            return Opcodes.H_INVOKESTATIC;
+                        case ConstantMethodHandle.INVOKE_VIRTUAL:
+                            return Opcodes.H_INVOKEVIRTUAL;
+                        case ConstantMethodHandle.INVOKE_SPECIAL:
+                            return Opcodes.H_INVOKESPECIAL;
+                        case ConstantMethodHandle.NEW_INVOKE_SPECIAL:
+                            return Opcodes.H_NEWINVOKESPECIAL;
+                        case ConstantMethodHandle.INVOKE_INTERFACE:
+                            return Opcodes.H_INVOKEINTERFACE;
+                    }
+                    throw new Error("Unhandled kind " + kind);
+                }
+
+                private void insertConstantMethodHandle(ConstantMethodHandle constantMethodHandle) {
+                    Handle handle =
+                            new Handle(
+                                    getHandleTag(constantMethodHandle.kind()),
+                                    constantMethodHandle.owner(),
+                                    constantMethodHandle.fieldOrMethodName(),
+                                    constantMethodHandle.descriptor(),
+                                    constantMethodHandle.ownerIsInterface());
+                    mv.visitLdcInsn(handle);
+                }
+
+                private void insertConstantMethodType(ConstantMethodType constantMethodType) {
+                    Type methodType =
+                            buildMethodType(
+                                    constantMethodType.returnType(),
+                                    constantMethodType.parameterTypes());
+                    mv.visitLdcInsn(methodType);
+                }
+            };
+        }
+    }
+
+    private static void throwAnnotationError(
+            Method method, Class<?> annotationClass, String reason) {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Error in annotation ")
+                .append(annotationClass)
+                .append(" on method ")
+                .append(method)
+                .append(": ")
+                .append(reason);
+        throw new Error(sb.toString());
+    }
+
+    private static void checkMethodToBeReplaced(
+            Method method, Class<?> annotationClass, Class<?> returnType) {
+        final int PRIVATE_STATIC = Modifier.STATIC | Modifier.PRIVATE;
+        if ((method.getModifiers() & PRIVATE_STATIC) != PRIVATE_STATIC) {
+            throwAnnotationError(method, annotationClass, " method is not private and static");
+        }
+        if (method.getTypeParameters().length != 0) {
+            throwAnnotationError(method, annotationClass, " method expects parameters");
+        }
+        if (!method.getReturnType().equals(returnType)) {
+            throwAnnotationError(method, annotationClass, " wrong return type");
+        }
+    }
+
+    private static void transform(Path inputClassPath, Path outputClassPath) throws Throwable {
+        Path classLoadPath = inputClassPath.toAbsolutePath().getParent();
+        URLClassLoader classLoader =
+                new URLClassLoader(new URL[] {classLoadPath.toUri().toURL()},
+                                   ClassLoader.getSystemClassLoader());
+        String inputClassName = inputClassPath.getFileName().toString().replace(".class", "");
+        Class<?> inputClass = classLoader.loadClass(inputClassName);
+
+        final Map<String, ConstantMethodHandle> constantMethodHandles = new HashMap<>();
+        final Map<String, ConstantMethodType> constantMethodTypes = new HashMap<>();
+
+        for (Method m : inputClass.getDeclaredMethods()) {
+            ConstantMethodHandle constantMethodHandle = m.getAnnotation(ConstantMethodHandle.class);
+            if (constantMethodHandle != null) {
+                checkMethodToBeReplaced(m, ConstantMethodHandle.class, MethodHandle.class);
+                constantMethodHandles.put(m.getName(), constantMethodHandle);
+                continue;
+            }
+
+            ConstantMethodType constantMethodType = m.getAnnotation(ConstantMethodType.class);
+            if (constantMethodType != null) {
+                checkMethodToBeReplaced(m, ConstantMethodType.class, MethodType.class);
+                constantMethodTypes.put(m.getName(), constantMethodType);
+                continue;
+            }
+        }
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
+        try (InputStream is = Files.newInputStream(inputClassPath)) {
+            ClassReader cr = new ClassReader(is);
+            ConstantBuilder cb =
+                    new ConstantBuilder(
+                            Opcodes.ASM7, cw, constantMethodHandles, constantMethodTypes);
+            cr.accept(cb, 0);
+        }
+        try (OutputStream os = Files.newOutputStream(outputClassPath)) {
+            os.write(cw.toByteArray());
+        }
+    }
+
+    public static void main(String[] args) throws Throwable {
+        transform(Paths.get(args[0]), Paths.get(args[1]));
+    }
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeConstructor.java b/test/2280-const-method-handle-validation/src/InvokeConstructor.java
new file mode 100644
index 0000000000..4ca22b8e0c
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeConstructor.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class InvokeConstructor {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    public static void runTests() {
+        try {
+            InvokeConstructorForInstanceMethod.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeConstructorForClassInitializer.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeConstructorForStaticMethod.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+    }
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeConstructorForClassInitializer.java b/test/2280-const-method-handle-validation/src/InvokeConstructorForClassInitializer.java
new file mode 100644
index 0000000000..d326e484a5
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeConstructorForClassInitializer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeConstructorForClassInitializer {
+
+    private static int STATIC_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.NEW_INVOKE_SPECIAL,
+        owner = "InvokeConstructorForClassInitializer",
+        fieldOrMethodName = "<clinit>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeConstructorForInstanceMethod.java b/test/2280-const-method-handle-validation/src/InvokeConstructorForInstanceMethod.java
new file mode 100644
index 0000000000..4b9536515a
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeConstructorForInstanceMethod.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeConstructorForInstanceMethod {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.NEW_INVOKE_SPECIAL,
+        owner = "java/lang/Object",
+        fieldOrMethodName = "hashCode",
+        descriptor = "()I")
+    private static MethodHandle forInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forInstanceMethod();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeConstructorForStaticMethod.java b/test/2280-const-method-handle-validation/src/InvokeConstructorForStaticMethod.java
new file mode 100644
index 0000000000..d447b7025e
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeConstructorForStaticMethod.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeConstructorForStaticMethod {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.NEW_INVOKE_SPECIAL,
+        owner = "InvokeConstructorForStaticMethod",
+        fieldOrMethodName = "unreachable",
+        descriptor = "()V")
+    private static MethodHandle forStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forStaticMethod();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInstance.java b/test/2280-const-method-handle-validation/src/InvokeInstance.java
new file mode 100644
index 0000000000..0c8ad69470
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInstance.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInstance {
+
+    private int instanceField;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "InvokeInstance",
+        fieldOrMethodName = "unreachable",
+        descriptor = "()V")
+    private static MethodHandle forStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "java/util/List",
+        fieldOrMethodName = "size",
+        descriptor = "()I")
+    private static MethodHandle forInterfaceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "Main",
+        fieldOrMethodName = "instanceMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessibleInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "Main",
+        fieldOrMethodName = "staticMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessibleStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forStaticMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forInterfaceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            InvokeInstanceForConstructor.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeInstanceForClassInitializer.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            inaccessibleInstanceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInstanceForClassInitializer.java b/test/2280-const-method-handle-validation/src/InvokeInstanceForClassInitializer.java
new file mode 100644
index 0000000000..e648ce037e
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInstanceForClassInitializer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInstanceForClassInitializer {
+
+    private static int STATIC_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "InvokeInstanceForClassInitializer",
+        fieldOrMethodName = "<clinit>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInstanceForConstructor.java b/test/2280-const-method-handle-validation/src/InvokeInstanceForConstructor.java
new file mode 100644
index 0000000000..8d662628e5
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInstanceForConstructor.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInstanceForConstructor {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_VIRTUAL,
+        owner = "InvokeInstanceForConstructor",
+        fieldOrMethodName = "<init>",
+        descriptor = "()V")
+    private static MethodHandle forConstructor() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forConstructor();
+    }
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInterface.java b/test/2280-const-method-handle-validation/src/InvokeInterface.java
new file mode 100644
index 0000000000..602eef3ce0
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInterface.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInterface {
+
+    private int instanceField;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "InvokeInterface",
+        fieldOrMethodName = "unreachable",
+        descriptor = "()V")
+    private static MethodHandle forStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "java/lang/Object",
+        fieldOrMethodName = "hashCode",
+        descriptor = "()I")
+    private static MethodHandle forInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "Main$I",
+        fieldOrMethodName = "privateMethod",
+        descriptor = "()V",
+        ownerIsInterface = true)
+    private static MethodHandle inaccessiblePrivateInterfaceMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            InvokeInterfaceForStaticMethod.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeInterfaceForInstanceMethod.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeInterfaceForConstructor.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeInterfaceForClassInitializer.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            inaccessiblePrivateInterfaceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInterfaceForClassInitializer.java b/test/2280-const-method-handle-validation/src/InvokeInterfaceForClassInitializer.java
new file mode 100644
index 0000000000..a837a7a066
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInterfaceForClassInitializer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInterfaceForClassInitializer {
+
+    private static int STATIC_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "InvokeInterfaceForClassInitializer",
+        fieldOrMethodName = "<clinit>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInterfaceForConstructor.java b/test/2280-const-method-handle-validation/src/InvokeInterfaceForConstructor.java
new file mode 100644
index 0000000000..0306f2831f
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInterfaceForConstructor.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInterfaceForConstructor {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "InvokeInterfaceForConstructor",
+        fieldOrMethodName = "<init>",
+        descriptor = "()V")
+    private static MethodHandle forConstructor() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forConstructor();
+    }
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInterfaceForInstanceMethod.java b/test/2280-const-method-handle-validation/src/InvokeInterfaceForInstanceMethod.java
new file mode 100644
index 0000000000..0a6ca3b73a
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInterfaceForInstanceMethod.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInterfaceForInstanceMethod {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "java/lang/Object",
+        fieldOrMethodName = "hashCode",
+        descriptor = "()I")
+    private static MethodHandle forInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forInstanceMethod();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeInterfaceForStaticMethod.java b/test/2280-const-method-handle-validation/src/InvokeInterfaceForStaticMethod.java
new file mode 100644
index 0000000000..1a66eb2909
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeInterfaceForStaticMethod.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeInterfaceForStaticMethod {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_INTERFACE,
+        owner = "InvokeInterfaceForStaticMethod",
+        fieldOrMethodName = "unreachable",
+        descriptor = "()V")
+    private static MethodHandle forStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forStaticMethod();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeSpecial.java b/test/2280-const-method-handle-validation/src/InvokeSpecial.java
new file mode 100644
index 0000000000..f861fc77cb
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeSpecial.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeSpecial {
+
+    private int instanceField;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    public void method() {}
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "InvokeSpecial",
+        fieldOrMethodName = "unreachable",
+        descriptor = "()V")
+    private static MethodHandle forStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "java/util/List",
+        fieldOrMethodName = "size",
+        descriptor = "()I")
+    private static MethodHandle forInterfaceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "Main",
+        fieldOrMethodName = "instanceMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessiblePrivateMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "Main",
+        fieldOrMethodName = "staticMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessibleStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forStaticMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        // TODO(b/297147201): runtime crashes here.
+        /*
+        try {
+            forInterfaceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+        */
+
+        // TODO(b/297147201): runtime does not throw exception here.
+        /*
+        try {
+            InvokeSpecialForConstructor.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+        */
+
+        try {
+            InvokeSpecialForClassInitializer.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            inaccessibleStaticMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeSpecialForClassInitializer.java b/test/2280-const-method-handle-validation/src/InvokeSpecialForClassInitializer.java
new file mode 100644
index 0000000000..9258b79593
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeSpecialForClassInitializer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeSpecialForClassInitializer {
+
+    private static int STATIC_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "InvokeSpecialForClassInitializer",
+        fieldOrMethodName = "<clinit>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeSpecialForConstructor.java b/test/2280-const-method-handle-validation/src/InvokeSpecialForConstructor.java
new file mode 100644
index 0000000000..c87509bf57
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeSpecialForConstructor.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeSpecialForConstructor {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_SPECIAL,
+        owner = "InvokeSpecialForConstructor",
+        fieldOrMethodName = "<init>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeStatic.java b/test/2280-const-method-handle-validation/src/InvokeStatic.java
new file mode 100644
index 0000000000..638630145b
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeStatic.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeStatic {
+    private int instanceField;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    public void method() {}
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "InvokeStatic",
+        fieldOrMethodName = "method",
+        descriptor = "()V")
+    private static MethodHandle forInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "java/util/List",
+        fieldOrMethodName = "size",
+        descriptor = "()I")
+    private static MethodHandle forInterfaceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "Main",
+        fieldOrMethodName = "instanceMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessibleInstanceMethod() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "Main",
+        fieldOrMethodName = "staticMethod",
+        descriptor = "()V")
+    private static MethodHandle inaccessibleStaticMethod() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forInstanceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forInterfaceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            InvokeStaticForConstructor.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            InvokeStaticForClassInitializer.runTests();
+            unreachable();
+        } catch (IncompatibleClassChangeError | ClassFormatError expected) {}
+
+        try {
+            inaccessibleInstanceMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticMethod();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeStaticForClassInitializer.java b/test/2280-const-method-handle-validation/src/InvokeStaticForClassInitializer.java
new file mode 100644
index 0000000000..ebce0ee3d2
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeStaticForClassInitializer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeStaticForClassInitializer {
+
+    private static int STATIC_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "InvokeStaticForClassInitializer",
+        fieldOrMethodName = "<clinit>",
+        descriptor = "()V")
+    private static MethodHandle forClassInitializer() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forClassInitializer();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/InvokeStaticForConstructor.java b/test/2280-const-method-handle-validation/src/InvokeStaticForConstructor.java
new file mode 100644
index 0000000000..7ad189815a
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/InvokeStaticForConstructor.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class InvokeStaticForConstructor {
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INVOKE_STATIC,
+        owner = "InvokeStaticForConstructor",
+        fieldOrMethodName = "<init>",
+        descriptor = "()V")
+    private static MethodHandle forConstructor() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        forConstructor();
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/Main.java b/test/2280-const-method-handle-validation/src/Main.java
new file mode 100644
index 0000000000..21713ec5c4
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/Main.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+
+    private interface I {
+        public void method();
+
+        private void privateMethod() {}
+
+        default void defaultMethod() {}
+    }
+
+    private int privateField;
+    private static int PRIVATE_STATIC_FIELD;
+
+    private void instanceMethod() {}
+    private static void staticMethod() {}
+
+    public static void main(String[] args) {
+        PlainGet.runTests();
+        PlainPut.runTests();
+        StaticGet.runTests();
+        StaticPut.runTests();
+
+        InvokeInstance.runTests();
+        InvokeStatic.runTests();
+        InvokeInterface.runTests();
+        InvokeSpecial.runTests();
+        InvokeConstructor.runTests();
+    }
+}
diff --git a/test/2280-const-method-handle-validation/src/PlainGet.java b/test/2280-const-method-handle-validation/src/PlainGet.java
new file mode 100644
index 0000000000..0b880e5744
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/PlainGet.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class PlainGet {
+
+    private static int STATIC_FIELD;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_GET,
+        owner = "PlainGet",
+        fieldOrMethodName = "STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle forStaticField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_GET,
+        owner = "Main",
+        fieldOrMethodName = "privateField",
+        descriptor = "I")
+    private static MethodHandle inaccessibleInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_GET,
+        owner = "Main",
+        fieldOrMethodName = "PRIVATE_STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle inaccessibleStaticField() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/PlainPut.java b/test/2280-const-method-handle-validation/src/PlainPut.java
new file mode 100644
index 0000000000..4c5d2833c0
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/PlainPut.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class PlainPut {
+
+    private final int finalField = 2;
+    private static int STATIC_FIELD;
+    private static final int STATIC_FINAL_FIELD = 1;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_PUT,
+        owner = "PlainGet",
+        fieldOrMethodName = "STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle forStaticField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_PUT,
+        owner = "PlainGet",
+        fieldOrMethodName = "finalField",
+        descriptor = "I")
+    private static MethodHandle forFinalField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_PUT,
+        owner = "PlainGet",
+        fieldOrMethodName = "STATIC_FINAL_FIELD",
+        descriptor = "I")
+    private static MethodHandle forStaticFinalField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_PUT,
+        owner = "Main",
+        fieldOrMethodName = "privateField",
+        descriptor = "I")
+    private static MethodHandle inaccessibleInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.INSTANCE_PUT,
+        owner = "Main",
+        fieldOrMethodName = "PRIVATE_STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle inaccessibleStaticField() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forFinalField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forStaticFinalField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/StaticGet.java b/test/2280-const-method-handle-validation/src/StaticGet.java
new file mode 100644
index 0000000000..8f42db91aa
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/StaticGet.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class StaticGet {
+
+    private int instanceField;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_GET,
+        owner = "StaticGet",
+        fieldOrMethodName = "instanceField",
+        descriptor = "I")
+    private static MethodHandle forInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_GET,
+        owner = "Main",
+        fieldOrMethodName = "privateField",
+        descriptor = "I")
+    private static MethodHandle inaccessibleInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_GET,
+        owner = "Main",
+        fieldOrMethodName = "PRIVATE_STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle inaccessibleStaticField() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2280-const-method-handle-validation/src/StaticPut.java b/test/2280-const-method-handle-validation/src/StaticPut.java
new file mode 100644
index 0000000000..ef57baabd4
--- /dev/null
+++ b/test/2280-const-method-handle-validation/src/StaticPut.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.invoke.MethodHandle;
+
+import annotations.ConstantMethodHandle;
+
+public class StaticPut {
+
+    private int instanceField;
+    private final int finalInstanceField = 1;
+    private static final int STATIC_FINAL_FIELD = 2;
+
+    private static void unreachable() {
+        throw new AssertionError("unreachable!");
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_PUT,
+        owner = "StaticPut",
+        fieldOrMethodName = "instanceField",
+        descriptor = "I")
+    private static MethodHandle forInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_PUT,
+        owner = "StaticPut",
+        fieldOrMethodName = "finalInstanceField",
+        descriptor = "I")
+    private static MethodHandle forFinalInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_PUT,
+        owner = "StaticPut",
+        fieldOrMethodName = "STATIC_FINAL_FIELD",
+        descriptor = "I")
+    private static MethodHandle forFinalStaticField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_PUT,
+        owner = "Main",
+        fieldOrMethodName = "privateField",
+        descriptor = "I")
+    private static MethodHandle inaccessibleInstanceField() {
+        unreachable();
+        return null;
+    }
+
+    @ConstantMethodHandle(
+        kind = ConstantMethodHandle.STATIC_PUT,
+        owner = "Main",
+        fieldOrMethodName = "PRIVATE_STATIC_FIELD",
+        descriptor = "I")
+    private static MethodHandle inaccessibleStaticField() {
+        unreachable();
+        return null;
+    }
+
+    public static void runTests() {
+        try {
+            forInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forFinalInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            forFinalStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleInstanceField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+
+        try {
+            inaccessibleStaticField();
+            unreachable();
+        } catch (IncompatibleClassChangeError expected) {}
+    }
+
+}
diff --git a/test/2282-checker-always-throws-try-catch/Android.bp b/test/2282-checker-always-throws-try-catch/Android.bp
new file mode 100644
index 0000000000..566d89b7d6
--- /dev/null
+++ b/test/2282-checker-always-throws-try-catch/Android.bp
@@ -0,0 +1,46 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2282-checker-always-throws-try-catch`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2282-checker-always-throws-try-catch",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2282-checker-always-throws-try-catch-expected-stdout",
+        ":art-run-test-2282-checker-always-throws-try-catch-expected-stderr",
+    ],
+    test_suites: [
+        "mts-art",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2282-checker-always-throws-try-catch-expected-stdout",
+    out: ["art-run-test-2282-checker-always-throws-try-catch-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2282-checker-always-throws-try-catch-expected-stderr",
+    out: ["art-run-test-2282-checker-always-throws-try-catch-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2282-checker-always-throws-try-catch/expected-stderr.txt b/test/2282-checker-always-throws-try-catch/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2282-checker-always-throws-try-catch/expected-stdout.txt b/test/2282-checker-always-throws-try-catch/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2282-checker-always-throws-try-catch/info.txt b/test/2282-checker-always-throws-try-catch/info.txt
new file mode 100644
index 0000000000..49168b8c0a
--- /dev/null
+++ b/test/2282-checker-always-throws-try-catch/info.txt
@@ -0,0 +1,2 @@
+Tests we don't mark an always throwing method with a try/catch. Otherwise,
+we might incorrectly mark other methods as "always throws" methods.
diff --git a/test/2282-checker-always-throws-try-catch/src/Main.java b/test/2282-checker-always-throws-try-catch/src/Main.java
new file mode 100644
index 0000000000..4c5357d592
--- /dev/null
+++ b/test/2282-checker-always-throws-try-catch/src/Main.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    public static void main(String[] args) {
+        $noinline$testAlwaysThrows();
+    }
+
+    // This never visibily throws as all throws are caught within the same method.
+    private static void alwaysThrowsInfiniteLoop() {
+        while (true) {
+            try {
+                throw new Error();
+            } catch (Error expected) {
+            }
+        }
+    }
+
+    private static void alwaysThrows() throws Exception {
+        try {
+            throw new Error();
+        } catch (Error expected) {
+            throw new Exception();
+        }
+    }
+
+    /// CHECK-START: void Main.$noinline$testAlwaysThrows() inliner (after)
+    /// CHECK: InvokeStaticOrDirect method_name:Main.alwaysThrows always_throws:false
+    private static void $noinline$testAlwaysThrows() {
+        try {
+            alwaysThrows();
+            System.out.println("alwaysThrows didn't throw");
+        } catch (Exception expected) {
+        }
+    }
+
+    // Don't call this method as it has an infinite loop
+
+    /// CHECK-START: void Main.$noinline$doNotCallInfiniteLoop() inliner (after)
+    /// CHECK: InvokeStaticOrDirect method_name:Main.alwaysThrowsInfiniteLoop always_throws:false
+    private static void $noinline$doNotCallInfiniteLoop() {
+        alwaysThrowsInfiniteLoop();
+    }
+}
diff --git a/test/2282-single-step-before-catch/Android.bp b/test/2282-single-step-before-catch/Android.bp
new file mode 100644
index 0000000000..c1a95371ca
--- /dev/null
+++ b/test/2282-single-step-before-catch/Android.bp
@@ -0,0 +1,40 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2282-single-step-before-catch`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2282-single-step-before-catch",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-no-test-suite-tag-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2282-single-step-before-catch-expected-stdout",
+        ":art-run-test-2282-single-step-before-catch-expected-stderr",
+    ],
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2282-single-step-before-catch-expected-stdout",
+    out: ["art-run-test-2282-single-step-before-catch-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2282-single-step-before-catch-expected-stderr",
+    out: ["art-run-test-2282-single-step-before-catch-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2282-single-step-before-catch/expected-stderr.txt b/test/2282-single-step-before-catch/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2282-single-step-before-catch/expected-stdout.txt b/test/2282-single-step-before-catch/expected-stdout.txt
new file mode 100644
index 0000000000..b801373cda
--- /dev/null
+++ b/test/2282-single-step-before-catch/expected-stdout.txt
@@ -0,0 +1,3 @@
+main: public static void art.Test2282.run() throws java.lang.Exception @ line = 75 caught class art.Test2282$TestException: Test
+Single step: public static void art.Test2282.run() throws java.lang.Exception @ line=77
+Caught TestException
diff --git a/test/2282-single-step-before-catch/info.txt b/test/2282-single-step-before-catch/info.txt
new file mode 100644
index 0000000000..ecd08f34af
--- /dev/null
+++ b/test/2282-single-step-before-catch/info.txt
@@ -0,0 +1 @@
+Tests that the DexPCMoveEvents are generated before exception catch events.
diff --git a/test/2282-single-step-before-catch/run.py b/test/2282-single-step-before-catch/run.py
new file mode 100755
index 0000000000..b87c0beb0e
--- /dev/null
+++ b/test/2282-single-step-before-catch/run.py
@@ -0,0 +1,17 @@
+# Copyright 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  ctx.default_run(args, jvmti=True)
diff --git a/test/2282-single-step-before-catch/src/Main.java b/test/2282-single-step-before-catch/src/Main.java
new file mode 100644
index 0000000000..d3f32944b4
--- /dev/null
+++ b/test/2282-single-step-before-catch/src/Main.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    public static void main(String[] args) throws Exception {
+        art.Test2282.run();
+    }
+}
diff --git a/test/2282-single-step-before-catch/src/art/Breakpoint.java b/test/2282-single-step-before-catch/src/art/Breakpoint.java
new file mode 120000
index 0000000000..3673916cc6
--- /dev/null
+++ b/test/2282-single-step-before-catch/src/art/Breakpoint.java
@@ -0,0 +1 @@
+../../../jvmti-common/Breakpoint.java
\ No newline at end of file
diff --git a/test/2282-single-step-before-catch/src/art/Exceptions.java b/test/2282-single-step-before-catch/src/art/Exceptions.java
new file mode 120000
index 0000000000..b8450fe7b6
--- /dev/null
+++ b/test/2282-single-step-before-catch/src/art/Exceptions.java
@@ -0,0 +1 @@
+../../../jvmti-common/Exceptions.java
\ No newline at end of file
diff --git a/test/2282-single-step-before-catch/src/art/Test2282.java b/test/2282-single-step-before-catch/src/art/Test2282.java
new file mode 100644
index 0000000000..9fbcdaa5fd
--- /dev/null
+++ b/test/2282-single-step-before-catch/src/art/Test2282.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package art;
+
+import java.lang.reflect.Executable;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+public class Test2282 {
+    static int LAST_LINE_NUMBER = -1;
+    static int CATCH_LINE_NUMBER = -1;
+    static Method TEST_METHOD;
+    static Method CATCH_HANDLER;
+    static Method SINGLE_STEP_HANDLER;
+
+    public static void notifySingleStep(Thread thr, Executable e, long loc) {
+        if (!e.equals(TEST_METHOD) || LAST_LINE_NUMBER != -1) {
+            // Ignore single stepping from methods like enableSingleStepping. We are only interested
+            // in the first line from the test method. So ignore others. This would make the test
+            // more robust if the implementation changes.
+            return;
+        }
+
+        int cur_line = Breakpoint.locationToLine(e, loc);
+        System.out.println("Single step: " + e + " @ line=" + cur_line);
+        LAST_LINE_NUMBER = cur_line;
+        if (LAST_LINE_NUMBER == CATCH_LINE_NUMBER) {
+            System.out.println("Single stepping was enabled in catch handler. We should not break "
+                               + "on catch line");
+        }
+    }
+
+    public static void ExceptionCatchHandler(
+            Thread thr, Executable method, long location, Throwable exception) {
+        CATCH_LINE_NUMBER = Breakpoint.locationToLine(method, location);
+        System.out.println(thr.getName() + ": " + method + " @ line = " + CATCH_LINE_NUMBER
+                + " caught " + exception.getClass() + ": " + exception.getMessage());
+        Exceptions.disableExceptionTracing(Thread.currentThread());
+        Trace.enableSingleStepTracing(Test2282.class, SINGLE_STEP_HANDLER, Thread.currentThread());
+    }
+
+    public static class TestException extends Error {
+        public TestException(String e) {
+            super(e);
+        }
+    }
+
+    public static void run() throws Exception {
+        CATCH_HANDLER = Test2282.class.getDeclaredMethod("ExceptionCatchHandler", Thread.class,
+                Executable.class, Long.TYPE, Throwable.class);
+        SINGLE_STEP_HANDLER = Test2282.class.getDeclaredMethod(
+                "notifySingleStep", Thread.class, Executable.class, Long.TYPE);
+        TEST_METHOD = Test2282.class.getDeclaredMethod("run");
+        // Enable exception catch event and setup a handler for the events.
+        Exceptions.setupExceptionTracing(Test2282.class, TestException.class,
+                /*ExceptionCaughtEventHandler=*/null, CATCH_HANDLER);
+        Exceptions.enableExceptionCatchEvent(Thread.currentThread());
+
+        try {
+            throw new TestException("Test");
+        } catch (TestException e) {
+            // Single step should stop here.
+            Trace.disableTracing(Thread.currentThread());
+            System.out.println("Caught TestException");
+        }
+    }
+}
diff --git a/test/2282-single-step-before-catch/src/art/Trace.java b/test/2282-single-step-before-catch/src/art/Trace.java
new file mode 120000
index 0000000000..5d9b44b463
--- /dev/null
+++ b/test/2282-single-step-before-catch/src/art/Trace.java
@@ -0,0 +1 @@
+../../../jvmti-common/Trace.java
\ No newline at end of file
diff --git a/test/2283-checker-remove-null-check/Android.bp b/test/2283-checker-remove-null-check/Android.bp
new file mode 100644
index 0000000000..4c0e6692ab
--- /dev/null
+++ b/test/2283-checker-remove-null-check/Android.bp
@@ -0,0 +1,46 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `2283-checker-remove-null-check`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-2283-checker-remove-null-check",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-2283-checker-remove-null-check-expected-stdout",
+        ":art-run-test-2283-checker-remove-null-check-expected-stderr",
+    ],
+    test_suites: [
+        "mts-art",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-2283-checker-remove-null-check-expected-stdout",
+    out: ["art-run-test-2283-checker-remove-null-check-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-2283-checker-remove-null-check-expected-stderr",
+    out: ["art-run-test-2283-checker-remove-null-check-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/2283-checker-remove-null-check/expected-stderr.txt b/test/2283-checker-remove-null-check/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2283-checker-remove-null-check/expected-stdout.txt b/test/2283-checker-remove-null-check/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2283-checker-remove-null-check/info.txt b/test/2283-checker-remove-null-check/info.txt
new file mode 100644
index 0000000000..909b15166c
--- /dev/null
+++ b/test/2283-checker-remove-null-check/info.txt
@@ -0,0 +1 @@
+Tests we remove null checks for known-not-null SSA variables after GVN
diff --git a/test/2283-checker-remove-null-check/src/Main.java b/test/2283-checker-remove-null-check/src/Main.java
new file mode 100644
index 0000000000..cbc7ed02d8
--- /dev/null
+++ b/test/2283-checker-remove-null-check/src/Main.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    public static void main(String[] args) {
+        $noinline$testReturnValueOrDefault();
+    }
+
+    private class InnerObject {
+        int value;
+    }
+
+    static InnerObject inner_obj;
+
+    // GVN removes the second `inner_obj` get.
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() GVN (before)
+    /// CHECK: StaticFieldGet field_name:Main.inner_obj
+    /// CHECK: StaticFieldGet field_name:Main.inner_obj
+
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() GVN (after)
+    /// CHECK:     StaticFieldGet field_name:Main.inner_obj
+    /// CHECK-NOT: StaticFieldGet field_name:Main.inner_obj
+
+    // Consistency check: No BoundTypes existed before.
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() reference_type_propagation$after_gvn (before)
+    /// CHECK-NOT: BoundType
+
+    // Consistency check: Only one null check.
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() reference_type_propagation$after_gvn (before)
+    /// CHECK:     NullCheck
+    /// CHECK-NOT: NullCheck
+
+    // RTP will add a BoundType between the `StaticFieldGet` and `NullCheck`.
+
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() reference_type_propagation$after_gvn (before)
+    /// CHECK: <<SFG:l\d+>> StaticFieldGet field_name:Main.inner_obj
+    /// CHECK:              NullCheck [<<SFG>>]
+
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() reference_type_propagation$after_gvn (after)
+    /// CHECK: <<SFG:l\d+>> StaticFieldGet field_name:Main.inner_obj
+    /// CHECK: <<BT:l\d+>>  BoundType [<<SFG>>]
+    /// CHECK:              NullCheck [<<BT>>]
+
+    // Finally, InstructionSimplifier can remove the NullCheck
+
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() instruction_simplifier$after_gvn (before)
+    /// CHECK:     NullCheck
+    /// CHECK-NOT: NullCheck
+
+    /// CHECK-START: int Main.$noinline$returnValueOrDefault() instruction_simplifier$after_gvn (after)
+    /// CHECK-NOT: NullCheck
+    static int $noinline$returnValueOrDefault() {
+        if (inner_obj != null) {
+            return inner_obj.value;
+        } else {
+            return -123;
+        }
+    }
+
+    static void $noinline$testReturnValueOrDefault() {
+        inner_obj = null;
+        $noinline$assertIntEquals(-123, $noinline$returnValueOrDefault());
+
+        Main m = new Main();
+        inner_obj = m.new InnerObject();
+        inner_obj.value = 0;
+        $noinline$assertIntEquals(0, $noinline$returnValueOrDefault());
+
+        inner_obj.value = 1000;
+        $noinline$assertIntEquals(1000, $noinline$returnValueOrDefault());
+    }
+
+    public static void $noinline$assertIntEquals(int expected, int result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+}
diff --git a/test/2284-regression-test-368984521-loop-opt/expected-stderr.txt b/test/2284-regression-test-368984521-loop-opt/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2284-regression-test-368984521-loop-opt/expected-stdout.txt b/test/2284-regression-test-368984521-loop-opt/expected-stdout.txt
new file mode 100644
index 0000000000..4a8e8afe9d
--- /dev/null
+++ b/test/2284-regression-test-368984521-loop-opt/expected-stdout.txt
@@ -0,0 +1,10 @@
+37105
+74210
+111315
+148420
+185525
+222630
+259735
+296840
+333945
+371050
diff --git a/test/2284-regression-test-368984521-loop-opt/info.txt b/test/2284-regression-test-368984521-loop-opt/info.txt
new file mode 100644
index 0000000000..44b31d2ef1
--- /dev/null
+++ b/test/2284-regression-test-368984521-loop-opt/info.txt
@@ -0,0 +1 @@
+Regression test for b/368984521 where we were mistakenly loop peeling a loop.
diff --git a/test/2284-regression-test-368984521-loop-opt/src/Main.java b/test/2284-regression-test-368984521-loop-opt/src/Main.java
new file mode 100644
index 0000000000..42c3fd3507
--- /dev/null
+++ b/test/2284-regression-test-368984521-loop-opt/src/Main.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class Main {
+    static int field;
+    static long checksum;
+
+    static void $noinline$testDoNotPeelLoop() {
+        int to_add_to_checksum = 112;
+        int[] iArr1 = new int[256];
+        try {
+            for (int i = 10; i < 187; i++) {
+                try {
+                    int i20 = field % iArr1[i];
+                } catch (ArithmeticException ae) {
+                }
+                // This loop won't be fully unrolled, since `to_add_to_checksum` is part of the
+                // outer catch phi.
+                // This part of the code can't throw and therefore we eliminate the TryBoundary
+                // instructions related to it. However, we still have the value used in the outer
+                // catch phi as we don't remove it from there. SuperblockCloner doesn't deal with
+                // blocks in a try/catch but this is not considered to be part of a try/catch and
+                // therefore it used to try to peel this loop, resulting in errors.
+                for (int j = 1; j < 2; j++) {
+                    to_add_to_checksum += 209;
+                    field -= field;
+                }
+            }
+        } catch (Throwable e) {
+        }
+        checksum += to_add_to_checksum;
+    }
+
+    public static void main(String[] strArr) {
+        for (int i = 0; i < 10; ++i) {
+            $noinline$testDoNotPeelLoop();
+            System.out.println(checksum);
+        }
+    }
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/expected-stderr.txt b/test/2285-var-and-methodhandles-staticfield-initialization/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/expected-stdout.txt b/test/2285-var-and-methodhandles-staticfield-initialization/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/info.txt b/test/2285-var-and-methodhandles-staticfield-initialization/info.txt
new file mode 100644
index 0000000000..df9ecac8da
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/info.txt
@@ -0,0 +1,2 @@
+Invocation of a VarHandle or a MethodHandle targeting a static field should trigger initialization
+of its declaring class.
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticGetter.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticGetter.java
new file mode 100644
index 0000000000..8aec79b4e6
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticGetter.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class MHStaticGetter {
+    public static int a = 10;
+    public static int b = a + 2;
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticMethod.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticMethod.java
new file mode 100644
index 0000000000..c4a2054e06
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticMethod.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class MHStaticMethod {
+    public static int a = 10;
+    public static int b = a + 2;
+
+    public static int getB() {
+        return b;
+    }
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticSetter.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticSetter.java
new file mode 100644
index 0000000000..d5594f4ae1
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/MHStaticSetter.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class MHStaticSetter {
+    public static int a = 10;
+    public static int b = a + 2;
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/Main.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/Main.java
new file mode 100644
index 0000000000..43257658cf
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/Main.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import static java.lang.invoke.MethodType.methodType;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+
+public class Main {
+
+    public static void main(String[] args) throws Throwable {
+        testMethodHandleStaticFieldGet();
+        testMethodHandleStaticFieldPut();
+        testMethodHandleStaticMethod();
+        testVarHandleStaticFieldGet();
+        testVarHandleStaticFieldPut();
+    }
+
+    private static void testMethodHandleStaticFieldGet() throws Throwable {
+        MethodHandle mh = MethodHandles.lookup()
+            .findStaticGetter(MHStaticGetter.class, "a", int.class);
+
+        int actual = (int) mh.invokeExact();
+
+        assertEquals(actual, 10);
+        assertEquals(MHStaticGetter.b, 12);
+    }
+
+
+    private static void testMethodHandleStaticFieldPut() throws Throwable {
+        MethodHandle mh = MethodHandles.lookup()
+            .findStaticSetter(MHStaticSetter.class, "a", int.class);
+
+        mh.invokeExact(100);
+
+        assertEquals(MHStaticSetter.a, 100);
+        assertEquals(MHStaticGetter.b, 12);
+    }
+
+    private static void testMethodHandleStaticMethod() throws Throwable {
+        MethodHandle mh = MethodHandles.lookup()
+            .findStatic(MHStaticMethod.class, "getB", methodType(int.class));
+
+        int actualB = (int) mh.invokeExact();
+
+        assertEquals(actualB, 12);
+        assertEquals(MHStaticMethod.a, 10);
+    }
+
+    private static void testVarHandleStaticFieldGet() throws Throwable {
+        VarHandle vh = MethodHandles.lookup()
+            .findStaticVarHandle(VHStaticGet.class, "a", int.class);
+
+        int actual = (int) vh.get();
+
+        assertEquals(actual, 10);
+        assertEquals(VHStaticGet.b, 12);
+    }
+
+    private static void testVarHandleStaticFieldPut() throws Throwable {
+        VarHandle vh = MethodHandles.lookup()
+            .findStaticVarHandle(VHStaticGet.class, "a", int.class);
+
+        vh.set(100);
+
+        assertEquals(VHStaticGet.a, 100);
+        assertEquals(VHStaticGet.b, 12);
+    }
+
+    private static void assertEquals(int actual, int expected) {
+        if (actual != expected) {
+            throw new AssertionError("Expected: " + expected + ", but got: " + actual);
+        }
+    }
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticGet.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticGet.java
new file mode 100644
index 0000000000..62ed256296
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticGet.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class VHStaticGet {
+    public static int a = 10;
+    public static int b = a + 2;
+}
diff --git a/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticPut.java b/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticPut.java
new file mode 100644
index 0000000000..4ba9e5ca75
--- /dev/null
+++ b/test/2285-var-and-methodhandles-staticfield-initialization/src/VHStaticPut.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class VHStaticPut {
+    public static int a = 10;
+    public static int b = a + 2;
+}
diff --git a/test/300-package-override/Android.bp b/test/300-package-override/Android.bp
index cbe94c420d..31c3aff7f5 100644
--- a/test/300-package-override/Android.bp
+++ b/test/300-package-override/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-300-package-override-expected-stdout",
         ":art-run-test-300-package-override-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/301-abstract-protected/Android.bp b/test/301-abstract-protected/Android.bp
index 02aae2d03c..ca370e5895 100644
--- a/test/301-abstract-protected/Android.bp
+++ b/test/301-abstract-protected/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-301-abstract-protected-expected-stdout",
         ":art-run-test-301-abstract-protected-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/302-float-conversion/Android.bp b/test/302-float-conversion/Android.bp
index ae5c76e0e4..db06307e71 100644
--- a/test/302-float-conversion/Android.bp
+++ b/test/302-float-conversion/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-302-float-conversion-expected-stdout",
         ":art-run-test-302-float-conversion-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/304-method-tracing/Android.bp b/test/304-method-tracing/Android.bp
index e6276031b8..9f6821d658 100644
--- a/test/304-method-tracing/Android.bp
+++ b/test/304-method-tracing/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-304-method-tracing-expected-stdout",
         ":art-run-test-304-method-tracing-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/401-optimizing-compiler/Android.bp b/test/401-optimizing-compiler/Android.bp
index 3335fca22d..145338ec96 100644
--- a/test/401-optimizing-compiler/Android.bp
+++ b/test/401-optimizing-compiler/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-401-optimizing-compiler-expected-stdout",
         ":art-run-test-401-optimizing-compiler-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/402-optimizing-control-flow/Android.bp b/test/402-optimizing-control-flow/Android.bp
index c2db8c6ebd..dc8423d1dd 100644
--- a/test/402-optimizing-control-flow/Android.bp
+++ b/test/402-optimizing-control-flow/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-402-optimizing-control-flow-expected-stdout",
         ":art-run-test-402-optimizing-control-flow-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/403-optimizing-long/Android.bp b/test/403-optimizing-long/Android.bp
index fda0fbbcc2..1215165e33 100644
--- a/test/403-optimizing-long/Android.bp
+++ b/test/403-optimizing-long/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-403-optimizing-long-expected-stdout",
         ":art-run-test-403-optimizing-long-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/404-optimizing-allocator/Android.bp b/test/404-optimizing-allocator/Android.bp
index 0cbef465d4..eb19765cac 100644
--- a/test/404-optimizing-allocator/Android.bp
+++ b/test/404-optimizing-allocator/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-404-optimizing-allocator-expected-stdout",
         ":art-run-test-404-optimizing-allocator-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/405-optimizing-long-allocator/Android.bp b/test/405-optimizing-long-allocator/Android.bp
index 50445c9cb4..5bc00526e1 100644
--- a/test/405-optimizing-long-allocator/Android.bp
+++ b/test/405-optimizing-long-allocator/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-405-optimizing-long-allocator-expected-stdout",
         ":art-run-test-405-optimizing-long-allocator-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/406-fields/Android.bp b/test/406-fields/Android.bp
index 8e6b3d1d4b..1f44b49bec 100644
--- a/test/406-fields/Android.bp
+++ b/test/406-fields/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-406-fields-expected-stdout",
         ":art-run-test-406-fields-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/407-arrays/Android.bp b/test/407-arrays/Android.bp
index 20be07d5ba..73d5705f93 100644
--- a/test/407-arrays/Android.bp
+++ b/test/407-arrays/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-407-arrays-expected-stdout",
         ":art-run-test-407-arrays-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/408-move-bug/Android.bp b/test/408-move-bug/Android.bp
index 828f5c7bd6..52a9e4665c 100644
--- a/test/408-move-bug/Android.bp
+++ b/test/408-move-bug/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-408-move-bug-expected-stdout",
         ":art-run-test-408-move-bug-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/409-materialized-condition/Android.bp b/test/409-materialized-condition/Android.bp
index 2aabaf2f45..4210240265 100644
--- a/test/409-materialized-condition/Android.bp
+++ b/test/409-materialized-condition/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-409-materialized-condition-expected-stdout",
         ":art-run-test-409-materialized-condition-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/410-floats/Android.bp b/test/410-floats/Android.bp
index 4fa1ad4382..2c5255905f 100644
--- a/test/410-floats/Android.bp
+++ b/test/410-floats/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-410-floats-expected-stdout",
         ":art-run-test-410-floats-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/411-checker-hdiv-hrem-const/Android.bp b/test/411-checker-hdiv-hrem-const/Android.bp
index 94cb1c884d..1fcebe1a2b 100644
--- a/test/411-checker-hdiv-hrem-const/Android.bp
+++ b/test/411-checker-hdiv-hrem-const/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-411-checker-hdiv-hrem-const-expected-stdout",
         ":art-run-test-411-checker-hdiv-hrem-const-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/411-checker-hdiv-hrem-pow2/Android.bp b/test/411-checker-hdiv-hrem-pow2/Android.bp
index 734a28fde6..0f41582b1d 100644
--- a/test/411-checker-hdiv-hrem-pow2/Android.bp
+++ b/test/411-checker-hdiv-hrem-pow2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-411-checker-hdiv-hrem-pow2-expected-stdout",
         ":art-run-test-411-checker-hdiv-hrem-pow2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/411-checker-instruct-simplifier-hrem/Android.bp b/test/411-checker-instruct-simplifier-hrem/Android.bp
index 2d2a221a00..08cf3b735d 100644
--- a/test/411-checker-instruct-simplifier-hrem/Android.bp
+++ b/test/411-checker-instruct-simplifier-hrem/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-411-checker-instruct-simplifier-hrem-expected-stdout",
         ":art-run-test-411-checker-instruct-simplifier-hrem-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/411-optimizing-arith/Android.bp b/test/411-optimizing-arith/Android.bp
index 1a9b2042f6..a8f4397a3c 100644
--- a/test/411-optimizing-arith/Android.bp
+++ b/test/411-optimizing-arith/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-411-optimizing-arith-expected-stdout",
         ":art-run-test-411-optimizing-arith-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/413-regalloc-regression/Android.bp b/test/413-regalloc-regression/Android.bp
index 6ff8d95a8c..16af8d5aad 100644
--- a/test/413-regalloc-regression/Android.bp
+++ b/test/413-regalloc-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-413-regalloc-regression-expected-stdout",
         ":art-run-test-413-regalloc-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/414-static-fields/Android.bp b/test/414-static-fields/Android.bp
index 7f105d443f..8ab19f793f 100644
--- a/test/414-static-fields/Android.bp
+++ b/test/414-static-fields/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-414-static-fields-expected-stdout",
         ":art-run-test-414-static-fields-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/418-const-string/Android.bp b/test/418-const-string/Android.bp
index 8a57f20fe9..70db7005ac 100644
--- a/test/418-const-string/Android.bp
+++ b/test/418-const-string/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-418-const-string-expected-stdout",
         ":art-run-test-418-const-string-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/419-long-parameter/Android.bp b/test/419-long-parameter/Android.bp
index 5e3c4176e7..cf1018cc5e 100644
--- a/test/419-long-parameter/Android.bp
+++ b/test/419-long-parameter/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-419-long-parameter-expected-stdout",
         ":art-run-test-419-long-parameter-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/420-const-class/Android.bp b/test/420-const-class/Android.bp
index 11cd5577b3..bffc12861a 100644
--- a/test/420-const-class/Android.bp
+++ b/test/420-const-class/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-420-const-class-expected-stdout",
         ":art-run-test-420-const-class-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/421-exceptions/Android.bp b/test/421-exceptions/Android.bp
index d1ee3419fc..e5a18957d9 100644
--- a/test/421-exceptions/Android.bp
+++ b/test/421-exceptions/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-421-exceptions-expected-stdout",
         ":art-run-test-421-exceptions-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/421-large-frame/Android.bp b/test/421-large-frame/Android.bp
index 68f12f8453..5d76f0f58c 100644
--- a/test/421-large-frame/Android.bp
+++ b/test/421-large-frame/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-421-large-frame-expected-stdout",
         ":art-run-test-421-large-frame-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/422-instanceof/Android.bp b/test/422-instanceof/Android.bp
index 983dbeea89..08c92f7d9d 100644
--- a/test/422-instanceof/Android.bp
+++ b/test/422-instanceof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-422-instanceof-expected-stdout",
         ":art-run-test-422-instanceof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/422-type-conversion/Android.bp b/test/422-type-conversion/Android.bp
index 737f06b8c8..7946cb1a53 100644
--- a/test/422-type-conversion/Android.bp
+++ b/test/422-type-conversion/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-422-type-conversion-expected-stdout",
         ":art-run-test-422-type-conversion-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/423-invoke-interface/Android.bp b/test/423-invoke-interface/Android.bp
index 49a131188a..b984f6c32a 100644
--- a/test/423-invoke-interface/Android.bp
+++ b/test/423-invoke-interface/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-423-invoke-interface-expected-stdout",
         ":art-run-test-423-invoke-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/424-checkcast/Android.bp b/test/424-checkcast/Android.bp
index 11684c3839..4d8cfbd383 100644
--- a/test/424-checkcast/Android.bp
+++ b/test/424-checkcast/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-424-checkcast-expected-stdout",
         ":art-run-test-424-checkcast-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/426-monitor/Android.bp b/test/426-monitor/Android.bp
index 7bea5da06b..40b6b83d12 100644
--- a/test/426-monitor/Android.bp
+++ b/test/426-monitor/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-426-monitor-expected-stdout",
         ":art-run-test-426-monitor-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/427-bitwise/Android.bp b/test/427-bitwise/Android.bp
index 858aaf5d51..94c28cc4f7 100644
--- a/test/427-bitwise/Android.bp
+++ b/test/427-bitwise/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-427-bitwise-expected-stdout",
         ":art-run-test-427-bitwise-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/427-bounds/Android.bp b/test/427-bounds/Android.bp
index 606c186284..2afa2b0f28 100644
--- a/test/427-bounds/Android.bp
+++ b/test/427-bounds/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-427-bounds-expected-stdout",
         ":art-run-test-427-bounds-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/429-ssa-builder/Android.bp b/test/429-ssa-builder/Android.bp
index 4e7b2634d2..27b26f05c3 100644
--- a/test/429-ssa-builder/Android.bp
+++ b/test/429-ssa-builder/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-429-ssa-builder-expected-stdout",
         ":art-run-test-429-ssa-builder-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/430-live-register-slow-path/Android.bp b/test/430-live-register-slow-path/Android.bp
index 0295e466b2..8093987e39 100644
--- a/test/430-live-register-slow-path/Android.bp
+++ b/test/430-live-register-slow-path/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-430-live-register-slow-path-expected-stdout",
         ":art-run-test-430-live-register-slow-path-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/433-gvn/Android.bp b/test/433-gvn/Android.bp
index e4f6b9a5b4..7a4f2d4637 100644
--- a/test/433-gvn/Android.bp
+++ b/test/433-gvn/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-433-gvn-expected-stdout",
         ":art-run-test-433-gvn-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/434-shifter-operand/Android.bp b/test/434-shifter-operand/Android.bp
index 4309d8aba2..36124aaa42 100644
--- a/test/434-shifter-operand/Android.bp
+++ b/test/434-shifter-operand/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-434-shifter-operand-expected-stdout",
         ":art-run-test-434-shifter-operand-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/435-try-finally-without-catch/Android.bp b/test/435-try-finally-without-catch/Android.bp
index d8c0409bbf..83d8314026 100644
--- a/test/435-try-finally-without-catch/Android.bp
+++ b/test/435-try-finally-without-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-435-try-finally-without-catch-expected-stdout",
         ":art-run-test-435-try-finally-without-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/436-rem-float/Android.bp b/test/436-rem-float/Android.bp
index 526f22f776..dc3cdc4b45 100644
--- a/test/436-rem-float/Android.bp
+++ b/test/436-rem-float/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-436-rem-float-expected-stdout",
         ":art-run-test-436-rem-float-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/436-shift-constant/Android.bp b/test/436-shift-constant/Android.bp
index 107e392799..97a2e1950f 100644
--- a/test/436-shift-constant/Android.bp
+++ b/test/436-shift-constant/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-436-shift-constant-expected-stdout",
         ":art-run-test-436-shift-constant-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/437-inline/Android.bp b/test/437-inline/Android.bp
index 7596d03585..e5688ef446 100644
--- a/test/437-inline/Android.bp
+++ b/test/437-inline/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-437-inline-expected-stdout",
         ":art-run-test-437-inline-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/438-volatile/Android.bp b/test/438-volatile/Android.bp
index adc4a80771..64879883cb 100644
--- a/test/438-volatile/Android.bp
+++ b/test/438-volatile/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-438-volatile-expected-stdout",
         ":art-run-test-438-volatile-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/439-npe/Android.bp b/test/439-npe/Android.bp
index 527b6cfc16..d47a8b779f 100644
--- a/test/439-npe/Android.bp
+++ b/test/439-npe/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-439-npe-expected-stdout",
         ":art-run-test-439-npe-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/439-swap-double/Android.bp b/test/439-swap-double/Android.bp
index f175231d28..8328aa366a 100644
--- a/test/439-swap-double/Android.bp
+++ b/test/439-swap-double/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-439-swap-double-expected-stdout",
         ":art-run-test-439-swap-double-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/440-stmp/Android.bp b/test/440-stmp/Android.bp
index 5ace2fc9aa..2534da6fe9 100644
--- a/test/440-stmp/Android.bp
+++ b/test/440-stmp/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-440-stmp-expected-stdout",
         ":art-run-test-440-stmp-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/441-checker-inliner/Android.bp b/test/441-checker-inliner/Android.bp
index f4eef68566..8c4a5de902 100644
--- a/test/441-checker-inliner/Android.bp
+++ b/test/441-checker-inliner/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-441-checker-inliner-expected-stdout",
         ":art-run-test-441-checker-inliner-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/443-not-bool-inline/Android.bp b/test/443-not-bool-inline/Android.bp
index 706c992220..bd20a9b28b 100644
--- a/test/443-not-bool-inline/Android.bp
+++ b/test/443-not-bool-inline/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-443-not-bool-inline-expected-stdout",
         ":art-run-test-443-not-bool-inline-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/444-checker-nce/Android.bp b/test/444-checker-nce/Android.bp
index de79050517..6cbe63e438 100644
--- a/test/444-checker-nce/Android.bp
+++ b/test/444-checker-nce/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-444-checker-nce-expected-stdout",
         ":art-run-test-444-checker-nce-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/445-checker-licm/Android.bp b/test/445-checker-licm/Android.bp
index 0932efb4bc..c38c9522b9 100644
--- a/test/445-checker-licm/Android.bp
+++ b/test/445-checker-licm/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-445-checker-licm-expected-stdout",
         ":art-run-test-445-checker-licm-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/446-checker-inliner2/Android.bp b/test/446-checker-inliner2/Android.bp
index 6f2e554274..adaabfaa39 100644
--- a/test/446-checker-inliner2/Android.bp
+++ b/test/446-checker-inliner2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-446-checker-inliner2-expected-stdout",
         ":art-run-test-446-checker-inliner2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/447-checker-inliner3/Android.bp b/test/447-checker-inliner3/Android.bp
index ee3b41b071..b2b7cf24df 100644
--- a/test/447-checker-inliner3/Android.bp
+++ b/test/447-checker-inliner3/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-447-checker-inliner3-expected-stdout",
         ":art-run-test-447-checker-inliner3-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/449-checker-bce-rem/Android.bp b/test/449-checker-bce-rem/Android.bp
index d6f10ee4e7..100dd689a8 100644
--- a/test/449-checker-bce-rem/Android.bp
+++ b/test/449-checker-bce-rem/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-449-checker-bce-rem-expected-stdout",
         ":art-run-test-449-checker-bce-rem-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/450-checker-types/Android.bp b/test/450-checker-types/Android.bp
index bf45226669..b20e6d1a98 100644
--- a/test/450-checker-types/Android.bp
+++ b/test/450-checker-types/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-450-checker-types-expected-stdout",
         ":art-run-test-450-checker-types-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/451-regression-add-float/Android.bp b/test/451-regression-add-float/Android.bp
index 26d7d0af40..a343561db8 100644
--- a/test/451-regression-add-float/Android.bp
+++ b/test/451-regression-add-float/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-451-regression-add-float-expected-stdout",
         ":art-run-test-451-regression-add-float-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/451-spill-splot/Android.bp b/test/451-spill-splot/Android.bp
index d7736738c5..2a21df7c87 100644
--- a/test/451-spill-splot/Android.bp
+++ b/test/451-spill-splot/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-451-spill-splot-expected-stdout",
         ":art-run-test-451-spill-splot-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/455-checker-gvn/Android.bp b/test/455-checker-gvn/Android.bp
index 2e366167c0..7c525e0213 100644
--- a/test/455-checker-gvn/Android.bp
+++ b/test/455-checker-gvn/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-455-checker-gvn-expected-stdout",
         ":art-run-test-455-checker-gvn-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/456-baseline-array-set/Android.bp b/test/456-baseline-array-set/Android.bp
index 28d83d010d..55246b4fc0 100644
--- a/test/456-baseline-array-set/Android.bp
+++ b/test/456-baseline-array-set/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-456-baseline-array-set-expected-stdout",
         ":art-run-test-456-baseline-array-set-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/458-checker-riscv64-shift-add/Android.bp b/test/458-checker-riscv64-shift-add/Android.bp
index aafc079d24..7ba43b16e3 100644
--- a/test/458-checker-riscv64-shift-add/Android.bp
+++ b/test/458-checker-riscv64-shift-add/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-458-checker-riscv64-shift-add-expected-stdout",
         ":art-run-test-458-checker-riscv64-shift-add-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/458-long-to-fpu/Android.bp b/test/458-long-to-fpu/Android.bp
index efd612ea11..ad493959d1 100644
--- a/test/458-long-to-fpu/Android.bp
+++ b/test/458-long-to-fpu/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-458-long-to-fpu-expected-stdout",
         ":art-run-test-458-long-to-fpu-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/464-checker-inline-sharpen-calls/Android.bp b/test/464-checker-inline-sharpen-calls/Android.bp
index aeff431925..2ed61f1261 100644
--- a/test/464-checker-inline-sharpen-calls/Android.bp
+++ b/test/464-checker-inline-sharpen-calls/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-464-checker-inline-sharpen-calls-expected-stdout",
         ":art-run-test-464-checker-inline-sharpen-calls-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/465-checker-clinit-gvn/Android.bp b/test/465-checker-clinit-gvn/Android.bp
index eef374c999..3e3ad0678a 100644
--- a/test/465-checker-clinit-gvn/Android.bp
+++ b/test/465-checker-clinit-gvn/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-465-checker-clinit-gvn-expected-stdout",
         ":art-run-test-465-checker-clinit-gvn-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/469-condition-materialization/Android.bp b/test/469-condition-materialization/Android.bp
index c9861412ac..1e46150833 100644
--- a/test/469-condition-materialization/Android.bp
+++ b/test/469-condition-materialization/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-469-condition-materialization-expected-stdout",
         ":art-run-test-469-condition-materialization-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/470-huge-method/Android.bp b/test/470-huge-method/Android.bp
index e5cabea43b..fd7d263eff 100644
--- a/test/470-huge-method/Android.bp
+++ b/test/470-huge-method/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-470-huge-method-expected-stdout",
         ":art-run-test-470-huge-method-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/471-deopt-environment/Android.bp b/test/471-deopt-environment/Android.bp
index d0eaca3523..139558a402 100644
--- a/test/471-deopt-environment/Android.bp
+++ b/test/471-deopt-environment/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-471-deopt-environment-expected-stdout",
         ":art-run-test-471-deopt-environment-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/472-type-propagation/Android.bp b/test/472-type-propagation/Android.bp
index 247e222439..bc7f054efb 100644
--- a/test/472-type-propagation/Android.bp
+++ b/test/472-type-propagation/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-472-type-propagation-expected-stdout",
         ":art-run-test-472-type-propagation-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/473-checker-inliner-constants/Android.bp b/test/473-checker-inliner-constants/Android.bp
index 4768c70d7e..d2b62938a4 100644
--- a/test/473-checker-inliner-constants/Android.bp
+++ b/test/473-checker-inliner-constants/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-473-checker-inliner-constants-expected-stdout",
         ":art-run-test-473-checker-inliner-constants-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/473-remove-dead-block/Android.bp b/test/473-remove-dead-block/Android.bp
index ea4145357f..2b5c678dd6 100644
--- a/test/473-remove-dead-block/Android.bp
+++ b/test/473-remove-dead-block/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-473-remove-dead-block-expected-stdout",
         ":art-run-test-473-remove-dead-block-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/474-checker-boolean-input/Android.bp b/test/474-checker-boolean-input/Android.bp
index 505d4c2b67..6ca6acf72d 100644
--- a/test/474-checker-boolean-input/Android.bp
+++ b/test/474-checker-boolean-input/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-474-checker-boolean-input-expected-stdout",
         ":art-run-test-474-checker-boolean-input-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/474-fp-sub-neg/Android.bp b/test/474-fp-sub-neg/Android.bp
index 2d61503be5..08e9ba2839 100644
--- a/test/474-fp-sub-neg/Android.bp
+++ b/test/474-fp-sub-neg/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-474-fp-sub-neg-expected-stdout",
         ":art-run-test-474-fp-sub-neg-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/475-simplify-mul-zero/Android.bp b/test/475-simplify-mul-zero/Android.bp
index 0e9dfd583d..a81b41b4e9 100644
--- a/test/475-simplify-mul-zero/Android.bp
+++ b/test/475-simplify-mul-zero/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-475-simplify-mul-zero-expected-stdout",
         ":art-run-test-475-simplify-mul-zero-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/476-checker-ctor-fence-redun-elim/Android.bp b/test/476-checker-ctor-fence-redun-elim/Android.bp
index dfbbb7a1e5..1a7d68a92b 100644
--- a/test/476-checker-ctor-fence-redun-elim/Android.bp
+++ b/test/476-checker-ctor-fence-redun-elim/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-476-checker-ctor-fence-redun-elim-expected-stdout",
         ":art-run-test-476-checker-ctor-fence-redun-elim-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/476-checker-ctor-memory-barrier/Android.bp b/test/476-checker-ctor-memory-barrier/Android.bp
index ec92628600..60f1eaa539 100644
--- a/test/476-checker-ctor-memory-barrier/Android.bp
+++ b/test/476-checker-ctor-memory-barrier/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-476-checker-ctor-memory-barrier-expected-stdout",
         ":art-run-test-476-checker-ctor-memory-barrier-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/476-clinit-inline-static-invoke/Android.bp b/test/476-clinit-inline-static-invoke/Android.bp
index c1fc1dcd30..dc850817c9 100644
--- a/test/476-clinit-inline-static-invoke/Android.bp
+++ b/test/476-clinit-inline-static-invoke/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-476-clinit-inline-static-invoke-expected-stdout",
         ":art-run-test-476-clinit-inline-static-invoke-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/477-checker-bound-type/Android.bp b/test/477-checker-bound-type/Android.bp
index 72bf2a692e..a16526db22 100644
--- a/test/477-checker-bound-type/Android.bp
+++ b/test/477-checker-bound-type/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-477-checker-bound-type-expected-stdout",
         ":art-run-test-477-checker-bound-type-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/477-long-2-float-convers-precision/Android.bp b/test/477-long-2-float-convers-precision/Android.bp
index baaf623b90..6454b0146d 100644
--- a/test/477-long-2-float-convers-precision/Android.bp
+++ b/test/477-long-2-float-convers-precision/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-477-long-2-float-convers-precision-expected-stdout",
         ":art-run-test-477-long-2-float-convers-precision-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/478-checker-clinit-check-pruning/Android.bp b/test/478-checker-clinit-check-pruning/Android.bp
index 78a41b9f75..3cc9ab1768 100644
--- a/test/478-checker-clinit-check-pruning/Android.bp
+++ b/test/478-checker-clinit-check-pruning/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-478-checker-clinit-check-pruning-expected-stdout",
         ":art-run-test-478-checker-clinit-check-pruning-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/478-checker-inline-noreturn/Android.bp b/test/478-checker-inline-noreturn/Android.bp
index a766f88c83..2f2c293353 100644
--- a/test/478-checker-inline-noreturn/Android.bp
+++ b/test/478-checker-inline-noreturn/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-478-checker-inline-noreturn-expected-stdout",
         ":art-run-test-478-checker-inline-noreturn-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/478-checker-inliner-nested-loop/Android.bp b/test/478-checker-inliner-nested-loop/Android.bp
index afdcc163b9..12116b1d05 100644
--- a/test/478-checker-inliner-nested-loop/Android.bp
+++ b/test/478-checker-inliner-nested-loop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-478-checker-inliner-nested-loop-expected-stdout",
         ":art-run-test-478-checker-inliner-nested-loop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/479-regression-implicit-null-check/Android.bp b/test/479-regression-implicit-null-check/Android.bp
index 25d8907720..0575f4ae87 100644
--- a/test/479-regression-implicit-null-check/Android.bp
+++ b/test/479-regression-implicit-null-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-479-regression-implicit-null-check-expected-stdout",
         ":art-run-test-479-regression-implicit-null-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/480-checker-dead-blocks/Android.bp b/test/480-checker-dead-blocks/Android.bp
index 706a723ac2..5b04b42cfe 100644
--- a/test/480-checker-dead-blocks/Android.bp
+++ b/test/480-checker-dead-blocks/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-480-checker-dead-blocks-expected-stdout",
         ":art-run-test-480-checker-dead-blocks-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/481-regression-phi-cond/Android.bp b/test/481-regression-phi-cond/Android.bp
index cf9e14a609..72ecb7316e 100644
--- a/test/481-regression-phi-cond/Android.bp
+++ b/test/481-regression-phi-cond/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-481-regression-phi-cond-expected-stdout",
         ":art-run-test-481-regression-phi-cond-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/482-checker-loop-back-edge-use/Android.bp b/test/482-checker-loop-back-edge-use/Android.bp
index 5c911bdd9c..ad6e0a08e9 100644
--- a/test/482-checker-loop-back-edge-use/Android.bp
+++ b/test/482-checker-loop-back-edge-use/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-482-checker-loop-back-edge-use-expected-stdout",
         ":art-run-test-482-checker-loop-back-edge-use-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/483-dce-block/Android.bp b/test/483-dce-block/Android.bp
index 52ec2af780..c7f507793b 100644
--- a/test/483-dce-block/Android.bp
+++ b/test/483-dce-block/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-483-dce-block-expected-stdout",
         ":art-run-test-483-dce-block-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/485-checker-dce-switch/Android.bp b/test/485-checker-dce-switch/Android.bp
index ea5646130a..2ea03649f9 100644
--- a/test/485-checker-dce-switch/Android.bp
+++ b/test/485-checker-dce-switch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-485-checker-dce-switch-expected-stdout",
         ":art-run-test-485-checker-dce-switch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/486-checker-must-do-null-check/Android.bp b/test/486-checker-must-do-null-check/Android.bp
index 5c07c39ec8..b99415bf4b 100644
--- a/test/486-checker-must-do-null-check/Android.bp
+++ b/test/486-checker-must-do-null-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-486-checker-must-do-null-check-expected-stdout",
         ":art-run-test-486-checker-must-do-null-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/487-checker-inline-calls/Android.bp b/test/487-checker-inline-calls/Android.bp
index 42d64f4687..390ceb5db6 100644
--- a/test/487-checker-inline-calls/Android.bp
+++ b/test/487-checker-inline-calls/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-487-checker-inline-calls-expected-stdout",
         ":art-run-test-487-checker-inline-calls-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/488-checker-inline-recursive-calls/Android.bp b/test/488-checker-inline-recursive-calls/Android.bp
index 9a171adead..8de1568796 100644
--- a/test/488-checker-inline-recursive-calls/Android.bp
+++ b/test/488-checker-inline-recursive-calls/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-488-checker-inline-recursive-calls-expected-stdout",
         ":art-run-test-488-checker-inline-recursive-calls-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/489-current-method-regression/Android.bp b/test/489-current-method-regression/Android.bp
index 27aae46adf..8af9eb716c 100644
--- a/test/489-current-method-regression/Android.bp
+++ b/test/489-current-method-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-489-current-method-regression-expected-stdout",
         ":art-run-test-489-current-method-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/490-checker-inline/Android.bp b/test/490-checker-inline/Android.bp
index 70ca37f305..4bb3265dc0 100644
--- a/test/490-checker-inline/Android.bp
+++ b/test/490-checker-inline/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-490-checker-inline-expected-stdout",
         ":art-run-test-490-checker-inline-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/491-current-method/Android.bp b/test/491-current-method/Android.bp
index af93f4bb70..9617440c69 100644
--- a/test/491-current-method/Android.bp
+++ b/test/491-current-method/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-491-current-method-expected-stdout",
         ":art-run-test-491-current-method-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/492-checker-inline-invoke-interface/Android.bp b/test/492-checker-inline-invoke-interface/Android.bp
index 06eecee8f9..b9c5ba545e 100644
--- a/test/492-checker-inline-invoke-interface/Android.bp
+++ b/test/492-checker-inline-invoke-interface/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-492-checker-inline-invoke-interface-expected-stdout",
         ":art-run-test-492-checker-inline-invoke-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/493-checker-inline-invoke-interface/Android.bp b/test/493-checker-inline-invoke-interface/Android.bp
index 4b981bf79a..a86a3b5d72 100644
--- a/test/493-checker-inline-invoke-interface/Android.bp
+++ b/test/493-checker-inline-invoke-interface/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-493-checker-inline-invoke-interface-expected-stdout",
         ":art-run-test-493-checker-inline-invoke-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/494-checker-instanceof-tests/Android.bp b/test/494-checker-instanceof-tests/Android.bp
index cd9c4c713e..99da9df524 100644
--- a/test/494-checker-instanceof-tests/Android.bp
+++ b/test/494-checker-instanceof-tests/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-494-checker-instanceof-tests-expected-stdout",
         ":art-run-test-494-checker-instanceof-tests-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/495-checker-checkcast-tests/Android.bp b/test/495-checker-checkcast-tests/Android.bp
index 019a6fdeb1..2a4614c5dd 100644
--- a/test/495-checker-checkcast-tests/Android.bp
+++ b/test/495-checker-checkcast-tests/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-495-checker-checkcast-tests-expected-stdout",
         ":art-run-test-495-checker-checkcast-tests-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/496-checker-inlining-class-loader/Android.bp b/test/496-checker-inlining-class-loader/Android.bp
index 17e838da0d..ff1d3bb720 100644
--- a/test/496-checker-inlining-class-loader/Android.bp
+++ b/test/496-checker-inlining-class-loader/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-496-checker-inlining-class-loader-expected-stdout",
         ":art-run-test-496-checker-inlining-class-loader-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/499-bce-phi-array-length/Android.bp b/test/499-bce-phi-array-length/Android.bp
index 1af6673f41..44505ab2e9 100644
--- a/test/499-bce-phi-array-length/Android.bp
+++ b/test/499-bce-phi-array-length/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-499-bce-phi-array-length-expected-stdout",
         ":art-run-test-499-bce-phi-array-length-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/500-instanceof/Android.bp b/test/500-instanceof/Android.bp
index fdb48a7eba..d99bf044db 100644
--- a/test/500-instanceof/Android.bp
+++ b/test/500-instanceof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-500-instanceof-expected-stdout",
         ":art-run-test-500-instanceof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/505-simplifier-type-propagation/Android.bp b/test/505-simplifier-type-propagation/Android.bp
index 4e8ab74cb8..9cdc46f9f3 100644
--- a/test/505-simplifier-type-propagation/Android.bp
+++ b/test/505-simplifier-type-propagation/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-505-simplifier-type-propagation-expected-stdout",
         ":art-run-test-505-simplifier-type-propagation-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/507-boolean-test/Android.bp b/test/507-boolean-test/Android.bp
index b1066bd1af..0cbab41549 100644
--- a/test/507-boolean-test/Android.bp
+++ b/test/507-boolean-test/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-507-boolean-test-expected-stdout",
         ":art-run-test-507-boolean-test-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/507-referrer/Android.bp b/test/507-referrer/Android.bp
index 2062922e83..548a55da30 100644
--- a/test/507-referrer/Android.bp
+++ b/test/507-referrer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-507-referrer-expected-stdout",
         ":art-run-test-507-referrer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/508-checker-disassembly/Android.bp b/test/508-checker-disassembly/Android.bp
index a657c16f80..37a153f01b 100644
--- a/test/508-checker-disassembly/Android.bp
+++ b/test/508-checker-disassembly/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-508-checker-disassembly-expected-stdout",
         ":art-run-test-508-checker-disassembly-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/508-referrer-method/Android.bp b/test/508-referrer-method/Android.bp
index 0964765ea5..54dc6e159a 100644
--- a/test/508-referrer-method/Android.bp
+++ b/test/508-referrer-method/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-508-referrer-method-expected-stdout",
         ":art-run-test-508-referrer-method-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/513-array-deopt/Android.bp b/test/513-array-deopt/Android.bp
index 1ede9a831a..fea15da431 100644
--- a/test/513-array-deopt/Android.bp
+++ b/test/513-array-deopt/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-513-array-deopt-expected-stdout",
         ":art-run-test-513-array-deopt-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/514-shifts/Android.bp b/test/514-shifts/Android.bp
index e5bd604c75..b0c4f565ac 100644
--- a/test/514-shifts/Android.bp
+++ b/test/514-shifts/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-514-shifts-expected-stdout",
         ":art-run-test-514-shifts-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/519-bound-load-class/Android.bp b/test/519-bound-load-class/Android.bp
index 5b0cbedd96..49798ab3b2 100644
--- a/test/519-bound-load-class/Android.bp
+++ b/test/519-bound-load-class/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-519-bound-load-class-expected-stdout",
         ":art-run-test-519-bound-load-class-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/521-checker-array-set-null/Android.bp b/test/521-checker-array-set-null/Android.bp
index 1199d81124..265db4c16f 100644
--- a/test/521-checker-array-set-null/Android.bp
+++ b/test/521-checker-array-set-null/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-521-checker-array-set-null-expected-stdout",
         ":art-run-test-521-checker-array-set-null-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/521-regression-integer-field-set/Android.bp b/test/521-regression-integer-field-set/Android.bp
index b90141e83c..0205ff2c0a 100644
--- a/test/521-regression-integer-field-set/Android.bp
+++ b/test/521-regression-integer-field-set/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-521-regression-integer-field-set-expected-stdout",
         ":art-run-test-521-regression-integer-field-set-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/524-boolean-simplifier-regression/Android.bp b/test/524-boolean-simplifier-regression/Android.bp
index be075e8999..8f73d9604a 100644
--- a/test/524-boolean-simplifier-regression/Android.bp
+++ b/test/524-boolean-simplifier-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-524-boolean-simplifier-regression-expected-stdout",
         ":art-run-test-524-boolean-simplifier-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/525-checker-arrays-fields1/Android.bp b/test/525-checker-arrays-fields1/Android.bp
index 8cfe2b0811..7806624a0e 100644
--- a/test/525-checker-arrays-fields1/Android.bp
+++ b/test/525-checker-arrays-fields1/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-525-checker-arrays-fields1-expected-stdout",
         ":art-run-test-525-checker-arrays-fields1-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/525-checker-arrays-fields2/Android.bp b/test/525-checker-arrays-fields2/Android.bp
index c6e165be54..9808f7333a 100644
--- a/test/525-checker-arrays-fields2/Android.bp
+++ b/test/525-checker-arrays-fields2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-525-checker-arrays-fields2-expected-stdout",
         ":art-run-test-525-checker-arrays-fields2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/526-checker-caller-callee-regs/Android.bp b/test/526-checker-caller-callee-regs/Android.bp
index c84b09cad5..578215f11e 100644
--- a/test/526-checker-caller-callee-regs/Android.bp
+++ b/test/526-checker-caller-callee-regs/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-526-checker-caller-callee-regs-expected-stdout",
         ":art-run-test-526-checker-caller-callee-regs-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/526-long-regalloc/Android.bp b/test/526-long-regalloc/Android.bp
index 34e4a2da17..1bfa389dad 100644
--- a/test/526-long-regalloc/Android.bp
+++ b/test/526-long-regalloc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-526-long-regalloc-expected-stdout",
         ":art-run-test-526-long-regalloc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/527-checker-array-access-simd/Android.bp b/test/527-checker-array-access-simd/Android.bp
index 96bb43a401..8109f339f2 100644
--- a/test/527-checker-array-access-simd/Android.bp
+++ b/test/527-checker-array-access-simd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-527-checker-array-access-simd-expected-stdout",
         ":art-run-test-527-checker-array-access-simd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/527-checker-array-access-split/Android.bp b/test/527-checker-array-access-split/Android.bp
index 849530a925..2e71ca8aed 100644
--- a/test/527-checker-array-access-split/Android.bp
+++ b/test/527-checker-array-access-split/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-527-checker-array-access-split-expected-stdout",
         ":art-run-test-527-checker-array-access-split-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/528-long-hint/Android.bp b/test/528-long-hint/Android.bp
index b3ddd560a4..f853956aa6 100644
--- a/test/528-long-hint/Android.bp
+++ b/test/528-long-hint/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-528-long-hint-expected-stdout",
         ":art-run-test-528-long-hint-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/529-long-split/Android.bp b/test/529-long-split/Android.bp
index d607272202..1870afc4a1 100644
--- a/test/529-long-split/Android.bp
+++ b/test/529-long-split/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-529-long-split-expected-stdout",
         ":art-run-test-529-long-split-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/530-checker-loops-try-catch/Android.bp b/test/530-checker-loops-try-catch/Android.bp
index b7b41275b3..91df9b0816 100644
--- a/test/530-checker-loops-try-catch/Android.bp
+++ b/test/530-checker-loops-try-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops-try-catch-expected-stdout",
         ":art-run-test-530-checker-loops-try-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-loops1/Android.bp b/test/530-checker-loops1/Android.bp
index 6bbb5af870..f1a541fb9b 100644
--- a/test/530-checker-loops1/Android.bp
+++ b/test/530-checker-loops1/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops1-expected-stdout",
         ":art-run-test-530-checker-loops1-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-loops2/Android.bp b/test/530-checker-loops2/Android.bp
index d196923715..0ff1af43e9 100644
--- a/test/530-checker-loops2/Android.bp
+++ b/test/530-checker-loops2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops2-expected-stdout",
         ":art-run-test-530-checker-loops2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-loops3/Android.bp b/test/530-checker-loops3/Android.bp
index ef2f738daa..9c6454eb01 100644
--- a/test/530-checker-loops3/Android.bp
+++ b/test/530-checker-loops3/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops3-expected-stdout",
         ":art-run-test-530-checker-loops3-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-loops4/Android.bp b/test/530-checker-loops4/Android.bp
index 54014669b2..fae666ce78 100644
--- a/test/530-checker-loops4/Android.bp
+++ b/test/530-checker-loops4/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops4-expected-stdout",
         ":art-run-test-530-checker-loops4-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-loops5/Android.bp b/test/530-checker-loops5/Android.bp
index 658e985645..6ac9b7e6f5 100644
--- a/test/530-checker-loops5/Android.bp
+++ b/test/530-checker-loops5/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-loops5-expected-stdout",
         ":art-run-test-530-checker-loops5-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-lse-ctor-fences/Android.bp b/test/530-checker-lse-ctor-fences/Android.bp
index c42ed9681d..019aa5f95f 100644
--- a/test/530-checker-lse-ctor-fences/Android.bp
+++ b/test/530-checker-lse-ctor-fences/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-lse-ctor-fences-expected-stdout",
         ":art-run-test-530-checker-lse-ctor-fences-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-lse-simd/Android.bp b/test/530-checker-lse-simd/Android.bp
index cf08d41d56..50e6e85cc8 100644
--- a/test/530-checker-lse-simd/Android.bp
+++ b/test/530-checker-lse-simd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-lse-simd-expected-stdout",
         ":art-run-test-530-checker-lse-simd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-lse-try-catch/Android.bp b/test/530-checker-lse-try-catch/Android.bp
index 6a58ea7327..71ef28ea88 100644
--- a/test/530-checker-lse-try-catch/Android.bp
+++ b/test/530-checker-lse-try-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-lse-try-catch-expected-stdout",
         ":art-run-test-530-checker-lse-try-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-checker-lse/Android.bp b/test/530-checker-lse/Android.bp
index f53de37a1c..73b46d308f 100644
--- a/test/530-checker-lse/Android.bp
+++ b/test/530-checker-lse/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-checker-lse-expected-stdout",
         ":art-run-test-530-checker-lse-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/530-instanceof-checkcast/Android.bp b/test/530-instanceof-checkcast/Android.bp
index 3b782c42e2..488dd7bc81 100644
--- a/test/530-instanceof-checkcast/Android.bp
+++ b/test/530-instanceof-checkcast/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-530-instanceof-checkcast-expected-stdout",
         ":art-run-test-530-instanceof-checkcast-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/532-checker-nonnull-arrayset/Android.bp b/test/532-checker-nonnull-arrayset/Android.bp
index 5ada4c537a..b75d63534c 100644
--- a/test/532-checker-nonnull-arrayset/Android.bp
+++ b/test/532-checker-nonnull-arrayset/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-532-checker-nonnull-arrayset-expected-stdout",
         ":art-run-test-532-checker-nonnull-arrayset-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/534-checker-bce-deoptimization/Android.bp b/test/534-checker-bce-deoptimization/Android.bp
index 7fcfce0e6b..0ff98e5ed1 100644
--- a/test/534-checker-bce-deoptimization/Android.bp
+++ b/test/534-checker-bce-deoptimization/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-534-checker-bce-deoptimization-expected-stdout",
         ":art-run-test-534-checker-bce-deoptimization-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/535-deopt-and-inlining/Android.bp b/test/535-deopt-and-inlining/Android.bp
index 2429c1ed2b..664e15915e 100644
--- a/test/535-deopt-and-inlining/Android.bp
+++ b/test/535-deopt-and-inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-535-deopt-and-inlining-expected-stdout",
         ":art-run-test-535-deopt-and-inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/536-checker-intrinsic-optimization/Android.bp b/test/536-checker-intrinsic-optimization/Android.bp
index b9832af09d..2a2a0e5aed 100644
--- a/test/536-checker-intrinsic-optimization/Android.bp
+++ b/test/536-checker-intrinsic-optimization/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-536-checker-intrinsic-optimization-expected-stdout",
         ":art-run-test-536-checker-intrinsic-optimization-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/536-checker-needs-access-check/Android.bp b/test/536-checker-needs-access-check/Android.bp
index 2f2b650646..bd925e2c22 100644
--- a/test/536-checker-needs-access-check/Android.bp
+++ b/test/536-checker-needs-access-check/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-536-checker-needs-access-check-expected-stdout",
         ":art-run-test-536-checker-needs-access-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/537-checker-arraycopy/Android.bp b/test/537-checker-arraycopy/Android.bp
index 83b7bd313b..a7e4ab5a24 100644
--- a/test/537-checker-arraycopy/Android.bp
+++ b/test/537-checker-arraycopy/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-537-checker-arraycopy-expected-stdout",
         ":art-run-test-537-checker-arraycopy-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/537-checker-inline-and-unverified/Android.bp b/test/537-checker-inline-and-unverified/Android.bp
index cca7486525..92c42b24a4 100644
--- a/test/537-checker-inline-and-unverified/Android.bp
+++ b/test/537-checker-inline-and-unverified/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-537-checker-inline-and-unverified-expected-stdout",
         ":art-run-test-537-checker-inline-and-unverified-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/537-checker-jump-over-jump/Android.bp b/test/537-checker-jump-over-jump/Android.bp
index e53a69fccd..ca717643ef 100644
--- a/test/537-checker-jump-over-jump/Android.bp
+++ b/test/537-checker-jump-over-jump/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-537-checker-jump-over-jump-expected-stdout",
         ":art-run-test-537-checker-jump-over-jump-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/538-checker-embed-constants/Android.bp b/test/538-checker-embed-constants/Android.bp
index 5fa5a74d28..140cd1b7c3 100644
--- a/test/538-checker-embed-constants/Android.bp
+++ b/test/538-checker-embed-constants/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-538-checker-embed-constants-expected-stdout",
         ":art-run-test-538-checker-embed-constants-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/540-checker-rtp-bug/Android.bp b/test/540-checker-rtp-bug/Android.bp
index 413e55da34..507b2269bf 100644
--- a/test/540-checker-rtp-bug/Android.bp
+++ b/test/540-checker-rtp-bug/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-540-checker-rtp-bug-expected-stdout",
         ":art-run-test-540-checker-rtp-bug-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/542-bitfield-rotates/Android.bp b/test/542-bitfield-rotates/Android.bp
index 21f6999c66..61884c9f6a 100644
--- a/test/542-bitfield-rotates/Android.bp
+++ b/test/542-bitfield-rotates/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-542-bitfield-rotates-expected-stdout",
         ":art-run-test-542-bitfield-rotates-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/542-inline-trycatch/Android.bp b/test/542-inline-trycatch/Android.bp
index 41ca0492a3..52ab35fcf9 100644
--- a/test/542-inline-trycatch/Android.bp
+++ b/test/542-inline-trycatch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-542-inline-trycatch-expected-stdout",
         ":art-run-test-542-inline-trycatch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/542-unresolved-access-check/Android.bp b/test/542-unresolved-access-check/Android.bp
index cb77b500e2..f2c499b44c 100644
--- a/test/542-unresolved-access-check/Android.bp
+++ b/test/542-unresolved-access-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-542-unresolved-access-check-expected-stdout",
         ":art-run-test-542-unresolved-access-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/545-tracing-and-jit/Android.bp b/test/545-tracing-and-jit/Android.bp
index 2615572973..22c8c30fc9 100644
--- a/test/545-tracing-and-jit/Android.bp
+++ b/test/545-tracing-and-jit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-545-tracing-and-jit-expected-stdout",
         ":art-run-test-545-tracing-and-jit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/548-checker-inlining-and-dce/Android.bp b/test/548-checker-inlining-and-dce/Android.bp
index eb4874a648..43e1fbc157 100644
--- a/test/548-checker-inlining-and-dce/Android.bp
+++ b/test/548-checker-inlining-and-dce/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-548-checker-inlining-and-dce-expected-stdout",
         ":art-run-test-548-checker-inlining-and-dce-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/549-checker-types-merge/Android.bp b/test/549-checker-types-merge/Android.bp
index 6899fbc8c3..95a9192b71 100644
--- a/test/549-checker-types-merge/Android.bp
+++ b/test/549-checker-types-merge/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-549-checker-types-merge-expected-stdout",
         ":art-run-test-549-checker-types-merge-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/550-checker-multiply-accumulate/Android.bp b/test/550-checker-multiply-accumulate/Android.bp
index 12ad79b38d..1f5f4a0db1 100644
--- a/test/550-checker-multiply-accumulate/Android.bp
+++ b/test/550-checker-multiply-accumulate/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-550-checker-multiply-accumulate-expected-stdout",
         ":art-run-test-550-checker-multiply-accumulate-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/550-new-instance-clinit/Android.bp b/test/550-new-instance-clinit/Android.bp
index 458aa581a7..b954739743 100644
--- a/test/550-new-instance-clinit/Android.bp
+++ b/test/550-new-instance-clinit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-550-new-instance-clinit-expected-stdout",
         ":art-run-test-550-new-instance-clinit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/551-checker-clinit/Android.bp b/test/551-checker-clinit/Android.bp
index 8004adecd1..b53b189ef4 100644
--- a/test/551-checker-clinit/Android.bp
+++ b/test/551-checker-clinit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-551-checker-clinit-expected-stdout",
         ":art-run-test-551-checker-clinit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/551-checker-shifter-operand/Android.bp b/test/551-checker-shifter-operand/Android.bp
index e28af78845..bd55536b2c 100644
--- a/test/551-checker-shifter-operand/Android.bp
+++ b/test/551-checker-shifter-operand/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-551-checker-shifter-operand-expected-stdout",
         ":art-run-test-551-checker-shifter-operand-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/551-implicit-null-checks/Android.bp b/test/551-implicit-null-checks/Android.bp
index a29f36d3a2..47688be486 100644
--- a/test/551-implicit-null-checks/Android.bp
+++ b/test/551-implicit-null-checks/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-551-implicit-null-checks-expected-stdout",
         ":art-run-test-551-implicit-null-checks-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/552-checker-sharpening/profile b/test/552-checker-sharpening/profile
new file mode 100644
index 0000000000..e883f017e4
--- /dev/null
+++ b/test/552-checker-sharpening/profile
@@ -0,0 +1,15 @@
+LAppImageClass;
+HSPLMain;->testSimple(I)I
+HSPLMain;->testSimpleAppImage(I)I
+HSPLMain;->testDiamond(ZI)I
+HSPLMain;->testLoop([II)I
+HSPLMain;->testLoopWithDiamond([IZI)I
+HSPLMain;->$noinline$getBootImageString()Ljava/lang/String;
+HSPLMain;->$noinline$getNonBootImageString()Ljava/lang/String;
+HSPLMain;->$noinline$getStringClass()Ljava/lang/Class;
+HSPLMain;->$noinline$getOtherClass()Ljava/lang/Class;
+HSPLMain;->$noinline$getAppImageClass()Ljava/lang/Class;
+HSPLMain;->$noinline$toHexString(I)Ljava/lang/String;
+HSPLMain;->$noinline$toHexStringIndirect(I)Ljava/lang/String;
+HSPLMain;->$noinline$foo()V
+HSPLMulti;->localToHexString()Ljava/lang/String;
diff --git a/test/552-checker-sharpening/run.py b/test/552-checker-sharpening/run.py
new file mode 100644
index 0000000000..1a893fbb1c
--- /dev/null
+++ b/test/552-checker-sharpening/run.py
@@ -0,0 +1,20 @@
+#!/bin/bash
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+def run(ctx, args):
+  # Use a profile to put specific classes in the app image.
+  ctx.default_run(args, profile=True)
diff --git a/test/552-checker-sharpening/src/Main.java b/test/552-checker-sharpening/src/Main.java
index b017ab024b..730c1c800a 100644
--- a/test/552-checker-sharpening/src/Main.java
+++ b/test/552-checker-sharpening/src/Main.java
@@ -38,7 +38,7 @@ public class Main {
     return x;
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: int Main.testSimple(int) builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: int Main.testSimple(int) builder (after)
   /// CHECK:                InvokeStaticOrDirect method_load_kind:BssEntry
 
   /// CHECK-START-X86: int Main.testSimple(int) pc_relative_fixups_x86 (before)
@@ -53,7 +53,22 @@ public class Main {
     return $noinline$foo(x);
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: int Main.testDiamond(boolean, int) builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: int Main.testSimpleAppImage(int) builder (after)
+  /// CHECK:                InvokeStaticOrDirect method_load_kind:AppImageRelRo
+
+  /// CHECK-START-X86: int Main.testSimpleAppImage(int) pc_relative_fixups_x86 (before)
+  /// CHECK-NOT:            X86ComputeBaseMethodAddress
+
+  /// CHECK-START-X86: int Main.testSimpleAppImage(int) pc_relative_fixups_x86 (after)
+  /// CHECK:                X86ComputeBaseMethodAddress
+  /// CHECK-NOT:            X86ComputeBaseMethodAddress
+
+  public static int testSimpleAppImage(int x) {
+    // This call should use PC-relative .data.img.rel.ro array load to retrieve the target method.
+    return AppImageClass.$noinline$foo(x);
+  }
+
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: int Main.testDiamond(boolean, int) builder (after)
   /// CHECK:                InvokeStaticOrDirect method_load_kind:BssEntry
   /// CHECK:                InvokeStaticOrDirect method_load_kind:BssEntry
 
@@ -128,7 +143,7 @@ public class Main {
     return x;
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.String Main.$noinline$getBootImageString() builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.String Main.$noinline$getBootImageString() builder (after)
   /// CHECK:                LoadString load_kind:BootImageRelRo
 
   public static String $noinline$getBootImageString() {
@@ -136,7 +151,7 @@ public class Main {
     return "";
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.String Main.$noinline$getNonBootImageString() builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.String Main.$noinline$getNonBootImageString() builder (after)
   /// CHECK:                LoadString load_kind:BssEntry
 
   /// CHECK-START-X86: java.lang.String Main.$noinline$getNonBootImageString() pc_relative_fixups_x86 (before)
@@ -151,7 +166,7 @@ public class Main {
     return "non-boot-image-string";
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.Class Main.$noinline$getStringClass() builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.Class Main.$noinline$getStringClass() builder (after)
   /// CHECK:                LoadClass load_kind:BootImageRelRo class_name:java.lang.String
 
   public static Class<?> $noinline$getStringClass() {
@@ -159,7 +174,7 @@ public class Main {
     return String.class;
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.Class Main.$noinline$getOtherClass() builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.Class Main.$noinline$getOtherClass() builder (after)
   /// CHECK:                LoadClass load_kind:BssEntry class_name:Other
 
   /// CHECK-START-X86: java.lang.Class Main.$noinline$getOtherClass() pc_relative_fixups_x86 (before)
@@ -170,17 +185,32 @@ public class Main {
   /// CHECK-DAG:            LoadClass load_kind:BssEntry class_name:Other
 
   public static Class<?> $noinline$getOtherClass() {
-    // Other class is not in the boot image.
+    // Other class is neither in the boot image nor in the app image.
     return Other.class;
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.String Main.$noinline$toHexString(int) builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.Class Main.$noinline$getAppImageClass() builder (after)
+  /// CHECK:                LoadClass load_kind:AppImageRelRo class_name:AppImageClass
+
+  /// CHECK-START-X86: java.lang.Class Main.$noinline$getAppImageClass() pc_relative_fixups_x86 (before)
+  /// CHECK-NOT:            X86ComputeBaseMethodAddress
+
+  /// CHECK-START-X86: java.lang.Class Main.$noinline$getAppImageClass() pc_relative_fixups_x86 (after)
+  /// CHECK-DAG:            X86ComputeBaseMethodAddress
+  /// CHECK-DAG:            LoadClass load_kind:AppImageRelRo class_name:AppImageClass
+
+  public static Class<?> $noinline$getAppImageClass() {
+    // AppImageClass class is in the app image.
+    return AppImageClass.class;
+  }
+
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.String Main.$noinline$toHexString(int) builder (after)
   /// CHECK:                InvokeStaticOrDirect method_load_kind:BootImageRelRo
   public static String $noinline$toHexString(int value) {
     return Integer.toString(value, 16);
   }
 
-  /// CHECK-START-{ARM,ARM64,X86,X86_64}: java.lang.String Main.$noinline$toHexStringIndirect(int) builder (after)
+  /// CHECK-START-{ARM,ARM64,X86,X86_64,RISCV64}: java.lang.String Main.$noinline$toHexStringIndirect(int) builder (after)
   /// CHECK:                InvokeStaticOrDirect method_load_kind:BssEntry
 
   /// CHECK-START-X86: java.lang.String Main.$noinline$toHexStringIndirect(int) pc_relative_fixups_x86 (before)
@@ -195,6 +225,7 @@ public class Main {
 
   public static void main(String[] args) {
     assertIntEquals(1, testSimple(1));
+    assertIntEquals(1, testSimpleAppImage(1));
     assertIntEquals(1, testDiamond(false, 1));
     assertIntEquals(-1, testDiamond(true, 1));
     assertIntEquals(3, testLoop(new int[]{ 2 }, 1));
@@ -211,6 +242,12 @@ public class Main {
   }
 }
 
+class AppImageClass {
+  public static int $noinline$foo(int x) {
+    return x;
+  }
+}
+
 class Other {
 }
 
diff --git a/test/552-checker-x86-avx2-bit-manipulation/Android.bp b/test/552-checker-x86-avx2-bit-manipulation/Android.bp
index 505b631f02..09f399ca1f 100644
--- a/test/552-checker-x86-avx2-bit-manipulation/Android.bp
+++ b/test/552-checker-x86-avx2-bit-manipulation/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-552-checker-x86-avx2-bit-manipulation-expected-stdout",
         ":art-run-test-552-checker-x86-avx2-bit-manipulation-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/554-checker-rtp-checkcast/Android.bp b/test/554-checker-rtp-checkcast/Android.bp
index 7c4bf6c8c7..94f1399eed 100644
--- a/test/554-checker-rtp-checkcast/Android.bp
+++ b/test/554-checker-rtp-checkcast/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-554-checker-rtp-checkcast-expected-stdout",
         ":art-run-test-554-checker-rtp-checkcast-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/557-checker-instruct-simplifier-ror/Android.bp b/test/557-checker-instruct-simplifier-ror/Android.bp
index a424b8ab56..3a7e067bd6 100644
--- a/test/557-checker-instruct-simplifier-ror/Android.bp
+++ b/test/557-checker-instruct-simplifier-ror/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-557-checker-instruct-simplifier-ror-expected-stdout",
         ":art-run-test-557-checker-instruct-simplifier-ror-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/558-switch/Android.bp b/test/558-switch/Android.bp
index 7c7ffddab9..01f5c8c460 100644
--- a/test/558-switch/Android.bp
+++ b/test/558-switch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-558-switch-expected-stdout",
         ":art-run-test-558-switch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/559-bce-ssa/Android.bp b/test/559-bce-ssa/Android.bp
index 025c7febe5..84d2158f65 100644
--- a/test/559-bce-ssa/Android.bp
+++ b/test/559-bce-ssa/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-559-bce-ssa-expected-stdout",
         ":art-run-test-559-bce-ssa-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/559-checker-rtp-ifnotnull/Android.bp b/test/559-checker-rtp-ifnotnull/Android.bp
index 68bcb7e6ca..77dff521c2 100644
--- a/test/559-checker-rtp-ifnotnull/Android.bp
+++ b/test/559-checker-rtp-ifnotnull/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-559-checker-rtp-ifnotnull-expected-stdout",
         ":art-run-test-559-checker-rtp-ifnotnull-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/560-packed-switch/Android.bp b/test/560-packed-switch/Android.bp
index 418aa6de6e..047897f544 100644
--- a/test/560-packed-switch/Android.bp
+++ b/test/560-packed-switch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-560-packed-switch-expected-stdout",
         ":art-run-test-560-packed-switch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/561-divrem/Android.bp b/test/561-divrem/Android.bp
index b07e10eaf0..7cefc23e5e 100644
--- a/test/561-divrem/Android.bp
+++ b/test/561-divrem/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-561-divrem-expected-stdout",
         ":art-run-test-561-divrem-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/561-shared-slowpaths/Android.bp b/test/561-shared-slowpaths/Android.bp
index 1058c0c30e..120d3ff1c8 100644
--- a/test/561-shared-slowpaths/Android.bp
+++ b/test/561-shared-slowpaths/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-561-shared-slowpaths-expected-stdout",
         ":art-run-test-561-shared-slowpaths-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/562-bce-preheader/Android.bp b/test/562-bce-preheader/Android.bp
index d7c979290b..e3107e7df9 100644
--- a/test/562-bce-preheader/Android.bp
+++ b/test/562-bce-preheader/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-562-bce-preheader-expected-stdout",
         ":art-run-test-562-bce-preheader-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/562-checker-no-intermediate/Android.bp b/test/562-checker-no-intermediate/Android.bp
index 1ac31425ef..72696ef754 100644
--- a/test/562-checker-no-intermediate/Android.bp
+++ b/test/562-checker-no-intermediate/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-562-checker-no-intermediate-expected-stdout",
         ":art-run-test-562-checker-no-intermediate-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/563-checker-invoke-super/Android.bp b/test/563-checker-invoke-super/Android.bp
index 1097d85d34..6111fd0e04 100644
--- a/test/563-checker-invoke-super/Android.bp
+++ b/test/563-checker-invoke-super/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-563-checker-invoke-super-expected-stdout",
         ":art-run-test-563-checker-invoke-super-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/564-checker-bitcount/Android.bp b/test/564-checker-bitcount/Android.bp
index 85c81bbc9a..21e55d9430 100644
--- a/test/564-checker-bitcount/Android.bp
+++ b/test/564-checker-bitcount/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-564-checker-bitcount-expected-stdout",
         ":art-run-test-564-checker-bitcount-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/564-checker-inline-loop/Android.bp b/test/564-checker-inline-loop/Android.bp
index 6f0a15948c..dec0f92d0d 100644
--- a/test/564-checker-inline-loop/Android.bp
+++ b/test/564-checker-inline-loop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-564-checker-inline-loop-expected-stdout",
         ":art-run-test-564-checker-inline-loop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/564-checker-negbitwise/Android.bp b/test/564-checker-negbitwise/Android.bp
index 8d658a18a2..733ae37112 100644
--- a/test/564-checker-negbitwise/Android.bp
+++ b/test/564-checker-negbitwise/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-564-checker-negbitwise-expected-stdout",
         ":art-run-test-564-checker-negbitwise-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/565-checker-condition-liveness/Android.bp b/test/565-checker-condition-liveness/Android.bp
index c70f56a5a4..0eb89e9180 100644
--- a/test/565-checker-condition-liveness/Android.bp
+++ b/test/565-checker-condition-liveness/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-565-checker-condition-liveness-expected-stdout",
         ":art-run-test-565-checker-condition-liveness-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/566-checker-codegen-select/Android.bp b/test/566-checker-codegen-select/Android.bp
index 27c5f4838a..523180b09e 100644
--- a/test/566-checker-codegen-select/Android.bp
+++ b/test/566-checker-codegen-select/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-566-checker-codegen-select-expected-stdout",
         ":art-run-test-566-checker-codegen-select-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/567-checker-builder-intrinsics/Android.bp b/test/567-checker-builder-intrinsics/Android.bp
index 5bf3c030c7..a47bc51876 100644
--- a/test/567-checker-builder-intrinsics/Android.bp
+++ b/test/567-checker-builder-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-567-checker-builder-intrinsics-expected-stdout",
         ":art-run-test-567-checker-builder-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/568-checker-onebit/Android.bp b/test/568-checker-onebit/Android.bp
index 649b81cc25..7a9a417150 100644
--- a/test/568-checker-onebit/Android.bp
+++ b/test/568-checker-onebit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-568-checker-onebit-expected-stdout",
         ":art-run-test-568-checker-onebit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/569-checker-pattern-replacement/smali-multidex/multidex.smali b/test/569-checker-pattern-replacement/smali-multidex/multidex.smali
new file mode 100644
index 0000000000..8a21ff2515
--- /dev/null
+++ b/test/569-checker-pattern-replacement/smali-multidex/multidex.smali
@@ -0,0 +1,23 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+.class public LMultidex;
+.super Ljava/lang/Object;
+
+.method public constructor <init>()V
+    .registers 1
+    invoke-direct/range {p0}, Ljava/lang/Object;-><init>()V
+    return-void
+.end method
diff --git a/test/569-checker-pattern-replacement/smali/smali.smali b/test/569-checker-pattern-replacement/smali/smali.smali
new file mode 100644
index 0000000000..b6c1685394
--- /dev/null
+++ b/test/569-checker-pattern-replacement/smali/smali.smali
@@ -0,0 +1,30 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+.class public LSmali;
+.super Ljava/lang/Object;
+
+## CHECK-START: Multidex Smali.createMultiDex() inliner (before)
+## CHECK: InvokeStaticOrDirect method_name:Multidex.<init>
+
+## CHECK-START: Multidex Smali.createMultiDex() inliner (after)
+## CHECK-NOT: InvokeStaticOrDirect method_name:Multidex.<init>
+.method public createMultiDex()LMultidex;
+.registers 1
+    new-instance v0, LMultidex;
+    invoke-direct {v0}, LMultidex;-><init>()V
+    return-object v0
+.end method
+
diff --git a/test/570-checker-osr-locals/src/Main.java b/test/570-checker-osr-locals/src/Main.java
index c215fa0ab1..60508deb98 100644
--- a/test/570-checker-osr-locals/src/Main.java
+++ b/test/570-checker-osr-locals/src/Main.java
@@ -69,6 +69,9 @@ public class Main {
   public static void runSmaliTest() {
     try {
       Class<?> c = Class.forName("WeirdLoop");
+      // Make sure `WeirdLoop` is visibly initialized to avoid waiting for OSR
+      // for the `--jit-on=first-use` configuration.
+      makeVisiblyInitialized();
       int result = (int) c.getDeclaredMethod("weirdLoop").invoke(null);
       if (result != 42) {
         throw new Error("Unexpected result: " + result);
@@ -120,4 +123,5 @@ public class Main {
 
   public static native boolean isInOsrCode(String methodName);
   public static native boolean isInInterpreter(String methodName);
+  public static native void makeVisiblyInitialized();
 }
diff --git a/test/570-checker-select/Android.bp b/test/570-checker-select/Android.bp
index e41303dba7..61a62b1140 100644
--- a/test/570-checker-select/Android.bp
+++ b/test/570-checker-select/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-570-checker-select-expected-stdout",
         ":art-run-test-570-checker-select-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/572-checker-array-get-regression/Android.bp b/test/572-checker-array-get-regression/Android.bp
index 415a9f1c30..71b9af9e64 100644
--- a/test/572-checker-array-get-regression/Android.bp
+++ b/test/572-checker-array-get-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-572-checker-array-get-regression-expected-stdout",
         ":art-run-test-572-checker-array-get-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/573-checker-checkcast-regression/Android.bp b/test/573-checker-checkcast-regression/Android.bp
index cf7186f734..51173e3d33 100644
--- a/test/573-checker-checkcast-regression/Android.bp
+++ b/test/573-checker-checkcast-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-573-checker-checkcast-regression-expected-stdout",
         ":art-run-test-573-checker-checkcast-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/576-polymorphic-inlining/Android.bp b/test/576-polymorphic-inlining/Android.bp
index f40b51e7a4..e326fa81cf 100644
--- a/test/576-polymorphic-inlining/Android.bp
+++ b/test/576-polymorphic-inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-576-polymorphic-inlining-expected-stdout",
         ":art-run-test-576-polymorphic-inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/577-checker-fp2int/Android.bp b/test/577-checker-fp2int/Android.bp
index cd0a5d3dfc..8141ed3e2c 100644
--- a/test/577-checker-fp2int/Android.bp
+++ b/test/577-checker-fp2int/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-577-checker-fp2int-expected-stdout",
         ":art-run-test-577-checker-fp2int-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/578-bce-visit/Android.bp b/test/578-bce-visit/Android.bp
index bddc53ebf3..92059aad7c 100644
--- a/test/578-bce-visit/Android.bp
+++ b/test/578-bce-visit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-578-bce-visit-expected-stdout",
         ":art-run-test-578-bce-visit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/578-polymorphic-inlining/Android.bp b/test/578-polymorphic-inlining/Android.bp
index 207c91b28c..4d670d877c 100644
--- a/test/578-polymorphic-inlining/Android.bp
+++ b/test/578-polymorphic-inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-578-polymorphic-inlining-expected-stdout",
         ":art-run-test-578-polymorphic-inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/579-inline-infinite/Android.bp b/test/579-inline-infinite/Android.bp
index 39fce3f30c..a321d3cfc0 100644
--- a/test/579-inline-infinite/Android.bp
+++ b/test/579-inline-infinite/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-579-inline-infinite-expected-stdout",
         ":art-run-test-579-inline-infinite-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/580-checker-fp16/Android.bp b/test/580-checker-fp16/Android.bp
index a165fe7ae2..e57c102324 100644
--- a/test/580-checker-fp16/Android.bp
+++ b/test/580-checker-fp16/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-580-checker-fp16-expected-stdout",
         ":art-run-test-580-checker-fp16-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/580-checker-round/Android.bp b/test/580-checker-round/Android.bp
index 5a05b19547..7ae5eefda3 100644
--- a/test/580-checker-round/Android.bp
+++ b/test/580-checker-round/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-580-checker-round-expected-stdout",
         ":art-run-test-580-checker-round-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/580-checker-string-fact-intrinsics/Android.bp b/test/580-checker-string-fact-intrinsics/Android.bp
index a0bb8442f5..46236b25e3 100644
--- a/test/580-checker-string-fact-intrinsics/Android.bp
+++ b/test/580-checker-string-fact-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-580-checker-string-fact-intrinsics-expected-stdout",
         ":art-run-test-580-checker-string-fact-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/580-crc32/Android.bp b/test/580-crc32/Android.bp
index 7d209491dd..3ee42fe188 100644
--- a/test/580-crc32/Android.bp
+++ b/test/580-crc32/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-580-crc32-expected-stdout",
         ":art-run-test-580-crc32-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/581-checker-rtp/Android.bp b/test/581-checker-rtp/Android.bp
index ddfbe0f707..ebc79d516e 100644
--- a/test/581-checker-rtp/Android.bp
+++ b/test/581-checker-rtp/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-581-checker-rtp-expected-stdout",
         ":art-run-test-581-checker-rtp-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/582-checker-bce-length/Android.bp b/test/582-checker-bce-length/Android.bp
index 937fd2d200..348aa7541a 100644
--- a/test/582-checker-bce-length/Android.bp
+++ b/test/582-checker-bce-length/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-582-checker-bce-length-expected-stdout",
         ":art-run-test-582-checker-bce-length-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/583-checker-zero/Android.bp b/test/583-checker-zero/Android.bp
index 4952dec11f..2e973a6600 100644
--- a/test/583-checker-zero/Android.bp
+++ b/test/583-checker-zero/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-583-checker-zero-expected-stdout",
         ":art-run-test-583-checker-zero-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/584-checker-div-bool/Android.bp b/test/584-checker-div-bool/Android.bp
index 5e7f928641..4aa2523851 100644
--- a/test/584-checker-div-bool/Android.bp
+++ b/test/584-checker-div-bool/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-584-checker-div-bool-expected-stdout",
         ":art-run-test-584-checker-div-bool-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/589-super-imt/Android.bp b/test/589-super-imt/Android.bp
index 5a79bc98e2..54ca9ac594 100644
--- a/test/589-super-imt/Android.bp
+++ b/test/589-super-imt/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-589-super-imt-expected-stdout",
         ":art-run-test-589-super-imt-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/590-checker-arr-set-null-regression/Android.bp b/test/590-checker-arr-set-null-regression/Android.bp
index e42602ab53..b6ee45fa77 100644
--- a/test/590-checker-arr-set-null-regression/Android.bp
+++ b/test/590-checker-arr-set-null-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-590-checker-arr-set-null-regression-expected-stdout",
         ":art-run-test-590-checker-arr-set-null-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/591-checker-regression-dead-loop/Android.bp b/test/591-checker-regression-dead-loop/Android.bp
index b2138a8f7d..465ad94b7b 100644
--- a/test/591-checker-regression-dead-loop/Android.bp
+++ b/test/591-checker-regression-dead-loop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-591-checker-regression-dead-loop-expected-stdout",
         ":art-run-test-591-checker-regression-dead-loop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/593-checker-long-2-float-regression/Android.bp b/test/593-checker-long-2-float-regression/Android.bp
index bc5adc7c55..5ae8dde99d 100644
--- a/test/593-checker-long-2-float-regression/Android.bp
+++ b/test/593-checker-long-2-float-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-593-checker-long-2-float-regression-expected-stdout",
         ":art-run-test-593-checker-long-2-float-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/594-checker-array-alias/Android.bp b/test/594-checker-array-alias/Android.bp
index 82e5a885fa..6e8f109071 100644
--- a/test/594-checker-array-alias/Android.bp
+++ b/test/594-checker-array-alias/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-594-checker-array-alias-expected-stdout",
         ":art-run-test-594-checker-array-alias-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/594-load-string-regression/Android.bp b/test/594-load-string-regression/Android.bp
index b1a86440a3..95b64283b7 100644
--- a/test/594-load-string-regression/Android.bp
+++ b/test/594-load-string-regression/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-594-load-string-regression-expected-stdout",
         ":art-run-test-594-load-string-regression-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/595-profile-saving/src/Main.java b/test/595-profile-saving/src/Main.java
index 8fdc4e1ede..a0ea3c505e 100644
--- a/test/595-profile-saving/src/Main.java
+++ b/test/595-profile-saving/src/Main.java
@@ -17,6 +17,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Method;
+import java.time.Duration;
 
 public class Main {
 
@@ -28,81 +29,93 @@ public class Main {
       return;
     }
 
-    File file = null;
-    File file2 = null;
-    File file3 = null;
-    try {
-      // Register `file2` with an empty jar. Even though `file2` is registered before `file`, the
-      // runtime should not write bootclasspath methods to `file2`, and it should not even create
-      // `file2`.
-      file2 = createTempFile();
-      String emptyJarPath =
-          System.getenv("DEX_LOCATION") + "/res/art-gtest-jars-MainEmptyUncompressed.jar";
-      VMRuntime.registerAppInfo("test.app",
-                                file2.getPath(),
-                                file2.getPath(),
-                                new String[] {emptyJarPath},
-                                VMRuntime.CODE_PATH_TYPE_SPLIT_APK);
-
-      file = createTempFile();
-      String codePath = System.getenv("DEX_LOCATION") + "/595-profile-saving.jar";
-      VMRuntime.registerAppInfo("test.app",
-                                file.getPath(),
-                                file.getPath(),
-                                new String[] {codePath},
-                                VMRuntime.CODE_PATH_TYPE_PRIMARY_APK);
-
-      file3 = createTempFile();
-      String dexPath = System.getenv("DEX_LOCATION") + "/res/art-gtest-jars-Main.dex";
-      VMRuntime.registerAppInfo("test.app",
-                                file3.getPath(),
-                                file3.getPath(),
-                                new String[] {dexPath},
-                                VMRuntime.CODE_PATH_TYPE_SPLIT_APK);
-
-      // Delete the files so that we can check if the runtime creates them. The runtime should
-      // create `file` and `file3` but not `file2`.
-      file.delete();
-      file2.delete();
-      file3.delete();
-
-      // Test that the runtime saves the profiling info of an app method in a .jar file.
-      Method appMethod = Main.class.getDeclaredMethod("testAddMethodToProfile",
-          File.class, Method.class);
-      testAddMethodToProfile(file, appMethod);
-
-      // Test that the runtime saves the profiling info of an app method in a .dex file.
-      ClassLoader dexClassLoader = (ClassLoader) Class.forName("dalvik.system.PathClassLoader")
-                                           .getDeclaredConstructor(String.class, ClassLoader.class)
-                                           .newInstance(dexPath, null /* parent */);
-      Class<?> c = Class.forName("Main", true /* initialize */, dexClassLoader);
-      Method methodInDex = c.getMethod("main", (new String[0]).getClass());
-      testAddMethodToProfile(file3, methodInDex);
-
-      // Test that the runtime saves the profiling info of a bootclasspath method.
-      Method bootMethod = File.class.getDeclaredMethod("exists");
-      if (bootMethod.getDeclaringClass().getClassLoader() != Object.class.getClassLoader()) {
+    // Register `file2` with an empty jar. Even though `file2` is registered before `file`, the
+    // runtime should not write bootclasspath methods to `file2`, and it should not even create
+    // `file2`.
+    File file2 = createTempFile();
+    file2.deleteOnExit();
+    String emptyJarPath =
+            System.getenv("DEX_LOCATION") + "/res/art-gtest-jars-MainEmptyUncompressed.jar";
+    VMRuntime.registerAppInfo("test.app", file2.getPath(), file2.getPath(),
+            new String[] {emptyJarPath}, VMRuntime.CODE_PATH_TYPE_SPLIT_APK);
+
+    File file = createTempFile();
+    file.deleteOnExit();
+    String codePath = System.getenv("DEX_LOCATION") + "/595-profile-saving.jar";
+    VMRuntime.registerAppInfo("test.app", file.getPath(), file.getPath(), new String[] {codePath},
+            VMRuntime.CODE_PATH_TYPE_PRIMARY_APK);
+
+    File file3 = createTempFile();
+    file3.deleteOnExit();
+    String dexPath = System.getenv("DEX_LOCATION") + "/res/art-gtest-jars-Main.dex";
+    VMRuntime.registerAppInfo("test.app", file3.getPath(), file3.getPath(), new String[] {dexPath},
+            VMRuntime.CODE_PATH_TYPE_SPLIT_APK);
+
+    // Delete the files so that we can check if the runtime creates them. The runtime should
+    // create `file` and `file3` but not `file2`.
+    file.delete();
+    file2.delete();
+    file3.delete();
+
+    // Test that the runtime saves the profiling info of an app method in a .jar file.
+    Method appMethod =
+            Main.class.getDeclaredMethod("testAddMethodToProfile", File.class, Method.class);
+    testAddMethodToProfile(file, appMethod);
+
+    // Test that the runtime saves the profiling info of an app method in a .dex file.
+    ClassLoader dexClassLoader = (ClassLoader) Class.forName("dalvik.system.PathClassLoader")
+                                         .getDeclaredConstructor(String.class, ClassLoader.class)
+                                         .newInstance(dexPath, null /* parent */);
+    Class<?> c = Class.forName("Main", true /* initialize */, dexClassLoader);
+    Method methodInDex = c.getMethod("main", (new String[0]).getClass());
+    testAddMethodToProfile(file3, methodInDex);
+
+    // Test that the runtime saves the profiling info of a bootclasspath method.
+    Method bootMethod = File.class.getDeclaredMethod("exists");
+    if (bootMethod.getDeclaringClass().getClassLoader() != Object.class.getClassLoader()) {
         System.out.println("Class loader does not match boot class");
-      }
-      testAddMethodToProfile(file, bootMethod);
+    }
+    testAddMethodToProfile(file, bootMethod);
 
-      // We never expect System.console to be executed before Main.main gets invoked, and therefore
-      // it should never be in a profile.
-      Method bootNotInProfileMethod = System.class.getDeclaredMethod("console");
-      testMethodNotInProfile(file, bootNotInProfileMethod);
+    // We never expect System.console to be executed before Main.main gets invoked, and therefore
+    // it should never be in a profile.
+    Method bootNotInProfileMethod = System.class.getDeclaredMethod("console");
+    testMethodNotInProfile(file, bootNotInProfileMethod);
 
-      testProfileNotExist(file2);
+    testProfileNotExist(file2);
 
-      if (!isForBootImage(file.getPath())) {
+    if (!isForBootImage(file.getPath())) {
         throw new Error("Expected profile to be for boot image");
-      }
-    } finally {
-      if (file != null) {
-        file.delete();
-      }
-      if (file2 != null) {
-        file2.delete();
-      }
+    }
+
+    // Test that:
+    // 1. The runtime always writes to disk upon a forced save, even if there is nothing to update.
+    // 2. The profile for the primary APK is always the last one to write.
+    // The checks may yield false negatives. Repeat multiple times to reduce the chance of false
+    // negatives.
+    for (int i = 0; i < 10; i++) {
+        Duration primaryTimestampBefore = getMTime(file.getPath());
+        Duration splitTimestampBefore = getMTime(file3.getPath());
+        ensureProfileProcessing();
+        Duration primaryTimestampAfter = getMTime(file.getPath());
+        Duration splitTimestampAfter = getMTime(file3.getPath());
+
+        if (primaryTimestampAfter.compareTo(primaryTimestampBefore) <= 0) {
+            throw new Error(
+                    String.format("Profile for primary APK not updated (before: %d, after: %d)",
+                            primaryTimestampBefore.toNanos(), primaryTimestampAfter.toNanos()));
+        }
+        if (splitTimestampAfter.compareTo(splitTimestampBefore) <= 0) {
+            throw new Error(
+                    String.format("Profile for split APK not updated (before: %d, after: %d)",
+                            primaryTimestampBefore.toNanos(), primaryTimestampAfter.toNanos()));
+        }
+        if (primaryTimestampAfter.compareTo(splitTimestampAfter) < 0) {
+            throw new Error(String.format(
+                    "Profile for primary APK is unexpected updated before profile for "
+                            + "split APK (primary: %d, split: %d)",
+                    primaryTimestampAfter.toNanos(), splitTimestampAfter.toNanos()));
+        }
     }
   }
 
@@ -168,6 +181,12 @@ public class Main {
     }
   }
 
+  private static Duration getMTime(String path) throws Exception {
+      // We cannot use `Files.getLastModifiedTime` because it doesn't have nanosecond precision.
+      StructTimespec st_mtim = Os.stat(path).st_mtim;
+      return Duration.ofSeconds(st_mtim.tv_sec).plus(Duration.ofNanos(st_mtim.tv_nsec));
+  }
+
   private static class VMRuntime {
     public static final int CODE_PATH_TYPE_PRIMARY_APK = 1 << 0;
     public static final int CODE_PATH_TYPE_SPLIT_APK = 1 << 1;
@@ -198,4 +217,30 @@ public class Main {
           codePathsType);
     }
   }
+
+  private static class Os {
+      public static StructStat stat(String path) throws Exception {
+          return new StructStat(Class.forName("android.system.Os")
+                          .getMethod("stat", String.class)
+                          .invoke(null, path));
+      }
+  }
+
+  private static class StructStat {
+      public final StructTimespec st_mtim;
+
+      public StructStat(Object instance) throws Exception {
+          st_mtim = new StructTimespec(instance.getClass().getField("st_mtim").get(instance));
+      }
+  }
+
+  private static class StructTimespec {
+      public final long tv_nsec;
+      public final long tv_sec;
+
+      public StructTimespec(Object instance) throws Exception {
+          tv_nsec = (long) instance.getClass().getField("tv_nsec").get(instance);
+          tv_sec = (long) instance.getClass().getField("tv_sec").get(instance);
+      }
+  }
 }
diff --git a/test/603-checker-instanceof/Android.bp b/test/603-checker-instanceof/Android.bp
index 3fcc54d0fd..a8ffcb1e0b 100644
--- a/test/603-checker-instanceof/Android.bp
+++ b/test/603-checker-instanceof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-603-checker-instanceof-expected-stdout",
         ":art-run-test-603-checker-instanceof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/605-new-string-from-bytes/Android.bp b/test/605-new-string-from-bytes/Android.bp
index 4bbfa10ee6..d148c61779 100644
--- a/test/605-new-string-from-bytes/Android.bp
+++ b/test/605-new-string-from-bytes/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-605-new-string-from-bytes-expected-stdout",
         ":art-run-test-605-new-string-from-bytes-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/607-daemon-stress/Android.bp b/test/607-daemon-stress/Android.bp
index 083bd7c87e..01a22f55f5 100644
--- a/test/607-daemon-stress/Android.bp
+++ b/test/607-daemon-stress/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-607-daemon-stress-expected-stdout",
         ":art-run-test-607-daemon-stress-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/609-checker-inline-interface/Android.bp b/test/609-checker-inline-interface/Android.bp
index 33c2cacd0b..ad83513441 100644
--- a/test/609-checker-inline-interface/Android.bp
+++ b/test/609-checker-inline-interface/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-609-checker-inline-interface-expected-stdout",
         ":art-run-test-609-checker-inline-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/609-checker-x86-bounds-check/Android.bp b/test/609-checker-x86-bounds-check/Android.bp
index 81591bc60d..747ba17a71 100644
--- a/test/609-checker-x86-bounds-check/Android.bp
+++ b/test/609-checker-x86-bounds-check/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-609-checker-x86-bounds-check-expected-stdout",
         ":art-run-test-609-checker-x86-bounds-check-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/610-arraycopy/Android.bp b/test/610-arraycopy/Android.bp
index c049136cb8..7e0a01765e 100644
--- a/test/610-arraycopy/Android.bp
+++ b/test/610-arraycopy/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-610-arraycopy-expected-stdout",
         ":art-run-test-610-arraycopy-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/611-checker-simplify-if/Android.bp b/test/611-checker-simplify-if/Android.bp
index 7637af3da1..e138164f20 100644
--- a/test/611-checker-simplify-if/Android.bp
+++ b/test/611-checker-simplify-if/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-611-checker-simplify-if-expected-stdout",
         ":art-run-test-611-checker-simplify-if-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/614-checker-dump-constant-location/Android.bp b/test/614-checker-dump-constant-location/Android.bp
index 566bdaed6c..f7c73c7368 100644
--- a/test/614-checker-dump-constant-location/Android.bp
+++ b/test/614-checker-dump-constant-location/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-614-checker-dump-constant-location-expected-stdout",
         ":art-run-test-614-checker-dump-constant-location-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/615-checker-arm64-store-zero/Android.bp b/test/615-checker-arm64-store-zero/Android.bp
index bd5acd9ba9..ffb53d73d6 100644
--- a/test/615-checker-arm64-store-zero/Android.bp
+++ b/test/615-checker-arm64-store-zero/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-615-checker-arm64-store-zero-expected-stdout",
         ":art-run-test-615-checker-arm64-store-zero-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/617-clinit-oome/Android.bp b/test/617-clinit-oome/Android.bp
index a58c888aa2..432f6d3517 100644
--- a/test/617-clinit-oome/Android.bp
+++ b/test/617-clinit-oome/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-617-clinit-oome-expected-stdout",
         ":art-run-test-617-clinit-oome-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/618-checker-induction/Android.bp b/test/618-checker-induction/Android.bp
index 6d1a0542f9..17fa0f2637 100644
--- a/test/618-checker-induction/Android.bp
+++ b/test/618-checker-induction/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-618-checker-induction-expected-stdout",
         ":art-run-test-618-checker-induction-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/619-checker-current-method/Android.bp b/test/619-checker-current-method/Android.bp
index 10e2d9a768..6fc753331a 100644
--- a/test/619-checker-current-method/Android.bp
+++ b/test/619-checker-current-method/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-619-checker-current-method-expected-stdout",
         ":art-run-test-619-checker-current-method-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/620-checker-bce-intrinsics/Android.bp b/test/620-checker-bce-intrinsics/Android.bp
index 0014b038a4..c18e8cbc82 100644
--- a/test/620-checker-bce-intrinsics/Android.bp
+++ b/test/620-checker-bce-intrinsics/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-620-checker-bce-intrinsics-expected-stdout",
         ":art-run-test-620-checker-bce-intrinsics-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/622-checker-bce-regressions/Android.bp b/test/622-checker-bce-regressions/Android.bp
index b14a5a0365..8abeac6da0 100644
--- a/test/622-checker-bce-regressions/Android.bp
+++ b/test/622-checker-bce-regressions/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-622-checker-bce-regressions-expected-stdout",
         ":art-run-test-622-checker-bce-regressions-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/624-checker-stringops/src/Main.java b/test/624-checker-stringops/src/Main.java
index 055a4d7ec9..06b1af36df 100644
--- a/test/624-checker-stringops/src/Main.java
+++ b/test/624-checker-stringops/src/Main.java
@@ -27,16 +27,16 @@ public class Main {
   // Variant intrinsics remain in the loop, but invariant references are hoisted out of the loop.
   //
   /// CHECK-START: int Main.liveIndexOf() licm (before)
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOf            loop:{{B\d+}} outer_loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOfAfter       loop:{{B\d+}} outer_loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringStringIndexOf      loop:{{B\d+}} outer_loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringStringIndexOfAfter loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOf                   loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOfAfter              loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeStaticOrDirect intrinsic:StringStringIndexOf      loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeStaticOrDirect intrinsic:StringStringIndexOfAfter loop:{{B\d+}} outer_loop:none
   //
   /// CHECK-START: int Main.liveIndexOf() licm (after)
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOf            loop:{{B\d+}} outer_loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOfAfter       loop:{{B\d+}} outer_loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringStringIndexOf      loop:none
-  /// CHECK-DAG: InvokeVirtual intrinsic:StringStringIndexOfAfter loop:none
+  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOf                   loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeVirtual intrinsic:StringIndexOfAfter              loop:{{B\d+}} outer_loop:none
+  /// CHECK-DAG: InvokeStaticOrDirect intrinsic:StringStringIndexOf      loop:none
+  /// CHECK-DAG: InvokeStaticOrDirect intrinsic:StringStringIndexOfAfter loop:none
   static int liveIndexOf() {
     int k = ABC.length() + XYZ.length();  // does LoadString before loops
     for (char c = 'A'; c <= 'Z'; c++) {
@@ -89,8 +89,8 @@ public class Main {
   // Explicit null check on receiver, implicit null check on argument prevents hoisting.
   //
   /// CHECK-START: int Main.indexOfExceptions(java.lang.String, java.lang.String) licm (after)
-  /// CHECK-DAG: <<String:l\d+>> NullCheck                                                         loop:<<Loop:B\d+>> outer_loop:none
-  /// CHECK-DAG:                 InvokeVirtual [<<String>>,{{l\d+}}] intrinsic:StringStringIndexOf loop:<<Loop>>      outer_loop:none
+  /// CHECK-DAG: <<String:l\d+>> NullCheck                                                                loop:<<Loop:B\d+>> outer_loop:none
+  /// CHECK-DAG:                 InvokeStaticOrDirect [<<String>>,{{l\d+}}] intrinsic:StringStringIndexOf loop:<<Loop>>      outer_loop:none
   static int indexOfExceptions(String s, String t) {
     int k = 0;
     for (char c = 'A'; c <= 'Z'; c++) {
@@ -234,17 +234,27 @@ public class Main {
   }
 
   //
-  // All calls in the loop-body and thus loop can be eliminated.
+  // All calls in the loop-body are dead and thus loop can be eliminated.
   //
-  /// CHECK-START: int Main.bufferDeadLoop() instruction_simplifier (before)
+  /// CHECK-START: int Main.bufferDeadLoop() dead_code_elimination$initial (before)
   /// CHECK-DAG: Phi                                              loop:<<Loop:B\d+>>
   /// CHECK-DAG: InvokeVirtual intrinsic:StringBufferToString     loop:<<Loop>>
   /// CHECK-DAG: InvokeVirtual intrinsic:StringStringIndexOfAfter loop:<<Loop>>
   //
+  /// CHECK-START: int Main.bufferDeadLoop() dead_code_elimination$initial (after)
+  /// CHECK-NOT: InvokeVirtual intrinsic:StringStringIndexOfAfter
+  //
+  /// CHECK-START: int Main.bufferDeadLoop() instruction_simplifier$after_inlining (before)
+  /// CHECK: InvokeStaticOrDirect intrinsic:StringBufferToString
+  //
+  /// CHECK-START: int Main.bufferDeadLoop() instruction_simplifier$after_inlining (after)
+  /// CHECK-NOT: InvokeStaticOrDirect intrinsic:StringBufferToString
+  //
+  /// CHECK-START: int Main.bufferDeadLoop() loop_optimization (before)
+  /// CHECK: Phi
+  //
   /// CHECK-START: int Main.bufferDeadLoop() loop_optimization (after)
   /// CHECK-NOT: Phi
-  /// CHECK-NOT: InvokeVirtual intrinsic:StringBufferToString
-  /// CHECK-NOT: InvokeVirtual intrinsic:StringStringIndexOfAfter
   static int bufferDeadLoop() {
     StringBuffer b = new StringBuffer();
     String x = "x";
@@ -255,7 +265,7 @@ public class Main {
   }
 
   //
-  // All calls in the loop-body and thus loop can be eliminated.
+  // All calls in the loop-body are dead and thus loop can be eliminated.
   //
   /// CHECK-START: int Main.builderDeadLoop() instruction_simplifier (before)
   /// CHECK-DAG: Phi                                              loop:<<Loop:B\d+>>
diff --git a/test/625-checker-licm-regressions/Android.bp b/test/625-checker-licm-regressions/Android.bp
index 95175b0c0f..f4484b9af7 100644
--- a/test/625-checker-licm-regressions/Android.bp
+++ b/test/625-checker-licm-regressions/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-625-checker-licm-regressions-expected-stdout",
         ":art-run-test-625-checker-licm-regressions-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/627-checker-unroll/Android.bp b/test/627-checker-unroll/Android.bp
index 1c2baca9d3..83f619efd3 100644
--- a/test/627-checker-unroll/Android.bp
+++ b/test/627-checker-unroll/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-627-checker-unroll-expected-stdout",
         ":art-run-test-627-checker-unroll-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/628-vdex/Android.bp b/test/628-vdex/Android.bp
index 7b768fc800..c5ae620527 100644
--- a/test/628-vdex/Android.bp
+++ b/test/628-vdex/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-628-vdex-expected-stdout",
         ":art-run-test-628-vdex-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/631-checker-get-class/Android.bp b/test/631-checker-get-class/Android.bp
index f08cfe0648..03d75bf73a 100644
--- a/test/631-checker-get-class/Android.bp
+++ b/test/631-checker-get-class/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-631-checker-get-class-expected-stdout",
         ":art-run-test-631-checker-get-class-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/632-checker-char-at-bounds/Android.bp b/test/632-checker-char-at-bounds/Android.bp
index d7f680a3c9..3f6fe96947 100644
--- a/test/632-checker-char-at-bounds/Android.bp
+++ b/test/632-checker-char-at-bounds/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-632-checker-char-at-bounds-expected-stdout",
         ":art-run-test-632-checker-char-at-bounds-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/635-checker-arm64-volatile-load-cc/Android.bp b/test/635-checker-arm64-volatile-load-cc/Android.bp
index 253abb1027..4ab74a43e8 100644
--- a/test/635-checker-arm64-volatile-load-cc/Android.bp
+++ b/test/635-checker-arm64-volatile-load-cc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-635-checker-arm64-volatile-load-cc-expected-stdout",
         ":art-run-test-635-checker-arm64-volatile-load-cc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/636-arm64-veneer-pool/Android.bp b/test/636-arm64-veneer-pool/Android.bp
index 9d8f7ccd19..16045f0286 100644
--- a/test/636-arm64-veneer-pool/Android.bp
+++ b/test/636-arm64-veneer-pool/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-636-arm64-veneer-pool-expected-stdout",
         ":art-run-test-636-arm64-veneer-pool-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/637-checker-throw-inline/Android.bp b/test/637-checker-throw-inline/Android.bp
index f44e64bcd7..9de3ae891d 100644
--- a/test/637-checker-throw-inline/Android.bp
+++ b/test/637-checker-throw-inline/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-637-checker-throw-inline-expected-stdout",
         ":art-run-test-637-checker-throw-inline-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/639-checker-code-sinking/Android.bp b/test/639-checker-code-sinking/Android.bp
index 7772a68eaa..b88763c205 100644
--- a/test/639-checker-code-sinking/Android.bp
+++ b/test/639-checker-code-sinking/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-639-checker-code-sinking-expected-stdout",
         ":art-run-test-639-checker-code-sinking-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/640-checker-boolean-simd/Android.bp b/test/640-checker-boolean-simd/Android.bp
index 89e6ac7ace..9b5cc57256 100644
--- a/test/640-checker-boolean-simd/Android.bp
+++ b/test/640-checker-boolean-simd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-640-checker-boolean-simd-expected-stdout",
         ":art-run-test-640-checker-boolean-simd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/640-checker-integer-valueof/Android.bp b/test/640-checker-integer-valueof/Android.bp
index aca0bb3b59..98a7992320 100644
--- a/test/640-checker-integer-valueof/Android.bp
+++ b/test/640-checker-integer-valueof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-640-checker-integer-valueof-expected-stdout",
         ":art-run-test-640-checker-integer-valueof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/640-checker-simd/Android.bp b/test/640-checker-simd/Android.bp
index 45d08854cf..591a06abaa 100644
--- a/test/640-checker-simd/Android.bp
+++ b/test/640-checker-simd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-640-checker-simd-expected-stdout",
         ":art-run-test-640-checker-simd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/641-checker-arraycopy/Android.bp b/test/641-checker-arraycopy/Android.bp
index fabb0fe96f..5c02f3980f 100644
--- a/test/641-checker-arraycopy/Android.bp
+++ b/test/641-checker-arraycopy/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-641-checker-arraycopy-expected-stdout",
         ":art-run-test-641-checker-arraycopy-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/641-iterations/Android.bp b/test/641-iterations/Android.bp
index be127bb3fe..1bd30bb88a 100644
--- a/test/641-iterations/Android.bp
+++ b/test/641-iterations/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-641-iterations-expected-stdout",
         ":art-run-test-641-iterations-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/643-checker-bogus-ic/Android.bp b/test/643-checker-bogus-ic/Android.bp
index ee2b7dc697..1ada4c20b1 100644
--- a/test/643-checker-bogus-ic/Android.bp
+++ b/test/643-checker-bogus-ic/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-643-checker-bogus-ic-expected-stdout",
         ":art-run-test-643-checker-bogus-ic-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/645-checker-abs-simd/Android.bp b/test/645-checker-abs-simd/Android.bp
index bf29f92e13..0579dc1ab4 100644
--- a/test/645-checker-abs-simd/Android.bp
+++ b/test/645-checker-abs-simd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-645-checker-abs-simd-expected-stdout",
         ":art-run-test-645-checker-abs-simd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/646-checker-arraycopy-large-cst-pos/Android.bp b/test/646-checker-arraycopy-large-cst-pos/Android.bp
index 983c9df0ca..601a2fc8bd 100644
--- a/test/646-checker-arraycopy-large-cst-pos/Android.bp
+++ b/test/646-checker-arraycopy-large-cst-pos/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-646-checker-arraycopy-large-cst-pos-expected-stdout",
         ":art-run-test-646-checker-arraycopy-large-cst-pos-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/646-checker-long-const-to-int/Android.bp b/test/646-checker-long-const-to-int/Android.bp
index be5cf75d15..295c1abb9c 100644
--- a/test/646-checker-long-const-to-int/Android.bp
+++ b/test/646-checker-long-const-to-int/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-646-checker-long-const-to-int-expected-stdout",
         ":art-run-test-646-checker-long-const-to-int-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/646-checker-simd-hadd/Android.bp b/test/646-checker-simd-hadd/Android.bp
index 12df43d5f1..dab5f0a385 100644
--- a/test/646-checker-simd-hadd/Android.bp
+++ b/test/646-checker-simd-hadd/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-646-checker-simd-hadd-expected-stdout",
         ":art-run-test-646-checker-simd-hadd-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/650-checker-inline-access-thunks/Android.bp b/test/650-checker-inline-access-thunks/Android.bp
index 2b98cce611..7a47397b37 100644
--- a/test/650-checker-inline-access-thunks/Android.bp
+++ b/test/650-checker-inline-access-thunks/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-650-checker-inline-access-thunks-expected-stdout",
         ":art-run-test-650-checker-inline-access-thunks-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/654-checker-periodic/Android.bp b/test/654-checker-periodic/Android.bp
index 79e38bb5ce..d92884fc75 100644
--- a/test/654-checker-periodic/Android.bp
+++ b/test/654-checker-periodic/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-654-checker-periodic-expected-stdout",
         ":art-run-test-654-checker-periodic-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/655-checker-simd-arm-opt/Android.bp b/test/655-checker-simd-arm-opt/Android.bp
index 50f18fedcd..f3d563c1b0 100644
--- a/test/655-checker-simd-arm-opt/Android.bp
+++ b/test/655-checker-simd-arm-opt/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-655-checker-simd-arm-opt-expected-stdout",
         ":art-run-test-655-checker-simd-arm-opt-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/656-checker-simd-opt/Android.bp b/test/656-checker-simd-opt/Android.bp
index 2b72352ffe..ef586f0211 100644
--- a/test/656-checker-simd-opt/Android.bp
+++ b/test/656-checker-simd-opt/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-656-checker-simd-opt-expected-stdout",
         ":art-run-test-656-checker-simd-opt-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/657-branches/Android.bp b/test/657-branches/Android.bp
index 70c422f6b1..58d1944845 100644
--- a/test/657-branches/Android.bp
+++ b/test/657-branches/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-657-branches-expected-stdout",
         ":art-run-test-657-branches-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/658-fp-read-barrier/Android.bp b/test/658-fp-read-barrier/Android.bp
index fdb2b35b7b..3e694cd197 100644
--- a/test/658-fp-read-barrier/Android.bp
+++ b/test/658-fp-read-barrier/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-658-fp-read-barrier-expected-stdout",
         ":art-run-test-658-fp-read-barrier-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/659-unpadded-array/Android.bp b/test/659-unpadded-array/Android.bp
index 05360117d8..2aa4f7b4a5 100644
--- a/test/659-unpadded-array/Android.bp
+++ b/test/659-unpadded-array/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-659-unpadded-array-expected-stdout",
         ":art-run-test-659-unpadded-array-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/660-checker-sad/Android.bp b/test/660-checker-sad/Android.bp
index 76b8c7bf33..231c76d548 100644
--- a/test/660-checker-sad/Android.bp
+++ b/test/660-checker-sad/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-660-checker-sad-expected-stdout",
         ":art-run-test-660-checker-sad-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/660-checker-simd-sad/Android.bp b/test/660-checker-simd-sad/Android.bp
index f751904c34..a89f1839bc 100644
--- a/test/660-checker-simd-sad/Android.bp
+++ b/test/660-checker-simd-sad/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-660-checker-simd-sad-expected-stdout",
         ":art-run-test-660-checker-simd-sad-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/661-checker-simd-cf-loops/Android.bp b/test/661-checker-simd-cf-loops/Android.bp
index 8d2c193c02..fb2ce49f45 100644
--- a/test/661-checker-simd-cf-loops/Android.bp
+++ b/test/661-checker-simd-cf-loops/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-661-checker-simd-cf-loops-expected-stdout",
         ":art-run-test-661-checker-simd-cf-loops-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/661-checker-simd-cf-loops/src/Main.java b/test/661-checker-simd-cf-loops/src/Main.java
index aee6c6a4f4..2089bda290 100644
--- a/test/661-checker-simd-cf-loops/src/Main.java
+++ b/test/661-checker-simd-cf-loops/src/Main.java
@@ -59,7 +59,7 @@ public class Main {
   ///     CHECK-DAG: <<LoopP:j\d+>>   VecPredWhile [<<Phi>>,{{i\d+}}]                       loop:<<Loop>>      outer_loop:none
   //
   ///     CHECK-DAG: <<Load1:d\d+>>   VecLoad [<<Arr:l\d+>>,<<Phi>>,<<LoopP>>]              loop:<<Loop>>      outer_loop:none
-  ///     CHECK-DAG: <<Cond:j\d+>>    VecCondition [<<Load1>>,<<Vec100>>,<<LoopP>>]         loop:<<Loop>>      outer_loop:none
+  ///     CHECK-DAG: <<Cond:j\d+>>    VecEqual [<<Load1>>,<<Vec100>>,<<LoopP>>]             loop:<<Loop>>      outer_loop:none
   ///     CHECK-DAG: <<CondR:j\d+>>   VecPredNot [<<Cond>>,<<LoopP>>]                       loop:<<Loop>>      outer_loop:none
   ///     CHECK-DAG: <<AddT:d\d+>>    VecAdd [<<Load1>>,<<Vec99>>,<<CondR>>]                loop:<<Loop>>      outer_loop:none
   ///     CHECK-DAG: <<StT:d\d+>>     VecStore [<<Arr>>,<<Phi>>,<<AddT>>,<<CondR>>]         loop:<<Loop>>      outer_loop:none
@@ -289,18 +289,45 @@ public class Main {
   // Test condition types.
   //
 
-  /// CHECK-START-ARM64: void Main.$compile$noinline$SimpleBelow(int[]) loop_optimization (after)
+  /// CHECK-START-ARM64: void Main.$compile$noinline$SimpleCondition(int[]) loop_optimization (before)
+  //
+  ///     CHECK-DAG: <<C0:i\d+>>      IntConstant 0                                                           loop:none
+  ///     CHECK-DAG: <<C100:i\d+>>    IntConstant 100                                                         loop:none
+  ///     CHECK-DAG: <<C199:i\d+>>    IntConstant 199                                                         loop:none
+  //
+  ///     CHECK-DAG: <<Phi:i\d+>>     Phi [<<C0>>,{{i\d+}}]                                                   loop:<<Loop:B\d+>>
+  ///     CHECK-DAG: <<Load:i\d+>>    ArrayGet [<<Arr:l\d+>>,<<Phi>>]                                         loop:<<Loop>>
+  ///     CHECK-DAG: <<Cond:z\d+>>    NotEqual [<<Load>>,<<C100>>]                                            loop:<<Loop>>
+  ///     CHECK-DAG:                  If [<<Cond>>]                                                           loop:<<Loop>>
+  //
+  ///     CHECK-DAG:                  ArraySet [<<Arr>>,<<Phi>>,<<C199>>]                                     loop:<<Loop>>
+  //
+  /// CHECK-START-ARM64: void Main.$compile$noinline$SimpleCondition(int[]) loop_optimization (after)
   /// CHECK-IF:     hasIsaFeature("sve") and os.environ.get('ART_FORCE_TRY_PREDICATED_SIMD') == 'true'
   //
-  ///     CHECK-NOT: VecLoad
+  ///     CHECK-DAG: <<C0:i\d+>>      IntConstant 0                                                           loop:none
+  ///     CHECK-DAG: <<C100:i\d+>>    IntConstant 100                                                         loop:none
+  ///     CHECK-DAG: <<C199:i\d+>>    IntConstant 199                                                         loop:none
+  //
+  ///     CHECK-DAG: <<Vec100:d\d+>>  VecReplicateScalar [<<C100>>,{{j\d+}}]           packed_type:Int32      loop:none
+  ///     CHECK-DAG: <<Vec199:d\d+>>  VecReplicateScalar [<<C199>>,{{j\d+}}]           packed_type:Int32      loop:none
+  //
+  ///     CHECK-DAG: <<Phi:i\d+>>     Phi [<<C0>>,{{i\d+}}]                                                   loop:<<Loop:B\d+>>
+  ///     CHECK-DAG: <<LoopP:j\d+>>   VecPredWhile [<<Phi>>,{{i\d+}}]                                         loop:<<Loop>>
+  //
+  ///     CHECK-DAG: <<Load:d\d+>>    VecLoad [<<Arr:l\d+>>,<<Phi>>,<<LoopP>>]         packed_type:Int32      loop:<<Loop>>
+  ///     CHECK-DAG: <<Cond:j\d+>>    VecNotEqual [<<Load>>,<<Vec100>>,<<LoopP>>]      packed_type:Int32      loop:<<Loop>>
+  ///     CHECK-DAG: <<CondR:j\d+>>   VecPredNot [<<Cond>>,<<LoopP>>]                  packed_type:Int32      loop:<<Loop>>
+  ///     CHECK-DAG:                  VecStore [<<Arr>>,<<Phi>>,<<Vec199>>,<<CondR>>]  packed_type:Int32      loop:<<Loop>>
   //
   /// CHECK-FI:
   //
-  // TODO: Support other conditions.
-  public static void $compile$noinline$SimpleBelow(int[] x) {
+  // Example of a condition being vectorized. See loop_optimization_test.cc and codegen_test.cc for
+  // full testing of vector conditions.
+  public static void $compile$noinline$SimpleCondition(int[] x) {
     for (int i = 0; i < USED_ARRAY_LENGTH; i++) {
       int val = x[i];
-      if (val < MAGIC_VALUE_C) {
+      if (val == MAGIC_VALUE_C) {
         x[i] += MAGIC_ADD_CONST;
       }
     }
@@ -450,6 +477,44 @@ public class Main {
     }
   }
 
+  //
+  // Non-condition if statements.
+  //
+
+  /// CHECK-START-ARM64: void Main.$compile$noinline$SingleBoolean(int[], boolean) loop_optimization (after)
+  /// CHECK-IF:     hasIsaFeature("sve") and os.environ.get('ART_FORCE_TRY_PREDICATED_SIMD') == 'true'
+  //
+  ///     CHECK-NOT: VecLoad
+  //
+  /// CHECK-FI:
+  //
+  // Check that single boolean if statements are not vectorized because only binary condition if
+  // statements are supported.
+  public static void $compile$noinline$SingleBoolean(int[] x, boolean y) {
+    for (int i = 0; i < USED_ARRAY_LENGTH; i++) {
+      if (y) {
+        x[i] += MAGIC_ADD_CONST;
+      }
+    }
+  }
+
+  /// CHECK-START-ARM64: void Main.$compile$noinline$InstanceOf(int[], java.lang.Object) loop_optimization (after)
+  /// CHECK-IF:     hasIsaFeature("sve") and os.environ.get('ART_FORCE_TRY_PREDICATED_SIMD') == 'true'
+  //
+  ///     CHECK-NOT: VecLoad
+  //
+  /// CHECK-FI:
+  //
+  // Check that control flow without a condition is not vectorized because only binary condition if
+  // statements are supported.
+  public static void $compile$noinline$InstanceOf(int[] x, Object y) {
+    for (int i = 0; i < USED_ARRAY_LENGTH; i++) {
+      if (y instanceof Main) {
+        x[i] += MAGIC_ADD_CONST;
+      }
+    }
+  }
+
   //
   // Main driver.
   //
@@ -513,8 +578,8 @@ public class Main {
 
     // Conditions.
     initIntArray(intArray);
-    $compile$noinline$SimpleBelow(intArray);
-    expectIntEquals(23121, IntArraySum(intArray));
+    $compile$noinline$SimpleCondition(intArray);
+    expectIntEquals(18864, IntArraySum(intArray));
 
     // Idioms.
     initIntArray(intArray);
@@ -552,6 +617,16 @@ public class Main {
     $compile$noinline$BrokenInduction(intArray);
     expectIntEquals(18963, IntArraySum(intArray));
 
+    // Non-condition if statements.
+    initIntArray(intArray);
+    $compile$noinline$SingleBoolean(intArray, true);
+    expectIntEquals(27279, IntArraySum(intArray));
+
+    initIntArray(intArray);
+    Main instance = new Main();
+    $compile$noinline$InstanceOf(intArray, instance);
+    expectIntEquals(27279, IntArraySum(intArray));
+
     System.out.println("passed");
   }
 
diff --git a/test/661-checker-simd-reduc/Android.bp b/test/661-checker-simd-reduc/Android.bp
index 65e00c7eea..61dbfd52c2 100644
--- a/test/661-checker-simd-reduc/Android.bp
+++ b/test/661-checker-simd-reduc/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-661-checker-simd-reduc-expected-stdout",
         ":art-run-test-661-checker-simd-reduc-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/661-oat-writer-layout/expected-stdout.txt b/test/661-oat-writer-layout/expected-stdout.txt
index b7ad70a985..cc6d526fe2 100644
--- a/test/661-oat-writer-layout/expected-stdout.txt
+++ b/test/661-oat-writer-layout/expected-stdout.txt
@@ -1,22 +1,13 @@
 JNI_OnLoad called
-A::m_a$$$
-A::m_b$$$
-A::m_c$$$
-B::m_a$$$
-B::m_b$$$
-B::m_c$$$
-C::m_a$$$
-C::m_b$$$
-C::m_c$$$
-A::m_a$$Startup$
-A::m_b$$Startup$
-A::m_c$$Startup$
-B::m_a$$Startup$
-B::m_b$$Startup$
-B::m_c$$Startup$
-C::m_a$$Startup$
-C::m_b$$Startup$
-C::m_c$$Startup$
+A::m_a$Hot$Startup$Poststartup
+A::m_b$Hot$Startup$Poststartup
+A::m_c$Hot$Startup$Poststartup
+B::m_a$Hot$Startup$Poststartup
+B::m_b$Hot$Startup$Poststartup
+B::m_c$Hot$Startup$Poststartup
+C::m_a$Hot$Startup$Poststartup
+C::m_b$Hot$Startup$Poststartup
+C::m_c$Hot$Startup$Poststartup
 A::m_a$Hot$Startup$
 A::m_b$Hot$Startup$
 A::m_c$Hot$Startup$
@@ -26,24 +17,6 @@ B::m_c$Hot$Startup$
 C::m_a$Hot$Startup$
 C::m_b$Hot$Startup$
 C::m_c$Hot$Startup$
-A::m_a$$$Poststartup
-A::m_b$$$Poststartup
-A::m_c$$$Poststartup
-B::m_a$$$Poststartup
-B::m_b$$$Poststartup
-B::m_c$$$Poststartup
-C::m_a$$$Poststartup
-C::m_b$$$Poststartup
-C::m_c$$$Poststartup
-A::m_a$Hot$$Poststartup
-A::m_b$Hot$$Poststartup
-A::m_c$Hot$$Poststartup
-B::m_a$Hot$$Poststartup
-B::m_b$Hot$$Poststartup
-B::m_c$Hot$$Poststartup
-C::m_a$Hot$$Poststartup
-C::m_b$Hot$$Poststartup
-C::m_c$Hot$$Poststartup
 A::m_a$$Startup$Poststartup
 A::m_b$$Startup$Poststartup
 A::m_c$$Startup$Poststartup
@@ -53,12 +26,39 @@ B::m_c$$Startup$Poststartup
 C::m_a$$Startup$Poststartup
 C::m_b$$Startup$Poststartup
 C::m_c$$Startup$Poststartup
-A::m_a$Hot$Startup$Poststartup
-A::m_b$Hot$Startup$Poststartup
-A::m_c$Hot$Startup$Poststartup
-B::m_a$Hot$Startup$Poststartup
-B::m_b$Hot$Startup$Poststartup
-B::m_c$Hot$Startup$Poststartup
-C::m_a$Hot$Startup$Poststartup
-C::m_b$Hot$Startup$Poststartup
-C::m_c$Hot$Startup$Poststartup
+A::m_a$$Startup$
+A::m_b$$Startup$
+A::m_c$$Startup$
+B::m_a$$Startup$
+B::m_b$$Startup$
+B::m_c$$Startup$
+C::m_a$$Startup$
+C::m_b$$Startup$
+C::m_c$$Startup$
+A::m_a$Hot$$Poststartup
+A::m_b$Hot$$Poststartup
+A::m_c$Hot$$Poststartup
+B::m_a$Hot$$Poststartup
+B::m_b$Hot$$Poststartup
+B::m_c$Hot$$Poststartup
+C::m_a$Hot$$Poststartup
+C::m_b$Hot$$Poststartup
+C::m_c$Hot$$Poststartup
+A::m_a$$$Poststartup
+A::m_b$$$Poststartup
+A::m_c$$$Poststartup
+B::m_a$$$Poststartup
+B::m_b$$$Poststartup
+B::m_c$$$Poststartup
+C::m_a$$$Poststartup
+C::m_b$$$Poststartup
+C::m_c$$$Poststartup
+A::m_a$$$
+A::m_b$$$
+A::m_c$$$
+B::m_a$$$
+B::m_b$$$
+B::m_c$$$
+C::m_a$$$
+C::m_b$$$
+C::m_c$$$
diff --git a/test/662-regression-alias/Android.bp b/test/662-regression-alias/Android.bp
index 7d38415cc4..6b9407349f 100644
--- a/test/662-regression-alias/Android.bp
+++ b/test/662-regression-alias/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-662-regression-alias-expected-stdout",
         ":art-run-test-662-regression-alias-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/663-checker-select-generator/Android.bp b/test/663-checker-select-generator/Android.bp
index c6b9087c81..0c3af98a20 100644
--- a/test/663-checker-select-generator/Android.bp
+++ b/test/663-checker-select-generator/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-663-checker-select-generator-expected-stdout",
         ":art-run-test-663-checker-select-generator-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/665-checker-simd-zero/Android.bp b/test/665-checker-simd-zero/Android.bp
index 23e9f0988f..8f921f711e 100644
--- a/test/665-checker-simd-zero/Android.bp
+++ b/test/665-checker-simd-zero/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-665-checker-simd-zero-expected-stdout",
         ":art-run-test-665-checker-simd-zero-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/666-dex-cache-itf/Android.bp b/test/666-dex-cache-itf/Android.bp
index f7f27f68ba..1b13975f1a 100644
--- a/test/666-dex-cache-itf/Android.bp
+++ b/test/666-dex-cache-itf/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-666-dex-cache-itf-expected-stdout",
         ":art-run-test-666-dex-cache-itf-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/667-checker-simd-alignment/Android.bp b/test/667-checker-simd-alignment/Android.bp
index 0426aac25f..2e23174ec7 100644
--- a/test/667-checker-simd-alignment/Android.bp
+++ b/test/667-checker-simd-alignment/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-667-checker-simd-alignment-expected-stdout",
         ":art-run-test-667-checker-simd-alignment-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/667-out-of-bounds/Android.bp b/test/667-out-of-bounds/Android.bp
index 97185960f9..8e0ead23a7 100644
--- a/test/667-out-of-bounds/Android.bp
+++ b/test/667-out-of-bounds/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-667-out-of-bounds-expected-stdout",
         ":art-run-test-667-out-of-bounds-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/669-checker-break/Android.bp b/test/669-checker-break/Android.bp
index 0eb41a281a..6b69db19f0 100644
--- a/test/669-checker-break/Android.bp
+++ b/test/669-checker-break/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-669-checker-break-expected-stdout",
         ":art-run-test-669-checker-break-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/671-npe-field-opts/Android.bp b/test/671-npe-field-opts/Android.bp
index 4fbdd961f0..a4997fa718 100644
--- a/test/671-npe-field-opts/Android.bp
+++ b/test/671-npe-field-opts/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-671-npe-field-opts-expected-stdout",
         ":art-run-test-671-npe-field-opts-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/672-checker-throw-method/Android.bp b/test/672-checker-throw-method/Android.bp
index 612b37f4df..7e4a4fd9ae 100644
--- a/test/672-checker-throw-method/Android.bp
+++ b/test/672-checker-throw-method/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-672-checker-throw-method-expected-stdout",
         ":art-run-test-672-checker-throw-method-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/672-checker-throw-method/src/Main.java b/test/672-checker-throw-method/src/Main.java
index c2344b23e8..f149536e1d 100644
--- a/test/672-checker-throw-method/src/Main.java
+++ b/test/672-checker-throw-method/src/Main.java
@@ -55,7 +55,7 @@ public class Main {
   /// CHECK:                If [<<Tst>>]
   /// CHECK: end_block
   /// CHECK: begin_block
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   //
@@ -66,7 +66,7 @@ public class Main {
   /// CHECK: end_block
   /// CHECK: begin_block
   /// CHECK:   <<Str:l\d+>> LoadString
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   static public void doit1(int[] a) {
@@ -117,7 +117,7 @@ public class Main {
   /// CHECK:                If [<<Tst>>]
   /// CHECK: end_block
   /// CHECK: begin_block
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   //
@@ -128,7 +128,7 @@ public class Main {
   /// CHECK: end_block
   /// CHECK: begin_block
   /// CHECK:   <<Str:l\d+>> LoadString
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   static public void doit3(int[] a) {
diff --git a/test/673-checker-throw-vmethod/Android.bp b/test/673-checker-throw-vmethod/Android.bp
index bfbccc492e..12a7c6f768 100644
--- a/test/673-checker-throw-vmethod/Android.bp
+++ b/test/673-checker-throw-vmethod/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-673-checker-throw-vmethod-expected-stdout",
         ":art-run-test-673-checker-throw-vmethod-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/673-checker-throw-vmethod/src/Main.java b/test/673-checker-throw-vmethod/src/Main.java
index 39793001f0..dcffcabf51 100644
--- a/test/673-checker-throw-vmethod/src/Main.java
+++ b/test/673-checker-throw-vmethod/src/Main.java
@@ -49,7 +49,7 @@ public class Main {
   /// CHECK:                If [<<Tst>>]
   /// CHECK: end_block
   /// CHECK: begin_block
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   //
@@ -60,7 +60,7 @@ public class Main {
   /// CHECK: end_block
   /// CHECK: begin_block
   /// CHECK:   <<Str:l\d+>> LoadString
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   public void doit1(int[] a) {
@@ -111,7 +111,7 @@ public class Main {
   /// CHECK:                If [<<Tst>>]
   /// CHECK: end_block
   /// CHECK: begin_block
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   //
@@ -122,7 +122,7 @@ public class Main {
   /// CHECK: end_block
   /// CHECK: begin_block
   /// CHECK:   <<Str:l\d+>> LoadString
-  /// CHECK:                InvokeVirtual [{{l\d+}},<<Str>>]
+  /// CHECK:                InvokeStaticOrDirect [{{l\d+}},<<Str>>] method_name:java.lang.StringBuilder.append
   /// CHECK:                Throw
   /// CHECK: end_block
   public void doit3(int[] a) {
diff --git a/test/674-hiddenapi/src-art/Main.java b/test/674-hiddenapi/src-art/Main.java
index bfde4f78e3..5a1b89b0eb 100644
--- a/test/674-hiddenapi/src-art/Main.java
+++ b/test/674-hiddenapi/src-art/Main.java
@@ -156,6 +156,7 @@ public class Main {
         (addAllApisToSdk ? "1" : "0"));
     File tempFile = new File(System.getenv("DEX_LOCATION"), tempFileName);
     Files.copy(new File(nativeLibFileName).toPath(), tempFile.toPath());
+    tempFile.setWritable(false);
     return tempFile.getAbsolutePath();
   }
 
diff --git a/test/676-proxy-jit-at-first-use/Android.bp b/test/676-proxy-jit-at-first-use/Android.bp
index f8ab7bbdf4..9b1288e504 100644
--- a/test/676-proxy-jit-at-first-use/Android.bp
+++ b/test/676-proxy-jit-at-first-use/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-676-proxy-jit-at-first-use-expected-stdout",
         ":art-run-test-676-proxy-jit-at-first-use-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/677-fsi2/Android.bp b/test/677-fsi2/Android.bp
index c95c227bcd..a55a3c1439 100644
--- a/test/677-fsi2/Android.bp
+++ b/test/677-fsi2/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-677-fsi2-expected-stdout",
         ":art-run-test-677-fsi2-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/678-quickening/Android.bp b/test/678-quickening/Android.bp
index 2dcb19c087..cb8498e8d2 100644
--- a/test/678-quickening/Android.bp
+++ b/test/678-quickening/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-678-quickening-expected-stdout",
         ":art-run-test-678-quickening-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/684-checker-simd-dotprod/Android.bp b/test/684-checker-simd-dotprod/Android.bp
index 1410e9186c..fcd8a8be9a 100644
--- a/test/684-checker-simd-dotprod/Android.bp
+++ b/test/684-checker-simd-dotprod/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-684-checker-simd-dotprod-expected-stdout",
         ":art-run-test-684-checker-simd-dotprod-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/684-select-condition/Android.bp b/test/684-select-condition/Android.bp
index 4360d5ddbe..031d151064 100644
--- a/test/684-select-condition/Android.bp
+++ b/test/684-select-condition/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-684-select-condition-expected-stdout",
         ":art-run-test-684-select-condition-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/689-multi-catch/Android.bp b/test/689-multi-catch/Android.bp
index 3dbf0fb04b..e544eaee0c 100644
--- a/test/689-multi-catch/Android.bp
+++ b/test/689-multi-catch/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-689-multi-catch-expected-stdout",
         ":art-run-test-689-multi-catch-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/692-vdex-inmem-loader/vdex_inmem_loader.cc b/test/692-vdex-inmem-loader/vdex_inmem_loader.cc
index 8152435212..919107eb63 100644
--- a/test/692-vdex-inmem-loader/vdex_inmem_loader.cc
+++ b/test/692-vdex-inmem-loader/vdex_inmem_loader.cc
@@ -59,9 +59,9 @@ extern "C" JNIEXPORT jboolean JNICALL Java_Main_areClassesVerified(JNIEnv*,
   bool all_verified = false;
   for (const DexFile* dex_file : dex_files) {
     for (uint16_t cdef_idx = 0; cdef_idx < dex_file->NumClassDefs(); ++cdef_idx) {
-      const char* desc = dex_file->GetClassDescriptor(dex_file->GetClassDef(cdef_idx));
-      h_class.Assign(class_linker->FindClass(soa.Self(), desc, h_loader));
-      CHECK(h_class != nullptr) << "Could not find class " << desc;
+      dex::TypeIndex type_idx = dex_file->GetClassDef(cdef_idx).class_idx_;
+      h_class.Assign(class_linker->FindClass(soa.Self(), *dex_file, type_idx, h_loader));
+      CHECK(h_class != nullptr) << "Could not find class " << dex_file->GetTypeDescriptor(type_idx);
       bool is_verified = h_class->IsVerified();
       if (is_first) {
         all_verified = is_verified;
@@ -95,7 +95,7 @@ extern "C" JNIEXPORT bool JNICALL Java_Main_hasVdexFile(JNIEnv*,
   std::string odex_filename;
   std::string error_msg;
   if (!OatFileAssistant::DexLocationToOdexFilename(dex_location,
-                                                   kRuntimeISA,
+                                                   kRuntimeQuickCodeISA,
                                                    &odex_filename,
                                                    &error_msg)) {
     LOG(WARNING) << "Could not get odex filename for " << dex_location << ": " << error_msg;
@@ -155,9 +155,9 @@ extern "C" JNIEXPORT jboolean JNICALL Java_Main_areClassesPreverified(JNIEnv*,
   bool all_preverified = false;
   for (const DexFile* dex_file : dex_files) {
     for (uint16_t cdef_idx = 0; cdef_idx < dex_file->NumClassDefs(); ++cdef_idx) {
-      const char* desc = dex_file->GetClassDescriptor(dex_file->GetClassDef(cdef_idx));
-      h_class.Assign(class_linker->FindClass(soa.Self(), desc, h_loader));
-      CHECK(h_class != nullptr) << "Could not find class " << desc;
+      dex::TypeIndex type_idx = dex_file->GetClassDef(cdef_idx).class_idx_;
+      h_class.Assign(class_linker->FindClass(soa.Self(), *dex_file, type_idx, h_loader));
+      CHECK(h_class != nullptr) << "Could not find class " << dex_file->GetTypeDescriptor(type_idx);
 
       ClassStatus oat_file_class_status(ClassStatus::kNotReady);
       bool is_preverified = class_linker->VerifyClassUsingOatFile(
diff --git a/test/694-clinit-jit/Android.bp b/test/694-clinit-jit/Android.bp
index 2f25ec063f..c4408d77a1 100644
--- a/test/694-clinit-jit/Android.bp
+++ b/test/694-clinit-jit/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-694-clinit-jit-expected-stdout",
         ":art-run-test-694-clinit-jit-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/695-simplify-throws/Android.bp b/test/695-simplify-throws/Android.bp
index d6d7c7c303..22948eb7b2 100644
--- a/test/695-simplify-throws/Android.bp
+++ b/test/695-simplify-throws/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-695-simplify-throws-expected-stdout",
         ":art-run-test-695-simplify-throws-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/696-loop/Android.bp b/test/696-loop/Android.bp
index b39271f034..09e48c0076 100644
--- a/test/696-loop/Android.bp
+++ b/test/696-loop/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-696-loop-expected-stdout",
         ":art-run-test-696-loop-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/697-checker-string-append/Android.bp b/test/697-checker-string-append/Android.bp
index 767e97023f..6e9d3d8e06 100644
--- a/test/697-checker-string-append/Android.bp
+++ b/test/697-checker-string-append/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-697-checker-string-append-expected-stdout",
         ":art-run-test-697-checker-string-append-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/698-selects/Android.bp b/test/698-selects/Android.bp
index a3be249bb0..e0a9eec4a2 100644
--- a/test/698-selects/Android.bp
+++ b/test/698-selects/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-698-selects-expected-stdout",
         ":art-run-test-698-selects-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/700-LoadArgRegs/Android.bp b/test/700-LoadArgRegs/Android.bp
index bbaa28d645..26472ce613 100644
--- a/test/700-LoadArgRegs/Android.bp
+++ b/test/700-LoadArgRegs/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-700-LoadArgRegs-expected-stdout",
         ":art-run-test-700-LoadArgRegs-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/703-floating-point-div/Android.bp b/test/703-floating-point-div/Android.bp
index 42ae166875..dd8a012ff8 100644
--- a/test/703-floating-point-div/Android.bp
+++ b/test/703-floating-point-div/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-703-floating-point-div-expected-stdout",
         ":art-run-test-703-floating-point-div-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/704-multiply-accumulate/Android.bp b/test/704-multiply-accumulate/Android.bp
index 3cd5ba18ea..838768a2fb 100644
--- a/test/704-multiply-accumulate/Android.bp
+++ b/test/704-multiply-accumulate/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-704-multiply-accumulate-expected-stdout",
         ":art-run-test-704-multiply-accumulate-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/705-register-conflict/Android.bp b/test/705-register-conflict/Android.bp
index 6182c2f329..6304d4a630 100644
--- a/test/705-register-conflict/Android.bp
+++ b/test/705-register-conflict/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-705-register-conflict-expected-stdout",
         ":art-run-test-705-register-conflict-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/711-checker-type-conversion/Android.bp b/test/711-checker-type-conversion/Android.bp
index f9ae9d0574..c09233cfae 100644
--- a/test/711-checker-type-conversion/Android.bp
+++ b/test/711-checker-type-conversion/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-711-checker-type-conversion-expected-stdout",
         ":art-run-test-711-checker-type-conversion-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/713-varhandle-invokers/Android.bp b/test/713-varhandle-invokers/Android.bp
index 8719d381cd..0507df592f 100644
--- a/test/713-varhandle-invokers/Android.bp
+++ b/test/713-varhandle-invokers/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-713-varhandle-invokers-expected-stdout",
         ":art-run-test-713-varhandle-invokers-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/718-zipfile-finalizer/Android.bp b/test/718-zipfile-finalizer/Android.bp
index ed1dc66a3a..5019a9a8dd 100644
--- a/test/718-zipfile-finalizer/Android.bp
+++ b/test/718-zipfile-finalizer/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-718-zipfile-finalizer-expected-stdout",
         ":art-run-test-718-zipfile-finalizer-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/719-varhandle-concurrency/Android.bp b/test/719-varhandle-concurrency/Android.bp
index 4c9f46534d..f26f0ab275 100644
--- a/test/719-varhandle-concurrency/Android.bp
+++ b/test/719-varhandle-concurrency/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-719-varhandle-concurrency-expected-stdout",
         ":art-run-test-719-varhandle-concurrency-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/721-osr/Android.bp b/test/721-osr/Android.bp
index 22aa0c3e07..91601700dc 100644
--- a/test/721-osr/Android.bp
+++ b/test/721-osr/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-721-osr-expected-stdout",
         ":art-run-test-721-osr-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/726-array-store/Android.bp b/test/726-array-store/Android.bp
index dc6cc2432f..0918f14687 100644
--- a/test/726-array-store/Android.bp
+++ b/test/726-array-store/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-726-array-store-expected-stdout",
         ":art-run-test-726-array-store-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/730-checker-inlining-super/Android.bp b/test/730-checker-inlining-super/Android.bp
index 8247b65948..2de61c5950 100644
--- a/test/730-checker-inlining-super/Android.bp
+++ b/test/730-checker-inlining-super/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-730-checker-inlining-super-expected-stdout",
         ":art-run-test-730-checker-inlining-super-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/731-bounds-check-slow-path/Android.bp b/test/731-bounds-check-slow-path/Android.bp
index bc9e84b431..8427a2822b 100644
--- a/test/731-bounds-check-slow-path/Android.bp
+++ b/test/731-bounds-check-slow-path/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-731-bounds-check-slow-path-expected-stdout",
         ":art-run-test-731-bounds-check-slow-path-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/800-smali/expected-stdout.txt b/test/800-smali/expected-stdout.txt
index fbf10bbfc3..6054dea28d 100644
--- a/test/800-smali/expected-stdout.txt
+++ b/test/800-smali/expected-stdout.txt
@@ -67,7 +67,8 @@ b/27799205 (3)
 b/27799205 (4)
 b/27799205 (5)
 b/27799205 (6)
-b/28187158
+b/28187158 (1)
+b/28187158 (2)
 b/29778499 (1)
 b/29778499 (2)
 b/30458218
diff --git a/test/800-smali/smali/b_28187158_2.smali b/test/800-smali/smali/b_28187158_2.smali
new file mode 100644
index 0000000000..244e553818
--- /dev/null
+++ b/test/800-smali/smali/b_28187158_2.smali
@@ -0,0 +1,20 @@
+.class public LB28187158_2;
+
+# Regression test for iget with unresolved class.
+
+.super Ljava/lang/Object;
+
+.field public f:I
+
+.method public static run()V
+   .registers 1
+   const/4 v0, 0
+   invoke-static {v0}, LB28187158_2;->test(Ljava/lang/DoesNotExist;)V
+   return-void
+.end method
+
+.method public static test(Ljava/lang/DoesNotExist;)V
+   .registers 2
+   iget v0, p0, LB28187158_2;->f:I
+   return-void
+.end method
diff --git a/test/800-smali/smali/b_28187158_2Helper.smali b/test/800-smali/smali/b_28187158_2Helper.smali
new file mode 100644
index 0000000000..27ff3332bd
--- /dev/null
+++ b/test/800-smali/smali/b_28187158_2Helper.smali
@@ -0,0 +1,9 @@
+.class public LB28187158_2Helper;
+
+.super Ljava/lang/Object;
+
+.method public static run()V
+   .registers 0
+   invoke-static {}, LB28187158_2;->run()V
+   return-void
+.end method
diff --git a/test/800-smali/src/Main.java b/test/800-smali/src/Main.java
index 06d24d8c56..99230fa7af 100644
--- a/test/800-smali/src/Main.java
+++ b/test/800-smali/src/Main.java
@@ -183,8 +183,10 @@ public class Main {
         testCases.add(new TestCase("b/27799205 (5)", "B27799205Helper", "run5", null,
                 new VerifyError(), null));
         testCases.add(new TestCase("b/27799205 (6)", "B27799205Helper", "run6", null, null, null));
-        testCases.add(new TestCase("b/28187158", "B28187158", "run", new Object[] { null },
+        testCases.add(new TestCase("b/28187158 (1)", "B28187158", "run", new Object[] { null },
                 new VerifyError(), null));
+        testCases.add(new TestCase("b/28187158 (2)", "B28187158_2Helper", "run", null,
+                new NullPointerException(), null));
         testCases.add(new TestCase("b/29778499 (1)", "B29778499_1", "run", null,
                 new IncompatibleClassChangeError(), null));
         testCases.add(new TestCase("b/29778499 (2)", "B29778499_2", "run", null,
diff --git a/test/805-TooDeepClassInstanceOf/Android.bp b/test/805-TooDeepClassInstanceOf/Android.bp
index 878f126f22..baf547c669 100644
--- a/test/805-TooDeepClassInstanceOf/Android.bp
+++ b/test/805-TooDeepClassInstanceOf/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-805-TooDeepClassInstanceOf-expected-stdout",
         ":art-run-test-805-TooDeepClassInstanceOf-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/806-TooWideClassInstanceOf/Android.bp b/test/806-TooWideClassInstanceOf/Android.bp
index bdff81282d..2c7eee816c 100644
--- a/test/806-TooWideClassInstanceOf/Android.bp
+++ b/test/806-TooWideClassInstanceOf/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-806-TooWideClassInstanceOf-expected-stdout",
         ":art-run-test-806-TooWideClassInstanceOf-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/812-recursive-default/Android.bp b/test/812-recursive-default/Android.bp
index 9c2fe2c0d0..92641fb9d6 100644
--- a/test/812-recursive-default/Android.bp
+++ b/test/812-recursive-default/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-812-recursive-default-expected-stdout",
         ":art-run-test-812-recursive-default-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/814-large-field-offsets/Android.bp b/test/814-large-field-offsets/Android.bp
index e3193a876f..55f66f8b17 100644
--- a/test/814-large-field-offsets/Android.bp
+++ b/test/814-large-field-offsets/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-814-large-field-offsets-expected-stdout",
         ":art-run-test-814-large-field-offsets-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/815-invokeinterface-default/Android.bp b/test/815-invokeinterface-default/Android.bp
index 9981b02659..69868b7cc3 100644
--- a/test/815-invokeinterface-default/Android.bp
+++ b/test/815-invokeinterface-default/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-815-invokeinterface-default-expected-stdout",
         ":art-run-test-815-invokeinterface-default-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/817-hiddenapi/src-art/Main.java b/test/817-hiddenapi/src-art/Main.java
index b83327e7ab..6c46deadb1 100644
--- a/test/817-hiddenapi/src-art/Main.java
+++ b/test/817-hiddenapi/src-art/Main.java
@@ -73,6 +73,7 @@ public class Main {
     String tempFileName = System.mapLibraryName("hiddenapitest");
     File tempFile = new File(System.getenv("DEX_LOCATION"), tempFileName);
     Files.copy(new File(nativeLibFileName).toPath(), tempFile.toPath());
+    tempFile.setWritable(false);
     return tempFile.getAbsolutePath();
   }
 
diff --git a/test/818-clinit-nterp/Android.bp b/test/818-clinit-nterp/Android.bp
index f168de3693..a18c1ff2d1 100644
--- a/test/818-clinit-nterp/Android.bp
+++ b/test/818-clinit-nterp/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-818-clinit-nterp-expected-stdout",
         ":art-run-test-818-clinit-nterp-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/821-madvise-willneed/Android.bp b/test/821-madvise-willneed/Android.bp
index 86e883cbfa..317caec647 100644
--- a/test/821-madvise-willneed/Android.bp
+++ b/test/821-madvise-willneed/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-821-madvise-willneed-expected-stdout",
         ":art-run-test-821-madvise-willneed-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/828-partial-lse/Android.bp b/test/828-partial-lse/Android.bp
index a336150fc6..38adf221d2 100644
--- a/test/828-partial-lse/Android.bp
+++ b/test/828-partial-lse/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-828-partial-lse-expected-stdout",
         ":art-run-test-828-partial-lse-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/834-lse/Android.bp b/test/834-lse/Android.bp
index 3d44972411..265dcb3789 100644
--- a/test/834-lse/Android.bp
+++ b/test/834-lse/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-834-lse-expected-stdout",
         ":art-run-test-834-lse-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/835-b216762268/Android.bp b/test/835-b216762268/Android.bp
index a68f2ed042..799245c1a3 100644
--- a/test/835-b216762268/Android.bp
+++ b/test/835-b216762268/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-835-b216762268-expected-stdout",
         ":art-run-test-835-b216762268-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/838-override/Android.bp b/test/838-override/Android.bp
index 2ac4e210ce..ebdc31097a 100644
--- a/test/838-override/Android.bp
+++ b/test/838-override/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-838-override-expected-stdout",
         ":art-run-test-838-override-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/839-clinit-throw/Android.bp b/test/839-clinit-throw/Android.bp
index dad79f0aa2..c650aae415 100644
--- a/test/839-clinit-throw/Android.bp
+++ b/test/839-clinit-throw/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-839-clinit-throw-expected-stdout",
         ":art-run-test-839-clinit-throw-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/841-defaults/Android.bp b/test/841-defaults/Android.bp
index 2d2fce6a75..1dcba308ff 100644
--- a/test/841-defaults/Android.bp
+++ b/test/841-defaults/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-841-defaults-expected-stdout",
         ":art-run-test-841-defaults-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/843-default-interface/Android.bp b/test/843-default-interface/Android.bp
index 417166fec0..64ad0fa7a6 100644
--- a/test/843-default-interface/Android.bp
+++ b/test/843-default-interface/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-843-default-interface-expected-stdout",
         ":art-run-test-843-default-interface-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/851-null-instanceof/Android.bp b/test/851-null-instanceof/Android.bp
index 42efaaac13..3054eb0b61 100644
--- a/test/851-null-instanceof/Android.bp
+++ b/test/851-null-instanceof/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-851-null-instanceof-expected-stdout",
         ":art-run-test-851-null-instanceof-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/853-checker-inlining/Android.bp b/test/853-checker-inlining/Android.bp
index f0938558a4..79d6e2eddf 100644
--- a/test/853-checker-inlining/Android.bp
+++ b/test/853-checker-inlining/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-853-checker-inlining-expected-stdout",
         ":art-run-test-853-checker-inlining-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
     // Include the Java source files in the test's artifacts, to make Checker assertions
     // available to the TradeFed test runner.
     include_srcs: true,
diff --git a/test/856-clone/Android.bp b/test/856-clone/Android.bp
index 00e47b727b..e80d0e3e74 100644
--- a/test/856-clone/Android.bp
+++ b/test/856-clone/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-856-clone-expected-stdout",
         ":art-run-test-856-clone-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/857-default-access/Android.bp b/test/857-default-access/Android.bp
index 48e21b9f77..060d18fd97 100644
--- a/test/857-default-access/Android.bp
+++ b/test/857-default-access/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-857-default-access-expected-stdout",
         ":art-run-test-857-default-access-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/858-checker-unsafe/Android.bp b/test/858-checker-unsafe/Android.bp
new file mode 100644
index 0000000000..da1b8977e9
--- /dev/null
+++ b/test/858-checker-unsafe/Android.bp
@@ -0,0 +1,46 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `858-checker-unsafe`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-858-checker-unsafe",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-858-checker-unsafe-expected-stdout",
+        ":art-run-test-858-checker-unsafe-expected-stderr",
+    ],
+    test_suites: [
+        "mts-art",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-858-checker-unsafe-expected-stdout",
+    out: ["art-run-test-858-checker-unsafe-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-858-checker-unsafe-expected-stderr",
+    out: ["art-run-test-858-checker-unsafe-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/858-checker-unsafe/src/Main.java b/test/858-checker-unsafe/src/Main.java
index dbd96a7ac9..772cadb87e 100644
--- a/test/858-checker-unsafe/src/Main.java
+++ b/test/858-checker-unsafe/src/Main.java
@@ -39,6 +39,7 @@ public class Main {
     testPutFixedOffset();
     assertEquals(0, testGet());
     assertEquals(42, testGetFar());
+    testGetAndPutAbsoluteAddress();
   }
 
   /// CHECK-START-ARM64: void Main.testPutZero() disassembly (after)
@@ -87,4 +88,29 @@ public class Main {
   private static int testArrayBaseOffsetDouble() {
     return unsafe.arrayBaseOffset(double[].class);
   }
+
+  private static void testGetAndPutAbsoluteAddress() {
+    long address = 0;
+    try {
+      address = unsafe.allocateMemory(4);
+      $noinline$unsafePutAbsoluteInt(address, 0xDEADBEEF);
+      assertEquals(0xDEADBEEF, $noinline$unsafeGetAbsoluteInt(address));
+    } finally {
+      if (address != 0) {
+        unsafe.freeMemory(address);
+      }
+    }
+  }
+
+  /// CHECK-START: void Main.$noinline$unsafePutAbsoluteInt(long, int) builder (after)
+  /// CHECK:                  InvokeVirtual intrinsic:UnsafePutAbsolute
+  private static void $noinline$unsafePutAbsoluteInt(long address, int value) {
+    unsafe.putInt(address, value);
+  }
+
+  /// CHECK-START: int Main.$noinline$unsafeGetAbsoluteInt(long) builder (after)
+  /// CHECK:                  InvokeVirtual intrinsic:UnsafeGetAbsolute
+  private static int $noinline$unsafeGetAbsoluteInt(long address) {
+    return unsafe.getInt(address);
+  }
 }
diff --git a/test/859-checker-var-handles-intrinsics/Android.bp b/test/859-checker-var-handles-intrinsics/Android.bp
new file mode 100644
index 0000000000..7a31a1d290
--- /dev/null
+++ b/test/859-checker-var-handles-intrinsics/Android.bp
@@ -0,0 +1,46 @@
+// Generated by `regen-test-files`. Do not edit manually.
+
+// Build rules for ART run-test `859-checker-var-handles-intrinsics`.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "art_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["art_license"],
+}
+
+// Test's Dex code.
+java_test {
+    name: "art-run-test-859-checker-var-handles-intrinsics",
+    defaults: ["art-run-test-defaults"],
+    test_config_template: ":art-run-test-target-template",
+    srcs: ["src/**/*.java"],
+    data: [
+        ":art-run-test-859-checker-var-handles-intrinsics-expected-stdout",
+        ":art-run-test-859-checker-var-handles-intrinsics-expected-stderr",
+    ],
+    test_suites: [
+        "mts-art",
+    ],
+    // Include the Java source files in the test's artifacts, to make Checker assertions
+    // available to the TradeFed test runner.
+    include_srcs: true,
+}
+
+// Test's expected standard output.
+genrule {
+    name: "art-run-test-859-checker-var-handles-intrinsics-expected-stdout",
+    out: ["art-run-test-859-checker-var-handles-intrinsics-expected-stdout.txt"],
+    srcs: ["expected-stdout.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
+
+// Test's expected standard error.
+genrule {
+    name: "art-run-test-859-checker-var-handles-intrinsics-expected-stderr",
+    out: ["art-run-test-859-checker-var-handles-intrinsics-expected-stderr.txt"],
+    srcs: ["expected-stderr.txt"],
+    cmd: "cp -f $(in) $(out)",
+}
diff --git a/test/859-checker-var-handles-intrinsics/expected-stderr.txt b/test/859-checker-var-handles-intrinsics/expected-stderr.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/859-checker-var-handles-intrinsics/expected-stdout.txt b/test/859-checker-var-handles-intrinsics/expected-stdout.txt
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/859-checker-var-handles-intrinsics/info.txt b/test/859-checker-var-handles-intrinsics/info.txt
new file mode 100644
index 0000000000..5b8f9eb3c5
--- /dev/null
+++ b/test/859-checker-var-handles-intrinsics/info.txt
@@ -0,0 +1,3 @@
+Test that we successfully intrinsify VarHandle's getAndUpdate intrinsics
+when the return value is ignored by the VarHandle call specifying a void
+return type.
diff --git a/test/859-checker-var-handles-intrinsics/src/Main.java b/test/859-checker-var-handles-intrinsics/src/Main.java
new file mode 100644
index 0000000000..350d3d4a7a
--- /dev/null
+++ b/test/859-checker-var-handles-intrinsics/src/Main.java
@@ -0,0 +1,735 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+
+public class Main {
+    public static void main(String[] args) {
+        // Since the tests will share a value, we have the condition that the value starts
+        // and ends as 0 before and after each test.
+
+        // Int tests
+        $noinline$testGetAndAdd_Int();
+        $noinline$testGetAndSet_Int();
+        $noinline$testGetAndBitwiseAnd_Int();
+        $noinline$testGetAndBitwiseOr_Int();
+        $noinline$testGetAndBitwiseXor_Int();
+
+        // Long tests
+        $noinline$testGetAndAdd_Long();
+        $noinline$testGetAndSet_Long();
+        $noinline$testGetAndBitwiseAnd_Long();
+        $noinline$testGetAndBitwiseOr_Long();
+        $noinline$testGetAndBitwiseXor_Long();
+
+        // Float tests
+        $noinline$testGetAndAdd_Float();
+        $noinline$testGetAndSet_Float();
+
+        // Double tests
+        $noinline$testGetAndAdd_Double();
+        $noinline$testGetAndSet_Double();
+    }
+
+    private static void $noinline$testGetAndAdd_Int() {
+        Main m = new Main();
+        // 0 + 100 = 100
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+        m.$noinline$getAndAdd_Int(100);
+        $noinline$assertIntEquals(100, (int) INT_VALUE.get(m));
+
+        // 100 - 100 = 0
+        m.$noinline$getAndAdd_Int(-100);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndSet_Int() {
+        Main m = new Main();
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+        m.$noinline$getAndSet_Int(100);
+        $noinline$assertIntEquals(100, (int) INT_VALUE.get(m));
+
+        m.$noinline$getAndSet_Int(-100);
+        $noinline$assertIntEquals(-100, (int) INT_VALUE.get(m));
+
+        m.$noinline$getAndSet_Int(0);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseAnd_Int() {
+        Main m = new Main();
+        // 0 AND X = 0
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+        m.$noinline$getAndBitwiseAnd_Int(100);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+
+        // 10101010 AND
+        // 11001100 =
+        // 10001000
+        m.$noinline$getAndSet_Int(0b10101010);
+        m.$noinline$getAndBitwiseAnd_Int(0b11001100);
+        $noinline$assertIntEquals(0b10001000, (int) INT_VALUE.get(m));
+
+        // 10001000 AND
+        // 11111111 =
+        // 10001000
+        m.$noinline$getAndBitwiseAnd_Int(0b11111111);
+        $noinline$assertIntEquals(0b10001000, (int) INT_VALUE.get(m));
+
+        // 10001000 AND
+        // 01110111 =
+        // 0
+        m.$noinline$getAndBitwiseAnd_Int(0b01110111);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseOr_Int() {
+        Main m = new Main();
+
+        // 0 OR X = X
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+        m.$noinline$getAndBitwiseOr_Int(0b10101010);
+        $noinline$assertIntEquals(0b10101010, (int) INT_VALUE.get(m));
+
+        // 10101010 OR
+        // 01010101 =
+        // 11111111
+        m.$noinline$getAndBitwiseOr_Int(0b01010101);
+        $noinline$assertIntEquals(0b11111111, (int) INT_VALUE.get(m));
+
+        // 11111111 OR
+        // 0 =
+        // 11111111
+        m.$noinline$getAndBitwiseOr_Int(0);
+        $noinline$assertIntEquals(0b11111111, (int) INT_VALUE.get(m));
+
+        // Set to 0 due to precondition. See comment in main.
+        m.$noinline$getAndSet_Int(0);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseXor_Int() {
+        Main m = new Main();
+
+        // 0 XOR X = X
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+        m.$noinline$getAndBitwiseXor_Int(0b10101010);
+        $noinline$assertIntEquals(0b10101010, (int) INT_VALUE.get(m));
+
+        // 10101010 XOR
+        // 01010101 =
+        // 11111111
+        m.$noinline$getAndBitwiseXor_Int(0b01010101);
+        $noinline$assertIntEquals(0b11111111, (int) INT_VALUE.get(m));
+
+        // 11111111 XOR
+        // 01010101 =
+        // 10101010
+        m.$noinline$getAndBitwiseXor_Int(0b01010101);
+        $noinline$assertIntEquals(0b10101010, (int) INT_VALUE.get(m));
+
+        // X XOR X = 0
+        m.$noinline$getAndBitwiseXor_Int(0b10101010);
+        $noinline$assertIntEquals(0, (int) INT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndAdd_Long() {
+        Main m = new Main();
+        // 0 + 100 = 100
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+        m.$noinline$getAndAdd_Long(100);
+        $noinline$assertLongEquals(100L, (long) LONG_VALUE.get(m));
+
+        // 100 - 100 = 0
+        m.$noinline$getAndAdd_Long(-100);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndSet_Long() {
+        Main m = new Main();
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+        m.$noinline$getAndSet_Long(100);
+        $noinline$assertLongEquals(100L, (long) LONG_VALUE.get(m));
+
+        m.$noinline$getAndSet_Long(-100);
+        $noinline$assertLongEquals(-100L, (long) LONG_VALUE.get(m));
+
+        m.$noinline$getAndSet_Long(0);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseAnd_Long() {
+        Main m = new Main();
+        // 0 AND X = 0
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+        m.$noinline$getAndBitwiseAnd_Long(100);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+
+        // 10101010 AND
+        // 11001100 =
+        // 10001000
+        m.$noinline$getAndSet_Long(0b10101010);
+        m.$noinline$getAndBitwiseAnd_Long(0b11001100);
+        $noinline$assertLongEquals(0b10001000L, (long) LONG_VALUE.get(m));
+
+        // 10001000 AND
+        // 11111111 =
+        // 10001000
+        m.$noinline$getAndBitwiseAnd_Long(0b11111111);
+        $noinline$assertLongEquals(0b10001000L, (long) LONG_VALUE.get(m));
+
+        // 10001000 AND
+        // 01110111 =
+        // 0
+        m.$noinline$getAndBitwiseAnd_Long(0b01110111);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseOr_Long() {
+        Main m = new Main();
+
+        // 0 OR X = X
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+        m.$noinline$getAndBitwiseOr_Long(0b10101010);
+        $noinline$assertLongEquals(0b10101010L, (long) LONG_VALUE.get(m));
+
+        // 10101010 OR
+        // 01010101 =
+        // 11111111
+        m.$noinline$getAndBitwiseOr_Long(0b01010101);
+        $noinline$assertLongEquals(0b11111111L, (long) LONG_VALUE.get(m));
+
+        // 11111111 OR
+        // 0 =
+        // 11111111
+        m.$noinline$getAndBitwiseOr_Long(0);
+        $noinline$assertLongEquals(0b11111111L, (long) LONG_VALUE.get(m));
+
+        // Set to 0 due to precondition. See comment in main.
+        m.$noinline$getAndSet_Long(0);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndBitwiseXor_Long() {
+        Main m = new Main();
+
+        // 0 XOR X = X
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+        m.$noinline$getAndBitwiseXor_Long(0b10101010);
+        $noinline$assertLongEquals(0b10101010L, (long) LONG_VALUE.get(m));
+
+        // 10101010 XOR
+        // 01010101 =
+        // 11111111
+        m.$noinline$getAndBitwiseXor_Long(0b01010101);
+        $noinline$assertLongEquals(0b11111111L, (long) LONG_VALUE.get(m));
+
+        // 11111111 XOR
+        // 01010101 =
+        // 10101010
+        m.$noinline$getAndBitwiseXor_Long(0b01010101);
+        $noinline$assertLongEquals(0b10101010L, (long) LONG_VALUE.get(m));
+
+        // X XOR X = 0
+        m.$noinline$getAndBitwiseXor_Long(0b10101010);
+        $noinline$assertLongEquals(0L, (long) LONG_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndAdd_Float() {
+        Main m = new Main();
+        // 0 + 100 = 100
+        $noinline$assertFloatEquals(0.0f, (float) FLOAT_VALUE.get(m));
+        m.$noinline$getAndAdd_Float(100.0f);
+        $noinline$assertFloatEquals(100.0f, (float) FLOAT_VALUE.get(m));
+
+        // 100 - 100 = 0
+        m.$noinline$getAndAdd_Float(-100.0f);
+        $noinline$assertFloatEquals(0.0f, (float) FLOAT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndSet_Float() {
+        Main m = new Main();
+        $noinline$assertFloatEquals(0.0f, (float) FLOAT_VALUE.get(m));
+        m.$noinline$getAndSet_Float(100.0f);
+        $noinline$assertFloatEquals(100.0f, (float) FLOAT_VALUE.get(m));
+
+        m.$noinline$getAndSet_Float(-100.0f);
+        $noinline$assertFloatEquals(-100.0f, (float) FLOAT_VALUE.get(m));
+
+        m.$noinline$getAndSet_Float(0.0f);
+        $noinline$assertFloatEquals(0.0f, (float) FLOAT_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndAdd_Double() {
+        Main m = new Main();
+        // 0 + 100 = 100
+        $noinline$assertDoubleEquals(0.0d, (double) DOUBLE_VALUE.get(m));
+        m.$noinline$getAndAdd_Double(100.0d);
+        $noinline$assertDoubleEquals(100.0d, (double) DOUBLE_VALUE.get(m));
+
+        // 100 - 100 = 0
+        m.$noinline$getAndAdd_Double(-100.0d);
+        $noinline$assertDoubleEquals(0.0d, (double) DOUBLE_VALUE.get(m));
+    }
+
+    private static void $noinline$testGetAndSet_Double() {
+        Main m = new Main();
+        $noinline$assertDoubleEquals(0.0d, (double) DOUBLE_VALUE.get(m));
+        m.$noinline$getAndSet_Double(100.0d);
+        $noinline$assertDoubleEquals(100.0d, (double) DOUBLE_VALUE.get(m));
+
+        m.$noinline$getAndSet_Double(-100.0d);
+        $noinline$assertDoubleEquals(-100.0d, (double) DOUBLE_VALUE.get(m));
+
+        m.$noinline$getAndSet_Double(0.0d);
+        $noinline$assertDoubleEquals(0.0d, (double) DOUBLE_VALUE.get(m));
+    }
+
+    // VarHandles
+    private volatile int int_value = 0;
+    private static final VarHandle INT_VALUE;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            INT_VALUE = l.findVarHandle(Main.class, "int_value", int.class);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private volatile long long_value = 0L;
+    private static final VarHandle LONG_VALUE;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            LONG_VALUE = l.findVarHandle(Main.class, "long_value", long.class);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private volatile float float_value = 0.0f;
+    private static final VarHandle FLOAT_VALUE;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            FLOAT_VALUE = l.findVarHandle(Main.class, "float_value", float.class);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private volatile double double_value = 0.0d;
+    private static final VarHandle DOUBLE_VALUE;
+    static {
+        try {
+            MethodHandles.Lookup l = MethodHandles.lookup();
+            DOUBLE_VALUE = l.findVarHandle(Main.class, "double_value", double.class);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    // Check that we successfully intrinsify intrinsics (e.g. getAndAdd) by checking that there's no
+    // call to the runtime.
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndAdd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndAdd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndAdd_Int(int value) {
+        INT_VALUE.getAndAdd(this, value);
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndSet_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndSet_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndSet_Int(int value) {
+        INT_VALUE.getAndSet(this, value);
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndBitwiseAnd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseAnd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseAnd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseAnd_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseAnd_Int(int value) {
+        INT_VALUE.getAndBitwiseAnd(this, value);
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndBitwiseOr_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseOr_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseOr_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseOr_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseOr_Int(int value) {
+        INT_VALUE.getAndBitwiseOr(this, value);
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndBitwiseXor_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseXor_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseXor_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseXor_Int(int) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseXor_Int(int value) {
+        INT_VALUE.getAndBitwiseXor(this, value);
+    }
+
+    private static void $noinline$assertIntEquals(int expected, int result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+
+    // Note that the Long ones do a call for X86.
+    // TODO(solanes): Add this support.
+
+    /// CHECK-START-X86: void Main.$noinline$getAndAdd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndAdd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndAdd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndAdd_Long(long value) {
+        LONG_VALUE.getAndAdd(this, value);
+    }
+
+    /// CHECK-START-X86: void Main.$noinline$getAndSet_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndSet_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndSet_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndSet_Long(long value) {
+        LONG_VALUE.getAndSet(this, value);
+    }
+
+    /// CHECK-START-X86: void Main.$noinline$getAndBitwiseAnd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndBitwiseAnd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseAnd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseAnd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseAnd_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseAnd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseAnd_Long(long value) {
+        LONG_VALUE.getAndBitwiseAnd(this, value);
+    }
+
+    /// CHECK-START-X86: void Main.$noinline$getAndBitwiseOr_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndBitwiseOr_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseOr_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseOr_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseOr_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseOr
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseOr_Long(long value) {
+        LONG_VALUE.getAndBitwiseOr(this, value);
+    }
+
+    /// CHECK-START-X86: void Main.$noinline$getAndBitwiseXor_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndBitwiseXor_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseXor_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndBitwiseXor_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndBitwiseXor_Long(long) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndBitwiseXor
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndBitwiseXor_Long(long value) {
+        LONG_VALUE.getAndBitwiseXor(this, value);
+    }
+
+    private static void $noinline$assertLongEquals(long expected, long result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndAdd_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndAdd_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndAdd_Float(float value) {
+        FLOAT_VALUE.getAndAdd(this, value);
+    }
+
+    /// CHECK-START-{X86,X86_64}: void Main.$noinline$getAndSet_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndSet_Float(float) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndSet_Float(float value) {
+        FLOAT_VALUE.getAndSet(this, value);
+    }
+
+    private static void $noinline$assertFloatEquals(float expected, float result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+
+    // Note that the Double ones do a call for X86.
+    // TODO(solanes): Add this support.
+
+    /// CHECK-START-X86: void Main.$noinline$getAndAdd_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndAdd_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndAdd_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndAdd_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndAdd
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndAdd_Double(double value) {
+        DOUBLE_VALUE.getAndAdd(this, value);
+    }
+
+    /// CHECK-START-X86: void Main.$noinline$getAndSet_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK:     call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-X86_64: void Main.$noinline$getAndSet_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: call
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blx
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-ARM64: void Main.$noinline$getAndSet_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: blr
+    /// CHECK:     ReturnVoid
+
+    /// CHECK-START-RISCV64: void Main.$noinline$getAndSet_Double(double) disassembly (after)
+    /// CHECK:     InvokePolymorphic intrinsic:VarHandleGetAndSet
+    /// CHECK-NOT: jalr
+    /// CHECK:     ReturnVoid
+    private void $noinline$getAndSet_Double(double value) {
+        DOUBLE_VALUE.getAndSet(this, value);
+    }
+
+    private static void $noinline$assertDoubleEquals(double expected, double result) {
+        if (expected != result) {
+            throw new Error("Expected: " + expected + ", found: " + result);
+        }
+    }
+}
diff --git a/test/912-classes/expected-stdout.txt b/test/912-classes/expected-stdout.txt
index 9f09823c70..5ce834eff7 100644
--- a/test/912-classes/expected-stdout.txt
+++ b/test/912-classes/expected-stdout.txt
@@ -20,10 +20,10 @@ java.util.ArrayList interface=false array=false modifiable=true
 [I interface=false array=true modifiable=false
 [Ljava.lang.Runnable; interface=false array=true modifiable=false
 [Ljava.lang.String; interface=false array=true modifiable=false
-[public static final int java.lang.Integer.BYTES, static final byte[] java.lang.Integer.DigitOnes, static final byte[] java.lang.Integer.DigitTens, public static final int java.lang.Integer.MAX_VALUE, public static final int java.lang.Integer.MIN_VALUE, public static final int java.lang.Integer.SIZE, private static final java.lang.String[] java.lang.Integer.SMALL_NEG_VALUES, private static final java.lang.String[] java.lang.Integer.SMALL_NONNEG_VALUES, public static final java.lang.Class java.lang.Integer.TYPE, static final char[] java.lang.Integer.digits, private static final long java.lang.Integer.serialVersionUID, static final int[] java.lang.Integer.sizeTable, private final int java.lang.Integer.value]
+[public static final int java.lang.Integer.BYTES, static final byte[] java.lang.Integer.DigitOnes, static final byte[] java.lang.Integer.DigitTens, public static final int java.lang.Integer.MAX_VALUE, public static final int java.lang.Integer.MIN_VALUE, public static final int java.lang.Integer.SIZE, private static final java.lang.String[] java.lang.Integer.SMALL_NEG_VALUES, private static final java.lang.String[] java.lang.Integer.SMALL_NONNEG_VALUES, public static final java.lang.Class java.lang.Integer.TYPE, static final char[] java.lang.Integer.digits, private static final long java.lang.Integer.serialVersionUID, private final int java.lang.Integer.value]
 []
 []
-[java.lang.Integer(), public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.bitCount(int), public static int java.lang.Integer.compare(int,int), public static int java.lang.Integer.compareUnsigned(int,int), public static java.lang.Integer java.lang.Integer.decode(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.divideUnsigned(int,int), private static void java.lang.Integer.formatUnsignedInt(int,int,byte[],int), static void java.lang.Integer.formatUnsignedInt(int,int,byte[],int,int), static void java.lang.Integer.formatUnsignedInt(int,int,char[],int,int), static int java.lang.Integer.getChars(int,int,byte[]), static int java.lang.Integer.getChars(int,int,char[]), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String,int), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String,java.lang.Integer), public static int java.lang.Integer.hashCode(int), public static int java.lang.Integer.highestOneBit(int), public static int java.lang.Integer.lowestOneBit(int), public static int java.lang.Integer.max(int,int), public static int java.lang.Integer.min(int,int), public static int java.lang.Integer.numberOfLeadingZeros(int), public static int java.lang.Integer.numberOfTrailingZeros(int), public static int java.lang.Integer.parseInt(java.lang.CharSequence,int,int,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseInt(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseInt(java.lang.String,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.CharSequence,int,int,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.String,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.remainderUnsigned(int,int), public static int java.lang.Integer.reverse(int), public static int java.lang.Integer.reverseBytes(int), public static int java.lang.Integer.rotateLeft(int,int), public static int java.lang.Integer.rotateRight(int,int), public static int java.lang.Integer.signum(int), static int java.lang.Integer.stringSize(int), public static int java.lang.Integer.sum(int,int), public static java.lang.String java.lang.Integer.toBinaryString(int), public static java.lang.String java.lang.Integer.toHexString(int), public static java.lang.String java.lang.Integer.toOctalString(int), public static java.lang.String java.lang.Integer.toString(int), public static java.lang.String java.lang.Integer.toString(int,int), public static long java.lang.Integer.toUnsignedLong(int), public static java.lang.String java.lang.Integer.toUnsignedString(int), public static java.lang.String java.lang.Integer.toUnsignedString(int,int), private static java.lang.String java.lang.Integer.toUnsignedString0(int,int), public static java.lang.Integer java.lang.Integer.valueOf(int), public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String) throws java.lang.NumberFormatException, public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String,int) throws java.lang.NumberFormatException, public byte java.lang.Integer.byteValue(), public int java.lang.Integer.compareTo(java.lang.Integer), public int java.lang.Integer.compareTo(java.lang.Object), public java.util.Optional java.lang.Integer.describeConstable(), public double java.lang.Integer.doubleValue(), public boolean java.lang.Integer.equals(java.lang.Object), public float java.lang.Integer.floatValue(), public int java.lang.Integer.hashCode(), public int java.lang.Integer.intValue(), public long java.lang.Integer.longValue(), public java.lang.Integer java.lang.Integer.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup), public java.lang.Object java.lang.Integer.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException, public short java.lang.Integer.shortValue(), public java.lang.String java.lang.Integer.toString()]
+[java.lang.Integer(), public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.bitCount(int), public static int java.lang.Integer.compare(int,int), public static int java.lang.Integer.compareUnsigned(int,int), public static int java.lang.Integer.compress(int,int), public static java.lang.Integer java.lang.Integer.decode(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.divideUnsigned(int,int), public static int java.lang.Integer.expand(int,int), private static void java.lang.Integer.formatUnsignedInt(int,int,byte[],int), static void java.lang.Integer.formatUnsignedInt(int,int,byte[],int,int), static void java.lang.Integer.formatUnsignedInt(int,int,char[],int,int), static int java.lang.Integer.getChars(int,int,byte[]), static int java.lang.Integer.getChars(int,int,char[]), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String,int), public static java.lang.Integer java.lang.Integer.getInteger(java.lang.String,java.lang.Integer), public static int java.lang.Integer.hashCode(int), public static int java.lang.Integer.highestOneBit(int), public static int java.lang.Integer.lowestOneBit(int), public static int java.lang.Integer.max(int,int), public static int java.lang.Integer.min(int,int), public static int java.lang.Integer.numberOfLeadingZeros(int), public static int java.lang.Integer.numberOfTrailingZeros(int), private static int java.lang.Integer.parallelSuffix(int), public static int java.lang.Integer.parseInt(java.lang.CharSequence,int,int,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseInt(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseInt(java.lang.String,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.CharSequence,int,int,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.String) throws java.lang.NumberFormatException, public static int java.lang.Integer.parseUnsignedInt(java.lang.String,int) throws java.lang.NumberFormatException, public static int java.lang.Integer.remainderUnsigned(int,int), public static int java.lang.Integer.reverse(int), public static int java.lang.Integer.reverseBytes(int), public static int java.lang.Integer.rotateLeft(int,int), public static int java.lang.Integer.rotateRight(int,int), public static int java.lang.Integer.signum(int), static int java.lang.Integer.stringSize(int), public static int java.lang.Integer.sum(int,int), public static java.lang.String java.lang.Integer.toBinaryString(int), public static java.lang.String java.lang.Integer.toHexString(int), public static java.lang.String java.lang.Integer.toOctalString(int), public static java.lang.String java.lang.Integer.toString(int), public static java.lang.String java.lang.Integer.toString(int,int), public static long java.lang.Integer.toUnsignedLong(int), public static java.lang.String java.lang.Integer.toUnsignedString(int), public static java.lang.String java.lang.Integer.toUnsignedString(int,int), private static java.lang.String java.lang.Integer.toUnsignedString0(int,int), public static java.lang.Integer java.lang.Integer.valueOf(int), public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String) throws java.lang.NumberFormatException, public static java.lang.Integer java.lang.Integer.valueOf(java.lang.String,int) throws java.lang.NumberFormatException, public byte java.lang.Integer.byteValue(), public int java.lang.Integer.compareTo(java.lang.Integer), public int java.lang.Integer.compareTo(java.lang.Object), public java.util.Optional java.lang.Integer.describeConstable(), public double java.lang.Integer.doubleValue(), public boolean java.lang.Integer.equals(java.lang.Object), public float java.lang.Integer.floatValue(), public int java.lang.Integer.hashCode(), public int java.lang.Integer.intValue(), public long java.lang.Integer.longValue(), public java.lang.Integer java.lang.Integer.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup), public java.lang.Object java.lang.Integer.resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException, public short java.lang.Integer.shortValue(), public java.lang.String java.lang.Integer.toString()]
 []
 []
 int 100000
diff --git a/test/913-heaps/expected-stdout.txt b/test/913-heaps/expected-stdout.txt
index e7a372aa10..7d3622305a 100644
--- a/test/913-heaps/expected-stdout.txt
+++ b/test/913-heaps/expected-stdout.txt
@@ -1,6 +1,6 @@
 ---
 true true
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=8,location= 31])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=0,location= 31])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 1001@0 --(superclass)--> 1000@0 [size=123456780000, length=-1]
@@ -45,8 +45,7 @@ root@root --(jni-global)--> 1@1000 [size=16, length=-1]
 root@root --(jni-local[id=1,tag=3000,depth=0,method=followReferences])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=10,location= 8])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=5,location= 8])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=13,location= 20])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=4,location= 20])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=5,location= 20])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 1001@0 --(superclass)--> 1000@0 [size=123456780005, length=-1]
@@ -95,7 +94,7 @@ root@root --(thread)--> 3000@0 [size=120, length=-1]
 ---
 3@1001 --(class)--> 1001@0 [size=123456780016, length=-1]
 ---
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=8,location= 31])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=0,location= 31])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 ---
@@ -108,8 +107,7 @@ root@root --(jni-global)--> 1@1000 [size=16, length=-1]
 root@root --(jni-local[id=1,tag=3000,depth=0,method=followReferences])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=10,location= 8])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=5,location= 8])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=13,location= 20])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=4,location= 20])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=5,location= 20])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 ---
@@ -153,7 +151,7 @@ root@root --(thread)--> 3000@0 [size=120, length=-1]
 10007@0 (instance, float, index=13) 000000003f9d70a4
 10008
 --- klass ---
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=8,location= 31])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=0,location= 31])--> 1@1000 [size=16, length=-1]
 1@1000 --(field@2)--> 2@1000 [size=16, length=-1]
 3@1001 --(field@4)--> 4@1000 [size=16, length=-1]
 500@0 --(array-element@1)--> 2@1000 [size=16, length=-1]
@@ -170,8 +168,7 @@ root@root --(jni-global)--> 1@1000 [size=16, length=-1]
 root@root --(jni-local[id=1,tag=3000,depth=0,method=followReferences])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=10,location= 8])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=5,location= 8])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=13,location= 20])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=4,location= 20])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=5,location= 20])--> 1@1000 [size=16, length=-1]
 1@1000 --(field@2)--> 2@1000 [size=16, length=-1]
 3@1001 --(field@4)--> 4@1000 [size=16, length=-1]
 500@0 --(array-element@1)--> 2@1000 [size=16, length=-1]
@@ -191,7 +188,7 @@ root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot
 ---
 ---
 ---- untagged objects
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=8,location= 31])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=0,location= 31])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 1001@0 --(superclass)--> 1000@0 [size=123456780050, length=-1]
@@ -236,8 +233,7 @@ root@root --(jni-global)--> 1@1000 [size=16, length=-1]
 root@root --(jni-local[id=1,tag=3000,depth=0,method=followReferences])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=10,location= 8])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=5,location= 8])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=13,location= 20])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=4,location= 20])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=5,location= 20])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=5,method=run,vreg=2,location= 0])--> 3000@0 [size=120, length=-1]
 root@root --(thread)--> 3000@0 [size=120, length=-1]
 1001@0 --(superclass)--> 1000@0 [size=123456780055, length=-1]
@@ -332,7 +328,7 @@ root@root --(thread)--> 3000@0 [size=120, length=-1]
 6@1000 --(class)--> 1000@0 [size=123456780065, length=-1]
 ---
 ---- untagged classes
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=8,location= 31])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestNonRoot,vreg=0,location= 31])--> 1@1000 [size=16, length=-1]
 1@1000 --(field@2)--> 2@1000 [size=16, length=-1]
 1@1000 --(field@3)--> 3@1001 [size=24, length=-1]
 3@1001 --(field@4)--> 4@1000 [size=16, length=-1]
@@ -353,8 +349,7 @@ root@root --(jni-global)--> 1@1000 [size=16, length=-1]
 root@root --(jni-local[id=1,tag=3000,depth=0,method=followReferences])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=10,location= 8])--> 1@1000 [size=16, length=-1]
 root@root --(stack-local[id=1,tag=3000,depth=1,method=doFollowReferencesTestImpl,vreg=5,location= 8])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=13,location= 20])--> 1@1000 [size=16, length=-1]
-root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=4,location= 20])--> 1@1000 [size=16, length=-1]
+root@root --(stack-local[id=1,tag=3000,depth=2,method=doFollowReferencesTestRoot,vreg=5,location= 20])--> 1@1000 [size=16, length=-1]
 1@1000 --(field@2)--> 2@1000 [size=16, length=-1]
 1@1000 --(field@3)--> 3@1001 [size=24, length=-1]
 3@1001 --(field@4)--> 4@1000 [size=16, length=-1]
diff --git a/test/918-fields/src/art/Test918.java b/test/918-fields/src/art/Test918.java
index 966c093215..7d8050e453 100644
--- a/test/918-fields/src/art/Test918.java
+++ b/test/918-fields/src/art/Test918.java
@@ -64,7 +64,15 @@ public class Test918 {
     private static native int getFieldModifiers(Field f);
     private static native boolean isFieldSynthetic(Field f);
 
-    private class Foo {}
+    private class Foo {
+        public void inc() {
+            // Touch a field in the outer class. Needed to avoid a javac optimization which removes
+            // the synthetic field that refers to the instance of the outer class (this$0).
+            fooVal++;
+        }
+    }
+
+    private int fooVal = 0;
 
     private static interface Bar {
         public static int VAL = 1;
diff --git a/test/950-redefine-intrinsic/src/Main.java b/test/950-redefine-intrinsic/src/Main.java
index dd59192b40..de8178b52b 100644
--- a/test/950-redefine-intrinsic/src/Main.java
+++ b/test/950-redefine-intrinsic/src/Main.java
@@ -85,6 +85,17 @@ public class Main {
   //     public static long reverse(long i) {
   //       return -i;
   //     }
+  //     /** @hide  */
+  //     public static long compress(long i, long mask) {
+  //       return -1;
+  //     }
+  //     /** @hide */
+  //     public static long expand(long i, long mask) {
+  //       return -1;
+  //     }
+  //     private static long parallelSuffix(long maskCount) {
+  //       return 0;
+  //     }
   //     // Intrinsic! Do something cool. Return 0
   //     public static int signum(long i) {
   //       return 0;
@@ -236,263 +247,272 @@ public class Main {
   //
   //     /** @hide */
   //     @Override
-  //     public Object resolveConstantDesc(MethodHandles.Lookup lookup) {
+  //     public Long resolveConstantDesc(MethodHandles.Lookup lookup) {
   //       throw new Error("Method redefined away!");
   //     }
   // }
   private static final byte[] CLASS_BYTES = Base64.getDecoder().decode(
-    "yv66vgAAAD0AwQcAAgEADmphdmEvbGFuZy9Mb25nBwAEAQAOamF2YS9sYW5nL0J5dGUKAAYABwcA" +
+    "yv66vgAAAEEAyQcAAgEADmphdmEvbGFuZy9Mb25nBwAEAQAOamF2YS9sYW5nL0J5dGUKAAYABwcA" +
     "CAwACQAKAQAQamF2YS9sYW5nL051bWJlcgEABjxpbml0PgEAAygpVgkAAQAMDAANAA4BAAV2YWx1" +
-    "ZQEAAUoKAAEAEAwACQARAQAEKEopVgUAAAAAAAAACgcAFQEAF2phdmEvbGFuZy9TdHJpbmdCdWls" +
-    "ZGVyCgAUAAcIABgBACJSZWRlZmluZWQgTG9uZyEgdmFsdWUgKGFzIGRvdWJsZSk9CgAUABoMABsA" +
-    "HAEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVy" +
-    "OwoAFAAeDAAbAB8BABwoRClMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7CgAUACEMACIAIwEACHRv" +
-    "U3RyaW5nAQAUKClMamF2YS9sYW5nL1N0cmluZzsHACUBAA9qYXZhL2xhbmcvRXJyb3IIACcBABZN" +
-    "ZXRob2QgcmVkZWZpbmVkIGF3YXkhCgAkACkMAAkAKgEAFShMamF2YS9sYW5nL1N0cmluZzspVgoA" +
-    "AQAsDAAtAC4BAAljb21wYXJlVG8BABMoTGphdmEvbGFuZy9Mb25nOylJCgABADAMADEAMgEAE3Jl" +
-    "c29sdmVDb25zdGFudERlc2MBADkoTGphdmEvbGFuZy9pbnZva2UvTWV0aG9kSGFuZGxlcyRMb29r" +
-    "dXA7KUxqYXZhL2xhbmcvTG9uZzsJAAEANAwANQA2AQAEVFlQRQEAEUxqYXZhL2xhbmcvQ2xhc3M7" +
-    "BwA4AQAUamF2YS9sYW5nL0NvbXBhcmFibGUHADoBABxqYXZhL2xhbmcvY29uc3RhbnQvQ29uc3Rh" +
-    "YmxlBwA8AQAfamF2YS9sYW5nL2NvbnN0YW50L0NvbnN0YW50RGVzYwEACU1JTl9WQUxVRQEADUNv" +
-    "bnN0YW50VmFsdWUFAAAAAAAAAAABAAlNQVhfVkFMVUUBAAlTaWduYXR1cmUBACNMamF2YS9sYW5n" +
-    "L0NsYXNzPExqYXZhL2xhbmcvTG9uZzs+OwEABFNJWkUBAAFJAwAAAEABAAVCWVRFUwMAAAAIAQAQ" +
-    "c2VyaWFsVmVyc2lvblVJRAEAA3N1bQEABShKSilKAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEA" +
-    "EkxvY2FsVmFyaWFibGVUYWJsZQEAAWEBAAFiAQAEdGhpcwEAEExqYXZhL2xhbmcvTG9uZzsBAAd2" +
-    "YWx1ZU9mAQATKEopTGphdmEvbGFuZy9Mb25nOwEAAWwBAA1oaWdoZXN0T25lQml0AQAEKEopSgEA" +
-    "AWkBAAxsb3dlc3RPbmVCaXQBABRudW1iZXJPZkxlYWRpbmdaZXJvcwEABChKKUkBABVudW1iZXJP" +
-    "ZlRyYWlsaW5nWmVyb3MBAAhiaXRDb3VudAEACnJvdGF0ZUxlZnQBAAUoSkkpSgEACGRpc3RhbmNl" +
-    "AQALcm90YXRlUmlnaHQBAAdyZXZlcnNlAQAGc2lnbnVtAQAMcmV2ZXJzZUJ5dGVzAQAWKEpJKUxq" +
-    "YXZhL2xhbmcvU3RyaW5nOwEABXJhZGl4AQAQdG9VbnNpZ25lZFN0cmluZwEAFHRvVW5zaWduZWRC" +
-    "aWdJbnRlZ2VyAQAZKEopTGphdmEvbWF0aC9CaWdJbnRlZ2VyOwEAC3RvSGV4U3RyaW5nAQAVKEop" +
-    "TGphdmEvbGFuZy9TdHJpbmc7AQANdG9PY3RhbFN0cmluZwEADnRvQmluYXJ5U3RyaW5nAQARdG9V" +
-    "bnNpZ25lZFN0cmluZzABAAN2YWwBAAVzaGlmdAEAE2Zvcm1hdFVuc2lnbmVkTG9uZzABAAkoSklb" +
-    "QklJKVYBAANidWYBAAJbQgEABm9mZnNldAEAA2xlbgEACGdldENoYXJzAQAHKEpJW0IpSQEABWlu" +
-    "ZGV4AQAHKEpJW0MpSQEAAltDAQAKc3RyaW5nU2l6ZQEAAXgBAAlwYXJzZUxvbmcBABYoTGphdmEv" +
-    "bGFuZy9TdHJpbmc7SSlKAQABcwEAEkxqYXZhL2xhbmcvU3RyaW5nOwEACkV4Y2VwdGlvbnMHAIQB" +
-    "AB9qYXZhL2xhbmcvTnVtYmVyRm9ybWF0RXhjZXB0aW9uAQAVKExqYXZhL2xhbmcvU3RyaW5nOylK" +
-    "AQAeKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlO0lJSSlKAQAYTGphdmEvbGFuZy9DaGFyU2VxdWVu" +
-    "Y2U7AQAKYmVnaW5JbmRleAEACGVuZEluZGV4AQARcGFyc2VVbnNpZ25lZExvbmcBACUoTGphdmEv" +
-    "bGFuZy9TdHJpbmc7SSlMamF2YS9sYW5nL0xvbmc7AQAkKExqYXZhL2xhbmcvU3RyaW5nOylMamF2" +
-    "YS9sYW5nL0xvbmc7AQAGZGVjb2RlAQACbm0BAAlieXRlVmFsdWUBAAMoKUIBAApzaG9ydFZhbHVl" +
-    "AQADKClTAQAIaW50VmFsdWUBAAMoKUkBAAlsb25nVmFsdWUBAAMoKUoBAApmbG9hdFZhbHVlAQAD" +
-    "KClGAQALZG91YmxlVmFsdWUBAAMoKUQBAAhoYXNoQ29kZQEABmVxdWFscwEAFShMamF2YS9sYW5n" +
-    "L09iamVjdDspWgEAA29iagEAEkxqYXZhL2xhbmcvT2JqZWN0OwEAB2dldExvbmcBACUoTGphdmEv" +
-    "bGFuZy9TdHJpbmc7SilMamF2YS9sYW5nL0xvbmc7AQA0KExqYXZhL2xhbmcvU3RyaW5nO0xqYXZh" +
-    "L2xhbmcvTG9uZzspTGphdmEvbGFuZy9Mb25nOwEAC2Fub3RoZXJMb25nAQAHY29tcGFyZQEABShK" +
-    "SilJAQABeQEAD2NvbXBhcmVVbnNpZ25lZAEADmRpdmlkZVVuc2lnbmVkAQAIZGl2aWRlbmQBAAdk" +
-    "aXZpc29yAQARcmVtYWluZGVyVW5zaWduZWQBAANtYXgBAANtaW4BABFkZXNjcmliZUNvbnN0YWJs" +
-    "ZQEAFigpTGphdmEvdXRpbC9PcHRpb25hbDsBAEAoKUxqYXZhL3V0aWwvT3B0aW9uYWw8TGphdmEv" +
-    "bGFuZy9jb25zdGFudC9EeW5hbWljQ29uc3RhbnREZXNjOz47AQAGbG9va3VwAQAnTGphdmEvbGFu" +
-    "Zy9pbnZva2UvTWV0aG9kSGFuZGxlcyRMb29rdXA7AQAVKExqYXZhL2xhbmcvT2JqZWN0OylJAQA7" +
-    "KExqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZXMkTG9va3VwOylMamF2YS9sYW5nL09iamVj" +
-    "dDsHALYBACZqYXZhL2xhbmcvUmVmbGVjdGl2ZU9wZXJhdGlvbkV4Y2VwdGlvbgEACDxjbGluaXQ+" +
-    "AQB5TGphdmEvbGFuZy9OdW1iZXI7TGphdmEvbGFuZy9Db21wYXJhYmxlPExqYXZhL2xhbmcvTG9u" +
-    "Zzs+O0xqYXZhL2xhbmcvY29uc3RhbnQvQ29uc3RhYmxlO0xqYXZhL2xhbmcvY29uc3RhbnQvQ29u" +
-    "c3RhbnREZXNjOwEAClNvdXJjZUZpbGUBAAlMb25nLmphdmEBAAxJbm5lckNsYXNzZXMHAL0BACVq" +
-    "YXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZXMkTG9va3VwBwC/AQAeamF2YS9sYW5nL2ludm9r" +
-    "ZS9NZXRob2RIYW5kbGVzAQAGTG9va3VwADEAAQAGAAMANwA5ADsABwAZAD0ADgABAD4AAAACAD8A" +
-    "GQBBAA4AAQA+AAAAAgA/ABkANQA2AAEAQgAAAAIAQwASAA0ADgAAABkARABFAAEAPgAAAAIARgAZ" +
-    "AEcARQABAD4AAAACAEgAGgBJAA4AAQA+AAAAAgA/AD0ACQBKAEsAAQBMAAAAOAAEAAQAAAAEHiBh" +
-    "rQAAAAIATQAAAAYAAQAAABAATgAAABYAAgAAAAQATwAOAAAAAAAEAFAADgACAAEACQARAAEATAAA" +
-    "AEYAAwADAAAACiq3AAUqH7UAC7EAAAACAE0AAAAOAAMAAAATAAQAFAAJABUATgAAABYAAgAAAAoA" +
-    "UQBSAAAAAAAKAA0ADgABAAkAUwBUAAEATAAAADMABAACAAAACbsAAVketwAPsAAAAAIATQAAAAYA" +
-    "AQAAABgATgAAAAwAAQAAAAkAVQAOAAAACQBWAFcAAQBMAAAALgAEAAIAAAAEHgphrQAAAAIATQAA" +
-    "AAYAAQAAABwATgAAAAwAAQAAAAQAWAAOAAAACQBZAFcAAQBMAAAALgAEAAIAAAAEHgplrQAAAAIA" +
-    "TQAAAAYAAQAAACAATgAAAAwAAQAAAAQAWAAOAAAACQBaAFsAAQBMAAAALwAEAAIAAAAFHh5hiKwA" +
-    "AAACAE0AAAAGAAEAAAAkAE4AAAAMAAEAAAAFAFgADgAAAAkAXABbAAEATAAAADEABQACAAAABx4e" +
-    "BH1/iKwAAAACAE0AAAAGAAEAAAAoAE4AAAAMAAEAAAAHAFgADgAAAAkAXQBbAAEATAAAACwAAQAC" +
-    "AAAAAgisAAAAAgBNAAAABgABAAAALABOAAAADAABAAAAAgBYAA4AAAAJAF4AXwABAEwAAAA2AAIA" +
-    "AwAAAAIerQAAAAIATQAAAAYAAQAAADAATgAAABYAAgAAAAIAWAAOAAAAAAACAGAARQACAAkAYQBf" +
-    "AAEATAAAADoABAADAAAABhQAEh5prQAAAAIATQAAAAYAAQAAADQATgAAABYAAgAAAAYAWAAOAAAA" +
-    "AAAGAGAARQACAAkAYgBXAAEATAAAAC0AAgACAAAAAx51rQAAAAIATQAAAAYAAQAAADgATgAAAAwA" +
-    "AQAAAAMAWAAOAAAACQBjAFsAAQBMAAAALAABAAIAAAACA6wAAAACAE0AAAAGAAEAAAA8AE4AAAAM" +
-    "AAEAAAACAFgADgAAAAkAZABXAAEATAAAACwAAgACAAAAAgmtAAAAAgBNAAAABgABAAAAQABOAAAA" +
-    "DAABAAAAAgBYAA4AAAABACIAIwABAEwAAABCAAMAAQAAABi7ABRZtwAWEhe2ABkqtAALirYAHbYA" +
-    "ILAAAAACAE0AAAAGAAEAAABDAE4AAAAMAAEAAAAYAFEAUgAAAAkAIgBlAAEATAAAAD4AAwADAAAA" +
-    "CrsAJFkSJrcAKL8AAAACAE0AAAAGAAEAAABGAE4AAAAWAAIAAAAKAFgADgAAAAAACgBmAEUAAgAJ" +
-    "AGcAZQABAEwAAAA+AAMAAwAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAASQBOAAAAFgACAAAA" +
-    "CgBYAA4AAAAAAAoAZgBFAAIACgBoAGkAAQBMAAAANAADAAIAAAAKuwAkWRImtwAovwAAAAIATQAA" +
-    "AAYAAQAAAEwATgAAAAwAAQAAAAoAWAAOAAAACQBqAGsAAQBMAAAANAADAAIAAAAKuwAkWRImtwAo" +
-    "vwAAAAIATQAAAAYAAQAAAE8ATgAAAAwAAQAAAAoAWAAOAAAACQBsAGsAAQBMAAAANAADAAIAAAAK" +
-    "uwAkWRImtwAovwAAAAIATQAAAAYAAQAAAFIATgAAAAwAAQAAAAoAWAAOAAAACQBtAGsAAQBMAAAA" +
-    "NAADAAIAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAFUATgAAAAwAAQAAAAoAWAAOAAAACABu" +
-    "AGUAAQBMAAAAPgADAAMAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAFgATgAAABYAAgAAAAoA" +
-    "bwAOAAAAAAAKAHAARQACAAgAcQByAAEATAAAAFwAAwAGAAAACrsAJFkSJrcAKL8AAAACAE0AAAAG" +
-    "AAEAAABbAE4AAAA0AAUAAAAKAG8ADgAAAAAACgBwAEUAAgAAAAoAcwB0AAMAAAAKAHUARQAEAAAA" +
-    "CgB2AEUABQAJACIAawABAEwAAAA0AAMAAgAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAXgBO" +
-    "AAAADAABAAAACgBYAA4AAAAJAGcAawABAEwAAAA0AAMAAgAAAAq7ACRZEia3ACi/AAAAAgBNAAAA" +
-    "BgABAAAAYQBOAAAADAABAAAACgBYAA4AAAAIAHcAeAABAEwAAABIAAMABAAAAAq7ACRZEia3ACi/" +
-    "AAAAAgBNAAAABgABAAAAZABOAAAAIAADAAAACgBYAA4AAAAAAAoAeQBFAAIAAAAKAHMAdAADAAgA" +
-    "dwB6AAEATAAAAEgAAwAEAAAACrsAJFkSJrcAKL8AAAACAE0AAAAGAAEAAABnAE4AAAAgAAMAAAAK" +
-    "AFgADgAAAAAACgB5AEUAAgAAAAoAcwB7AAMACAB8AFsAAQBMAAAANAADAAIAAAAKuwAkWRImtwAo" +
-    "vwAAAAIATQAAAAYAAQAAAGoATgAAAAwAAQAAAAoAfQAOAAAACQB+AH8AAgBMAAAAPgADAAIAAAAK" +
-    "uwAkWRImtwAovwAAAAIATQAAAAYAAQAAAG0ATgAAABYAAgAAAAoAgACBAAAAAAAKAGYARQABAIIA" +
-    "AAAEAAEAgwAJAH4AhQACAEwAAAA0AAMAAQAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAcABO" +
-    "AAAADAABAAAACgCAAIEAAACCAAAABAABAIMACQB+AIYAAgBMAAAAUgADAAQAAAAKuwAkWRImtwAo" +
-    "vwAAAAIATQAAAAYAAQAAAHMATgAAACoABAAAAAoAgACHAAAAAAAKAIgARQABAAAACgCJAEUAAgAA" +
-    "AAoAZgBFAAMAggAAAAQAAQCDAAkAigB/AAIATAAAAD4AAwACAAAACrsAJFkSJrcAKL8AAAACAE0A" +
-    "AAAGAAEAAAB2AE4AAAAWAAIAAAAKAIAAgQAAAAAACgBmAEUAAQCCAAAABAABAIMACQCKAIUAAgBM" +
-    "AAAANAADAAEAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAHkATgAAAAwAAQAAAAoAgACBAAAA" +
-    "ggAAAAQAAQCDAAkAigCGAAIATAAAAFIAAwAEAAAACrsAJFkSJrcAKL8AAAACAE0AAAAGAAEAAAB8" +
-    "AE4AAAAqAAQAAAAKAIAAhwAAAAAACgCIAEUAAQAAAAoAiQBFAAIAAAAKAGYARQADAIIAAAAEAAEA" +
-    "gwAJAFMAiwACAEwAAAA+AAMAAgAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAfwBOAAAAFgAC" +
-    "AAAACgCAAIEAAAAAAAoAZgBFAAEAggAAAAQAAQCDAAkAUwCMAAIATAAAADQAAwABAAAACrsAJFkS" +
-    "JrcAKL8AAAACAE0AAAAGAAEAAACCAE4AAAAMAAEAAAAKAIAAgQAAAIIAAAAEAAEAgwAJAI0AjAAC" +
-    "AEwAAAA0AAMAAQAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAhQBOAAAADAABAAAACgCOAIEA" +
-    "AACCAAAABAABAIMAAQAJACoAAgBMAAAARwADAAIAAAAPKgm3AA+7ACRZEia3ACi/AAAAAgBNAAAA" +
-    "CgACAAAAiQAFAIoATgAAABYAAgAAAA8AUQBSAAAAAAAPAIAAgQABAIIAAAAEAAEAgwABAI8AkAAB" +
-    "AEwAAAA0AAMAAQAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAjQBOAAAADAABAAAACgBRAFIA" +
-    "AAABAJEAkgABAEwAAAA0AAMAAQAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAkABOAAAADAAB" +
-    "AAAACgBRAFIAAAABAJMAlAABAEwAAAA0AAMAAQAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAA" +
-    "kwBOAAAADAABAAAACgBRAFIAAAABAJUAlgABAEwAAAAvAAIAAQAAAAUqtAALrQAAAAIATQAAAAYA" +
-    "AQAAAJYATgAAAAwAAQAAAAUAUQBSAAAAAQCXAJgAAQBMAAAANAADAAEAAAAKuwAkWRImtwAovwAA" +
-    "AAIATQAAAAYAAQAAAJkATgAAAAwAAQAAAAoAUQBSAAAAAQCZAJoAAQBMAAAANAADAAEAAAAKuwAk" +
-    "WRImtwAovwAAAAIATQAAAAYAAQAAAJwATgAAAAwAAQAAAAoAUQBSAAAAAQCbAJQAAQBMAAAANAAD" +
-    "AAEAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAJ8ATgAAAAwAAQAAAAoAUQBSAAAACQCbAFsA" +
-    "AQBMAAAANAADAAIAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAKIATgAAAAwAAQAAAAoADQAO" +
-    "AAAAAQCcAJ0AAQBMAAAAPgADAAIAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAAKUATgAAABYA" +
-    "AgAAAAoAUQBSAAAAAAAKAJ4AnwABAAkAoACMAAEATAAAADQAAwABAAAACrsAJFkSJrcAKL8AAAAC" +
-    "AE0AAAAGAAEAAACoAE4AAAAMAAEAAAAKAI4AgQAAAAkAoAChAAEATAAAAD4AAwADAAAACrsAJFkS" +
-    "JrcAKL8AAAACAE0AAAAGAAEAAACrAE4AAAAWAAIAAAAKAI4AgQAAAAAACgBvAA4AAQAJAKAAogAB" +
-    "AEwAAAA+AAMAAgAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAArgBOAAAAFgACAAAACgCOAIEA" +
-    "AAAAAAoAbwBSAAEAAQAtAC4AAQBMAAAAPgADAAIAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAA" +
-    "ALEATgAAABYAAgAAAAoAUQBSAAAAAAAKAKMAUgABAAkApAClAAEATAAAAD4AAwAEAAAACrsAJFkS" +
-    "JrcAKL8AAAACAE0AAAAGAAEAAAC0AE4AAAAWAAIAAAAKAH0ADgAAAAAACgCmAA4AAgAJAKcApQAB" +
-    "AEwAAAA+AAMABAAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAtwBOAAAAFgACAAAACgB9AA4A" +
-    "AAAAAAoApgAOAAIACQCoAEsAAQBMAAAAPgADAAQAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAA" +
-    "ALoATgAAABYAAgAAAAoAqQAOAAAAAAAKAKoADgACAAkAqwBLAAEATAAAAD4AAwAEAAAACrsAJFkS" +
-    "JrcAKL8AAAACAE0AAAAGAAEAAAC9AE4AAAAWAAIAAAAKAKkADgAAAAAACgCqAA4AAgAJAKwASwAB" +
-    "AEwAAAA+AAMABAAAAAq7ACRZEia3ACi/AAAAAgBNAAAABgABAAAAwgBOAAAAFgACAAAACgBPAA4A" +
-    "AAAAAAoAUAAOAAIACQCtAEsAAQBMAAAAPgADAAQAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAA" +
-    "AMUATgAAABYAAgAAAAoATwAOAAAAAAAKAFAADgACAAEArgCvAAIATAAAADQAAwABAAAACrsAJFkS" +
-    "JrcAKL8AAAACAE0AAAAGAAEAAADMAE4AAAAMAAEAAAAKAFEAUgAAAEIAAAACALAAAQAxADIAAQBM" +
-    "AAAAPgADAAIAAAAKuwAkWRImtwAovwAAAAIATQAAAAYAAQAAANIATgAAABYAAgAAAAoAUQBSAAAA" +
-    "AAAKALEAsgABEEEALQCzAAEATAAAADMAAgACAAAACSorwAABtgArrAAAAAIATQAAAAYAAQAAAAkA" +
-    "TgAAAAwAAQAAAAkAUQBSAAAQQQAxALQAAgBMAAAAMAACAAIAAAAGKiu2AC+wAAAAAgBNAAAABgAB" +
-    "AAAACQBOAAAADAABAAAABgBRAFIAAACCAAAABAABALUACAC3AAoAAQBMAAAAIQABAAAAAAAFAbMA" +
-    "M7EAAAABAE0AAAAKAAIAAAAMAAQADQADAEIAAAACALgAuQAAAAIAugC7AAAACgABALwAvgDAABk="
-    );
+    "ZQEAAUoKAAEAEAwACQARAQAEKEopVgUAAAAAAAAACgX//////////wcAFwEAF2phdmEvbGFuZy9T" +
+    "dHJpbmdCdWlsZGVyCgAWAAcIABoBACJSZWRlZmluZWQgTG9uZyEgdmFsdWUgKGFzIGRvdWJsZSk9" +
+    "CgAWABwMAB0AHgEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJp" +
+    "bmdCdWlsZGVyOwoAFgAgDAAdACEBABwoRClMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7CgAWACMM" +
+    "ACQAJQEACHRvU3RyaW5nAQAUKClMamF2YS9sYW5nL1N0cmluZzsHACcBAA9qYXZhL2xhbmcvRXJy" +
+    "b3IIACkBABZNZXRob2QgcmVkZWZpbmVkIGF3YXkhCgAmACsMAAkALAEAFShMamF2YS9sYW5nL1N0" +
+    "cmluZzspVgoAAQAuDAAvADABAAljb21wYXJlVG8BABMoTGphdmEvbGFuZy9Mb25nOylJCgABADIM" +
+    "ADMANAEAE3Jlc29sdmVDb25zdGFudERlc2MBADkoTGphdmEvbGFuZy9pbnZva2UvTWV0aG9kSGFu" +
+    "ZGxlcyRMb29rdXA7KUxqYXZhL2xhbmcvTG9uZzsJAAEANgwANwA4AQAEVFlQRQEAEUxqYXZhL2xh" +
+    "bmcvQ2xhc3M7BwA6AQAUamF2YS9sYW5nL0NvbXBhcmFibGUHADwBABxqYXZhL2xhbmcvY29uc3Rh" +
+    "bnQvQ29uc3RhYmxlBwA+AQAfamF2YS9sYW5nL2NvbnN0YW50L0NvbnN0YW50RGVzYwEACU1JTl9W" +
+    "QUxVRQEADUNvbnN0YW50VmFsdWUFAAAAAAAAAAABAAlNQVhfVkFMVUUBAAlTaWduYXR1cmUBACNM" +
+    "amF2YS9sYW5nL0NsYXNzPExqYXZhL2xhbmcvTG9uZzs+OwEABFNJWkUBAAFJAwAAAEABAAVCWVRF" +
+    "UwMAAAAIAQAQc2VyaWFsVmVyc2lvblVJRAEAA3N1bQEABShKSilKAQAEQ29kZQEAD0xpbmVOdW1i" +
+    "ZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWEBAAFiAQAEdGhpcwEAEExqYXZhL2xhbmcv" +
+    "TG9uZzsBAAd2YWx1ZU9mAQATKEopTGphdmEvbGFuZy9Mb25nOwEAAWwBAA1oaWdoZXN0T25lQml0" +
+    "AQAEKEopSgEAAWkBAAxsb3dlc3RPbmVCaXQBABRudW1iZXJPZkxlYWRpbmdaZXJvcwEABChKKUkB" +
+    "ABVudW1iZXJPZlRyYWlsaW5nWmVyb3MBAAhiaXRDb3VudAEACnJvdGF0ZUxlZnQBAAUoSkkpSgEA" +
+    "CGRpc3RhbmNlAQALcm90YXRlUmlnaHQBAAdyZXZlcnNlAQAIY29tcHJlc3MBAARtYXNrAQAGZXhw" +
+    "YW5kAQAOcGFyYWxsZWxTdWZmaXgBAAltYXNrQ291bnQBAAZzaWdudW0BAAxyZXZlcnNlQnl0ZXMB" +
+    "ABYoSkkpTGphdmEvbGFuZy9TdHJpbmc7AQAFcmFkaXgBABB0b1Vuc2lnbmVkU3RyaW5nAQAUdG9V" +
+    "bnNpZ25lZEJpZ0ludGVnZXIBABkoSilMamF2YS9tYXRoL0JpZ0ludGVnZXI7AQALdG9IZXhTdHJp" +
+    "bmcBABUoSilMamF2YS9sYW5nL1N0cmluZzsBAA10b09jdGFsU3RyaW5nAQAOdG9CaW5hcnlTdHJp" +
+    "bmcBABF0b1Vuc2lnbmVkU3RyaW5nMAEAA3ZhbAEABXNoaWZ0AQATZm9ybWF0VW5zaWduZWRMb25n" +
+    "MAEACShKSVtCSUkpVgEAA2J1ZgEAAltCAQAGb2Zmc2V0AQADbGVuAQAIZ2V0Q2hhcnMBAAcoSklb" +
+    "QilJAQAFaW5kZXgBAAcoSklbQylJAQACW0MBAApzdHJpbmdTaXplAQABeAEACXBhcnNlTG9uZwEA" +
+    "FihMamF2YS9sYW5nL1N0cmluZztJKUoBAAFzAQASTGphdmEvbGFuZy9TdHJpbmc7AQAKRXhjZXB0" +
+    "aW9ucwcAiwEAH2phdmEvbGFuZy9OdW1iZXJGb3JtYXRFeGNlcHRpb24BABUoTGphdmEvbGFuZy9T" +
+    "dHJpbmc7KUoBAB4oTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7SUlJKUoBABhMamF2YS9sYW5nL0No" +
+    "YXJTZXF1ZW5jZTsBAApiZWdpbkluZGV4AQAIZW5kSW5kZXgBABFwYXJzZVVuc2lnbmVkTG9uZwEA" +
+    "JShMamF2YS9sYW5nL1N0cmluZztJKUxqYXZhL2xhbmcvTG9uZzsBACQoTGphdmEvbGFuZy9TdHJp" +
+    "bmc7KUxqYXZhL2xhbmcvTG9uZzsBAAZkZWNvZGUBAAJubQEACWJ5dGVWYWx1ZQEAAygpQgEACnNo" +
+    "b3J0VmFsdWUBAAMoKVMBAAhpbnRWYWx1ZQEAAygpSQEACWxvbmdWYWx1ZQEAAygpSgEACmZsb2F0" +
+    "VmFsdWUBAAMoKUYBAAtkb3VibGVWYWx1ZQEAAygpRAEACGhhc2hDb2RlAQAGZXF1YWxzAQAVKExq" +
+    "YXZhL2xhbmcvT2JqZWN0OylaAQADb2JqAQASTGphdmEvbGFuZy9PYmplY3Q7AQAHZ2V0TG9uZwEA" +
+    "JShMamF2YS9sYW5nL1N0cmluZztKKUxqYXZhL2xhbmcvTG9uZzsBADQoTGphdmEvbGFuZy9TdHJp" +
+    "bmc7TGphdmEvbGFuZy9Mb25nOylMamF2YS9sYW5nL0xvbmc7AQALYW5vdGhlckxvbmcBAAdjb21w" +
+    "YXJlAQAFKEpKKUkBAAF5AQAPY29tcGFyZVVuc2lnbmVkAQAOZGl2aWRlVW5zaWduZWQBAAhkaXZp" +
+    "ZGVuZAEAB2Rpdmlzb3IBABFyZW1haW5kZXJVbnNpZ25lZAEAA21heAEAA21pbgEAEWRlc2NyaWJl" +
+    "Q29uc3RhYmxlAQAWKClMamF2YS91dGlsL09wdGlvbmFsOwEAOigpTGphdmEvdXRpbC9PcHRpb25h" +
+    "bDwrTGphdmEvbGFuZy9jb25zdGFudC9Db25zdGFudERlc2M7PjsBAAZsb29rdXABACdMamF2YS9s" +
+    "YW5nL2ludm9rZS9NZXRob2RIYW5kbGVzJExvb2t1cDsBABUoTGphdmEvbGFuZy9PYmplY3Q7KUkB" +
+    "ABBNZXRob2RQYXJhbWV0ZXJzAQA7KExqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZXMkTG9v" +
+    "a3VwOylMamF2YS9sYW5nL09iamVjdDsHAL4BACZqYXZhL2xhbmcvUmVmbGVjdGl2ZU9wZXJhdGlv" +
+    "bkV4Y2VwdGlvbgEACDxjbGluaXQ+AQB5TGphdmEvbGFuZy9OdW1iZXI7TGphdmEvbGFuZy9Db21w" +
+    "YXJhYmxlPExqYXZhL2xhbmcvTG9uZzs+O0xqYXZhL2xhbmcvY29uc3RhbnQvQ29uc3RhYmxlO0xq" +
+    "YXZhL2xhbmcvY29uc3RhbnQvQ29uc3RhbnREZXNjOwEAClNvdXJjZUZpbGUBAAlMb25nLmphdmEB" +
+    "AAxJbm5lckNsYXNzZXMHAMUBACVqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZXMkTG9va3Vw" +
+    "BwDHAQAeamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGVzAQAGTG9va3VwADEAAQAGAAMAOQA7" +
+    "AD0ABwAZAD8ADgABAEAAAAACAEEAGQBDAA4AAQBAAAAAAgBBABkANwA4AAEARAAAAAIARQASAA0A" +
+    "DgAAABkARgBHAAEAQAAAAAIASAAZAEkARwABAEAAAAACAEoAGgBLAA4AAQBAAAAAAgBBAEAACQBM" +
+    "AE0AAQBOAAAAOAAEAAQAAAAEHiBhrQAAAAIATwAAAAYAAQAAAA8AUAAAABYAAgAAAAQAUQAOAAAA" +
+    "AAAEAFIADgACAAEACQARAAEATgAAAEYAAwADAAAACiq3AAUqH7UAC7EAAAACAE8AAAAOAAMAAAAS" +
+    "AAQAEwAJABQAUAAAABYAAgAAAAoAUwBUAAAAAAAKAA0ADgABAAkAVQBWAAEATgAAADMABAACAAAA" +
+    "CbsAAVketwAPsAAAAAIATwAAAAYAAQAAABcAUAAAAAwAAQAAAAkAVwAOAAAACQBYAFkAAQBOAAAA" +
+    "LgAEAAIAAAAEHgphrQAAAAIATwAAAAYAAQAAABsAUAAAAAwAAQAAAAQAWgAOAAAACQBbAFkAAQBO" +
+    "AAAALgAEAAIAAAAEHgplrQAAAAIATwAAAAYAAQAAAB8AUAAAAAwAAQAAAAQAWgAOAAAACQBcAF0A" +
+    "AQBOAAAALwAEAAIAAAAFHh5hiKwAAAACAE8AAAAGAAEAAAAjAFAAAAAMAAEAAAAFAFoADgAAAAkA" +
+    "XgBdAAEATgAAADEABQACAAAABx4eBH1/iKwAAAACAE8AAAAGAAEAAAAnAFAAAAAMAAEAAAAHAFoA" +
+    "DgAAAAkAXwBdAAEATgAAACwAAQACAAAAAgisAAAAAgBPAAAABgABAAAAKwBQAAAADAABAAAAAgBa" +
+    "AA4AAAAJAGAAYQABAE4AAAA2AAIAAwAAAAIerQAAAAIATwAAAAYAAQAAAC8AUAAAABYAAgAAAAIA" +
+    "WgAOAAAAAAACAGIARwACAAkAYwBhAAEATgAAADoABAADAAAABhQAEh5prQAAAAIATwAAAAYAAQAA" +
+    "ADMAUAAAABYAAgAAAAYAWgAOAAAAAAAGAGIARwACAAkAZABZAAEATgAAAC0AAgACAAAAAx51rQAA" +
+    "AAIATwAAAAYAAQAAADcAUAAAAAwAAQAAAAMAWgAOAAAACQBlAE0AAQBOAAAAOAACAAQAAAAEFAAU" +
+    "rQAAAAIATwAAAAYAAQAAADsAUAAAABYAAgAAAAQAWgAOAAAAAAAEAGYADgACAAkAZwBNAAEATgAA" +
+    "ADgAAgAEAAAABBQAFK0AAAACAE8AAAAGAAEAAAA/AFAAAAAWAAIAAAAEAFoADgAAAAAABABmAA4A" +
+    "AgAKAGgAWQABAE4AAAAsAAIAAgAAAAIJrQAAAAIATwAAAAYAAQAAAEIAUAAAAAwAAQAAAAIAaQAO" +
+    "AAAACQBqAF0AAQBOAAAALAABAAIAAAACA6wAAAACAE8AAAAGAAEAAABGAFAAAAAMAAEAAAACAFoA" +
+    "DgAAAAkAawBZAAEATgAAACwAAgACAAAAAgmtAAAAAgBPAAAABgABAAAASgBQAAAADAABAAAAAgBa" +
+    "AA4AAAABACQAJQABAE4AAABCAAMAAQAAABi7ABZZtwAYEhm2ABsqtAALirYAH7YAIrAAAAACAE8A" +
+    "AAAGAAEAAABNAFAAAAAMAAEAAAAYAFMAVAAAAAkAJABsAAEATgAAAD4AAwADAAAACrsAJlkSKLcA" +
+    "Kr8AAAACAE8AAAAGAAEAAABQAFAAAAAWAAIAAAAKAFoADgAAAAAACgBtAEcAAgAJAG4AbAABAE4A" +
+    "AAA+AAMAAwAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAUwBQAAAAFgACAAAACgBaAA4AAAAA" +
+    "AAoAbQBHAAIACgBvAHAAAQBOAAAANAADAAIAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAFYA" +
+    "UAAAAAwAAQAAAAoAWgAOAAAACQBxAHIAAQBOAAAANAADAAIAAAAKuwAmWRIotwAqvwAAAAIATwAA" +
+    "AAYAAQAAAFkAUAAAAAwAAQAAAAoAWgAOAAAACQBzAHIAAQBOAAAANAADAAIAAAAKuwAmWRIotwAq" +
+    "vwAAAAIATwAAAAYAAQAAAFwAUAAAAAwAAQAAAAoAWgAOAAAACQB0AHIAAQBOAAAANAADAAIAAAAK" +
+    "uwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAF8AUAAAAAwAAQAAAAoAWgAOAAAACAB1AGwAAQBOAAAA" +
+    "PgADAAMAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAGIAUAAAABYAAgAAAAoAdgAOAAAAAAAK" +
+    "AHcARwACAAgAeAB5AAEATgAAAFwAAwAGAAAACrsAJlkSKLcAKr8AAAACAE8AAAAGAAEAAABlAFAA" +
+    "AAA0AAUAAAAKAHYADgAAAAAACgB3AEcAAgAAAAoAegB7AAMAAAAKAHwARwAEAAAACgB9AEcABQAJ" +
+    "ACQAcgABAE4AAAA0AAMAAgAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAaABQAAAADAABAAAA" +
+    "CgBaAA4AAAAJAG4AcgABAE4AAAA0AAMAAgAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAawBQ" +
+    "AAAADAABAAAACgBaAA4AAAAIAH4AfwABAE4AAABIAAMABAAAAAq7ACZZEii3ACq/AAAAAgBPAAAA" +
+    "BgABAAAAbgBQAAAAIAADAAAACgBaAA4AAAAAAAoAgABHAAIAAAAKAHoAewADAAgAfgCBAAEATgAA" +
+    "AEgAAwAEAAAACrsAJlkSKLcAKr8AAAACAE8AAAAGAAEAAABxAFAAAAAgAAMAAAAKAFoADgAAAAAA" +
+    "CgCAAEcAAgAAAAoAegCCAAMACACDAF0AAQBOAAAANAADAAIAAAAKuwAmWRIotwAqvwAAAAIATwAA" +
+    "AAYAAQAAAHQAUAAAAAwAAQAAAAoAhAAOAAAACQCFAIYAAgBOAAAAPgADAAIAAAAKuwAmWRIotwAq" +
+    "vwAAAAIATwAAAAYAAQAAAHcAUAAAABYAAgAAAAoAhwCIAAAAAAAKAG0ARwABAIkAAAAEAAEAigAJ" +
+    "AIUAjAACAE4AAAA0AAMAAQAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAegBQAAAADAABAAAA" +
+    "CgCHAIgAAACJAAAABAABAIoACQCFAI0AAgBOAAAAUgADAAQAAAAKuwAmWRIotwAqvwAAAAIATwAA" +
+    "AAYAAQAAAH0AUAAAACoABAAAAAoAhwCOAAAAAAAKAI8ARwABAAAACgCQAEcAAgAAAAoAbQBHAAMA" +
+    "iQAAAAQAAQCKAAkAkQCGAAIATgAAAD4AAwACAAAACrsAJlkSKLcAKr8AAAACAE8AAAAGAAEAAACA" +
+    "AFAAAAAWAAIAAAAKAIcAiAAAAAAACgBtAEcAAQCJAAAABAABAIoACQCRAIwAAgBOAAAANAADAAEA" +
+    "AAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAIMAUAAAAAwAAQAAAAoAhwCIAAAAiQAAAAQAAQCK" +
+    "AAkAkQCNAAIATgAAAFIAAwAEAAAACrsAJlkSKLcAKr8AAAACAE8AAAAGAAEAAACGAFAAAAAqAAQA" +
+    "AAAKAIcAjgAAAAAACgCPAEcAAQAAAAoAkABHAAIAAAAKAG0ARwADAIkAAAAEAAEAigAJAFUAkgAC" +
+    "AE4AAAA+AAMAAgAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAiQBQAAAAFgACAAAACgCHAIgA" +
+    "AAAAAAoAbQBHAAEAiQAAAAQAAQCKAAkAVQCTAAIATgAAADQAAwABAAAACrsAJlkSKLcAKr8AAAAC" +
+    "AE8AAAAGAAEAAACMAFAAAAAMAAEAAAAKAIcAiAAAAIkAAAAEAAEAigAJAJQAkwACAE4AAAA0AAMA" +
+    "AQAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAjwBQAAAADAABAAAACgCVAIgAAACJAAAABAAB" +
+    "AIoAAQAJACwAAgBOAAAARwADAAIAAAAPKgm3AA+7ACZZEii3ACq/AAAAAgBPAAAACgACAAAAkwAF" +
+    "AJQAUAAAABYAAgAAAA8AUwBUAAAAAAAPAIcAiAABAIkAAAAEAAEAigABAJYAlwABAE4AAAA0AAMA" +
+    "AQAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAlwBQAAAADAABAAAACgBTAFQAAAABAJgAmQAB" +
+    "AE4AAAA0AAMAAQAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAmgBQAAAADAABAAAACgBTAFQA" +
+    "AAABAJoAmwABAE4AAAA0AAMAAQAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAnQBQAAAADAAB" +
+    "AAAACgBTAFQAAAABAJwAnQABAE4AAAAvAAIAAQAAAAUqtAALrQAAAAIATwAAAAYAAQAAAKAAUAAA" +
+    "AAwAAQAAAAUAUwBUAAAAAQCeAJ8AAQBOAAAANAADAAEAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYA" +
+    "AQAAAKMAUAAAAAwAAQAAAAoAUwBUAAAAAQCgAKEAAQBOAAAANAADAAEAAAAKuwAmWRIotwAqvwAA" +
+    "AAIATwAAAAYAAQAAAKYAUAAAAAwAAQAAAAoAUwBUAAAAAQCiAJsAAQBOAAAANAADAAEAAAAKuwAm" +
+    "WRIotwAqvwAAAAIATwAAAAYAAQAAAKkAUAAAAAwAAQAAAAoAUwBUAAAACQCiAF0AAQBOAAAANAAD" +
+    "AAIAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAKwAUAAAAAwAAQAAAAoADQAOAAAAAQCjAKQA" +
+    "AQBOAAAAPgADAAIAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAK8AUAAAABYAAgAAAAoAUwBU" +
+    "AAAAAAAKAKUApgABAAkApwCTAAEATgAAADQAAwABAAAACrsAJlkSKLcAKr8AAAACAE8AAAAGAAEA" +
+    "AACyAFAAAAAMAAEAAAAKAJUAiAAAAAkApwCoAAEATgAAAD4AAwADAAAACrsAJlkSKLcAKr8AAAAC" +
+    "AE8AAAAGAAEAAAC1AFAAAAAWAAIAAAAKAJUAiAAAAAAACgB2AA4AAQAJAKcAqQABAE4AAAA+AAMA" +
+    "AgAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAuABQAAAAFgACAAAACgCVAIgAAAAAAAoAdgBU" +
+    "AAEAAQAvADAAAQBOAAAAPgADAAIAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAALsAUAAAABYA" +
+    "AgAAAAoAUwBUAAAAAAAKAKoAVAABAAkAqwCsAAEATgAAAD4AAwAEAAAACrsAJlkSKLcAKr8AAAAC" +
+    "AE8AAAAGAAEAAAC+AFAAAAAWAAIAAAAKAIQADgAAAAAACgCtAA4AAgAJAK4ArAABAE4AAAA+AAMA" +
+    "BAAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAwQBQAAAAFgACAAAACgCEAA4AAAAAAAoArQAO" +
+    "AAIACQCvAE0AAQBOAAAAPgADAAQAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAMQAUAAAABYA" +
+    "AgAAAAoAsAAOAAAAAAAKALEADgACAAkAsgBNAAEATgAAAD4AAwAEAAAACrsAJlkSKLcAKr8AAAAC" +
+    "AE8AAAAGAAEAAADHAFAAAAAWAAIAAAAKALAADgAAAAAACgCxAA4AAgAJALMATQABAE4AAAA+AAMA" +
+    "BAAAAAq7ACZZEii3ACq/AAAAAgBPAAAABgABAAAAzABQAAAAFgACAAAACgBRAA4AAAAAAAoAUgAO" +
+    "AAIACQC0AE0AAQBOAAAAPgADAAQAAAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAAM8AUAAAABYA" +
+    "AgAAAAoAUQAOAAAAAAAKAFIADgACAAEAtQC2AAIATgAAADQAAwABAAAACrsAJlkSKLcAKr8AAAAC" +
+    "AE8AAAAGAAEAAADWAFAAAAAMAAEAAAAKAFMAVAAAAEQAAAACALcAAQAzADQAAQBOAAAAPgADAAIA" +
+    "AAAKuwAmWRIotwAqvwAAAAIATwAAAAYAAQAAANwAUAAAABYAAgAAAAoAUwBUAAAAAAAKALgAuQAB" +
+    "EEEALwC6AAIATgAAADMAAgACAAAACSorwAABtgAtrAAAAAIATwAAAAYAAQAAAAgAUAAAAAwAAQAA" +
+    "AAkAUwBUAAAAuwAAAAUBAAAQABBBADMAvAADAE4AAAAwAAIAAgAAAAYqK7YAMbAAAAACAE8AAAAG" +
+    "AAEAAAAIAFAAAAAMAAEAAAAGAFMAVAAAAIkAAAAEAAEAvQC7AAAABQEAABAAAAgAvwAKAAEATgAA" +
+    "ACEAAQAAAAAABQGzADWxAAAAAQBPAAAACgACAAAACwAEAAwAAwBEAAAAAgDAAMEAAAACAMIAwwAA" +
+    "AAoAAQDEAMYAyAAZ");
 
   private static final byte[] DEX_BYTES = Base64.getDecoder().decode(
-    "ZGV4CjAzNQCC6NqF6YcFy4KrMQ61yOakOSk9scYPTAY0GgAAcAAAAHhWNBIAAAAAAAAAAGQZAACI" +
-    "AAAAcAAAABwAAACQAgAAJQAAAAADAAAHAAAAvAQAAEMAAAD0BAAAAQAAAAwHAAAIEwAALAcAAH4Q" +
-    "AACCEAAAjBAAAJQQAACYEAAAmxAAAKIQAAClEAAAqBAAAKsQAACvEAAAtRAAALoQAAC+EAAAwRAA" +
-    "AMUQAADKEAAAzxAAANMQAADYEAAA3xAAAOIQAADmEAAA6hAAAO8QAADzEAAA+BAAAP0QAAACEQAA" +
-    "IREAAD0RAABXEQAAahEAAH0RAACVEQAArREAAMARAADSEQAA5hEAAAkSAAAdEgAARxIAAFsSAAB2" +
-    "EgAAlhIAALkSAADjEgAADBMAACQTAAA6EwAAUBMAAFsTAABmEwAAcRMAAIkTAACtEwAAsBMAALYT" +
-    "AAC8EwAAvxMAAMMTAADLEwAAzxMAANITAADWEwAA2hMAAN4TAADhEwAA7hMAAPYTAAD5EwAABRQA" +
-    "AA8UAAAUFAAAHxQAACgUAAAzFAAARBQAAEwUAABfFAAAaRQAAHkUAACDFAAAjBQAAJkUAACjFAAA" +
-    "qxQAALcUAADMFAAA1hQAAN8UAADpFAAA+BQAAPsUAAACFQAADBUAAA8VAAAUFQAAHxUAACcVAAA1" +
-    "FQAAOhUAAD8VAABDFQAAWRUAAHAVAAB1FQAAfRUAAIgVAACbFQAAohUAALUVAADKFQAA0xUAAOEV" +
-    "AADtFQAA+hUAAP0VAAAPFgAAFhYAACIWAAAqFgAANhYAADsWAABLFgAAWBYAAGcWAABxFgAAhxYA" +
-    "AJkWAACsFgAAsRYAALgWAADBFgAAxBYAAMcWAAAEAAAABgAAAAcAAAAIAAAADQAAABwAAAAdAAAA" +
-    "HgAAAB8AAAAhAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC4AAAAv" +
-    "AAAAMAAAADcAAAA6AAAAPgAAAEAAAABBAAAABAAAAAAAAAAAAAAABgAAAAEAAAAAAAAABwAAAAIA" +
-    "AAAAAAAACAAAAAMAAAAAAAAACQAAAAMAAAD0DwAACgAAAAMAAAD8DwAACgAAAAMAAAAIEAAACwAA" +
-    "AAMAAAAUEAAADAAAAAMAAAAcEAAADAAAAAMAAAAkEAAADQAAAAQAAAAAAAAADgAAAAQAAAD0DwAA" +
-    "DwAAAAQAAAAsEAAAEAAAAAQAAAAUEAAAEwAAAAQAAAA0EAAAEQAAAAQAAABAEAAAEgAAAAQAAABI" +
-    "EAAAFgAAAAsAAAD0DwAAGAAAAAsAAABAEAAAGQAAAAsAAABIEAAAGgAAAAsAAABQEAAAGwAAAAsA" +
-    "AABYEAAAGAAAAAsAAABgEAAAGAAAAA4AAABgEAAAFAAAABAAAAAAAAAAFgAAABAAAAD0DwAAFwAA" +
-    "ABAAAAAsEAAAFQAAABEAAABoEAAAGAAAABEAAABAEAAAFgAAABUAAAD0DwAAFAAAABYAAAAAAAAA" +
-    "NwAAABcAAAAAAAAAOgAAABgAAAAAAAAAOwAAABgAAAD0DwAAPAAAABgAAABwEAAAPQAAABgAAABA" +
-    "EAAAPwAAABkAAAAkEAAACwADAAUAAAALAAQAMwAAAAsABAA0AAAACwADADgAAAALAAgAOQAAAAsA" +
-    "BAB1AAAACwAEAIMAAAAKACMAAgAAAAsAIAABAAAACwAhAAIAAAALACMAAgAAAAsABABHAAAACwAA" +
-    "AEkAAAALAAcASgAAAAsACABLAAAACwAJAEsAAAALAAcATAAAAAsAEgBNAAAACwAeAE4AAAALAA0A" +
-    "UAAAAAsAAQBTAAAACwAkAFUAAAALAAIAVgAAAAsAIgBXAAAACwAFAFgAAAALAAYAWAAAAAsAEgBZ" +
-    "AAAACwAUAFkAAAALABUAWQAAAAsAAwBaAAAACwAEAFoAAAALAAsAWwAAAAsAAwBeAAAACwAKAGEA" +
-    "AAALAAsAYwAAAAsADQBkAAAACwANAGUAAAALAAQAZwAAAAsABABoAAAACwAOAGsAAAALAA8AawAA" +
-    "AAsAEABrAAAACwAOAGwAAAALAA8AbAAAAAsAEABsAAAACwANAG4AAAALABYAbwAAAAsAFwBvAAAA" +
-    "CwALAHAAAAALAAsAcQAAAAsADAByAAAACwAMAHMAAAALAB8AdwAAAAsABAB4AAAACwAEAHkAAAAL" +
-    "AA0AegAAAAsAGQB7AAAACwAZAHwAAAALABkAfQAAAAsAGAB+AAAACwAZAH4AAAALABoAfgAAAAsA" +
-    "HQB/AAAACwAZAIAAAAALABoAgAAAAAsAGgCBAAAACwARAIQAAAALABIAhAAAAAsAEwCEAAAADAAg" +
-    "AAIAAAARACAAAgAAABEAGwBEAAAAEQAcAEQAAAARABgAfgAAAAsAAAARAAAADAAAAOgPAAAyAAAA" +
-    "7BgAAKYXAAC0GAAABAACAAIAAACADgAACAAAACIACgAaATUAcCAAABAAJwADAAEAAgAAAIYOAAAI" +
-    "AAAAIgAKABoBNQBwIAAAEAAnAAMAAQACAAAAiw4AAAgAAAAiAAoAGgE1AHAgAAAQACcAAwABAAIA" +
-    "AACQDgAACAAAACIACgAaATUAcCAAABAAJwADAAIAAAAAAJUOAAACAAAAElAPAAYABAACAAAAmg4A" +
-    "AAgAAAAiAAoAGgE1AHAgAAAQACcABAACAAIAAACjDgAACAAAACIACgAaATUAcCAAABAAJwACAAIA" +
-    "AgAAAKkOAAAHAAAAHwELAG4gBwAQAAoBDwEAAAYABAACAAAArg4AAAgAAAAiAAoAGgE1AHAgAAAQ" +
-    "ACcABgAEAAIAAAC3DgAACAAAACIACgAaATUAcCAAABAAJwAGAAQAAgAAAL4OAAAIAAAAIgAKABoB" +
-    "NQBwIAAAEAAnAAMAAQACAAAAxQ4AAAgAAAAiAAoAGgE1AHAgAAAQACcABAACAAIAAADKDgAACAAA" +
-    "ACIACgAaATUAcCAAABAAJwADAAEAAgAAANEOAAAIAAAAIgAKABoBNQBwIAAAEAAnAAQAAgAAAAAA" +
-    "1g4AAAQAAACbAAIChAEPAQQAAgAAAAAA2w4AAAYAAAASEKUAAgDAIIQBDwEDAAIAAAAAAOAOAAAC" +
-    "AAAAEgAPAAQAAgACAAAA5Q4AAAgAAAAiAAoAGgE1AHAgAAAQACcAAwABAAIAAADrDgAACAAAACIA" +
-    "CgAaATUAcCAAABAAJwADAAEAAgAAAPEOAAAIAAAAIgAKABoBNQBwIAAAEAAnAAQAAgACAAAA9w4A" +
-    "AAgAAAAiAAoAGgE1AHAgAAAQACcABQADAAIAAAD/DgAACAAAACIACgAaATUAcCAAABAAJwAEAAIA" +
-    "AgAAAAcPAAAIAAAAIgAKABoBNQBwIAAAEAAnAAMAAQACAAAADQ8AAAgAAAAiAAoAGgE1AHAgAAAQ" +
-    "ACcABAACAAIAAAATDwAACAAAACIACgAaATUAcCAAABAAJwADAAIAAwAAABkPAAAGAAAAIgALAHAw" +
-    "AgAQAhEAAgACAAIAAACpDgAABQAAAG4gJwAQAAwBEQEAAAQAAgACAAAAHg8AAAgAAAAiAAoAGgE1" +
-    "AHAgAAAQACcABAACAAIAAAAjDwAACAAAACIACgAaATUAcCAAABAAJwAEAAIAAgAAACgPAAAIAAAA" +
-    "IgAKABoBNQBwIAAAEAAnAAQAAQADAAAALQ8AABcAAAAiABEAcBA/AAAAGgE2AG4gQQAQAAwAUzEG" +
-    "AIYRbjBAABACDABuEEIAAAAMABEAAAAEAAIAAgAAADEPAAAIAAAAIgAKABoBNQBwIAAAEAAnAAUA" +
-    "AwACAAAANg8AAAgAAAAiAAoAGgE1AHAgAAAQACcABAACAAIAAAA8DwAACAAAACIACgAaATUAcCAA" +
-    "ABAAJwAFAAMAAgAAAEEPAAAIAAAAIgAKABoBNQBwIAAAEAAnAAUAAwACAAAARw8AAAgAAAAiAAoA" +
-    "GgE1AHAgAAAQACcABAACAAIAAABODwAACAAAACIACgAaATUAcCAAABAAJwADAAEAAgAAAFMPAAAI" +
-    "AAAAIgAKABoBNQBwIAAAEAAnAAYABAACAAAAWA8AAAgAAAAiAAoAGgE1AHAgAAAQACcABAACAAAA" +
-    "AABfDwAABAAAABYAAQC7IBAAAwABAAAAAABkDwAAAwAAAFMgBgAQAAAABAACAAAAAABpDwAABQAA" +
-    "ABYAAQCcAAIAEAAAAAYABAACAAAAbg8AAAgAAAAiAAoAGgE1AHAgAAAQACcABgAEAAIAAAB1DwAA" +
-    "CAAAACIACgAaATUAcCAAABAAJwAGAAQAAgAAAHwPAAAIAAAAIgAKABoBNQBwIAAAEAAnAAMAAQAC" +
-    "AAAAhA8AAAgAAAAiAAoAGgE1AHAgAAAQACcABAACAAIAAACJDwAACAAAACIACgAaATUAcCAAABAA" +
-    "JwAGAAQAAgAAAI8PAAAIAAAAIgAKABoBNQBwIAAAEAAnAAMAAQACAAAAlw8AAAgAAAAiAAoAGgE1" +
-    "AHAgAAAQACcABAACAAIAAACcDwAACAAAACIACgAaATUAcCAAABAAJwAGAAQAAgAAAKIPAAAIAAAA" +
-    "IgAKABoBNQBwIAAAEAAnAAQAAgAAAAAAqQ8AAAIAAAB9IBAABAACAAAAAACuDwAAAwAAABYAAAAQ" +
-    "AAAAAwADAAAAAACzDwAAAQAAABAAAAAFAAMAAAAAALkPAAAFAAAAFgAKAJ0AAAIQAAAABgAEAAAA" +
-    "AAC/DwAAAwAAAJsAAgQQAAAAAwABAAIAAADFDwAACAAAACIACgAaATUAcCAAABAAJwABAAAAAAAA" +
-    "AMoPAAAEAAAAEgBpAAQADgAEAAIAAwAAAM8PAAANAAAAFgAAAHAwAgACASIACgAaATUAcCAAABAA" +
-    "JwAAAAMAAwABAAAA1g8AAAYAAABwED4AAABaAQYADgAIAAYAAgAAAN4PAAAIAAAAIgAKABoBNQBw" +
-    "IAAAEAAnAKUBAWoOAI0BAA4AnAEADgCZAQAOACwBXQ4AtAEChgGHAQ4AsQEBRA4ACQEADgC3AQKG" +
-    "AYcBDgBkA11eSQ4AZwNdXkkOAJ8BAA4AogEBhAEOAJMBAA4AJAFdDgAoAV0OADwBXQ4AagGGAQ4A" +
-    "hQEBZw4AqAEBZw4ArgECZ4MBDgCrAQJngwEOANIBAWMOAIIBAXUOAH8CdW4OABgBYA4AVQFdDgBP" +
-    "AV0OAFIBXQ4AQwAOAF4BXQ4ARgJdbg4AYQFdDgBJAl1uDgBYAoMBdw4ATAFdDgDMAQAOALoBAlJT" +
-    "DgAcAV0OAJYBAA4AIAFdDgDCAQJDRg4AxQECQ0YOAHMEdUdVbg4AcAF1DgBtAnVuDgB8BHVHVW4O" +
-    "AHkBdQ4AdgJ1bg4AvQECUlMOADgBXQ4AQAFdDgAwAl1QDgA0Al1QDgAQAkNGDgCQAQAOAAwADjwA" +
-    "iQEBdQ5aABMBhAEOPC0AWwWDAXdJa2EOAAMAAAAJABIAEwAAAAEAAAAEAAAAAwAAAAQAAwAaAAAA" +
-    "AwAAAAQAAwAbAAAAAgAAAAQABAABAAAACwAAAAEAAAAOAAAAAgAAAAQAAwAEAAAABwADAAMAAwAB" +
-    "AAAAEAAAAAIAAAAQAAMAAgAAABAABAACAAAAEAALAAEAAAAUAAAAAQAAAAEAAAAFAAAABAADABoA" +
-    "AwADAAIoKQAIPGNsaW5pdD4ABjxpbml0PgACPjsAAUIABUJZVEVTAAFEAAFGAAFJAAJJSgAESUpJ" +
-    "TAADSUpKAAJJTAABSgACSkoAA0pKSQADSkpKAAJKTAADSkxJAAVKTElJSQABTAACTEQAAkxKAANM" +
-    "SkkAAkxMAANMTEkAA0xMSgADTExMAB1MZGFsdmlrL2Fubm90YXRpb24vU2lnbmF0dXJlOwAaTGRh" +
-    "bHZpay9hbm5vdGF0aW9uL1Rocm93czsAGExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlOwARTGphdmEv" +
-    "bGFuZy9DbGFzczsAEUxqYXZhL2xhbmcvQ2xhc3M8ABZMamF2YS9sYW5nL0NvbXBhcmFibGU7ABZM" +
-    "amF2YS9sYW5nL0NvbXBhcmFibGU8ABFMamF2YS9sYW5nL0Vycm9yOwAQTGphdmEvbGFuZy9Mb25n" +
-    "OwASTGphdmEvbGFuZy9OdW1iZXI7ACFMamF2YS9sYW5nL051bWJlckZvcm1hdEV4Y2VwdGlvbjsA" +
-    "EkxqYXZhL2xhbmcvT2JqZWN0OwAoTGphdmEvbGFuZy9SZWZsZWN0aXZlT3BlcmF0aW9uRXhjZXB0" +
-    "aW9uOwASTGphdmEvbGFuZy9TdHJpbmc7ABlMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7AB5MamF2" +
-    "YS9sYW5nL2NvbnN0YW50L0NvbnN0YWJsZTsAIUxqYXZhL2xhbmcvY29uc3RhbnQvQ29uc3RhbnRE" +
-    "ZXNjOwAoTGphdmEvbGFuZy9jb25zdGFudC9EeW5hbWljQ29uc3RhbnREZXNjOwAnTGphdmEvbGFu" +
-    "Zy9pbnZva2UvTWV0aG9kSGFuZGxlcyRMb29rdXA7ABZMamF2YS9tYXRoL0JpZ0ludGVnZXI7ABRM" +
-    "amF2YS91dGlsL09wdGlvbmFsOwAUTGphdmEvdXRpbC9PcHRpb25hbDwACUxvbmcuamF2YQAJTUFY" +
-    "X1ZBTFVFAAlNSU5fVkFMVUUAFk1ldGhvZCByZWRlZmluZWQgYXdheSEAIlJlZGVmaW5lZCBMb25n" +
-    "ISB2YWx1ZSAoYXMgZG91YmxlKT0AAVMABFNJWkUABFRZUEUAAVYAAlZKAAZWSklMSUkAAlZMAAFa" +
-    "AAJaTAACW0IAAltDAAFhAAthbm90aGVyTG9uZwAGYXBwZW5kAAFiAApiZWdpbkluZGV4AAhiaXRD" +
-    "b3VudAADYnVmAAlieXRlVmFsdWUAB2NvbXBhcmUACWNvbXBhcmVUbwAPY29tcGFyZVVuc2lnbmVk" +
-    "AAZkZWNvZGUAEWRlc2NyaWJlQ29uc3RhYmxlAAhkaXN0YW5jZQAOZGl2aWRlVW5zaWduZWQACGRp" +
-    "dmlkZW5kAAdkaXZpc29yAAtkb3VibGVWYWx1ZQAIZW5kSW5kZXgABmVxdWFscwAKZmxvYXRWYWx1" +
-    "ZQATZm9ybWF0VW5zaWduZWRMb25nMAAIZ2V0Q2hhcnMAB2dldExvbmcACGhhc2hDb2RlAA1oaWdo" +
-    "ZXN0T25lQml0AAFpAAVpbmRleAAIaW50VmFsdWUAAWwAA2xlbgAJbG9uZ1ZhbHVlAAZsb29rdXAA" +
-    "DGxvd2VzdE9uZUJpdAADbWF4AANtaW4AAm5tABRudW1iZXJPZkxlYWRpbmdaZXJvcwAVbnVtYmVy" +
-    "T2ZUcmFpbGluZ1plcm9zAANvYmoABm9mZnNldAAJcGFyc2VMb25nABFwYXJzZVVuc2lnbmVkTG9u" +
-    "ZwAFcmFkaXgAEXJlbWFpbmRlclVuc2lnbmVkABNyZXNvbHZlQ29uc3RhbnREZXNjAAdyZXZlcnNl" +
-    "AAxyZXZlcnNlQnl0ZXMACnJvdGF0ZUxlZnQAC3JvdGF0ZVJpZ2h0AAFzABBzZXJpYWxWZXJzaW9u" +
-    "VUlEAAVzaGlmdAAKc2hvcnRWYWx1ZQAGc2lnbnVtAApzdHJpbmdTaXplAANzdW0ADnRvQmluYXJ5" +
-    "U3RyaW5nAAt0b0hleFN0cmluZwANdG9PY3RhbFN0cmluZwAIdG9TdHJpbmcAFHRvVW5zaWduZWRC" +
-    "aWdJbnRlZ2VyABB0b1Vuc2lnbmVkU3RyaW5nABF0b1Vuc2lnbmVkU3RyaW5nMAADdmFsAAV2YWx1" +
-    "ZQAHdmFsdWVPZgABeAABeQCbAX5+RDh7ImJhY2tlbmQiOiJkZXgiLCJjb21waWxhdGlvbi1tb2Rl" +
-    "IjoiZGVidWciLCJoYXMtY2hlY2tzdW1zIjpmYWxzZSwibWluLWFwaSI6MSwic2hhLTEiOiJmZWE0" +
-    "ZmY0ZDg1MWIxMThhZWFjZjMxZDRkODJmZmJjYmNiZWE0ZGVmIiwidmVyc2lvbiI6IjguMi44LWRl" +
-    "diJ9AAIGAYMBHAEYDQIFAYMBHAQXABcxFy0XAwIGAYMBHAEYDwIFAYMBHAMXIBckFwMCBQGDARwG" +
-    "FyUXIhckFwMXKxcsBgEvDgAZARkBGQEZARkBGgYSAYiABIAcAYGABMQcAYGABJgcAQmsDwIJwA8D" +
-    "CaAQAQnIEgIJ4BcECOAcAQjAEAEI4BABCegSAQmoEwEJiBMCCaARAQmAGAMJsBgBCcwYAQnsGAEJ" +
-    "4BEBCfgRAQmMGQEJrBkBCcwZAQnsGQEJjBoBCawaAQnMGgMJ7BoBCYAbAQmYGwEJrBsCCZQSAQio" +
-    "EgEJyBsBCeAUAQmAFQEJoBUCCYAWAQmgFgEKoBcBCcAWAQngFgEIgBcBCagUAQnoEwEJiBQFAcwO" +
-    "AgHgDwHBIIAQAwHAFwIB7A4BAawOAQGMDwcBgBEDAcARAQGYGA0ByBMBwSDEFAUB4BsHAcAVBAQI" +
-    "BgAGAARAAAAAAAAAAAEAAABlFwAAAQAAAG4XAAABAAAAfRcAAAEAAACGFwAAAQAAAJMXAADkGAAA" +
-    "AQAAAAwAAAAAAAAABAAAANwYAAADAAAAxBgAAAoAAADEGAAACwAAAMwYAAAgAAAAxBgAACEAAADE" +
-    "GAAAIgAAAMQYAAAjAAAAxBgAACQAAADEGAAAJQAAAMQYAAAoAAAA1BgAADwAAADEGAAAPQAAAMQY" +
-    "AAARAAAAAAAAAAEAAAAAAAAAAQAAAIgAAABwAAAAAgAAABwAAACQAgAAAwAAACUAAAAAAwAABAAA" +
-    "AAcAAAC8BAAABQAAAEMAAAD0BAAABgAAAAEAAAAMBwAAASAAAD0AAAAsBwAAAyAAADwAAACADgAA" +
-    "ARAAABAAAADoDwAAAiAAAIgAAAB+EAAABCAAAAUAAABlFwAAACAAAAEAAACmFwAABSAAAAEAAAC0" +
-    "GAAAAxAAAAYAAADAGAAABiAAAAEAAADsGAAAABAAAAEAAABkGQAA"
-    );
+    "ZGV4CjAzNQCwD214dMo0Mvrm3e2vDCfqFcx5GioGfBxEGwAAcAAAAHhWNBIAAAAAAAAAAHQaAACQ" +
+    "AAAAcAAAAB0AAACwAgAAJQAAACQDAAAHAAAA4AQAAEYAAAAYBQAAAQAAAEgHAADcEwAAaAcAABoR" +
+    "AAAeEQAAIREAACsRAAAzEQAANxEAADoRAABBEQAARBEAAEcRAABKEQAAThEAAFQRAABZEQAAXREA" +
+    "AGARAABkEQAAaREAAG4RAAByEQAAdxEAAH4RAACBEQAAhREAAIkRAACOEQAAkhEAAJcRAACcEQAA" +
+    "oREAAMcRAADmEQAAAhIAABwSAAAvEgAAQhIAAFoSAAByEgAAhRIAAJcSAACrEgAAzhIAAOISAAAM" +
+    "EwAAIBMAADsTAABbEwAAfhMAAKcTAAC/EwAA1RMAAOsTAAD2EwAAARQAAAwUAAAkFAAASBQAAEsU" +
+    "AABRFAAAVxQAAFoUAABeFAAAZhQAAGoUAABtFAAAcRQAAHUUAAB5FAAAfBQAAIkUAACWFAAAnhQA" +
+    "AKEUAACtFAAAtxQAALwUAADHFAAA0BQAANsUAADsFAAA9hQAAP4UAAARFQAAGxUAACsVAAA1FQAA" +
+    "PhUAAEsVAABVFQAAXRUAAGUVAABxFQAAhhUAAJAVAACZFQAAoxUAALIVAAC1FQAAvBUAAMYVAADJ" +
+    "FQAAzhUAANkVAADhFQAA7xUAAPUVAAAAFgAABRYAAAoWAAARFgAAFRYAACsWAABCFgAARxYAAE8W" +
+    "AABfFgAAahYAAH0WAACEFgAAlxYAAKwWAAC1FgAAwxYAAM8WAADcFgAA3xYAAPEWAAD4FgAABBcA" +
+    "AAwXAAAYFwAAHRcAAC0XAAA6FwAASRcAAFMXAABpFwAAexcAAI4XAACTFwAAmhcAAKMXAACmFwAA" +
+    "qRcAAAUAAAAHAAAACAAAAAkAAAAOAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAjAAAAJQAAACYAAAAn" +
+    "AAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADgAAAA7AAAAPwAAAEEA" +
+    "AABCAAAABQAAAAAAAAAAAAAABwAAAAEAAAAAAAAACAAAAAIAAAAAAAAACQAAAAMAAAAAAAAACgAA" +
+    "AAMAAACQEAAACwAAAAMAAACYEAAACwAAAAMAAACkEAAADAAAAAMAAACwEAAADQAAAAMAAAC4EAAA" +
+    "DQAAAAMAAADAEAAADgAAAAQAAAAAAAAADwAAAAQAAACQEAAAEAAAAAQAAADIEAAAEQAAAAQAAACw" +
+    "EAAAFAAAAAQAAADQEAAAEgAAAAQAAADcEAAAEwAAAAQAAADkEAAAFwAAAAwAAACQEAAAGQAAAAwA" +
+    "AADcEAAAGgAAAAwAAADkEAAAGwAAAAwAAADsEAAAHAAAAAwAAAD0EAAAGQAAAAwAAAD8EAAAGQAA" +
+    "AA8AAAD8EAAAFQAAABEAAAAAAAAAFwAAABEAAACQEAAAGAAAABEAAADIEAAAFgAAABIAAAAEEQAA" +
+    "GQAAABIAAADcEAAAFwAAABYAAACQEAAAFQAAABcAAAAAAAAAOAAAABgAAAAAAAAAOwAAABkAAAAA" +
+    "AAAAPAAAABkAAACQEAAAPQAAABkAAAAMEQAAPgAAABkAAADcEAAAQAAAABoAAADAEAAADAADAAYA" +
+    "AAAMAAQANAAAAAwABAA1AAAADAADADkAAAAMAAkAOgAAAAwABAB9AAAADAAEAIsAAAALACMAAwAA" +
+    "AAwAIAACAAAADAAhAAMAAAAMACMAAwAAAAwABABJAAAADAAAAEsAAAAMAAcATAAAAAwACABNAAAA" +
+    "DAAJAE0AAAAMAAcATgAAAAwADQBPAAAADAASAFAAAAAMAB4AUQAAAAwADQBTAAAADAABAFYAAAAM" +
+    "ACQAWAAAAAwADQBZAAAADAACAFoAAAAMACIAWwAAAAwABQBcAAAADAAGAFwAAAAMABIAXQAAAAwA" +
+    "FABdAAAADAAVAF0AAAAMAAMAXgAAAAwABABeAAAADAALAF8AAAAMAAMAYgAAAAwACgBlAAAADAAL" +
+    "AGcAAAAMAA0AagAAAAwADQBrAAAADAAEAG4AAAAMAAQAbwAAAAwACwByAAAADAAOAHMAAAAMAA8A" +
+    "cwAAAAwAEABzAAAADAAOAHQAAAAMAA8AdAAAAAwAEAB0AAAADAANAHYAAAAMABYAdwAAAAwAFwB3" +
+    "AAAADAALAHgAAAAMAAsAeQAAAAwADAB6AAAADAAMAHsAAAAMAB8AfwAAAAwABACAAAAADAAEAIEA" +
+    "AAAMAA0AggAAAAwAGQCDAAAADAAZAIQAAAAMABkAhQAAAAwAGACGAAAADAAZAIYAAAAMABoAhgAA" +
+    "AAwAHQCHAAAADAAZAIgAAAAMABoAiAAAAAwAGgCJAAAADAARAIwAAAAMABIAjAAAAAwAEwCMAAAA" +
+    "DQAgAAMAAAASACAAAwAAABIAGwBGAAAAEgAcAEYAAAASABgAhgAAAAwAAAARAAAADQAAAIQQAAAz" +
+    "AAAA9BkAAJcYAACxGQAABAACAAIAAAAEDwAACAAAACIACwAaATYAcCAAABAAJwADAAEAAgAAAAoP" +
+    "AAAIAAAAIgALABoBNgBwIAAAEAAnAAMAAQACAAAADw8AAAgAAAAiAAsAGgE2AHAgAAAQACcAAwAB" +
+    "AAIAAAAUDwAACAAAACIACwAaATYAcCAAABAAJwADAAIAAAAAABkPAAACAAAAElAPAAYABAACAAAA" +
+    "Hg8AAAgAAAAiAAsAGgE2AHAgAAAQACcABAACAAIAAAAnDwAACAAAACIACwAaATYAcCAAABAAJwAC" +
+    "AAIAAgAAAC0PAAAHAAAAHwEMAG4gBwAQAAoBDwEAAAYABAACAAAAMg8AAAgAAAAiAAsAGgE2AHAg" +
+    "AAAQACcABgAEAAIAAAA7DwAACAAAACIACwAaATYAcCAAABAAJwAGAAQAAgAAAEIPAAAIAAAAIgAL" +
+    "ABoBNgBwIAAAEAAnAAMAAQACAAAASQ8AAAgAAAAiAAsAGgE2AHAgAAAQACcABAACAAIAAABODwAA" +
+    "CAAAACIACwAaATYAcCAAABAAJwADAAEAAgAAAFUPAAAIAAAAIgALABoBNgBwIAAAEAAnAAQAAgAA" +
+    "AAAAWg8AAAQAAACbAAIChAEPAQQAAgAAAAAAXw8AAAYAAAASEKUAAgDAIIQBDwEDAAIAAAAAAGQP" +
+    "AAACAAAAEgAPAAQAAgACAAAAaQ8AAAgAAAAiAAsAGgE2AHAgAAAQACcAAwABAAIAAABvDwAACAAA" +
+    "ACIACwAaATYAcCAAABAAJwADAAEAAgAAAHUPAAAIAAAAIgALABoBNgBwIAAAEAAnAAQAAgACAAAA" +
+    "ew8AAAgAAAAiAAsAGgE2AHAgAAAQACcABQADAAIAAACDDwAACAAAACIACwAaATYAcCAAABAAJwAE" +
+    "AAIAAgAAAIsPAAAIAAAAIgALABoBNgBwIAAAEAAnAAMAAQACAAAAkQ8AAAgAAAAiAAsAGgE2AHAg" +
+    "AAAQACcABAACAAIAAACXDwAACAAAACIACwAaATYAcCAAABAAJwADAAIAAwAAAJ4PAAAGAAAAIgAM" +
+    "AHAwAgAQAhEAAgACAAIAAAAtDwAABQAAAG4gKgAQAAwBEQEAAAQAAgACAAAAow8AAAgAAAAiAAsA" +
+    "GgE2AHAgAAAQACcABAACAAIAAACoDwAACAAAACIACwAaATYAcCAAABAAJwAEAAIAAgAAAK0PAAAI" +
+    "AAAAIgALABoBNgBwIAAAEAAnAAQAAQADAAAAsg8AABcAAAAiABIAcBBCAAAAGgE3AG4gRAAQAAwA" +
+    "UzEGAIYRbjBDABACDABuEEUAAAAMABEAAAAEAAIAAgAAALYPAAAIAAAAIgALABoBNgBwIAAAEAAn" +
+    "AAUAAwACAAAAuw8AAAgAAAAiAAsAGgE2AHAgAAAQACcABAACAAIAAADBDwAACAAAACIACwAaATYA" +
+    "cCAAABAAJwAFAAMAAgAAAMYPAAAIAAAAIgALABoBNgBwIAAAEAAnAAUAAwACAAAAzA8AAAgAAAAi" +
+    "AAsAGgE2AHAgAAAQACcABAACAAIAAADTDwAACAAAACIACwAaATYAcCAAABAAJwADAAEAAgAAANgP" +
+    "AAAIAAAAIgALABoBNgBwIAAAEAAnAAYABAAAAAAA3Q8AAAMAAAAWAP//EAAAAAYABAACAAAA4w8A" +
+    "AAgAAAAiAAsAGgE2AHAgAAAQACcABgAEAAAAAADqDwAAAwAAABYA//8QAAAABAACAAAAAADwDwAA" +
+    "BAAAABYAAQC7IBAAAwABAAAAAAD1DwAAAwAAAFMgBgAQAAAABAACAAAAAAD6DwAABQAAABYAAQCc" +
+    "AAIAEAAAAAYABAACAAAA/w8AAAgAAAAiAAsAGgE2AHAgAAAQACcABgAEAAIAAAAGEAAACAAAACIA" +
+    "CwAaATYAcCAAABAAJwAEAAIAAAAAAA0QAAADAAAAFgAAABAAAAAGAAQAAgAAABIQAAAIAAAAIgAL" +
+    "ABoBNgBwIAAAEAAnAAMAAQACAAAAGhAAAAgAAAAiAAsAGgE2AHAgAAAQACcABAACAAIAAAAfEAAA" +
+    "CAAAACIACwAaATYAcCAAABAAJwAGAAQAAgAAACUQAAAIAAAAIgALABoBNgBwIAAAEAAnAAMAAQAC" +
+    "AAAALhAAAAgAAAAiAAsAGgE2AHAgAAAQACcABAACAAIAAAA0EAAACAAAACIACwAaATYAcCAAABAA" +
+    "JwAGAAQAAgAAADsQAAAIAAAAIgALABoBNgBwIAAAEAAnAAQAAgAAAAAAQhAAAAIAAAB9IBAABAAC" +
+    "AAAAAABHEAAAAwAAABYAAAAQAAAAAwADAAAAAABMEAAAAQAAABAAAAAFAAMAAAAAAFIQAAAFAAAA" +
+    "FgAKAJ0AAAIQAAAABgAEAAAAAABYEAAAAwAAAJsAAgQQAAAAAwABAAIAAABeEAAACAAAACIACwAa" +
+    "ATYAcCAAABAAJwABAAAAAAAAAGMQAAAEAAAAEgBpAAQADgAEAAIAAwAAAGgQAAANAAAAFgAAAHAw" +
+    "AgACASIACwAaATYAcCAAABAAJwAAAAMAAwABAAAAbxAAAAYAAABwEEEAAABaAQYADgAIAAYAAgAA" +
+    "AHcQAAAIAAAAIgALABoBNgBwIAAAEAAnAK8BAXEOAJcBAA4ApgEADgCjAQAOACsBYQ4AvgECjgGP" +
+    "AQ4AuwEBRg4ACAEADgDBAQKOAY8BDgBuA2FiSw4AcQNhYksOAKkBAA4ArAEBjAEOAJ0BAA4AIwFh" +
+    "DgAnAWEOAEYBYQ4AdAGOAQ4AjwEBbg4AsgEBbg4AuAECbosBDgC1AQJuiwEOANwBAWcOAIwBAX0O" +
+    "AIkBAn12DgAXAWQOAF8BYQ4AWQFhDgBcAWEOAE0ADgBoAWEOAFACYXYOAGsBYQ4AUwJhdg4AYgKL" +
+    "AX8OAFYBYQ4A1gEADgA7AmFpDgDEAQJVVg4APwJhaQ4AGwFhDgCgAQAOAB8BYQ4AzAECREgOAM8B" +
+    "AkRIDgBCAWoOAH0EfUlYdg4AegF9DgB3An12DgCGAQR9SVh2DgCDAQF9DgCAAQJ9dg4AxwECVVYO" +
+    "ADcBYQ4ASgFhDgAvAmFTDgAzAmFTDgAPAkRIDgCaAQAOAAsADjwAkwEBfQ5aABIBjAEOPC0AZQWL" +
+    "AX9LcmUOAAAAAAMAAAAKABMAFAAAAAEAAAAEAAAAAwAAAAQAAwAbAAAAAwAAAAQAAwAcAAAAAgAA" +
+    "AAQABAABAAAADAAAAAEAAAAPAAAAAgAAAAQAAwAEAAAACAADAAMAAwABAAAAEQAAAAIAAAARAAMA" +
+    "AgAAABEABAACAAAAEQAMAAEAAAAVAAAAAQAAAAEAAAAFAAAABAADABsAAwADAAIoKQABKwAIPGNs" +
+    "aW5pdD4ABjxpbml0PgACPjsAAUIABUJZVEVTAAFEAAFGAAFJAAJJSgAESUpJTAADSUpKAAJJTAAB" +
+    "SgACSkoAA0pKSQADSkpKAAJKTAADSkxJAAVKTElJSQABTAACTEQAAkxKAANMSkkAAkxMAANMTEkA" +
+    "A0xMSgADTExMACRMZGFsdmlrL2Fubm90YXRpb24vTWV0aG9kUGFyYW1ldGVyczsAHUxkYWx2aWsv" +
+    "YW5ub3RhdGlvbi9TaWduYXR1cmU7ABpMZGFsdmlrL2Fubm90YXRpb24vVGhyb3dzOwAYTGphdmEv" +
+    "bGFuZy9DaGFyU2VxdWVuY2U7ABFMamF2YS9sYW5nL0NsYXNzOwARTGphdmEvbGFuZy9DbGFzczwA" +
+    "FkxqYXZhL2xhbmcvQ29tcGFyYWJsZTsAFkxqYXZhL2xhbmcvQ29tcGFyYWJsZTwAEUxqYXZhL2xh" +
+    "bmcvRXJyb3I7ABBMamF2YS9sYW5nL0xvbmc7ABJMamF2YS9sYW5nL051bWJlcjsAIUxqYXZhL2xh" +
+    "bmcvTnVtYmVyRm9ybWF0RXhjZXB0aW9uOwASTGphdmEvbGFuZy9PYmplY3Q7AChMamF2YS9sYW5n" +
+    "L1JlZmxlY3RpdmVPcGVyYXRpb25FeGNlcHRpb247ABJMamF2YS9sYW5nL1N0cmluZzsAGUxqYXZh" +
+    "L2xhbmcvU3RyaW5nQnVpbGRlcjsAHkxqYXZhL2xhbmcvY29uc3RhbnQvQ29uc3RhYmxlOwAhTGph" +
+    "dmEvbGFuZy9jb25zdGFudC9Db25zdGFudERlc2M7ACdMamF2YS9sYW5nL2ludm9rZS9NZXRob2RI" +
+    "YW5kbGVzJExvb2t1cDsAFkxqYXZhL21hdGgvQmlnSW50ZWdlcjsAFExqYXZhL3V0aWwvT3B0aW9u" +
+    "YWw7ABRMamF2YS91dGlsL09wdGlvbmFsPAAJTG9uZy5qYXZhAAlNQVhfVkFMVUUACU1JTl9WQUxV" +
+    "RQAWTWV0aG9kIHJlZGVmaW5lZCBhd2F5IQAiUmVkZWZpbmVkIExvbmchIHZhbHVlIChhcyBkb3Vi" +
+    "bGUpPQABUwAEU0laRQAEVFlQRQABVgACVkoABlZKSUxJSQACVkwAAVoAAlpMAAJbQgACW0MAAWEA" +
+    "C2FjY2Vzc0ZsYWdzAAthbm90aGVyTG9uZwAGYXBwZW5kAAFiAApiZWdpbkluZGV4AAhiaXRDb3Vu" +
+    "dAADYnVmAAlieXRlVmFsdWUAB2NvbXBhcmUACWNvbXBhcmVUbwAPY29tcGFyZVVuc2lnbmVkAAhj" +
+    "b21wcmVzcwAGZGVjb2RlABFkZXNjcmliZUNvbnN0YWJsZQAIZGlzdGFuY2UADmRpdmlkZVVuc2ln" +
+    "bmVkAAhkaXZpZGVuZAAHZGl2aXNvcgALZG91YmxlVmFsdWUACGVuZEluZGV4AAZlcXVhbHMABmV4" +
+    "cGFuZAAKZmxvYXRWYWx1ZQATZm9ybWF0VW5zaWduZWRMb25nMAAIZ2V0Q2hhcnMAB2dldExvbmcA" +
+    "CGhhc2hDb2RlAA1oaWdoZXN0T25lQml0AAFpAAVpbmRleAAIaW50VmFsdWUAAWwAA2xlbgAJbG9u" +
+    "Z1ZhbHVlAAZsb29rdXAADGxvd2VzdE9uZUJpdAAEbWFzawAJbWFza0NvdW50AANtYXgAA21pbgAF" +
+    "bmFtZXMAAm5tABRudW1iZXJPZkxlYWRpbmdaZXJvcwAVbnVtYmVyT2ZUcmFpbGluZ1plcm9zAANv" +
+    "YmoABm9mZnNldAAOcGFyYWxsZWxTdWZmaXgACXBhcnNlTG9uZwARcGFyc2VVbnNpZ25lZExvbmcA" +
+    "BXJhZGl4ABFyZW1haW5kZXJVbnNpZ25lZAATcmVzb2x2ZUNvbnN0YW50RGVzYwAHcmV2ZXJzZQAM" +
+    "cmV2ZXJzZUJ5dGVzAApyb3RhdGVMZWZ0AAtyb3RhdGVSaWdodAABcwAQc2VyaWFsVmVyc2lvblVJ" +
+    "RAAFc2hpZnQACnNob3J0VmFsdWUABnNpZ251bQAKc3RyaW5nU2l6ZQADc3VtAA50b0JpbmFyeVN0" +
+    "cmluZwALdG9IZXhTdHJpbmcADXRvT2N0YWxTdHJpbmcACHRvU3RyaW5nABR0b1Vuc2lnbmVkQmln" +
+    "SW50ZWdlcgAQdG9VbnNpZ25lZFN0cmluZwARdG9VbnNpZ25lZFN0cmluZzAAA3ZhbAAFdmFsdWUA" +
+    "B3ZhbHVlT2YAAXgAAXkAmwF+fkQ4eyJiYWNrZW5kIjoiZGV4IiwiY29tcGlsYXRpb24tbW9kZSI6" +
+    "ImRlYnVnIiwiaGFzLWNoZWNrc3VtcyI6ZmFsc2UsIm1pbi1hcGkiOjEsInNoYS0xIjoiZWFlNDNh" +
+    "MzAyODgyMjQ4ZmExYzU4NDUzZjJjZGViMjNiMGZkZDU1MCIsInZlcnNpb24iOiI4LjkuMS1kZXYi" +
+    "fQACBwGLARwBGA4CBgGLARwFFwAXMhcBFy4XBAIFAkQcASQAEGwcAR4CBwGLARwBGBACBgGLARwD" +
+    "FyIXJhcEAgYBiwEcBhcnFyQXJhcEFy0XLgYBMg4AGQEZARkBGQEZARoGEgGIgASEHQGBgATIHQGB" +
+    "gAScHQEJ6A8CCfwPAwncEAEJnBgBCYQTAgm0GAMJ1BgCCOQdAQj8EAEInBEBCaQTAQnkEwEJxBMC" +
+    "CdwRAQnsGAMJnBkBCbgZAQnYGQEJnBIBCbQSAQr4GQEJkBoBCbAaAQnQGgEJ8BoBCZAbAQmwGwEJ" +
+    "0BsDCfAbAQmEHAEJnBwBCbAcAgnQEgEI5BIBCcwcAQmcFQEJvBUBCdwVAgm8FgEJ3BYBCtwXAQn8" +
+    "FgEJnBcBCLwXAQnkFAEJpBQBCcQUBQGIDwIBnBABwSC8EAQB/BcCAagPAQHoDgIByA8HAbwRAwH8" +
+    "EQEBhBkOAYQUAcEggBUFAeQcBwH8FQQECAYABgAEQAAAAAAAAAEAAABHGAAAAQAAAFAYAAABAAAA" +
+    "YRgAAAIAAABhGAAAbhgAAAEAAAB3GAAAAQAAAIQYAADsGQAAAQAAAA0AAAAAAAAABAAAAOQZAAAD" +
+    "AAAAwBkAAAgAAADQGQAACwAAAMAZAAAMAAAAyBkAACMAAADAGQAAJAAAAMAZAAAlAAAAwBkAACYA" +
+    "AADAGQAAJwAAAMAZAAAoAAAAwBkAACsAAADYGQAAPwAAAMAZAABAAAAAwBkAABEAAAAAAAAAAQAA" +
+    "AAAAAAABAAAAkAAAAHAAAAACAAAAHQAAALACAAADAAAAJQAAACQDAAAEAAAABwAAAOAEAAAFAAAA" +
+    "RgAAABgFAAAGAAAAAQAAAEgHAAABIAAAQAAAAGgHAAADIAAAPwAAAAQPAAABEAAAEAAAAIQQAAAC" +
+    "IAAAkAAAABoRAAAEIAAABgAAAEcYAAAAIAAAAQAAAJcYAAAFIAAAAQAAALEZAAADEAAABwAAALwZ" +
+    "AAAGIAAAAQAAAPQZAAAAEAAAAQAAAHQaAAA=");
 
   static class FuncCmp implements LongPredicate {
     final String name;
diff --git a/test/954-invoke-polymorphic-verifier/expected-stdout.txt b/test/954-invoke-polymorphic-verifier/expected-stdout.txt
index d49af9648f..65f9785050 100644
--- a/test/954-invoke-polymorphic-verifier/expected-stdout.txt
+++ b/test/954-invoke-polymorphic-verifier/expected-stdout.txt
@@ -1,9 +1,9 @@
 java.lang.VerifyError: Verifier rejected class MethodHandleNotInvoke: void MethodHandleNotInvoke.<init>() failed to verify: void MethodHandleNotInvoke.<init>(): void MethodHandleNotInvoke.<init>(): couldn't find method java.lang.invoke.MethodHandle.notInvoke ([Ljava/lang/Object;)Ljava/lang/Object;
 java.lang.VerifyError: Verifier rejected class MethodHandleToString: void MethodHandleToString.<init>() failed to verify: void MethodHandleToString.<init>(): void MethodHandleToString.<init>(): invoke type (METHOD_POLYMORPHIC) does not match method type of java.lang.String java.lang.invoke.MethodHandle.toString()
-java.lang.VerifyError: Verifier rejected class NonReference: void NonReference.<init>() failed to verify: void NonReference.<init>(): void NonReference.<init>(): tried to get class from non-reference register v0 (type=Precise Low-half Constant: 0)
+java.lang.VerifyError: Verifier rejected class NonReference: void NonReference.<init>() failed to verify: void NonReference.<init>(): void NonReference.<init>(): tried to get class from non-reference register v0 (type=Low-half Constant)
 java.lang.VerifyError: Verifier rejected class TooFewArguments: void TooFewArguments.<init>() failed to verify: void TooFewArguments.<init>(): void TooFewArguments.<init>(): Rejecting invocation, expected 2 argument registers, method signature has 3 or more
 java.lang.VerifyError: Verifier rejected class TooManyArguments: void TooManyArguments.<init>() failed to verify: void TooManyArguments.<init>(): void TooManyArguments.<init>(): Rejecting invocation, expected 4 argument registers, method signature has 3
-java.lang.VerifyError: Verifier rejected class BadThis: void BadThis.<init>() failed to verify: void BadThis.<init>(): void BadThis.<init>(): 'this' argument 'Precise Reference: java.lang.String' not instance of 'Reference: java.lang.invoke.MethodHandle'
+java.lang.VerifyError: Verifier rejected class BadThis: void BadThis.<init>() failed to verify: void BadThis.<init>(): void BadThis.<init>(): 'this' argument 'Reference: java.lang.String' not instance of 'Reference: java.lang.invoke.MethodHandle'
 java.lang.VerifyError: Verifier rejected class FakeSignaturePolymorphic: void FakeSignaturePolymorphic.<init>() failed to verify: void FakeSignaturePolymorphic.<init>(): void FakeSignaturePolymorphic.<init>(): invoke type (METHOD_POLYMORPHIC) does not match method type of java.lang.Object Main.invoke(java.lang.Object[])
 java.lang.VerifyError: Verifier rejected class BetterFakeSignaturePolymorphic: void BetterFakeSignaturePolymorphic.<init>() failed to verify: void BetterFakeSignaturePolymorphic.<init>(): Signature polymorphic method in unsuppported class: Main
 Passed Subclass test
diff --git a/test/956-methodhandles/src/Main.java b/test/956-methodhandles/src/Main.java
index 168862c040..51f7a17779 100644
--- a/test/956-methodhandles/src/Main.java
+++ b/test/956-methodhandles/src/Main.java
@@ -185,6 +185,12 @@ public class Main {
         MethodType.methodType(void.class), D.class /* specialCaller */);
     mh3.invoke(dInstance);
 
+    try {
+      mh3.invokeExact((D) null);
+      fail("Expected NPE to be thrown");
+    } catch (NullPointerException expected) {
+    }
+
     // The private method shouldn't be accessible from any special caller except
     // itself...
     try {
diff --git a/test/963-default-range-smali/Android.bp b/test/963-default-range-smali/Android.bp
index b4cb157e47..1baf04d1c5 100644
--- a/test/963-default-range-smali/Android.bp
+++ b/test/963-default-range-smali/Android.bp
@@ -21,6 +21,9 @@ java_test {
         ":art-run-test-963-default-range-smali-expected-stdout",
         ":art-run-test-963-default-range-smali-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/965-default-verify/Android.bp b/test/965-default-verify/Android.bp
index 40e51e0ee4..d14b458a14 100644
--- a/test/965-default-verify/Android.bp
+++ b/test/965-default-verify/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-965-default-verify-expected-stdout",
         ":art-run-test-965-default-verify-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/967-default-ame/Android.bp b/test/967-default-ame/Android.bp
index ee8c864b14..703c84deb2 100644
--- a/test/967-default-ame/Android.bp
+++ b/test/967-default-ame/Android.bp
@@ -31,6 +31,9 @@ java_test {
         ":art-run-test-967-default-ame-expected-stdout",
         ":art-run-test-967-default-ame-expected-stderr",
     ],
+    test_suites: [
+        "mts-art",
+    ],
 }
 
 // Test's expected standard output.
diff --git a/test/983-source-transform-verify/source_transform_art.cc b/test/983-source-transform-verify/source_transform_art.cc
index 289874b95b..852810474d 100644
--- a/test/983-source-transform-verify/source_transform_art.cc
+++ b/test/983-source-transform-verify/source_transform_art.cc
@@ -54,7 +54,7 @@ void VerifyClassData(jint class_data_len, const unsigned char* class_data) {
     for (const ClassAccessor::Method& method : accessor.GetMethods()) {
       for (const DexInstructionPcPair& pair : method.GetInstructions()) {
         const Instruction& inst = pair.Inst();
-        int forbidden_flags = (Instruction::kVerifyError | Instruction::kVerifyRuntimeOnly);
+        int forbidden_flags = Instruction::kVerifyError;
         if ((inst.GetVerifyExtraFlags() & forbidden_flags) != 0) {
           LOG(FATAL) << "Unexpected instruction found in " << dex->PrettyMethod(method.GetIndex())
                      << " [Dex PC: 0x" << std::hex << pair.DexPc() << std::dec << "] : "
diff --git a/test/Android.bp b/test/Android.bp
index eef30336e3..a0e2f5980d 100644
--- a/test/Android.bp
+++ b/test/Android.bp
@@ -85,12 +85,6 @@ cc_defaults {
         android_x86_64: {
             relative_install_path: "art/x86_64",
         },
-        android: {
-            test_for: [
-                "com.android.art",
-                "com.android.art.debug",
-            ],
-        },
     },
     // Tests aren't generally included in any APEX, but this is necessary to
     // avoid duplicate install rules for them by making them unavailable to platform.
@@ -110,12 +104,6 @@ art_cc_defaults {
     name: "art_test_internal_library_defaults",
     defaults: ["art_test_defaults"],
     target: {
-        android: {
-            test_for: [
-                "com.android.art",
-                "com.android.art.debug",
-            ],
-        },
         android_arm: {
             relative_install_path: "com.android.art/lib",
         },
@@ -539,7 +527,6 @@ java_defaults {
     },
     test_suites: [
         "general-tests",
-        "mts-art",
     ],
     host_required: [
         "art-run-test-checker",
@@ -556,7 +543,7 @@ art_cc_test_library {
     defaults: ["libarttest-defaults"],
     shared_libs: [
         "libart",
-        "libdexfile",
+        "libdexfile#impl",
         "libprofile",
         "libartbase",
     ],
@@ -570,7 +557,7 @@ art_cc_test_library {
     ],
     shared_libs: [
         "libartd",
-        "libdexfiled",
+        "libdexfiled#impl",
         "libprofiled",
         "libartbased",
     ],
@@ -784,7 +771,7 @@ art_cc_test_library {
     defaults: ["libtiagent-defaults"],
     shared_libs: [
         "libart",
-        "libdexfile",
+        "libdexfile#impl",
         "libprofile",
         "libartbase",
     ],
@@ -798,7 +785,7 @@ art_cc_test_library {
     ],
     shared_libs: [
         "libartd",
-        "libdexfiled",
+        "libdexfiled#impl",
         "libprofiled",
         "libartbased",
     ],
@@ -1338,13 +1325,12 @@ art_cc_test {
     // It seems that only device-tests build can create a valid apex.
     test_suites: [
         "device-tests",
-        "mts-art",
     ],
     test_config: "art-gtests-target-install-apex.xml",
 
     // Support multilib variants (using different suffix per sub-architecture), which is needed on
-    // build targets with secondary architectures, as the MTS test suite packaging logic flattens
-    // all test artifacts into a single `testcases` directory.
+    // build targets with secondary architectures, as the packaging logic for some test suites
+    // flattens all test artifacts into a single `testcases` directory.
     compile_multilib: "both",
     multilib: {
         lib32: {
@@ -1354,10 +1340,6 @@ art_cc_test {
             suffix: "64",
         },
     },
-    test_for: [
-        "com.android.art",
-        "com.android.art.debug",
-    ],
 }
 
 art_cc_test {
@@ -1370,10 +1352,6 @@ art_cc_test {
     ],
     test_suites: ["general-tests"],
     test_config: "art-gtests-target-chroot.xml",
-    test_for: [
-        "com.android.art",
-        "com.android.art.debug",
-    ],
 }
 
 csuite_test {
@@ -1383,7 +1361,7 @@ csuite_test {
 
 filegroup {
     name: "art-gtest-jars",
-    srcs: [
+    device_common_srcs: [
         ":art-gtest-jars-AbstractMethod",
         ":art-gtest-jars-AllFields",
         ":art-gtest-jars-ArrayClassWithUnresolvedComponent",
@@ -1722,7 +1700,7 @@ genrule_defaults {
 }
 
 // A copy of Main with the classes.dex stripped for the oat file assistant tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MainStripped",
     srcs: [":art-gtest-jars-Main"],
     cmd: "$(location zip2zip) -i $(in) -o $(out) -x 'classes*.dex'",
@@ -1731,7 +1709,7 @@ genrule {
 }
 
 // An empty.dex that is empty and uncompressed for the dex2oat tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MainEmptyUncompressed",
     srcs: ["Main/empty.dex"],
     cmd: "$(location soong_zip) -j -L 0 -o $(out) -f $(in)",
@@ -1740,7 +1718,7 @@ genrule {
 }
 
 // An empty.dex that is empty and uncompressed and aligned for the dex2oat tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MainEmptyUncompressedAligned",
     defaults: ["art-gtest-jars-align-defaults"],
     srcs: [":art-gtest-jars-MainEmptyUncompressed"],
@@ -1748,7 +1726,7 @@ genrule {
 }
 
 // A copy of Main with the classes.dex uncompressed for the dex2oat tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MainUncompressed",
     defaults: ["art-gtest-jars-uncompress-defaults"],
     srcs: [":art-gtest-jars-Main"],
@@ -1756,7 +1734,7 @@ genrule {
 }
 
 // A copy of Main with the classes.dex uncompressed and aligned for the dex2oat tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MainUncompressedAligned",
     defaults: ["art-gtest-jars-align-defaults"],
     srcs: [":art-gtest-jars-MainUncompressed"],
@@ -1775,7 +1753,7 @@ java_library {
 }
 
 // A copy of MultiDex with the classes.dex uncompressed for the OatFile tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MultiDexUncompressed",
     defaults: ["art-gtest-jars-uncompress-defaults"],
     srcs: [":art-gtest-jars-MultiDex"],
@@ -1783,7 +1761,7 @@ genrule {
 }
 
 // A copy of MultiDex with the classes.dex uncompressed and aligned for the OatFile tests.
-genrule {
+java_genrule {
     name: "art-gtest-jars-MultiDexUncompressedAligned",
     defaults: ["art-gtest-jars-align-defaults"],
     srcs: [":art-gtest-jars-MultiDexUncompressed"],
diff --git a/test/Android.run-test.bp b/test/Android.run-test.bp
index 4bbeb4a1b7..f119ec75b4 100644
--- a/test/Android.run-test.bp
+++ b/test/Android.run-test.bp
@@ -21,10 +21,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard00-fg",
+    device_common_srcs: [":art-run-test-host-data-shard00-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard00",
-    src: ":art-run-test-host-data-shard00-tmp",
+    src: ":art-run-test-host-data-shard00-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard00.zip",
 }
@@ -40,10 +47,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard01-fg",
+    device_common_srcs: [":art-run-test-host-data-shard01-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard01",
-    src: ":art-run-test-host-data-shard01-tmp",
+    src: ":art-run-test-host-data-shard01-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard01.zip",
 }
@@ -59,10 +73,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard02-fg",
+    device_common_srcs: [":art-run-test-host-data-shard02-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard02",
-    src: ":art-run-test-host-data-shard02-tmp",
+    src: ":art-run-test-host-data-shard02-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard02.zip",
 }
@@ -78,10 +99,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard03-fg",
+    device_common_srcs: [":art-run-test-host-data-shard03-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard03",
-    src: ":art-run-test-host-data-shard03-tmp",
+    src: ":art-run-test-host-data-shard03-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard03.zip",
 }
@@ -97,10 +125,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard04-fg",
+    device_common_srcs: [":art-run-test-host-data-shard04-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard04",
-    src: ":art-run-test-host-data-shard04-tmp",
+    src: ":art-run-test-host-data-shard04-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard04.zip",
 }
@@ -116,10 +151,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard05-fg",
+    device_common_srcs: [":art-run-test-host-data-shard05-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard05",
-    src: ":art-run-test-host-data-shard05-tmp",
+    src: ":art-run-test-host-data-shard05-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard05.zip",
 }
@@ -135,10 +177,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard06-fg",
+    device_common_srcs: [":art-run-test-host-data-shard06-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard06",
-    src: ":art-run-test-host-data-shard06-tmp",
+    src: ":art-run-test-host-data-shard06-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard06.zip",
 }
@@ -154,10 +203,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard07-fg",
+    device_common_srcs: [":art-run-test-host-data-shard07-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard07",
-    src: ":art-run-test-host-data-shard07-tmp",
+    src: ":art-run-test-host-data-shard07-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard07.zip",
 }
@@ -173,10 +229,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard08-fg",
+    device_common_srcs: [":art-run-test-host-data-shard08-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard08",
-    src: ":art-run-test-host-data-shard08-tmp",
+    src: ":art-run-test-host-data-shard08-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard08.zip",
 }
@@ -192,10 +255,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard09-fg",
+    device_common_srcs: [":art-run-test-host-data-shard09-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard09",
-    src: ":art-run-test-host-data-shard09-tmp",
+    src: ":art-run-test-host-data-shard09-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard09.zip",
 }
@@ -211,10 +281,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard10-fg",
+    device_common_srcs: [":art-run-test-host-data-shard10-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard10",
-    src: ":art-run-test-host-data-shard10-tmp",
+    src: ":art-run-test-host-data-shard10-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard10.zip",
 }
@@ -230,10 +307,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard11-fg",
+    device_common_srcs: [":art-run-test-host-data-shard11-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard11",
-    src: ":art-run-test-host-data-shard11-tmp",
+    src: ":art-run-test-host-data-shard11-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard11.zip",
 }
@@ -249,10 +333,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard12-fg",
+    device_common_srcs: [":art-run-test-host-data-shard12-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard12",
-    src: ":art-run-test-host-data-shard12-tmp",
+    src: ":art-run-test-host-data-shard12-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard12.zip",
 }
@@ -268,10 +359,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard13-fg",
+    device_common_srcs: [":art-run-test-host-data-shard13-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard13",
-    src: ":art-run-test-host-data-shard13-tmp",
+    src: ":art-run-test-host-data-shard13-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard13.zip",
 }
@@ -287,10 +385,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard14-fg",
+    device_common_srcs: [":art-run-test-host-data-shard14-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard14",
-    src: ":art-run-test-host-data-shard14-tmp",
+    src: ":art-run-test-host-data-shard14-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard14.zip",
 }
@@ -306,10 +411,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard15-fg",
+    device_common_srcs: [":art-run-test-host-data-shard15-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard15",
-    src: ":art-run-test-host-data-shard15-tmp",
+    src: ":art-run-test-host-data-shard15-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard15.zip",
 }
@@ -325,10 +437,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard16-fg",
+    device_common_srcs: [":art-run-test-host-data-shard16-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard16",
-    src: ":art-run-test-host-data-shard16-tmp",
+    src: ":art-run-test-host-data-shard16-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard16.zip",
 }
@@ -344,10 +463,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard17-fg",
+    device_common_srcs: [":art-run-test-host-data-shard17-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard17",
-    src: ":art-run-test-host-data-shard17-tmp",
+    src: ":art-run-test-host-data-shard17-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard17.zip",
 }
@@ -363,10 +489,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard18-fg",
+    device_common_srcs: [":art-run-test-host-data-shard18-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard18",
-    src: ":art-run-test-host-data-shard18-tmp",
+    src: ":art-run-test-host-data-shard18-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard18.zip",
 }
@@ -382,10 +515,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard19-fg",
+    device_common_srcs: [":art-run-test-host-data-shard19-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard19",
-    src: ":art-run-test-host-data-shard19-tmp",
+    src: ":art-run-test-host-data-shard19-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard19.zip",
 }
@@ -401,10 +541,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard20-fg",
+    device_common_srcs: [":art-run-test-host-data-shard20-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard20",
-    src: ":art-run-test-host-data-shard20-tmp",
+    src: ":art-run-test-host-data-shard20-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard20.zip",
 }
@@ -420,10 +567,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard21-fg",
+    device_common_srcs: [":art-run-test-host-data-shard21-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard21",
-    src: ":art-run-test-host-data-shard21-tmp",
+    src: ":art-run-test-host-data-shard21-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard21.zip",
 }
@@ -439,10 +593,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard22-fg",
+    device_common_srcs: [":art-run-test-host-data-shard22-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard22",
-    src: ":art-run-test-host-data-shard22-tmp",
+    src: ":art-run-test-host-data-shard22-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard22.zip",
 }
@@ -458,10 +619,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard23-fg",
+    device_common_srcs: [":art-run-test-host-data-shard23-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard23",
-    src: ":art-run-test-host-data-shard23-tmp",
+    src: ":art-run-test-host-data-shard23-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard23.zip",
 }
@@ -477,10 +645,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard24-fg",
+    device_common_srcs: [":art-run-test-host-data-shard24-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard24",
-    src: ":art-run-test-host-data-shard24-tmp",
+    src: ":art-run-test-host-data-shard24-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard24.zip",
 }
@@ -496,10 +671,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard25-fg",
+    device_common_srcs: [":art-run-test-host-data-shard25-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard25",
-    src: ":art-run-test-host-data-shard25-tmp",
+    src: ":art-run-test-host-data-shard25-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard25.zip",
 }
@@ -515,10 +697,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard26-fg",
+    device_common_srcs: [":art-run-test-host-data-shard26-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard26",
-    src: ":art-run-test-host-data-shard26-tmp",
+    src: ":art-run-test-host-data-shard26-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard26.zip",
 }
@@ -534,10 +723,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard27-fg",
+    device_common_srcs: [":art-run-test-host-data-shard27-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard27",
-    src: ":art-run-test-host-data-shard27-tmp",
+    src: ":art-run-test-host-data-shard27-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard27.zip",
 }
@@ -553,10 +749,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard28-fg",
+    device_common_srcs: [":art-run-test-host-data-shard28-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard28",
-    src: ":art-run-test-host-data-shard28-tmp",
+    src: ":art-run-test-host-data-shard28-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard28.zip",
 }
@@ -572,10 +775,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard29-fg",
+    device_common_srcs: [":art-run-test-host-data-shard29-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard29",
-    src: ":art-run-test-host-data-shard29-tmp",
+    src: ":art-run-test-host-data-shard29-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard29.zip",
 }
@@ -591,10 +801,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard30-fg",
+    device_common_srcs: [":art-run-test-host-data-shard30-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard30",
-    src: ":art-run-test-host-data-shard30-tmp",
+    src: ":art-run-test-host-data-shard30-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard30.zip",
 }
@@ -610,10 +827,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard31-fg",
+    device_common_srcs: [":art-run-test-host-data-shard31-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard31",
-    src: ":art-run-test-host-data-shard31-tmp",
+    src: ":art-run-test-host-data-shard31-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard31.zip",
 }
@@ -629,10 +853,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard32-fg",
+    device_common_srcs: [":art-run-test-host-data-shard32-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard32",
-    src: ":art-run-test-host-data-shard32-tmp",
+    src: ":art-run-test-host-data-shard32-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard32.zip",
 }
@@ -648,10 +879,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard33-fg",
+    device_common_srcs: [":art-run-test-host-data-shard33-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard33",
-    src: ":art-run-test-host-data-shard33-tmp",
+    src: ":art-run-test-host-data-shard33-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard33.zip",
 }
@@ -667,10 +905,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard34-fg",
+    device_common_srcs: [":art-run-test-host-data-shard34-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard34",
-    src: ":art-run-test-host-data-shard34-tmp",
+    src: ":art-run-test-host-data-shard34-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard34.zip",
 }
@@ -686,10 +931,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard35-fg",
+    device_common_srcs: [":art-run-test-host-data-shard35-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard35",
-    src: ":art-run-test-host-data-shard35-tmp",
+    src: ":art-run-test-host-data-shard35-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard35.zip",
 }
@@ -705,10 +957,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard36-fg",
+    device_common_srcs: [":art-run-test-host-data-shard36-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard36",
-    src: ":art-run-test-host-data-shard36-tmp",
+    src: ":art-run-test-host-data-shard36-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard36.zip",
 }
@@ -724,10 +983,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard37-fg",
+    device_common_srcs: [":art-run-test-host-data-shard37-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard37",
-    src: ":art-run-test-host-data-shard37-tmp",
+    src: ":art-run-test-host-data-shard37-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard37.zip",
 }
@@ -743,10 +1009,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard38-fg",
+    device_common_srcs: [":art-run-test-host-data-shard38-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard38",
-    src: ":art-run-test-host-data-shard38-tmp",
+    src: ":art-run-test-host-data-shard38-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard38.zip",
 }
@@ -762,10 +1035,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard39-fg",
+    device_common_srcs: [":art-run-test-host-data-shard39-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard39",
-    src: ":art-run-test-host-data-shard39-tmp",
+    src: ":art-run-test-host-data-shard39-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard39.zip",
 }
@@ -781,10 +1061,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard40-fg",
+    device_common_srcs: [":art-run-test-host-data-shard40-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard40",
-    src: ":art-run-test-host-data-shard40-tmp",
+    src: ":art-run-test-host-data-shard40-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard40.zip",
 }
@@ -800,10 +1087,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard41-fg",
+    device_common_srcs: [":art-run-test-host-data-shard41-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard41",
-    src: ":art-run-test-host-data-shard41-tmp",
+    src: ":art-run-test-host-data-shard41-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard41.zip",
 }
@@ -819,10 +1113,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard42-fg",
+    device_common_srcs: [":art-run-test-host-data-shard42-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard42",
-    src: ":art-run-test-host-data-shard42-tmp",
+    src: ":art-run-test-host-data-shard42-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard42.zip",
 }
@@ -838,10 +1139,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard43-fg",
+    device_common_srcs: [":art-run-test-host-data-shard43-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard43",
-    src: ":art-run-test-host-data-shard43-tmp",
+    src: ":art-run-test-host-data-shard43-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard43.zip",
 }
@@ -857,10 +1165,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard44-fg",
+    device_common_srcs: [":art-run-test-host-data-shard44-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard44",
-    src: ":art-run-test-host-data-shard44-tmp",
+    src: ":art-run-test-host-data-shard44-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard44.zip",
 }
@@ -876,10 +1191,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard45-fg",
+    device_common_srcs: [":art-run-test-host-data-shard45-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard45",
-    src: ":art-run-test-host-data-shard45-tmp",
+    src: ":art-run-test-host-data-shard45-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard45.zip",
 }
@@ -895,10 +1217,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard46-fg",
+    device_common_srcs: [":art-run-test-host-data-shard46-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard46",
-    src: ":art-run-test-host-data-shard46-tmp",
+    src: ":art-run-test-host-data-shard46-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard46.zip",
 }
@@ -914,10 +1243,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard47-fg",
+    device_common_srcs: [":art-run-test-host-data-shard47-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard47",
-    src: ":art-run-test-host-data-shard47-tmp",
+    src: ":art-run-test-host-data-shard47-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard47.zip",
 }
@@ -933,10 +1269,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard48-fg",
+    device_common_srcs: [":art-run-test-host-data-shard48-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard48",
-    src: ":art-run-test-host-data-shard48-tmp",
+    src: ":art-run-test-host-data-shard48-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard48.zip",
 }
@@ -952,10 +1295,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard49-fg",
+    device_common_srcs: [":art-run-test-host-data-shard49-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard49",
-    src: ":art-run-test-host-data-shard49-tmp",
+    src: ":art-run-test-host-data-shard49-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard49.zip",
 }
@@ -971,10 +1321,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard50-fg",
+    device_common_srcs: [":art-run-test-host-data-shard50-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard50",
-    src: ":art-run-test-host-data-shard50-tmp",
+    src: ":art-run-test-host-data-shard50-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard50.zip",
 }
@@ -990,10 +1347,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard51-fg",
+    device_common_srcs: [":art-run-test-host-data-shard51-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard51",
-    src: ":art-run-test-host-data-shard51-tmp",
+    src: ":art-run-test-host-data-shard51-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard51.zip",
 }
@@ -1009,10 +1373,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard52-fg",
+    device_common_srcs: [":art-run-test-host-data-shard52-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard52",
-    src: ":art-run-test-host-data-shard52-tmp",
+    src: ":art-run-test-host-data-shard52-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard52.zip",
 }
@@ -1028,10 +1399,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard53-fg",
+    device_common_srcs: [":art-run-test-host-data-shard53-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard53",
-    src: ":art-run-test-host-data-shard53-tmp",
+    src: ":art-run-test-host-data-shard53-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard53.zip",
 }
@@ -1047,10 +1425,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard54-fg",
+    device_common_srcs: [":art-run-test-host-data-shard54-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard54",
-    src: ":art-run-test-host-data-shard54-tmp",
+    src: ":art-run-test-host-data-shard54-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard54.zip",
 }
@@ -1066,10 +1451,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard55-fg",
+    device_common_srcs: [":art-run-test-host-data-shard55-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard55",
-    src: ":art-run-test-host-data-shard55-tmp",
+    src: ":art-run-test-host-data-shard55-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard55.zip",
 }
@@ -1085,10 +1477,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard56-fg",
+    device_common_srcs: [":art-run-test-host-data-shard56-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard56",
-    src: ":art-run-test-host-data-shard56-tmp",
+    src: ":art-run-test-host-data-shard56-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard56.zip",
 }
@@ -1104,10 +1503,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard57-fg",
+    device_common_srcs: [":art-run-test-host-data-shard57-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard57",
-    src: ":art-run-test-host-data-shard57-tmp",
+    src: ":art-run-test-host-data-shard57-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard57.zip",
 }
@@ -1123,10 +1529,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard58-fg",
+    device_common_srcs: [":art-run-test-host-data-shard58-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard58",
-    src: ":art-run-test-host-data-shard58-tmp",
+    src: ":art-run-test-host-data-shard58-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard58.zip",
 }
@@ -1142,10 +1555,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard59-fg",
+    device_common_srcs: [":art-run-test-host-data-shard59-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard59",
-    src: ":art-run-test-host-data-shard59-tmp",
+    src: ":art-run-test-host-data-shard59-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard59.zip",
 }
@@ -1161,10 +1581,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard60-fg",
+    device_common_srcs: [":art-run-test-host-data-shard60-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard60",
-    src: ":art-run-test-host-data-shard60-tmp",
+    src: ":art-run-test-host-data-shard60-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard60.zip",
 }
@@ -1180,10 +1607,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard61-fg",
+    device_common_srcs: [":art-run-test-host-data-shard61-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard61",
-    src: ":art-run-test-host-data-shard61-tmp",
+    src: ":art-run-test-host-data-shard61-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard61.zip",
 }
@@ -1199,10 +1633,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard62-fg",
+    device_common_srcs: [":art-run-test-host-data-shard62-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard62",
-    src: ":art-run-test-host-data-shard62-tmp",
+    src: ":art-run-test-host-data-shard62-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard62.zip",
 }
@@ -1218,10 +1659,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard63-fg",
+    device_common_srcs: [":art-run-test-host-data-shard63-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard63",
-    src: ":art-run-test-host-data-shard63-tmp",
+    src: ":art-run-test-host-data-shard63-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard63.zip",
 }
@@ -1237,10 +1685,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard64-fg",
+    device_common_srcs: [":art-run-test-host-data-shard64-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard64",
-    src: ":art-run-test-host-data-shard64-tmp",
+    src: ":art-run-test-host-data-shard64-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard64.zip",
 }
@@ -1256,10 +1711,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard65-fg",
+    device_common_srcs: [":art-run-test-host-data-shard65-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard65",
-    src: ":art-run-test-host-data-shard65-tmp",
+    src: ":art-run-test-host-data-shard65-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard65.zip",
 }
@@ -1275,10 +1737,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard66-fg",
+    device_common_srcs: [":art-run-test-host-data-shard66-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard66",
-    src: ":art-run-test-host-data-shard66-tmp",
+    src: ":art-run-test-host-data-shard66-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard66.zip",
 }
@@ -1294,10 +1763,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard67-fg",
+    device_common_srcs: [":art-run-test-host-data-shard67-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard67",
-    src: ":art-run-test-host-data-shard67-tmp",
+    src: ":art-run-test-host-data-shard67-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard67.zip",
 }
@@ -1313,10 +1789,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard68-fg",
+    device_common_srcs: [":art-run-test-host-data-shard68-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard68",
-    src: ":art-run-test-host-data-shard68-tmp",
+    src: ":art-run-test-host-data-shard68-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard68.zip",
 }
@@ -1332,10 +1815,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard69-fg",
+    device_common_srcs: [":art-run-test-host-data-shard69-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard69",
-    src: ":art-run-test-host-data-shard69-tmp",
+    src: ":art-run-test-host-data-shard69-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard69.zip",
 }
@@ -1351,10 +1841,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard70-fg",
+    device_common_srcs: [":art-run-test-host-data-shard70-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard70",
-    src: ":art-run-test-host-data-shard70-tmp",
+    src: ":art-run-test-host-data-shard70-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard70.zip",
 }
@@ -1370,10 +1867,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard71-fg",
+    device_common_srcs: [":art-run-test-host-data-shard71-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard71",
-    src: ":art-run-test-host-data-shard71-tmp",
+    src: ":art-run-test-host-data-shard71-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard71.zip",
 }
@@ -1389,10 +1893,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard72-fg",
+    device_common_srcs: [":art-run-test-host-data-shard72-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard72",
-    src: ":art-run-test-host-data-shard72-tmp",
+    src: ":art-run-test-host-data-shard72-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard72.zip",
 }
@@ -1408,10 +1919,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard73-fg",
+    device_common_srcs: [":art-run-test-host-data-shard73-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard73",
-    src: ":art-run-test-host-data-shard73-tmp",
+    src: ":art-run-test-host-data-shard73-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard73.zip",
 }
@@ -1427,10 +1945,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard74-fg",
+    device_common_srcs: [":art-run-test-host-data-shard74-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard74",
-    src: ":art-run-test-host-data-shard74-tmp",
+    src: ":art-run-test-host-data-shard74-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard74.zip",
 }
@@ -1446,10 +1971,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard75-fg",
+    device_common_srcs: [":art-run-test-host-data-shard75-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard75",
-    src: ":art-run-test-host-data-shard75-tmp",
+    src: ":art-run-test-host-data-shard75-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard75.zip",
 }
@@ -1465,10 +1997,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard76-fg",
+    device_common_srcs: [":art-run-test-host-data-shard76-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard76",
-    src: ":art-run-test-host-data-shard76-tmp",
+    src: ":art-run-test-host-data-shard76-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard76.zip",
 }
@@ -1484,10 +2023,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard77-fg",
+    device_common_srcs: [":art-run-test-host-data-shard77-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard77",
-    src: ":art-run-test-host-data-shard77-tmp",
+    src: ":art-run-test-host-data-shard77-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard77.zip",
 }
@@ -1503,10 +2049,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard78-fg",
+    device_common_srcs: [":art-run-test-host-data-shard78-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard78",
-    src: ":art-run-test-host-data-shard78-tmp",
+    src: ":art-run-test-host-data-shard78-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard78.zip",
 }
@@ -1522,10 +2075,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard79-fg",
+    device_common_srcs: [":art-run-test-host-data-shard79-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard79",
-    src: ":art-run-test-host-data-shard79-tmp",
+    src: ":art-run-test-host-data-shard79-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard79.zip",
 }
@@ -1541,10 +2101,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard80-fg",
+    device_common_srcs: [":art-run-test-host-data-shard80-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard80",
-    src: ":art-run-test-host-data-shard80-tmp",
+    src: ":art-run-test-host-data-shard80-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard80.zip",
 }
@@ -1560,10 +2127,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard81-fg",
+    device_common_srcs: [":art-run-test-host-data-shard81-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard81",
-    src: ":art-run-test-host-data-shard81-tmp",
+    src: ":art-run-test-host-data-shard81-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard81.zip",
 }
@@ -1579,10 +2153,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard82-fg",
+    device_common_srcs: [":art-run-test-host-data-shard82-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard82",
-    src: ":art-run-test-host-data-shard82-tmp",
+    src: ":art-run-test-host-data-shard82-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard82.zip",
 }
@@ -1598,10 +2179,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard83-fg",
+    device_common_srcs: [":art-run-test-host-data-shard83-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard83",
-    src: ":art-run-test-host-data-shard83-tmp",
+    src: ":art-run-test-host-data-shard83-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard83.zip",
 }
@@ -1617,10 +2205,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard84-fg",
+    device_common_srcs: [":art-run-test-host-data-shard84-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard84",
-    src: ":art-run-test-host-data-shard84-tmp",
+    src: ":art-run-test-host-data-shard84-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard84.zip",
 }
@@ -1636,10 +2231,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard85-fg",
+    device_common_srcs: [":art-run-test-host-data-shard85-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard85",
-    src: ":art-run-test-host-data-shard85-tmp",
+    src: ":art-run-test-host-data-shard85-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard85.zip",
 }
@@ -1655,10 +2257,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard86-fg",
+    device_common_srcs: [":art-run-test-host-data-shard86-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard86",
-    src: ":art-run-test-host-data-shard86-tmp",
+    src: ":art-run-test-host-data-shard86-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard86.zip",
 }
@@ -1674,10 +2283,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard87-fg",
+    device_common_srcs: [":art-run-test-host-data-shard87-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard87",
-    src: ":art-run-test-host-data-shard87-tmp",
+    src: ":art-run-test-host-data-shard87-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard87.zip",
 }
@@ -1693,10 +2309,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard88-fg",
+    device_common_srcs: [":art-run-test-host-data-shard88-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard88",
-    src: ":art-run-test-host-data-shard88-tmp",
+    src: ":art-run-test-host-data-shard88-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard88.zip",
 }
@@ -1712,10 +2335,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard89-fg",
+    device_common_srcs: [":art-run-test-host-data-shard89-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard89",
-    src: ":art-run-test-host-data-shard89-tmp",
+    src: ":art-run-test-host-data-shard89-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard89.zip",
 }
@@ -1731,10 +2361,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard90-fg",
+    device_common_srcs: [":art-run-test-host-data-shard90-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard90",
-    src: ":art-run-test-host-data-shard90-tmp",
+    src: ":art-run-test-host-data-shard90-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard90.zip",
 }
@@ -1750,10 +2387,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard91-fg",
+    device_common_srcs: [":art-run-test-host-data-shard91-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard91",
-    src: ":art-run-test-host-data-shard91-tmp",
+    src: ":art-run-test-host-data-shard91-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard91.zip",
 }
@@ -1769,10 +2413,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard92-fg",
+    device_common_srcs: [":art-run-test-host-data-shard92-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard92",
-    src: ":art-run-test-host-data-shard92-tmp",
+    src: ":art-run-test-host-data-shard92-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard92.zip",
 }
@@ -1788,10 +2439,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard93-fg",
+    device_common_srcs: [":art-run-test-host-data-shard93-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard93",
-    src: ":art-run-test-host-data-shard93-tmp",
+    src: ":art-run-test-host-data-shard93-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard93.zip",
 }
@@ -1807,10 +2465,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard94-fg",
+    device_common_srcs: [":art-run-test-host-data-shard94-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard94",
-    src: ":art-run-test-host-data-shard94-tmp",
+    src: ":art-run-test-host-data-shard94-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard94.zip",
 }
@@ -1826,10 +2491,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard95-fg",
+    device_common_srcs: [":art-run-test-host-data-shard95-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard95",
-    src: ":art-run-test-host-data-shard95-tmp",
+    src: ":art-run-test-host-data-shard95-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard95.zip",
 }
@@ -1845,10 +2517,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard96-fg",
+    device_common_srcs: [":art-run-test-host-data-shard96-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard96",
-    src: ":art-run-test-host-data-shard96-tmp",
+    src: ":art-run-test-host-data-shard96-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard96.zip",
 }
@@ -1864,10 +2543,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard97-fg",
+    device_common_srcs: [":art-run-test-host-data-shard97-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard97",
-    src: ":art-run-test-host-data-shard97-tmp",
+    src: ":art-run-test-host-data-shard97-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard97.zip",
 }
@@ -1883,10 +2569,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard98-fg",
+    device_common_srcs: [":art-run-test-host-data-shard98-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard98",
-    src: ":art-run-test-host-data-shard98-tmp",
+    src: ":art-run-test-host-data-shard98-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard98.zip",
 }
@@ -1902,10 +2595,17 @@ java_genrule {
     defaults: ["art-run-test-host-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shard99-fg",
+    device_common_srcs: [":art-run-test-host-data-shard99-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shard99",
-    src: ":art-run-test-host-data-shard99-tmp",
+    src: ":art-run-test-host-data-shard99-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shard99.zip",
 }
@@ -1922,26 +2622,30 @@ java_genrule {
     cmd: TEST_BUILD_COMMON_ARGS + "--hiddenapi $(location hiddenapi) --mode host --test-dir-regex 'art/test/....?-[^/]*hiddenapi' $(in)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-shardHiddenApi-fg",
+    device_common_srcs: [":art-run-test-host-data-shardHiddenApi-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-shardHiddenApi",
-    src: ":art-run-test-host-data-shardHiddenApi-tmp",
+    src: ":art-run-test-host-data-shardHiddenApi-fg",
     sub_dir: "art",
     filename: "art-run-test-host-data-shardHiddenApi.zip",
 }
 
 genrule_defaults {
     name: "art-run-test-host-data-defaults",
-    tool_files: [
-        "run_test_build.py",
-        ":art-run-test-bootclasspath",
-    ],
     srcs: [
         // Since genrules are sandboxed, all the sources they use must be listed in
         // the Android.bp file. Some tests have symlinks to files from other tests, and
         // those must also be listed to avoid a dangling symlink in the sandbox.
         "jvmti-common/*.java",
         "utils/python/**/*.py",
+        ":art-run-test-bootclasspath",
         ":development_docs",
         ":asm-9.6-filegroup",
         ":ojluni-AbstractCollection",
@@ -1952,6 +2656,13 @@ genrule_defaults {
         "988-method-trace/trace_fib.cc",
         "1953-pop-frame/src/art/Test1953.java",
         "1953-pop-frame/src/art/SuspendEvents.java",
+        // Files needed to generate runner scripts.
+        "testrunner/*.py",
+        "knownfailures.json",
+        "default_run.py",
+        "globals.py",
+        "run-test",
+        "run_test_build.py",
     ],
     tools: [
         "android-smali",
@@ -1965,7 +2676,7 @@ genrule_defaults {
 
 java_genrule {
     name: "art-run-test-host-data-merged-tmp",
-    out: ["art-run-test-host-data-merged.zip"],
+    out: ["art-run-test-host-data-merged.tgz"],
     srcs: [
         ":art-run-test-host-data-shard00-tmp",
         ":art-run-test-host-data-shard01-tmp",
@@ -2069,14 +2780,21 @@ java_genrule {
         ":art-run-test-host-data-shard99-tmp",
         ":art-run-test-host-data-shardHiddenApi-tmp",
     ],
-    tools: ["merge_zips"],
-    cmd: "$(location merge_zips) $(out) $(in)",
+    tool_files: ["merge_zips_to_tgz.py"],
+    cmd: "$(location merge_zips_to_tgz.py) $(out) $(in)",
+}
+
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-merged-fg",
+    device_common_srcs: [":art-run-test-host-data-merged-tmp"],
 }
 
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-host-data-merged",
-    src: ":art-run-test-host-data-merged-tmp",
+    src: ":art-run-test-host-data-merged-fg",
     required: [
         "art-run-test-host-data-shard00",
         "art-run-test-host-data-shard01",
@@ -2181,7 +2899,7 @@ prebuilt_etc_host {
         "art-run-test-host-data-shardHiddenApi",
     ],
     sub_dir: "art",
-    filename: "art-run-test-host-data-merged.zip",
+    filename: "art-run-test-host-data-merged.tgz",
 }
 
 // Phony target used to build all shards
@@ -2294,10 +3012,17 @@ java_genrule {
     cmd: "echo $(in) > $(out)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-host-data-fg",
+    device_common_srcs: [":art-run-test-host-data-tmp"],
+}
+
 // Phony target used to install all shards
 prebuilt_etc_host {
     name: "art-run-test-host-data",
-    src: ":art-run-test-host-data-tmp",
+    src: ":art-run-test-host-data-fg",
     required: [
         "art-run-test-host-data-shard00",
         "art-run-test-host-data-shard01",
@@ -2416,10 +3141,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard00-fg",
+    device_common_srcs: [":art-run-test-target-data-shard00-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard00",
-    src: ":art-run-test-target-data-shard00-tmp",
+    src: ":art-run-test-target-data-shard00-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard00.zip",
 }
@@ -2435,10 +3167,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard01-fg",
+    device_common_srcs: [":art-run-test-target-data-shard01-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard01",
-    src: ":art-run-test-target-data-shard01-tmp",
+    src: ":art-run-test-target-data-shard01-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard01.zip",
 }
@@ -2454,10 +3193,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard02-fg",
+    device_common_srcs: [":art-run-test-target-data-shard02-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard02",
-    src: ":art-run-test-target-data-shard02-tmp",
+    src: ":art-run-test-target-data-shard02-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard02.zip",
 }
@@ -2473,10 +3219,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard03-fg",
+    device_common_srcs: [":art-run-test-target-data-shard03-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard03",
-    src: ":art-run-test-target-data-shard03-tmp",
+    src: ":art-run-test-target-data-shard03-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard03.zip",
 }
@@ -2492,10 +3245,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard04-fg",
+    device_common_srcs: [":art-run-test-target-data-shard04-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard04",
-    src: ":art-run-test-target-data-shard04-tmp",
+    src: ":art-run-test-target-data-shard04-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard04.zip",
 }
@@ -2511,10 +3271,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard05-fg",
+    device_common_srcs: [":art-run-test-target-data-shard05-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard05",
-    src: ":art-run-test-target-data-shard05-tmp",
+    src: ":art-run-test-target-data-shard05-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard05.zip",
 }
@@ -2530,10 +3297,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard06-fg",
+    device_common_srcs: [":art-run-test-target-data-shard06-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard06",
-    src: ":art-run-test-target-data-shard06-tmp",
+    src: ":art-run-test-target-data-shard06-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard06.zip",
 }
@@ -2549,10 +3323,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard07-fg",
+    device_common_srcs: [":art-run-test-target-data-shard07-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard07",
-    src: ":art-run-test-target-data-shard07-tmp",
+    src: ":art-run-test-target-data-shard07-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard07.zip",
 }
@@ -2568,10 +3349,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard08-fg",
+    device_common_srcs: [":art-run-test-target-data-shard08-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard08",
-    src: ":art-run-test-target-data-shard08-tmp",
+    src: ":art-run-test-target-data-shard08-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard08.zip",
 }
@@ -2587,10 +3375,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard09-fg",
+    device_common_srcs: [":art-run-test-target-data-shard09-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard09",
-    src: ":art-run-test-target-data-shard09-tmp",
+    src: ":art-run-test-target-data-shard09-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard09.zip",
 }
@@ -2606,10 +3401,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard10-fg",
+    device_common_srcs: [":art-run-test-target-data-shard10-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard10",
-    src: ":art-run-test-target-data-shard10-tmp",
+    src: ":art-run-test-target-data-shard10-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard10.zip",
 }
@@ -2625,10 +3427,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard11-fg",
+    device_common_srcs: [":art-run-test-target-data-shard11-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard11",
-    src: ":art-run-test-target-data-shard11-tmp",
+    src: ":art-run-test-target-data-shard11-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard11.zip",
 }
@@ -2644,10 +3453,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard12-fg",
+    device_common_srcs: [":art-run-test-target-data-shard12-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard12",
-    src: ":art-run-test-target-data-shard12-tmp",
+    src: ":art-run-test-target-data-shard12-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard12.zip",
 }
@@ -2663,10 +3479,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard13-fg",
+    device_common_srcs: [":art-run-test-target-data-shard13-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard13",
-    src: ":art-run-test-target-data-shard13-tmp",
+    src: ":art-run-test-target-data-shard13-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard13.zip",
 }
@@ -2682,10 +3505,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard14-fg",
+    device_common_srcs: [":art-run-test-target-data-shard14-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard14",
-    src: ":art-run-test-target-data-shard14-tmp",
+    src: ":art-run-test-target-data-shard14-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard14.zip",
 }
@@ -2701,10 +3531,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard15-fg",
+    device_common_srcs: [":art-run-test-target-data-shard15-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard15",
-    src: ":art-run-test-target-data-shard15-tmp",
+    src: ":art-run-test-target-data-shard15-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard15.zip",
 }
@@ -2720,10 +3557,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard16-fg",
+    device_common_srcs: [":art-run-test-target-data-shard16-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard16",
-    src: ":art-run-test-target-data-shard16-tmp",
+    src: ":art-run-test-target-data-shard16-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard16.zip",
 }
@@ -2739,10 +3583,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard17-fg",
+    device_common_srcs: [":art-run-test-target-data-shard17-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard17",
-    src: ":art-run-test-target-data-shard17-tmp",
+    src: ":art-run-test-target-data-shard17-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard17.zip",
 }
@@ -2758,10 +3609,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard18-fg",
+    device_common_srcs: [":art-run-test-target-data-shard18-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard18",
-    src: ":art-run-test-target-data-shard18-tmp",
+    src: ":art-run-test-target-data-shard18-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard18.zip",
 }
@@ -2777,10 +3635,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard19-fg",
+    device_common_srcs: [":art-run-test-target-data-shard19-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard19",
-    src: ":art-run-test-target-data-shard19-tmp",
+    src: ":art-run-test-target-data-shard19-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard19.zip",
 }
@@ -2796,10 +3661,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard20-fg",
+    device_common_srcs: [":art-run-test-target-data-shard20-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard20",
-    src: ":art-run-test-target-data-shard20-tmp",
+    src: ":art-run-test-target-data-shard20-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard20.zip",
 }
@@ -2815,10 +3687,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard21-fg",
+    device_common_srcs: [":art-run-test-target-data-shard21-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard21",
-    src: ":art-run-test-target-data-shard21-tmp",
+    src: ":art-run-test-target-data-shard21-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard21.zip",
 }
@@ -2834,10 +3713,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard22-fg",
+    device_common_srcs: [":art-run-test-target-data-shard22-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard22",
-    src: ":art-run-test-target-data-shard22-tmp",
+    src: ":art-run-test-target-data-shard22-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard22.zip",
 }
@@ -2853,10 +3739,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard23-fg",
+    device_common_srcs: [":art-run-test-target-data-shard23-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard23",
-    src: ":art-run-test-target-data-shard23-tmp",
+    src: ":art-run-test-target-data-shard23-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard23.zip",
 }
@@ -2872,10 +3765,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard24-fg",
+    device_common_srcs: [":art-run-test-target-data-shard24-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard24",
-    src: ":art-run-test-target-data-shard24-tmp",
+    src: ":art-run-test-target-data-shard24-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard24.zip",
 }
@@ -2891,10 +3791,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard25-fg",
+    device_common_srcs: [":art-run-test-target-data-shard25-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard25",
-    src: ":art-run-test-target-data-shard25-tmp",
+    src: ":art-run-test-target-data-shard25-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard25.zip",
 }
@@ -2910,10 +3817,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard26-fg",
+    device_common_srcs: [":art-run-test-target-data-shard26-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard26",
-    src: ":art-run-test-target-data-shard26-tmp",
+    src: ":art-run-test-target-data-shard26-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard26.zip",
 }
@@ -2929,10 +3843,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard27-fg",
+    device_common_srcs: [":art-run-test-target-data-shard27-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard27",
-    src: ":art-run-test-target-data-shard27-tmp",
+    src: ":art-run-test-target-data-shard27-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard27.zip",
 }
@@ -2948,10 +3869,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard28-fg",
+    device_common_srcs: [":art-run-test-target-data-shard28-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard28",
-    src: ":art-run-test-target-data-shard28-tmp",
+    src: ":art-run-test-target-data-shard28-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard28.zip",
 }
@@ -2967,10 +3895,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard29-fg",
+    device_common_srcs: [":art-run-test-target-data-shard29-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard29",
-    src: ":art-run-test-target-data-shard29-tmp",
+    src: ":art-run-test-target-data-shard29-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard29.zip",
 }
@@ -2986,10 +3921,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard30-fg",
+    device_common_srcs: [":art-run-test-target-data-shard30-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard30",
-    src: ":art-run-test-target-data-shard30-tmp",
+    src: ":art-run-test-target-data-shard30-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard30.zip",
 }
@@ -3005,10 +3947,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard31-fg",
+    device_common_srcs: [":art-run-test-target-data-shard31-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard31",
-    src: ":art-run-test-target-data-shard31-tmp",
+    src: ":art-run-test-target-data-shard31-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard31.zip",
 }
@@ -3024,10 +3973,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard32-fg",
+    device_common_srcs: [":art-run-test-target-data-shard32-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard32",
-    src: ":art-run-test-target-data-shard32-tmp",
+    src: ":art-run-test-target-data-shard32-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard32.zip",
 }
@@ -3043,10 +3999,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard33-fg",
+    device_common_srcs: [":art-run-test-target-data-shard33-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard33",
-    src: ":art-run-test-target-data-shard33-tmp",
+    src: ":art-run-test-target-data-shard33-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard33.zip",
 }
@@ -3062,10 +4025,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard34-fg",
+    device_common_srcs: [":art-run-test-target-data-shard34-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard34",
-    src: ":art-run-test-target-data-shard34-tmp",
+    src: ":art-run-test-target-data-shard34-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard34.zip",
 }
@@ -3081,10 +4051,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard35-fg",
+    device_common_srcs: [":art-run-test-target-data-shard35-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard35",
-    src: ":art-run-test-target-data-shard35-tmp",
+    src: ":art-run-test-target-data-shard35-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard35.zip",
 }
@@ -3100,10 +4077,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard36-fg",
+    device_common_srcs: [":art-run-test-target-data-shard36-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard36",
-    src: ":art-run-test-target-data-shard36-tmp",
+    src: ":art-run-test-target-data-shard36-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard36.zip",
 }
@@ -3119,10 +4103,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard37-fg",
+    device_common_srcs: [":art-run-test-target-data-shard37-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard37",
-    src: ":art-run-test-target-data-shard37-tmp",
+    src: ":art-run-test-target-data-shard37-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard37.zip",
 }
@@ -3138,10 +4129,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard38-fg",
+    device_common_srcs: [":art-run-test-target-data-shard38-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard38",
-    src: ":art-run-test-target-data-shard38-tmp",
+    src: ":art-run-test-target-data-shard38-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard38.zip",
 }
@@ -3157,10 +4155,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard39-fg",
+    device_common_srcs: [":art-run-test-target-data-shard39-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard39",
-    src: ":art-run-test-target-data-shard39-tmp",
+    src: ":art-run-test-target-data-shard39-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard39.zip",
 }
@@ -3176,10 +4181,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard40-fg",
+    device_common_srcs: [":art-run-test-target-data-shard40-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard40",
-    src: ":art-run-test-target-data-shard40-tmp",
+    src: ":art-run-test-target-data-shard40-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard40.zip",
 }
@@ -3195,10 +4207,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard41-fg",
+    device_common_srcs: [":art-run-test-target-data-shard41-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard41",
-    src: ":art-run-test-target-data-shard41-tmp",
+    src: ":art-run-test-target-data-shard41-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard41.zip",
 }
@@ -3214,10 +4233,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard42-fg",
+    device_common_srcs: [":art-run-test-target-data-shard42-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard42",
-    src: ":art-run-test-target-data-shard42-tmp",
+    src: ":art-run-test-target-data-shard42-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard42.zip",
 }
@@ -3233,10 +4259,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard43-fg",
+    device_common_srcs: [":art-run-test-target-data-shard43-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard43",
-    src: ":art-run-test-target-data-shard43-tmp",
+    src: ":art-run-test-target-data-shard43-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard43.zip",
 }
@@ -3252,10 +4285,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard44-fg",
+    device_common_srcs: [":art-run-test-target-data-shard44-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard44",
-    src: ":art-run-test-target-data-shard44-tmp",
+    src: ":art-run-test-target-data-shard44-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard44.zip",
 }
@@ -3271,10 +4311,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard45-fg",
+    device_common_srcs: [":art-run-test-target-data-shard45-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard45",
-    src: ":art-run-test-target-data-shard45-tmp",
+    src: ":art-run-test-target-data-shard45-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard45.zip",
 }
@@ -3290,10 +4337,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard46-fg",
+    device_common_srcs: [":art-run-test-target-data-shard46-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard46",
-    src: ":art-run-test-target-data-shard46-tmp",
+    src: ":art-run-test-target-data-shard46-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard46.zip",
 }
@@ -3309,10 +4363,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard47-fg",
+    device_common_srcs: [":art-run-test-target-data-shard47-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard47",
-    src: ":art-run-test-target-data-shard47-tmp",
+    src: ":art-run-test-target-data-shard47-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard47.zip",
 }
@@ -3328,10 +4389,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard48-fg",
+    device_common_srcs: [":art-run-test-target-data-shard48-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard48",
-    src: ":art-run-test-target-data-shard48-tmp",
+    src: ":art-run-test-target-data-shard48-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard48.zip",
 }
@@ -3347,10 +4415,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard49-fg",
+    device_common_srcs: [":art-run-test-target-data-shard49-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard49",
-    src: ":art-run-test-target-data-shard49-tmp",
+    src: ":art-run-test-target-data-shard49-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard49.zip",
 }
@@ -3366,10 +4441,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard50-fg",
+    device_common_srcs: [":art-run-test-target-data-shard50-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard50",
-    src: ":art-run-test-target-data-shard50-tmp",
+    src: ":art-run-test-target-data-shard50-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard50.zip",
 }
@@ -3385,10 +4467,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard51-fg",
+    device_common_srcs: [":art-run-test-target-data-shard51-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard51",
-    src: ":art-run-test-target-data-shard51-tmp",
+    src: ":art-run-test-target-data-shard51-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard51.zip",
 }
@@ -3404,10 +4493,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard52-fg",
+    device_common_srcs: [":art-run-test-target-data-shard52-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard52",
-    src: ":art-run-test-target-data-shard52-tmp",
+    src: ":art-run-test-target-data-shard52-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard52.zip",
 }
@@ -3423,10 +4519,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard53-fg",
+    device_common_srcs: [":art-run-test-target-data-shard53-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard53",
-    src: ":art-run-test-target-data-shard53-tmp",
+    src: ":art-run-test-target-data-shard53-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard53.zip",
 }
@@ -3442,10 +4545,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard54-fg",
+    device_common_srcs: [":art-run-test-target-data-shard54-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard54",
-    src: ":art-run-test-target-data-shard54-tmp",
+    src: ":art-run-test-target-data-shard54-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard54.zip",
 }
@@ -3461,10 +4571,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard55-fg",
+    device_common_srcs: [":art-run-test-target-data-shard55-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard55",
-    src: ":art-run-test-target-data-shard55-tmp",
+    src: ":art-run-test-target-data-shard55-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard55.zip",
 }
@@ -3480,10 +4597,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard56-fg",
+    device_common_srcs: [":art-run-test-target-data-shard56-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard56",
-    src: ":art-run-test-target-data-shard56-tmp",
+    src: ":art-run-test-target-data-shard56-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard56.zip",
 }
@@ -3499,10 +4623,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard57-fg",
+    device_common_srcs: [":art-run-test-target-data-shard57-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard57",
-    src: ":art-run-test-target-data-shard57-tmp",
+    src: ":art-run-test-target-data-shard57-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard57.zip",
 }
@@ -3518,10 +4649,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard58-fg",
+    device_common_srcs: [":art-run-test-target-data-shard58-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard58",
-    src: ":art-run-test-target-data-shard58-tmp",
+    src: ":art-run-test-target-data-shard58-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard58.zip",
 }
@@ -3537,10 +4675,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard59-fg",
+    device_common_srcs: [":art-run-test-target-data-shard59-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard59",
-    src: ":art-run-test-target-data-shard59-tmp",
+    src: ":art-run-test-target-data-shard59-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard59.zip",
 }
@@ -3556,10 +4701,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard60-fg",
+    device_common_srcs: [":art-run-test-target-data-shard60-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard60",
-    src: ":art-run-test-target-data-shard60-tmp",
+    src: ":art-run-test-target-data-shard60-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard60.zip",
 }
@@ -3575,10 +4727,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard61-fg",
+    device_common_srcs: [":art-run-test-target-data-shard61-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard61",
-    src: ":art-run-test-target-data-shard61-tmp",
+    src: ":art-run-test-target-data-shard61-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard61.zip",
 }
@@ -3594,10 +4753,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard62-fg",
+    device_common_srcs: [":art-run-test-target-data-shard62-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard62",
-    src: ":art-run-test-target-data-shard62-tmp",
+    src: ":art-run-test-target-data-shard62-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard62.zip",
 }
@@ -3613,10 +4779,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard63-fg",
+    device_common_srcs: [":art-run-test-target-data-shard63-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard63",
-    src: ":art-run-test-target-data-shard63-tmp",
+    src: ":art-run-test-target-data-shard63-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard63.zip",
 }
@@ -3632,10 +4805,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard64-fg",
+    device_common_srcs: [":art-run-test-target-data-shard64-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard64",
-    src: ":art-run-test-target-data-shard64-tmp",
+    src: ":art-run-test-target-data-shard64-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard64.zip",
 }
@@ -3651,10 +4831,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard65-fg",
+    device_common_srcs: [":art-run-test-target-data-shard65-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard65",
-    src: ":art-run-test-target-data-shard65-tmp",
+    src: ":art-run-test-target-data-shard65-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard65.zip",
 }
@@ -3670,10 +4857,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard66-fg",
+    device_common_srcs: [":art-run-test-target-data-shard66-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard66",
-    src: ":art-run-test-target-data-shard66-tmp",
+    src: ":art-run-test-target-data-shard66-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard66.zip",
 }
@@ -3689,10 +4883,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard67-fg",
+    device_common_srcs: [":art-run-test-target-data-shard67-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard67",
-    src: ":art-run-test-target-data-shard67-tmp",
+    src: ":art-run-test-target-data-shard67-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard67.zip",
 }
@@ -3708,10 +4909,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard68-fg",
+    device_common_srcs: [":art-run-test-target-data-shard68-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard68",
-    src: ":art-run-test-target-data-shard68-tmp",
+    src: ":art-run-test-target-data-shard68-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard68.zip",
 }
@@ -3727,10 +4935,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard69-fg",
+    device_common_srcs: [":art-run-test-target-data-shard69-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard69",
-    src: ":art-run-test-target-data-shard69-tmp",
+    src: ":art-run-test-target-data-shard69-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard69.zip",
 }
@@ -3746,10 +4961,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard70-fg",
+    device_common_srcs: [":art-run-test-target-data-shard70-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard70",
-    src: ":art-run-test-target-data-shard70-tmp",
+    src: ":art-run-test-target-data-shard70-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard70.zip",
 }
@@ -3765,10 +4987,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard71-fg",
+    device_common_srcs: [":art-run-test-target-data-shard71-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard71",
-    src: ":art-run-test-target-data-shard71-tmp",
+    src: ":art-run-test-target-data-shard71-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard71.zip",
 }
@@ -3784,10 +5013,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard72-fg",
+    device_common_srcs: [":art-run-test-target-data-shard72-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard72",
-    src: ":art-run-test-target-data-shard72-tmp",
+    src: ":art-run-test-target-data-shard72-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard72.zip",
 }
@@ -3803,10 +5039,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard73-fg",
+    device_common_srcs: [":art-run-test-target-data-shard73-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard73",
-    src: ":art-run-test-target-data-shard73-tmp",
+    src: ":art-run-test-target-data-shard73-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard73.zip",
 }
@@ -3822,10 +5065,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard74-fg",
+    device_common_srcs: [":art-run-test-target-data-shard74-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard74",
-    src: ":art-run-test-target-data-shard74-tmp",
+    src: ":art-run-test-target-data-shard74-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard74.zip",
 }
@@ -3841,10 +5091,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard75-fg",
+    device_common_srcs: [":art-run-test-target-data-shard75-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard75",
-    src: ":art-run-test-target-data-shard75-tmp",
+    src: ":art-run-test-target-data-shard75-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard75.zip",
 }
@@ -3860,10 +5117,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard76-fg",
+    device_common_srcs: [":art-run-test-target-data-shard76-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard76",
-    src: ":art-run-test-target-data-shard76-tmp",
+    src: ":art-run-test-target-data-shard76-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard76.zip",
 }
@@ -3879,10 +5143,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard77-fg",
+    device_common_srcs: [":art-run-test-target-data-shard77-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard77",
-    src: ":art-run-test-target-data-shard77-tmp",
+    src: ":art-run-test-target-data-shard77-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard77.zip",
 }
@@ -3898,10 +5169,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard78-fg",
+    device_common_srcs: [":art-run-test-target-data-shard78-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard78",
-    src: ":art-run-test-target-data-shard78-tmp",
+    src: ":art-run-test-target-data-shard78-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard78.zip",
 }
@@ -3917,10 +5195,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard79-fg",
+    device_common_srcs: [":art-run-test-target-data-shard79-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard79",
-    src: ":art-run-test-target-data-shard79-tmp",
+    src: ":art-run-test-target-data-shard79-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard79.zip",
 }
@@ -3936,10 +5221,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard80-fg",
+    device_common_srcs: [":art-run-test-target-data-shard80-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard80",
-    src: ":art-run-test-target-data-shard80-tmp",
+    src: ":art-run-test-target-data-shard80-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard80.zip",
 }
@@ -3955,10 +5247,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard81-fg",
+    device_common_srcs: [":art-run-test-target-data-shard81-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard81",
-    src: ":art-run-test-target-data-shard81-tmp",
+    src: ":art-run-test-target-data-shard81-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard81.zip",
 }
@@ -3974,10 +5273,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard82-fg",
+    device_common_srcs: [":art-run-test-target-data-shard82-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard82",
-    src: ":art-run-test-target-data-shard82-tmp",
+    src: ":art-run-test-target-data-shard82-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard82.zip",
 }
@@ -3993,10 +5299,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard83-fg",
+    device_common_srcs: [":art-run-test-target-data-shard83-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard83",
-    src: ":art-run-test-target-data-shard83-tmp",
+    src: ":art-run-test-target-data-shard83-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard83.zip",
 }
@@ -4012,10 +5325,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard84-fg",
+    device_common_srcs: [":art-run-test-target-data-shard84-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard84",
-    src: ":art-run-test-target-data-shard84-tmp",
+    src: ":art-run-test-target-data-shard84-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard84.zip",
 }
@@ -4031,10 +5351,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard85-fg",
+    device_common_srcs: [":art-run-test-target-data-shard85-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard85",
-    src: ":art-run-test-target-data-shard85-tmp",
+    src: ":art-run-test-target-data-shard85-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard85.zip",
 }
@@ -4050,10 +5377,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard86-fg",
+    device_common_srcs: [":art-run-test-target-data-shard86-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard86",
-    src: ":art-run-test-target-data-shard86-tmp",
+    src: ":art-run-test-target-data-shard86-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard86.zip",
 }
@@ -4069,10 +5403,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard87-fg",
+    device_common_srcs: [":art-run-test-target-data-shard87-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard87",
-    src: ":art-run-test-target-data-shard87-tmp",
+    src: ":art-run-test-target-data-shard87-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard87.zip",
 }
@@ -4088,10 +5429,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard88-fg",
+    device_common_srcs: [":art-run-test-target-data-shard88-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard88",
-    src: ":art-run-test-target-data-shard88-tmp",
+    src: ":art-run-test-target-data-shard88-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard88.zip",
 }
@@ -4107,10 +5455,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard89-fg",
+    device_common_srcs: [":art-run-test-target-data-shard89-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard89",
-    src: ":art-run-test-target-data-shard89-tmp",
+    src: ":art-run-test-target-data-shard89-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard89.zip",
 }
@@ -4126,10 +5481,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard90-fg",
+    device_common_srcs: [":art-run-test-target-data-shard90-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard90",
-    src: ":art-run-test-target-data-shard90-tmp",
+    src: ":art-run-test-target-data-shard90-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard90.zip",
 }
@@ -4145,10 +5507,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard91-fg",
+    device_common_srcs: [":art-run-test-target-data-shard91-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard91",
-    src: ":art-run-test-target-data-shard91-tmp",
+    src: ":art-run-test-target-data-shard91-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard91.zip",
 }
@@ -4164,10 +5533,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard92-fg",
+    device_common_srcs: [":art-run-test-target-data-shard92-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard92",
-    src: ":art-run-test-target-data-shard92-tmp",
+    src: ":art-run-test-target-data-shard92-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard92.zip",
 }
@@ -4183,10 +5559,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard93-fg",
+    device_common_srcs: [":art-run-test-target-data-shard93-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard93",
-    src: ":art-run-test-target-data-shard93-tmp",
+    src: ":art-run-test-target-data-shard93-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard93.zip",
 }
@@ -4202,10 +5585,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard94-fg",
+    device_common_srcs: [":art-run-test-target-data-shard94-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard94",
-    src: ":art-run-test-target-data-shard94-tmp",
+    src: ":art-run-test-target-data-shard94-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard94.zip",
 }
@@ -4221,10 +5611,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard95-fg",
+    device_common_srcs: [":art-run-test-target-data-shard95-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard95",
-    src: ":art-run-test-target-data-shard95-tmp",
+    src: ":art-run-test-target-data-shard95-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard95.zip",
 }
@@ -4240,10 +5637,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard96-fg",
+    device_common_srcs: [":art-run-test-target-data-shard96-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard96",
-    src: ":art-run-test-target-data-shard96-tmp",
+    src: ":art-run-test-target-data-shard96-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard96.zip",
 }
@@ -4259,10 +5663,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard97-fg",
+    device_common_srcs: [":art-run-test-target-data-shard97-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard97",
-    src: ":art-run-test-target-data-shard97-tmp",
+    src: ":art-run-test-target-data-shard97-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard97.zip",
 }
@@ -4278,10 +5689,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard98-fg",
+    device_common_srcs: [":art-run-test-target-data-shard98-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard98",
-    src: ":art-run-test-target-data-shard98-tmp",
+    src: ":art-run-test-target-data-shard98-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard98.zip",
 }
@@ -4297,10 +5715,17 @@ java_genrule {
     defaults: ["art-run-test-target-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shard99-fg",
+    device_common_srcs: [":art-run-test-target-data-shard99-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shard99",
-    src: ":art-run-test-target-data-shard99-tmp",
+    src: ":art-run-test-target-data-shard99-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shard99.zip",
 }
@@ -4317,26 +5742,30 @@ java_genrule {
     cmd: TEST_BUILD_COMMON_ARGS + "--hiddenapi $(location hiddenapi) --mode target --test-dir-regex 'art/test/....?-[^/]*hiddenapi' $(in)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-shardHiddenApi-fg",
+    device_common_srcs: [":art-run-test-target-data-shardHiddenApi-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-shardHiddenApi",
-    src: ":art-run-test-target-data-shardHiddenApi-tmp",
+    src: ":art-run-test-target-data-shardHiddenApi-fg",
     sub_dir: "art",
     filename: "art-run-test-target-data-shardHiddenApi.zip",
 }
 
 genrule_defaults {
     name: "art-run-test-target-data-defaults",
-    tool_files: [
-        "run_test_build.py",
-        ":art-run-test-bootclasspath",
-    ],
     srcs: [
         // Since genrules are sandboxed, all the sources they use must be listed in
         // the Android.bp file. Some tests have symlinks to files from other tests, and
         // those must also be listed to avoid a dangling symlink in the sandbox.
         "jvmti-common/*.java",
         "utils/python/**/*.py",
+        ":art-run-test-bootclasspath",
         ":development_docs",
         ":asm-9.6-filegroup",
         ":ojluni-AbstractCollection",
@@ -4347,6 +5776,13 @@ genrule_defaults {
         "988-method-trace/trace_fib.cc",
         "1953-pop-frame/src/art/Test1953.java",
         "1953-pop-frame/src/art/SuspendEvents.java",
+        // Files needed to generate runner scripts.
+        "testrunner/*.py",
+        "knownfailures.json",
+        "default_run.py",
+        "globals.py",
+        "run-test",
+        "run_test_build.py",
     ],
     tools: [
         "android-smali",
@@ -4360,7 +5796,7 @@ genrule_defaults {
 
 java_genrule {
     name: "art-run-test-target-data-merged-tmp",
-    out: ["art-run-test-target-data-merged.zip"],
+    out: ["art-run-test-target-data-merged.tgz"],
     srcs: [
         ":art-run-test-target-data-shard00-tmp",
         ":art-run-test-target-data-shard01-tmp",
@@ -4464,14 +5900,21 @@ java_genrule {
         ":art-run-test-target-data-shard99-tmp",
         ":art-run-test-target-data-shardHiddenApi-tmp",
     ],
-    tools: ["merge_zips"],
-    cmd: "$(location merge_zips) $(out) $(in)",
+    tool_files: ["merge_zips_to_tgz.py"],
+    cmd: "$(location merge_zips_to_tgz.py) $(out) $(in)",
+}
+
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-merged-fg",
+    device_common_srcs: [":art-run-test-target-data-merged-tmp"],
 }
 
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-target-data-merged",
-    src: ":art-run-test-target-data-merged-tmp",
+    src: ":art-run-test-target-data-merged-fg",
     required: [
         "art-run-test-target-data-shard00",
         "art-run-test-target-data-shard01",
@@ -4576,7 +6019,7 @@ prebuilt_etc_host {
         "art-run-test-target-data-shardHiddenApi",
     ],
     sub_dir: "art",
-    filename: "art-run-test-target-data-merged.zip",
+    filename: "art-run-test-target-data-merged.tgz",
 }
 
 // Phony target used to build all shards
@@ -4689,10 +6132,17 @@ java_genrule {
     cmd: "echo $(in) > $(out)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-target-data-fg",
+    device_common_srcs: [":art-run-test-target-data-tmp"],
+}
+
 // Phony target used to install all shards
 prebuilt_etc_host {
     name: "art-run-test-target-data",
-    src: ":art-run-test-target-data-tmp",
+    src: ":art-run-test-target-data-fg",
     required: [
         "art-run-test-target-data-shard00",
         "art-run-test-target-data-shard01",
@@ -4811,10 +6261,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard00-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard00-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard00",
-    src: ":art-run-test-jvm-data-shard00-tmp",
+    src: ":art-run-test-jvm-data-shard00-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard00.zip",
 }
@@ -4830,10 +6287,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard01-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard01-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard01",
-    src: ":art-run-test-jvm-data-shard01-tmp",
+    src: ":art-run-test-jvm-data-shard01-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard01.zip",
 }
@@ -4849,10 +6313,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard02-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard02-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard02",
-    src: ":art-run-test-jvm-data-shard02-tmp",
+    src: ":art-run-test-jvm-data-shard02-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard02.zip",
 }
@@ -4868,10 +6339,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard03-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard03-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard03",
-    src: ":art-run-test-jvm-data-shard03-tmp",
+    src: ":art-run-test-jvm-data-shard03-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard03.zip",
 }
@@ -4887,10 +6365,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard04-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard04-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard04",
-    src: ":art-run-test-jvm-data-shard04-tmp",
+    src: ":art-run-test-jvm-data-shard04-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard04.zip",
 }
@@ -4906,10 +6391,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard05-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard05-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard05",
-    src: ":art-run-test-jvm-data-shard05-tmp",
+    src: ":art-run-test-jvm-data-shard05-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard05.zip",
 }
@@ -4925,10 +6417,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard06-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard06-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard06",
-    src: ":art-run-test-jvm-data-shard06-tmp",
+    src: ":art-run-test-jvm-data-shard06-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard06.zip",
 }
@@ -4944,10 +6443,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard07-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard07-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard07",
-    src: ":art-run-test-jvm-data-shard07-tmp",
+    src: ":art-run-test-jvm-data-shard07-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard07.zip",
 }
@@ -4963,10 +6469,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard08-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard08-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard08",
-    src: ":art-run-test-jvm-data-shard08-tmp",
+    src: ":art-run-test-jvm-data-shard08-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard08.zip",
 }
@@ -4982,10 +6495,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard09-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard09-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard09",
-    src: ":art-run-test-jvm-data-shard09-tmp",
+    src: ":art-run-test-jvm-data-shard09-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard09.zip",
 }
@@ -5001,10 +6521,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard10-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard10-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard10",
-    src: ":art-run-test-jvm-data-shard10-tmp",
+    src: ":art-run-test-jvm-data-shard10-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard10.zip",
 }
@@ -5020,10 +6547,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard11-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard11-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard11",
-    src: ":art-run-test-jvm-data-shard11-tmp",
+    src: ":art-run-test-jvm-data-shard11-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard11.zip",
 }
@@ -5039,10 +6573,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard12-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard12-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard12",
-    src: ":art-run-test-jvm-data-shard12-tmp",
+    src: ":art-run-test-jvm-data-shard12-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard12.zip",
 }
@@ -5058,10 +6599,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard13-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard13-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard13",
-    src: ":art-run-test-jvm-data-shard13-tmp",
+    src: ":art-run-test-jvm-data-shard13-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard13.zip",
 }
@@ -5077,10 +6625,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard14-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard14-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard14",
-    src: ":art-run-test-jvm-data-shard14-tmp",
+    src: ":art-run-test-jvm-data-shard14-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard14.zip",
 }
@@ -5096,10 +6651,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard15-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard15-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard15",
-    src: ":art-run-test-jvm-data-shard15-tmp",
+    src: ":art-run-test-jvm-data-shard15-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard15.zip",
 }
@@ -5115,10 +6677,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard16-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard16-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard16",
-    src: ":art-run-test-jvm-data-shard16-tmp",
+    src: ":art-run-test-jvm-data-shard16-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard16.zip",
 }
@@ -5134,10 +6703,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard17-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard17-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard17",
-    src: ":art-run-test-jvm-data-shard17-tmp",
+    src: ":art-run-test-jvm-data-shard17-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard17.zip",
 }
@@ -5153,10 +6729,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard18-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard18-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard18",
-    src: ":art-run-test-jvm-data-shard18-tmp",
+    src: ":art-run-test-jvm-data-shard18-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard18.zip",
 }
@@ -5172,10 +6755,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard19-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard19-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard19",
-    src: ":art-run-test-jvm-data-shard19-tmp",
+    src: ":art-run-test-jvm-data-shard19-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard19.zip",
 }
@@ -5191,10 +6781,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard20-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard20-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard20",
-    src: ":art-run-test-jvm-data-shard20-tmp",
+    src: ":art-run-test-jvm-data-shard20-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard20.zip",
 }
@@ -5210,10 +6807,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard21-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard21-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard21",
-    src: ":art-run-test-jvm-data-shard21-tmp",
+    src: ":art-run-test-jvm-data-shard21-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard21.zip",
 }
@@ -5229,10 +6833,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard22-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard22-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard22",
-    src: ":art-run-test-jvm-data-shard22-tmp",
+    src: ":art-run-test-jvm-data-shard22-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard22.zip",
 }
@@ -5248,10 +6859,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard23-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard23-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard23",
-    src: ":art-run-test-jvm-data-shard23-tmp",
+    src: ":art-run-test-jvm-data-shard23-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard23.zip",
 }
@@ -5267,10 +6885,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard24-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard24-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard24",
-    src: ":art-run-test-jvm-data-shard24-tmp",
+    src: ":art-run-test-jvm-data-shard24-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard24.zip",
 }
@@ -5286,10 +6911,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard25-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard25-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard25",
-    src: ":art-run-test-jvm-data-shard25-tmp",
+    src: ":art-run-test-jvm-data-shard25-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard25.zip",
 }
@@ -5305,10 +6937,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard26-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard26-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard26",
-    src: ":art-run-test-jvm-data-shard26-tmp",
+    src: ":art-run-test-jvm-data-shard26-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard26.zip",
 }
@@ -5324,10 +6963,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard27-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard27-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard27",
-    src: ":art-run-test-jvm-data-shard27-tmp",
+    src: ":art-run-test-jvm-data-shard27-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard27.zip",
 }
@@ -5343,10 +6989,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard28-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard28-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard28",
-    src: ":art-run-test-jvm-data-shard28-tmp",
+    src: ":art-run-test-jvm-data-shard28-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard28.zip",
 }
@@ -5362,10 +7015,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard29-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard29-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard29",
-    src: ":art-run-test-jvm-data-shard29-tmp",
+    src: ":art-run-test-jvm-data-shard29-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard29.zip",
 }
@@ -5381,10 +7041,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard30-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard30-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard30",
-    src: ":art-run-test-jvm-data-shard30-tmp",
+    src: ":art-run-test-jvm-data-shard30-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard30.zip",
 }
@@ -5400,10 +7067,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard31-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard31-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard31",
-    src: ":art-run-test-jvm-data-shard31-tmp",
+    src: ":art-run-test-jvm-data-shard31-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard31.zip",
 }
@@ -5419,10 +7093,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard32-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard32-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard32",
-    src: ":art-run-test-jvm-data-shard32-tmp",
+    src: ":art-run-test-jvm-data-shard32-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard32.zip",
 }
@@ -5438,10 +7119,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard33-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard33-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard33",
-    src: ":art-run-test-jvm-data-shard33-tmp",
+    src: ":art-run-test-jvm-data-shard33-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard33.zip",
 }
@@ -5457,10 +7145,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard34-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard34-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard34",
-    src: ":art-run-test-jvm-data-shard34-tmp",
+    src: ":art-run-test-jvm-data-shard34-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard34.zip",
 }
@@ -5476,10 +7171,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard35-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard35-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard35",
-    src: ":art-run-test-jvm-data-shard35-tmp",
+    src: ":art-run-test-jvm-data-shard35-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard35.zip",
 }
@@ -5495,10 +7197,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard36-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard36-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard36",
-    src: ":art-run-test-jvm-data-shard36-tmp",
+    src: ":art-run-test-jvm-data-shard36-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard36.zip",
 }
@@ -5514,10 +7223,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard37-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard37-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard37",
-    src: ":art-run-test-jvm-data-shard37-tmp",
+    src: ":art-run-test-jvm-data-shard37-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard37.zip",
 }
@@ -5533,10 +7249,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard38-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard38-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard38",
-    src: ":art-run-test-jvm-data-shard38-tmp",
+    src: ":art-run-test-jvm-data-shard38-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard38.zip",
 }
@@ -5552,10 +7275,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard39-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard39-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard39",
-    src: ":art-run-test-jvm-data-shard39-tmp",
+    src: ":art-run-test-jvm-data-shard39-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard39.zip",
 }
@@ -5571,10 +7301,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard40-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard40-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard40",
-    src: ":art-run-test-jvm-data-shard40-tmp",
+    src: ":art-run-test-jvm-data-shard40-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard40.zip",
 }
@@ -5590,10 +7327,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard41-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard41-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard41",
-    src: ":art-run-test-jvm-data-shard41-tmp",
+    src: ":art-run-test-jvm-data-shard41-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard41.zip",
 }
@@ -5609,10 +7353,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard42-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard42-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard42",
-    src: ":art-run-test-jvm-data-shard42-tmp",
+    src: ":art-run-test-jvm-data-shard42-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard42.zip",
 }
@@ -5628,10 +7379,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard43-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard43-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard43",
-    src: ":art-run-test-jvm-data-shard43-tmp",
+    src: ":art-run-test-jvm-data-shard43-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard43.zip",
 }
@@ -5647,10 +7405,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard44-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard44-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard44",
-    src: ":art-run-test-jvm-data-shard44-tmp",
+    src: ":art-run-test-jvm-data-shard44-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard44.zip",
 }
@@ -5666,10 +7431,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard45-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard45-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard45",
-    src: ":art-run-test-jvm-data-shard45-tmp",
+    src: ":art-run-test-jvm-data-shard45-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard45.zip",
 }
@@ -5685,10 +7457,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard46-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard46-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard46",
-    src: ":art-run-test-jvm-data-shard46-tmp",
+    src: ":art-run-test-jvm-data-shard46-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard46.zip",
 }
@@ -5704,10 +7483,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard47-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard47-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard47",
-    src: ":art-run-test-jvm-data-shard47-tmp",
+    src: ":art-run-test-jvm-data-shard47-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard47.zip",
 }
@@ -5723,10 +7509,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard48-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard48-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard48",
-    src: ":art-run-test-jvm-data-shard48-tmp",
+    src: ":art-run-test-jvm-data-shard48-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard48.zip",
 }
@@ -5742,10 +7535,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard49-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard49-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard49",
-    src: ":art-run-test-jvm-data-shard49-tmp",
+    src: ":art-run-test-jvm-data-shard49-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard49.zip",
 }
@@ -5761,10 +7561,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard50-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard50-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard50",
-    src: ":art-run-test-jvm-data-shard50-tmp",
+    src: ":art-run-test-jvm-data-shard50-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard50.zip",
 }
@@ -5780,10 +7587,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard51-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard51-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard51",
-    src: ":art-run-test-jvm-data-shard51-tmp",
+    src: ":art-run-test-jvm-data-shard51-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard51.zip",
 }
@@ -5799,10 +7613,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard52-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard52-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard52",
-    src: ":art-run-test-jvm-data-shard52-tmp",
+    src: ":art-run-test-jvm-data-shard52-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard52.zip",
 }
@@ -5818,10 +7639,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard53-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard53-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard53",
-    src: ":art-run-test-jvm-data-shard53-tmp",
+    src: ":art-run-test-jvm-data-shard53-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard53.zip",
 }
@@ -5837,10 +7665,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard54-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard54-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard54",
-    src: ":art-run-test-jvm-data-shard54-tmp",
+    src: ":art-run-test-jvm-data-shard54-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard54.zip",
 }
@@ -5856,10 +7691,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard55-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard55-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard55",
-    src: ":art-run-test-jvm-data-shard55-tmp",
+    src: ":art-run-test-jvm-data-shard55-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard55.zip",
 }
@@ -5875,10 +7717,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard56-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard56-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard56",
-    src: ":art-run-test-jvm-data-shard56-tmp",
+    src: ":art-run-test-jvm-data-shard56-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard56.zip",
 }
@@ -5894,10 +7743,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard57-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard57-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard57",
-    src: ":art-run-test-jvm-data-shard57-tmp",
+    src: ":art-run-test-jvm-data-shard57-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard57.zip",
 }
@@ -5913,10 +7769,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard58-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard58-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard58",
-    src: ":art-run-test-jvm-data-shard58-tmp",
+    src: ":art-run-test-jvm-data-shard58-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard58.zip",
 }
@@ -5932,10 +7795,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard59-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard59-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard59",
-    src: ":art-run-test-jvm-data-shard59-tmp",
+    src: ":art-run-test-jvm-data-shard59-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard59.zip",
 }
@@ -5951,10 +7821,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard60-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard60-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard60",
-    src: ":art-run-test-jvm-data-shard60-tmp",
+    src: ":art-run-test-jvm-data-shard60-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard60.zip",
 }
@@ -5970,10 +7847,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard61-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard61-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard61",
-    src: ":art-run-test-jvm-data-shard61-tmp",
+    src: ":art-run-test-jvm-data-shard61-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard61.zip",
 }
@@ -5989,10 +7873,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard62-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard62-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard62",
-    src: ":art-run-test-jvm-data-shard62-tmp",
+    src: ":art-run-test-jvm-data-shard62-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard62.zip",
 }
@@ -6008,10 +7899,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard63-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard63-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard63",
-    src: ":art-run-test-jvm-data-shard63-tmp",
+    src: ":art-run-test-jvm-data-shard63-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard63.zip",
 }
@@ -6027,10 +7925,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard64-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard64-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard64",
-    src: ":art-run-test-jvm-data-shard64-tmp",
+    src: ":art-run-test-jvm-data-shard64-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard64.zip",
 }
@@ -6046,10 +7951,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard65-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard65-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard65",
-    src: ":art-run-test-jvm-data-shard65-tmp",
+    src: ":art-run-test-jvm-data-shard65-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard65.zip",
 }
@@ -6065,10 +7977,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard66-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard66-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard66",
-    src: ":art-run-test-jvm-data-shard66-tmp",
+    src: ":art-run-test-jvm-data-shard66-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard66.zip",
 }
@@ -6084,10 +8003,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard67-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard67-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard67",
-    src: ":art-run-test-jvm-data-shard67-tmp",
+    src: ":art-run-test-jvm-data-shard67-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard67.zip",
 }
@@ -6103,10 +8029,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard68-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard68-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard68",
-    src: ":art-run-test-jvm-data-shard68-tmp",
+    src: ":art-run-test-jvm-data-shard68-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard68.zip",
 }
@@ -6122,10 +8055,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard69-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard69-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard69",
-    src: ":art-run-test-jvm-data-shard69-tmp",
+    src: ":art-run-test-jvm-data-shard69-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard69.zip",
 }
@@ -6141,10 +8081,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard70-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard70-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard70",
-    src: ":art-run-test-jvm-data-shard70-tmp",
+    src: ":art-run-test-jvm-data-shard70-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard70.zip",
 }
@@ -6160,10 +8107,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard71-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard71-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard71",
-    src: ":art-run-test-jvm-data-shard71-tmp",
+    src: ":art-run-test-jvm-data-shard71-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard71.zip",
 }
@@ -6179,10 +8133,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard72-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard72-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard72",
-    src: ":art-run-test-jvm-data-shard72-tmp",
+    src: ":art-run-test-jvm-data-shard72-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard72.zip",
 }
@@ -6198,10 +8159,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard73-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard73-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard73",
-    src: ":art-run-test-jvm-data-shard73-tmp",
+    src: ":art-run-test-jvm-data-shard73-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard73.zip",
 }
@@ -6217,10 +8185,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard74-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard74-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard74",
-    src: ":art-run-test-jvm-data-shard74-tmp",
+    src: ":art-run-test-jvm-data-shard74-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard74.zip",
 }
@@ -6236,10 +8211,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard75-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard75-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard75",
-    src: ":art-run-test-jvm-data-shard75-tmp",
+    src: ":art-run-test-jvm-data-shard75-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard75.zip",
 }
@@ -6255,10 +8237,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard76-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard76-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard76",
-    src: ":art-run-test-jvm-data-shard76-tmp",
+    src: ":art-run-test-jvm-data-shard76-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard76.zip",
 }
@@ -6274,10 +8263,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard77-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard77-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard77",
-    src: ":art-run-test-jvm-data-shard77-tmp",
+    src: ":art-run-test-jvm-data-shard77-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard77.zip",
 }
@@ -6293,10 +8289,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard78-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard78-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard78",
-    src: ":art-run-test-jvm-data-shard78-tmp",
+    src: ":art-run-test-jvm-data-shard78-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard78.zip",
 }
@@ -6312,10 +8315,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard79-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard79-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard79",
-    src: ":art-run-test-jvm-data-shard79-tmp",
+    src: ":art-run-test-jvm-data-shard79-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard79.zip",
 }
@@ -6331,10 +8341,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard80-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard80-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard80",
-    src: ":art-run-test-jvm-data-shard80-tmp",
+    src: ":art-run-test-jvm-data-shard80-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard80.zip",
 }
@@ -6350,10 +8367,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard81-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard81-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard81",
-    src: ":art-run-test-jvm-data-shard81-tmp",
+    src: ":art-run-test-jvm-data-shard81-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard81.zip",
 }
@@ -6369,10 +8393,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard82-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard82-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard82",
-    src: ":art-run-test-jvm-data-shard82-tmp",
+    src: ":art-run-test-jvm-data-shard82-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard82.zip",
 }
@@ -6388,10 +8419,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard83-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard83-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard83",
-    src: ":art-run-test-jvm-data-shard83-tmp",
+    src: ":art-run-test-jvm-data-shard83-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard83.zip",
 }
@@ -6407,10 +8445,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard84-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard84-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard84",
-    src: ":art-run-test-jvm-data-shard84-tmp",
+    src: ":art-run-test-jvm-data-shard84-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard84.zip",
 }
@@ -6426,10 +8471,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard85-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard85-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard85",
-    src: ":art-run-test-jvm-data-shard85-tmp",
+    src: ":art-run-test-jvm-data-shard85-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard85.zip",
 }
@@ -6445,10 +8497,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard86-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard86-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard86",
-    src: ":art-run-test-jvm-data-shard86-tmp",
+    src: ":art-run-test-jvm-data-shard86-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard86.zip",
 }
@@ -6464,10 +8523,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard87-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard87-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard87",
-    src: ":art-run-test-jvm-data-shard87-tmp",
+    src: ":art-run-test-jvm-data-shard87-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard87.zip",
 }
@@ -6483,10 +8549,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard88-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard88-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard88",
-    src: ":art-run-test-jvm-data-shard88-tmp",
+    src: ":art-run-test-jvm-data-shard88-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard88.zip",
 }
@@ -6502,10 +8575,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard89-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard89-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard89",
-    src: ":art-run-test-jvm-data-shard89-tmp",
+    src: ":art-run-test-jvm-data-shard89-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard89.zip",
 }
@@ -6521,10 +8601,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard90-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard90-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard90",
-    src: ":art-run-test-jvm-data-shard90-tmp",
+    src: ":art-run-test-jvm-data-shard90-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard90.zip",
 }
@@ -6540,10 +8627,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard91-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard91-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard91",
-    src: ":art-run-test-jvm-data-shard91-tmp",
+    src: ":art-run-test-jvm-data-shard91-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard91.zip",
 }
@@ -6559,10 +8653,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard92-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard92-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard92",
-    src: ":art-run-test-jvm-data-shard92-tmp",
+    src: ":art-run-test-jvm-data-shard92-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard92.zip",
 }
@@ -6578,10 +8679,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard93-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard93-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard93",
-    src: ":art-run-test-jvm-data-shard93-tmp",
+    src: ":art-run-test-jvm-data-shard93-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard93.zip",
 }
@@ -6597,10 +8705,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard94-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard94-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard94",
-    src: ":art-run-test-jvm-data-shard94-tmp",
+    src: ":art-run-test-jvm-data-shard94-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard94.zip",
 }
@@ -6616,10 +8731,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard95-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard95-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard95",
-    src: ":art-run-test-jvm-data-shard95-tmp",
+    src: ":art-run-test-jvm-data-shard95-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard95.zip",
 }
@@ -6635,10 +8757,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard96-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard96-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard96",
-    src: ":art-run-test-jvm-data-shard96-tmp",
+    src: ":art-run-test-jvm-data-shard96-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard96.zip",
 }
@@ -6654,10 +8783,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard97-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard97-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard97",
-    src: ":art-run-test-jvm-data-shard97-tmp",
+    src: ":art-run-test-jvm-data-shard97-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard97.zip",
 }
@@ -6673,10 +8809,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard98-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard98-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard98",
-    src: ":art-run-test-jvm-data-shard98-tmp",
+    src: ":art-run-test-jvm-data-shard98-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard98.zip",
 }
@@ -6692,10 +8835,17 @@ java_genrule {
     defaults: ["art-run-test-jvm-data-defaults"],
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shard99-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shard99-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shard99",
-    src: ":art-run-test-jvm-data-shard99-tmp",
+    src: ":art-run-test-jvm-data-shard99-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shard99.zip",
 }
@@ -6712,26 +8862,30 @@ java_genrule {
     cmd: TEST_BUILD_COMMON_ARGS + "--hiddenapi $(location hiddenapi) --mode jvm --test-dir-regex 'art/test/....?-[^/]*hiddenapi' $(in)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-shardHiddenApi-fg",
+    device_common_srcs: [":art-run-test-jvm-data-shardHiddenApi-tmp"],
+}
+
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-shardHiddenApi",
-    src: ":art-run-test-jvm-data-shardHiddenApi-tmp",
+    src: ":art-run-test-jvm-data-shardHiddenApi-fg",
     sub_dir: "art",
     filename: "art-run-test-jvm-data-shardHiddenApi.zip",
 }
 
 genrule_defaults {
     name: "art-run-test-jvm-data-defaults",
-    tool_files: [
-        "run_test_build.py",
-        ":art-run-test-bootclasspath",
-    ],
     srcs: [
         // Since genrules are sandboxed, all the sources they use must be listed in
         // the Android.bp file. Some tests have symlinks to files from other tests, and
         // those must also be listed to avoid a dangling symlink in the sandbox.
         "jvmti-common/*.java",
         "utils/python/**/*.py",
+        ":art-run-test-bootclasspath",
         ":development_docs",
         ":asm-9.6-filegroup",
         ":ojluni-AbstractCollection",
@@ -6742,6 +8896,13 @@ genrule_defaults {
         "988-method-trace/trace_fib.cc",
         "1953-pop-frame/src/art/Test1953.java",
         "1953-pop-frame/src/art/SuspendEvents.java",
+        // Files needed to generate runner scripts.
+        "testrunner/*.py",
+        "knownfailures.json",
+        "default_run.py",
+        "globals.py",
+        "run-test",
+        "run_test_build.py",
     ],
     tools: [
         "android-smali",
@@ -6755,7 +8916,7 @@ genrule_defaults {
 
 java_genrule {
     name: "art-run-test-jvm-data-merged-tmp",
-    out: ["art-run-test-jvm-data-merged.zip"],
+    out: ["art-run-test-jvm-data-merged.tgz"],
     srcs: [
         ":art-run-test-jvm-data-shard00-tmp",
         ":art-run-test-jvm-data-shard01-tmp",
@@ -6859,14 +9020,21 @@ java_genrule {
         ":art-run-test-jvm-data-shard99-tmp",
         ":art-run-test-jvm-data-shardHiddenApi-tmp",
     ],
-    tools: ["merge_zips"],
-    cmd: "$(location merge_zips) $(out) $(in)",
+    tool_files: ["merge_zips_to_tgz.py"],
+    cmd: "$(location merge_zips_to_tgz.py) $(out) $(in)",
+}
+
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-merged-fg",
+    device_common_srcs: [":art-run-test-jvm-data-merged-tmp"],
 }
 
 // Install in the output directory to make it accessible for tests.
 prebuilt_etc_host {
     name: "art-run-test-jvm-data-merged",
-    src: ":art-run-test-jvm-data-merged-tmp",
+    src: ":art-run-test-jvm-data-merged-fg",
     required: [
         "art-run-test-jvm-data-shard00",
         "art-run-test-jvm-data-shard01",
@@ -6971,7 +9139,7 @@ prebuilt_etc_host {
         "art-run-test-jvm-data-shardHiddenApi",
     ],
     sub_dir: "art",
-    filename: "art-run-test-jvm-data-merged.zip",
+    filename: "art-run-test-jvm-data-merged.tgz",
 }
 
 // Phony target used to build all shards
@@ -7084,10 +9252,17 @@ java_genrule {
     cmd: "echo $(in) > $(out)",
 }
 
+// This filegroup is so that the host prebuilt etc can depend on a device genrule,
+// as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+filegroup {
+    name: "art-run-test-jvm-data-fg",
+    device_common_srcs: [":art-run-test-jvm-data-tmp"],
+}
+
 // Phony target used to install all shards
 prebuilt_etc_host {
     name: "art-run-test-jvm-data",
-    src: ":art-run-test-jvm-data-tmp",
+    src: ":art-run-test-jvm-data-fg",
     required: [
         "art-run-test-jvm-data-shard00",
         "art-run-test-jvm-data-shard01",
diff --git a/test/Android.run-test.bp.py b/test/Android.run-test.bp.py
index ac121127e1..e208672b11 100755
--- a/test/Android.run-test.bp.py
+++ b/test/Android.run-test.bp.py
@@ -58,10 +58,17 @@ def main():
               defaults: ["art-run-test-{mode}-data-defaults"],
           }}
 
+          // This filegroup is so that the host prebuilt etc can depend on a device genrule,
+          // as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+          filegroup {{
+              name: "{name}-fg",
+              device_common_srcs: [":{name}-tmp"],
+          }}
+
           // Install in the output directory to make it accessible for tests.
           prebuilt_etc_host {{
               name: "{name}",
-              src: ":{name}-tmp",
+              src: ":{name}-fg",
               sub_dir: "art",
               filename: "{name}.zip",
           }}
@@ -85,10 +92,17 @@ def main():
             cmd: TEST_BUILD_COMMON_ARGS + "--hiddenapi $(location hiddenapi) --mode {mode} --test-dir-regex 'art/test/....?-[^/]*hiddenapi' $(in)",
         }}
 
+        // This filegroup is so that the host prebuilt etc can depend on a device genrule,
+        // as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+        filegroup {{
+            name: "{name}-fg",
+            device_common_srcs: [":{name}-tmp"],
+        }}
+
         // Install in the output directory to make it accessible for tests.
         prebuilt_etc_host {{
             name: "{name}",
-            src: ":{name}-tmp",
+            src: ":{name}-fg",
             sub_dir: "art",
             filename: "{name}.zip",
         }}
@@ -97,16 +111,13 @@ def main():
       f.write(textwrap.dedent(f"""
         genrule_defaults {{
             name: "art-run-test-{mode}-data-defaults",
-            tool_files: [
-                "run_test_build.py",
-                ":art-run-test-bootclasspath",
-            ],
             srcs: [
                 // Since genrules are sandboxed, all the sources they use must be listed in
                 // the Android.bp file. Some tests have symlinks to files from other tests, and
                 // those must also be listed to avoid a dangling symlink in the sandbox.
                 "jvmti-common/*.java",
                 "utils/python/**/*.py",
+                ":art-run-test-bootclasspath",
                 ":development_docs",
                 ":asm-9.6-filegroup",
                 ":ojluni-AbstractCollection",
@@ -117,6 +128,13 @@ def main():
                 "988-method-trace/trace_fib.cc",
                 "1953-pop-frame/src/art/Test1953.java",
                 "1953-pop-frame/src/art/SuspendEvents.java",
+                // Files needed to generate runner scripts.
+                "testrunner/*.py",
+                "knownfailures.json",
+                "default_run.py",
+                "globals.py",
+                "run-test",
+                "run_test_build.py",
             ],
             tools: [
                 "android-smali",
@@ -135,23 +153,30 @@ def main():
       f.write(textwrap.dedent(f"""
         java_genrule {{
             name: "{name}-tmp",
-            out: ["{name}.zip"],
+            out: ["{name}.tgz"],
             srcs: [
                 {srcs}
             ],
-            tools: ["merge_zips"],
-            cmd: "$(location merge_zips) $(out) $(in)",
+            tool_files: ["merge_zips_to_tgz.py"],
+            cmd: "$(location merge_zips_to_tgz.py) $(out) $(in)",
+        }}
+
+        // This filegroup is so that the host prebuilt etc can depend on a device genrule,
+        // as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+        filegroup {{
+            name: "{name}-fg",
+            device_common_srcs: [":{name}-tmp"],
         }}
 
         // Install in the output directory to make it accessible for tests.
         prebuilt_etc_host {{
             name: "{name}",
-            src: ":{name}-tmp",
+            src: ":{name}-fg",
             required: [
                 {deps}
             ],
             sub_dir: "art",
-            filename: "{name}.zip",
+            filename: "{name}.tgz",
         }}
         """))
 
@@ -169,10 +194,17 @@ def main():
             cmd: "echo $(in) > $(out)",
         }}
 
+        // This filegroup is so that the host prebuilt etc can depend on a device genrule,
+        // as prebuilt_etc doesn't have the equivalent of device_common_srcs.
+        filegroup {{
+            name: "{name}-fg",
+            device_common_srcs: [":{name}-tmp"],
+        }}
+
         // Phony target used to install all shards
         prebuilt_etc_host {{
             name: "{name}",
-            src: ":{name}-tmp",
+            src: ":{name}-fg",
             required: [
                 {deps}
             ],
diff --git a/test/Android.run-test.mk b/test/Android.run-test.mk
index 42ce1a4d58..f4fdd10ef0 100644
--- a/test/Android.run-test.mk
+++ b/test/Android.run-test.mk
@@ -71,7 +71,8 @@ ART_TEST_HOST_RUN_TEST_DEPENDENCIES := \
   $(ART_HOST_OUT_SHARED_LIBRARIES)/libopenjdkjvmti$(ART_HOST_SHLIB_EXTENSION) \
   $(ART_HOST_OUT_SHARED_LIBRARIES)/libopenjdkjvmtid$(ART_HOST_SHLIB_EXTENSION) \
   $(ART_HOST_DEX_DEPENDENCIES) \
-  $(HOST_I18N_DATA)
+  $(HOST_I18N_DATA) \
+  art_boot_images
 
 ifneq ($(HOST_PREFER_32_BIT),true)
 ART_TEST_HOST_RUN_TEST_DEPENDENCIES += \
@@ -96,7 +97,7 @@ endif
 
 test-art-host-run-test-dependencies : \
       $(ART_TEST_HOST_RUN_TEST_DEPENDENCIES) $(TEST_ART_RUN_TEST_DEPENDENCIES) \
-      $(HOST_BOOT_IMAGE_JARS) $(HOST_BOOT_IMAGE) $(2ND_HOST_BOOT_IMAGE)
+      $(HOST_BOOT_IMAGE_JARS)
 .PHONY: test-art-host-run-test-dependencies
 test-art-run-test-dependencies : test-art-host-run-test-dependencies
 
diff --git a/test/common/runtime_state.cc b/test/common/runtime_state.cc
index d4bbba2a4f..c046e26755 100644
--- a/test/common/runtime_state.cc
+++ b/test/common/runtime_state.cc
@@ -276,7 +276,9 @@ static void ForceJitCompiled(Thread* self,
   if (jit->JitAtFirstUse()) {
     ScopedObjectAccess soa(self);
     jit->CompileMethod(method, self, kind, /*prejit=*/ false);
-  } else if (kind == CompilationKind::kBaseline || jit->GetJitCompiler()->IsBaselineCompiler()) {
+    return;
+  }
+  if (kind == CompilationKind::kBaseline || jit->GetJitCompiler()->IsBaselineCompiler()) {
     ScopedObjectAccess soa(self);
     if (jit->TryPatternMatch(method, CompilationKind::kBaseline)) {
       return;
diff --git a/test/default_run.py b/test/default_run.py
index 01b7542476..fa6341a31d 100755
--- a/test/default_run.py
+++ b/test/default_run.py
@@ -15,6 +15,7 @@
 
 import sys, os, shutil, shlex, re, subprocess, glob
 from argparse import ArgumentParser, BooleanOptionalAction, Namespace
+from globals import BOOTCLASSPATH
 from os import path
 from os.path import isfile, isdir, basename
 from subprocess import check_output, DEVNULL, PIPE, STDOUT
@@ -144,29 +145,11 @@ def get_target_arch(is64: bool) -> str:
     assert len(arches) == 1, f"Can not find (unique) 32-bit arch in {arches}"
   return arches[0]
 
-# Note: This must start with the CORE_IMG_JARS in Android.common_path.mk
-# because that's what we use for compiling the boot.art image.
-# It may contain additional modules from TEST_CORE_JARS.
-bpath_modules = ("core-oj core-libart okhttp bouncycastle apache-xml core-icu4j"
-                 " conscrypt")
-
 
 # Helper function to construct paths for apex modules (for both -Xbootclasspath and
 # -Xbootclasspath-location).
 def get_apex_bootclasspath_impl(bpath_prefix: str):
-  bpath_separator = ""
-  bpath = ""
-  bpath_jar = ""
-  for bpath_module in bpath_modules.split(" "):
-    apex_module = "com.android.art"
-    if bpath_module == "conscrypt":
-      apex_module = "com.android.conscrypt"
-    if bpath_module == "core-icu4j":
-      apex_module = "com.android.i18n"
-    bpath_jar = f"/apex/{apex_module}/javalib/{bpath_module}.jar"
-    bpath += f"{bpath_separator}{bpath_prefix}{bpath_jar}"
-    bpath_separator = ":"
-  return bpath
+  return ":".join(bpath_prefix + bpath for bpath in BOOTCLASSPATH)
 
 
 # Gets a -Xbootclasspath paths with the apex modules.
@@ -444,6 +427,10 @@ def default_run(ctx, args, **kwargs):
   if HOST or ON_VM:
     TIME_OUT = "timeout"
 
+# Give extra 60 min for tests on QEMU (to avoid timeouts in debuggable mode).
+  if ON_VM:
+    TIME_OUT_EXTRA = 6000
+
 # If you change this, update the timeout in testrunner.py as well.
   if not TIME_OUT_VALUE:
     # 10 minutes is the default.
@@ -1049,6 +1036,7 @@ def default_run(ctx, args, **kwargs):
       ANDROID_ART_ROOT = ANDROID_ART_ROOT,
       ANDROID_TZDATA_ROOT = ANDROID_TZDATA_ROOT,
       ANDROID_LOG_TAGS = ANDROID_LOG_TAGS,
+      ART_TEST_ON_VM=ON_VM,
       LD_LIBRARY_PATH = LD_LIBRARY_PATH,
       NATIVELOADER_DEFAULT_NAMESPACE_LIBS = NATIVELOADER_DEFAULT_NAMESPACE_LIBS,
       PATH = f"{PREPEND_TARGET_PATH}:$PATH",
diff --git a/test/globals.py b/test/globals.py
new file mode 100644
index 0000000000..fa51150776
--- /dev/null
+++ b/test/globals.py
@@ -0,0 +1,24 @@
+#
+# Copyright (C) 2024 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+BOOTCLASSPATH = [
+  "/apex/com.android.art/javalib/core-oj.jar",
+  "/apex/com.android.art/javalib/core-libart.jar",
+  "/apex/com.android.art/javalib/okhttp.jar",
+  "/apex/com.android.art/javalib/bouncycastle.jar",
+  "/apex/com.android.art/javalib/apache-xml.jar",
+  "/apex/com.android.i18n/javalib/core-icu4j.jar",
+  "/apex/com.android.conscrypt/javalib/conscrypt.jar",
+]
\ No newline at end of file
diff --git a/test/jvmti-common/Exceptions.java b/test/jvmti-common/Exceptions.java
index 2c959ec83f..b7dc89836b 100644
--- a/test/jvmti-common/Exceptions.java
+++ b/test/jvmti-common/Exceptions.java
@@ -25,6 +25,7 @@ public class Exceptions {
       Class<?> exceptionClass,
       Method exceptionEventMethod,
       Method exceptionCaughtEventMethod);
+  public static native void disableExceptionTracing(Thread thr);
 
   public static native void enableExceptionCatchEvent(Thread thr);
   public static native void enableExceptionEvent(Thread thr);
diff --git a/test/knownfailures.json b/test/knownfailures.json
index e58a6cd4a2..1a3a44ee91 100644
--- a/test/knownfailures.json
+++ b/test/knownfailures.json
@@ -1,20 +1,8 @@
 [
-    {
-        "tests": "153-reference-stress",
-        "description": ["Disable 153-reference-stress temporarily until a fix",
-                        "arrives."],
-        "bug": "http://b/33389022"
-    },
     {
         "tests": "626-checker-arm64-scratch-register",
         "description": ["Disable 626-checker until we assses whether to keep it"]
     },
-    {
-        "tests": "304-method-tracing",
-        "description": ["Disable 304-method-tracing temporarily until a fix",
-                        "arrives."],
-        "bug": "http://b/203253172"
-    },
     {
         "tests": "132-daemon-locks-shutdown",
         "description": ["This test seems to fail occasionally on redefine-stress for unknown reasons without stack-traces"],
@@ -1259,7 +1247,8 @@
     },
     {
         "tests": ["990-field-trace",
-                  "991-field-trace-2"],
+                  "991-field-trace-2",
+                  "710-varhandle-creation"],
         "variant": "gcstress & debug & target",
         "description": ["Test can time out on gcstress with debug"]
     },
@@ -1299,6 +1288,16 @@
         "bug": "b/68792448",
         "description": ["Timing margins are too tight for gcstress"]
     },
+    {
+        "tests": ["153-reference-stress"],
+        "variant": "gcstress | debuggable",
+        "description": ["Timing out."]
+    },
+    {
+        "tests": ["153-reference-stress"],
+        "env_vars": {"SANITIZE_HOST": "address"},
+        "description": ["Timing out for ASAN."]
+    },
     {
         "tests": ["021-string2"],
         "variant": "jit & debuggable",
diff --git a/test/merge_zips_to_tgz.py b/test/merge_zips_to_tgz.py
new file mode 100755
index 0000000000..bca4feef96
--- /dev/null
+++ b/test/merge_zips_to_tgz.py
@@ -0,0 +1,30 @@
+#!/usr/bin/env python3
+
+import tarfile
+import zipfile
+import sys
+import io
+from pathlib import Path
+
+def merge_zips_to_tgz(tgz_filename, zip_filenames):
+  with open(tgz_filename, 'wb') as outfile:
+    with tarfile.open(fileobj=outfile, mode='w:gz') as tgz:
+      for zip_filename in zip_filenames:
+        with zipfile.ZipFile(zip_filename, 'r') as zip_file:
+          for zip_info in zip_file.infolist():
+            with zip_file.open(zip_info) as zip_member:
+              buffer = io.BytesIO(zip_member.read())
+              tar_info = tarfile.TarInfo(name=zip_info.filename)
+              tar_info.size = len(buffer.getbuffer())
+              tgz.addfile(tarinfo=tar_info, fileobj=buffer)
+
+
+if __name__ == "__main__":
+  if len(sys.argv) < 2:
+    print(f"Usage: {Path(__file__).name} output.tgz zip1.zip zip2.zip ...")
+    sys.exit(1)
+
+  tgz_filename = sys.argv[1]
+  zip_filenames = sys.argv[2:]
+  merge_zips_to_tgz(tgz_filename, zip_filenames)
+
diff --git a/test/odsign/Android.bp b/test/odsign/Android.bp
index 5aa0f4d25a..d12f608f64 100644
--- a/test/odsign/Android.bp
+++ b/test/odsign/Android.bp
@@ -32,14 +32,13 @@ java_test_host {
     defaults: ["odsign_e2e_tests_defaults"],
     // TODO(b/228838581): Do not add `data` to the defaults unless the bug is
     // fixed.
-    data: [
+    device_common_data: [
         ":odsign_e2e_test_app",
     ],
     test_config: "odsign-e2e-tests.xml",
     test_suites: [
         "general-tests",
         "cts",
-        "mcts-art",
     ],
 }
 
@@ -48,10 +47,10 @@ java_test_host {
     defaults: ["odsign_e2e_tests_defaults"],
     // TODO(b/228838581): Do not add `data` to the defaults unless the bug is
     // fixed.
-    data: [
+    device_common_data: [
         ":odsign_e2e_test_app",
     ],
-    java_resources: [
+    device_common_java_resources: [
         ":art-gtest-jars-Main",
     ],
     test_config: "odsign-e2e-tests-full.xml",
diff --git a/test/run-test b/test/run-test
index d0e7c8bdb1..cc31077818 100755
--- a/test/run-test
+++ b/test/run-test
@@ -15,14 +15,19 @@
 # limitations under the License.
 
 import os, sys, glob, re, shutil, subprocess, shlex, resource, atexit
+import urllib.parse
 
 import default_run as default_run_module
 
+from argparse import ArgumentParser, BooleanOptionalAction
 from default_run import get_target_arch
+from fcntl import lockf, LOCK_EX, LOCK_NB
+from hashlib import sha1
 from importlib.machinery import SourceFileLoader
 from inspect import currentframe, getframeinfo, FrameInfo
 from pathlib import Path
-from shutil import copyfile
+from pprint import pprint
+from shutil import copyfile, copytree
 from testrunner import env
 from typing import Optional, Dict, List
 from zipfile import ZipFile
@@ -97,20 +102,33 @@ class RunTestContext:
   def default_run(self, args, **kwargs):
     default_run_module.default_run(self, args, **kwargs)
 
+# Make unique temporary directory guarded by lock file.
+# The name is deterministic (appending suffix as needed).
+def make_tmp_dir():
+  parent = Path(os.environ.get("TMPDIR", "/tmp")) / "art" / "test"
+  parent.mkdir(parents=True, exist_ok=True)
+  args = [a for a in sys.argv[1:] if not a.startswith("--create-runner")]
+  hash = sha1((" ".join(args)).encode()).hexdigest()
+  for i in range(100):
+    tmp_dir = parent / (f"{hash[:8]}" + (f"-{i}" if i > 0 else ""))
+    lock = tmp_dir.with_suffix(".lock")  # NB: Next to the directory, not inside.
+    lock_handle = open(lock, "w")
+    try:
+      lockf(lock_handle, LOCK_EX | LOCK_NB)
+      tmp_dir.mkdir(exist_ok=True)
+      return str(tmp_dir), lock, lock_handle
+    except BlockingIOError:
+      continue
+  assert False, "Failed to create test directory"
 
 # TODO: Replace with 'def main():' (which might change variables from globals to locals)
 if True:
   progdir = os.path.dirname(__file__)
   oldwd = os.getcwd()
   os.chdir(progdir)
-  test_dir = "test-{}".format(os.getpid())
-  TMPDIR = os.environ.get("TMPDIR")
-  USER = os.environ.get("USER")
   PYTHON3 = os.environ.get("PYTHON3")
-  if not TMPDIR:
-    tmp_dir = f"/tmp/{USER}/{test_dir}"
-  else:
-    tmp_dir = f"{TMPDIR}/{test_dir}"
+  tmp_dir, tmp_dir_lock, tmp_dir_lock_handle = make_tmp_dir()
+  test_dir = Path(tmp_dir).name
   checker = f"{progdir}/../tools/checker/checker.py"
 
   ON_VM = env.ART_TEST_ON_VM
@@ -160,7 +178,10 @@ if True:
   export("PYTHON3",
          f"{ANDROID_BUILD_TOP}/prebuilts/build-tools/path/linux-x86/python3")
   export("RUN", f"{PYTHON3} {progdir}/etc/run-test-jar")
-  export("DEX_LOCATION", f"/data/run-test/{test_dir}")
+  if env.ART_TEST_RUN_FROM_SOONG:
+    export("DEX_LOCATION", f"/data/local/tmp/art/test/{test_dir}")
+  else:
+    export("DEX_LOCATION", f"/data/run-test/{test_dir}")
 
   # OUT_DIR defaults to out, and may be relative to ANDROID_BUILD_TOP.
   # Convert it to an absolute path, since we cd into the tmp_dir to run the tests.
@@ -174,51 +195,13 @@ if True:
   if not ANDROID_HOST_OUT:
     export("ANDROID_HOST_OUT", f"{OUT_DIR}/host/linux-x86")
 
-  host_lib_root = ANDROID_HOST_OUT
-  chroot = ""
   info = "info.txt"
   run_cmd = "run"
   test_stdout = "test-stdout.txt"
   test_stderr = "test-stderr.txt"
   cfg_output = "graph.cfg"
-  strace_output = "strace-output.txt"
-  lib = "libartd.so"
-  testlib = "arttestd"
-  run_args = []
-  run_checker = "no"
-
-  quiet = "no"
-  debuggable = "no"
-  prebuild_mode = "yes"
-  target_mode = "yes"
-  dev_mode = "no"
-  create_runner = "no"
-  update_mode = "no"
-  debug_mode = "no"
-  relocate = "no"
-  runtime = "art"
-  usage = "no"
-  suffix64 = ""
-  trace = "false"
-  trace_stream = "false"
-  basic_verify = "false"
-  gc_verify = "false"
-  gc_stress = "false"
-  jvmti_trace_stress = "false"
-  jvmti_field_stress = "false"
-  jvmti_step_stress = "false"
-  jvmti_redefine_stress = "false"
-  strace = "false"
-  always_clean = "no"
-  never_clean = "no"
-  have_image = "yes"
-  android_root = "/system"
-  bisection_search = "no"
-  timeout = ""
-  suspend_timeout = "500000"
-  run_optimizing = "false"
-  dump_cfg = "false"
-  dump_cfg_path = ""
+  run_checker = False
+  debug_mode = False
   # To cause tests to fail fast, limit the file sizes created by dx, dex2oat and
   # ART output to approximately 128MB. This should be more than sufficient
   # for any test while still catching cases of runaway output.
@@ -228,354 +211,373 @@ if True:
   # particular configurations.
   file_ulimit = 128000
 
-  args = list(sys.argv)
-  arg = args[0]
-
-  def shift():
-    global arg
-    args.pop(0)
-    arg = args[0] if args else ""
+  argp, opt_bool = ArgumentParser(), BooleanOptionalAction
+  argp.add_argument("--O", action='store_true',
+                    help="Run non-debug rather than debug build (off by default).")
+  argp.add_argument("--Xcompiler-option", type=str, action='append', default=[],
+                    help="Pass an option to the compiler.")
+  argp.add_argument("--runtime-option", type=str, action='append', default=[],
+                    help="Pass an option to the runtime.")
+  argp.add_argument("--debug", action='store_true',
+                    help="Wait for the default debugger to attach.")
+  argp.add_argument("--debug-agent", type=str,
+                    help="Wait for the given debugger agent to attach. Currently "
+                         "only supported on host.")
+  argp.add_argument("--debug-wrap-agent", action='store_true',
+                    help="use libwrapagentproperties and tools/libjdwp-compat.props "
+                         "to load the debugger agent specified by --debug-agent.")
+  argp.add_argument("--with-agent", type=str, action='append', default=[],
+                    help="Run the test with the given agent loaded with -agentpath:")
+  argp.add_argument("--debuggable", action='store_true',
+                    help="Whether to compile Java code for a debugger.")
+  argp.add_argument("--gdb", action='store_true',
+                    help="Run under gdb; incompatible with some tests.")
+  argp.add_argument("--gdb-dex2oat", action='store_true',
+                    help="Run dex2oat under the prebuilt gdb.")
+  argp.add_argument("--gdbserver", action='store_true',
+                    help="Start gdbserver (defaults to port :5039).")
+  argp.add_argument("--gdbserver-port", type=str,
+                    help="Start gdbserver with the given COMM (see man gdbserver).")
+  argp.add_argument("--gdbserver-bin", type=str,
+                    help="Use the given binary as gdbserver.")
+  argp.add_argument("--gdb-arg", type=str, action='append', default=[],
+                    help="Pass an option to gdb or gdbserver.")
+  argp.add_argument("--gdb-dex2oat-args", type=str,
+                    help="Pass options separated by ';' to gdb for dex2oat.")
+  argp.add_argument("--simpleperf", action='store_true',
+                    help="Wraps the dalvikvm invocation in 'simpleperf record "
+                         "and dumps stats to stdout.")
+  argp.add_argument("--interpreter", action='store_true',
+                    help="Enable interpreter only mode (off by default).")
+  argp.add_argument("--jit", action='store_true',
+                    help="Enable jit (off by default).")
+  argp.add_argument("--optimizing", action='store_true',
+                    help="Enable optimizing compiler (default).")
+  argp.add_argument("--baseline", action='store_true',
+                    help="Enable baseline compiler.")
+  argp.add_argument("--no-verify", action='store_true',
+                    help="Turn off verification (on by default).")
+  argp.add_argument("--verify-soft-fail", action='store_true',
+                    help="Force soft fail verification (off by default). "
+                         "Verification is enabled if neither --no-verify "
+                         "nor --verify-soft-fail is specified.")
+  argp.add_argument("--no-optimize", action='store_true',
+                    help="Turn off optimization (on by default).")
+  argp.add_argument("--no-precise", action='store_true',
+                    help="Turn off precise GC (on by default).")
+  argp.add_argument("--zygote", action='store_true',
+                    help="Spawn the process from the Zygote. "
+                         "If used, then the other runtime options are ignored.")
+  argp.add_argument("--prebuild", action='store_true',
+                    help="Run dex2oat on the files before starting test. (default)")
+  argp.add_argument("--no-prebuild", action='store_true',
+                    help="Do not run dex2oat on the files before starting the test.")
+  argp.add_argument("--strip-dex", action='store_true',
+                    help="Strip the dex files before starting test.")
+  argp.add_argument("--relocate", action='store_true',
+                    help="Force the use of relocating in the test, making "
+                         "the image and oat files be relocated to a random address before running.")
+  argp.add_argument("--no-relocate", action='store_true',
+                    help="Force the use of no relocating in the test. (default)")
+  argp.add_argument("--image", type=str,
+                    help="Run the test using a precompiled boot image. (default)")
+  argp.add_argument("--no-image", action='store_true',
+                    help="Run the test without a precompiled boot image.")
+  argp.add_argument("--host", action='store_true',
+                    help="Use the host-mode virtual machine.")
+  argp.add_argument("--invoke-with", type=str, action='append', default=[],
+                    help="Pass --invoke-with option to runtime.")
+  argp.add_argument("--dalvik", action='store_true',
+                    help="Use Dalvik (off by default).")
+  argp.add_argument("--jvm", action='store_true',
+                    help="Use a host-local RI virtual machine.")
+  argp.add_argument("--use-java-home", action='store_true',
+                    help="Use the JAVA_HOME environment variable to find the java compiler "
+                         "and runtime (if applicable) to run the test with.")
+  argp.add_argument("--64", dest="is64bit", action='store_true',
+                    help="Run the test in 64-bit mode")
+  argp.add_argument("--bionic", action='store_true',
+                    help="Use the (host, 64-bit only) linux_bionic libc runtime")
+  argp.add_argument("--timeout", type=str,
+                    help="Test timeout in seconds")
+  argp.add_argument("--trace", action='store_true',
+                    help="Run with method tracing")
+  argp.add_argument("--strace", action='store_true',
+                    help="Run with syscall tracing from strace.")
+  argp.add_argument("--stream", action='store_true',
+                    help="Run method tracing in streaming mode (requires --trace)")
+  argp.add_argument("--gcstress", action='store_true',
+                    help="Run with gc stress testing")
+  argp.add_argument("--gcverify", action='store_true',
+                    help="Run with gc verification")
+  argp.add_argument("--jvmti-trace-stress", action='store_true',
+                    help="Run with jvmti method tracing stress testing")
+  argp.add_argument("--jvmti-step-stress", action='store_true',
+                    help="Run with jvmti single step stress testing")
+  argp.add_argument("--jvmti-redefine-stress", action='store_true',
+                    help="Run with jvmti method redefinition stress testing")
+  argp.add_argument("--always-clean", action='store_true',
+                    help="Delete the test files even if the test fails.")
+  argp.add_argument("--never-clean", action='store_true',
+                    help="Keep the test files even if the test succeeds.")
+  argp.add_argument("--chroot", type=str,
+                    help="Run with root directory set to newroot.")
+  argp.add_argument("--android-root", type=str,
+                    help="The path on target for the android root. (/system by default).")
+  argp.add_argument("--android-art-root", type=str,
+                    help="The path on target for the ART module root. "
+                         "(/apex/com.android.art by default).")
+  argp.add_argument("--android-tzdata-root", type=str,
+                    help="The path on target for the Android Time Zone Data root. "
+                         "(/apex/com.android.tzdata by default).")
+  argp.add_argument("--android-i18n-root", type=str,
+                    help="The path on target for the i18n module root. "
+                         "(/apex/com.android.i18n by default)."),
+  argp.add_argument("--dex2oat-swap", action='store_true',
+                    help="Use a dex2oat swap file.")
+  argp.add_argument("--instruction-set-features", type=str,
+                    help="Set instruction-set-features for compilation.")
+  argp.add_argument("--quiet", action='store_true',
+                    help="Don't print anything except failure messages")
+  argp.add_argument("--external-log-tags", action='store_true',
+                    help="Deprecated. Use --android-log-tags instead.")
+  argp.add_argument("--android-log-tags", type=str,
+                    help="Custom logging level for a test run.")
+  argp.add_argument("--suspend-timeout", type=str,
+                    help="Change thread suspend timeout ms (default 500000).")
+  argp.add_argument("--switch-interpreter", action='store_true')
+  argp.add_argument("--jvmti-field-stress", action='store_true',
+                    help="Run with jvmti method field stress testing")
+  argp.add_argument("--vdex", action='store_true',
+                    help="Test using vdex as in input to dex2oat. Only works with --prebuild.")
+  argp.add_argument("--dm", action='store_true'),
+  argp.add_argument("--vdex-filter", type=str)
+  argp.add_argument("--random-profile", action='store_true')
+  argp.add_argument("--dex2oat-jobs", type=int,
+                    help="Number of dex2oat jobs.")
+  argp.add_argument("--create-runner", type=Path, metavar='output_dir',
+                    help="Creates a runner script for use with other tools.")
+  argp.add_argument("--dev", action='store_true',
+                    help="Development mode (dumps to stdout).")
+  argp.add_argument("--update", action='store_true',
+                    help="Update mode (replaces expected-stdout.txt and expected-stderr.txt).")
+  argp.add_argument("--dump-cfg", type=str,
+                    help="Dump the CFG to the specified path.")
+  argp.add_argument("--bisection-search", action='store_true',
+                    help="Perform bisection bug search.")
+  argp.add_argument("--temp-path", type=str,
+                    help="Location where to execute the tests.")
+  argp.add_argument("test_name", nargs="?", default='-', type=str,
+                    help="Name of the test to run.")
+  argp.add_argument("test_args", nargs="*", default=None,
+                    help="Arguments to be passed to the test directly.")
+
+  # Python parser requires the format --key=--value, since without the equals symbol
+  # it looks like the required value has been omitted and there is just another flag.
+  # For example, '--Xcompiler-option --debuggable' will become '--Xcompiler-option=--debuggable'
+  # because otherwise the --Xcompiler-option is missing value and --debuggable is unknown argument.
+  argv = list(sys.argv[1:])
+  for i, arg in reversed(list(enumerate(argv))):
+    if arg in ["--runtime-option", "-Xcompiler-option"]:
+      argv[i] += "=" + argv.pop(i + 1)
+
+  # Accept single-dash arguments as if they were double-dash arguments.
+  # For example, '-Xcompiler-option' becomes '--Xcompiler-option'
+  # because single-dash can be used only with single-letter arguments.
+  for i, arg in list(enumerate(argv)):
+    if arg.startswith("-") and not arg.startswith("--"):
+      argv[i] = "-" + arg
+    if arg == "--":
+      break
 
-  shift()
+  args = argp.parse_args(argv)
 
-  while True:
-    if arg == "--host":
-      target_mode = "no"
+  if True:
+    run_args = []
+    target_mode = not args.host
+    if not target_mode:
       DEX_LOCATION = tmp_dir
       run_args += ["--host"]
       os.environ["RUN_MODE"] = "host"
-      shift()
-    elif arg == "--quiet":
-      quiet = "yes"
-      shift()
-    elif arg == "--use-java-home":
+    quiet = args.quiet
+    usage = False
+    if args.use_java_home:
       JAVA_HOME = os.environ.get("JAVA_HOME")
       if JAVA_HOME:
         export("JAVA", f"{JAVA_HOME}/bin/java")
         export("JAVAC", f"{JAVA_HOME}/bin/javac -g")
       else:
         error("Passed --use-java-home without JAVA_HOME variable set!")
-        usage = "yes"
-      shift()
-    elif arg == "--jvm":
-      target_mode = "no"
+        usage = True
+    prebuild_mode = True
+    runtime = "art"
+    if args.jvm:
+      target_mode = False
       DEX_LOCATION = tmp_dir
       runtime = "jvm"
-      prebuild_mode = "no"
+      prebuild_mode = False
       run_args += ["--jvm"]
-      shift()
-    elif arg == "-O":
+    lib = "libartd.so"
+    testlib = "arttestd"
+    if args.O:
       lib = "libart.so"
       testlib = "arttest"
       run_args += ["-O"]
-      shift()
-    elif arg == "--dalvik":
+    if args.dalvik:
       lib = "libdvm.so"
       runtime = "dalvik"
-      shift()
-    elif arg == "--no-image":
-      have_image = "no"
-      shift()
-    elif arg == "--relocate":
-      relocate = "yes"
-      shift()
-    elif arg == "--no-relocate":
-      relocate = "no"
-      shift()
-    elif arg == "--prebuild":
+    have_image = not args.no_image
+    relocate = args.relocate and not args.no_relocate
+    if args.prebuild:
       run_args += ["--prebuild"]
-      prebuild_mode = "yes"
-      shift()
-    elif arg == "--strip-dex":
+      prebuild_mode = True
+    if args.strip_dex:
       run_args += ["--strip-dex"]
-      shift()
-    elif arg == "--debuggable":
+    debuggable = args.debuggable
+    if debuggable:
       run_args += ["-Xcompiler-option --debuggable"]
-      debuggable = "yes"
-      shift()
-    elif arg == "--no-prebuild":
+    if args.no_prebuild:
       run_args += ["--no-prebuild"]
-      prebuild_mode = "no"
-      shift()
-    elif arg == "--gcverify":
-      basic_verify = "true"
-      gc_verify = "true"
-      shift()
-    elif arg == "--gcstress":
-      basic_verify = "true"
-      gc_stress = "true"
-      shift()
-    elif arg == "--jvmti-step-stress":
-      jvmti_step_stress = "true"
+      prebuild_mode = False
+    basic_verify = gc_verify = args.gcverify
+    gc_stress = args.gcstress
+    if gc_stress:
+        basic_verify = True
+
+    jvmti_step_stress = args.jvmti_step_stress
+    jvmti_redefine_stress = args.jvmti_redefine_stress
+    jvmti_field_stress = args.jvmti_field_stress
+    jvmti_trace_stress = args.jvmti_trace_stress
+
+    if jvmti_step_stress:
       os.environ["JVMTI_STEP_STRESS"] = "true"
-      shift()
-    elif arg == "--jvmti-redefine-stress":
-      jvmti_redefine_stress = "true"
+    if jvmti_redefine_stress:
       os.environ["JVMTI_REDEFINE_STRESS"] = "true"
-      shift()
-    elif arg == "--jvmti-field-stress":
-      jvmti_field_stress = "true"
+    if jvmti_field_stress:
       os.environ["JVMTI_FIELD_STRESS"] = "true"
-      shift()
-    elif arg == "--jvmti-trace-stress":
-      jvmti_trace_stress = "true"
+    if jvmti_trace_stress:
       os.environ["JVMTI_TRACE_STRESS"] = "true"
-      shift()
-    elif arg == "--suspend-timeout":
-      shift()
-      suspend_timeout = arg
-      shift()
-    elif arg == "--image":
-      shift()
-      image = arg
-      run_args += [f'--image "{image}"']
-      shift()
-    elif arg == "-Xcompiler-option":
-      shift()
-      option = arg
-      run_args += [f'-Xcompiler-option "{option}"']
-      shift()
-    elif arg == "--runtime-option":
-      shift()
-      option = arg
-      run_args += [f'--runtime-option "{option}"']
-      shift()
-    elif arg == "--gdb-arg":
-      shift()
-      gdb_arg = arg
-      run_args += [f'--gdb-arg "{gdb_arg}"']
-      shift()
-    elif arg == "--gdb-dex2oat-args":
-      shift()
-      gdb_dex2oat_args = arg
-      run_args += [f'--gdb-dex2oat-args="{gdb_dex2oat_args}"']
-      shift()
-    elif arg == "--debug":
-      run_args += ["--debug"]
-      shift()
-    elif arg == "--debug-wrap-agent":
-      run_args += ["--debug-wrap-agent"]
-      shift()
-    elif arg == "--with-agent":
-      shift()
-      option = arg
-      run_args += [f'--with-agent "{arg}"']
-      shift()
-    elif arg == "--debug-agent":
-      shift()
-      option = arg
-      run_args += [f'--debug-agent "{arg}"']
-      shift()
-    elif arg == "--dump-cfg":
-      shift()
-      dump_cfg = "true"
-      dump_cfg_path = arg
-      shift()
-    elif arg == "--gdb":
-      run_args += ["--gdb"]
-      dev_mode = "yes"
-      shift()
-    elif arg == "--gdb-dex2oat":
-      run_args += ["--gdb-dex2oat"]
-      dev_mode = "yes"
-      shift()
-    elif arg == "--gdbserver-bin":
-      shift()
-      run_args += [f'--gdbserver-bin "{arg}"']
-      shift()
-    elif arg == "--gdbserver-port":
-      shift()
-      run_args += [f'--gdbserver-port "{arg}"']
-      shift()
-    elif arg == "--gdbserver":
-      run_args += ["--gdbserver"]
-      dev_mode = "yes"
-      shift()
-    elif arg == "--strace":
-      strace = "yes"
+    suspend_timeout = args.suspend_timeout or "500000"
+    if args.image:
+      run_args += [f'--image "{args.image}"']
+    run_args.extend([f'-Xcompiler-option "{option}"' for option in args.Xcompiler_option])
+    run_args.extend([f'--runtime-option "{option}"' for option in args.runtime_option])
+    run_args.extend([f'--gdb-arg "{gdb_arg}"' for gdb_arg in args.gdb_arg])
+
+    if args.gdb_dex2oat_args:
+      run_args.append(f'--gdb-dex2oat-args="{args.gdb_dex2oat_args}"')
+    if args.debug:
+      run_args.append("--debug")
+    if args.debug_wrap_agent:
+      run_args.append("--debug-wrap-agent")
+    run_args.extend([f'--with-agent "{arg}"' for arg in args.with_agent])
+
+    if args.debug_agent:
+      run_args.append(f'--debug-agent "{args.debug_agent}"')
+
+    dump_cfg = bool(args.dump_cfg)
+    dump_cfg_path = args.dump_cfg or ""
+
+    dev_mode = args.gdb or args.gdb_dex2oat
+    if args.gdb:
+      run_args.append("--gdb")
+    if args.gdb_dex2oat:
+      run_args.append("--gdb-dex2oat")
+    if args.gdbserver_bin:
+      run_args.append(f'--gdbserver-bin "{args.gdbserver_bin}"')
+    if args.gdbserver_port:
+      run_args.append(f'--gdbserver-port "{args.gdbserver_port}"')
+    if args.gdbserver:
+      run_args.append("--gdbserver")
+      dev_mode = True
+    strace = args.strace
+    strace_output = "strace-output.txt"
+    timeout = ""
+    if strace:
       run_args += [
           f'--invoke-with=strace --invoke-with=-o --invoke-with="{tmp_dir}/{strace_output}"'
       ]
       timeout = timeout or "1800"
-      shift()
-    elif arg == "--zygote":
+    if args.zygote:
       run_args += ["--zygote"]
-      shift()
-    elif arg == "--interpreter":
+    if args.interpreter:
       run_args += ["--interpreter"]
-      shift()
-    elif arg == "--switch-interpreter":
+    if args.switch_interpreter:
       run_args += ["--switch-interpreter"]
-      shift()
-    elif arg == "--jit":
+    if args.jit:
       run_args += ["--jit"]
-      shift()
-    elif arg == "--baseline":
+    if args.baseline:
       run_args += ["--baseline"]
-      shift()
-    elif arg == "--optimizing":
-      run_optimizing = "true"
-      shift()
-    elif arg == "--no-verify":
+    run_optimizing = args.optimizing
+    if args.no_verify:
       run_args += ["--no-verify"]
-      shift()
-    elif arg == "--verify-soft-fail":
+    if args.verify_soft_fail:
       run_args += ["--verify-soft-fail"]
       os.environ["VERIFY_SOFT_FAIL"] = "true"
-      shift()
-    elif arg == "--no-optimize":
+    if args.no_optimize:
       run_args += ["--no-optimize"]
-      shift()
-    elif arg == "--no-precise":
+    if args.no_precise:
       run_args += ["--no-precise"]
-      shift()
-    elif arg.startswith("--android-log-tags"):
-      run_args += [arg]
-      shift()
-    elif arg == "--external-log-tags":
+    if args.android_log_tags:
+      run_args += [f"--android-log-tags {args.android_log_tags}"]
+    if args.external_log_tags:
       run_args += ["--external-log-tags"]
-      shift()
-    elif arg == "--invoke-with":
-      shift()
-      what = arg
-      if not arg:
-        error("missing argument to --invoke-with")
-        usage = "yes"
-        break
-      run_args += [f'--invoke-with "{what}"']
-      shift()
-    elif arg == "--create-runner":
+    if args.invoke_with:
+      run_args += [f'--invoke-with "{what}"' for what in args.invoke_with]
+    create_runner = args.create_runner
+    if create_runner:
       run_args += ["--create-runner --dry-run"]
-      dev_mode = "yes"
-      never_clean = "yes"
-      create_runner = "yes"
-      shift()
-    elif arg == "--dev":
-      dev_mode = "yes"
-      shift()
-    elif arg == "--temp-path":
-      shift()
-      if not arg:
-        error("missing argument to --temp-path")
-        usage = "yes"
-        break
-      shift()
-    elif arg == "--chroot":
-      shift()
-      if not arg:
-        error("missing argument to --chroot")
-        usage = "yes"
-        break
-      chroot = arg
-      run_args += [f'--chroot "{arg}"']
-      shift()
-    elif arg == "--simpleperf":
+      dev_mode = True
+    dev_mode = dev_mode or args.dev
+    chroot = args.chroot or ""
+    if chroot:
+      run_args += [f'--chroot "{chroot}"']
+    if args.simpleperf:
       run_args += ["--simpleperf"]
-      shift()
-    elif arg == "--android-root":
-      shift()
-      if not arg:
-        error("missing argument to --android-root")
-        usage = "yes"
-        break
-      android_root = arg
-      run_args += [f'--android-root "{arg}"']
-      shift()
-    elif arg == "--android-art-root":
-      shift()
-      if not arg:
-        error("missing argument to --android-art-root")
-        usage = "yes"
-        break
-      run_args += [f'--android-art-root "{arg}"']
-      shift()
-    elif arg == "--android-tzdata-root":
-      shift()
-      if not arg:
-        error("missing argument to --android-tzdata-root")
-        usage = "yes"
-        break
-      run_args += [f'--android-tzdata-root "{arg}"']
-      shift()
-    elif arg == "--update":
-      update_mode = "yes"
-      shift()
-    elif arg == "--help":
-      usage = "yes"
-      shift()
-    elif arg == "--64":
+    android_root = args.android_root or "/system"
+    if args.android_root:
+      run_args += [f'--android-root "{android_root}"']
+    if args.android_art_root:
+      run_args += [f'--android-art-root "{args.android_art_root}"']
+    if args.android_tzdata_root:
+      run_args += [f'--android-tzdata-root "{args.android_tzdata_root}"']
+    update_mode = args.update
+    suffix64 = "64" if args.is64bit else ""
+    if args.is64bit:
       run_args += ["--64"]
-      suffix64 = "64"
-      shift()
-    elif arg == "--bionic":
+    host_lib_root = ANDROID_HOST_OUT
+    if args.bionic:
       # soong linux_bionic builds are 64bit only.
       run_args += ["--bionic --host --64"]
       suffix64 = "64"
-      target_mode = "no"
+      target_mode = False
       DEX_LOCATION = tmp_dir
       host_lib_root = f"{OUT_DIR}/soong/host/linux_bionic-x86"
-      shift()
-    elif arg == "--timeout":
-      shift()
-      if not arg:
-        error("missing argument to --timeout")
-        usage = "yes"
-        break
-      timeout = arg
-      shift()
-    elif arg == "--trace":
-      trace = "true"
-      shift()
-    elif arg == "--stream":
-      trace_stream = "true"
-      shift()
-    elif arg == "--always-clean":
-      always_clean = "yes"
-      shift()
-    elif arg == "--never-clean":
-      never_clean = "yes"
-      shift()
-    elif arg == "--dex2oat-swap":
+
+    timeout = args.timeout or timeout
+    trace = args.trace
+    trace_stream = args.stream
+    always_clean = args.always_clean
+    never_clean = create_runner or args.never_clean
+    if args.dex2oat_swap:
       run_args += ["--dex2oat-swap"]
-      shift()
-    elif arg == "--instruction-set-features":
-      shift()
-      run_args += [f'--instruction-set-features "{arg}"']
-      shift()
-    elif arg == "--bisection-search":
-      bisection_search = "yes"
-      shift()
-    elif arg == "--vdex":
+    if args.instruction_set_features:
+      run_args += [f'--instruction-set-features "{args.instruction_set_features}"']
+
+    bisection_search = args.bisection_search
+    if args.vdex:
       run_args += ["--vdex"]
-      shift()
-    elif arg == "--dm":
+    if args.dm:
       run_args += ["--dm"]
-      shift()
-    elif arg == "--vdex-filter":
-      shift()
-      filter = arg
-      run_args += ['--vdex-filter "{filter}"']
-      shift()
-    elif arg == "--random-profile":
+    if args.vdex_filter:
+      run_args += [f'--vdex-filter "{args.vdex_filter}"']
+    if args.random_profile:
       run_args += ["--random-profile"]
-      shift()
-    elif arg == "--dex2oat-jobs":
-      shift()
-      run_args += [f'-Xcompiler-option "-j{arg}"']
-      shift()
-    elif arg.startswith("--"):
-      error(f"unknown option: {arg}")
-      usage = "yes"
-      break
-    else:
-      break
+    if args.dex2oat_jobs:
+      run_args += [f'-Xcompiler-option "-j{str(args.dex2oat_jobs)}"']
 
   export("DEX_LOCATION", DEX_LOCATION)
 
-  if usage == "no" and not arg:
-    error("missing test to run")
-    usage = "yes"
-
 # The DEX_LOCATION with the chroot prefix, if any.
   chroot_dex_location = f"{chroot}{DEX_LOCATION}"
 
@@ -594,36 +596,36 @@ if True:
         f'--runtime-option "-XX:ThreadSuspendTimeout={suspend_timeout}"'
     ]
 
-  if basic_verify == "true":
+  if basic_verify:
     # Set HspaceCompactForOOMMinIntervalMs to zero to run hspace compaction for OOM more frequently in tests.
     run_args += [
         "--runtime-option -Xgc:preverify --runtime-option -Xgc:postverify "
         "--runtime-option -XX:HspaceCompactForOOMMinIntervalMs=0"
     ]
-  if gc_verify == "true":
+  if gc_verify:
     run_args += [
         "--runtime-option -Xgc:preverify_rosalloc --runtime-option "
         "-Xgc:postverify_rosalloc"
     ]
-  if gc_stress == "true":
+  if gc_stress:
     run_args += [
         "--gc-stress --runtime-option -Xgc:gcstress --runtime-option -Xms2m "
         "--runtime-option -Xmx16m"
     ]
-  if jvmti_redefine_stress == "true":
+  if jvmti_redefine_stress:
     run_args += ["--no-app-image --jvmti-redefine-stress"]
-  if jvmti_step_stress == "true":
+  if jvmti_step_stress:
     run_args += ["--no-app-image --jvmti-step-stress"]
-  if jvmti_field_stress == "true":
+  if jvmti_field_stress:
     run_args += ["--no-app-image --jvmti-field-stress"]
-  if jvmti_trace_stress == "true":
+  if jvmti_trace_stress:
     run_args += ["--no-app-image --jvmti-trace-stress"]
-  if trace == "true":
+  if trace:
     run_args += [
         "--runtime-option -Xmethod-trace --runtime-option "
         "-Xmethod-trace-file-size:2000000"
     ]
-    if trace_stream == "true":
+    if trace_stream:
       # Streaming mode uses the file size as the buffer size. So output gets really large. Drop
       # the ability to analyze the file and just write to /dev/null.
       run_args += ["--runtime-option -Xmethod-trace-file:/dev/null"]
@@ -633,7 +635,7 @@ if True:
       run_args += [
           f'--runtime-option "-Xmethod-trace-file:{DEX_LOCATION}/trace.bin"'
       ]
-  elif trace_stream == "true":
+  elif trace_stream:
     error("Cannot use --stream without --trace.")
     sys.exit(1)
   if timeout:
@@ -651,9 +653,9 @@ if True:
     else:
       return "x86"
 
-  if target_mode == "no":
+  if not target_mode:
     if runtime == "jvm":
-      if prebuild_mode == "yes":
+      if prebuild_mode:
         error("--prebuild with --jvm is unsupported")
         sys.exit(1)
     else:
@@ -667,14 +669,14 @@ if True:
 
   ANDROID_PRODUCT_OUT = os.environ.get("ANDROID_PRODUCT_OUT")
   if runtime == "dalvik":
-    if target_mode == "no":
+    if not target_mode:
       framework = f"{ANDROID_PRODUCT_OUT}/system/framework"
       bpath = f"{framework}/core-icu4j.jar:{framework}/core-libart.jar:{framework}/core-oj.jar:{framework}/conscrypt.jar:{framework}/okhttp.jar:{framework}/bouncycastle.jar:{framework}/ext.jar"
       run_args += [f'--boot --runtime-option "-Xbootclasspath:{bpath}"']
     else:
       pass  # defaults to using target BOOTCLASSPATH
   elif runtime == "art":
-    if target_mode == "no":
+    if not target_mode:
       host_arch_name = guess_host_arch_name()
       run_args += [
           f'--boot "{ANDROID_HOST_OUT}/apex/art_boot_images/javalib/boot.art"'
@@ -691,8 +693,11 @@ if True:
       run_args += [
           f'--runtime-option "-Djava.library.path=/data/nativetest{suffix64}/art/{target_arch_name}"'
       ]
-      run_args += ['--boot "/system/framework/art_boot_images/boot.art"']
-    if relocate == "yes":
+      if env.ART_TEST_RUN_FROM_SOONG:
+        run_args += ['--boot "/data/local/tmp/art/apex/art_boot_images/boot.art"']
+      else:
+        run_args += ['--boot "/system/framework/art_boot_images/boot.art"']
+    if relocate:
       run_args += ["--relocate"]
     else:
       run_args += ["--no-relocate"]
@@ -702,160 +707,41 @@ if True:
         f'--runtime-option "-Djava.library.path={ANDROID_HOST_OUT}/lib64:{ANDROID_HOST_OUT}/nativetest64"'
     ]
 
-  if have_image == "no":
+  if not have_image:
     if runtime != "art":
       error("--no-image is only supported on the art runtime")
       sys.exit(1)
     run_args += ["--no-image"]
 
-  if create_runner == "yes" and target_mode == "yes":
-    error("--create-runner does not function for non --host tests")
-    usage = "yes"
-
-  if dev_mode == "yes" and update_mode == "yes":
+  if dev_mode and update_mode:
     error("--dev and --update are mutually exclusive")
-    usage = "yes"
+    usage = True
 
-  if dev_mode == "yes" and quiet == "yes":
+  if dev_mode and quiet:
     error("--dev and --quiet are mutually exclusive")
-    usage = "yes"
+    usage = True
 
-  if bisection_search == "yes" and prebuild_mode == "yes":
+  if bisection_search and prebuild_mode:
     error("--bisection-search and --prebuild are mutually exclusive")
-    usage = "yes"
+    usage = True
 
 # TODO: Chroot-based bisection search is not supported yet (see below); implement it.
-  if bisection_search == "yes" and chroot:
+  if bisection_search and chroot:
     error("--chroot with --bisection-search is unsupported")
     sys.exit(1)
 
-  if usage == "no":
-    if not arg or arg == "-":
-      test_dir = os.path.basename(oldwd)
-    else:
-      test_dir = arg
+  if args.test_name == "-":
+    test_dir = os.path.basename(oldwd)
+  else:
+    test_dir = args.test_name
 
-    if not os.path.isdir(test_dir):
-      td2 = glob.glob(f"{test_dir}-*")
-      if len(td2) == 1 and os.path.isdir(td2[0]):
-        test_dir = td2[0]
-      else:
-        error(f"{test_dir}: no such test directory")
-        usage = "yes"
-    # Shift to get rid of the test name argument. The rest of the arguments
-    # will get passed to the test run.
-    shift()
-
-  if usage == "yes":
-    prog = os.path.basename(__file__)
-    # pyformat: disable
-    help=(
-        "usage:\n"
-        f"  $prog --help                          Print this message.\n"
-        f"  $prog [options] [test-name]           Run test normally.\n"
-        f"  $prog --dev [options] [test-name]     Development mode\n"
-        "(dumps to stdout).\n"
-        f"  $prog --create-runner [options] [test-name]\n"
-        "              Creates a runner script for use with other \n"
-        "tools (e.g. parallel_run.py).\n"
-        "              The script will only run the test portion, and \n"
-        "share oat and dex files.\n"
-        f"  $prog --update [options] [test-name]  Update mode\n"
-        "(replaces expected-stdout.txt and expected-stderr.txt).\n"
-        '  Omitting the test name or specifying "-" will use the\n'
-        "current directory.\n"
-        "  Runtime Options:\n"
-        "    -O                    Run non-debug rather than debug build (off by default).\n"
-        "    -Xcompiler-option     Pass an option to the compiler.\n"
-        "    --runtime-option      Pass an option to the runtime.\n"
-        "    --debug               Wait for the default debugger to attach.\n"
-        "    --debug-agent <agent-path>\n"
-        "                          Wait for the given debugger agent to attach. Currently\n"
-        "                          only supported on host.\n"
-        "    --debug-wrap-agent    use libwrapagentproperties and tools/libjdwp-compat.props\n"
-        "                          to load the debugger agent specified by --debug-agent.\n"
-        "    --with-agent <agent>  Run the test with the given agent loaded with -agentpath:\n"
-        "    --debuggable          Whether to compile Java code for a debugger.\n"
-        "    --gdb                 Run under gdb; incompatible with some tests.\n"
-        "    --gdb-dex2oat         Run dex2oat under the prebuilt gdb.\n"
-        "    --gdbserver           Start gdbserver (defaults to port :5039).\n"
-        "    --gdbserver-port <port>\n"
-        "                          Start gdbserver with the given COMM (see man gdbserver).\n"
-        "    --gdbserver-bin <binary>\n"
-        "                          Use the given binary as gdbserver.\n"
-        "    --gdb-arg             Pass an option to gdb or gdbserver.\n"
-        "    --gdb-dex2oat-args    Pass options separated by ';' to gdb for dex2oat.\n"
-        "    --simpleperf          Wraps the dalvikvm invocation in 'simpleperf record ...\n"
-        "                          ... simpleperf report' and dumps stats to stdout.\n"
-        "    --temp-path [path]    Location where to execute the tests.\n"
-        "    --interpreter         Enable interpreter only mode (off by default).\n"
-        "    --jit                 Enable jit (off by default).\n"
-        "    --optimizing          Enable optimizing compiler (default).\n"
-        "    --no-verify           Turn off verification (on by default).\n"
-        "    --verify-soft-fail    Force soft fail verification (off by default).\n"
-        "                          Verification is enabled if neither --no-verify\n"
-        "                          nor --verify-soft-fail is specified.\n"
-        "    --no-optimize         Turn off optimization (on by default).\n"
-        "    --no-precise          Turn off precise GC (on by default).\n"
-        "    --zygote              Spawn the process from the Zygote.\n"
-        "If used, then the\n"
-        "                          other runtime options are ignored.\n"
-        "    --prebuild            Run dex2oat on the files before starting test. (default)\n"
-        "    --no-prebuild         Do not run dex2oat on the files before starting\n"
-        "                          the test.\n"
-        "    --strip-dex           Strip the dex files before starting test.\n"
-        "    --relocate            Force the use of relocating in the test, making\n"
-        "                          the image and oat files be relocated to a random\n"
-        "                          address before running.\n"
-        "    --no-relocate         Force the use of no relocating in the test. (default)\n"
-        "    --image               Run the test using a precompiled boot image. (default)\n"
-        "    --no-image            Run the test without a precompiled boot image.\n"
-        "    --host                Use the host-mode virtual machine.\n"
-        "    --invoke-with         Pass --invoke-with option to runtime.\n"
-        "    --dalvik              Use Dalvik (off by default).\n"
-        "    --jvm                 Use a host-local RI virtual machine.\n"
-        "    --use-java-home       Use the JAVA_HOME environment variable\n"
-        "                          to find the java compiler and runtime\n"
-        "                          (if applicable) to run the test with.\n"
-        "    --64                  Run the test in 64-bit mode\n"
-        "    --bionic              Use the (host, 64-bit only) linux_bionic libc runtime\n"
-        "    --timeout n           Test timeout in seconds\n"
-        "    --trace               Run with method tracing\n"
-        "    --strace              Run with syscall tracing from strace.\n"
-        "    --stream              Run method tracing in streaming mode (requires --trace)\n"
-        "    --gcstress            Run with gc stress testing\n"
-        "    --gcverify            Run with gc verification\n"
-        "    --jvmti-trace-stress  Run with jvmti method tracing stress testing\n"
-        "    --jvmti-step-stress   Run with jvmti single step stress testing\n"
-        "    --jvmti-redefine-stress\n"
-        "                          Run with jvmti method redefinition stress testing\n"
-        "    --always-clean        Delete the test files even if the test fails.\n"
-        "    --never-clean         Keep the test files even if the test succeeds.\n"
-        "    --chroot [newroot]    Run with root directory set to newroot.\n"
-        "    --android-root [path] The path on target for the android root. (/system by default).\n"
-        "    --android-i18n-root [path]\n"
-        "                          The path on target for the i18n module root.\n"
-        "                          (/apex/com.android.i18n by default).\n"
-        "    --android-art-root [path]\n"
-        "                          The path on target for the ART module root.\n"
-        "                          (/apex/com.android.art by default).\n"
-        "    --android-tzdata-root [path]\n"
-        "                          The path on target for the Android Time Zone Data root.\n"
-        "                          (/apex/com.android.tzdata by default).\n"
-        "    --dex2oat-swap        Use a dex2oat swap file.\n"
-        "    --instruction-set-features [string]\n"
-        "                          Set instruction-set-features for compilation.\n"
-        "    --quiet               Don't print anything except failure messages\n"
-        "    --external-log-tags   Use ANDROID_LOG_TAGS to set a custom logging level for\n"
-        "                          a test run.\n"
-        "    --bisection-search    Perform bisection bug search.\n"
-        "    --vdex                Test using vdex as in input to dex2oat. Only works with --prebuild.\n"
-        "    --suspend-timeout     Change thread suspend timeout ms (default 500000).\n"
-        "    --dex2oat-jobs        Number of dex2oat jobs.\n"
-    )
-    # pyformat: enable
-    error(help)
-    sys.exit(1)
+  if not os.path.isdir(test_dir):
+    td2 = glob.glob(f"{test_dir}-*")
+    if len(td2) == 1 and os.path.isdir(td2[0]):
+      test_dir = td2[0]
+    else:
+      error(f"{test_dir}: no such test directory")
+      usage = True
 
   os.chdir(test_dir)
   test_dir = os.getcwd()
@@ -867,20 +753,20 @@ if True:
   # Checker when compiled with Optimizing on host.
   # Additionally, if the user specifies that the CFG must be dumped, it will
   # run the checker for any type of test to generate the CFG.
-  if re.match("[0-9]+-checker-", TEST_NAME) or dump_cfg == "true":
-    if runtime == "art" and run_optimizing == "true":
+  if re.match("[0-9]+-checker-", TEST_NAME) or dump_cfg:
+    if runtime == "art" and run_optimizing:
       # In no-prebuild or no-image mode, the compiler only quickens so disable the checker.
-      if prebuild_mode == "yes":
-        run_checker = "yes"
+      if prebuild_mode:
+        run_checker = True
 
-        if target_mode == "no":
+        if not target_mode:
           cfg_output_dir = tmp_dir
           checker_args = f"--arch={host_arch_name.upper()}"
         else:
           cfg_output_dir = DEX_LOCATION
           checker_args = f"--arch={target_arch_name.upper()}"
 
-        if debuggable == "yes":
+        if debuggable:
           checker_args += " --debuggable"
 
         run_args += [
@@ -893,61 +779,76 @@ if True:
   resource.setrlimit(resource.RLIMIT_FSIZE, (file_ulimit * 1024, resource.RLIM_INFINITY))
 
   # Extract run-test data from the zip file.
-  shutil.rmtree(tmp_dir)
-  os.makedirs(f"{tmp_dir}/.unzipped")
-  os.chdir(tmp_dir)
-  m = re.match("[0-9]*([0-9][0-9])-.*", TEST_NAME)
-  assert m, "Can not find test number in " + TEST_NAME
-  SHARD = "HiddenApi" if "hiddenapi" in TEST_NAME else m.group(1)
-  if target_mode == "yes":
-    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-target-data-shard{SHARD}.zip"
-    zip_entry = f"target/{TEST_NAME}/"
-  elif runtime == "jvm":
-    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-jvm-data-shard{SHARD}.zip"
-    zip_entry = f"jvm/{TEST_NAME}/"
-  else:
-    zip_file = f"{ANDROID_HOST_OUT}/etc/art/art-run-test-host-data-shard{SHARD}.zip"
-    zip_entry = f"host/{TEST_NAME}/"
-  zip = ZipFile(zip_file, "r")
-  zip_entries = [e for e in zip.namelist() if e.startswith(zip_entry)]
-  zip.extractall(Path(tmp_dir) / ".unzipped", members=zip_entries)
-  for entry in (Path(tmp_dir) / ".unzipped" / zip_entry).iterdir():
-    entry.rename(Path(tmp_dir) / entry.name)
+  def unzip():
+    if env.ART_TEST_RUN_FROM_SOONG:
+      # We already have the unzipped copy of the data.
+      assert target_mode
+      src = Path(ANDROID_BUILD_TOP) / "out" / "zip" / "target" / TEST_NAME
+      assert src.exists(), src
+      shutil.rmtree(tmp_dir)
+      copytree(src, tmp_dir)
+      os.chdir(tmp_dir)
+      return
+
+    # Clear the contents, but keep the directory just in case it is open in terminal.
+    for file in Path(tmp_dir).iterdir():
+      if file.is_file() or file.is_symlink():
+        file.unlink()
+      else:
+        shutil.rmtree(file)
+    os.makedirs(f"{tmp_dir}/.unzipped")
+    os.chdir(tmp_dir)
+    m = re.match("[0-9]*([0-9][0-9])-.*", TEST_NAME)
+    assert m, "Can not find test number in " + TEST_NAME
+    SHARD = "HiddenApi" if "hiddenapi" in TEST_NAME else m.group(1)
+    zip_dir = f"{ANDROID_HOST_OUT}/etc/art"
+    if target_mode:
+      zip_file = f"{zip_dir}/art-run-test-target-data-shard{SHARD}.zip"
+      zip_entry = f"target/{TEST_NAME}/"
+    elif runtime == "jvm":
+      zip_file = f"{zip_dir}/art-run-test-jvm-data-shard{SHARD}.zip"
+      zip_entry = f"jvm/{TEST_NAME}/"
+    else:
+      zip_file = f"{zip_dir}/art-run-test-host-data-shard{SHARD}.zip"
+      zip_entry = f"host/{TEST_NAME}/"
+    zip = ZipFile(zip_file, "r")
+    zip_entries = [e for e in zip.namelist() if e.startswith(zip_entry)]
+    zip.extractall(Path(tmp_dir) / ".unzipped", members=zip_entries)
+    for entry in (Path(tmp_dir) / ".unzipped" / zip_entry).iterdir():
+      entry.rename(Path(tmp_dir) / entry.name)
+
+  unzip()
 
   def clean_up(passed: bool):
-    if always_clean == "yes" or (passed and never_clean == "no"):
+    if always_clean or (passed and not never_clean):
       os.chdir(oldwd)
       shutil.rmtree(tmp_dir)
-      if target_mode == "yes":
+      if target_mode:
         if ON_VM:
           run(f"{SSH_CMD} \"rm -rf {chroot_dex_location}\"")
         else:
           run(f"adb shell rm -rf {chroot_dex_location}")
+      os.remove(tmp_dir_lock)
       print(f"{TEST_NAME} files deleted from host" +
-            (" and from target" if target_mode == "yes" else ""))
+            (" and from target" if target_mode else ""))
     else:
       print(f"{TEST_NAME} files left in {tmp_dir} on host" +
-            (f" and in {chroot_dex_location} on target" if target_mode == "yes" else ""))
+            (f" and in {chroot_dex_location} on target" if target_mode else ""))
     atexit.unregister(clean_up)
-  # TODO: Run this in global try-finally once the script is more refactored.
-  atexit.register(clean_up, passed=False)
 
-  ctx = RunTestContext(Path(tmp_dir), target_mode == "yes", chroot, DEX_LOCATION, TEST_NAME)
+  ctx = RunTestContext(Path(tmp_dir), target_mode, chroot, DEX_LOCATION, TEST_NAME)
   td_info = f"{test_dir}/{info}"
   for td_file in [td_info, ctx.expected_stdout, ctx.expected_stderr]:
     assert os.access(td_file, os.R_OK)
 
-  joined_run_args = " ".join(run_args)
-  joined_args = " ".join(args)
-
   # Create runner (bash script that executes the whole test)
   def create_runner_script() -> Path:
-    parsed_args = default_run_module.parse_args(shlex.split(" ".join(run_args + args)))
+    parsed_args = default_run_module.parse_args(shlex.split(" ".join(run_args + args.test_args)))
     parsed_args.stdout_file = os.path.join(DEX_LOCATION, test_stdout)
     parsed_args.stderr_file = os.path.join(DEX_LOCATION, test_stderr)
 
     ctx.run(f"cd {DEX_LOCATION}")
-    if target_mode != "yes":
+    if not target_mode:
       # Make "out" directory accessible from test directory.
       ctx.run(f"ln -s -f -t {DEX_LOCATION} {ANDROID_BUILD_TOP}/out")
     # Clear the stdout/stderr files (create empty files).
@@ -966,9 +867,8 @@ if True:
     return runner
 
   def do_dump_cfg():
-    assert run_optimizing == "true", ("The CFG can be dumped only in"
-                                      " optimizing mode")
-    if target_mode == "yes":
+    assert run_optimizing, "The CFG can be dumped only in optimizing mode"
+    if target_mode:
       if ON_VM:
         run(f'{SCP_CMD} "{SSH_USER}@${SSH_HOST}:{CHROOT}/{cfg_output_dir}/'
             f'{cfg_output} {dump_cfg_path}"')
@@ -986,8 +886,34 @@ if True:
   print(f"{test_dir}: Create runner script...")
   runner = create_runner_script()
 
+  if args.create_runner:
+    # TODO: Generate better unique names.
+    dst = args.create_runner / TEST_NAME / f"{Path(tmp_dir).name}.sh"
+    assert not dst.exists(), dst
+    dst.parent.mkdir(parents=True, exist_ok=True)
+    copyfile(runner, dst)
+
+  # Script debugging feature - just export the runner script into a directory,
+  # so that it can be compared before/after runner script refactoring.
+  save_runner_dir = os.environ.get("RUN_TEST_DEBUG__SAVE_RUNNER_DIR")
+  if save_runner_dir:
+    name = [a for a in sys.argv[1:] if not a.startswith("--create-runner")]
+    name = urllib.parse.quote(" ".join(name), safe=' ')
+    dst = Path(save_runner_dir) / TEST_NAME / name
+    os.makedirs(dst.parent, exist_ok=True)
+    txt = runner.read_text()
+    txt = txt.replace(Path(tmp_dir).name, "${TMP_DIR}")  # Make it deterministic.
+    txt = re.sub('\[run-test:\d+\]', '[run-test:(line-number)]', txt)
+    dst.write_text(txt)
+
+  if args.create_runner or save_runner_dir:
+    sys.exit(0)
+
+  # TODO: Run this in global try-finally once the script is more refactored.
+  atexit.register(clean_up, passed=False)
+
   print(f"{test_dir}: Run...")
-  if target_mode == "yes":
+  if target_mode:
     # Prepare the on-device test directory
     if ON_VM:
       run(f"{SSH_CMD} 'rm -rf {chroot_dex_location} && mkdir -p {chroot_dex_location}'")
@@ -1015,7 +941,7 @@ if True:
             fail_message=f"Runner {chroot_dex_location}/run.sh failed")
     finally:
       # Copy the generated CFG to the specified path.
-      if dump_cfg == "true":
+      if dump_cfg:
         do_dump_cfg()
 
     # Copy the on-device stdout/stderr to host.
@@ -1031,7 +957,7 @@ if True:
   # NB: There is no exit code or return value.
   # Failing tests just raise python exception.
   os.chdir(tmp_dir)
-  if update_mode == "yes":
+  if update_mode:
     for src, dst in [(test_stdout, os.path.join(test_dir, ctx.expected_stdout.name)),
                      (test_stderr, os.path.join(test_dir, ctx.expected_stderr.name))]:
       if "[DO_NOT_UPDATE]" not in open(dst).readline():
@@ -1045,12 +971,12 @@ if True:
   print("#################### stderr diff")
   proc_err = run(f'diff --strip-trailing-cr -u '
                  f'"{ctx.expected_stderr}" "{test_stderr}"', check=False)
-  if strace == "yes":
+  if strace:
     print("#################### strace output (trimmed to 3000 lines)")
     # Some tests do not run dalvikvm, in which case the trace does not exist.
     run(f'tail -n 3000 "{tmp_dir}/{strace_output}"', check=False)
   SANITIZE_HOST = os.environ.get("SANITIZE_HOST")
-  if target_mode == "no" and SANITIZE_HOST == "address":
+  if not target_mode and SANITIZE_HOST == "address":
     # Run the stack script to symbolize any ASAN aborts on the host for SANITIZE_HOST. The
     # tools used by the given ABI work for both x86 and x86-64.
     print("#################### symbolizer (trimmed to 3000 lines)")
@@ -1064,8 +990,8 @@ if True:
               (["stderr"] if proc_err.returncode != 0 else []))
       fail("{} did not match the expected file".format(" and ".join(kind)))
 
-    if run_checker == "yes":
-      if target_mode == "yes":
+    if run_checker:
+      if target_mode:
         if ON_VM:
           run(f'{SCP_CMD} "{SSH_USER}@{SSH_HOST}:{CHROOT}/{cfg_output_dir}/'
               f'{cfg_output}" "{tmp_dir}"')
@@ -1075,7 +1001,7 @@ if True:
           fail_message="CFG checker failed")
   finally:
     # Copy the generated CFG to the specified path.
-    if dump_cfg == "true":
+    if dump_cfg:
       do_dump_cfg()
 
   clean_up(passed=True)
diff --git a/test/run_test_build.py b/test/run_test_build.py
index ca4634d5ce..a93950f02f 100755
--- a/test/run_test_build.py
+++ b/test/run_test_build.py
@@ -19,14 +19,11 @@ This scripts compiles Java files which are needed to execute run-tests.
 It is intended to be used only from soong genrule.
 """
 
-import argparse
 import functools
-import glob
+import json
 import os
 import pathlib
 import re
-import shlex
-import shutil
 import subprocess
 import sys
 import zipfile
@@ -35,15 +32,17 @@ from argparse import ArgumentParser
 from concurrent.futures import ThreadPoolExecutor
 from fcntl import lockf, LOCK_EX, LOCK_NB
 from importlib.machinery import SourceFileLoader
-from os import environ, getcwd, chdir, cpu_count, chmod
+from os import environ, getcwd, cpu_count
 from os.path import relpath
 from pathlib import Path
 from pprint import pprint
-from re import match
 from shutil import copytree, rmtree
-from subprocess import run
+from subprocess import PIPE, run
 from tempfile import TemporaryDirectory, NamedTemporaryFile
 from typing import Dict, List, Union, Set, Optional
+from multiprocessing import cpu_count
+
+from globals import BOOTCLASSPATH
 
 USE_RBE = 100  # Percentage of tests that can use RBE (between 0 and 100)
 
@@ -513,6 +512,83 @@ class BuildTestContext:
       else:
         zip(Path(self.test_name + ".jar"), Path("classes.dex"))
 
+# Create bash script that compiles the boot image on device.
+# This is currently only used for eng-prod testing (which is different
+# to the local and LUCI code paths that use buildbot-sync.sh script).
+def create_setup_script(is64: bool):
+  out = "/data/local/tmp/art/apex/art_boot_images"
+  isa = 'arm64' if is64 else 'arm'
+  jar = BOOTCLASSPATH
+  cmd = [
+    f"/apex/com.android.art/bin/{'dex2oat64' if is64 else 'dex2oat32'}",
+    "--runtime-arg", f"-Xbootclasspath:{':'.join(jar)}",
+    "--runtime-arg", f"-Xbootclasspath-locations:{':'.join(jar)}",
+  ] + [f"--dex-file={j}" for j in jar] + [f"--dex-location={j}" for j in jar] + [
+    f"--instruction-set={isa}",
+    "--base=0x70000000",
+    "--compiler-filter=speed-profile",
+    "--profile-file=/apex/com.android.art/etc/boot-image.prof",
+    "--avoid-storing-invocation",
+    "--generate-debug-info",
+    "--generate-build-id",
+    "--image-format=lz4hc",
+    "--strip",
+    "--android-root=out/empty",
+    f"--image={out}/{isa}/boot.art",
+    f"--oat-file={out}/{isa}/boot.oat",
+  ]
+  return [
+    f"rm -rf {out}/{isa}",
+    f"mkdir -p {out}/{isa}",
+    " ".join(cmd),
+  ]
+
+# Create bash scripts that can fully execute the run tests.
+# This can be used in CI to execute the tests without running `testrunner.py`.
+# This takes into account any custom behaviour defined in per-test `run.py`.
+# We generate distinct scripts for all of the pre-defined variants.
+def create_ci_runner_scripts(out, mode, test_names):
+  out.mkdir(parents=True)
+  setup = out / "setup.sh"
+  setup_script = create_setup_script(False) + create_setup_script(True)
+  setup.write_text("\n".join(setup_script))
+
+  python = sys.executable
+  script = 'art/test/testrunner/testrunner.py'
+  envs = {
+    "ANDROID_BUILD_TOP": str(Path(getcwd()).absolute()),
+    "ART_TEST_RUN_FROM_SOONG": "true",
+    # TODO: Make the runner scripts target agnostic.
+    #       The only dependency is setting of "-Djava.library.path".
+    "TARGET_ARCH": "arm64",
+    "TARGET_2ND_ARCH": "arm",
+    "TMPDIR": Path(getcwd()) / "tmp",
+  }
+  args = [
+    f"--run-test-option=--create-runner={out}",
+    f"-j={cpu_count()}",
+    f"--{mode}",
+  ]
+  run([python, script] + args + test_names, env=envs, check=True)
+  tests = {
+    "setup": {
+      "adb push": [[str(setup.relative_to(out)), "/data/local/tmp/art/setup.sh"]],
+      "adb shell": [["sh", "/data/local/tmp/art/setup.sh"]],
+    },
+  }
+  for runner in Path(out).glob("*/*.sh"):
+    test_name = runner.parent.name
+    test_hash = runner.stem
+    target_dir = f"/data/local/tmp/art/test/{test_hash}"
+    tests[f"{test_name}-{test_hash}"] = {
+      "dependencies": ["setup"],
+      "adb push": [
+        [f"../{mode}/{test_name}/", f"{target_dir}/"],
+        [str(runner.relative_to(out)), f"{target_dir}/run.sh"]
+      ],
+      "adb shell": [["sh", f"{target_dir}/run.sh"]],
+    }
+  return tests
 
 # If we build just individual shard, we want to split the work among all the cores,
 # but if the build system builds all shards, we don't want to overload the machine.
@@ -550,11 +626,7 @@ def main() -> None:
   android_build_top = Path(getcwd()).absolute()
   ziproot = args.out.absolute().parent / "zip"
   test_dir_regex = re.compile(args.test_dir_regex) if args.test_dir_regex else re.compile(".*")
-  srcdirs = set(
-    s.parents[-4].absolute()
-    for s in args.srcs
-    if test_dir_regex.search(str(s))
-  )
+  srcdirs = set(s.parents[-4].absolute() for s in args.srcs if test_dir_regex.search(str(s)))
 
   # Special hidden-api shard: If the --hiddenapi flag is provided, build only
   # hiddenapi tests. Otherwise exclude all hiddenapi tests from normal shards.
@@ -575,19 +647,24 @@ def main() -> None:
     os.chdir(invalid_tmpdir)
     os.chmod(invalid_tmpdir, 0)
     with ThreadPoolExecutor(cpu_count() if use_multiprocessing(args.mode) else 1) as pool:
-      jobs = {}
-      for ctx in tests:
-        jobs[ctx.test_name] = pool.submit(ctx.build)
+      jobs = {ctx.test_name: pool.submit(ctx.build) for ctx in tests}
       for test_name, job in jobs.items():
         try:
           job.result()
         except Exception as e:
           raise Exception("Failed to build " + test_name) from e
 
-  # Create the final zip file which contains the content of the temporary directory.
-  proc = run([android_build_top / args.soong_zip, "-o", android_build_top / args.out,
-              "-C", ziproot, "-D", ziproot], check=True)
+  if args.mode == "target":
+    os.chdir(android_build_top)
+    test_names = [ctx.test_name for ctx in tests]
+    dst = ziproot / "runner" / args.out.with_suffix(".tests.json").name
+    tests = create_ci_runner_scripts(dst.parent, args.mode, test_names)
+    dst.write_text(json.dumps(tests, indent=2, sort_keys=True))
 
+  # Create the final zip file which contains the content of the temporary directory.
+  soong_zip = android_build_top / args.soong_zip
+  zip_file = android_build_top / args.out
+  run([soong_zip, "-L", "0", "-o", zip_file, "-C", ziproot, "-D", ziproot], check=True)
 
 if __name__ == "__main__":
   main()
diff --git a/test/testrunner/env.py b/test/testrunner/env.py
index de24b4cde6..3aa27938f3 100644
--- a/test/testrunner/env.py
+++ b/test/testrunner/env.py
@@ -17,17 +17,21 @@ import re
 import tempfile
 import subprocess
 
-# begin import $ANDROID_BUILD_TOP/art/tools/build/var_cache.py
-_THIS_DIR = os.path.dirname(os.path.realpath(__file__))
-_TOP = os.path.join(_THIS_DIR, "../../..")
-_VAR_CACHE_DIR = os.path.join(_TOP, "art/tools/build/")
+_env = dict(os.environ)
 
-import sys
-sys.path.append(_VAR_CACHE_DIR)
-import var_cache  # type: ignore
-# end import var_cache.py
+# Check if we are running from the build system.
+ART_TEST_RUN_FROM_SOONG = os.environ.get("ART_TEST_RUN_FROM_SOONG")
 
-_env = dict(os.environ)
+if not ART_TEST_RUN_FROM_SOONG:
+  # begin import $ANDROID_BUILD_TOP/art/tools/build/var_cache.py
+  _THIS_DIR = os.path.dirname(os.path.realpath(__file__))
+  _TOP = os.path.join(_THIS_DIR, "../../..")
+  _VAR_CACHE_DIR = os.path.join(_TOP, "art/tools/build/")
+
+  import sys
+  sys.path.append(_VAR_CACHE_DIR)
+  import var_cache  # type: ignore
+  # end import var_cache.py
 
 def _getEnvBoolean(var, default):
   val = _env.get(var)
@@ -39,6 +43,8 @@ def _getEnvBoolean(var, default):
   return default
 
 def _get_build_var(var_name):
+  if ART_TEST_RUN_FROM_SOONG:
+    return _env.get(var_name)
   return var_cache.get_build_var(var_name)
 
 def _get_build_var_boolean(var, default):
@@ -62,15 +68,13 @@ def _get_android_build_top():
     path_to_top = os.path.realpath(path_to_top)
 
   if not os.path.exists(os.path.join(path_to_top, 'build/envsetup.sh')):
-    raise AssertionError("env.py must be located inside an android source tree")
+    if not ART_TEST_RUN_FROM_SOONG:
+      raise AssertionError("env.py must be located inside an android source tree")
 
   return path_to_top
 
 ANDROID_BUILD_TOP = _get_android_build_top()
 
-# Directory used for temporary test files on the host.
-ART_HOST_TEST_DIR = tempfile.mkdtemp(prefix = 'test-art-')
-
 # Directory used to store files build by the run-test script.
 ART_TEST_RUN_TEST_BUILD_PATH = _env.get('ART_TEST_RUN_TEST_BUILD_PATH')
 
@@ -129,18 +133,18 @@ else:
   ART_PHONY_TEST_HOST_SUFFIX = "64"
   ART_2ND_PHONY_TEST_HOST_SUFFIX = "32"
 
-HOST_OUT_EXECUTABLES = os.path.join(ANDROID_BUILD_TOP,
-                                    _get_build_var("HOST_OUT_EXECUTABLES"))
+if HOST_OUT_EXECUTABLES := _get_build_var("HOST_OUT_EXECUTABLES"):
+  HOST_OUT_EXECUTABLES = os.path.join(ANDROID_BUILD_TOP, HOST_OUT_EXECUTABLES)
 
-# Set up default values for $D8, $SMALI, etc to the $HOST_OUT_EXECUTABLES/$name path.
-for tool in ['smali', 'jasmin', 'd8']:
-  os.environ.setdefault(tool.upper(), HOST_OUT_EXECUTABLES + '/' + tool)
+  # Set up default values for $D8, $SMALI, etc to the $HOST_OUT_EXECUTABLES/$name path.
+  for tool in ['smali', 'jasmin', 'd8']:
+    os.environ.setdefault(tool.upper(), HOST_OUT_EXECUTABLES + '/' + tool)
 
-ANDROID_JAVA_TOOLCHAIN = os.path.join(ANDROID_BUILD_TOP,
-                                     _get_build_var('ANDROID_JAVA_TOOLCHAIN'))
+if ANDROID_JAVA_TOOLCHAIN := _get_build_var('ANDROID_JAVA_TOOLCHAIN'):
+  ANDROID_JAVA_TOOLCHAIN = os.path.join(ANDROID_BUILD_TOP, ANDROID_JAVA_TOOLCHAIN)
 
-# include platform prebuilt java, javac, etc in $PATH.
-os.environ['PATH'] = ANDROID_JAVA_TOOLCHAIN + ':' + os.environ['PATH']
+  # include platform prebuilt java, javac, etc in $PATH.
+  os.environ['PATH'] = ANDROID_JAVA_TOOLCHAIN + ':' + os.environ['PATH']
 
 DIST_DIR = _get_build_var('DIST_DIR')
 SOONG_OUT_DIR = _get_build_var('SOONG_OUT_DIR')
diff --git a/test/testrunner/testrunner.py b/test/testrunner/testrunner.py
index c92f18369b..5892345067 100755
--- a/test/testrunner/testrunner.py
+++ b/test/testrunner/testrunner.py
@@ -82,6 +82,7 @@ from target_config import target_config
 from device_config import device_config
 from typing import Dict, Set, List
 from functools import lru_cache
+from pathlib import Path
 
 # TODO: make it adjustable per tests and for buildbots
 #
@@ -351,6 +352,8 @@ def get_device_name():
   """
   Gets the value of ro.product.name from remote device (unless running on a VM).
   """
+  if env.ART_TEST_RUN_FROM_SOONG:
+    return "target"  # We can't use adb during build.
   if env.ART_TEST_ON_VM:
     return subprocess.Popen(f"{env.ART_SSH_CMD} uname -a".split(),
                             stdout = subprocess.PIPE,
@@ -568,13 +571,11 @@ def run_tests(tests):
       if address_size == '64':
         args_test += ['--64']
 
-      # b/36039166: Note that the path lengths must kept reasonably short.
-      temp_path = tempfile.mkdtemp(dir=env.ART_HOST_TEST_DIR)
-      args_test = ['--temp-path', temp_path] + args_test
-
       # Run the run-test script using the prebuilt python.
       python3_bin = env.ANDROID_BUILD_TOP + "/prebuilts/build-tools/path/linux-x86/python3"
-      run_test_sh = env.ANDROID_BUILD_TOP + '/art/test/run-test'
+      run_test_sh = str(Path(__file__).parent.parent / 'run-test')
+      if not os.path.exists(python3_bin):
+        python3_bin = sys.executable  # Fallback to current python if we are in a sandbox.
       args_test = [python3_bin, run_test_sh] + args_test + extra_arguments[target] + [test]
       return executor.submit(run_test, args_test, test, variant_set, test_name)
 
@@ -819,7 +820,7 @@ def get_disabled_test_info(device_name):
     The method returns a dict of tests mapped to the variants list
     for which the test should not be run.
   """
-  known_failures_file = env.ANDROID_BUILD_TOP + '/art/test/knownfailures.json'
+  known_failures_file = Path(__file__).parent.parent / 'knownfailures.json'
   with open(known_failures_file) as known_failures_json:
     known_failures_info = json.loads(known_failures_json.read())
 
@@ -853,6 +854,8 @@ def get_disabled_test_info(device_name):
     if check_env_vars(env_vars):
       for test in tests:
         if test not in RUN_TEST_SET:
+          if env.ART_TEST_RUN_FROM_SOONG:
+            continue  # Soong can see only sub-set of the tests within the shard.
           raise ValueError('%s is not a valid run-test' % (
               test))
         if test in disabled_test_info:
@@ -935,7 +938,9 @@ def parse_variants(variants):
     variant_list.add(frozenset(variant))
   return variant_list
 
-def print_text(output):
+def print_text(output, error=False):
+  if env.ART_TEST_RUN_FROM_SOONG and not error:
+    return  # Be quiet during build.
   sys.stdout.write(output)
   sys.stdout.flush()
 
@@ -966,9 +971,9 @@ def print_analysis():
 
   # Prints the list of failed tests, if any.
   if failed_tests:
-    print_text(COLOR_ERROR + 'FAILED: ' + COLOR_NORMAL + '\n')
+    print_text(COLOR_ERROR + 'FAILED: ' + COLOR_NORMAL + '\n', error=True)
     for test_info in failed_tests:
-      print_text(('%s\n%s\n' % (test_info[0], test_info[1])))
+      print_text(('%s\n%s\n' % (test_info[0], test_info[1])), error=True)
     print_text(COLOR_ERROR + '----------' + COLOR_NORMAL + '\n')
     for failed_test in sorted([test_info[0] for test_info in failed_tests]):
       print_text(('%s\n' % (failed_test)))
diff --git a/test/ti-agent/exceptions_helper.cc b/test/ti-agent/exceptions_helper.cc
index 6095c2eeb6..6b6bb08b66 100644
--- a/test/ti-agent/exceptions_helper.cc
+++ b/test/ti-agent/exceptions_helper.cc
@@ -157,6 +157,36 @@ extern "C" JNIEXPORT void JNICALL Java_art_Exceptions_setupExceptionTracing(
   }
 }
 
+extern "C" JNIEXPORT void JNICALL Java_art_Exceptions_disableExceptionTracing(
+    JNIEnv* env, [[maybe_unused]] jclass klass, jthread thr) {
+  ExceptionsData* data = nullptr;
+  if (JvmtiErrorToException(
+          env, jvmti_env, jvmti_env->GetEnvironmentLocalStorage(reinterpret_cast<void**>(&data)))) {
+    return;
+  }
+
+  if (data == nullptr) {
+    return;
+  }
+
+  // Disable Exception and Exception catch events.
+  JvmtiErrorToException(
+      env,
+      jvmti_env,
+      jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, thr));
+  JvmtiErrorToException(
+      env,
+      jvmti_env,
+      jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION_CATCH, thr));
+
+  env->DeleteGlobalRef(data->test_klass);
+  env->DeleteGlobalRef(data->exception_klass);
+
+  if (JvmtiErrorToException(env, jvmti_env, jvmti_env->SetEnvironmentLocalStorage(nullptr))) {
+    return;
+  }
+}
+
 extern "C" JNIEXPORT void JNICALL Java_art_Exceptions_enableExceptionCatchEvent(
     JNIEnv* env, [[maybe_unused]] jclass klass, jthread thr) {
   JvmtiErrorToException(env,
diff --git a/test/update-rollback/Android.bp b/test/update-rollback/Android.bp
index 8bba8cfd24..e22865c1fb 100644
--- a/test/update-rollback/Android.bp
+++ b/test/update-rollback/Android.bp
@@ -21,7 +21,7 @@ java_test_host {
     srcs: ["src/**/*.java"],
     libs: ["tradefed"],
     static_libs: ["cts-install-lib-host"],
-    data: [":test_broken_com.android.art"],
+    device_common_data: [":test_broken_com.android.art"],
     // Add this test to `device-tests` rather than `general-tests` to ensure
     // that the type of ART APEX -- public (`com.android.art`) or internal
     // (`com.google.android.art`) -- used in the test matches the one bundled
diff --git a/test/utils/regen-test-files b/test/utils/regen-test-files
index c91bfbf18a..c7c32c401a 100755
--- a/test/utils/regen-test-files
+++ b/test/utils/regen-test-files
@@ -238,7 +238,6 @@ known_failing_tests = frozenset([
 # removing them from this set (in order to promote them to
 # presubmits).
 postsubmit_only_tests = frozenset([
-    "057-math-intrinsics",
 ])
 
 known_failing_on_hwasan_tests = frozenset([
@@ -268,6 +267,7 @@ art_gtest_user_module_names = [
     "art_standalone_odrefresh_tests",
     "art_standalone_runtime_tests",
     "art_standalone_sigchain_tests",
+    "libnativebridge-lazy-tests",
     "libnativebridge-tests",
     "libnativeloader_test",
 ]
@@ -288,7 +288,6 @@ art_gtest_module_names = sorted(art_gtest_user_module_names + art_gtest_eng_only
 # removing them from this set (in order to promote them to
 # presubmits).
 art_gtest_postsubmit_only_module_names = [
-    "art_standalone_dex2oat_cts_tests",
 ]
 
 # ART gtests not supported in MTS.
@@ -503,9 +502,9 @@ class Generator:
       return True
     return False
 
-  # Is building `run_test` supported?
+  # Can `run_test` be built with Soong?
   # TODO(b/147814778): Add build support for more tests.
-  def is_buildable(self, run_test):
+  def is_soong_buildable(self, run_test):
     run_test_path = os.path.join(self.art_test_dir, run_test)
 
     # Skip tests with non-default build rules, unless these build
@@ -610,9 +609,9 @@ class Generator:
           srcs: ["{src_dir}/**/*.java"],{extra_props}
       }}"""
 
-  # Is (successfully) running `run_test` supported?
+  # Can `run_test` be succesfully run with TradeFed?
   # TODO(b/147812905): Add run-time support for more tests.
-  def is_runnable(self, run_test):
+  def is_tradefed_runnable(self, run_test):
     run_test_path = os.path.join(self.art_test_dir, run_test)
 
     # Skip tests with non-default run rules, unless these run rules
@@ -660,10 +659,14 @@ class Generator:
                     f"`test_suites` contains `{present}` but not `{absent}`")
       sys.exit(1)
 
+    # Do not package non-runnable ART run-tests in ART MTS (see b/363075236).
+    if self.is_tradefed_runnable(run_test):
+      test_suites.append("mts-art")
+
     run_test_module_name = ART_RUN_TEST_MODULE_NAME_PREFIX + run_test
 
     # Set the test configuration template.
-    if self.is_runnable(run_test):
+    if self.is_tradefed_runnable(run_test):
       if is_cts_test:
         test_config_template = "art-run-test-target-cts-template"
       elif self.is_slow(run_test):
@@ -1097,14 +1100,15 @@ class Generator:
 
     # Create a list of the tests that can currently be built, and for
     # which a Blueprint file is to be generated.
-    buildable_tests = list(filter(self.is_buildable, run_tests))
+    buildable_tests = list(filter(self.is_soong_buildable, run_tests))
 
     # Create a list of the tests that can be built and run
     # (successfully). These tests are to be added to ART's
     # `TEST_MAPPING` file and also tagged as part of TradeFed's
     # `art-target-run-test` test suite via the `test-suite-tag` option
     # in their configuration file.
-    expected_succeeding_tests = list(filter(self.is_runnable, buildable_tests))
+    expected_succeeding_tests = list(filter(self.is_tradefed_runnable,
+                                            buildable_tests))
 
     # Regenerate Blueprint files.
     # ---------------------------
@@ -1163,7 +1167,7 @@ class Generator:
         (num_mainline_presubmit_gtests, "ART gtests", mainline_presubmit_gtests_percentage,
          "mainline-presubmit"),
         (num_presubmit_gtests, "ART gtests", presubmit_gtests_percentage, "presubmit"),
-        (num_postsubmit_gtests, "ART gtests", postsubmit_gtests_percentage, "presubmit"),
+        (num_postsubmit_gtests, "ART gtests", postsubmit_gtests_percentage, "postsubmit"),
     ]:
       print(
           f"  {num_tests:3d} {test_kind} ({tests_percentage}%) in `{test_group_name}` test group.")
diff --git a/tools/ahat/src/main/com/android/ahat/heapdump/AhatArrayInstance.java b/tools/ahat/src/main/com/android/ahat/heapdump/AhatArrayInstance.java
index 6c215ae808..dbf4c7e70e 100644
--- a/tools/ahat/src/main/com/android/ahat/heapdump/AhatArrayInstance.java
+++ b/tools/ahat/src/main/com/android/ahat/heapdump/AhatArrayInstance.java
@@ -267,27 +267,61 @@ public class AhatArrayInstance extends AhatInstance {
     return asString(0, getLength(), maxChars);
   }
 
+  /**
+   * Tests whether a byte looks like an ascii character.
+   */
+  private static boolean looksLikeAscii(byte b) {
+    return b == '\n' || b == '\t' || (b >= ' ' && b <= '~');
+  }
+
   /**
    * Returns the String value associated with this array.
-   * Only char arrays are considered as having an associated String value.
    */
   String asString(int offset, int count, int maxChars) {
-    if (mCharArray == null) {
-      return null;
-    }
-
-    if (count == 0) {
-      return "";
-    }
-    int numChars = mCharArray.length;
     if (0 <= maxChars && maxChars < count) {
       count = maxChars;
     }
 
-    int end = offset + count - 1;
-    if (offset >= 0 && offset < numChars && end >= 0 && end < numChars) {
-      return new String(mCharArray, offset, count);
+    if (mCharArray != null) {
+      // Always treat char arrays as strings.
+      if (count == 0) {
+        return "";
+      }
+
+      int numChars = mCharArray.length;
+      int end = offset + count - 1;
+      if (offset >= 0 && offset < numChars && end >= 0 && end < numChars) {
+        return new String(mCharArray, offset, count);
+      }
+
+      return null;
+    }
+
+    if (mByteArray != null) {
+      // Treat byte arrays as strings if they look like a sequence of ascii
+      // characters.
+      int end = offset + count - 1;
+      if (offset < 0 || offset >= mByteArray.length || end < 0 || end >= mByteArray.length) {
+        return null;
+      }
+
+      for (int i = offset; i < end; ++i) {
+        if (mByteArray[i] == '\0') {
+          count = i - offset;
+          break;
+        }
+
+        if (!looksLikeAscii(mByteArray[i])) {
+          return null;
+        }
+      }
+
+      if (count <= 0) {
+        return null;
+      }
+      return asAsciiString(offset, count, maxChars);
     }
+
     return null;
   }
 
diff --git a/tools/ahat/src/test-dump/DumpedStuff.java b/tools/ahat/src/test-dump/DumpedStuff.java
index f8d74dc27e..e1f97fa895 100644
--- a/tools/ahat/src/test-dump/DumpedStuff.java
+++ b/tools/ahat/src/test-dump/DumpedStuff.java
@@ -178,6 +178,9 @@ public class DumpedStuff extends SuperDumpedStuff {
   public String nonAscii = "Sigma () is not ASCII";
   public String embeddedZero = "embedded\0...";  // Non-ASCII for string compression purposes.
   public char[] charArray = "char thing".toCharArray();
+  public byte[] byteString = new byte[] {'h', 'i', '.', '\n', '\0', '\0', '\0'};
+  public byte[] byteNotString = new byte[] {0, 1, 2, 3, 4, 5};
+  public byte[] byteEmpty = new byte[] {};
   public String nullString = null;
   public Object anObject = new Object();
   public Object aCleanedObject = new Object();
diff --git a/tools/ahat/src/test/com/android/ahat/InstanceTest.java b/tools/ahat/src/test/com/android/ahat/InstanceTest.java
index e1eb504c1f..b3b970eb66 100644
--- a/tools/ahat/src/test/com/android/ahat/InstanceTest.java
+++ b/tools/ahat/src/test/com/android/ahat/InstanceTest.java
@@ -177,6 +177,30 @@ public class InstanceTest {
     assertEquals("char thing", str.asString(-3));
   }
 
+  @Test
+  public void asStringByteArray() throws IOException {
+    TestDump dump = TestDump.getTestDump();
+    AhatInstance obj = dump.getDumpedAhatInstance("byteString");
+    assertNotNull(obj);
+    assertEquals("hi.\n", obj.asString());
+  }
+
+  @Test
+  public void asStringByteArrayNotString() throws IOException {
+    TestDump dump = TestDump.getTestDump();
+    AhatInstance obj = dump.getDumpedAhatInstance("byteNotString");
+    assertNotNull(obj);
+    assertNull(obj.asString());
+  }
+
+  @Test
+  public void asStringByteArrayNotString2() throws IOException {
+    TestDump dump = TestDump.getTestDump();
+    AhatInstance obj = dump.getDumpedAhatInstance("byteEmpty");
+    assertNotNull(obj);
+    assertNull(obj.asString());
+  }
+
   @Test
   public void asStringNull() throws IOException {
     TestDump dump = TestDump.getTestDump();
diff --git a/tools/art_verifier/art_verifier.cc b/tools/art_verifier/art_verifier.cc
index f5d957683a..66cb326dbb 100644
--- a/tools/art_verifier/art_verifier.cc
+++ b/tools/art_verifier/art_verifier.cc
@@ -234,11 +234,11 @@ struct MethodVerifierMain : public CmdlineMain<MethodVerifierArgs> {
       }
       for (const DexFile* dex_file : dex_files) {
         for (ClassAccessor accessor : dex_file->GetClasses()) {
-          const char* descriptor = accessor.GetDescriptor();
-          h_klass.Assign(class_linker->FindClass(soa.Self(), descriptor, h_loader));
+          h_klass.Assign(
+              class_linker->FindClass(soa.Self(), *dex_file, accessor.GetClassIdx(), h_loader));
           if (h_klass == nullptr || h_klass->IsErroneous()) {
             if (args_->repetitions_ == 0) {
-              LOG(ERROR) << "Warning: could not load " << descriptor;
+              LOG(ERROR) << "Warning: could not load " << accessor.GetDescriptor();
             }
             soa.Self()->ClearException();
             continue;
@@ -258,7 +258,7 @@ struct MethodVerifierMain : public CmdlineMain<MethodVerifierArgs> {
                                                  args_->api_level_,
                                                  &error_msg);
           if (args_->repetitions_ == 0) {
-            LOG(INFO) << descriptor << ": " << res << " " << error_msg;
+            LOG(INFO) << accessor.GetDescriptor() << ": " << res << " " << error_msg;
           }
         }
       }
diff --git a/tools/buildbot-build.sh b/tools/buildbot-build.sh
index bdd311d6af..03751dc13e 100755
--- a/tools/buildbot-build.sh
+++ b/tools/buildbot-build.sh
@@ -61,7 +61,7 @@ if [[ $TARGET_ARCH = "riscv64" && ! ( -d frameworks/base ) ]]; then
 fi
 
 java_libraries_dir=${out_dir}/target/common/obj/JAVA_LIBRARIES
-common_targets="vogar core-tests core-ojtests apache-harmony-jdwp-tests-hostdex jsr166-tests mockito-target desugar"
+common_targets="vogar core-tests core-ojtests apache-harmony-jdwp-tests-hostdex jsr166-tests mockito-target"
 # These build targets have different names on device and host.
 specific_targets="libjavacoretests libwrapagentproperties libwrapagentpropertiesd"
 build_host="no"
diff --git a/tools/buildbot-setup-device.sh b/tools/buildbot-setup-device.sh
index 1df5d4f85b..9bff48b804 100755
--- a/tools/buildbot-setup-device.sh
+++ b/tools/buildbot-setup-device.sh
@@ -35,6 +35,7 @@ if [[ -n "$ART_TEST_ON_VM" ]]; then
     mkdir $ART_TEST_CHROOT/apex
     mkdir $ART_TEST_CHROOT/bin
     mkdir -p $ART_TEST_CHROOT/data/local/tmp
+    mkdir -p $ART_TEST_CHROOT/data/misc/trace
     mkdir $ART_TEST_CHROOT/dev
     mkdir $ART_TEST_CHROOT/etc
     mkdir $ART_TEST_CHROOT/lib
diff --git a/tools/buildbot-symbolize-crashes.sh b/tools/buildbot-symbolize-crashes.sh
index c12567c8e8..0200346fa0 100755
--- a/tools/buildbot-symbolize-crashes.sh
+++ b/tools/buildbot-symbolize-crashes.sh
@@ -17,13 +17,11 @@
 # We push art and its dependencies to '/data/local/tmp', but the 'stack'
 # script expect things to be in '/'. So we just remove the
 # '/data/local/tmp' prefix.
-
-# TODO(solanes, b/338199464): Reactivate this
-# if [[ -n "$1" ]]; then
-#   cat $1
-# else
-#   adb logcat -d
-# fi | sed 's,/data/local/tmp,,g' | development/scripts/stack
+if [[ -n "$1" ]]; then
+  cat $1
+else
+  adb logcat -d
+fi | sed 's,/data/local/tmp,,g' | development/scripts/stack
 
 # Always return 0 to avoid having the buildbot complain about wrong stacks.
 exit 0
diff --git a/tools/buildbot-vm.sh b/tools/buildbot-vm.sh
index a801b589ea..720b06f749 100755
--- a/tools/buildbot-vm.sh
+++ b/tools/buildbot-vm.sh
@@ -37,8 +37,6 @@ get_stable_binary() {
     cd .. && rm -rf tmp
 }
 
-qemu_path="$ANDROID_BUILD_TOP/device/google/cuttlefish_vmm/qemu/x86_64-linux-gnu/bin"
-
 if [[ $action = create ]]; then
 (
     rm -rf "$ART_TEST_VM_DIR"
@@ -53,18 +51,13 @@ if [[ $action = create ]]; then
     if [[ "$TARGET_ARCH" = "riscv64" ]]; then
         # Get U-Boot for Ubuntu 22.04 (Jammy)
         get_stable_binary \
-            u/u-boot/u-boot-qemu_2023.07+dfsg-1ubuntu2_all.deb \
+            u/u-boot/u-boot-qemu_2024.01+dfsg-5ubuntu2_all.deb \
             usr/lib/u-boot/qemu-riscv64_smode/uboot.elf
 
-        # Get OpenSBI for Ubuntu 22.04 (Jammy)
-        get_stable_binary \
-            o/opensbi/opensbi_1.3-1ubuntu0.23.04.2_all.deb \
-            usr/lib/riscv64-linux-gnu/opensbi/generic/fw_jump.elf
-
     elif [[ "$TARGET_ARCH" = "arm64" ]]; then
         # Get EFI (ARM64)
         get_stable_binary \
-            e/edk2/qemu-efi-aarch64_2023.05-2ubuntu0.1_all.deb \
+            e/edk2/qemu-efi-aarch64_2024.05-2ubuntu0.1_all.deb \
             usr/share/qemu-efi-aarch64/QEMU_EFI.fd
 
         dd if=/dev/zero of=flash0.img bs=1M count=64
@@ -106,13 +99,12 @@ elif [[ $action = boot ]]; then
     cp "$(dirname $0)/user-data.img" "$ART_TEST_VM_DIR/user-data.img"
     cd "$ART_TEST_VM_DIR"
     if [[ "$TARGET_ARCH" = "riscv64" ]]; then
-        ("$qemu_path/qemu-system-riscv64" \
+        ($ANDROID_BUILD_TOP/device/google/cuttlefish_vmm/qemu/x86_64-linux-gnu/bin/qemu-system-riscv64 \
             -M virt \
             -nographic \
             -m 16G \
             -smp 8 \
             -cpu rv64,v=true,elen=64,vlen=128,zba=true,zbb=true,zbs=true \
-            -bios fw_jump.elf \
             -kernel uboot.elf \
             -drive file="$ART_TEST_VM_IMG",if=virtio \
             -drive file=user-data.img,format=raw,if=virtio \
@@ -134,7 +126,7 @@ elif [[ $action = boot ]]; then
         done < <(tail -f $SCRIPT_DIR/boot.out)
 
     elif [[ "$TARGET_ARCH" = "arm64" ]]; then
-        ("$qemu_path/qemu-system-aarch64" \
+        (qemu-system-aarch64 \
             -m 16G \
             -smp 8 \
             -cpu cortex-a710,sve=on \
diff --git a/tools/cpp-define-generator/art_method.def b/tools/cpp-define-generator/art_method.def
index d5ba59998d..3c34247ec2 100644
--- a/tools/cpp-define-generator/art_method.def
+++ b/tools/cpp-define-generator/art_method.def
@@ -21,6 +21,10 @@
 
 ASM_DEFINE(ART_METHOD_ACCESS_FLAGS_OFFSET,
            art::ArtMethod::AccessFlagsOffset().Int32Value())
+ASM_DEFINE(ART_METHOD_IS_INTRINSIC_FLAG,
+           art::kAccIntrinsic)
+ASM_DEFINE(ART_METHOD_IS_INTRINSIC_FLAG_BIT,
+           art::MostSignificantBit(art::kAccIntrinsic))
 ASM_DEFINE(ART_METHOD_IS_MEMORY_SHARED_FLAG,
            art::kAccMemorySharedMethod)
 ASM_DEFINE(ART_METHOD_IS_MEMORY_SHARED_FLAG_BIT,
diff --git a/tools/cpp-define-generator/globals.def b/tools/cpp-define-generator/globals.def
index afa9499687..7f76b050a0 100644
--- a/tools/cpp-define-generator/globals.def
+++ b/tools/cpp-define-generator/globals.def
@@ -82,7 +82,7 @@ ASM_DEFINE(STACK_REFERENCE_SIZE,
 ASM_DEFINE(STD_MEMORY_ORDER_RELAXED,
            static_cast<std::underlying_type_t<std::memory_order>>(std::memory_order_relaxed))
 ASM_DEFINE(STACK_OVERFLOW_RESERVED_BYTES,
-           GetStackOverflowReservedBytes(art::kRuntimeISA))
+           GetStackOverflowReservedBytes(art::kRuntimeQuickCodeISA))
 ASM_DEFINE(CALLEE_SAVE_EVERYTHING_NUM_CORE_SPILLS,
            art::POPCOUNT(art::RuntimeCalleeSaveFrame::GetCoreSpills(
                art::CalleeSaveType::kSaveEverything)))
diff --git a/tools/cpp-define-generator/shadow_frame.def b/tools/cpp-define-generator/shadow_frame.def
index 10a309cbdb..f7e8243fca 100644
--- a/tools/cpp-define-generator/shadow_frame.def
+++ b/tools/cpp-define-generator/shadow_frame.def
@@ -36,7 +36,5 @@ ASM_DEFINE(SHADOWFRAME_METHOD_OFFSET,
            art::ShadowFrame::MethodOffset())
 ASM_DEFINE(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET,
            art::ShadowFrame::NumberOfVRegsOffset())
-ASM_DEFINE(SHADOWFRAME_RESULT_REGISTER_OFFSET,
-           art::ShadowFrame::ResultRegisterOffset())
 ASM_DEFINE(SHADOWFRAME_VREGS_OFFSET,
            art::ShadowFrame::VRegsOffset())
diff --git a/tools/dexanalyze/Android.bp b/tools/dexanalyze/Android.bp
index 5b875594cf..4affca100d 100644
--- a/tools/dexanalyze/Android.bp
+++ b/tools/dexanalyze/Android.bp
@@ -42,7 +42,7 @@ art_cc_binary {
     name: "dexanalyze",
     defaults: ["dexanalyze-defaults"],
     shared_libs: [
-        "libdexfile",
+        "libdexfile#impl",
         "libartbase",
         "libbase",
     ],
@@ -58,7 +58,7 @@ art_cc_test {
     defaults: [
         "art_gtest_defaults",
     ],
-    data: [
+    device_common_data: [
         ":art-gtest-jars-MultiDex",
     ],
     srcs: [
diff --git a/tools/external_oj_libjdwp_art_failures.txt b/tools/external_oj_libjdwp_art_failures.txt
index 5783d92e60..77be98d6f3 100644
--- a/tools/external_oj_libjdwp_art_failures.txt
+++ b/tools/external_oj_libjdwp_art_failures.txt
@@ -54,5 +54,16 @@
   bug: 70459916,
   names: [ "org.apache.harmony.jpda.tests.jdwp.VMDebug_VMDebugTest#testVMDebug",
            "org.apache.harmony.jpda.tests.jdwp.VMDebug_VMDebugTest002#testVMDebug" ]
+},
+{
+  description: "Test fails because after a throw we don't stop at the right pc
+  in the catch block. If we fix this, then the behaviour of single stepping when
+  enabled from exception catch handlers breaks. We just match the behaviour of
+  openjdk here. These tests fail on RI as well.",
+  result: EXEC_FAILED,
+  bug: 333446719,
+  names: [ "org.apache.harmony.jpda.tests.jdwp.Events_EventWithExceptionTest#testSingleStepOut",
+           "org.apache.harmony.jpda.tests.jdwp.Events_SingleStepWithPendingExceptionTest#testSingleStepWithPendingException" ]
 }
+
 ]
diff --git a/tools/fuzzer/Android.bp b/tools/fuzzer/Android.bp
index d2a4e25f09..45c4c4aad0 100644
--- a/tools/fuzzer/Android.bp
+++ b/tools/fuzzer/Android.bp
@@ -78,7 +78,7 @@ cc_defaults {
         },
     },
 
-    data: [
+    device_common_data: [
         ":core-oj",
         ":core-libart",
         ":okhttp",
@@ -96,7 +96,7 @@ cc_fuzz {
         "libart_static_defaults",
     ],
     // Can not be in defaults due to soong limitations.
-    corpus: [
+    device_common_corpus: [
         ":art_runtest_corpus",
         "dex-verifier-corpus/*",
     ],
@@ -109,7 +109,7 @@ cc_fuzz {
         "libartd_static_defaults",
     ],
     // Can not be in defaults due to soong limitations.
-    corpus: [
+    device_common_corpus: [
         ":art_runtest_corpus",
         "dex-verifier-corpus/*",
     ],
@@ -123,7 +123,7 @@ cc_fuzz {
         "libart_static_defaults",
     ],
     // Can not be in defaults due to soong limitations.
-    corpus: [
+    device_common_corpus: [
         ":art_runtest_corpus",
         "class-verifier-corpus/*",
     ],
@@ -134,7 +134,7 @@ cc_fuzz {
 // If test is modified or removed, remove the corresponding dex entry.
 // It is not strictly necessary to add new entries for new tests.
 // TODO(b/171429704): Remove this genrule and use the zip directly.
-genrule {
+java_genrule {
     name: "art_runtest_corpus",
     tool_files: ["create_corpus.py"],
     cmd: "$(location) $(genDir) $(in)",
diff --git a/tools/fuzzer/libart_verify_classes_fuzzer.cc b/tools/fuzzer/libart_verify_classes_fuzzer.cc
index d066ef4b6e..13abd7c613 100644
--- a/tools/fuzzer/libart_verify_classes_fuzzer.cc
+++ b/tools/fuzzer/libart_verify_classes_fuzzer.cc
@@ -186,8 +186,8 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
         scope.NewHandle<art::mirror::DexCache>(nullptr));
 
     for (art::ClassAccessor accessor : dex_file.GetClasses()) {
-      const char* descriptor = accessor.GetDescriptor();
-      h_klass.Assign(class_linker->FindClass(soa.Self(), descriptor, h_loader));
+      h_klass.Assign(
+          class_linker->FindClass(soa.Self(), dex_file, accessor.GetClassIdx(), h_loader));
       // Ignore classes that couldn't be loaded since we are looking for crashes during
       // class/method verification.
       if (h_klass == nullptr || h_klass->IsErroneous()) {
diff --git a/tools/hiddenapi/Android.bp b/tools/hiddenapi/Android.bp
index 506197ce46..906e282df4 100644
--- a/tools/hiddenapi/Android.bp
+++ b/tools/hiddenapi/Android.bp
@@ -80,7 +80,7 @@ art_cc_test {
     defaults: [
         "art_gtest_defaults",
     ],
-    data: [
+    device_common_data: [
         ":art-gtest-jars-HiddenApi",
         ":art-gtest-jars-HiddenApiStubs",
     ],
diff --git a/tools/luci/config/generated/cr-buildbucket.cfg b/tools/luci/config/generated/cr-buildbucket.cfg
index 722a36e1ef..7ff98559f9 100644
--- a/tools/luci/config/generated/cr-buildbucket.cfg
+++ b/tools/luci/config/generated/cr-buildbucket.cfg
@@ -15,10 +15,10 @@ buckets {
   }
   swarming {
     builders {
-      name: "angler-armv7-debug"
+      name: "host.x86.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -28,71 +28,8 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"angler-armv7\""
-        properties_j: "generational_cc:true"
-        properties_j: "product:\"arm_krait\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "angler-armv7-ndebug"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"angler-armv7\""
         properties_j: "generational_cc:true"
-        properties_j: "product:\"arm_krait\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "angler-armv7-non-gen-cc"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:A"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "debug:true"
-        properties_j: "device:\"angler-armv7\""
-        properties_j: "product:\"arm_krait\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -108,10 +45,10 @@ buckets {
       }
     }
     builders {
-      name: "angler-armv8-debug"
+      name: "host.x86.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -121,71 +58,8 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"angler-armv8\""
         properties_j: "generational_cc:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "angler-armv8-ndebug"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"angler-armv8\""
-        properties_j: "generational_cc:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "angler-armv8-non-gen-cc"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:A"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "debug:true"
-        properties_j: "device:\"angler-armv8\""
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -201,10 +75,10 @@ buckets {
       }
     }
     builders {
-      name: "bullhead-armv7-gcstress-ndebug"
+      name: "host.x86.cmc.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -212,45 +86,9 @@ buckets {
         cipd_version: "refs/heads/main"
         properties_j: "bitness:32"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"bullhead-armv7\""
-        properties_j: "gcstress:true"
-        properties_j: "generational_cc:true"
-        properties_j: "product:\"arm_krait\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\",\"--gcstress\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "bullhead-armv8-gcstress-debug"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"bullhead-armv8\""
-        properties_j: "gcstress:true"
         properties_j: "generational_cc:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\",\"--gcstress\"]"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -266,10 +104,10 @@ buckets {
       }
     }
     builders {
-      name: "bullhead-armv8-gcstress-ndebug"
+      name: "host.x86.cmc.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -277,38 +115,8 @@ buckets {
         cipd_version: "refs/heads/main"
         properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"bullhead-armv8\""
-        properties_j: "gcstress:true"
-        properties_j: "generational_cc:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\",\"--gcstress\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "host-x86-cms"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
-        properties_j: "builder_group:\"client.art\""
         properties_j: "debug:true"
+        properties_j: "generational_cc:true"
         properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
@@ -325,9 +133,10 @@ buckets {
       }
     }
     builders {
-      name: "host-x86-debug"
+      name: "host.x86.gsctress.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -337,8 +146,9 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
+        properties_j: "gcstress:true"
         properties_j: "generational_cc:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\",\"--gcstress\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -354,15 +164,16 @@ buckets {
       }
     }
     builders {
-      name: "host-x86-gcstress-debug"
+      name: "host.x86.gsctress.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
+        properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
@@ -384,9 +195,10 @@ buckets {
       }
     }
     builders {
-      name: "host-x86-ndebug"
+      name: "host.x86.ndebug.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -412,48 +224,20 @@ buckets {
       }
     }
     builders {
-      name: "host-x86-poison-debug"
+      name: "host.x86.ndebug.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
+        properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
-        properties_j: "debug:true"
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "host-x86_64-cms"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "debug:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -469,19 +253,18 @@ buckets {
       }
     }
     builders {
-      name: "host-x86_64-debug"
+      name: "host.x86.ngen-cmc.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
+        properties_j: "bitness:32"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "generational_cc:true"
         properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
@@ -498,37 +281,10 @@ buckets {
       }
     }
     builders {
-      name: "host-x86_64-ndebug"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "generational_cc:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
-    builders {
-      name: "host-x86_64-non-gen-cc"
+      name: "host.x86.ngen-cmc.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -536,7 +292,6 @@ buckets {
         cipd_version: "refs/heads/main"
         properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
         properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
@@ -554,15 +309,16 @@ buckets {
       }
     }
     builders {
-      name: "host-x86_64-poison-debug"
+      name: "host.x86.poison.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "os:Ubuntu-20"
+      dimensions: "cores:8"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
+        properties_j: "bitness:32"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
@@ -584,20 +340,21 @@ buckets {
       }
     }
     builders {
-      name: "host.x86.debug.32"
+      name: "host.x86.poison.64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
+        properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
         properties_j: "generational_cc:true"
+        properties_j: "heap_poisoning:true"
         properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
@@ -614,10 +371,10 @@ buckets {
       }
     }
     builders {
-      name: "host.x86.debug.64"
+      name: "qemu.arm.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "cores:16"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -627,8 +384,11 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
+        properties_j: "device:\"qemu.arm.64\""
         properties_j: "generational_cc:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+        properties_j: "on_virtual_machine:true"
+        properties_j: "product:\"armv8\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -639,44 +399,19 @@ buckets {
       build_numbers: YES
       service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
       experiments {
-        key: "luci.recipes.use_python3"
+        key: "art.superproject"
         value: 100
       }
-    }
-    builders {
-      name: "host.x86.ndebug.32"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:32"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "generational_cc:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
       experiments {
         key: "luci.recipes.use_python3"
         value: 100
       }
     }
     builders {
-      name: "host.x86.ndebug.64"
+      name: "qemu.riscv.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "cores:16"
+      dimensions: "os:Ubuntu"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -685,8 +420,12 @@ buckets {
         properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
+        properties_j: "debug:true"
+        properties_j: "device:\"qemu.riscv.64\""
         properties_j: "generational_cc:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--ndebug\"]"
+        properties_j: "on_virtual_machine:true"
+        properties_j: "product:\"riscv64\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -696,16 +435,20 @@ buckets {
       }
       build_numbers: YES
       service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
+      experiments {
+        key: "art.superproject"
+        value: 100
+      }
       experiments {
         key: "luci.recipes.use_python3"
         value: 100
       }
     }
     builders {
-      name: "host.x86.poison.debug.32"
+      name: "target.arm.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -715,9 +458,10 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
+        properties_j: "device:\"target.arm.32\""
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+        properties_j: "product:\"arm_krait\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -733,10 +477,10 @@ buckets {
       }
     }
     builders {
-      name: "host.x86.poison.debug.64"
+      name: "target.arm.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:8"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "device_os:S"
+      dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -746,9 +490,10 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
+        properties_j: "device:\"target.arm.64\""
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
-        properties_j: "testrunner_args:[\"--verbose\",\"--host\",\"--debug\"]"
+        properties_j: "product:\"armv8\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -764,23 +509,22 @@ buckets {
       }
     }
     builders {
-      name: "qemu-armv8-ndebug"
+      name: "target.arm.cmc.32"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:16"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "device_os:A"
+      dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
         cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
         cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
+        properties_j: "bitness:32"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"qemu-armv8\""
+        properties_j: "debug:true"
+        properties_j: "device:\"target.arm.cmc.32\""
         properties_j: "generational_cc:true"
-        properties_j: "on_virtual_machine:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
+        properties_j: "product:\"arm_krait\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -796,10 +540,10 @@ buckets {
       }
     }
     builders {
-      name: "qemu-riscv64-ndebug"
+      name: "target.arm.cmc.64"
       swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "cores:16"
-      dimensions: "os:Ubuntu-22"
+      dimensions: "device_os:A"
+      dimensions: "os:Android"
       dimensions: "pool:luci.art.ci"
       recipe {
         name: "art"
@@ -807,12 +551,11 @@ buckets {
         cipd_version: "refs/heads/main"
         properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"qemu-riscv64\""
+        properties_j: "debug:true"
+        properties_j: "device:\"target.arm.cmc.64\""
         properties_j: "generational_cc:true"
-        properties_j: "on_virtual_machine:true"
-        properties_j: "product:\"riscv64\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
+        properties_j: "product:\"armv8\""
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -828,7 +571,7 @@ buckets {
       }
     }
     builders {
-      name: "target.arm.poison.debug.32"
+      name: "target.arm.gsctress.32"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -841,11 +584,11 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"target.arm.poison.debug.32\""
+        properties_j: "device:\"target.arm.gsctress.32\""
+        properties_j: "gcstress:true"
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
         properties_j: "product:\"arm_krait\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\",\"--gcstress\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -861,7 +604,7 @@ buckets {
       }
     }
     builders {
-      name: "target.arm.poison.debug.64"
+      name: "target.arm.gsctress.64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -874,11 +617,11 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"target.arm.poison.debug.64\""
+        properties_j: "device:\"target.arm.gsctress.64\""
+        properties_j: "gcstress:true"
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
         properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\"]"
+        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--debug\",\"--gcstress\"]"
       }
       execution_timeout_secs: 108000
       expiration_secs: 61200
@@ -894,7 +637,7 @@ buckets {
       }
     }
     builders {
-      name: "target.arm.poison.ndebug.32"
+      name: "target.arm.ndebug.32"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -906,9 +649,8 @@ buckets {
         properties_j: "bitness:32"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
-        properties_j: "device:\"target.arm.poison.ndebug.32\""
+        properties_j: "device:\"target.arm.ndebug.32\""
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
         properties_j: "product:\"arm_krait\""
         properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
       }
@@ -926,7 +668,7 @@ buckets {
       }
     }
     builders {
-      name: "target.arm.poison.ndebug.64"
+      name: "target.arm.ndebug.64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -938,9 +680,8 @@ buckets {
         properties_j: "bitness:64"
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
-        properties_j: "device:\"target.arm.poison.ndebug.64\""
+        properties_j: "device:\"target.arm.ndebug.64\""
         properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
         properties_j: "product:\"armv8\""
         properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
       }
@@ -958,7 +699,7 @@ buckets {
       }
     }
     builders {
-      name: "walleye-armv7-poison-debug"
+      name: "target.arm.poison.32"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -971,7 +712,7 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"walleye-armv7\""
+        properties_j: "device:\"target.arm.poison.32\""
         properties_j: "generational_cc:true"
         properties_j: "heap_poisoning:true"
         properties_j: "product:\"arm_krait\""
@@ -991,7 +732,7 @@ buckets {
       }
     }
     builders {
-      name: "walleye-armv8-poison-debug"
+      name: "target.arm.poison.64"
       swarming_host: "chromium-swarm.appspot.com"
       dimensions: "device_os:S"
       dimensions: "os:Android"
@@ -1004,7 +745,7 @@ buckets {
         properties_j: "builder_group:\"client.art\""
         properties_j: "concurrent_collector:true"
         properties_j: "debug:true"
-        properties_j: "device:\"walleye-armv8\""
+        properties_j: "device:\"target.arm.poison.64\""
         properties_j: "generational_cc:true"
         properties_j: "heap_poisoning:true"
         properties_j: "product:\"armv8\""
@@ -1023,38 +764,6 @@ buckets {
         value: 100
       }
     }
-    builders {
-      name: "walleye-armv8-poison-ndebug"
-      swarming_host: "chromium-swarm.appspot.com"
-      dimensions: "device_os:S"
-      dimensions: "os:Android"
-      dimensions: "pool:luci.art.ci"
-      recipe {
-        name: "art"
-        cipd_package: "infra/recipe_bundles/chromium.googlesource.com/chromium/tools/build"
-        cipd_version: "refs/heads/main"
-        properties_j: "bitness:64"
-        properties_j: "builder_group:\"client.art\""
-        properties_j: "concurrent_collector:true"
-        properties_j: "device:\"walleye-armv8\""
-        properties_j: "generational_cc:true"
-        properties_j: "heap_poisoning:true"
-        properties_j: "product:\"armv8\""
-        properties_j: "testrunner_args:[\"--target\",\"--verbose\",\"--ndebug\"]"
-      }
-      execution_timeout_secs: 108000
-      expiration_secs: 61200
-      caches {
-        name: "art"
-        path: "art"
-      }
-      build_numbers: YES
-      service_account: "art-ci-builder@chops-service-accounts.iam.gserviceaccount.com"
-      experiments {
-        key: "luci.recipes.use_python3"
-        value: 100
-      }
-    }
   }
   shadow: "ci.shadow"
 }
diff --git a/tools/luci/config/generated/luci-milo.cfg b/tools/luci/config/generated/luci-milo.cfg
index a1a06892ff..46d170e40f 100644
--- a/tools/luci/config/generated/luci-milo.cfg
+++ b/tools/luci/config/generated/luci-milo.cfg
@@ -11,124 +11,124 @@ consoles {
   refs: "regexp:refs/heads/master"
   manifest_name: "REVISION"
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv7-debug"
-    category: "angler|armv7"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/target.arm.32"
+    category: "target.arm"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv7-non-gen-cc"
-    category: "angler|armv7"
-    short_name: "ngen"
+    name: "buildbucket/luci.art.ci/target.arm.64"
+    category: "target.arm"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv7-ndebug"
-    category: "angler|armv7"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/target.arm.ndebug.32"
+    category: "target.arm|ndebug"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv8-debug"
-    category: "angler|armv8"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/target.arm.cmc.32"
+    category: "target.arm|cmc"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv8-non-gen-cc"
-    category: "angler|armv8"
-    short_name: "ngen"
+    name: "buildbucket/luci.art.ci/target.arm.poison.32"
+    category: "target.arm|poison"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/angler-armv8-ndebug"
-    category: "angler|armv8"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/target.arm.gsctress.32"
+    category: "target.arm|gsctress"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/bullhead-armv7-gcstress-ndebug"
-    category: "bullhead|armv7|gcstress"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/target.arm.ndebug.64"
+    category: "target.arm|ndebug"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/bullhead-armv8-gcstress-debug"
-    category: "bullhead|armv8|gcstress"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/target.arm.cmc.64"
+    category: "target.arm|cmc"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/bullhead-armv8-gcstress-ndebug"
-    category: "bullhead|armv8|gcstress"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/target.arm.poison.64"
+    category: "target.arm|poison"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/walleye-armv7-poison-debug"
-    category: "walleye|armv7|poison"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/target.arm.gsctress.64"
+    category: "target.arm|gsctress"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/walleye-armv8-poison-debug"
-    category: "walleye|armv8|poison"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/host.x86.32"
+    category: "host.x86"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/walleye-armv8-poison-ndebug"
-    category: "walleye|armv8|poison"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/host.x86.64"
+    category: "host.x86"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86-cms"
-    category: "host|x86"
-    short_name: "cms"
+    name: "buildbucket/luci.art.ci/host.x86.ndebug.32"
+    category: "host.x86|ndebug"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86-debug"
-    category: "host|x86"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/host.x86.ngen-cmc.32"
+    category: "host.x86|ngen-cmc"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86-ndebug"
-    category: "host|x86"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/host.x86.cmc.32"
+    category: "host.x86|cmc"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86-gcstress-debug"
-    category: "host|x86"
-    short_name: "gcs"
+    name: "buildbucket/luci.art.ci/host.x86.poison.32"
+    category: "host.x86|poison"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86-poison-debug"
-    category: "host|x86"
-    short_name: "psn"
+    name: "buildbucket/luci.art.ci/host.x86.gsctress.32"
+    category: "host.x86|gsctress"
+    short_name: "32"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86_64-cms"
-    category: "host|x64"
-    short_name: "cms"
+    name: "buildbucket/luci.art.ci/host.x86.ndebug.64"
+    category: "host.x86|ndebug"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86_64-debug"
-    category: "host|x64"
-    short_name: "dbg"
+    name: "buildbucket/luci.art.ci/host.x86.ngen-cmc.64"
+    category: "host.x86|ngen-cmc"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86_64-non-gen-cc"
-    category: "host|x64"
-    short_name: "ngen"
+    name: "buildbucket/luci.art.ci/host.x86.cmc.64"
+    category: "host.x86|cmc"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86_64-ndebug"
-    category: "host|x64"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/host.x86.poison.64"
+    category: "host.x86|poison"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/host-x86_64-poison-debug"
-    category: "host|x64"
-    short_name: "psn"
+    name: "buildbucket/luci.art.ci/host.x86.gsctress.64"
+    category: "host.x86|gsctress"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/qemu-armv8-ndebug"
-    category: "qemu|armv8"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/qemu.arm.64"
+    category: "qemu|arm"
+    short_name: "64"
   }
   builders {
-    name: "buildbucket/luci.art.ci/qemu-riscv64-ndebug"
-    category: "qemu|riscv64"
-    short_name: "ndbg"
+    name: "buildbucket/luci.art.ci/qemu.riscv.64"
+    category: "qemu|riscv"
+    short_name: "64"
   }
   include_experimental_builds: true
 }
diff --git a/tools/luci/config/generated/luci-notify.cfg b/tools/luci/config/generated/luci-notify.cfg
index e99b2f4ae1..e070750f3f 100644
--- a/tools/luci/config/generated/luci-notify.cfg
+++ b/tools/luci/config/generated/luci-notify.cfg
@@ -14,7 +14,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv7-debug"
+    name: "host.x86.32"
   }
 }
 notifiers {
@@ -27,7 +27,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv7-ndebug"
+    name: "host.x86.64"
   }
 }
 notifiers {
@@ -40,7 +40,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv7-non-gen-cc"
+    name: "host.x86.cmc.32"
   }
 }
 notifiers {
@@ -53,7 +53,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv8-debug"
+    name: "host.x86.cmc.64"
   }
 }
 notifiers {
@@ -66,7 +66,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv8-ndebug"
+    name: "host.x86.gsctress.32"
   }
 }
 notifiers {
@@ -79,7 +79,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "angler-armv8-non-gen-cc"
+    name: "host.x86.gsctress.64"
   }
 }
 notifiers {
@@ -92,7 +92,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "bullhead-armv7-gcstress-ndebug"
+    name: "host.x86.ndebug.32"
   }
 }
 notifiers {
@@ -105,7 +105,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "bullhead-armv8-gcstress-debug"
+    name: "host.x86.ndebug.64"
   }
 }
 notifiers {
@@ -118,7 +118,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "bullhead-armv8-gcstress-ndebug"
+    name: "host.x86.ngen-cmc.32"
   }
 }
 notifiers {
@@ -131,7 +131,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86-cms"
+    name: "host.x86.ngen-cmc.64"
   }
 }
 notifiers {
@@ -144,7 +144,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86-debug"
+    name: "host.x86.poison.32"
   }
 }
 notifiers {
@@ -157,7 +157,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86-gcstress-debug"
+    name: "host.x86.poison.64"
   }
 }
 notifiers {
@@ -170,7 +170,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86-ndebug"
+    name: "qemu.arm.64"
   }
 }
 notifiers {
@@ -183,7 +183,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86-poison-debug"
+    name: "qemu.riscv.64"
   }
 }
 notifiers {
@@ -196,7 +196,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86_64-cms"
+    name: "target.arm.32"
   }
 }
 notifiers {
@@ -209,7 +209,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86_64-debug"
+    name: "target.arm.64"
   }
 }
 notifiers {
@@ -222,7 +222,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86_64-ndebug"
+    name: "target.arm.cmc.32"
   }
 }
 notifiers {
@@ -235,7 +235,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86_64-non-gen-cc"
+    name: "target.arm.cmc.64"
   }
 }
 notifiers {
@@ -248,7 +248,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "host-x86_64-poison-debug"
+    name: "target.arm.gsctress.32"
   }
 }
 notifiers {
@@ -261,7 +261,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "qemu-armv8-ndebug"
+    name: "target.arm.gsctress.64"
   }
 }
 notifiers {
@@ -274,7 +274,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "qemu-riscv64-ndebug"
+    name: "target.arm.ndebug.32"
   }
 }
 notifiers {
@@ -287,7 +287,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "walleye-armv7-poison-debug"
+    name: "target.arm.ndebug.64"
   }
 }
 notifiers {
@@ -300,7 +300,7 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "walleye-armv8-poison-debug"
+    name: "target.arm.poison.32"
   }
 }
 notifiers {
@@ -313,6 +313,6 @@ notifiers {
   }
   builders {
     bucket: "ci"
-    name: "walleye-armv8-poison-ndebug"
+    name: "target.arm.poison.64"
   }
 }
diff --git a/tools/luci/config/generated/luci-scheduler.cfg b/tools/luci/config/generated/luci-scheduler.cfg
index 7f4a6bab88..4bdd3ebd38 100644
--- a/tools/luci/config/generated/luci-scheduler.cfg
+++ b/tools/luci/config/generated/luci-scheduler.cfg
@@ -5,383 +5,273 @@
 #   https://config.luci.app/schemas/projects:luci-scheduler.cfg
 
 job {
-  id: "angler-armv7-debug"
+  id: "host.x86.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv7-debug"
+    builder: "host.x86.32"
   }
 }
 job {
-  id: "angler-armv7-ndebug"
+  id: "host.x86.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv7-ndebug"
+    builder: "host.x86.64"
   }
 }
 job {
-  id: "angler-armv7-non-gen-cc"
+  id: "host.x86.cmc.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv7-non-gen-cc"
+    builder: "host.x86.cmc.32"
   }
 }
 job {
-  id: "angler-armv8-debug"
+  id: "host.x86.cmc.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv8-debug"
+    builder: "host.x86.cmc.64"
   }
 }
 job {
-  id: "angler-armv8-ndebug"
+  id: "host.x86.gsctress.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv8-ndebug"
+    builder: "host.x86.gsctress.32"
   }
 }
 job {
-  id: "angler-armv8-non-gen-cc"
+  id: "host.x86.gsctress.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "angler-armv8-non-gen-cc"
+    builder: "host.x86.gsctress.64"
   }
 }
 job {
-  id: "bullhead-armv7-gcstress-ndebug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "bullhead-armv7-gcstress-ndebug"
-  }
-}
-job {
-  id: "bullhead-armv8-gcstress-debug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "bullhead-armv8-gcstress-debug"
-  }
-}
-job {
-  id: "bullhead-armv8-gcstress-ndebug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "bullhead-armv8-gcstress-ndebug"
-  }
-}
-job {
-  id: "host-x86-cms"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86-cms"
-  }
-}
-job {
-  id: "host-x86-debug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86-debug"
-  }
-}
-job {
-  id: "host-x86-gcstress-debug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86-gcstress-debug"
-  }
-}
-job {
-  id: "host-x86-ndebug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86-ndebug"
-  }
-}
-job {
-  id: "host-x86-poison-debug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86-poison-debug"
-  }
-}
-job {
-  id: "host-x86_64-cms"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86_64-cms"
-  }
-}
-job {
-  id: "host-x86_64-debug"
-  realm: "ci"
-  acl_sets: "ci"
-  buildbucket {
-    server: "cr-buildbucket.appspot.com"
-    bucket: "ci"
-    builder: "host-x86_64-debug"
-  }
-}
-job {
-  id: "host-x86_64-ndebug"
+  id: "host.x86.ndebug.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host-x86_64-ndebug"
+    builder: "host.x86.ndebug.32"
   }
 }
 job {
-  id: "host-x86_64-non-gen-cc"
+  id: "host.x86.ndebug.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host-x86_64-non-gen-cc"
+    builder: "host.x86.ndebug.64"
   }
 }
 job {
-  id: "host-x86_64-poison-debug"
+  id: "host.x86.ngen-cmc.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host-x86_64-poison-debug"
+    builder: "host.x86.ngen-cmc.32"
   }
 }
 job {
-  id: "host.x86.debug.32"
+  id: "host.x86.ngen-cmc.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.debug.32"
+    builder: "host.x86.ngen-cmc.64"
   }
 }
 job {
-  id: "host.x86.debug.64"
+  id: "host.x86.poison.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.debug.64"
+    builder: "host.x86.poison.32"
   }
 }
 job {
-  id: "host.x86.ndebug.32"
+  id: "host.x86.poison.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.ndebug.32"
+    builder: "host.x86.poison.64"
   }
 }
 job {
-  id: "host.x86.ndebug.64"
+  id: "qemu.arm.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.ndebug.64"
+    builder: "qemu.arm.64"
   }
 }
 job {
-  id: "host.x86.poison.debug.32"
+  id: "qemu.riscv.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.poison.debug.32"
+    builder: "qemu.riscv.64"
   }
 }
 job {
-  id: "host.x86.poison.debug.64"
+  id: "target.arm.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "host.x86.poison.debug.64"
+    builder: "target.arm.32"
   }
 }
 job {
-  id: "qemu-armv8-ndebug"
+  id: "target.arm.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "qemu-armv8-ndebug"
+    builder: "target.arm.64"
   }
 }
 job {
-  id: "qemu-riscv64-ndebug"
+  id: "target.arm.cmc.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "qemu-riscv64-ndebug"
+    builder: "target.arm.cmc.32"
   }
 }
 job {
-  id: "target.arm.poison.debug.32"
+  id: "target.arm.cmc.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "target.arm.poison.debug.32"
+    builder: "target.arm.cmc.64"
   }
 }
 job {
-  id: "target.arm.poison.debug.64"
+  id: "target.arm.gsctress.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "target.arm.poison.debug.64"
+    builder: "target.arm.gsctress.32"
   }
 }
 job {
-  id: "target.arm.poison.ndebug.32"
+  id: "target.arm.gsctress.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "target.arm.poison.ndebug.32"
+    builder: "target.arm.gsctress.64"
   }
 }
 job {
-  id: "target.arm.poison.ndebug.64"
+  id: "target.arm.ndebug.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "target.arm.poison.ndebug.64"
+    builder: "target.arm.ndebug.32"
   }
 }
 job {
-  id: "walleye-armv7-poison-debug"
+  id: "target.arm.ndebug.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "walleye-armv7-poison-debug"
+    builder: "target.arm.ndebug.64"
   }
 }
 job {
-  id: "walleye-armv8-poison-debug"
+  id: "target.arm.poison.32"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "walleye-armv8-poison-debug"
+    builder: "target.arm.poison.32"
   }
 }
 job {
-  id: "walleye-armv8-poison-ndebug"
+  id: "target.arm.poison.64"
   realm: "ci"
   acl_sets: "ci"
   buildbucket {
     server: "cr-buildbucket.appspot.com"
     bucket: "ci"
-    builder: "walleye-armv8-poison-ndebug"
+    builder: "target.arm.poison.64"
   }
 }
 trigger {
   id: "art"
   realm: "ci"
   acl_sets: "ci"
-  triggers: "angler-armv7-debug"
-  triggers: "angler-armv7-ndebug"
-  triggers: "angler-armv7-non-gen-cc"
-  triggers: "angler-armv8-debug"
-  triggers: "angler-armv8-ndebug"
-  triggers: "angler-armv8-non-gen-cc"
-  triggers: "bullhead-armv7-gcstress-ndebug"
-  triggers: "bullhead-armv8-gcstress-debug"
-  triggers: "bullhead-armv8-gcstress-ndebug"
-  triggers: "host-x86-cms"
-  triggers: "host-x86-debug"
-  triggers: "host-x86-gcstress-debug"
-  triggers: "host-x86-ndebug"
-  triggers: "host-x86-poison-debug"
-  triggers: "host-x86_64-cms"
-  triggers: "host-x86_64-debug"
-  triggers: "host-x86_64-ndebug"
-  triggers: "host-x86_64-non-gen-cc"
-  triggers: "host-x86_64-poison-debug"
-  triggers: "host.x86.debug.32"
-  triggers: "host.x86.debug.64"
+  triggers: "host.x86.32"
+  triggers: "host.x86.64"
+  triggers: "host.x86.cmc.32"
+  triggers: "host.x86.cmc.64"
+  triggers: "host.x86.gsctress.32"
+  triggers: "host.x86.gsctress.64"
   triggers: "host.x86.ndebug.32"
   triggers: "host.x86.ndebug.64"
-  triggers: "host.x86.poison.debug.32"
-  triggers: "host.x86.poison.debug.64"
-  triggers: "qemu-armv8-ndebug"
-  triggers: "qemu-riscv64-ndebug"
-  triggers: "target.arm.poison.debug.32"
-  triggers: "target.arm.poison.debug.64"
-  triggers: "target.arm.poison.ndebug.32"
-  triggers: "target.arm.poison.ndebug.64"
-  triggers: "walleye-armv7-poison-debug"
-  triggers: "walleye-armv8-poison-debug"
-  triggers: "walleye-armv8-poison-ndebug"
+  triggers: "host.x86.ngen-cmc.32"
+  triggers: "host.x86.ngen-cmc.64"
+  triggers: "host.x86.poison.32"
+  triggers: "host.x86.poison.64"
+  triggers: "qemu.arm.64"
+  triggers: "qemu.riscv.64"
+  triggers: "target.arm.32"
+  triggers: "target.arm.64"
+  triggers: "target.arm.cmc.32"
+  triggers: "target.arm.cmc.64"
+  triggers: "target.arm.gsctress.32"
+  triggers: "target.arm.gsctress.64"
+  triggers: "target.arm.ndebug.32"
+  triggers: "target.arm.ndebug.64"
+  triggers: "target.arm.poison.32"
+  triggers: "target.arm.poison.64"
   gitiles {
     repo: "https://android.googlesource.com/platform/art"
     refs: "regexp:refs/heads/master"
@@ -391,40 +281,30 @@ trigger {
   id: "libcore"
   realm: "ci"
   acl_sets: "ci"
-  triggers: "angler-armv7-debug"
-  triggers: "angler-armv7-ndebug"
-  triggers: "angler-armv7-non-gen-cc"
-  triggers: "angler-armv8-debug"
-  triggers: "angler-armv8-ndebug"
-  triggers: "angler-armv8-non-gen-cc"
-  triggers: "bullhead-armv7-gcstress-ndebug"
-  triggers: "bullhead-armv8-gcstress-debug"
-  triggers: "bullhead-armv8-gcstress-ndebug"
-  triggers: "host-x86-cms"
-  triggers: "host-x86-debug"
-  triggers: "host-x86-gcstress-debug"
-  triggers: "host-x86-ndebug"
-  triggers: "host-x86-poison-debug"
-  triggers: "host-x86_64-cms"
-  triggers: "host-x86_64-debug"
-  triggers: "host-x86_64-ndebug"
-  triggers: "host-x86_64-non-gen-cc"
-  triggers: "host-x86_64-poison-debug"
-  triggers: "host.x86.debug.32"
-  triggers: "host.x86.debug.64"
+  triggers: "host.x86.32"
+  triggers: "host.x86.64"
+  triggers: "host.x86.cmc.32"
+  triggers: "host.x86.cmc.64"
+  triggers: "host.x86.gsctress.32"
+  triggers: "host.x86.gsctress.64"
   triggers: "host.x86.ndebug.32"
   triggers: "host.x86.ndebug.64"
-  triggers: "host.x86.poison.debug.32"
-  triggers: "host.x86.poison.debug.64"
-  triggers: "qemu-armv8-ndebug"
-  triggers: "qemu-riscv64-ndebug"
-  triggers: "target.arm.poison.debug.32"
-  triggers: "target.arm.poison.debug.64"
-  triggers: "target.arm.poison.ndebug.32"
-  triggers: "target.arm.poison.ndebug.64"
-  triggers: "walleye-armv7-poison-debug"
-  triggers: "walleye-armv8-poison-debug"
-  triggers: "walleye-armv8-poison-ndebug"
+  triggers: "host.x86.ngen-cmc.32"
+  triggers: "host.x86.ngen-cmc.64"
+  triggers: "host.x86.poison.32"
+  triggers: "host.x86.poison.64"
+  triggers: "qemu.arm.64"
+  triggers: "qemu.riscv.64"
+  triggers: "target.arm.32"
+  triggers: "target.arm.64"
+  triggers: "target.arm.cmc.32"
+  triggers: "target.arm.cmc.64"
+  triggers: "target.arm.gsctress.32"
+  triggers: "target.arm.gsctress.64"
+  triggers: "target.arm.ndebug.32"
+  triggers: "target.arm.ndebug.64"
+  triggers: "target.arm.poison.32"
+  triggers: "target.arm.poison.64"
   gitiles {
     repo: "https://android.googlesource.com/platform/libcore"
     refs: "regexp:refs/heads/master"
@@ -434,40 +314,30 @@ trigger {
   id: "manifest"
   realm: "ci"
   acl_sets: "ci"
-  triggers: "angler-armv7-debug"
-  triggers: "angler-armv7-ndebug"
-  triggers: "angler-armv7-non-gen-cc"
-  triggers: "angler-armv8-debug"
-  triggers: "angler-armv8-ndebug"
-  triggers: "angler-armv8-non-gen-cc"
-  triggers: "bullhead-armv7-gcstress-ndebug"
-  triggers: "bullhead-armv8-gcstress-debug"
-  triggers: "bullhead-armv8-gcstress-ndebug"
-  triggers: "host-x86-cms"
-  triggers: "host-x86-debug"
-  triggers: "host-x86-gcstress-debug"
-  triggers: "host-x86-ndebug"
-  triggers: "host-x86-poison-debug"
-  triggers: "host-x86_64-cms"
-  triggers: "host-x86_64-debug"
-  triggers: "host-x86_64-ndebug"
-  triggers: "host-x86_64-non-gen-cc"
-  triggers: "host-x86_64-poison-debug"
-  triggers: "host.x86.debug.32"
-  triggers: "host.x86.debug.64"
+  triggers: "host.x86.32"
+  triggers: "host.x86.64"
+  triggers: "host.x86.cmc.32"
+  triggers: "host.x86.cmc.64"
+  triggers: "host.x86.gsctress.32"
+  triggers: "host.x86.gsctress.64"
   triggers: "host.x86.ndebug.32"
   triggers: "host.x86.ndebug.64"
-  triggers: "host.x86.poison.debug.32"
-  triggers: "host.x86.poison.debug.64"
-  triggers: "qemu-armv8-ndebug"
-  triggers: "qemu-riscv64-ndebug"
-  triggers: "target.arm.poison.debug.32"
-  triggers: "target.arm.poison.debug.64"
-  triggers: "target.arm.poison.ndebug.32"
-  triggers: "target.arm.poison.ndebug.64"
-  triggers: "walleye-armv7-poison-debug"
-  triggers: "walleye-armv8-poison-debug"
-  triggers: "walleye-armv8-poison-ndebug"
+  triggers: "host.x86.ngen-cmc.32"
+  triggers: "host.x86.ngen-cmc.64"
+  triggers: "host.x86.poison.32"
+  triggers: "host.x86.poison.64"
+  triggers: "qemu.arm.64"
+  triggers: "qemu.riscv.64"
+  triggers: "target.arm.32"
+  triggers: "target.arm.64"
+  triggers: "target.arm.cmc.32"
+  triggers: "target.arm.cmc.64"
+  triggers: "target.arm.gsctress.32"
+  triggers: "target.arm.gsctress.64"
+  triggers: "target.arm.ndebug.32"
+  triggers: "target.arm.ndebug.64"
+  triggers: "target.arm.poison.32"
+  triggers: "target.arm.poison.64"
   gitiles {
     repo: "https://android.googlesource.com/platform/manifest"
     refs: "regexp:refs/heads/master-art"
@@ -477,40 +347,30 @@ trigger {
   id: "vogar"
   realm: "ci"
   acl_sets: "ci"
-  triggers: "angler-armv7-debug"
-  triggers: "angler-armv7-ndebug"
-  triggers: "angler-armv7-non-gen-cc"
-  triggers: "angler-armv8-debug"
-  triggers: "angler-armv8-ndebug"
-  triggers: "angler-armv8-non-gen-cc"
-  triggers: "bullhead-armv7-gcstress-ndebug"
-  triggers: "bullhead-armv8-gcstress-debug"
-  triggers: "bullhead-armv8-gcstress-ndebug"
-  triggers: "host-x86-cms"
-  triggers: "host-x86-debug"
-  triggers: "host-x86-gcstress-debug"
-  triggers: "host-x86-ndebug"
-  triggers: "host-x86-poison-debug"
-  triggers: "host-x86_64-cms"
-  triggers: "host-x86_64-debug"
-  triggers: "host-x86_64-ndebug"
-  triggers: "host-x86_64-non-gen-cc"
-  triggers: "host-x86_64-poison-debug"
-  triggers: "host.x86.debug.32"
-  triggers: "host.x86.debug.64"
+  triggers: "host.x86.32"
+  triggers: "host.x86.64"
+  triggers: "host.x86.cmc.32"
+  triggers: "host.x86.cmc.64"
+  triggers: "host.x86.gsctress.32"
+  triggers: "host.x86.gsctress.64"
   triggers: "host.x86.ndebug.32"
   triggers: "host.x86.ndebug.64"
-  triggers: "host.x86.poison.debug.32"
-  triggers: "host.x86.poison.debug.64"
-  triggers: "qemu-armv8-ndebug"
-  triggers: "qemu-riscv64-ndebug"
-  triggers: "target.arm.poison.debug.32"
-  triggers: "target.arm.poison.debug.64"
-  triggers: "target.arm.poison.ndebug.32"
-  triggers: "target.arm.poison.ndebug.64"
-  triggers: "walleye-armv7-poison-debug"
-  triggers: "walleye-armv8-poison-debug"
-  triggers: "walleye-armv8-poison-ndebug"
+  triggers: "host.x86.ngen-cmc.32"
+  triggers: "host.x86.ngen-cmc.64"
+  triggers: "host.x86.poison.32"
+  triggers: "host.x86.poison.64"
+  triggers: "qemu.arm.64"
+  triggers: "qemu.riscv.64"
+  triggers: "target.arm.32"
+  triggers: "target.arm.64"
+  triggers: "target.arm.cmc.32"
+  triggers: "target.arm.cmc.64"
+  triggers: "target.arm.gsctress.32"
+  triggers: "target.arm.gsctress.64"
+  triggers: "target.arm.ndebug.32"
+  triggers: "target.arm.ndebug.64"
+  triggers: "target.arm.poison.32"
+  triggers: "target.arm.poison.64"
   gitiles {
     repo: "https://android.googlesource.com/platform/external/vogar"
     refs: "regexp:refs/heads/master"
diff --git a/tools/luci/config/generated/project.cfg b/tools/luci/config/generated/project.cfg
index 90bdf85851..12b1ae6e69 100644
--- a/tools/luci/config/generated/project.cfg
+++ b/tools/luci/config/generated/project.cfg
@@ -7,7 +7,7 @@
 name: "art"
 access: "group:all"
 lucicfg {
-  version: "1.43.13"
+  version: "1.43.14"
   package_dir: ".."
   config_dir: "generated"
   entry_point: "main.star"
diff --git a/tools/luci/config/main.star b/tools/luci/config/main.star
index 56cb4c1900..a2e4e2afa1 100755
--- a/tools/luci/config/main.star
+++ b/tools/luci/config/main.star
@@ -175,7 +175,8 @@ luci.gitiles_poller(
     refs = ["refs/heads/master-art"],
 )
 
-def ci_builder(name, category, short_name, dimensions, properties={}, hidden=False):
+def ci_builder(name, category, short_name, dimensions, properties={},
+               experiments={}, hidden=False):
     luci.builder(
         name = name,
         bucket = "ci",
@@ -210,6 +211,7 @@ def ci_builder(name, category, short_name, dimensions, properties={}, hidden=Fal
             "manifest",
             "vogar",
         ],
+        experiments = experiments,
     )
     if not hidden:
         luci.console_view_entry(
@@ -219,15 +221,15 @@ def ci_builder(name, category, short_name, dimensions, properties={}, hidden=Fal
             short_name = short_name,
         )
 
-def add_builder(name,
-                mode,
+def add_builder(mode,
                 arch,
                 bitness,
-                debug=False,
-                cc=True,
-                gen_cc=True,
+                ndebug=False,
+                ngen=False,
+                cmc=False,
                 gcstress=False,
-                heap_poisoning=False):
+                poison=False,
+                hidden=False):
     def check_arg(value, valid_values):
       if value not in valid_values:
         fail("Argument '{}' was expected to be on of {}".format(value, valid_values))
@@ -235,26 +237,22 @@ def add_builder(name,
     check_arg(arch, ["arm", "x86", "riscv"])
     check_arg(bitness, [32, 64])
 
-    # Automatically create name based on the configuaration.
-    default_name = mode + '.' + arch
-    default_name += '.gsctress' if gcstress else ''
-    default_name += '.poison' if heap_poisoning else ''
-    default_name += '' if cc else '.ncc'
-    default_name += '' if gen_cc else '.ngen'
-    default_name += '.debug' if debug else '.ndebug'
-    default_name += '.' + str(bitness)
-
-    # Create abbreviated named which is used to create the LUCI console header.
-    # TODO: Rename the builders to remove old device names and make it more uniform.
-    short_name = name or default_name.replace(".", "-")
-    short_name = short_name.replace("-x86-poison-debug", "-x86-psn")
-    short_name = short_name.replace("-x86-gcstress-debug", "-x86-gcs")
-    short_name = short_name.replace("-x86_64-poison-debug", "-x86_64-psn")
-    short_name = short_name.replace("-x86_64", "-x64")
-    short_name = short_name.replace("-ndebug-build_only", "-bo")
-    short_name = short_name.replace("-non-gen-cc", "-ngen")
-    short_name = short_name.replace("-debug", "-dbg")
-    short_name = short_name.replace("-ndebug", "-ndbg")
+    # Create builder name based on the configuaration parameters.
+    name = mode + '.' + arch
+    name += '.gsctress' if gcstress else ''
+    name += '.poison' if poison else ''
+    name += '.ngen' if ngen else ''
+    name += '.cmc' if cmc else ''
+    name += '.ndebug' if ndebug else ''
+    name += '.' + str(bitness)
+    name = name.replace("ngen.cmc", "ngen-cmc")
+
+    # Define the LUCI console category (the tree layout).
+    # The "|" splits the tree node into sub-categories.
+    # Merge some name parts to reduce the tree depth.
+    category = name.replace(".", "|")
+    category = category.replace("host|", "host.")
+    category = category.replace("target|", "target.")
 
     product = None
     if arch == "arm":
@@ -262,9 +260,9 @@ def add_builder(name,
     if arch == "riscv":
       product = "riscv64"
 
-    dimensions = {"os": "Android" if mode == "target" else "Linux"}
+    dimensions = {"os": "Android" if mode == "target" else "Ubuntu"}
     if mode == "target":
-      if not cc:
+      if cmc:
         # Request devices running Android 24Q3 (`AP1A` builds) for
         # (`userfaultfd`-based) Concurrent Mark-Compact GC configurations.
         # Currently (as of 2024-08-22), the only devices within the device pool
@@ -278,76 +276,52 @@ def add_builder(name,
         # This avoids allocating `userfaultfd` devices for tests that don't need it.
         dimensions |= {"device_os": "S"}
     elif mode == "host":
-      if name:
-        dimensions |= {"os": "Ubuntu-20"}
-      else:
-        # Test the new host builders with new ubuntu.
-        dimensions |= {"os": "Ubuntu-22"}
-        dimensions |= {"cores": "8"}
+      dimensions |= {"cores": "8"}
     elif mode == "qemu":
-      dimensions |= {"os": "Ubuntu-22"}
       dimensions |= {"cores": "16"}
 
     testrunner_args = ['--verbose', '--host'] if mode == 'host' else ['--target', '--verbose']
-    testrunner_args += ['--debug'] if debug else ['--ndebug']
+    testrunner_args += ['--ndebug'] if ndebug else ['--debug']
     testrunner_args += ['--gcstress'] if gcstress else []
 
-    hidden = not name  # Hide the new builders for now.
-    name = name or default_name
-
     properties = {
         "builder_group": "client.art",
         "bitness": bitness,
         "build_only": ("build_only" in name),
-        "debug": debug,
+        "debug": not ndebug,
         "device": None if mode == "host" else "-".join(name.split("-")[:2]),
         "on_virtual_machine": mode == "qemu",
         "product": product,
-        "concurrent_collector": cc,
-        "generational_cc": gen_cc,
+        "concurrent_collector": not cmc,
+        "generational_cc": not ngen,
         "gcstress": gcstress,
-        "heap_poisoning": heap_poisoning,
+        "heap_poisoning": poison,
         "testrunner_args": testrunner_args,
     }
 
-    ci_builder(name,
-               category="|".join(short_name.split("-")[:-1]),
-               short_name=short_name.split("-")[-1],
+    experiments = {"art.superproject": 100} if mode == "qemu" else {}
+
+    ci_builder(name=name,
+               category="|".join(category.split("|")[:-1]),
+               short_name=category.split("|")[-1],
                dimensions=dimensions,
                properties={k:v for k, v in properties.items() if v},
+               experiments=experiments,
                hidden=hidden)
 
-add_builder("angler-armv7-debug", 'target', 'arm', 32, debug=True)
-add_builder("angler-armv7-non-gen-cc", 'target', 'arm', 32, debug=True, cc=False, gen_cc=False)
-add_builder("angler-armv7-ndebug", 'target', 'arm', 32)
-add_builder("angler-armv8-debug", 'target', 'arm', 64, debug=True)
-add_builder("angler-armv8-non-gen-cc", 'target', 'arm', 64, debug=True, cc=False, gen_cc=False)
-add_builder("angler-armv8-ndebug", 'target', 'arm', 64)
-add_builder("bullhead-armv7-gcstress-ndebug", 'target', 'arm', 32, gcstress=True)
-add_builder("bullhead-armv8-gcstress-debug", 'target', 'arm', 64, debug=True, gcstress=True)
-add_builder("bullhead-armv8-gcstress-ndebug", 'target', 'arm', 64, gcstress=True)
-add_builder("walleye-armv7-poison-debug", 'target', 'arm', 32, debug=True, heap_poisoning=True)
-add_builder("walleye-armv8-poison-debug", 'target', 'arm', 64, debug=True, heap_poisoning=True)
-add_builder("walleye-armv8-poison-ndebug", 'target', 'arm', 64, heap_poisoning=True)
-add_builder("host-x86-cms", 'host', 'x86', 32, debug=True, cc=False, gen_cc=False)
-add_builder("host-x86-debug", 'host', 'x86', 32, debug=True)
-add_builder("host-x86-ndebug", 'host', 'x86', 32)
-add_builder("host-x86-gcstress-debug", 'host', 'x86', 32, debug=True, gcstress=True)
-add_builder("host-x86-poison-debug", 'host', 'x86', 32, debug=True, heap_poisoning=True)
-add_builder("host-x86_64-cms", 'host', 'x86', 64, cc=False, debug=True, gen_cc=False)
-add_builder("host-x86_64-debug", 'host', 'x86', 64, debug=True)
-add_builder("host-x86_64-non-gen-cc", 'host', 'x86', 64, debug=True, gen_cc=False)
-add_builder("host-x86_64-ndebug", 'host', 'x86', 64)
-add_builder("host-x86_64-poison-debug", 'host', 'x86', 64, debug=True, heap_poisoning=True)
-add_builder("qemu-armv8-ndebug", 'qemu', 'arm', 64)
-add_builder("qemu-riscv64-ndebug", 'qemu', 'riscv', 64)
-
 def add_builders():
-  for bitness in [32, 64]:
-    add_builder('', 'target', 'arm', bitness, debug=True, heap_poisoning=True)
-    add_builder('', 'target', 'arm', bitness, heap_poisoning=True)
-    add_builder('', 'host', 'x86', bitness, debug=True)
-    add_builder('', 'host', 'x86', bitness)
-    add_builder('', 'host', 'x86', bitness, debug=True, heap_poisoning=True)
+  for mode, arch in [("target", "arm"), ("host", "x86")]:
+    for bitness in [32, 64]:
+      # Add first to keep these builders together and left-aligned in the console.
+      add_builder(mode, arch, bitness)
+    for bitness in [32, 64]:
+      add_builder(mode, arch, bitness, ndebug=True)
+      if mode == "host":
+        add_builder(mode, arch, bitness, ngen=True, cmc=True)
+      add_builder(mode, arch, bitness, cmc=True)
+      add_builder(mode, arch, bitness, poison=True)
+      add_builder(mode, arch, bitness, gcstress=True)
+  add_builder('qemu', 'arm', bitness=64)
+  add_builder('qemu', 'riscv', bitness=64)
 
 add_builders()
\ No newline at end of file
diff --git a/tools/run-gtests.sh b/tools/run-gtests.sh
index 99ac8dfb7c..acc5c8a2ed 100755
--- a/tools/run-gtests.sh
+++ b/tools/run-gtests.sh
@@ -16,6 +16,8 @@
 
 set -e
 
+. "$(dirname $0)/buildbot-utils.sh"
+
 if [[ $1 = -h ]]; then
   cat <<EOF
 Usage: $0 [<gtest>...] [--] [<gtest-option>...]
@@ -99,6 +101,7 @@ for t in ${tests[@]}; do
     env ANDROID_ART_ROOT="$android_art_root" \
         ANDROID_I18N_ROOT="$android_i18n_root" \
         ANDROID_TZDATA_ROOT="$android_tzdata_root" \
+        ART_TEST_ON_VM="$ART_TEST_ON_VM" \
         $(maybe_get_fake_dex2oatbootclasspath) \
         $t $options \
     || failing_tests+=("$t")
diff --git a/tools/veridex/Android.bp b/tools/veridex/Android.bp
index ad1632b1ee..f069a02ee5 100644
--- a/tools/veridex/Android.bp
+++ b/tools/veridex/Android.bp
@@ -156,20 +156,17 @@ python_binary_host {
     srcs: ["appcompat.py"],
     data: [
         ":veridex",
-        ":platform-bootclasspath{hiddenapi-flags.csv}",
         ":org.apache.http.legacy-stubs.zip",
         ":system-stubs.zip",
     ],
-    version: {
-        py3: {
-            embedded_launcher: true,
-        },
-    },
+    device_common_data: [
+        ":platform-bootclasspath{hiddenapi-flags.csv}",
+    ],
 }
 
 // TODO: Remove `veridex_zip` and `appcompat.sh` after migrating
 //       `GtsUnofficialApisUsageTestCases` and `GtsNetUnofficialApisUsageTestCases` to use appcompat.
-genrule {
+java_genrule {
     name: "veridex_zip",
     srcs: [
         "appcompat.sh",
diff --git a/tools/veridex/veridex.cc b/tools/veridex/veridex.cc
index d2a32e6db1..9c7bd78cff 100644
--- a/tools/veridex/veridex.cc
+++ b/tools/veridex/veridex.cc
@@ -21,6 +21,7 @@
 
 #include <cstdlib>
 #include <sstream>
+#include <string_view>
 
 #include "base/mem_map.h"
 #include "dex/dex_file.h"
@@ -89,30 +90,27 @@ static const char* Substr(const char* str, int index) {
   return str + index;
 }
 
-static bool StartsWith(const char* str, const char* val) {
-  return strlen(str) >= strlen(val) && memcmp(str, val, strlen(val)) == 0;
-}
-
 static void ParseArgs(VeridexOptions* options, int argc, char** argv) {
   // Skip over the command name.
   argv++;
   argc--;
 
   for (int i = 0; i < argc; ++i) {
-    if (StartsWith(argv[i], kDexFileOption)) {
+    std::string_view arg(argv[i]);
+    if (arg.starts_with(kDexFileOption)) {
       options->dex_file = Substr(argv[i], strlen(kDexFileOption));
-    } else if (StartsWith(argv[i], kStubsOption)) {
+    } else if (arg.starts_with(kStubsOption)) {
       options->core_stubs = Substr(argv[i], strlen(kStubsOption));
-    } else if (StartsWith(argv[i], kFlagsOption)) {
+    } else if (arg.starts_with(kFlagsOption)) {
       options->flags_file = Substr(argv[i], strlen(kFlagsOption));
     } else if (strcmp(argv[i], kImprecise) == 0) {
       options->precise = false;
-    } else if (StartsWith(argv[i], kTargetSdkVersion)) {
+    } else if (arg.starts_with(kTargetSdkVersion)) {
       options->target_sdk_version = atoi(Substr(argv[i], strlen(kTargetSdkVersion)));
-    } else if (StartsWith(argv[i], kAppClassFilter)) {
+    } else if (arg.starts_with(kAppClassFilter)) {
       options->app_class_name_filter = android::base::Split(
           Substr(argv[i], strlen(kAppClassFilter)), ",");
-    } else if (StartsWith(argv[i], kExcludeApiListsOption)) {
+    } else if (arg.starts_with(kExcludeApiListsOption)) {
       options->exclude_api_lists = android::base::Split(
           Substr(argv[i], strlen(kExcludeApiListsOption)), ",");
     } else {
```

