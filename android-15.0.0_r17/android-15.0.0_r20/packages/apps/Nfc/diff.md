```diff
diff --git a/Android.bp b/Android.bp
index 806b03b1..ce94f9bf 100644
--- a/Android.bp
+++ b/Android.bp
@@ -24,13 +24,15 @@ java_library {
         "//apex_available:platform",
         "com.android.nfcservices",
     ],
-    min_sdk_version: "current",
+    min_sdk_version: "35", // Make it 36 once available.
     sdk_version: "module_current",
 }
 
 java_defaults {
     name: "NfcNciDefaults",
     static_libs: [
+        "android.app.flags-aconfig-java",
+        "android.service.chooser.flags-aconfig-java",
         "android.se.omapi-V1-java",
         "androidx.annotation_annotation",
         "androidx.appcompat_appcompat",
@@ -40,10 +42,10 @@ java_defaults {
         "modules-utils-shell-command-handler",
         "PlatformProperties",
         "nfc-event-log-proto",
-        "nfc_flags_lib",
+        "com.android.nfc.flags-aconfig-java",
     ],
     flags_packages: [
-        "nfc_aconfig_flags",
+        "com.android.nfc.flags-aconfig",
     ],
     privileged: true,
     optimize: {
@@ -92,7 +94,8 @@ android_app {
 android_app {
     name: "NfcNciApex",
     defaults: ["NfcNciDefaults"],
-    min_sdk_version: "current",
+    min_sdk_version: "35", // Make it 36 once available.
+    updatable: false, // TODO: fix this.
     sdk_version: "module_current",
     certificate: "nfc",
     srcs: [
@@ -100,6 +103,8 @@ android_app {
         "shim_src/apex/**/*.java",
     ],
     libs: [
+        "android.nfc.flags-aconfig-java",
+        "android.permission.flags-aconfig-java",
         "framework-annotations-lib",
         "framework-bluetooth.stubs.module_lib",
         "framework-configinfrastructure.stubs.module_lib",
@@ -108,9 +113,6 @@ android_app {
         "framework-permission.stubs.module_lib",
         "framework-statsd.stubs.module_lib",
         "framework-wifi.stubs.module_lib",
-        "android.nfc.flags-aconfig-java",
-        "android.permission.flags-aconfig-java",
-        "android.service.chooser.flags-aconfig-java",
         "unsupportedappusage",
     ],
     // prevent NfcNciApex from using product-specific resources
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 5d28f26b..77515aa8 100755
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -70,6 +70,7 @@
     <uses-permission android:name="android.permission.QUERY_CLONED_APPS"/>
     <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE"/>
     <uses-permission android:name="android.permission.MODIFY_PHONE_STATE"/>
+    <uses-permission android:name="android.permission.WRITE_SECURITY_LOG"/>
 
     <protected-broadcast android:name="android.nfc.intent.action.WATCHDOG" />
 
diff --git a/NfcMigration/Android.bp b/NfcMigration/Android.bp
new file mode 100644
index 00000000..46687926
--- /dev/null
+++ b/NfcMigration/Android.bp
@@ -0,0 +1,40 @@
+package {
+    default_team: "trendy_team_fwk_nfc",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+// NFC apk left behind for migrating persistent
+// data from old APK - com.android.nfc to the mainline module
+// APK - com.google.android.nfc
+android_app {
+    name: "NfcNciApexMigration",
+    min_sdk_version: "35", // Make it 36 once available.
+    updatable: false, // TODO: fix this.
+    sdk_version: "system_current",
+    certificate: "nfc",
+    enabled: select(release_flag("RELEASE_NFC_MAINLINE_MODULE"), {
+        true: true,
+        default: false,
+    }),
+    srcs: [
+        "src/**/*.java",
+    ],
+    libs: [
+        "unsupportedappusage",
+    ],
+    optimize: {
+        enabled: false,
+    },
+    // prevent NfcNciApex from using product-specific resources
+    aaptflags: ["--product default"],
+    apex_available: [
+        "com.android.nfcservices",
+    ],
+    privileged: true,
+    privapp_allowlist: ":privapp_allowlist_com.android.nfc_migration.xml",
+}
+
+filegroup {
+    name: "privapp_allowlist_com.android.nfc_migration.xml",
+    srcs: ["com.android.nfc_migration.xml"],
+}
diff --git a/NfcMigration/AndroidManifest.xml b/NfcMigration/AndroidManifest.xml
new file mode 100755
index 00000000..734efdf6
--- /dev/null
+++ b/NfcMigration/AndroidManifest.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2024 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        package="com.android.nfc"
+        android:sharedUserId="android.uid.nfc">
+
+    <uses-permission android:name="android.permission.NFC" />
+    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
+    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" />
+
+    <application android:label="NFC Migration"
+                 android:directBootAware="true"
+                 android:defaultToDeviceProtectedStorage="true">
+        <receiver android:name=".NfcMigrationBootCompleteReceiver"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+            </intent-filter>
+        </receiver>
+    </application>
+
+</manifest>
diff --git a/NfcMigration/com.android.nfc_migration.xml b/NfcMigration/com.android.nfc_migration.xml
new file mode 100644
index 00000000..21521547
--- /dev/null
+++ b/NfcMigration/com.android.nfc_migration.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<permissions>
+    <privapp-permissions package="com.android.nfc">
+        <permission name="android.permission.WRITE_SECURE_SETTINGS"/>
+    </privapp-permissions>
+</permissions>
diff --git a/NfcMigration/src/com/android/nfc/NfcMigrationBootCompleteReceiver.java b/NfcMigration/src/com/android/nfc/NfcMigrationBootCompleteReceiver.java
new file mode 100644
index 00000000..8c663ca1
--- /dev/null
+++ b/NfcMigration/src/com/android/nfc/NfcMigrationBootCompleteReceiver.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.nfc.NfcAdapter;
+import android.nfc.cardemulation.CardEmulation;
+import android.os.Handler;
+import android.util.Log;
+
+import com.android.nfc.SharedPreferencesMigration;
+import com.android.nfc.cardemulation.RegisteredServicesCacheMigration;
+
+import java.lang.reflect.Method;
+
+public class NfcMigrationBootCompleteReceiver extends BroadcastReceiver {
+    private static final String TAG = "NfcMigrationBootCompletedReceiver";
+    private static final String FEATURE_NFC_ANY = "android.hardware.nfc.any";
+
+    private NfcAdapter mNfcAdapter;
+
+    private void indicateDataMigration(boolean inProgress) {
+        try {
+            Method indicateDataMirationMethod =
+                    NfcAdapter.class.getMethod("indicateDataMigration", boolean.class);
+            indicateDataMirationMethod.invoke(mNfcAdapter, inProgress);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to indicate nfc data migration", e);
+        }
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        Log.d(TAG, "onReceive: " + intent);
+        if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
+            PackageManager pm = context.getPackageManager();
+            if (!pm.hasSystemFeature(FEATURE_NFC_ANY)) {
+                pm.setApplicationEnabledSetting(context.getPackageName(),
+                        PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);
+            } else {
+                mNfcAdapter = NfcAdapter.getDefaultAdapter(context);
+                if (mNfcAdapter == null) {
+                    throw new IllegalStateException("Failed to get NFC adapter");
+                }
+                SharedPreferencesMigration preferencesMigration =
+                        new SharedPreferencesMigration(context);
+               if (!preferencesMigration.hasAlreadyMigrated()) {
+                   Handler handler = new Handler();
+                   // Let NFC stack handle user unlock before doing the migration.
+                   handler.post(()  -> {
+                       Log.d(TAG, "Starting NFC data Migration");
+                       indicateDataMigration(true);
+                       preferencesMigration.handleMigration();
+                       RegisteredServicesCacheMigration cacheMigration =
+                               new RegisteredServicesCacheMigration(context);
+                       cacheMigration.handleMigration();
+                       preferencesMigration.markMigrationComplete();
+                       indicateDataMigration(false);
+                       pm.setComponentEnabledSetting(new ComponentName(context, this.getClass()),
+                           PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
+                           PackageManager.DONT_KILL_APP);
+                   });
+               }
+            }
+        }
+    }
+}
diff --git a/NfcMigration/src/com/android/nfc/SharedPreferencesMigration.java b/NfcMigration/src/com/android/nfc/SharedPreferencesMigration.java
new file mode 100644
index 00000000..a52a100f
--- /dev/null
+++ b/NfcMigration/src/com/android/nfc/SharedPreferencesMigration.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import static android.content.Context.MODE_PRIVATE;
+
+import android.app.ActivityManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.nfc.NfcAdapter;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.util.Log;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Used to migrate shared preferences files stored by
+ * {@link com.android.nfc.NfcService} from AOSP stack to NFC mainline
+ * module.
+ */
+public class SharedPreferencesMigration {
+    private static final String TAG = "SharedPreferencesMigration";
+    private static final String PREF = "NfcServicePrefs";
+    public static final String PREF_TAG_APP_LIST = "TagIntentAppPreferenceListPrefs";
+    private static final String PREF_NFC_ON = "nfc_on";
+    private static final String PREF_SECURE_NFC_ON = "secure_nfc_on";
+    private static final String PREF_NFC_READER_OPTION_ON = "nfc_reader_on";
+    private static final String PREF_MIGRATION_TO_MAINLINE_COMPLETE = "migration_to_mainline_complete";
+
+    private final SharedPreferences mSharedPreferences;
+    private SharedPreferences mTagAppPrefListPreferences;
+    private final Context mContext;
+    private final NfcAdapter mNfcAdapter;
+
+    public SharedPreferencesMigration(Context context) {
+        mContext = context;
+        mNfcAdapter = NfcAdapter.getDefaultAdapter(context);
+        if (mNfcAdapter == null) {
+            throw new IllegalStateException("Failed to get NFC adapter");
+        }
+        SharedPreferences sharedPreferences = context.getSharedPreferences(PREF, MODE_PRIVATE);
+        SharedPreferences tagAppPrefListPreferences =
+                context.getSharedPreferences(PREF_TAG_APP_LIST, MODE_PRIVATE);
+        // Check both CE & DE directory for migration.
+        if (sharedPreferences.getAll().isEmpty() && tagAppPrefListPreferences.getAll().isEmpty()) {
+            Log.d(TAG, "Searching for NFC preferences in CE directory");
+            Context ceContext = context.createCredentialProtectedStorageContext();
+            sharedPreferences = ceContext.getSharedPreferences(PREF, MODE_PRIVATE);
+            tagAppPrefListPreferences =
+                    ceContext.getSharedPreferences(PREF_TAG_APP_LIST, MODE_PRIVATE);
+        }
+        mSharedPreferences = sharedPreferences;
+        mTagAppPrefListPreferences = tagAppPrefListPreferences;
+    }
+
+    public boolean hasAlreadyMigrated() {
+        return mSharedPreferences.getAll().isEmpty() ||
+                mSharedPreferences.getBoolean(PREF_MIGRATION_TO_MAINLINE_COMPLETE, false);
+    }
+
+    public void markMigrationComplete() {
+        mSharedPreferences.edit().putBoolean(PREF_MIGRATION_TO_MAINLINE_COMPLETE, true).apply();
+    }
+
+    private List<Integer> getEnabledUserIds() {
+        List<Integer> userIds = new ArrayList<Integer>();
+        UserManager um =
+                mContext.createContextAsUser(UserHandle.of(ActivityManager.getCurrentUser()), 0)
+                        .getSystemService(UserManager.class);
+        List<UserHandle> luh = um.getEnabledProfiles();
+        for (UserHandle uh : luh) {
+            userIds.add(uh.getIdentifier());
+        }
+        return userIds;
+    }
+
+    private boolean setNfcEnabled(boolean enable) {
+        try {
+            if (mNfcAdapter.isEnabled() == enable) return true;
+            CountDownLatch countDownLatch = new CountDownLatch(1);
+            AtomicInteger state = new AtomicInteger(NfcAdapter.STATE_OFF);
+            BroadcastReceiver nfcChangeListener = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    int s = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE, NfcAdapter.STATE_OFF);
+                    if (s == NfcAdapter.STATE_TURNING_ON || s == NfcAdapter.STATE_TURNING_OFF) {
+                        return;
+                    }
+                    context.unregisterReceiver(this);
+                    state.set(s);
+                    countDownLatch.countDown();
+                }
+            };
+            HandlerThread handlerThread = new HandlerThread("nfc_migration_state_listener");
+            handlerThread.start();
+            Handler handler = new Handler(handlerThread.getLooper());
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
+            mContext.getApplicationContext().registerReceiver(
+                    nfcChangeListener, intentFilter, null, handler);
+            if (enable) {
+                if (!mNfcAdapter.enable()) return false;
+            } else {
+                if (!mNfcAdapter.disable()) return false;
+            }
+            if (!countDownLatch.await(2000, TimeUnit.MILLISECONDS)) return false;
+            return state.get() == (enable ? NfcAdapter.STATE_ON : NfcAdapter.STATE_OFF);
+        } catch (Exception e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+
+    public void handleMigration() {
+        Log.i(TAG, "Migrating preferences: " + mSharedPreferences.getAll()
+                + ", " + mTagAppPrefListPreferences.getAll());
+        if (mSharedPreferences.contains(PREF_NFC_ON)) {
+            boolean enableNfc = mSharedPreferences.getBoolean(PREF_NFC_ON, false);
+            Log.d(TAG, "enableNfc: " + enableNfc);
+            if (!setNfcEnabled(enableNfc)) {
+                Log.e(TAG, "Failed to set NFC " + (enableNfc ? "enabled" : "disabled"));
+            }
+        }
+        if (mSharedPreferences.contains(PREF_SECURE_NFC_ON)) {
+            boolean enableSecureNfc = mSharedPreferences.getBoolean(PREF_SECURE_NFC_ON, false);
+            Log.d(TAG, "enableSecureNfc: " + enableSecureNfc);
+            if (!mNfcAdapter.enableSecureNfc(enableSecureNfc)) {
+                Log.e(TAG, "enableSecureNfc failed");
+            }
+        }
+        if (mSharedPreferences.contains(PREF_NFC_READER_OPTION_ON)) {
+            boolean enableReaderOption =
+                mSharedPreferences.getBoolean(PREF_NFC_READER_OPTION_ON, false);
+            Log.d(TAG, "enableSecureNfc: " + enableReaderOption);
+            if (!mNfcAdapter.enableReaderOption(enableReaderOption)) {
+                Log.e(TAG, "enableReaderOption failed");
+            }
+        }
+        if (mTagAppPrefListPreferences != null) {
+            try {
+                for (Integer userId : getEnabledUserIds()) {
+                    String jsonString =
+                            mTagAppPrefListPreferences.getString(Integer.toString(userId),
+                                    (new JSONObject()).toString());
+                    if (jsonString != null) {
+                        JSONObject jsonObject = new JSONObject(jsonString);
+                        Iterator<String> keysItr = jsonObject.keys();
+                        while (keysItr.hasNext()) {
+                            String pkg = keysItr.next();
+                            Boolean allow = jsonObject.getBoolean(pkg);
+                            Log.d(TAG, "setTagIntentAppPreferenceForUser: " + pkg + " = " + allow);
+                            if (mNfcAdapter.setTagIntentAppPreferenceForUser(userId, pkg, allow)
+                                    != NfcAdapter.TAG_INTENT_APP_PREF_RESULT_SUCCESS) {
+                                Log.e(TAG, "setTagIntentAppPreferenceForUser failed");
+                            }
+                        }
+                    }
+                }
+            } catch (JSONException e) {
+                Log.e(TAG, "JSONException: " + e);
+            }
+        }
+    }
+
+}
diff --git a/NfcMigration/src/com/android/nfc/cardemulation/RegisteredServicesCacheMigration.java b/NfcMigration/src/com/android/nfc/cardemulation/RegisteredServicesCacheMigration.java
new file mode 100644
index 00000000..1f3ab9a1
--- /dev/null
+++ b/NfcMigration/src/com/android/nfc/cardemulation/RegisteredServicesCacheMigration.java
@@ -0,0 +1,505 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.cardemulation;
+
+import static android.nfc.cardemulation.CardEmulation.CATEGORY_OTHER;
+import static android.nfc.cardemulation.CardEmulation.CATEGORY_PAYMENT;
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.nfc.NfcAdapter;
+import android.nfc.cardemulation.AidGroup;
+import android.nfc.cardemulation.ApduServiceInfo;
+import android.nfc.cardemulation.CardEmulation;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.text.TextUtils;
+import android.util.AtomicFile;
+import android.util.Log;
+import android.util.Pair;
+import android.util.SparseArray;
+import android.util.Xml;
+
+import org.xmlpull.v1.XmlPullParser;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Used to migrate persistent cache files stored by
+ * {@link com.android.nfc.cardemulation.RegisteredServicesCache} from AOSP stack to NFC mainline
+ * module.
+ */
+public class RegisteredServicesCacheMigration {
+    static final String TAG = "RegisteredServicesCacheMigration";
+    static final String AID_XML_PATH = "dynamic_aids.xml";
+    static final String OTHER_STATUS_PATH = "other_status.xml";
+
+    private final Context mContext;
+    private final CardEmulation mCardEmulation;
+    private final SparseArray<UserServices> mUserServices = new SparseArray<UserServices>();
+    private final SettingsFile mDynamicSettingsFile;
+    private final SettingsFile mOthersFile;
+    static class DynamicSettings {
+        public final int uid;
+        public final HashMap<String, AidGroup> aidGroups = new HashMap<>();
+        public String offHostSE;
+        public String shouldDefaultToObserveModeStr;
+
+        DynamicSettings(int uid) {
+            this.uid = uid;
+        }
+    };
+
+    static class OtherServiceStatus {
+        public final int uid;
+        public boolean checked;
+
+        OtherServiceStatus(int uid, boolean checked) {
+            this.uid = uid;
+            this.checked = checked;
+        }
+    };
+
+    static class UserServices {
+        /**
+         * All services that have registered
+         */
+        final HashMap<ComponentName, ApduServiceInfo> services =
+                new HashMap<>(); // Re-built at run-time
+        final HashMap<ComponentName, DynamicSettings> dynamicSettings =
+                new HashMap<>(); // In memory cache of dynamic settings
+        final HashMap<ComponentName, OtherServiceStatus> others =
+                new HashMap<>();
+    };
+
+    static class SettingsFile {
+        final AtomicFile mFile;
+        SettingsFile(Context context, String path) {
+            File dir = context.getFilesDir();
+            mFile = new AtomicFile(new File(dir, path));
+        }
+
+        boolean exists() {
+            return mFile.getBaseFile().exists();
+        }
+
+        InputStream openRead() throws FileNotFoundException {
+            return mFile.openRead();
+        }
+
+        void delete() {
+            mFile.delete();
+        }
+    }
+
+    private UserServices findOrCreateUserLocked(int userId) {
+        UserServices services = mUserServices.get(userId);
+        if (services == null) {
+            services = new UserServices();
+            mUserServices.put(userId, services);
+        }
+        return services;
+    }
+
+    public RegisteredServicesCacheMigration(Context context) {
+        mContext = context;
+        NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(mContext);
+        if (nfcAdapter == null) {
+            throw new IllegalStateException("Failed to get NFC adapter");
+        }
+        mCardEmulation = CardEmulation.getInstance(nfcAdapter);
+        if (mCardEmulation == null) {
+            throw new IllegalStateException("Failed to get card emulation");
+        }
+        // Invoke this call to ensure the cache is populated in the NFC stack before triggering
+        // the migration.
+        mCardEmulation.isDefaultServiceForAid(
+                new ComponentName(context, getClass()), CATEGORY_PAYMENT);
+        SettingsFile dynamicSettingsFile = new SettingsFile(context, AID_XML_PATH);
+        SettingsFile othersFile = new SettingsFile(context, OTHER_STATUS_PATH);
+        // Check both CE & DE directory for migration.
+        if (!dynamicSettingsFile.exists() && !othersFile.exists()) {
+            Log.d(TAG, "Searching for NFC service info in CE directory");
+            Context ceContext = context.createCredentialProtectedStorageContext();
+            dynamicSettingsFile = new SettingsFile(ceContext, AID_XML_PATH);
+            othersFile = new SettingsFile(ceContext, OTHER_STATUS_PATH);
+        }
+        mDynamicSettingsFile = dynamicSettingsFile;
+        mOthersFile = othersFile;
+        readDynamicSettingsLocked();
+        readOthersLocked();
+    }
+
+    public void handleMigration() {
+        UserManager um = mContext.createContextAsUser(
+                        UserHandle.of(ActivityManager.getCurrentUser()), /*flags=*/0)
+                .getSystemService(UserManager.class);
+        Log.i(TAG, "Migrating cache files: " + mDynamicSettingsFile + ", " + mOthersFile);
+        for (UserHandle uh : um.getEnabledProfiles()) {
+            handleMigrationDynamicSettings(uh.getIdentifier());
+            handleMigrationOtherServices(uh.getIdentifier());
+        }
+    }
+
+    private List<ApduServiceInfo> getAllServices(int userId) {
+        List<ApduServiceInfo> validPaymentServices =
+                mCardEmulation.getServices(CATEGORY_PAYMENT, userId);
+        List<ApduServiceInfo> validOtherServices =
+                mCardEmulation.getServices(CATEGORY_OTHER, userId);
+        List<ApduServiceInfo> validServices = Stream.of(validPaymentServices, validOtherServices)
+                .flatMap(List::stream)
+                .collect(Collectors.toList());
+        Log.d(TAG, "getAllServices (all): " + validServices);
+        return validServices;
+    }
+
+    private static final boolean convertValueToBoolean(CharSequence value, boolean defaultValue) {
+        boolean result = false;
+
+        if (TextUtils.isEmpty(value)) {
+            return defaultValue;
+        }
+
+        if (value.equals("1")
+                ||  value.equals("true")
+                ||  value.equals("TRUE"))
+            result = true;
+
+        return result;
+    }
+
+    /**
+     * invalidateCache for specific userId.
+     */
+    private void handleMigrationDynamicSettings(int userId) {
+        final List<ApduServiceInfo> validServices = getAllServices(userId);
+        if (validServices == null || validServices.isEmpty()) {
+            Log.i(TAG, "No installed services");
+            return;
+        }
+        UserServices userServices = findOrCreateUserLocked(userId);
+        for (ApduServiceInfo service : validServices) {
+            userServices.services.put(service.getComponent(), service);
+        }
+        // Apply dynamic settings mappings
+        for (Map.Entry<ComponentName, DynamicSettings> entry :
+                userServices.dynamicSettings.entrySet()) {
+            // Verify component / uid match
+            ComponentName component = entry.getKey();
+            DynamicSettings dynamicSettings = entry.getValue();
+            ApduServiceInfo serviceInfo = userServices.services.get(component);
+            if (serviceInfo == null || (serviceInfo.getUid() != dynamicSettings.uid)) {
+                continue;
+            } else {
+                for (AidGroup group : dynamicSettings.aidGroups.values()) {
+                    Log.d(TAG, "registerAidsForService: " + component + " = " + group.getAids());
+                    if (!mCardEmulation.registerAidsForService(
+                            component, group.getCategory(), group.getAids())) {
+                        Log.e(TAG, "registerAidsForService failed");
+                    }
+                }
+                if (dynamicSettings.offHostSE != null) {
+                    Log.d(TAG, "setOffHostForService: " + component + " = "
+                        + dynamicSettings.offHostSE);
+                    if (!mCardEmulation.setOffHostForService(component, dynamicSettings.offHostSE)) {
+                        Log.e(TAG, "setOffHostForService failed");
+                    }
+                }
+                if (dynamicSettings.shouldDefaultToObserveModeStr != null) {
+                    boolean shouldDefaultToObserveMode =
+                        convertValueToBoolean(dynamicSettings.shouldDefaultToObserveModeStr, false);
+                    Log.d(TAG, "setShouldDefaultToObserveModeForService: " + component
+                        + " = " + shouldDefaultToObserveMode);
+                    if (!mCardEmulation.setShouldDefaultToObserveModeForService(
+                            component, shouldDefaultToObserveMode)) {
+                        Log.e(TAG, "setShouldDefaultToObserveModeForService failed");
+                    }
+                }
+            }
+        }
+
+    }
+
+    private void handleMigrationOtherServices(int userId) {
+        List<ApduServiceInfo> validOtherServices =
+                mCardEmulation.getServices(CATEGORY_OTHER, userId);
+        if (validOtherServices == null || validOtherServices.isEmpty()) {
+            Log.i(TAG, "No installed other services");
+            return;
+        }
+        UserServices userServices = findOrCreateUserLocked(userId);
+        for (ApduServiceInfo service : validOtherServices) {
+            if (!service.hasCategory(CATEGORY_OTHER)) {
+                Log.e(TAG, "service does not have other category");
+                continue;
+            }
+            ComponentName component = service.getComponent();
+            OtherServiceStatus status = userServices.others.get(component);
+            if (status != null) {
+                try {
+                    Method setServiceEnabledForCategoryOtherMethod =
+                            CardEmulation.class.getMethod(
+                                    "setServiceEnabledForCategoryOther", ComponentName.class,
+                                    boolean.class, int.class);
+                    Log.d(TAG, "setServiceEnabledForCategoryOther: " + component + " = "
+                        + status.checked);
+                    setServiceEnabledForCategoryOtherMethod.invoke(
+                            mCardEmulation, component, status.checked, userId);
+                    // TODO: Add formal API
+                    // mCardEmulation.setServiceEnabledForCategoryOther(
+                    //      component, status.checked, userId);
+                } catch (Exception e) {
+                    Log.e(TAG, "Failed to set other service status", e);
+
+                }
+            }
+        }
+    }
+
+    private Map<Integer, List<Pair<ComponentName, DynamicSettings>>>
+    readDynamicSettingsFromFile(SettingsFile settingsFile) {
+        Log.d(TAG, "Reading dynamic AIDs.");
+        Map<Integer, List<Pair<ComponentName, DynamicSettings>>> readSettingsMap =
+                new HashMap<>();
+        InputStream fis = null;
+        try {
+            if (!settingsFile.exists()) {
+                Log.d(TAG, "Dynamic AIDs file does not exist.");
+                return new HashMap<>();
+            }
+            fis = settingsFile.openRead();
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(fis, null);
+            int eventType = parser.getEventType();
+            while (eventType != XmlPullParser.START_TAG &&
+                    eventType != XmlPullParser.END_DOCUMENT) {
+                eventType = parser.next();
+            }
+            String tagName = parser.getName();
+            if ("services".equals(tagName)) {
+                boolean inService = false;
+                ComponentName currentComponent = null;
+                int currentUid = -1;
+                String currentOffHostSE = null;
+                String shouldDefaultToObserveModeStr = null;
+                ArrayList<AidGroup> currentGroups = new ArrayList<AidGroup>();
+                while (eventType != XmlPullParser.END_DOCUMENT) {
+                    tagName = parser.getName();
+                    if (eventType == XmlPullParser.START_TAG) {
+                        if ("service".equals(tagName) && parser.getDepth() == 2) {
+                            String compString = parser.getAttributeValue(null, "component");
+                            String uidString = parser.getAttributeValue(null, "uid");
+                            String offHostString
+                                    = parser.getAttributeValue(null, "offHostSE");
+                            shouldDefaultToObserveModeStr =
+                                    parser.getAttributeValue(null, "shouldDefaultToObserveMode");
+                            if (compString == null || uidString == null) {
+                                Log.e(TAG, "Invalid service attributes");
+                            } else {
+                                try {
+                                    currentUid = Integer.parseInt(uidString);
+                                    currentComponent = ComponentName
+                                            .unflattenFromString(compString);
+                                    currentOffHostSE = offHostString;
+                                    inService = true;
+                                } catch (NumberFormatException e) {
+                                    Log.e(TAG, "Could not parse service uid");
+                                }
+                            }
+                        }
+                        if ("aid-group".equals(tagName) && parser.getDepth() == 3 && inService) {
+                            AidGroup group = AidGroup.createFromXml(parser);
+                            if (group != null) {
+                                currentGroups.add(group);
+                            } else {
+                                Log.e(TAG, "Could not parse AID group.");
+                            }
+                        }
+                    } else if (eventType == XmlPullParser.END_TAG) {
+                        if ("service".equals(tagName)) {
+                            // See if we have a valid service
+                            if (currentComponent != null && currentUid >= 0 &&
+                                    (currentGroups.size() > 0 || currentOffHostSE != null)) {
+                                final int userId = UserHandle.
+                                        getUserHandleForUid(currentUid).getIdentifier();
+                                Log.d(TAG, " ## user id - " + userId);
+                                DynamicSettings dynSettings = new DynamicSettings(currentUid);
+                                for (AidGroup group : currentGroups) {
+                                    dynSettings.aidGroups.put(group.getCategory(), group);
+                                }
+                                dynSettings.offHostSE = currentOffHostSE;
+                                dynSettings.shouldDefaultToObserveModeStr
+                                        = shouldDefaultToObserveModeStr;
+                                if (!readSettingsMap.containsKey(userId)) {
+                                    readSettingsMap.put(userId, new ArrayList<>());
+                                }
+                                readSettingsMap.get(userId)
+                                        .add(new Pair<>(currentComponent, dynSettings));
+                            }
+                            currentUid = -1;
+                            currentComponent = null;
+                            currentGroups.clear();
+                            inService = false;
+                            currentOffHostSE = null;
+                        }
+                    }
+                    eventType = parser.next();
+                };
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Could not parse dynamic AIDs file, trashing.", e);
+            settingsFile.delete();
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+        return readSettingsMap;
+    }
+
+    private void readDynamicSettingsLocked() {
+        Map<Integer, List<Pair<ComponentName, DynamicSettings>>> readSettingsMap
+                = readDynamicSettingsFromFile(mDynamicSettingsFile);
+        for(Integer userId: readSettingsMap.keySet()) {
+            UserServices services = findOrCreateUserLocked(userId);
+            List<Pair<ComponentName, DynamicSettings>> componentNameDynamicServiceStatusPairs
+                    = readSettingsMap.get(userId);
+            int pairsSize = componentNameDynamicServiceStatusPairs.size();
+            for(int i = 0; i < pairsSize; i++) {
+                Pair<ComponentName, DynamicSettings> pair
+                        = componentNameDynamicServiceStatusPairs.get(i);
+                services.dynamicSettings.put(pair.first, pair.second);
+            }
+        }
+    }
+
+    private Map<Integer, List<Pair<ComponentName, OtherServiceStatus>>>
+    readOtherFromFile(SettingsFile settingsFile) {
+        Map<Integer, List<Pair<ComponentName, OtherServiceStatus>>> readSettingsMap =
+                new HashMap<>();
+        Log.d(TAG, "read others locked");
+
+        InputStream fis = null;
+        try {
+            if (!settingsFile.exists()) {
+                Log.d(TAG, "Other settings file does not exist.");
+                return new HashMap<>();
+            }
+            fis = settingsFile.openRead();
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(fis, null);
+            int eventType = parser.getEventType();
+            while (eventType != XmlPullParser.START_TAG &&
+                    eventType != XmlPullParser.END_DOCUMENT) {
+                eventType = parser.next();
+            }
+            String tagName = parser.getName();
+            if ("services".equals(tagName)) {
+                boolean checked = false;
+                ComponentName currentComponent = null;
+                int currentUid = -1;
+
+                while (eventType != XmlPullParser.END_DOCUMENT) {
+                    tagName = parser.getName();
+                    if (eventType == XmlPullParser.START_TAG) {
+                        if ("service".equals(tagName) && parser.getDepth() == 2) {
+                            String compString = parser.getAttributeValue(null, "component");
+                            String uidString = parser.getAttributeValue(null, "uid");
+                            String checkedString = parser.getAttributeValue(null, "checked");
+                            if (compString == null || uidString == null || checkedString == null) {
+                                Log.e(TAG, "Invalid service attributes");
+                            } else {
+                                try {
+                                    currentUid = Integer.parseInt(uidString);
+                                    currentComponent =
+                                            ComponentName.unflattenFromString(compString);
+                                    checked = checkedString.equals("true") ? true : false;
+                                } catch (NumberFormatException e) {
+                                    Log.e(TAG, "Could not parse service uid");
+                                }
+                            }
+                        }
+                    } else if (eventType == XmlPullParser.END_TAG) {
+                        if ("service".equals(tagName)) {
+                            // See if we have a valid service
+                            if (currentComponent != null && currentUid >= 0) {
+                                Log.d(TAG, " end of service tag");
+                                final int userId =
+                                        UserHandle.getUserHandleForUid(currentUid).getIdentifier();
+                                OtherServiceStatus status =
+                                        new OtherServiceStatus(currentUid, checked);
+                                Log.d(TAG, " ## user id - " + userId);
+                                if (!readSettingsMap.containsKey(userId)) {
+                                    readSettingsMap.put(userId, new ArrayList<>());
+                                }
+                                readSettingsMap.get(userId)
+                                        .add(new Pair<>(currentComponent, status));
+                            }
+                            currentUid = -1;
+                            currentComponent = null;
+                            checked = false;
+                        }
+                    }
+                    eventType = parser.next();
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Could not parse others AIDs file, trashing.", e);
+            settingsFile.delete();
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    // It is safe to ignore I/O exceptions when closing FileInputStream
+                }
+            }
+        }
+        return readSettingsMap;
+    }
+
+    private void readOthersLocked() {
+        Map<Integer, List<Pair<ComponentName, OtherServiceStatus>>> readSettingsMap
+                = readOtherFromFile(mOthersFile);
+        for(Integer userId: readSettingsMap.keySet()) {
+            UserServices services = findOrCreateUserLocked(userId);
+            List<Pair<ComponentName, OtherServiceStatus>> componentNameOtherServiceStatusPairs
+                    = readSettingsMap.get(userId);
+            int pairsSize = componentNameOtherServiceStatusPairs.size();
+            for(int i = 0; i < pairsSize; i++) {
+                Pair<ComponentName, OtherServiceStatus> pair
+                        = componentNameOtherServiceStatusPairs.get(i);
+                services.others.put(pair.first,
+                        pair.second);
+            }
+        }
+    }
+}
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 1bc8a166..2d7db09d 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -1,5 +1,8 @@
 {
   "presubmit": [
+    {
+      "name": "NfcTestCases"
+    },
     {
       "name": "CtsNfcTestCases"
     },
@@ -11,9 +14,6 @@
     }
   ],
   "postsubmit": [
-    {
-      "name": "NfcTestCases"
-    },
     {
       "name": "NfcNciInstrumentationTests",
       "keywords": ["primary-device"]
@@ -23,7 +23,7 @@
       "keywords": ["primary-device"]
     },
     {
-      "name": "nfc.nci.jni.tests",
+      "name": "libnfc-nci-jni-tests",
       "keywords": ["primary-device"]
     }
   ],
diff --git a/apex/Android.bp b/apex/Android.bp
index 0ffbd56b..d540d560 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -44,6 +44,9 @@ custom_apex {
     name: "com.android.nfcservices",
     manifest: "manifest.json",
     apps: ["NfcNciApex"],
+    defaults: ["b-launched-apex-module"],
+    updatable: false, // TODO: fix this.
+    min_sdk_version: "35", // Make it 36 once available.
     multilib: {
         first: {
             // Extractor process runs only with the primary ABI.
@@ -63,9 +66,18 @@ custom_apex {
         // does not ship one in /product
         "libnfc-nci.conf-default",
     ],
+    file_contexts: ":com.android.nfcservices-file_contexts",
     key: "com.android.nfcservices.key",
     certificate: ":com.android.nfcservices.certificate",
-    updatable: false,
+}
+
+sdk {
+    name: "nfcservices-module-sdk",
+    apexes: [
+        // Adds exportable dependencies of the APEX to the sdk,
+        // e.g. *classpath_fragments.
+        "com.android.nfcservices",
+    ],
 }
 
 soong_config_module_type {
diff --git a/com.android.nfc.xml b/com.android.nfc.xml
index 8bb6b14a..b2790604 100644
--- a/com.android.nfc.xml
+++ b/com.android.nfc.xml
@@ -36,5 +36,6 @@
         <permission name="android.permission.QUERY_CLONED_APPS"/>
         <permission name="android.permission.READ_PRIVILEGED_PHONE_STATE"/>
         <permission name="android.permission.MODIFY_PHONE_STATE"/>
+        <permission name="android.permission.WRITE_SECURITY_LOG"/>
     </privapp-permissions>
 </permissions>
diff --git a/flags/Android.bp b/flags/Android.bp
index 8a201f1a..14e83d40 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -20,38 +20,26 @@ package {
 }
 
 aconfig_declarations {
-    name: "nfc_aconfig_flags",
+    name: "com.android.nfc.flags-aconfig",
     package: "com.android.nfc.flags",
     container: "system",
-    srcs: ["nfc_flags.aconfig"],
+    srcs: ["*_flags.aconfig"],
 }
 
 java_aconfig_library {
-    name: "nfc_aconfig_flags_lib",
-    aconfig_declarations: "nfc_aconfig_flags",
-    min_sdk_version: "33",
-    apex_available: [
-        "//apex_available:platform",
-        "com.android.nfcservices",
-    ],
-}
-
-java_library {
-    name: "nfc_flags_lib",
-    sdk_version: "system_current",
-    min_sdk_version: "33",
-    srcs: [
-        "lib/**/*.java",
-    ],
-    static_libs: [
-        "nfc_aconfig_flags_lib",
-    ],
+    name: "com.android.nfc.flags-aconfig-java",
+    aconfig_declarations: "com.android.nfc.flags-aconfig",
+    sdk_version: "module_current",
+    min_sdk_version: "35",
     installable: false,
+    libs: ["framework-configinfrastructure.stubs.module_lib"],
     visibility: [
+        "//cts/tests/tests/nfc:__subpackages__",
         "//packages/apps/Nfc:__subpackages__",
     ],
     apex_available: [
-        "//apex_available:platform",
         "com.android.nfcservices",
     ],
 }
+
+
diff --git a/flags/multiple_services_flags.aconfig b/flags/multiple_services_flags.aconfig
new file mode 100644
index 00000000..4a5ba84f
--- /dev/null
+++ b/flags/multiple_services_flags.aconfig
@@ -0,0 +1,9 @@
+package: "com.android.nfc.flags"
+container: "system"
+
+flag {
+    name: "allow_multiple_hce_bindings"
+    namespace: "nfc"
+    description: "Allow HostEmulationManager to bind to multiple non-payment services at a time"
+    bug: "365533082"
+}
\ No newline at end of file
diff --git a/flags/nfc_flags.aconfig b/flags/nfc_flags.aconfig
index c52b4466..618bdfb9 100644
--- a/flags/nfc_flags.aconfig
+++ b/flags/nfc_flags.aconfig
@@ -53,3 +53,31 @@ flag {
     description: "Enable setting obseve mode state with out deactivating RF"
     bug: "368655283"
 }
+
+flag {
+    name: "post_callbacks"
+    namespace: "nfc"
+    description: "Post callbacks to CardEmulationManager to handler to get off of NFC callback thread."
+    bug: "370015438"
+}
+
+flag {
+    name: "ee_aid_select"
+    namespace: "nfc"
+    description: "Propigate NFA_EE_ACTION_EVT->NFC_EE_TRIG_SELECT up to onOffHostAidSelected()"
+    bug: "323440961"
+}
+
+flag {
+    name: "check_passed_in_package"
+    namespace: "nfc"
+    description: "Enable checking package name in nfc service"
+    bug: "364020298"
+}
+
+flag {
+    name: "nfc_alert_tag_app_launch"
+    namespace: "nfc"
+    description: "Notify user when tag app launched for the first time"
+    bug: "312390070"
+}
diff --git a/flags/use_device_lock_listener_flags.aconfig b/flags/use_device_lock_listener_flags.aconfig
new file mode 100644
index 00000000..bc683201
--- /dev/null
+++ b/flags/use_device_lock_listener_flags.aconfig
@@ -0,0 +1,9 @@
+package: "com.android.nfc.flags"
+container: "system"
+
+flag {
+    name: "use_device_lock_listener"
+    namespace: "wallet_integration"
+    description: "Use the device lock lock listener for secure NFC."
+    bug: "286735637"
+}
\ No newline at end of file
diff --git a/flags/wallet_integration_flags.aconfig b/flags/wallet_integration_flags.aconfig
new file mode 100644
index 00000000..4c2b4417
--- /dev/null
+++ b/flags/wallet_integration_flags.aconfig
@@ -0,0 +1,16 @@
+package: "com.android.nfc.flags"
+container: "system"
+
+flag {
+    name: "coalesce_rf_events"
+    namespace: "wallet_integration"
+    description: "Combine RF field activated and deactivated events to reduce excessive broadcasts."
+    bug: "365533082"
+}
+
+flag {
+    name: "exit_frames"
+    namespace: "wallet_integration"
+    description: "Enable exit frames to improve autotransact performance."
+    bug: "380455428"
+}
\ No newline at end of file
diff --git a/jarjar-rules.txt b/jarjar-rules.txt
index 677424a0..b35c921d 100644
--- a/jarjar-rules.txt
+++ b/jarjar-rules.txt
@@ -41,3 +41,10 @@ rule android.os.PersistableBundleProto* com.android.nfc.x.@0
 
 # Core utils available for modules
 rule com.android.modules.utils.** com.android.nfc.x.@0
+
+# Used for reading trunk stable flags
+rule android.app.*Flags* com.android.nfc.x.@0
+rule android.app.Flags com.android.nfc.x.@0
+rule android.service.chooser.*Flags* com.android.nfc.x.@0
+rule android.service.chooser.Flags com.android.nfc.x.@0
+rule android.permission.flags.** com.android.nfc.x.@0
diff --git a/lint-baseline.xml b/lint-baseline.xml
index 6a5981b0..9c164d8a 100644
--- a/lint-baseline.xml
+++ b/lint-baseline.xml
@@ -1,1744 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <issues format="6" by="lint 8.4.0-alpha01" type="baseline" client="" dependencies="true" name="" variant="all" version="8.4.0-alpha01">
 
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                UserHandle.getUserHandleForUid(info.serviceInfo.getUid()).getIdentifier(),"
-        errorLine2="                                                                ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="181"
-            column="65"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                info.serviceInfo.getComponent());"
-        errorLine2="                                 ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="182"
-            column="34"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Cast from `ApduServiceInfo` to `Parcelable` requires API level 35 (current min is 34)"
-        errorLine1="        dialogIntent.putExtra(TapAgainDialog.EXTRA_APDU_SERVICE, info.serviceInfo);"
-        errorLine2="                                                                 ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="185"
-            column="66"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getDescription`"
-        errorLine1="                CharSequence label = service.getDescription();"
-        errorLine2="                                             ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="217"
-            column="46"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#loadLabel`"
-        errorLine1="                if (label == null) label = service.loadLabel(pm);"
-        errorLine2="                                                   ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="218"
-            column="52"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#loadIcon`"
-        errorLine1="                Drawable icon = pm.getUserBadgedIcon(service.loadIcon(pm),"
-        errorLine2="                                                             ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="220"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                        UserHandle.getUserHandleForUid(service.getUid()));"
-        errorLine2="                                                               ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="221"
-            column="64"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#loadBanner`"
-        errorLine1="                    banner = service.loadBanner(pm);"
-        errorLine2="                                     ~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/AppChooserActivity.java"
-            line="225"
-            column="38"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#hasCategory`"
-        errorLine1="                if (service.hasCategory(CardEmulation.CATEGORY_PAYMENT)"
-        errorLine2="                            ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/CardEmulationManager.java"
-            line="372"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                            &amp;&amp; wasServicePreInstalled(pm, service.getComponent())) {"
-        errorLine2="                                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/CardEmulationManager.java"
-            line="373"
-            column="67"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                    lastFoundPaymentService = service.getComponent();"
-        errorLine2="                                                      ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/CardEmulationManager.java"
-            line="375"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getSystemCode`"
-        errorLine1='                if (serviceInfo.getSystemCode().equalsIgnoreCase("NULL") ||'
-        errorLine2="                                ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/EnabledNfcFServices.java"
-            line="130"
-            column="33"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1='                        serviceInfo.getNfcid2().equalsIgnoreCase("NULL") ||'
-        errorLine2="                                    ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/EnabledNfcFServices.java"
-            line="131"
-            column="37"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getT3tPmm`"
-        errorLine1='                        serviceInfo.getT3tPmm().equalsIgnoreCase("NULL")) {'
-        errorLine2="                                    ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/EnabledNfcFServices.java"
-            line="132"
-            column="37"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                        mStatsdUtils.setCardEmulationEventUid(defaultServiceInfo.getUid());"
-        errorLine2="                                                                                 ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="247"
-            column="82"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresUnlock`"
-        errorLine1="                    if ((defaultServiceInfo.requiresUnlock()"
-        errorLine2="                                            ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="250"
-            column="45"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                    if (defaultServiceInfo.requiresScreenOn() &amp;&amp; !mPowerManager.isScreenOn()) {"
-        errorLine2="                                           ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="262"
-            column="44"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="                    if (!defaultServiceInfo.isOnHost()) {"
-        errorLine2="                                            ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="272"
-            column="45"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                    resolvedService = defaultServiceInfo.getComponent();"
-        errorLine2="                                                         ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="281"
-            column="58"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                        if (mActiveServiceName.equals(serviceInfo.getComponent())) {"
-        errorLine2="                                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="285"
-            column="67"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                        int uid = resolvedServiceInfo.getUid();"
-        errorLine2="                                                      ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="310"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                                UserHandle.getUserHandleForUid(resolvedServiceInfo.getUid());"
-        errorLine2="                                                                                   ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="354"
-            column="84"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Cast from `ApduServiceInfo` to `Parcelable` requires API level 35 (current min is 34)"
-        errorLine1="        dialogIntent.putExtra(TapAgainDialog.EXTRA_APDU_SERVICE, service);"
-        errorLine2="                                                                 ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="557"
-            column="66"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                UserHandle.getUserHandleForUid(service.getUid()));"
-        errorLine2="                                                       ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostEmulationManager.java"
-            line="560"
-            column="56"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1="                    resolvedServiceName = resolvedService.getComponent();"
-        errorLine2="                                                          ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostNfcFEmulationManager.java"
-            line="124"
-            column="59"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="                    int uid = resolvedService != null ? resolvedService.getUid() : -1;"
-        errorLine2="                                                                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/HostNfcFEmulationManager.java"
-            line="146"
-            column="73"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.service.chooser.CustomChoosers#createNfcResolverIntent`"
-        errorLine1="                                CustomChoosers.createNfcResolverIntent(intent, null, filtered);"
-        errorLine2="                                               ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/NfcDispatcher.java"
-            line="312"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.service.chooser.CustomChoosers#createNfcResolverIntent`"
-        errorLine1="                intent = CustomChoosers.createNfcResolverIntent("
-        errorLine2="                                        ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/NfcDispatcher.java"
-            line="921"
-            column="41"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.se.omapi.SeFrameworkInitializer#getSeServiceManager`"
-        errorLine1="            SeServiceManager manager = SeFrameworkInitializer.getSeServiceManager();"
-        errorLine2="                                                              ~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/NfcService.java"
-            line="938"
-            column="63"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.se.omapi.SeServiceManager#getSeManagerServiceRegisterer`"
-        errorLine1="                    manager.getSeManagerServiceRegisterer().get());"
-        errorLine2="                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/NfcService.java"
-            line="944"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.se.omapi.SeServiceManager.ServiceRegisterer#get`"
-        errorLine1="                    manager.getSeManagerServiceRegisterer().get());"
-        errorLine2="                                                            ~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/NfcService.java"
-            line="944"
-            column="61"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#hasCategory`"
-        errorLine1="            if (serviceInfo.hasCategory(CardEmulation.CATEGORY_PAYMENT)) {"
-        errorLine2="                            ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/PreferredServices.java"
-            line="301"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getAids`"
-        errorLine1="            final List&lt;String&gt; otherAids = serviceInfo.getAids();"
-        errorLine2="                                                       ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/PreferredServices.java"
-            line="311"
-            column="56"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                    "service=" + service.getComponent() +'
-        errorLine2="                                         ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="92"
-            column="42"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="            return service.equals(resolveInfo.defaultService.getComponent());"
-        errorLine2="                                                             ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="249"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="            return service.equals(resolveInfo.services.get(0).getComponent());"
-        errorLine2="                                                              ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="251"
-            column="63"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            int userId = UserHandle.getUserHandleForUid(serviceAidInfo.service.getUid())"
-        errorLine2="                                                                               ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="292"
-            column="80"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="            ComponentName componentName = serviceAidInfo.service.getComponent();"
-        errorLine2="                                                                 ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="294"
-            column="66"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                        serviceAidInfo.service.getComponent()"
-        errorLine2="                                               ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="307"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                            serviceAidInfo.service.getComponent() +"
-        errorLine2="                                                   ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="325"
-            column="52"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isCategoryOtherServiceEnabled`"
-        errorLine1="                    if (serviceAidInfo.service.isCategoryOtherServiceEnabled()) {"
-        errorLine2="                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="328"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                        if (DBG) Log.d(TAG, serviceAidInfo.service.getComponent() +"
-        errorLine2="                                                                   ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="329"
-            column="68"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                                defaultWalletServices.get(0).getComponent() + " default.");'
-        errorLine2="                                                             ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="350"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                        resolveInfo.services.get(0).getComponent() + " default.");'
-        errorLine2="                                                    ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="362"
-            column="53"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            int userId = UserHandle.getUserHandleForUid(serviceAidInfo.service.getUid())"
-        errorLine2="                                                                               ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="384"
-            column="80"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="            ComponentName componentName = serviceAidInfo.service.getComponent();"
-        errorLine2="                                                                 ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="386"
-            column="66"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                    serviceAidInfo.service.getComponent()"
-        errorLine2="                                           ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="392"
-            column="44"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                    aidDefaultInfo.foregroundDefault.service.getComponent() + " has foreground" +'
-        errorLine2="                                                             ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="419"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                    aidDefaultInfo.paymentDefault.service.getComponent() + " is payment" +'
-        errorLine2="                                                          ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="458"
-            column="59"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                if (DBG) Log.d(TAG, "generateServiceMap component: " + service.getComponent());'
-        errorLine2="                                                                               ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="526"
-            column="80"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getPrefixAids`"
-        errorLine1="                List&lt;String&gt; prefixAids = service.getPrefixAids();"
-        errorLine2="                                                  ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="527"
-            column="51"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getSubsetAids`"
-        errorLine1="                List&lt;String&gt; subSetAids = service.getSubsetAids();"
-        errorLine2="                                                  ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="528"
-            column="51"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getAids`"
-        errorLine1="                for (String aid : service.getAids()) {"
-        errorLine2="                                          ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="530"
-            column="43"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getCategoryForAid`"
-        errorLine1="                    serviceAidInfo.category = service.getCategoryForAid(aid);"
-        errorLine2="                                                      ~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="580"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getPrefixAids`"
-        errorLine1="            for (String prefixAid : service.getPrefixAids()) {"
-        errorLine2="                                            ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="632"
-            column="45"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                       int userId = UserHandle.getUserHandleForUid(service.getUid())"
-        errorLine2="                                                                           ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="637"
-            column="76"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getCategoryForAid`"
-        errorLine1="                               .equals(service.getCategoryForAid(prefixAid)) ||"
-        errorLine2="                                               ~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="640"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                               (service.getComponent().equals(mPreferredForegroundService) &amp;&amp;"
-        errorLine2="                                        ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="641"
-            column="41"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getSubsetAids`"
-        errorLine1="                    for (String aid : resolveInfo.defaultService.getSubsetAids()) {"
-        errorLine2="                                                                 ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="756"
-            column="66"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                                    getUserHandleForUid(resolveInfo.defaultService.getUid())."
-        errorLine2="                                                                                   ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="759"
-            column="84"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getCategoryForAid`"
-        errorLine1="                                  equals(resolveInfo.defaultService.getCategoryForAid(aid))) ||"
-        errorLine2="                                                                    ~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="762"
-            column="69"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                                    (resolveInfo.defaultService.getComponent()."
-        errorLine2="                                                                ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="763"
-            column="65"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="                aidType.isOnHost = resolveInfo.defaultService.isOnHost();"
-        errorLine2="                                                              ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="982"
-            column="63"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getOffHostSecureElement`"
-        errorLine1="                            resolveInfo.defaultService.getOffHostSecureElement();"
-        errorLine2="                                                       ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="985"
-            column="56"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresUnlock`"
-        errorLine1="                boolean requiresUnlock = resolveInfo.defaultService.requiresUnlock();"
-        errorLine2="                                                                    ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="988"
-            column="69"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                boolean requiresScreenOn = resolveInfo.defaultService.requiresScreenOn();"
-        errorLine2="                                                                      ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="989"
-            column="71"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="                    aidType.isOnHost = resolveInfo.services.get(0).isOnHost();"
-        errorLine2="                                                                   ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1002"
-            column="68"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getOffHostSecureElement`"
-        errorLine1="                                resolveInfo.services.get(0).getOffHostSecureElement();"
-        errorLine2="                                                            ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1005"
-            column="61"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresUnlock`"
-        errorLine1="                boolean requiresUnlock = resolveInfo.services.get(0).requiresUnlock();"
-        errorLine2="                                                                     ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1009"
-            column="70"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                boolean requiresScreenOn = resolveInfo.services.get(0).requiresScreenOn();"
-        errorLine2="                                                                       ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1010"
-            column="72"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="                    onHost |= service.isOnHost();"
-        errorLine2="                                      ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1026"
-            column="39"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getOffHostSecureElement`"
-        errorLine1="                            offHostSE = service.getOffHostSecureElement();"
-        errorLine2="                                                ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1029"
-            column="49"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresUnlock`"
-        errorLine1="                            requiresUnlock = service.requiresUnlock();"
-        errorLine2="                                                     ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1030"
-            column="54"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                            requiresScreenOn = service.requiresScreenOn();"
-        errorLine2="                                                       ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1031"
-            column="56"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getOffHostSecureElement`"
-        errorLine1="                                service.getOffHostSecureElement())) {"
-        errorLine2="                                        ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1033"
-            column="41"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresUnlock`"
-        errorLine1="                        } else if (requiresUnlock != service.requiresUnlock()"
-        errorLine2="                                                             ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1041"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                                || requiresScreenOn != service.requiresScreenOn()) {"
-        errorLine2="                                                               ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1042"
-            column="64"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#requiresScreenOn`"
-        errorLine1="                    requiresScreenOnServiceExist |= service.requiresScreenOn();"
-        errorLine2="                                                            ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1053"
-            column="61"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                defaultServiceInfo.getComponent() : null;"
-        errorLine2="                                   ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1148"
-            column="36"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getDescription`"
-        errorLine1='                    " (Description: " + serviceInfo.getDescription() + ")\n");'
-        errorLine2="                                                    ~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1156"
-            column="53"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                    defaultServiceInfo.getComponent() : null;"
-        errorLine2="                                       ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1191"
-            column="40"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#dumpDebug`"
-        errorLine1="                serviceInfo.dumpDebug(proto);"
-        errorLine2="                            ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredAidCache.java"
-            line="1199"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1="            if (service.getComponent().equals(componentName)) return true;"
-        errorLine2="                        ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="209"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `new android.nfc.cardemulation.NfcFServiceInfo`"
-        errorLine1="                NfcFServiceInfo service = new NfcFServiceInfo(pm, resolvedService);"
-        errorLine2="                                          ~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="270"
-            column="43"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1="                userServices.services.put(service.getComponent(), service);"
-        errorLine2="                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="334"
-            column="51"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1='                if (DBG) Log.d(TAG, "Added service: " + service.getComponent());'
-        errorLine2="                                                                ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="335"
-            column="65"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1="                userServices.services.remove(service.getComponent());"
-        errorLine2="                                                     ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="338"
-            column="54"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1='                if (DBG) Log.d(TAG, "Removed service: " + service.getComponent());'
-        errorLine2="                                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="339"
-            column="67"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="                if (service == null || (service.getUid() != dynamicSystemCode.uid)) {"
-        errorLine2="                                                ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="350"
-            column="49"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#setDynamicSystemCode`"
-        errorLine1="                    service.setDynamicSystemCode(dynamicSystemCode.systemCode);"
-        errorLine2="                            ~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="354"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="                if (service == null || (service.getUid() != dynamicNfcid2.uid)) {"
-        errorLine2="                                                ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="366"
-            column="49"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#setDynamicNfcid2`"
-        errorLine1="                    service.setDynamicNfcid2(dynamicNfcid2.nfcid2);"
-        errorLine2="                            ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="370"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1='                if (service.getNfcid2().equalsIgnoreCase("RANDOM")) {'
-        errorLine2="                            ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="388"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#setDynamicNfcid2`"
-        errorLine1="                    service.setDynamicNfcid2(randomNfcid2);"
-        errorLine2="                            ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="390"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="                            new DynamicNfcid2(service.getUid(), randomNfcid2);"
-        errorLine2="                                                      ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="392"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="            if (service.getUid() != uid) {"
-        errorLine2="                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="564"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#setDynamicSystemCode`"
-        errorLine1="                service.setDynamicSystemCode(systemCode);"
-        errorLine2="                        ~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="585"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="            if (service.getUid() != uid) {"
-        errorLine2="                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="608"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getSystemCode`"
-        errorLine1="            return service.getSystemCode();"
-        errorLine2="                           ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="612"
-            column="28"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="            if (service.getUid() != uid) {"
-        errorLine2="                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="641"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#setDynamicNfcid2`"
-        errorLine1="                service.setDynamicNfcid2(nfcid2);"
-        errorLine2="                        ~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="660"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getUid`"
-        errorLine1="            if (service.getUid() != uid) {"
-        errorLine2="                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="683"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1="            return service.getNfcid2();"
-        errorLine2="                           ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="687"
-            column="28"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#dump`"
-        errorLine1="                        service.dump(pFd, pw, args);"
-        errorLine2="                                ~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="765"
-            column="33"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#dumpDebug`"
-        errorLine1="                service.dumpDebug(proto);"
-        errorLine2="                        ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredNfcFServicesCache.java"
-            line="791"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="            if (service.getComponent().equals(serviceName)) return true;"
-        errorLine2="                        ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="261"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#hasCategory`"
-        errorLine1="                if (service.hasCategory(category)) services.add(service);"
-        errorLine2="                            ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="291"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `new android.nfc.cardemulation.ApduServiceInfo`"
-        errorLine1="                ApduServiceInfo service = new ApduServiceInfo(pm, resolvedService, onHost);"
-        errorLine2="                                          ~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="344"
-            column="43"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                if (DEBUG) Log.d(TAG, "Adding service: " + service.getComponent() +'
-        errorLine2="                                                                   ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="381"
-            column="68"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getAids`"
-        errorLine1='                        " AIDs: " + service.getAids());'
-        errorLine2="                                            ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="382"
-            column="45"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                userServices.services.put(service.getComponent(), service);"
-        errorLine2="                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="383"
-            column="51"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                if (serviceInfo == null || (serviceInfo.getUid() != dynamicSettings.uid)) {"
-        errorLine2="                                                        ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="394"
-            column="57"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setDynamicAidGroup`"
-        errorLine1="                        serviceInfo.setDynamicAidGroup(group);"
-        errorLine2="                                    ~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="399"
-            column="37"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setOffHostSecureElement`"
-        errorLine1="                        serviceInfo.setOffHostSecureElement(dynamicSettings.offHostSE);"
-        errorLine2="                                    ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="402"
-            column="37"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='                Log.d(TAG, "update valid otherService: " + service.getComponent()'
-        errorLine2="                                                                   ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="455"
-            column="68"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getAids`"
-        errorLine1='                        + " AIDs: " + service.getAids());'
-        errorLine2="                                              ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="456"
-            column="47"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#hasCategory`"
-        errorLine1="                if (!service.hasCategory(CardEmulation.CATEGORY_OTHER)) {"
-        errorLine2="                             ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="457"
-            column="30"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="                ComponentName component = service.getComponent();"
-        errorLine2="                                                  ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="462"
-            column="51"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                    status = new OtherServiceStatus(service.getUid(), isChecked);"
-        errorLine2="                                                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="467"
-            column="61"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setCategoryOtherServiceEnabled`"
-        errorLine1="                service.setCategoryOtherServiceEnabled(status.checked);"
-        errorLine2="                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="472"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#createFromXml`"
-        errorLine1="                            AidGroup group = AidGroup.createFromXml(parser);"
-        errorLine2="                                                      ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="545"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#getCategory`"
-        errorLine1="                                    dynSettings.aidGroups.put(group.getCategory(), group);"
-        errorLine2="                                                                    ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="561"
-            column="69"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#writeAsXml`"
-        errorLine1="                        group.writeAsXml(out);"
-        errorLine2="                              ~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="690"
-            column="31"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            if (serviceInfo.getUid() != uid) {"
-        errorLine2="                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="778"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="            if (offHostSE == null || serviceInfo.isOnHost()) {"
-        errorLine2="                                                 ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="786"
-            column="50"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setOffHostSecureElement`"
-        errorLine1="            serviceInfo.setOffHostSecureElement(offHostSE);"
-        errorLine2="                        ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="803"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            if (serviceInfo.getUid() != uid) {"
-        errorLine2="                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="821"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getOffHostSecureElement`"
-        errorLine1="            if (serviceInfo.isOnHost() || serviceInfo.getOffHostSecureElement() == null) {"
-        errorLine2="                                                      ~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="829"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isOnHost`"
-        errorLine1="            if (serviceInfo.isOnHost() || serviceInfo.getOffHostSecureElement() == null) {"
-        errorLine2="                            ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="829"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#resetOffHostSecureElement`"
-        errorLine1="            serviceInfo.resetOffHostSecureElement();"
-        errorLine2="                        ~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="844"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            if (serviceInfo.getUid() != uid) {"
-        errorLine2="                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="862"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            if (serviceInfo.getUid() != uid) {"
-        errorLine2="                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="893"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#getAids`"
-        errorLine1="            List&lt;String&gt; aids = aidGroup.getAids();"
-        errorLine2="                                         ~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="903"
-            column="42"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setDynamicAidGroup`"
-        errorLine1="            serviceInfo.setDynamicAidGroup(aidGroup);"
-        errorLine2="                        ~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="910"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#getCategory`"
-        errorLine1="            dynSettings.aidGroups.put(aidGroup.getCategory(), aidGroup);"
-        errorLine2="                                               ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="917"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.AidGroup#getCategory`"
-        errorLine1="                dynSettings.aidGroups.remove(aidGroup.getCategory());"
-        errorLine2="                                                      ~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="925"
-            column="55"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="            if (serviceInfo.getUid() != uid) {"
-        errorLine2="                            ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="974"
-            column="29"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getDynamicAidGroupForCategory`"
-        errorLine1="            return serviceInfo.getDynamicAidGroupForCategory(category);"
-        errorLine2="                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="978"
-            column="32"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                if (serviceInfo.getUid() != uid) {"
-        errorLine2="                                ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="993"
-            column="33"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#removeDynamicAidGroupForCategory`"
-        errorLine1="                if (!serviceInfo.removeDynamicAidGroupForCategory(category)) {"
-        errorLine2="                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="998"
-            column="34"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1="        OtherServiceStatus status = userServices.others.get(service.getComponent());"
-        errorLine2="                                                                    ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1036"
-            column="69"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getComponent`"
-        errorLine1='            Log.d(TAG, service.getComponent() + " status is could not be null");'
-        errorLine2="                               ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1039"
-            column="32"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#isCategoryOtherServiceEnabled`"
-        errorLine1="        if (service.isCategoryOtherServiceEnabled() == checked) {"
-        errorLine2="                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1043"
-            column="21"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#setCategoryOtherServiceEnabled`"
-        errorLine1="        service.setCategoryOtherServiceEnabled(checked);"
-        errorLine2="                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1048"
-            column="17"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#dump`"
-        errorLine1="                        service.dump(pFd, pw, args);"
-        errorLine2="                                ~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1066"
-            column="33"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#dumpDebug`"
-        errorLine1="            service.dumpDebug(proto);"
-        errorLine2="                    ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredServicesCache.java"
-            line="1091"
-            column="21"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1="                if (mEnabledForegroundService.equals(service.getComponent())) {"
-        errorLine2="                                                             ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="126"
-            column="62"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getSystemCode`"
-        errorLine1='                    if (!service.getSystemCode().equalsIgnoreCase("NULL") &amp;&amp;'
-        errorLine2="                                 ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="127"
-            column="34"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1='                            !service.getNfcid2().equalsIgnoreCase("NULL")) {'
-        errorLine2="                                     ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="128"
-            column="38"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1="                        mForegroundT3tIdentifiersCache.put(service.getNfcid2(), service);"
-        errorLine2="                                                                   ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="129"
-            column="68"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getComponent`"
-        errorLine1='                        "/" + entry.getValue().getComponent().toString());'
-        errorLine2="                                               ~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="142"
-            column="48"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getNfcid2`"
-        errorLine1="                    entry.getValue().getSystemCode(), entry.getValue().getNfcid2(), entry.getValue().getT3tPmm()));"
-        errorLine2="                                                                       ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="169"
-            column="72"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getSystemCode`"
-        errorLine1="                    entry.getValue().getSystemCode(), entry.getValue().getNfcid2(), entry.getValue().getT3tPmm()));"
-        errorLine2="                                     ~~~~~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="169"
-            column="38"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#getT3tPmm`"
-        errorLine1="                    entry.getValue().getSystemCode(), entry.getValue().getNfcid2(), entry.getValue().getT3tPmm()));"
-        errorLine2="                                                                                                     ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="169"
-            column="102"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#dump`"
-        errorLine1="                entry.getValue().dump(pFd, pw, args);"
-        errorLine2="                                 ~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="245"
-            column="34"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.NfcFServiceInfo#dumpDebug`"
-        errorLine1="            serviceInfo.dumpDebug(proto);"
-        errorLine2="                        ~~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/RegisteredT3tIdentifiersCache.java"
-            line="269"
-            column="25"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#loadIcon`"
-        errorLine1="        Drawable icon = pm.getUserBadgedIcon(serviceInfo.loadIcon(pm),"
-        errorLine2="                                                         ~~~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/TapAgainDialog.java"
-            line="85"
-            column="58"/>
-    </issue>
-
-    <issue
-        id="NewApi"
-        message="Call requires API level 35 (current min is 34): `android.nfc.cardemulation.ApduServiceInfo#getUid`"
-        errorLine1="                UserHandle.getUserHandleForUid(serviceInfo.getUid()));"
-        errorLine2="                                                           ~~~~~~">
-        <location
-            file="packages/apps/Nfc/src/com/android/nfc/cardemulation/TapAgainDialog.java"
-            line="86"
-            column="60"/>
-    </issue>
-
     <issue
         id="FlaggedApi"
         message="Method `updateForShouldDefaultToObserveMode()` is a flagged API and should be inside an `if (Flags.nfcObserveMode())` check (or annotate the surrounding method `updateForShouldDefaultToObserveMode` with `@FlaggedApi(Flags.FLAG_NFC_OBSERVE_MODE) to transfer requirement to caller`)"
@@ -2069,4 +331,4 @@
             column="21"/>
     </issue>
 
-</issues>
\ No newline at end of file
+</issues>
diff --git a/nci/jni/Android.bp b/nci/jni/Android.bp
index 5836aeb4..635a0c57 100644
--- a/nci/jni/Android.bp
+++ b/nci/jni/Android.bp
@@ -29,7 +29,7 @@ cc_defaults {
     ],
 
     srcs: ["**/*.cpp"],
-    exclude_srcs: ["NfcTagTest.cpp"],
+    exclude_srcs: ["**/*Test.cpp"],
 
     include_dirs: [
         "system/nfc/src/nfa/include",
@@ -96,12 +96,13 @@ cc_defaults {
         // does not ship one in /product
         "libnfc-nci.conf-default",
     ],
+    min_sdk_version: "35", // Make it 36 once available.
 }
 
 cc_test {
-    name: "nfc.nci.jni.tests",
+    name: "libnfc-nci-jni-tests",
 
-    srcs: ["NfcTagTest.cpp"],
+    srcs: ["**/*Test.cpp"],
 
     shared_libs: [
         "libnativehelper",
@@ -153,5 +154,22 @@ cc_test {
         "system/nfc/src/nfc/include",
         "system/nfc/utils/include",
     ],
-    test_suites: ["general-tests"],
+    test_suites: [
+        "general-tests",
+        "mts-nfc",
+    ],
+    test_config_template: "nfc_test_config_template.xml",
+    // Support multilib variants (using different suffix per sub-architecture), which is needed on
+    // build targets with secondary architectures, as the MTS test suite packaging logic flattens
+    // all test artifacts into a single `testcases` directory.
+    compile_multilib: "both",
+    multilib: {
+        lib32: {
+            suffix: "32",
+        },
+        lib64: {
+            suffix: "64",
+        },
+    },
+    auto_gen_config: true,
 }
diff --git a/nci/jni/DataQueueTest.cpp b/nci/jni/DataQueueTest.cpp
new file mode 100644
index 00000000..d0297311
--- /dev/null
+++ b/nci/jni/DataQueueTest.cpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include "DataQueue.h"
+
+// Define a test fixture class
+class DataQueueTest : public ::testing::Test {
+ protected:
+  DataQueue queue;
+};
+
+// Test isEmpty() when the queue is empty
+TEST_F(DataQueueTest, IsEmptyInitially) { ASSERT_TRUE(queue.isEmpty()); }
+
+// Test enqueue() and dequeue() with a single element
+TEST_F(DataQueueTest, EnqueueDequeueOneElement) {
+  uint8_t data[] = {1, 2, 3};
+  ASSERT_TRUE(queue.enqueue(data, sizeof(data)));
+  ASSERT_FALSE(queue.isEmpty());
+
+  uint8_t buffer[10];
+  uint16_t actualLen;
+  ASSERT_TRUE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+  ASSERT_EQ(actualLen, sizeof(data));
+  ASSERT_EQ(memcmp(buffer, data, sizeof(data)), 0);
+  ASSERT_TRUE(queue.isEmpty());
+}
+
+// Test enqueue() and dequeue() with multiple elements
+TEST_F(DataQueueTest, EnqueueDequeueMultipleElements) {
+  uint8_t data1[] = {1, 2, 3};
+  uint8_t data2[] = {4, 5, 6, 7};
+  ASSERT_TRUE(queue.enqueue(data1, sizeof(data1)));
+  ASSERT_TRUE(queue.enqueue(data2, sizeof(data2)));
+
+  uint8_t buffer[10];
+  uint16_t actualLen;
+  ASSERT_TRUE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+  ASSERT_EQ(actualLen, sizeof(data1));
+  ASSERT_EQ(memcmp(buffer, data1, sizeof(data1)), 0);
+
+  ASSERT_TRUE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+  ASSERT_EQ(actualLen, sizeof(data2));
+  ASSERT_EQ(memcmp(buffer, data2, sizeof(data2)), 0);
+  ASSERT_TRUE(queue.isEmpty());
+}
+
+// Test dequeue() with a buffer smaller than the data size
+TEST_F(DataQueueTest, DequeuePartial) {
+  uint8_t data[] = {1, 2, 3, 4, 5};
+  ASSERT_TRUE(queue.enqueue(data, sizeof(data)));
+
+  uint8_t buffer[3];  // Smaller buffer
+  uint16_t actualLen;
+  ASSERT_TRUE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+  ASSERT_EQ(actualLen, sizeof(buffer));
+  ASSERT_EQ(memcmp(buffer, data, sizeof(buffer)), 0);
+
+  ASSERT_TRUE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+  ASSERT_EQ(actualLen, 2);  // Remaining 2 bytes
+  ASSERT_EQ(memcmp(buffer, data + 3, 2), 0);
+  ASSERT_TRUE(queue.isEmpty());
+}
+
+// Test dequeue() with an empty queue
+TEST_F(DataQueueTest, DequeueEmpty) {
+  uint8_t buffer[10];
+  uint16_t actualLen;
+  ASSERT_FALSE(queue.dequeue(buffer, sizeof(buffer), actualLen));
+}
+
+// Test enqueue() with NULL data and zero data length
+TEST_F(DataQueueTest, EnqueueInvalidInput) {
+  ASSERT_FALSE(queue.enqueue(nullptr, 10));
+  ASSERT_FALSE(queue.enqueue(reinterpret_cast<uint8_t*>(0x1234), 0));
+}
\ No newline at end of file
diff --git a/nci/jni/HciEventManager.cpp b/nci/jni/HciEventManager.cpp
index 6c5740b4..c2f87f0c 100644
--- a/nci/jni/HciEventManager.cpp
+++ b/nci/jni/HciEventManager.cpp
@@ -27,6 +27,7 @@
 const char* APP_NAME = "NfcNci";
 uint8_t HciEventManager::sEsePipe;
 std::vector<uint8_t> HciEventManager::sSimPipeIds;
+static Mutex sSimPipeIdsMutex;
 
 using android::base::StringPrintf;
 
@@ -46,12 +47,14 @@ void HciEventManager::initialize(nfc_jni_native_data* native) {
   }
   sEsePipe = NfcConfig::getUnsigned(NAME_OFF_HOST_ESE_PIPE_ID, 0x16);
   // Backward compatibility or For vendor supporting only single sim pipe ID
+  sSimPipeIdsMutex.lock();
   if (!NfcConfig::hasKey(NAME_OFF_HOST_SIM_PIPE_IDS)) {
     uint8_t simPipeId = NfcConfig::getUnsigned(NAME_OFF_HOST_SIM_PIPE_ID, 0x0A);
     sSimPipeIds = {simPipeId};
   } else {
     sSimPipeIds = NfcConfig::getBytes(NAME_OFF_HOST_SIM_PIPE_IDS);
   }
+  sSimPipeIdsMutex.unlock();
 }
 
 void HciEventManager::notifyTransactionListenersOfAid(std::vector<uint8_t> aid,
@@ -154,6 +157,7 @@ void HciEventManager::nfaHciCallback(tNFA_HCI_EVT event,
   if (eventData->rcvd_evt.pipe == sEsePipe) {
     evtSrc = "eSE1";
   } else {
+    sSimPipeIdsMutex.lock();
     bool isSimPipeId = false;
     for (size_t i = 0; i < (size_t)sSimPipeIds.size(); i++) {
       if (eventData->rcvd_evt.pipe == sSimPipeIds[i]) {
@@ -162,6 +166,7 @@ void HciEventManager::nfaHciCallback(tNFA_HCI_EVT event,
         break;
       }
     }
+    sSimPipeIdsMutex.unlock();
 
     if (!isSimPipeId) {
       LOG(WARNING) << "Incorrect Pipe Id";
diff --git a/nci/jni/HciEventManager.h b/nci/jni/HciEventManager.h
index 34b81de1..acf729cb 100644
--- a/nci/jni/HciEventManager.h
+++ b/nci/jni/HciEventManager.h
@@ -17,6 +17,7 @@
 
 #include <vector>
 
+#include "Mutex.h"
 #include "NfcJniUtil.h"
 #include "nfa_hci_api.h"
 #include "nfa_hci_defs.h"
diff --git a/nci/jni/JavaClassConstants.h b/nci/jni/JavaClassConstants.h
index dfe7687d..233a347a 100644
--- a/nci/jni/JavaClassConstants.h
+++ b/nci/jni/JavaClassConstants.h
@@ -27,10 +27,17 @@ extern jmethodID gCachedNfcManagerNotifyHostEmuActivated;
 extern jmethodID gCachedNfcManagerNotifyHostEmuData;
 extern jmethodID gCachedNfcManagerNotifyHostEmuDeactivated;
 
-extern jmethodID gCachedNfcManagerNotifyEeUpdated;
+extern jmethodID gCachedNfcManagerNotifyEeListenActivated;
 
+extern jmethodID gCachedNfcManagerNotifyEeUpdated;
+extern jmethodID gCachedNfcManagerNotifyTagDiscovered;
 extern jmethodID gCachedNfcManagerNotifyWlcStopped;
 
+extern jmethodID gCachedNfcManagerNotifyEeAidSelected;
+extern jmethodID gCachedNfcManagerNotifyEeProtocolSelected;
+extern jmethodID gCachedNfcManagerNotifyEeTechSelected;
+
 extern const char* gNativeNfcTagClassName;
 extern const char* gNativeNfcManagerClassName;
+extern const char* gNativeT4tNfceeClassName;
 }  // namespace android
diff --git a/nci/jni/NativeNfcManager.cpp b/nci/jni/NativeNfcManager.cpp
index 732857ed..d68edaa9 100644
--- a/nci/jni/NativeNfcManager.cpp
+++ b/nci/jni/NativeNfcManager.cpp
@@ -31,6 +31,7 @@
 #ifdef DTA_ENABLED
 #include "NfcDta.h"
 #endif /* DTA_ENABLED */
+#include "NativeT4tNfcee.h"
 #include "NfcJniUtil.h"
 #include "NfcTag.h"
 #include "NfceeManager.h"
@@ -42,6 +43,7 @@
 #include "debug_lmrt.h"
 #include "nfa_api.h"
 #include "nfa_ee_api.h"
+#include "nfa_nfcee_int.h"
 #include "nfc_brcm_defs.h"
 #include "nfc_config.h"
 #include "rw_api.h"
@@ -52,6 +54,7 @@ extern tNFA_DM_DISC_FREQ_CFG* p_nfa_dm_rf_disc_freq_cfg;  // defined in stack
 namespace android {
 extern bool gIsTagDeactivating;
 extern bool gIsSelectingRfInterface;
+extern bool gTagJustActivated;
 extern void nativeNfcTag_doTransceiveStatus(tNFA_STATUS status, uint8_t* buf,
                                             uint32_t buflen);
 extern void nativeNfcTag_notifyRfTimeout();
@@ -70,10 +73,12 @@ extern void nativeNfcTag_resetPresenceCheck();
 extern void nativeNfcTag_doReadCompleted(tNFA_STATUS status);
 extern void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface);
 extern void nativeNfcTag_setActivatedRfProtocol(tNFA_INTF_TYPE rfProtocol);
+extern void nativeNfcTag_setActivatedRfMode(uint8_t rfMode);
 extern void nativeNfcTag_abortWaits();
 extern void nativeNfcTag_registerNdefTypeHandler();
 extern void nativeNfcTag_acquireRfInterfaceMutexLock();
 extern void nativeNfcTag_releaseRfInterfaceMutexLock();
+extern void updateNfcID0Param(uint8_t* nfcID0);
 }  // namespace android
 
 /*****************************************************************************
@@ -97,6 +102,7 @@ jmethodID gCachedNfcManagerNotifyHostEmuDeactivated;
 jmethodID gCachedNfcManagerNotifyRfFieldActivated;
 jmethodID gCachedNfcManagerNotifyRfFieldDeactivated;
 jmethodID gCachedNfcManagerNotifyEeUpdated;
+jmethodID gCachedNfcManagerNotifyTagDiscovered;
 jmethodID gCachedNfcManagerNotifyHwErrorReported;
 jmethodID gCachedNfcManagerNotifyPollingLoopFrame;
 jmethodID gCachedNfcManagerNotifyWlcStopped;
@@ -104,11 +110,17 @@ jmethodID gCachedNfcManagerNotifyVendorSpecificEvent;
 jmethodID gCachedNfcManagerNotifyCommandTimeout;
 jmethodID gCachedNfcManagerNotifyObserveModeChanged;
 jmethodID gCachedNfcManagerNotifyRfDiscoveryEvent;
+jmethodID gCachedNfcManagerNotifyEeAidSelected;
+jmethodID gCachedNfcManagerNotifyEeProtocolSelected;
+jmethodID gCachedNfcManagerNotifyEeTechSelected;
+jmethodID gCachedNfcManagerNotifyEeListenActivated;
 const char* gNativeNfcTagClassName = "com/android/nfc/dhimpl/NativeNfcTag";
 const char* gNativeNfcManagerClassName =
     "com/android/nfc/dhimpl/NativeNfcManager";
 const char* gNfcVendorNciResponseClassName =
     "com/android/nfc/NfcVendorNciResponse";
+const char* gNativeT4tNfceeClassName =
+    "com/android/nfc/dhimpl/NativeT4tNfceeManager";
 void doStartupConfig();
 void startStopPolling(bool isStartPolling);
 void startRfDiscovery(bool isStart);
@@ -280,7 +292,6 @@ static void handleRfDiscoveryEvent(tNFC_RESULT_DEVT* discoveredDevice) {
 static void nfaConnectionCallback(uint8_t connEvent,
                                   tNFA_CONN_EVT_DATA* eventData) {
   tNFA_STATUS status = NFA_STATUS_FAILED;
-  LOG(DEBUG) << StringPrintf("%s: event= %u", __func__, connEvent);
 
   switch (connEvent) {
     case NFA_LISTEN_ENABLED_EVT:  // whether listening successfully started
@@ -407,6 +418,9 @@ static void nfaConnectionCallback(uint8_t connEvent,
           __func__, gIsSelectingRfInterface, sIsDisabling);
       uint8_t activatedProtocol =
           (tNFA_INTF_TYPE)eventData->activated.activate_ntf.protocol;
+      uint8_t activatedMode =
+          eventData->activated.activate_ntf.rf_tech_param.mode;
+      gTagJustActivated = true;
       if (NFC_PROTOCOL_T5T == activatedProtocol &&
           NfcTag::getInstance().getNumDiscNtf()) {
         /* T5T doesn't support multiproto detection logic */
@@ -418,11 +432,14 @@ static void nfaConnectionCallback(uint8_t connEvent,
         nativeNfcTag_setRfInterface(
             (tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param.type);
         nativeNfcTag_setActivatedRfProtocol(activatedProtocol);
+        nativeNfcTag_setActivatedRfMode(activatedMode);
       }
       NfcTag::getInstance().setActive(true);
       if (sIsDisabling || !sIsNfaEnabled) break;
       gActivated = true;
 
+      updateNfcID0Param(
+          eventData->activated.activate_ntf.rf_tech_param.param.pb.nfcid0);
       NfcTag::getInstance().setActivationState();
       if (gIsSelectingRfInterface) {
         nativeNfcTag_doConnectStatus(true);
@@ -443,6 +460,14 @@ static void nfaConnectionCallback(uint8_t connEvent,
         /*If its multiprotocol tag, deactivate tag with current selected
         protocol to sleep . Select tag with next supported protocol after
         deactivation event is received*/
+        if (((tNFA_INTF_TYPE)eventData->activated.activate_ntf.intf_param
+                 .type == NFA_INTERFACE_FRAME)) {
+          uint8_t RW_TAG_SLP_REQ[] = {0x50, 0x00};
+          SyncEvent waitSome;
+          SyncEventGuard g(waitSome);
+          NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);
+          waitSome.wait(4);
+        }
         NFA_Deactivate(true);
       }
 
@@ -463,8 +488,8 @@ static void nfaConnectionCallback(uint8_t connEvent,
           return;
         }
         e->CallVoidMethod(nat->manager,
-                          android::gCachedNfcManagerNotifyHostEmuActivated,
-                          (int)activatedProtocol);
+                          android::gCachedNfcManagerNotifyEeListenActivated,
+                          JNI_TRUE);
       }
     } break;
     case NFA_DEACTIVATED_EVT:  // NFC link/protocol deactivated
@@ -506,8 +531,8 @@ static void nfaConnectionCallback(uint8_t connEvent,
             return;
           }
           e->CallVoidMethod(nat->manager,
-                            android::gCachedNfcManagerNotifyHostEmuDeactivated,
-                            NFA_TECHNOLOGY_MASK_A);
+                            android::gCachedNfcManagerNotifyEeListenActivated,
+                            JNI_FALSE);
         }
       }
 
@@ -618,6 +643,13 @@ static void nfaConnectionCallback(uint8_t connEvent,
           "%s: NFA_CE_UICC_LISTEN_CONFIGURED_EVT : status=0x%X", __func__,
           eventData->status);
       break;
+    case NFA_T4TNFCEE_EVT:
+    case NFA_T4TNFCEE_READ_CPLT_EVT:
+    case NFA_T4TNFCEE_WRITE_CPLT_EVT:
+    case NFA_T4TNFCEE_CLEAR_CPLT_EVT:
+    case NFA_T4TNFCEE_READ_CC_DATA_CPLT_EVT:
+      NativeT4tNfcee::getInstance().eventHandler(connEvent, eventData);
+      break;
 
     default:
       LOG(DEBUG) << StringPrintf("%s: unknown event (%d) ????", __func__,
@@ -697,6 +729,9 @@ static jboolean nfcManager_initNativeStruc(JNIEnv* e, jobject o) {
   gCachedNfcManagerNotifyWlcStopped =
       e->GetMethodID(cls.get(), "notifyWlcStopped", "(I)V");
 
+  gCachedNfcManagerNotifyTagDiscovered =
+      e->GetMethodID(cls.get(), "notifyTagDiscovered", "(Z)V");
+
   gCachedNfcManagerNotifyCommandTimeout =
       e->GetMethodID(cls.get(), "notifyCommandTimeout", "()V");
 
@@ -706,12 +741,27 @@ static jboolean nfcManager_initNativeStruc(JNIEnv* e, jobject o) {
   gCachedNfcManagerNotifyRfDiscoveryEvent =
       e->GetMethodID(cls.get(), "notifyRFDiscoveryEvent", "(Z)V");
 
+  gCachedNfcManagerNotifyEeListenActivated =
+      e->GetMethodID(cls.get(), "notifyEeListenActivated", "(Z)V");
+
+  gCachedNfcManagerNotifyEeAidSelected = e->GetMethodID(
+      cls.get(), "notifyEeAidSelected", "([BLjava/lang/String;)V");
+
+  gCachedNfcManagerNotifyEeProtocolSelected = e->GetMethodID(
+      cls.get(), "notifyEeProtocolSelected", "(ILjava/lang/String;)V");
+
+  gCachedNfcManagerNotifyEeTechSelected = e->GetMethodID(
+      cls.get(), "notifyEeTechSelected", "(ILjava/lang/String;)V");
+
   if (nfc_jni_cache_object(e, gNativeNfcTagClassName, &(nat->cached_NfcTag)) ==
       -1) {
     LOG(ERROR) << StringPrintf("%s: fail cache NativeNfcTag", __func__);
     return JNI_FALSE;
   }
 
+  // Cache the reference to the manager
+  (void)getNative(e,o);
+
   LOG(DEBUG) << StringPrintf("%s: exit", __func__);
   return JNI_TRUE;
 }
@@ -858,6 +908,13 @@ void nfaDeviceManagementCallback(uint8_t dmEvent,
           SyncEventGuard guard(gNfaGetConfigEvent);
           gNfaGetConfigEvent.notifyOne();
         }
+        {
+          LOG(DEBUG) << StringPrintf(
+              "%s: aborting RoutingManager::getInstance().mEeUpdateEvent",
+              __func__);
+          SyncEventGuard guard(RoutingManager::getInstance().mEeUpdateEvent);
+          RoutingManager::getInstance().mEeUpdateEvent.notifyOne();
+        }
       } else {
         nativeNfcTag_abortWaits();
         NfcTag::getInstance().abort();
@@ -981,6 +1038,12 @@ static jboolean nfcManager_routeAid(JNIEnv* e, jobject, jbyteArray aid,
   ScopedByteArrayRO bytes(e, aid);
   buf = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
   bufLen = bytes.size();
+  if (NfcConfig::hasKey(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {
+    if (route == (int)NfcConfig::getUnsigned(NAME_DEFAULT_NDEF_NFCEE_ROUTE)) {
+      NativeT4tNfcee::getInstance().checkAndUpdateT4TAid(buf,
+                                                         (uint8_t*)&bufLen);
+    }
+  }
   return RoutingManager::getInstance().addAidRouting(buf, bufLen, route,
                                                      aidInfo, power);
 }
@@ -1022,15 +1085,17 @@ static jboolean nfcManager_unrouteAid(JNIEnv* e, jobject, jbyteArray aid) {
 **                  e: JVM environment.
 **                  o: Java object.
 **
-** Returns:         True if ok.
+** Returns:         NFA_STATUS_OK if successfully initiated
+**                  NFA_STATUS_SEMANTIC_ERROR is update is currently in progress
+**                  NFA_STATUS_FAILED otherwise
 **
 *******************************************************************************/
-static jboolean nfcManager_commitRouting(JNIEnv* e, jobject) {
+static jint nfcManager_commitRouting(JNIEnv* e, jobject) {
   if (sRfEnabled) {
     /*Update routing table only in Idle state.*/
     startRfDiscovery(false);
   }
-  jboolean commitStatus = RoutingManager::getInstance().commitRouting();
+  jint commitStatus = RoutingManager::getInstance().commitRouting();
   startRfDiscovery(true);
   return commitStatus;
 }
@@ -1356,6 +1421,11 @@ static jboolean doPartialInit() {
     SyncEventGuard guard(sNfaEnableEvent);
     tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();
     NFA_Partial_Init(halFuncEntries, gPartialInitMode);
+    if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+      LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);
+      NFA_RegVSCback(true, &nfaVSCallback);
+    }
+
     LOG(DEBUG) << StringPrintf("%s: calling enable", __func__);
     stat = NFA_Enable(nfaDeviceManagementCallback, nfaConnectionCallback);
     if (stat == NFA_STATUS_OK) {
@@ -1390,6 +1460,8 @@ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {
   tNFA_STATUS stat = NFA_STATUS_OK;
   sIsRecovering = false;
 
+  struct nfc_jni_native_data* nat = getNative(e, o);
+
   PowerSwitch& powerSwitch = PowerSwitch::getInstance();
 
   if (sIsNfaEnabled) {
@@ -1412,6 +1484,11 @@ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {
 
       NFA_Init(halFuncEntries);
 
+      if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+        LOG(DEBUG) << StringPrintf("%s: register VS callbacks", __func__);
+        NFA_RegVSCback(true, &nfaVSCallback);
+      }
+
       if (gIsDtaEnabled == true) {
         // Allows to set appl_dta_mode_flag
         LOG(DEBUG) << StringPrintf("%s: DTA; set dta flag in core stack",
@@ -1434,11 +1511,11 @@ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {
         NfcTag::getInstance().initialize(getNative(e, o));
         HciEventManager::getInstance().initialize(getNative(e, o));
         NativeWlcManager::getInstance().initialize(getNative(e, o));
+        NativeT4tNfcee::getInstance().initialize();
 
         /////////////////////////////////////////////////////////////////////////////////
         // Add extra configuration here (work-arounds, etc.)
 
-        struct nfc_jni_native_data* nat = getNative(e, o);
         if (nat) {
           nat->tech_mask =
               NfcConfig::getUnsigned(NAME_POLLING_TECH_MASK, DEFAULT_TECH_MASK);
@@ -1499,9 +1576,6 @@ static jboolean nfcManager_doInitialize(JNIEnv* e, jobject o) {
 TheEnd:
   if (sIsNfaEnabled) {
     PowerSwitch::getInstance().setLevel(PowerSwitch::LOW_POWER);
-    if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
-      NFA_RegVSCback(true, &nfaVSCallback);
-    }
   }
   LOG(DEBUG) << StringPrintf("%s: exit", __func__);
   return sIsNfaEnabled ? JNI_TRUE : JNI_FALSE;
@@ -1528,6 +1602,7 @@ static void nfcManager_doFactoryReset(JNIEnv*, jobject) {
 
 static void nfcManager_doShutdown(JNIEnv*, jobject) {
   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
+  NativeT4tNfcee::getInstance().onNfccShutdown();
   theInstance.DeviceShutdown();
 }
 
@@ -1716,6 +1791,11 @@ static jboolean doPartialDeinit() {
   }
   sIsDisabling = false;
 
+  if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+    LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);
+    NFA_RegVSCback(false, &nfaVSCallback);
+  }
+
   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
   LOG(DEBUG) << StringPrintf("%s: exit", __func__);
   theInstance.Finalize();
@@ -1741,6 +1821,7 @@ static jboolean nfcManager_doDeinitialize(JNIEnv*, jobject) {
   }
   sIsDisabling = true;
 
+  NativeT4tNfcee::getInstance().onNfccShutdown();
   if (!recovery_option || !sIsRecovering) {
     RoutingManager::getInstance().onNfccShutdown();
   }
@@ -1783,6 +1864,11 @@ static jboolean nfcManager_doDeinitialize(JNIEnv*, jobject) {
     sNfaEnableDisablePollingEvent.notifyOne();
   }
 
+  if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+    LOG(DEBUG) << StringPrintf("%s: deregister VS callbacks", __func__);
+    NFA_RegVSCback(false, &nfaVSCallback);
+  }
+
   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
   theInstance.Finalize();
 
@@ -1844,7 +1930,15 @@ static jboolean nfcManager_doDownload(JNIEnv*, jobject) {
   NfcAdaptation& theInstance = NfcAdaptation::GetInstance();
   bool result = JNI_FALSE;
   theInstance.Initialize();  // start GKI, NCI task, NFC task
+  if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+    tHAL_NFC_ENTRY* halFuncEntries = theInstance.GetHalEntryFuncs();
+    NFA_Partial_Init(halFuncEntries, gPartialInitMode);
+    NFA_RegVSCback(true, &nfaVSCallback);
+  }
   result = theInstance.DownloadFirmware();
+  if (android_nfc_nfc_read_polling_loop() || android_nfc_nfc_vendor_cmd()) {
+    NFA_RegVSCback(false, &nfaVSCallback);
+  }
   theInstance.Finalize();
   LOG(DEBUG) << StringPrintf("%s: exit", __func__);
   return result;
@@ -2204,14 +2298,20 @@ static void nfcManager_clearRoutingEntry(JNIEnv* e, jobject o,
 
 static void nfcManager_updateIsoDepProtocolRoute(JNIEnv* e, jobject o,
                                                  jint route) {
-  LOG(DEBUG) << StringPrintf("%s: clearFlags=0x%X", __func__, route);
+  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);
   RoutingManager::getInstance().updateIsoDepProtocolRoute(route);
 }
 
 static void nfcManager_updateTechnologyABFRoute(JNIEnv* e, jobject o,
+                                                jint route, jint felicaRoute) {
+  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);
+  RoutingManager::getInstance().updateTechnologyABFRoute(route, felicaRoute);
+}
+
+static void nfcManager_updateSystemCodeRoute(JNIEnv* e, jobject o,
                                                 jint route) {
-  LOG(DEBUG) << StringPrintf("%s: clearFlags=0x%X", __func__, route);
-  RoutingManager::getInstance().updateTechnologyABFRoute(route);
+  LOG(DEBUG) << StringPrintf("%s: route=0x%X", __func__, route);
+  RoutingManager::getInstance().updateSystemCodeRoute(route);
 }
 
 /*******************************************************************************
@@ -2393,7 +2493,7 @@ static JNINativeMethod gMethods[] = {
 
     {"unrouteAid", "([B)Z", (void*)nfcManager_unrouteAid},
 
-    {"commitRouting", "()Z", (void*)nfcManager_commitRouting},
+    {"commitRouting", "()I", (void*)nfcManager_commitRouting},
 
     {"doRegisterT3tIdentifier", "([B)I",
      (void*)nfcManager_doRegisterT3tIdentifier},
@@ -2455,16 +2555,18 @@ static JNINativeMethod gMethods[] = {
     {"setIsoDepProtocolRoute", "(I)V",
      (void*)nfcManager_updateIsoDepProtocolRoute},
 
-    {"setTechnologyABFRoute", "(I)V",
+    {"setTechnologyABFRoute", "(II)V",
      (void*)nfcManager_updateTechnologyABFRoute},
 
+    {"setSystemCodeRoute", "(I)V", (void*)nfcManager_updateSystemCodeRoute},
+
     {"setDiscoveryTech", "(II)V", (void*)nfcManager_setDiscoveryTech},
 
     {"resetDiscoveryTech", "()V", (void*)nfcManager_resetDiscoveryTech},
     {"nativeSendRawVendorCmd", "(III[B)Lcom/android/nfc/NfcVendorNciResponse;",
      (void*)nfcManager_nativeSendRawVendorCmd},
 
-    {"dofetchActiveNfceeList", "()Ljava/util/List;",
+    {"dofetchActiveNfceeList", "()Ljava/util/Map;",
      (void*)nfcManager_dofetchActiveNfceeList},
 
     {"getProprietaryCaps", "()[B", (void*)nfcManager_getProprietaryCaps},
diff --git a/nci/jni/NativeNfcTag.cpp b/nci/jni/NativeNfcTag.cpp
index 1c5aff0e..3d00f9cb 100644
--- a/nci/jni/NativeNfcTag.cpp
+++ b/nci/jni/NativeNfcTag.cpp
@@ -46,6 +46,7 @@ extern bool nfcManager_isNfcActive();
 
 extern bool gActivated;
 extern SyncEvent gDeactivatedEvent;
+uint8_t mNfcID0[4];
 
 /*****************************************************************************
 **
@@ -55,9 +56,9 @@ extern SyncEvent gDeactivatedEvent;
 namespace android {
 bool gIsTagDeactivating = false;  // flag for nfa callback indicating we are
                                   // deactivating for RF interface switch
-bool gIsSelectingRfInterface =
-    false;  // flag for nfa callback indicating we are
-            // selecting for RF interface switch
+bool gIsSelectingRfInterface = false;  // flag for nfa callback indicating we
+                                       // are selecting for RF interface switch
+bool gTagJustActivated = false;
 }  // namespace android
 
 /*****************************************************************************
@@ -85,9 +86,11 @@ static bool sCheckNdefCapable = false;  // whether tag has NDEF capability
 static tNFA_HANDLE sNdefTypeHandlerHandle = NFA_HANDLE_INVALID;
 static tNFA_INTF_TYPE sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
 static tNFA_INTF_TYPE sCurrentActivatedProtocl = NFA_INTERFACE_ISO_DEP;
+static uint8_t sCurrentActivatedMode = 0;
 static std::vector<uint8_t> sRxDataBuffer;
 static tNFA_STATUS sRxDataStatus = NFA_STATUS_OK;
 static bool sWaitingForTransceive = false;
+static bool sIsISODepActivatedByApp = false;
 static bool sTransceiveRfTimeout = false;
 static Mutex sRfInterfaceMutex;
 static uint32_t sReadDataLen = 0;
@@ -105,12 +108,13 @@ static IntervalTimer sSwitchBackTimer;  // timer used to tell us to switch back
                                         // to ISO_DEP frame interface
 uint8_t RW_TAG_SLP_REQ[] = {0x50, 0x00};
 uint8_t RW_DESELECT_REQ[] = {0xC2};
+uint8_t RW_ATTRIB_REQ[] = {0x1D};
+uint8_t RW_TAG_RATS[] = {0xE0, 0x80};
 static jboolean sWriteOk = JNI_FALSE;
 static jboolean sWriteWaitingForComplete = JNI_FALSE;
 static bool sFormatOk = false;
 static jboolean sConnectOk = JNI_FALSE;
 static jboolean sConnectWaitingForComplete = JNI_FALSE;
-static bool sGotDeactivate = false;
 static uint32_t sCheckNdefMaxSize = 0;
 static bool sCheckNdefCardReadOnly = false;
 static jboolean sCheckNdefWaitingForComplete = JNI_FALSE;
@@ -119,15 +123,17 @@ static tNFA_STATUS sMakeReadonlyStatus = NFA_STATUS_FAILED;
 static jboolean sMakeReadonlyWaitingForComplete = JNI_FALSE;
 static int sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
 static int sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
-static int sCurrentConnectedHandle = 0;
+static int sCurrentConnectedTargetIdx = 0;
 static int sIsoDepPresCheckCnt = 0;
 static bool sIsoDepPresCheckAlternate = false;
 static int sPresCheckErrCnt = 0;
+static bool sReselectTagIdle = false;
 
 static int sPresCheckStatus = 0;
+
 static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded);
-static bool switchRfInterface(tNFA_INTF_TYPE rfInterface);
 extern bool gIsDtaEnabled;
+static tNFA_STATUS performHaltPICC();
 
 /*******************************************************************************
 **
@@ -163,12 +169,15 @@ void nativeNfcTag_abortWaits() {
   sem_post(&sMakeReadonlySem);
   sCurrentRfInterface = NFA_INTERFACE_ISO_DEP;
   sCurrentActivatedProtocl = NFA_INTERFACE_ISO_DEP;
-  sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
-  sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
+  if (!gIsTagDeactivating) {
+    sCurrentConnectedTargetType = TARGET_TYPE_UNKNOWN;
+    sCurrentConnectedTargetProtocol = NFC_PROTOCOL_UNKNOWN;
+  }
 
   sIsoDepPresCheckCnt = 0;
   sPresCheckErrCnt = 0;
   sIsoDepPresCheckAlternate = false;
+  sIsISODepActivatedByApp = false;
 }
 
 /*******************************************************************************
@@ -211,6 +220,19 @@ void nativeNfcTag_setRfInterface(tNFA_INTF_TYPE rfInterface) {
   sCurrentRfInterface = rfInterface;
 }
 
+/*******************************************************************************
+ **
+ ** Function:        nativeNfcTag_setTransceiveFlag
+ **
+ ** Description:     Set transceive state.
+ **
+ ** Returns:         None
+ **
+ *******************************************************************************/
+void nativeNfcTag_setTransceiveFlag(bool state) {
+  sWaitingForTransceive = state;
+}
+
 /*******************************************************************************
  **
  ** Function:        nativeNfcTag_setActivatedRfProtocol
@@ -224,6 +246,25 @@ void nativeNfcTag_setActivatedRfProtocol(tNFA_INTF_TYPE rfProtocol) {
   sCurrentActivatedProtocl = rfProtocol;
 }
 
+/*******************************************************************************
+ **
+ ** Function:        nativeNfcTag_setActivatedRfMode
+ **
+ ** Description:     Set rf Activated mode.
+ **
+ ** Returns:         void
+ **
+ *******************************************************************************/
+void nativeNfcTag_setActivatedRfMode(tNFC_DISCOVERY_TYPE rfMode) {
+  if (rfMode == NFC_DISCOVERY_TYPE_POLL_A)
+    sCurrentActivatedMode = TARGET_TYPE_ISO14443_3A;
+  else if (rfMode == NFC_DISCOVERY_TYPE_POLL_B ||
+           rfMode == NFC_DISCOVERY_TYPE_POLL_B_PRIME)
+    sCurrentActivatedMode = TARGET_TYPE_ISO14443_3B;
+  else
+    sCurrentActivatedMode = sCurrentConnectedTargetType;
+}
+
 /*******************************************************************************
 **
 ** Function:        ndefHandlerCallback
@@ -480,8 +521,6 @@ void nativeNfcTag_doConnectStatus(jboolean isConnectOk) {
 **
 *******************************************************************************/
 void nativeNfcTag_doDeactivateStatus(int status) {
-  sGotDeactivate = (status == 0);
-
   SyncEventGuard g(sReconnectEvent);
   sReconnectEvent.notifyOne();
 }
@@ -498,11 +537,12 @@ void nativeNfcTag_doDeactivateStatus(int status) {
 ** Returns:         Must return NXP status code, which NFC service expects.
 **
 *******************************************************************************/
-static jint nativeNfcTag_doConnect(JNIEnv*, jobject, jint targetHandle) {
-  LOG(DEBUG) << StringPrintf("%s: targetHandle = %d", __func__, targetHandle);
-  int i = targetHandle;
+static jint nativeNfcTag_doConnect(JNIEnv*, jobject, jint targetIdx) {
+  LOG(DEBUG) << StringPrintf("%s: targetIdx = %d", __func__, targetIdx);
+  int i = targetIdx;
   NfcTag& natTag = NfcTag::getInstance();
   int retCode = NFCSTATUS_SUCCESS;
+  tNFA_INTF_TYPE intfType = NFA_INTERFACE_FRAME;
 
   sIsoDepPresCheckCnt = 0;
   sPresCheckErrCnt = 0;
@@ -522,12 +562,13 @@ static jint nativeNfcTag_doConnect(JNIEnv*, jobject, jint targetHandle) {
 
   sCurrentConnectedTargetType = natTag.mTechList[i];
   sCurrentConnectedTargetProtocol = natTag.mTechLibNfcTypes[i];
-  sCurrentConnectedHandle = targetHandle;
+  sCurrentConnectedTargetIdx = targetIdx;
 
   if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP &&
-      sCurrentConnectedTargetProtocol != NFC_PROTOCOL_MIFARE) {
+      sCurrentConnectedTargetProtocol != NFC_PROTOCOL_MIFARE &&
+      sCurrentConnectedTargetProtocol == sCurrentActivatedProtocl) {
     LOG(DEBUG) << StringPrintf(
-        "%s() Nfc type = %d, do nothing for non ISO_DEP and non Mifare ",
+        "%s() Nfc type = 0x%x, do nothing for non ISO_DEP and non Mifare ",
         __func__, sCurrentConnectedTargetProtocol);
     retCode = NFCSTATUS_SUCCESS;
     goto TheEnd;
@@ -535,20 +576,38 @@ static jint nativeNfcTag_doConnect(JNIEnv*, jobject, jint targetHandle) {
 
   if (sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3A ||
       sCurrentConnectedTargetType == TARGET_TYPE_ISO14443_3B) {
-
-      if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_MIFARE) {
+    if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_MIFARE) {
       LOG(DEBUG) << StringPrintf(
           "%s: switching to tech: %d need to switch rf intf to frame", __func__,
           sCurrentConnectedTargetType);
-      retCode = switchRfInterface(NFA_INTERFACE_FRAME) ? NFA_STATUS_OK
-                                                       : NFA_STATUS_FAILED;
-      }
+      intfType = NFA_INTERFACE_FRAME;
+    }
   } else if (sCurrentConnectedTargetType == TARGET_TYPE_MIFARE_CLASSIC) {
-    retCode = switchRfInterface(NFA_INTERFACE_MIFARE) ? NFA_STATUS_OK
-                                                      : NFA_STATUS_FAILED;
+    intfType = NFA_INTERFACE_MIFARE;
   } else {
-    retCode = switchRfInterface(NFA_INTERFACE_ISO_DEP) ? NFA_STATUS_OK
-                                                       : NFA_STATUS_FAILED;
+    intfType = NFA_INTERFACE_ISO_DEP;
+  }
+
+  retCode = reSelect(intfType, true);
+  if (retCode == STATUS_CODE_TARGET_LOST) sIsISODepActivatedByApp = false;
+
+  // Check we are connected to requested protocol/tech
+  if ((retCode == NFCSTATUS_SUCCESS) &&
+      ((sCurrentConnectedTargetProtocol != sCurrentActivatedProtocl) ||
+       (intfType != sCurrentRfInterface))) {
+    LOG(ERROR) << StringPrintf("%s: not connected to requested idx 0x%X",
+                               __func__, targetIdx);
+    retCode = NFCSTATUS_FAILED;
+
+    // We are still connected to something, update variables
+    for (int i = 0; i < natTag.mNumTechList; i++) {
+      if (sCurrentActivatedProtocl == natTag.mTechLibNfcTypes[i]) {
+        sCurrentConnectedTargetIdx = i;
+        sCurrentConnectedTargetType = natTag.mTechList[i];
+        sCurrentConnectedTargetProtocol = natTag.mTechLibNfcTypes[i];
+        break;
+      }
+    }
   }
 
 TheEnd:
@@ -568,9 +627,8 @@ TheEnd:
 **
 *******************************************************************************/
 static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
-  LOG(DEBUG) << StringPrintf("%s: enter; rf intf = %d, current intf = %d",
+  LOG(DEBUG) << StringPrintf("%s: enter; rf intf = 0x%x, current intf = 0x%x",
                              __func__, rfInterface, sCurrentRfInterface);
-
   sRfInterfaceMutex.lock();
 
   if (fSwitchIfNeeded && (rfInterface == sCurrentRfInterface)) {
@@ -588,7 +646,7 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
     LOG(DEBUG) << StringPrintf("%s: DTA; bypass flag not set", __func__);
 
   NfcTag& natTag = NfcTag::getInstance();
-
+  natTag.setReselect(TRUE);
   tNFA_STATUS status = NFA_STATUS_OK;
   int rVal = 1;
 
@@ -603,24 +661,25 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
         (NFC_GetNCIVersion() >= NCI_VERSION_2_0)) {
       {
         SyncEventGuard g3(sReconnectEvent);
-        if (sCurrentActivatedProtocl == NFA_PROTOCOL_T2T) {
-          status = NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);
-        } else if (sCurrentActivatedProtocl == NFA_PROTOCOL_ISO_DEP) {
-          status = NFA_SendRawFrame(RW_DESELECT_REQ,
-                                    sizeof(RW_DESELECT_REQ), 0);
-        }
+        status = performHaltPICC();
         sReconnectEvent.wait(4);
         if (status != NFA_STATUS_OK) {
           LOG(ERROR) << StringPrintf("%s: send error=%d", __func__, status);
           break;
         }
       }
+    } else if ((sCurrentRfInterface == NFA_INTERFACE_ISO_DEP) &&
+               gTagJustActivated && sReselectTagIdle) {
+      // If tag does not answer to S(DESELECT), this might be because no data
+      // was sent before. Send empty I-frame in that case
+      SyncEventGuard g4(sReconnectEvent);
+      status = NFA_SendRawFrame(nullptr, 0, 0);
+      sReconnectEvent.wait(30);
     }
 
     {
       SyncEventGuard g(sReconnectEvent);
       gIsTagDeactivating = true;
-      sGotDeactivate = false;
       LOG(DEBUG) << StringPrintf("%s: deactivate to sleep", __func__);
       if (NFA_STATUS_OK !=
           (status = NFA_Deactivate(TRUE)))  // deactivate to sleep state
@@ -630,22 +689,19 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
         break;
       }
 
-      if (sReconnectEvent.wait(1000) == false)  // if timeout occurred
+      if (sReconnectEvent.wait(natTag.getTransceiveTimeout(
+              sCurrentConnectedTargetType)) == false)  // if timeout occurred
       {
         LOG(ERROR) << StringPrintf("%s: timeout waiting for deactivate",
                                    __func__);
       }
     }
 
-    if (!sGotDeactivate) {
-      rVal = STATUS_CODE_TARGET_LOST;
-      break;
-    }
-
-    if (NfcTag::getInstance().getActivationState() != NfcTag::Sleep) {
-      LOG(ERROR) << StringPrintf("%s: tag is not in sleep", __func__);
-      rVal = STATUS_CODE_TARGET_LOST;
-      break;
+    if (NfcTag::getInstance().getActivationState() == NfcTag::Idle) {
+      LOG(ERROR) << StringPrintf("%s: tag is in Idle state", __func__);
+      sReselectTagIdle = true;
+    } else {
+      sReselectTagIdle = false;
     }
 
     gIsTagDeactivating = false;
@@ -654,18 +710,21 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
       SyncEventGuard g2(sReconnectEvent);
 
       sConnectWaitingForComplete = JNI_TRUE;
-      LOG(DEBUG) << StringPrintf("%s: select interface %u", __func__,
-                                 rfInterface);
       gIsSelectingRfInterface = true;
-      if (NFA_STATUS_OK !=
-          (status = NFA_Select(natTag.mTechHandles[sCurrentConnectedHandle],
-                               natTag.mTechLibNfcTypes[sCurrentConnectedHandle],
-                               rfInterface))) {
-        LOG(ERROR) << StringPrintf("%s: NFA_Select failed, status = %d",
-                                   __func__, status);
-        break;
-      }
 
+      if (!sReselectTagIdle) {
+        LOG(DEBUG) << StringPrintf("%s: select interface 0x%x", __func__,
+                                   rfInterface);
+        if (NFA_STATUS_OK !=
+            (status =
+                 NFA_Select(natTag.mTechHandles[sCurrentConnectedTargetIdx],
+                            natTag.mTechLibNfcTypes[sCurrentConnectedTargetIdx],
+                            rfInterface))) {
+          LOG(ERROR) << StringPrintf("%s: NFA_Select failed, status = %d",
+                                     __func__, status);
+          break;
+        }
+      }
       sConnectOk = false;
       if (sReconnectEvent.wait(1000) == false)  // if timeout occurred
       {
@@ -698,9 +757,9 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
       rVal = STATUS_CODE_TARGET_LOST;
       break;
     }
+    // Check if we are connected to the requested interface
     if (sConnectOk) {
       rVal = 0;  // success
-      sCurrentRfInterface = rfInterface;
     } else {
       rVal = 1;
     }
@@ -710,38 +769,11 @@ static int reSelect(tNFA_INTF_TYPE rfInterface, bool fSwitchIfNeeded) {
   gIsTagDeactivating = false;
   gIsSelectingRfInterface = false;
   sRfInterfaceMutex.unlock();
+  natTag.setReselect(FALSE);
   LOG(DEBUG) << StringPrintf("%s: exit; status=%d", __func__, rVal);
   return rVal;
 }
 
-/*******************************************************************************
-**
-** Function:        switchRfInterface
-**
-** Description:     Switch controller's RF interface to frame, ISO-DEP, or
-*NFC-DEP.
-**                  rfInterface: Type of RF interface.
-**
-** Returns:         True if ok.
-**
-*******************************************************************************/
-static bool switchRfInterface(tNFA_INTF_TYPE rfInterface) {
-  NfcTag& natTag = NfcTag::getInstance();
-
-  if (sCurrentConnectedTargetProtocol != NFC_PROTOCOL_ISO_DEP &&
-      sCurrentConnectedTargetProtocol != NFC_PROTOCOL_MIFARE) {
-    LOG(DEBUG) << StringPrintf(
-        "%s: protocol: %d not ISO_DEP and not Mifare, do nothing", __func__,
-        natTag.mTechLibNfcTypes[0]);
-    return true;
-  }
-
-  LOG(DEBUG) << StringPrintf("%s: new rf intf = %d, cur rf intf = %d", __func__,
-                             rfInterface, sCurrentRfInterface);
-
-  return (0 == reSelect(rfInterface, true));
-}
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doReconnect
@@ -754,7 +786,8 @@ static bool switchRfInterface(tNFA_INTF_TYPE rfInterface) {
 **
 *******************************************************************************/
 static jint nativeNfcTag_doReconnect(JNIEnv*, jobject) {
-  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+  LOG(DEBUG) << StringPrintf("%s(enter): sCurrentConnectedTargetIdx: 0x%x",
+                             __func__, sCurrentConnectedTargetIdx);
   int retCode = NFCSTATUS_SUCCESS;
   NfcTag& natTag = NfcTag::getInstance();
 
@@ -771,36 +804,37 @@ static jint nativeNfcTag_doReconnect(JNIEnv*, jobject) {
   }
 
   // this is only supported for type 2 or 4 (ISO_DEP) tags
-  if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP)
+  if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_ISO_DEP) {
+    sCurrentConnectedTargetType = TARGET_TYPE_ISO14443_4;
     retCode = reSelect(NFA_INTERFACE_ISO_DEP, false);
-  else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T2T)
+  } else if (sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T2T) {
+    sCurrentConnectedTargetType = TARGET_TYPE_ISO14443_3A;
     retCode = reSelect(NFA_INTERFACE_FRAME, false);
-  else if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE)
+  } else if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
+    sCurrentConnectedTargetType = TARGET_TYPE_MIFARE_CLASSIC;
     retCode = reSelect(NFA_INTERFACE_MIFARE, false);
+  }
+
+  // Check what we are connected to
+  if (retCode == NFCSTATUS_SUCCESS) {
+    for (int i = 0; i < natTag.mNumTechList; i++) {
+      if (sCurrentActivatedProtocl == natTag.mTechLibNfcTypes[i]) {
+        sCurrentConnectedTargetIdx = i;
+        sCurrentConnectedTargetType = natTag.mTechList[i];
+        sCurrentConnectedTargetProtocol = natTag.mTechLibNfcTypes[i];
+        break;
+      }
+    }
+  }
 
+  if (retCode == STATUS_CODE_TARGET_LOST) sIsISODepActivatedByApp = false;
 TheEnd:
-  LOG(DEBUG) << StringPrintf("%s: exit 0x%X", __func__, retCode);
+  LOG(DEBUG) << StringPrintf(
+      "%s(exit): sCurrentConnectedTargetIdx = 0x%X, retCode: 0x%x", __func__,
+      sCurrentConnectedTargetIdx, retCode);
   return retCode;
 }
 
-/*******************************************************************************
-**
-** Function:        nativeNfcTag_doHandleReconnect
-**
-** Description:     Re-connect to the tag in RF field.
-**                  e: JVM environment.
-**                  o: Java object.
-**                  targetHandle: Handle of the tag.
-**
-** Returns:         Status code.
-**
-*******************************************************************************/
-static jint nativeNfcTag_doHandleReconnect(JNIEnv* e, jobject o,
-                                           jint targetHandle) {
-  LOG(DEBUG) << StringPrintf("%s: targetHandle = %d", __func__, targetHandle);
-  return nativeNfcTag_doConnect(e, o, targetHandle);
-}
-
 /*******************************************************************************
 **
 ** Function:        nativeNfcTag_doDisconnect
@@ -817,8 +851,10 @@ jboolean nativeNfcTag_doDisconnect(JNIEnv*, jobject) {
   tNFA_STATUS nfaStat = NFA_STATUS_OK;
 
   NfcTag::getInstance().resetAllTransceiveTimeouts();
+  sReselectTagIdle = false;
 
-  if (NfcTag::getInstance().getActivationState() != NfcTag::Active) {
+  if (NfcTag::getInstance().getActivationState() != NfcTag::Active &&
+      NfcTag::getInstance().getActivationState() != NfcTag::Sleep) {
     LOG(WARNING) << StringPrintf("%s: tag already deactivated", __func__);
     goto TheEnd;
   }
@@ -938,9 +974,16 @@ static jbyteArray nativeNfcTag_doTransceive(JNIEnv* e, jobject o,
         LOG(ERROR) << StringPrintf("%s: fail send; error=%d", __func__, status);
         break;
       }
+      if (((bufLen >= 2) &&
+           (memcmp(buf, RW_TAG_RATS, sizeof(RW_TAG_RATS)) == 0)) ||
+          ((bufLen >= 5) &&
+           (memcmp(buf, RW_ATTRIB_REQ, sizeof(RW_ATTRIB_REQ)) == 0) &&
+           (memcmp((buf + 1), mNfcID0, sizeof(mNfcID0)) == 0))) {
+        sIsISODepActivatedByApp = true;
+      }
       waitOk = sTransceiveEvent.wait(timeout);
     }
-
+    gTagJustActivated = false;
     if (waitOk == false || sTransceiveRfTimeout)  // if timeout occurred
     {
       LOG(ERROR) << StringPrintf("%s: wait response timeout", __func__);
@@ -987,10 +1030,10 @@ static jbyteArray nativeNfcTag_doTransceive(JNIEnv* e, jobject o,
             result.reset(e->NewByteArray(transDataLen));
             if (result.get() != NULL) {
               e->SetByteArrayRegion(result.get(), 0, transDataLen,
-                                  (const jbyte*)transData);
+                                    (const jbyte*)transData);
             } else
-              LOG(ERROR) << StringPrintf("%s: Failed to allocate java byte array",
-                                       __func__);
+              LOG(ERROR) << StringPrintf(
+                  "%s: Failed to allocate java byte array", __func__);
           }
         }
       } else {
@@ -1073,11 +1116,11 @@ void nativeNfcTag_doCheckNdefResult(tNFA_STATUS status, uint32_t maxSize,
                                     uint32_t currentSize, uint8_t flags) {
   // this function's flags parameter is defined using the following macros
   // in nfc/include/rw_api.h;
-  //#define RW_NDEF_FL_READ_ONLY  0x01    /* Tag is read only              */
-  //#define RW_NDEF_FL_FORMATED   0x02    /* Tag formated for NDEF         */
-  //#define RW_NDEF_FL_SUPPORTED  0x04    /* NDEF supported by the tag     */
-  //#define RW_NDEF_FL_UNKNOWN    0x08    /* Unable to find if tag is ndef
-  // capable/formated/read only */ #define RW_NDEF_FL_FORMATABLE 0x10    /* Tag
+  // #define RW_NDEF_FL_READ_ONLY  0x01    /* Tag is read only              */
+  // #define RW_NDEF_FL_FORMATED   0x02    /* Tag formatted for NDEF         */
+  // #define RW_NDEF_FL_SUPPORTED  0x04    /* NDEF supported by the tag     */
+  // #define RW_NDEF_FL_UNKNOWN    0x08    /* Unable to find if tag is ndef
+  // capable/formatted/read only */ #define RW_NDEF_FL_FORMATABLE 0x10    /* Tag
   // supports format operation */
 
   if (!sCheckNdefWaitingForComplete) {
@@ -1153,8 +1196,6 @@ static jint nativeNfcTag_doCheckNdef(JNIEnv* e, jobject o, jintArray ndefInfo) {
     ndef[1] = NDEF_MODE_READ_ONLY;
     e->ReleaseIntArrayElements(ndefInfo, ndef, 0);
     return NFA_STATUS_FAILED;
-  } else if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
-    nativeNfcTag_doReconnect(e, o);
   }
 
   /* Create the write semaphore */
@@ -1221,11 +1262,6 @@ static jint nativeNfcTag_doCheckNdef(JNIEnv* e, jobject o, jintArray ndefInfo) {
     status = sCheckNdefStatus;
   }
 
-  /* Reconnect Mifare Classic Tag for furture use */
-  if (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_MIFARE) {
-    nativeNfcTag_doReconnect(e, o);
-  }
-
 TheEnd:
   /* Destroy semaphore */
   if (sem_destroy(&sCheckNdefSem)) {
@@ -1340,6 +1376,19 @@ static jboolean nativeNfcTag_doPresenceCheck(JNIEnv*, jobject) {
         method = NFA_RW_PRES_CHK_I_BLOCK;
       }
     }
+    if ((sCurrentConnectedTargetProtocol == NFA_PROTOCOL_T2T) &&
+        (sCurrentRfInterface == NFA_INTERFACE_FRAME) &&
+        (!NfcTag::getInstance().isNfcForumT2T())) {
+      /* Only applicable for Type2 tag which has SAK value other than 0
+       (as defined in NFC Digital Protocol, section 4.8.2(SEL_RES)) */
+      uint8_t RW_TAG_SLP_REQ[] = {0x50, 0x00};
+      status = NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);
+      usleep(4 * 1000);
+      if (status != NFA_STATUS_OK) {
+        LOG(ERROR) << StringPrintf(
+            "%s: failed to send RW_TAG_SLP_REQ, status=%d", __func__, status);
+      }
+    }
 
     status = NFA_RwPresenceCheck(method);
     if (status == NFA_STATUS_OK) {
@@ -1354,7 +1403,8 @@ static jboolean nativeNfcTag_doPresenceCheck(JNIEnv*, jobject) {
            ((sPresCheckStatus == NFA_STATUS_RF_FRAME_CORRUPTED) &&
             ((sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T1T) ||
              (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T2T) ||
-             (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T5T))) ||
+             (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T5T) ||
+             (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_CI))) ||
            (sCurrentConnectedTargetProtocol == NFC_PROTOCOL_T3T))) {
         sPresCheckErrCnt++;
 
@@ -1712,7 +1762,6 @@ static JNINativeMethod gMethods[] = {
     {"doConnect", "(I)I", (void*)nativeNfcTag_doConnect},
     {"doDisconnect", "()Z", (void*)nativeNfcTag_doDisconnect},
     {"doReconnect", "()I", (void*)nativeNfcTag_doReconnect},
-    {"doHandleReconnect", "(I)I", (void*)nativeNfcTag_doHandleReconnect},
     {"doTransceive", "([BZ[I)[B", (void*)nativeNfcTag_doTransceive},
     {"doGetNdefType", "(II)I", (void*)nativeNfcTag_doGetNdefType},
     {"doCheckNdef", "([I)I", (void*)nativeNfcTag_doCheckNdef},
@@ -1729,7 +1778,7 @@ static JNINativeMethod gMethods[] = {
 **
 ** Function:        register_com_android_nfc_NativeNfcTag
 **
-** Description:     Regisgter JNI functions with Java Virtual Machine.
+** Description:     Register JNI functions with Java Virtual Machine.
 **                  e: Environment of JVM.
 **
 ** Returns:         Status of registration.
@@ -1741,4 +1790,66 @@ int register_com_android_nfc_NativeNfcTag(JNIEnv* e) {
                                   NELEM(gMethods));
 }
 
+/*******************************************************************************
+**
+** Function:        performHaltPICC()
+**
+** Description:     Issue HALT as per the current activated protocol & mode
+**
+** Returns:         tNFA_STATUS.
+**
+*******************************************************************************/
+static tNFA_STATUS performHaltPICC() {
+  tNFA_STATUS status = NFA_STATUS_OK;
+  if ((sCurrentActivatedProtocl == NFA_PROTOCOL_T2T) ||
+      (sCurrentActivatedProtocl == NFC_PROTOCOL_MIFARE)) {
+    status = NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);
+    usleep(10 * 1000);
+  } else if (sCurrentActivatedProtocl == NFA_PROTOCOL_ISO_DEP) {
+    if (sIsISODepActivatedByApp) {
+      status = NFA_SendRawFrame(RW_DESELECT_REQ, sizeof(RW_DESELECT_REQ), 0);
+      usleep(10 * 1000);
+      sIsISODepActivatedByApp = false;
+    } else {
+      if (sCurrentActivatedMode == TARGET_TYPE_ISO14443_3A) {
+        status = NFA_SendRawFrame(RW_TAG_SLP_REQ, sizeof(RW_TAG_SLP_REQ), 0);
+        usleep(10 * 1000);
+      } else if (sCurrentActivatedMode == TARGET_TYPE_ISO14443_3B) {
+        uint8_t halt_b[5] = {0x50, 0, 0, 0, 0};
+        memcpy(&halt_b[1], mNfcID0, 4);
+        android::nativeNfcTag_setTransceiveFlag(true);
+        SyncEventGuard g(android::sTransceiveEvent);
+        status = NFA_SendRawFrame(halt_b, sizeof(halt_b), 0);
+        if (status != NFA_STATUS_OK) {
+          LOG(DEBUG) << StringPrintf("%s: fail send; error=%d", __func__,
+                                     status);
+        } else {
+          if (android::sTransceiveEvent.wait(100) == false) {
+            status = NCI_STATUS_FAILED;
+            LOG(DEBUG) << StringPrintf("%s: timeout on HALTB", __func__);
+          }
+        }
+        android::nativeNfcTag_setTransceiveFlag(false);
+      }
+    }
+    android::nativeNfcTag_setTransceiveFlag(false);
+  }
+  return status;
+}
+
+/******************************************************************************
+**
+** Function:        updateNfcID0Param
+**
+** Description:     Update TypeB NCIID0 from interface activated ntf.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+void updateNfcID0Param(uint8_t* nfcID0) {
+  LOG(DEBUG) << StringPrintf("%s: nfcID0 =%X%X%X%X", __func__, nfcID0[0],
+                             nfcID0[1], nfcID0[2], nfcID0[3]);
+  memcpy(mNfcID0, nfcID0, 4);
+}
+
 } /* namespace android */
diff --git a/nci/jni/NativeT4tNfcee.cpp b/nci/jni/NativeT4tNfcee.cpp
new file mode 100644
index 00000000..b6093b6c
--- /dev/null
+++ b/nci/jni/NativeT4tNfcee.cpp
@@ -0,0 +1,672 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2024 The Android Open Source Project.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include "NativeT4tNfcee.h"
+
+#include <android-base/logging.h>
+#include <android-base/stringprintf.h>
+#include <nativehelper/ScopedPrimitiveArray.h>
+
+#include "NfcJniUtil.h"
+#include "nfa_nfcee_api.h"
+#include "nfa_nfcee_int.h"
+#include "nfc_config.h"
+
+using android::base::StringPrintf;
+
+/*Considering NCI response timeout which is 2s, Timeout set 100ms more*/
+#define T4TNFCEE_TIMEOUT 2100
+#define T4TOP_TIMEOUT 200
+#define FILE_ID_LEN 0x02
+
+extern bool gActivated;
+namespace android {
+extern bool isDiscoveryStarted();
+extern void startRfDiscovery(bool isStart);
+extern bool nfcManager_isNfcActive();
+}  // namespace android
+
+NativeT4tNfcee NativeT4tNfcee::sNativeT4tNfceeInstance;
+bool NativeT4tNfcee::sIsNfcOffTriggered = false;
+
+NativeT4tNfcee::NativeT4tNfcee() {
+  mBusy = false;
+  memset(&mReadData, 0x00, sizeof(tNFA_RX_DATA));
+  mT4tOpStatus = NFA_STATUS_FAILED;
+}
+
+/*****************************************************************************
+**
+** Function:        getInstance
+**
+** Description:     Get the NativeT4tNfcee singleton object.
+**
+** Returns:         NativeT4tNfcee object.
+**
+*******************************************************************************/
+NativeT4tNfcee& NativeT4tNfcee::getInstance() {
+  return sNativeT4tNfceeInstance;
+}
+
+/*******************************************************************************
+**
+** Function:        initialize
+**
+** Description:     Initialize all member variables.
+**
+** Returns:         None.
+**
+*******************************************************************************/
+void NativeT4tNfcee::initialize(void) {
+  sIsNfcOffTriggered = false;
+  mBusy = false;
+}
+
+/*****************************************************************************
+**
+** Function:        onNfccShutdown
+**
+** Description:     This api shall be called in NFC OFF case.
+**
+** Returns:         none.
+**
+*******************************************************************************/
+void NativeT4tNfcee::onNfccShutdown() {
+  sIsNfcOffTriggered = true;
+  if (mBusy) {
+    /* Unblock JNI APIs */
+    {
+      SyncEventGuard g(mT4tNfcOffEvent);
+      if (mT4tNfcOffEvent.wait(T4TOP_TIMEOUT) == false) {
+        SyncEventGuard ga(mT4tNfcEeRWCEvent);
+        mT4tNfcEeRWCEvent.notifyOne();
+      }
+    }
+    /* Try to close the connection with t4t nfcee, discard the status */
+    (void)closeConnection();
+    resetBusy();
+  }
+}
+/*******************************************************************************
+**
+** Function:        t4tClearData
+**
+** Description:     This API will set all the T4T NFCEE NDEF data to zero.
+**                  This API can be called regardless of NDEF file lock state.
+**
+** Returns:         boolean : Return the Success or fail of the operation.
+**                  Return "True" when operation is successful. else "False"
+**
+*******************************************************************************/
+jboolean NativeT4tNfcee::t4tClearData(JNIEnv* e, jobject o) {
+  LOG(DEBUG) << StringPrintf("%s:Enter: ", __func__);
+
+  /*Local variable Initialization*/
+  uint8_t pFileId[] = {0xE1, 0x04};
+  jbyteArray fileIdArray = e->NewByteArray(sizeof(pFileId));
+  e->SetByteArrayRegion(fileIdArray, 0, sizeof(pFileId), (jbyte*)pFileId);
+  bool clear_status = false;
+
+  /*Validate Precondition*/
+  T4TNFCEE_STATUS_t t4tNfceeStatus =
+      validatePreCondition(OP_CLEAR, fileIdArray);
+
+  switch (t4tNfceeStatus) {
+    case STATUS_SUCCESS:
+      /*NFC is ON*/
+      clear_status = performT4tClearData(pFileId);
+      break;
+    default:
+      LOG(ERROR) << StringPrintf("%s:Exit: Returnig status : %d", __func__,
+                                 clear_status);
+      break;
+  }
+  LOG(DEBUG) << StringPrintf("%s:Exit: ", __func__);
+  return clear_status;
+}
+/*******************************************************************************
+**
+** Function:        performT4tClearData
+**
+** Description:     This api clear the T4T Nfcee data
+**
+** Returns:         boolean : Return the Success or fail of the operation.
+**                  Return "True" when operation is successful. else "False"
+**
+*******************************************************************************/
+jboolean NativeT4tNfcee::performT4tClearData(uint8_t* fileId) {
+  bool t4tClearReturn = false;
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+
+  /*Open connection and stop discovery*/
+  if (setup() != NFA_STATUS_OK) return t4tClearReturn;
+
+  /*Clear Ndef data*/
+  SyncEventGuard g(mT4tNfcEeRWCEvent);
+  status = NFA_T4tNfcEeClear(fileId);
+  if (status == NFA_STATUS_OK) {
+    if (mT4tNfcEeRWCEvent.wait(T4TNFCEE_TIMEOUT) == false)
+      t4tClearReturn = false;
+    else {
+      if (mT4tOpStatus == NFA_STATUS_OK) {
+        t4tClearReturn = true;
+      }
+    }
+  }
+
+  /*Close connection and start discovery*/
+  cleanup();
+  return t4tClearReturn;
+}
+/*******************************************************************************
+**
+** Function:        getT4tStatus
+**
+** Description:     This API will get T4T NDEF NFCEE status.
+**
+** Returns:         boolean : Indicates whether T4T NDEF NFCEE Read or write
+**                            operation is under process
+**                  Return "True" when operation is in progress. else "False"
+**
+*******************************************************************************/
+jboolean NativeT4tNfcee::getT4tStatus(JNIEnv* e, jobject o) {
+  LOG(DEBUG) << StringPrintf("%s:Enter: ", __func__);
+
+  bool t4tStatus = false;
+  t4tStatus = NFA_T4tNfcEeIsProcessing();
+
+  LOG(DEBUG) << StringPrintf("%s:Exit: Returnig status : %d", __func__,
+                             t4tStatus);
+  return t4tStatus;
+}
+/*******************************************************************************
+**
+** Function:        isT4tNdefNfceeEmulationSupported
+**
+** Description:     This API will tell whether T4T NDEF NFCEE emulation is
+**                  supported or not.
+**
+** Returns:         boolean : Indicates whether T4T NDEF NFCEE emulation is
+**                            supported or not
+**                  Return "True" emulation is supported. else "False"
+**
+*******************************************************************************/
+jboolean NativeT4tNfcee::isT4tNdefNfceeEmulationSupported(JNIEnv* e,
+                                                          jobject o) {
+  LOG(DEBUG) << StringPrintf("%s:Enter: ", __func__);
+
+  bool t4tStatus = false;
+  t4tStatus = NFA_T4tNfcEeIsEmulationSupported();
+
+  LOG(DEBUG) << StringPrintf("%s:Exit: ", __func__);
+  return t4tStatus;
+}
+
+/*******************************************************************************
+**
+** Function:        t4tWriteData
+**
+** Description:     Write the data into the T4T file of the specific file ID
+**
+** Returns:         Return the size of data written
+**                  Return negative number of error code
+**
+*******************************************************************************/
+jint NativeT4tNfcee::t4tWriteData(JNIEnv* e, jobject object, jbyteArray fileId,
+                                  jbyteArray data) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+
+  T4TNFCEE_STATUS_t t4tNfceeStatus =
+      validatePreCondition(OP_WRITE, fileId, data);
+  if (t4tNfceeStatus != STATUS_SUCCESS) return t4tNfceeStatus;
+
+  ScopedByteArrayRO bytes(e, fileId);
+  if (bytes.size() < FILE_ID_LEN) {
+    LOG(ERROR) << StringPrintf("%s:Wrong File Id", __func__);
+    return ERROR_INVALID_FILE_ID;
+  }
+
+  ScopedByteArrayRO bytesData(e, data);
+  if (bytesData.size() == 0x00) {
+    LOG(ERROR) << StringPrintf("%s:Empty Data", __func__);
+    return ERROR_EMPTY_PAYLOAD;
+  }
+
+  if (setup() != NFA_STATUS_OK) return ERROR_CONNECTION_FAILED;
+
+  uint8_t* pFileId = NULL;
+  pFileId = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+
+  uint8_t* pData = NULL;
+  pData = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytesData[0]));
+
+  jint t4tWriteReturn = STATUS_FAILED;
+  {
+    SyncEventGuard g(mT4tNfcEeRWCEvent);
+    status = NFA_T4tNfcEeWrite(pFileId, pData, bytesData.size());
+    if (status == NFA_STATUS_OK) {
+      if (mT4tNfcEeRWCEvent.wait(T4TNFCEE_TIMEOUT) == false)
+        t4tWriteReturn = STATUS_FAILED;
+      else {
+        if (mT4tOpStatus == NFA_STATUS_OK) {
+          /*if status is success then return length of data written*/
+          t4tWriteReturn = mReadData.len;
+        } else if (mT4tOpStatus == NFA_STATUS_REJECTED) {
+          t4tWriteReturn = ERROR_NDEF_VALIDATION_FAILED;
+        } else if (mT4tOpStatus == NFA_T4T_STATUS_INVALID_FILE_ID) {
+          t4tWriteReturn = ERROR_INVALID_FILE_ID;
+        } else if (mT4tOpStatus == NFA_STATUS_READ_ONLY) {
+          t4tWriteReturn = ERROR_WRITE_PERMISSION;
+        } else {
+          t4tWriteReturn = STATUS_FAILED;
+        }
+      }
+    }
+  }
+
+  /*Close connection and start discovery*/
+  cleanup();
+  LOG(ERROR) << StringPrintf("%s:Exit: Returnig status : %d", __func__,
+                             t4tWriteReturn);
+  return t4tWriteReturn;
+}
+
+/*******************************************************************************
+**
+** Function:        t4tReadData
+**
+** Description:     Read the data from the T4T file of the specific file ID.
+**
+** Returns:         byte[] : all the data previously written to the specific
+**                  file ID.
+**                  Return one byte '0xFF' if the data was never written to the
+**                  specific file ID,
+**                  Return null if reading fails.
+**
+*******************************************************************************/
+jbyteArray NativeT4tNfcee::t4tReadData(JNIEnv* e, jobject object,
+                                       jbyteArray fileId) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+
+  T4TNFCEE_STATUS_t t4tNfceeStatus = validatePreCondition(OP_READ, fileId);
+  if (t4tNfceeStatus != STATUS_SUCCESS) return NULL;
+
+  ScopedByteArrayRO bytes(e, fileId);
+  ScopedLocalRef<jbyteArray> result(e, NULL);
+  if (bytes.size() < FILE_ID_LEN) {
+    LOG(ERROR) << StringPrintf("%s:Wrong File Id", __func__);
+    return NULL;
+  }
+
+  if (setup() != NFA_STATUS_OK) return NULL;
+
+  uint8_t* pFileId = NULL;
+  pFileId = const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&bytes[0]));
+
+  { /*syncEvent code section*/
+    SyncEventGuard g(mT4tNfcEeRWCEvent);
+    sRxDataBuffer.clear();
+    status = NFA_T4tNfcEeRead(pFileId);
+    if ((status != NFA_STATUS_OK) ||
+        (mT4tNfcEeRWCEvent.wait(T4TNFCEE_TIMEOUT) == false)) {
+      LOG(ERROR) << StringPrintf("%s:Read Failed, status = 0x%X", __func__,
+                                 status);
+      cleanup();
+      return NULL;
+    }
+  }
+
+  if (sRxDataBuffer.size() > 0) {
+    result.reset(e->NewByteArray(sRxDataBuffer.size()));
+    if (result.get() != NULL) {
+      e->SetByteArrayRegion(result.get(), 0, sRxDataBuffer.size(),
+                            (const jbyte*)sRxDataBuffer.data());
+    } else {
+      result.reset(e->NewByteArray(0x00));
+      e->SetByteArrayRegion(result.get(), 0, 0x00, (jbyte*){});
+      LOG(ERROR) << StringPrintf("%s: Failed to allocate java byte array",
+                                 __func__);
+    }
+    sRxDataBuffer.clear();
+  } else if (mT4tOpStatus == NFA_T4T_STATUS_INVALID_FILE_ID) {
+    result.reset(e->NewByteArray(0x00));
+    e->SetByteArrayRegion(result.get(), 0, 0x00, (jbyte*){});
+  }
+  /*Close connection and start discovery*/
+  cleanup();
+  return result.release();
+}
+
+/*******************************************************************************
+**
+** Function:        openConnection
+**
+** Description:     Open T4T Nfcee Connection
+**
+** Returns:         Status
+**
+*******************************************************************************/
+tNFA_STATUS NativeT4tNfcee::openConnection() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  LOG(DEBUG) << StringPrintf("%s: Enter", __func__);
+  SyncEventGuard g(mT4tNfcEeEvent);
+  status = NFA_T4tNfcEeOpenConnection();
+  if (status == NFA_STATUS_OK) {
+    if (mT4tNfcEeEvent.wait(T4TNFCEE_TIMEOUT) == false)
+      status = NFA_STATUS_FAILED;
+    else
+      status = mT4tNfcEeEventStat;
+  }
+  LOG(DEBUG) << StringPrintf("%s: Exit status = 0x%02x", __func__, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        closeConnection
+**
+** Description:     Close T4T Nfcee Connection
+**
+** Returns:         Status
+**
+*******************************************************************************/
+tNFA_STATUS NativeT4tNfcee::closeConnection() {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  LOG(DEBUG) << StringPrintf("%s: Enter", __func__);
+  {
+    SyncEventGuard g(mT4tNfcEeEvent);
+    status = NFA_T4tNfcEeCloseConnection();
+    if (status == NFA_STATUS_OK) {
+      if (mT4tNfcEeEvent.wait(T4TNFCEE_TIMEOUT) == false)
+        status = NFA_STATUS_FAILED;
+      else
+        status = mT4tNfcEeEventStat;
+    }
+  }
+
+  LOG(DEBUG) << StringPrintf("%s: Exit status = 0x%02x", __func__, status);
+  return status;
+}
+
+/*******************************************************************************
+**
+** Function:        setup
+**
+** Description:     stops Discovery and opens T4TNFCEE connection
+**
+** Returns:         Status
+**
+*******************************************************************************/
+tNFA_STATUS NativeT4tNfcee::setup(void) {
+  tNFA_STATUS status = NFA_STATUS_FAILED;
+  setBusy();
+  if (android::isDiscoveryStarted()) {
+    android::startRfDiscovery(false);
+  }
+
+  status = openConnection();
+  if (status != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: openConnection Failed, status = 0x%X",
+                               __func__, status);
+    if (!android::isDiscoveryStarted()) android::startRfDiscovery(true);
+    resetBusy();
+  }
+  return status;
+}
+/*******************************************************************************
+**
+** Function:        cleanup
+**
+** Description:     closes connection and starts discovery
+**
+** Returns:         Status
+**
+*******************************************************************************/
+void NativeT4tNfcee::cleanup(void) {
+  if (sIsNfcOffTriggered) {
+    SyncEventGuard g(mT4tNfcOffEvent);
+    mT4tNfcOffEvent.notifyOne();
+    LOG(ERROR) << StringPrintf("%s: Nfc Off triggered", __func__);
+    return;
+  }
+  if (closeConnection() != NFA_STATUS_OK) {
+    LOG(ERROR) << StringPrintf("%s: closeConnection Failed", __func__);
+  }
+  if (!android::isDiscoveryStarted()) {
+    android::startRfDiscovery(true);
+  }
+  resetBusy();
+}
+
+/*******************************************************************************
+**
+** Function:        validatePreCondition
+**
+** Description:     Runs precondition checks for requested operation
+**
+** Returns:         Status
+**
+*******************************************************************************/
+T4TNFCEE_STATUS_t NativeT4tNfcee::validatePreCondition(T4TNFCEE_OPERATIONS_t op,
+                                                       jbyteArray fileId,
+                                                       jbyteArray data) {
+  T4TNFCEE_STATUS_t t4tNfceeStatus = STATUS_SUCCESS;
+  if (!android::nfcManager_isNfcActive()) {
+    t4tNfceeStatus = ERROR_NFC_NOT_ON;
+  } else if (sIsNfcOffTriggered) {
+    t4tNfceeStatus = ERROR_NFC_OFF_TRIGGERED;
+  } else if (gActivated) {
+    t4tNfceeStatus = ERROR_RF_ACTIVATED;
+  } else if (fileId == NULL) {
+    LOG(ERROR) << StringPrintf("%s:Invalid File Id", __func__);
+    t4tNfceeStatus = ERROR_INVALID_FILE_ID;
+  }
+
+  switch (op) {
+    case OP_READ:
+      break;
+    case OP_WRITE:
+      if (data == NULL) {
+        LOG(ERROR) << StringPrintf("%s:Empty data", __func__);
+        t4tNfceeStatus = ERROR_EMPTY_PAYLOAD;
+      }
+      break;
+    case OP_CLEAR:
+      [[fallthrough]];
+    default:
+      break;
+  }
+  return t4tNfceeStatus;
+}
+
+/*******************************************************************************
+**
+** Function:        t4tReadComplete
+**
+** Description:     Updates read data to the waiting READ API
+**
+** Returns:         none
+**
+*******************************************************************************/
+void NativeT4tNfcee::t4tReadComplete(tNFA_STATUS status, tNFA_RX_DATA data) {
+  mT4tOpStatus = status;
+  if (status == NFA_STATUS_OK) {
+    if (data.len > 0) {
+      sRxDataBuffer.insert(sRxDataBuffer.end(), data.p_data,
+                           data.p_data + data.len);
+      LOG(DEBUG) << StringPrintf("%s: Read Data len new: %d ", __func__,
+                                 data.len);
+    }
+  }
+  SyncEventGuard g(mT4tNfcEeRWCEvent);
+  mT4tNfcEeRWCEvent.notifyOne();
+}
+
+/*******************************************************************************
+ **
+ ** Function:        t4tWriteComplete
+ **
+ ** Description:     Returns write complete information
+ **
+ ** Returns:         none
+ **
+ *******************************************************************************/
+void NativeT4tNfcee::t4tWriteComplete(tNFA_STATUS status, tNFA_RX_DATA data) {
+  mReadData.len = 0x00;
+  LOG(DEBUG) << StringPrintf("%s: Enter", __func__);
+  if (status == NFA_STATUS_OK) mReadData.len = data.len;
+  mT4tOpStatus = status;
+  SyncEventGuard g(mT4tNfcEeRWCEvent);
+  mT4tNfcEeRWCEvent.notifyOne();
+}
+/*******************************************************************************
+ **
+ ** Function:        t4tClearComplete
+ **
+ ** Description:     Update T4T clear data status, waiting T4tClearData API.
+ **
+ ** Returns:         none
+ **
+ *******************************************************************************/
+void NativeT4tNfcee::t4tClearComplete(tNFA_STATUS status) {
+  LOG(DEBUG) << StringPrintf("%s: Enter", __func__);
+  mT4tOpStatus = status;
+  SyncEventGuard g(mT4tNfcEeRWCEvent);
+  mT4tNfcEeRWCEvent.notifyOne();
+}
+/*******************************************************************************
+**
+** Function:        t4tNfceeEventHandler
+**
+** Description:     Handles callback events received from lower layer
+**
+** Returns:         none
+**
+*******************************************************************************/
+void NativeT4tNfcee::eventHandler(uint8_t event,
+                                  tNFA_CONN_EVT_DATA* eventData) {
+  switch (event) {
+    case NFA_T4TNFCEE_EVT:
+      LOG(DEBUG) << StringPrintf("%s: NFA_T4TNFCEE_EVT", __func__);
+      {
+        SyncEventGuard guard(mT4tNfcEeEvent);
+        mT4tNfcEeEventStat = eventData->status;
+        mT4tNfcEeEvent.notifyOne();
+      }
+      break;
+
+    case NFA_T4TNFCEE_READ_CPLT_EVT:
+      LOG(DEBUG) << StringPrintf("%s: NFA_T4TNFCEE_READ_CPLT_EVT", __func__);
+      t4tReadComplete(eventData->status, eventData->data);
+      break;
+
+    case NFA_T4TNFCEE_WRITE_CPLT_EVT:
+      LOG(DEBUG) << StringPrintf("%s: NFA_T4TNFCEE_WRITE_CPLT_EVT", __func__);
+      t4tWriteComplete(eventData->status, eventData->data);
+      break;
+
+    case NFA_T4TNFCEE_CLEAR_CPLT_EVT:
+      LOG(DEBUG) << StringPrintf("%s: NFA_T4TNFCEE_CLEAR_CPLT_EVT", __func__);
+      t4tClearComplete(eventData->status);
+      break;
+
+    case NFA_T4TNFCEE_READ_CC_DATA_CPLT_EVT:
+      LOG(DEBUG) << StringPrintf("%s: NFA_T4TNFCEE_READ_CC_DATA_CPLT_EVT",
+                                 __func__);
+      t4tReadComplete(eventData->status, eventData->data);
+      break;
+
+    default:
+      LOG(DEBUG) << StringPrintf("%s: unknown Event", __func__);
+      break;
+  }
+}
+
+/*******************************************************************************
+ **
+ ** Function:        isT4tNfceeBusy
+ **
+ ** Description:     Returns True if T4tNfcee operation is ongoing else false
+ **
+ ** Returns:         true/false
+ **
+ *******************************************************************************/
+bool NativeT4tNfcee::isT4tNfceeBusy(void) { return mBusy; }
+
+/*******************************************************************************
+ **
+ ** Function:        setBusy
+ **
+ ** Description:     Sets busy flag indicating T4T operation is ongoing
+ **
+ ** Returns:         none
+ **
+ *******************************************************************************/
+void NativeT4tNfcee::setBusy() { mBusy = true; }
+
+/*******************************************************************************
+ **
+ ** Function:        resetBusy
+ **
+ ** Description:     Resets busy flag indicating T4T operation is completed
+ **
+ ** Returns:         none
+ **
+ *******************************************************************************/
+void NativeT4tNfcee::resetBusy() { mBusy = false; }
+/*******************************************************************************
+**
+** Function:        getT4TNfceeAid
+**
+** Description:     Get the T4T Nfcee AID.
+**
+** Returns:         T4T AID: vector<uint8_t>
+**
+*******************************************************************************/
+vector<uint8_t> NativeT4tNfcee::getT4TNfceeAid() {
+  LOG(DEBUG) << StringPrintf("%s:enter", __func__);
+
+  std::vector<uint8_t> t4tNfceeAidBuf;
+
+  if (NfcConfig::hasKey(NAME_T4T_NDEF_NFCEE_AID)) {
+    t4tNfceeAidBuf = NfcConfig::getBytes(NAME_T4T_NDEF_NFCEE_AID);
+  }
+
+  LOG(DEBUG) << StringPrintf("%s:Exit", __func__);
+
+  return t4tNfceeAidBuf;
+}
+
+/*******************************************************************************
+**
+** Function:        checkAndUpdateT4TAid
+**
+** Description:     Check and update T4T Ndef Nfcee AID.
+**
+** Returns:         void
+**
+*******************************************************************************/
+void NativeT4tNfcee::checkAndUpdateT4TAid(uint8_t* t4tNdefAid,
+                                          uint8_t* t4tNdefAidLen) {
+  vector<uint8_t> t4tNfceeAidBuf = getT4TNfceeAid();
+  if (t4tNfceeAidBuf.size() != 0) {
+    uint8_t* t4tAidBuf = t4tNfceeAidBuf.data();
+    *t4tNdefAidLen = t4tNfceeAidBuf.size();
+    memcpy(t4tNdefAid, t4tAidBuf, *t4tNdefAidLen);
+  }
+}
diff --git a/nci/jni/NativeT4tNfcee.h b/nci/jni/NativeT4tNfcee.h
new file mode 100644
index 00000000..33af993f
--- /dev/null
+++ b/nci/jni/NativeT4tNfcee.h
@@ -0,0 +1,318 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2024 The Android Open Source Project.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <nativehelper/ScopedLocalRef.h>
+
+#include <vector>
+
+#include "NfcJniUtil.h"
+#include "SyncEvent.h"
+#include "nfa_api.h"
+
+typedef enum { OP_READ = 0, OP_WRITE, OP_CLEAR } T4TNFCEE_OPERATIONS_t;
+
+typedef enum {
+  STATUS_SUCCESS = 0,
+  STATUS_FAILED = -1,
+  ERROR_RF_ACTIVATED = -2,
+  ERROR_NFC_NOT_ON = -3,
+  ERROR_INVALID_FILE_ID = -4,
+  ERROR_INVALID_LENGTH = -5,
+  ERROR_CONNECTION_FAILED = -6,
+  ERROR_EMPTY_PAYLOAD = -7,
+  ERROR_NDEF_VALIDATION_FAILED = -8,
+  ERROR_WRITE_PERMISSION = -9,
+  ERROR_NFC_OFF_TRIGGERED = -10,
+} T4TNFCEE_STATUS_t;
+
+class NativeT4tNfcee {
+ public:
+  /*****************************************************************************
+  **
+  ** Function:        getInstance
+  **
+  ** Description:     Get the NativeT4tNfcee singleton object.
+  **
+  ** Returns:         NativeT4tNfcee object.
+  **
+  *******************************************************************************/
+  static NativeT4tNfcee& getInstance();
+
+  /*******************************************************************************
+  **
+  ** Function:        initialize
+  **
+  ** Description:     Initialize all member variables.
+  **
+  ** Returns:         None.
+  **
+  *******************************************************************************/
+  void initialize(void);
+  /*****************************************************************************
+  **
+  ** Function:        onNfccShutdown
+  **
+  ** Description:     This api shall be called in NFC OFF case.
+  **
+  ** Returns:         none.
+  **
+  *******************************************************************************/
+  void onNfccShutdown();
+
+  /*******************************************************************************
+  **
+  ** Function:        t4tWriteData
+  **
+  ** Description:     Write the data into the T4T file of the specific file ID
+  **
+  ** Returns:         Return the size of data written
+  **                  Return negative number of error code
+  **
+  *******************************************************************************/
+  int t4tWriteData(JNIEnv* e, jobject o, jbyteArray fileId, jbyteArray data);
+  /*******************************************************************************
+  **
+  ** Function:        t4tClearData
+  **
+  ** Description:     This API will set all the T4T NFCEE NDEF data to zero.
+  **                  This API can be called regardless of NDEF file lock state.
+  **
+  ** Returns:         boolean : Return the Success or fail of the operation.
+  **                  Return "True" when operation is successful. else "False"
+  **
+  *******************************************************************************/
+  jboolean t4tClearData(JNIEnv* e, jobject o);
+  /*******************************************************************************
+  **
+  ** Function:        performT4tClearData
+  **
+  ** Description:     This api clear the T4T Nfcee data
+  **
+  ** Returns:         boolean : Return the Success or fail of the operation.
+  **                  Return "True" when operation is successful. else "False"
+  **
+  *******************************************************************************/
+  jboolean performT4tClearData(uint8_t* fileId);
+  /*******************************************************************************
+   **
+   ** Function:        getT4tStatus
+   **
+   ** Description:     This API will get T4T NDEF NFCEE status.
+   **
+   ** Returns:         boolean : Indicates whether T4T NDEF NFCEE Read or write
+   **                            operation is under process
+   **                  Return "True" when operation is in progress. else "False"
+   **
+   **
+   *******************************************************************************/
+  jboolean getT4tStatus(JNIEnv* e, jobject o);
+  /*******************************************************************************
+   **
+   ** Function:        t4tNfceeManager_isT4tNdefNfceeEmulationSupported
+   **
+   ** Description:     This API will tell whether T4T NDEF NFCEE emulation is
+   **                  supported or not.
+   **
+   ** Returns:         boolean : Indicates whether T4T NDEF NFCEE emulation is
+   **                            supported or not
+   **                  Return "True" when feature supported. else "False"
+   **
+   *******************************************************************************/
+  jboolean isT4tNdefNfceeEmulationSupported(JNIEnv* e, jobject o);
+  /*******************************************************************************
+  **
+  ** Function:        t4tReadData
+  **
+  ** Description:     Read the data from the T4T file of the specific file ID.
+  **
+  ** Returns:         byte[] : all the data previously written to the specific
+  **                  file ID.
+  **                  Return one byte '0xFF' if the data was never written to
+  *the
+  **                  specific file ID,
+  **                  Return null if reading fails.
+  **
+  *******************************************************************************/
+  jbyteArray t4tReadData(JNIEnv* e, jobject o, jbyteArray fileId);
+
+  /*******************************************************************************
+  **
+  ** Function:        t4tReadComplete
+  **
+  ** Description:     Updates read data to the waiting READ API
+  **
+  ** Returns:         none
+  **
+  *******************************************************************************/
+  void t4tReadComplete(tNFA_STATUS status, tNFA_RX_DATA data);
+
+  /*******************************************************************************
+   **
+   ** Function:        t4tWriteComplete
+   **
+   ** Description:     Returns write complete information
+   **
+   ** Returns:         none
+   **
+   *******************************************************************************/
+  void t4tWriteComplete(tNFA_STATUS status, tNFA_RX_DATA data);
+  /*******************************************************************************
+   **
+   ** Function:        t4tClearComplete
+   **
+   ** Description:     Update T4T clear data status, waiting T4tClearData API.
+   **
+   ** Returns:         none
+   **
+   *******************************************************************************/
+  void t4tClearComplete(tNFA_STATUS status);
+
+  /*******************************************************************************
+   **
+   ** Function:        isT4tNfceeBusy
+   **
+   ** Description:     Returns True if T4tNfcee operation is ongoing else false
+   **
+   ** Returns:         true/false
+   **
+   *******************************************************************************/
+  bool isT4tNfceeBusy(void);
+
+  /*******************************************************************************
+  **
+  ** Function:        t4tNfceeEventHandler
+  **
+  ** Description:     Handles callback events received from lower layer
+  **
+  ** Returns:         none
+  **
+  *******************************************************************************/
+  void eventHandler(uint8_t event, tNFA_CONN_EVT_DATA* eventData);
+  /*******************************************************************************
+  **
+  ** Function:        checkAndUpdateT4TAid
+  **
+  ** Description:     Check and update T4T Ndef Nfcee AID.
+  **
+  ** Returns:         void
+  **
+  *******************************************************************************/
+  void checkAndUpdateT4TAid(uint8_t* t4tAid, uint8_t* t4tNdefAidLen);
+
+ private:
+  bool mBusy;
+  static NativeT4tNfcee sNativeT4tNfceeInstance;
+  static bool sIsNfcOffTriggered;
+  SyncEvent mT4tNfcOffEvent;
+  SyncEvent mT4tNfcEeRWCEvent;  // Read, Write, & Clear event
+  SyncEvent mT4tNfcEeEvent;
+  tNFA_RX_DATA mReadData;
+  tNFA_STATUS mT4tOpStatus = NFA_STATUS_FAILED;
+  tNFA_STATUS mT4tNfcEeEventStat = NFA_STATUS_FAILED;
+  std::vector<uint8_t> sRxDataBuffer;
+  NativeT4tNfcee();
+
+  /*******************************************************************************
+  **
+  ** Function:        openConnection
+  **
+  ** Description:     Open T4T Nfcee Connection
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  tNFA_STATUS openConnection();
+
+  /*******************************************************************************
+  **
+  ** Function:        closeConnection
+  **
+  ** Description:     Close T4T Nfcee Connection
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  tNFA_STATUS closeConnection();
+
+  /*******************************************************************************
+  **
+  ** Function:        setup
+  **
+  ** Description:     stops Discovery and opens T4TNFCEE connection
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  tNFA_STATUS setup(void);
+
+  /*******************************************************************************
+  **
+  ** Function:        cleanup
+  **
+  ** Description:     closes connection and starts discovery
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  void cleanup(void);
+
+  /*******************************************************************************
+  **
+  ** Function:        validatePreCondition
+  **
+  ** Description:     Runs precondition checks for requested operation
+  **
+  ** Returns:         Status
+  **
+  *******************************************************************************/
+  T4TNFCEE_STATUS_t validatePreCondition(T4TNFCEE_OPERATIONS_t op,
+                                         jbyteArray fileId,
+                                         jbyteArray data = nullptr);
+
+  /*******************************************************************************
+   **
+   ** Function:        setBusy
+   **
+   ** Description:     Sets busy flag indicating T4T operation is ongoing
+   **
+   ** Returns:         none
+   **
+   *******************************************************************************/
+  void setBusy();
+
+  /*******************************************************************************
+   **
+   ** Function:        resetBusy
+   **
+   ** Description:     Resets busy flag indicating T4T operation is completed
+   **
+   ** Returns:         none
+   **
+   *******************************************************************************/
+  void resetBusy();
+  /*******************************************************************************
+  **
+  ** Function:        getT4TNfceeAid
+  **
+  ** Description:     Get the T4T Nfcee AID.
+  **
+  ** Returns:         T4T AID: vector<uint8_t>
+  **
+  *******************************************************************************/
+  std::vector<uint8_t> getT4TNfceeAid();
+};
diff --git a/nci/jni/NativeT4tNfceeManager.cpp b/nci/jni/NativeT4tNfceeManager.cpp
new file mode 100644
index 00000000..15aa499e
--- /dev/null
+++ b/nci/jni/NativeT4tNfceeManager.cpp
@@ -0,0 +1,173 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2024 The Android Open Source Project.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#include <android-base/logging.h>
+#include <android-base/stringprintf.h>
+#include <nativehelper/ScopedPrimitiveArray.h>
+
+#include "JavaClassConstants.h"
+#include "NativeT4tNfcee.h"
+#include "NfcJniUtil.h"
+#include "nfc_config.h"
+using android::base::StringPrintf;
+
+namespace android {
+/*******************************************************************************
+**
+** Function:        t4tNfceeManager_doClearNdefData
+**
+** Description:     This API will set all the NFCEE NDEF data to zero.
+**                  This API can be called regardless of NDEF file lock state.
+**
+** Returns:         boolean : Return the Success or fail of the operation.
+**                  Return "True" when operation is successful. else "False"
+**
+*******************************************************************************/
+jint t4tNfceeManager_doClearNdefData(JNIEnv* e, jobject o) {
+  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+
+  return NativeT4tNfcee::getInstance().t4tClearData(e, o);
+}
+/*******************************************************************************
+**
+** Function:        t4tNfceeManager_isNdefOperationOngoing
+**
+** Description:     This API will get NDEF NFCEE status.
+**
+** Returns:         boolean : Indicates whether NDEF NFCEE Read or write
+**                            operation is under process
+**                  Return "True" when operation is in progress. else "False"
+**
+*******************************************************************************/
+jboolean t4tNfceeManager_isNdefOperationOngoing(JNIEnv* e, jobject o) {
+  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+
+  return NativeT4tNfcee::getInstance().getT4tStatus(e, o);
+}
+/*******************************************************************************
+**
+** Function:        t4tNfceeManager_isNdefNfceeEmulationSupported
+**
+** Description:     This API will tell whether NDEF NFCEE emulation is supported
+**                  or not.
+**
+** Returns:         boolean : Indicates whether NDEF NFCEE emulation is
+**                            supported or not
+**                  Return "True" when feature supported. else "False"
+**
+*******************************************************************************/
+jboolean t4tNfceeManager_isNdefNfceeEmulationSupported(JNIEnv* e, jobject o) {
+  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+
+  return NativeT4tNfcee::getInstance().isT4tNdefNfceeEmulationSupported(e, o);
+}
+/*******************************************************************************
+ **
+ ** Function:        nfcManager_doWriteData
+ **
+ ** Description:     Write the data into the NDEF NFCEE file of the specific
+ **                  file ID
+ **
+ ** Returns:         Return the size of data written
+ **                  Return negative number of error code
+ **
+ *******************************************************************************/
+jint t4tNfceeManager_doWriteData(JNIEnv* e, jobject o, jbyteArray fileId,
+                                 jbyteArray data) {
+  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+
+  return NativeT4tNfcee::getInstance().t4tWriteData(e, o, fileId, data);
+}
+/*******************************************************************************
+**
+** Function:        nfcManager_doReadData
+**
+** Description:     Read the data from the NDEF NFCEE file of the specific file
+**                  ID.
+**
+** Returns:         byte[] : all the data previously written to the specific
+**                  file ID.
+**                  Return one byte '0xFF' if the data was never written to the
+**                  specific file ID,
+**                  Return null if reading fails.
+**
+*******************************************************************************/
+jbyteArray t4tNfceeManager_doReadData(JNIEnv* e, jobject o, jbyteArray fileId) {
+  LOG(DEBUG) << StringPrintf("%s: enter", __func__);
+  return NativeT4tNfcee::getInstance().t4tReadData(e, o, fileId);
+}
+/*******************************************************************************
+**
+** Function:        t4tNfceeManager_getNdefNfceeRouteId
+**
+** Description:     Get the NDEF NFCEE Route ID.
+**
+** Returns:         NDEF NFCEE route ID if available
+**
+*******************************************************************************/
+jint t4tNfceeManager_getNdefNfceeRouteId() {
+  return NfcConfig::getUnsigned(NAME_DEFAULT_NDEF_NFCEE_ROUTE, 0x10);
+}
+/*******************************************************************************
+**
+** Function:        t4tNfceeManager_getT4TNfceePowerState
+**
+** Description:     Get the T4T Nfcee power state supported.
+**                  e: JVM environment.
+**                  o: Java object.
+**                  mode: Not used.
+**
+** Returns:         None
+**
+*******************************************************************************/
+jint t4tNfceeManager_getT4TNfceePowerState(JNIEnv* e, jobject o) {
+  return NfcConfig::getUnsigned(NAME_DEFAULT_T4TNFCEE_AID_POWER_STATE, 0x01);
+}
+/*****************************************************************************
+ **
+ ** Description:     JNI functions
+ **
+ *****************************************************************************/
+static JNINativeMethod gMethods[] = {
+    {"doWriteData", "([B[B)I", (void*)t4tNfceeManager_doWriteData},
+    {"doReadData", "([B)[B", (void*)t4tNfceeManager_doReadData},
+    {"doClearNdefData", "()Z", (void*)t4tNfceeManager_doClearNdefData},
+    {"isNdefOperationOngoing", "()Z",
+     (void*)t4tNfceeManager_isNdefOperationOngoing},
+    {"isNdefNfceeEmulationSupported", "()Z",
+     (void*)t4tNfceeManager_isNdefNfceeEmulationSupported},
+    {"getT4TNfceePowerState", "()I",
+     (void*)t4tNfceeManager_getT4TNfceePowerState},
+    {"getNdefNfceeRouteId", "()I", (void*)t4tNfceeManager_getNdefNfceeRouteId},
+};
+
+/*******************************************************************************
+ **
+ ** Function:        register_com_android_nfc_NativeT4tNfcee
+ **
+ ** Description:     Regisgter JNI functions with Java Virtual Machine.
+ **                  e: Environment of JVM.
+ **
+ ** Returns:         Status of registration.
+ **
+ *******************************************************************************/
+int register_com_android_nfc_NativeT4tNfcee(JNIEnv* e) {
+  return jniRegisterNativeMethods(e, gNativeT4tNfceeClassName, gMethods,
+                                  NELEM(gMethods));
+}
+}  // namespace android
diff --git a/nci/jni/NfcJniUtil.cpp b/nci/jni/NfcJniUtil.cpp
index dbba6c56..3112424f 100644
--- a/nci/jni/NfcJniUtil.cpp
+++ b/nci/jni/NfcJniUtil.cpp
@@ -50,6 +50,7 @@ jint JNI_OnLoad(JavaVM* jvm, void*) {
 
   if (android::register_com_android_nfc_NativeNfcManager(e) == -1)
     return JNI_ERR;
+  if (android::register_com_android_nfc_NativeT4tNfcee(e) == -1) return JNI_ERR;
   if (android::register_com_android_nfc_NativeNfcTag(e) == -1) return JNI_ERR;
   if (RoutingManager::getInstance().registerJniFunctions(e) == -1)
     return JNI_ERR;
diff --git a/nci/jni/NfcJniUtil.h b/nci/jni/NfcJniUtil.h
index b1bedfa8..85db4922 100644
--- a/nci/jni/NfcJniUtil.h
+++ b/nci/jni/NfcJniUtil.h
@@ -123,13 +123,24 @@ struct nfc_jni_native_data {
 class ScopedAttach {
  public:
   ScopedAttach(JavaVM* vm, JNIEnv** env) : vm_(vm) {
-    vm_->AttachCurrentThread(env, NULL);
+    // Check if the thread is already attached, if not,
+    // attach the current thread and store the JNIEnv pointer
+    if (vm_->GetEnv((void**)env, JNI_VERSION_1_6) != JNI_OK) {
+      vm_->AttachCurrentThread(env, NULL);
+      env_ = *env;
+      attached_ = true;
+    }
   }
 
-  ~ScopedAttach() { vm_->DetachCurrentThread(); }
+  ~ScopedAttach() {
+    // Detach the thread only if it was attached by this object
+    if (attached_) vm_->DetachCurrentThread();
+  }
 
  private:
   JavaVM* vm_;
+  JNIEnv* env_ = nullptr;
+  bool attached_ = false;
 };
 
 jint JNI_OnLoad(JavaVM* jvm, void* reserved);
@@ -142,4 +153,5 @@ int nfc_jni_get_nfc_socket_handle(JNIEnv* e, jobject o);
 struct nfc_jni_native_data* nfc_jni_get_nat(JNIEnv* e, jobject o);
 int register_com_android_nfc_NativeNfcManager(JNIEnv* e);
 int register_com_android_nfc_NativeNfcTag(JNIEnv* e);
+int register_com_android_nfc_NativeT4tNfcee(JNIEnv* e);
 }  // namespace android
diff --git a/nci/jni/NfcTag.cpp b/nci/jni/NfcTag.cpp
index 9577318e..6261e76c 100755
--- a/nci/jni/NfcTag.cpp
+++ b/nci/jni/NfcTag.cpp
@@ -50,6 +50,7 @@ static int sLastSelectedTagId = 0;
 NfcTag::NfcTag()
     : mNumTechList(0),
       mNumRfDiscId(0),
+      mIsReselecting(false),
       mTechnologyTimeoutsTable(MAX_NUM_TECHNOLOGY),
       mNativeData(NULL),
       mIsActivated(false),
@@ -348,16 +349,21 @@ void NfcTag::discoverTechnologies(tNFA_ACTIVATED& activationData) {
     // type-4 tag uses technology ISO-DEP and technology A or B
     mTechList[mNumTechList] =
         TARGET_TYPE_ISO14443_4;  // is TagTechnology.ISO_DEP by Java API
+    uint8_t fwi = 0;
     if (NFC_DISCOVERY_TYPE_POLL_A == rfDetail.rf_tech_param.mode) {
-      uint8_t fwi = rfDetail.intf_param.intf_param.pa_iso.fwi;
-      if (fwi >= MIN_FWI && fwi <= MAX_FWI) {
-        //2^MIN_FWI * 256 * 16 * 1000 / 13560000 is approximately 618
-        int fwt = (1 << (fwi - MIN_FWI)) * 618;
-        LOG(DEBUG) << StringPrintf(
-            "Setting the transceive timeout = %d, fwi = %0#x", fwt, fwi);
-        setTransceiveTimeout(mTechList[mNumTechList], fwt);
-      }
+      fwi = rfDetail.intf_param.intf_param.pa_iso.fwi;
+    } else {
+      fwi = rfDetail.rf_tech_param.param.pb.fwi;
+    }
+    if (fwi >= MIN_FWI && fwi <= MAX_FWI) {
+      // 2^MIN_FWI * 256 * 16 * 1000 / 13560000 is approximately 618
+      int fwt = (1 << (fwi - MIN_FWI)) * 618;
+      LOG(DEBUG) << StringPrintf(
+          "%s; Setting the transceive timeout = %d(x2), fwi = %0#x", fn, fwt,
+          fwi);
+      setTransceiveTimeout(mTechList[mNumTechList], fwt * 2);
     }
+
     if ((rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_A) ||
         (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_LISTEN_A)) {
       mNumTechList++;
@@ -392,7 +398,8 @@ void NfcTag::discoverTechnologies(tNFA_ACTIVATED& activationData) {
   } else if (NFC_PROTOCOL_MIFARE == rfDetail.protocol) {
     LOG(DEBUG) << StringPrintf("%s: Mifare Classic", fn);
     mTechList[mNumTechList] =
-        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
+        TARGET_TYPE_MIFARE_CLASSIC;  // is TagTechnology.MIFARE_CLASSIC by Java
+                                     // API
     mNumTechList++;
     mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
     mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
@@ -400,18 +407,29 @@ void NfcTag::discoverTechnologies(tNFA_ACTIVATED& activationData) {
     memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
            sizeof(rfDetail.rf_tech_param));
     mTechList[mNumTechList] =
-        TARGET_TYPE_MIFARE_CLASSIC;  // is TagTechnology.MIFARE_CLASSIC by Java
-                                     // API
+        TARGET_TYPE_ISO14443_3A;  // is TagTechnology.NFC_A by Java API
   } else {
-    LOG(ERROR) << StringPrintf("%s: unknown protocol ????", fn);
-    mTechList[mNumTechList] = TARGET_TYPE_UNKNOWN;
+    if ((NCI_PROTOCOL_UNKNOWN == rfDetail.protocol) &&
+        (rfDetail.rf_tech_param.mode == NFC_DISCOVERY_TYPE_POLL_B)) {
+      mTechHandles[mNumTechList] = rfDetail.rf_disc_id;
+      mTechLibNfcTypes[mNumTechList] = rfDetail.protocol;
+      LOG(DEBUG) << StringPrintf("%s; Tech type B, unknown ", fn);
+      mTechList[mNumTechList] =
+          TARGET_TYPE_ISO14443_3B;  // is TagTechnology.NFC_B by Java API
+      // save the stack's data structure for interpretation later
+      memcpy(&(mTechParams[mNumTechList]), &(rfDetail.rf_tech_param),
+             sizeof(rfDetail.rf_tech_param));
+    } else {
+      LOG(ERROR) << StringPrintf("%s; unknown protocol ????", fn);
+      mTechList[mNumTechList] = TARGET_TYPE_UNKNOWN;
+    }
   }
 
   mNumTechList++;
   for (int i = 0; i < mNumTechList; i++) {
-    LOG(DEBUG) << StringPrintf("%s: index=%d; tech=%d; handle=%d; nfc type=%d",
-                               fn, i, mTechList[i], mTechHandles[i],
-                               mTechLibNfcTypes[i]);
+    LOG(DEBUG) << StringPrintf(
+        "%s: index=%d; tech=0x%x; handle=%d; nfc type=0x%x", fn, i,
+        mTechList[i], mTechHandles[i], mTechLibNfcTypes[i]);
   }
   mNfcStatsUtil->logNfcTagType(mTechLibNfcTypes[mTechListTail],
                                mTechParams[mTechListTail].mode);
@@ -437,7 +455,7 @@ void NfcTag::discoverTechnologies(tNFA_DISC_RESULT& discoveryData) {
   uint8_t index = mNumDiscNtf;
 
   LOG(DEBUG) << StringPrintf(
-      "%s: enter: rf disc. id=%u; protocol=%u, mNumTechList=%u", fn,
+      "%s: enter: rf disc. id=%u; protocol=0x%x, mNumTechList=%u", fn,
       discovery_ntf.rf_disc_id, discovery_ntf.protocol, mNumTechList);
   if (index >= MAX_NUM_TECHNOLOGY) {
     LOG(ERROR) << StringPrintf("%s: exceed max=%d", fn, MAX_NUM_TECHNOLOGY);
@@ -450,8 +468,8 @@ void NfcTag::discoverTechnologies(tNFA_DISC_RESULT& discoveryData) {
   }
   if (discovery_ntf.more != NCI_DISCOVER_NTF_MORE) {
     for (int i = 0; i < mNumDiscTechList; i++) {
-      LOG(DEBUG) << StringPrintf("%s: index=%d; handle=%d; nfc type=%d", fn, i,
-                                 mTechHandlesDiscData[i],
+      LOG(DEBUG) << StringPrintf("%s: index=%d; handle=%d; nfc type=0x%x", fn,
+                                 i, mTechHandlesDiscData[i],
                                  mTechLibNfcTypesDiscData[i]);
     }
   }
@@ -831,6 +849,10 @@ void NfcTag::fillNativeNfcTagMembers4(JNIEnv* e, jclass tag_cls, jobject tag,
         reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
   } else {
     for (int j = 0; j < mTechListTail; j++) {
+      if (gtechActBytes == NULL) {
+        gtechActBytes =
+            reinterpret_cast<jobjectArray>(e->NewGlobalRef(techActBytes.get()));
+      }
       gtechActBytesObject = e->GetObjectArrayElement(gtechActBytes, j);
       e->SetObjectArrayElement(techActBytes.get(), j, gtechActBytesObject);
     }
@@ -932,8 +954,17 @@ void NfcTag::fillNativeNfcTagMembers4(JNIEnv* e, jclass tag_cls, jobject tag,
       actBytes.reset(e->NewByteArray(2));
       e->SetByteArrayRegion(actBytes.get(), 0, 2, (jbyte*)data);
     } else {
-      LOG(DEBUG) << StringPrintf("%s: tech unknown ????", fn);
-      actBytes.reset(e->NewByteArray(0));
+      if ((NCI_PROTOCOL_UNKNOWN == mTechLibNfcTypes[i]) &&
+          (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_B)) {
+        LOG(DEBUG) << StringPrintf("%s; Chinese Id Card - MBI = %02X", fn,
+                                   activationData.params.ci.mbi);
+        actBytes.reset(e->NewByteArray(1));
+        e->SetByteArrayRegion(actBytes.get(), 0, 1,
+                              (jbyte*)&activationData.params.ci.mbi);
+      } else {
+        LOG(DEBUG) << StringPrintf("%s: tech unknown ????", fn);
+        actBytes.reset(e->NewByteArray(0));
+      }
     }
     e->SetObjectArrayElement(techActBytes.get(), i, actBytes.get());
   }  // for: every technology in the array of current selected tag
@@ -1112,8 +1143,8 @@ void NfcTag::selectNextTagIfExists() {
   LOG(DEBUG) << StringPrintf("%s: enter, mNumDiscTechList=%x", fn,
                              mNumDiscTechList);
   for (int i = 0; i < mNumDiscTechList; i++) {
-    LOG(DEBUG) << StringPrintf("%s: nfa target idx=%dh=0x%X; protocol=0x%X", fn,
-                               i, mTechHandlesDiscData[i],
+    LOG(DEBUG) << StringPrintf("%s: nfa target idx=%d h=0x%X; protocol=0x%X",
+                               fn, i, mTechHandlesDiscData[i],
                                mTechLibNfcTypesDiscData[i]);
     if (((mTechHandlesDiscData[sLastSelectedTagId] !=
           mTechHandlesDiscData[i]) ||
@@ -1203,6 +1234,31 @@ void NfcTag::calculateT1tMaxMessageSize(tNFA_ACTIVATED& activate) {
   }
 }
 
+/*******************************************************************************
+**
+** Function:        isNfcForumT2T
+**
+** Description:     Whether tag is Nfc-Forum based and uses read command for
+**                  presence check.
+**
+** Returns:         True if tag is isNfcForumT2T.
+**
+*******************************************************************************/
+bool NfcTag::isNfcForumT2T() {
+  static const char fn[] = "NfcTag::isNfcForumT2T";
+  bool retval = false;
+
+  for (int i = 0; i < mNumTechList; i++) {
+    if (mTechParams[i].mode == NFC_DISCOVERY_TYPE_POLL_A) {
+      if (mTechParams[i].param.pa.sel_rsp == 0) retval = true;
+
+      break;
+    }
+  }
+  LOG(DEBUG) << StringPrintf("%s: return=%u", fn, retval);
+  return retval;
+}
+
 /*******************************************************************************
 **
 ** Function:        isMifareUltralight
@@ -1316,6 +1372,33 @@ bool NfcTag::isT2tNackResponse(const uint8_t* response, uint32_t responseLen) {
 *******************************************************************************/
 bool NfcTag::isNdefDetectionTimedOut() { return mNdefDetectionTimedOut; }
 
+/*******************************************************************************
+**
+** Function:        notifyTagDiscovered
+**
+** Description:     Notify NFC service about tag discovery.
+**                  discovered: true if tag is discovered, false if tag is lost.
+**
+** Returns:         None
+**
+*******************************************************************************/
+void NfcTag::notifyTagDiscovered(bool discovered) {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  if (e == NULL) {
+    LOG(ERROR) << "jni env is null";
+    return;
+  }
+  LOG(DEBUG) << StringPrintf("%s: %d", __func__, discovered);
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyTagDiscovered,
+                    discovered);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("fail notify");
+  }
+}
+
 /*******************************************************************************
 **
 ** Function:        connectionEventHandler
@@ -1333,7 +1416,8 @@ void NfcTag::connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data) {
   switch (event) {
     case NFA_DISC_RESULT_EVT: {
       tNFA_DISC_RESULT& disc_result = data->disc_result;
-      if (disc_result.status == NFA_STATUS_OK) {
+      if ((disc_result.status == NFA_STATUS_OK) && !mIsReselecting) {
+        notifyTagDiscovered(true);
         discoverTechnologies(disc_result);
       }
     } break;
@@ -1345,12 +1429,15 @@ void NfcTag::connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data) {
               NCI_DISCOVERY_TYPE_LISTEN_A &&
           data->activated.activate_ntf.intf_param.type !=
               NFC_INTERFACE_EE_DIRECT_RF) {
+        notifyTagDiscovered(true);
         tNFA_ACTIVATED& activated = data->activated;
         if (IsSameKovio(activated)) break;
         mIsActivated = true;
         mProtocol = activated.activate_ntf.protocol;
         calculateT1tMaxMessageSize(activated);
-        discoverTechnologies(activated);
+        if (!mIsReselecting) {
+          discoverTechnologies(activated);
+        }
         createNativeNfcTag(activated);
       }
       break;
@@ -1358,7 +1445,10 @@ void NfcTag::connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data) {
     case NFA_DEACTIVATED_EVT:
       mIsActivated = false;
       mProtocol = NFC_PROTOCOL_UNKNOWN;
-      resetTechnologies();
+      if (!mIsReselecting) {
+        resetTechnologies();
+      }
+      notifyTagDiscovered(false);
       break;
 
     case NFA_READ_CPLT_EVT: {
@@ -1574,3 +1664,25 @@ void NfcTag::setNumDiscNtf(int numDiscNtfValue) {
 **
 *******************************************************************************/
 int NfcTag::getNumDiscNtf() { return mNumDiscNtf; }
+
+/*******************************************************************************
+**
+** Function:        isReselecting
+**
+** Description:     used to check if a reSelect() procedure is ongoing
+**
+** Returns:         value of mIsReselecting variable
+**
+*******************************************************************************/
+bool NfcTag::isReselecting() { return mIsReselecting; }
+
+/*******************************************************************************
+**
+** Function:        setReselect
+**
+** Description:     Called by JNI to indicate status of reSelect() procedure
+**
+** Returns:
+**
+*******************************************************************************/
+void NfcTag::setReselect(bool isReselecting) { mIsReselecting = isReselecting; }
diff --git a/nci/jni/NfcTag.h b/nci/jni/NfcTag.h
index 310df2b9..e91a66f6 100644
--- a/nci/jni/NfcTag.h
+++ b/nci/jni/NfcTag.h
@@ -47,6 +47,7 @@ class NfcTag {
                                              // RF_INTF_ACTIVATED NTF
   int mNumTechList;  // current number of NFC technologies in the list
   int mNumRfDiscId;
+  bool mIsReselecting;
 
   /*******************************************************************************
   **
@@ -105,6 +106,18 @@ class NfcTag {
   *******************************************************************************/
   void connectionEventHandler(uint8_t event, tNFA_CONN_EVT_DATA* data);
 
+  /*******************************************************************************
+  **
+  ** Function:        notifyTagDiscovered
+  **
+  ** Description:     Notify NFC service about tag discovery.
+  **                  discovered: true if tag is discovered, false if tag is lost.
+  **
+  ** Returns:         None
+  **
+  *******************************************************************************/
+  void notifyTagDiscovered(bool discovered);
+
   /*******************************************************************************
   **
   ** Function:        isActivated
@@ -196,6 +209,18 @@ class NfcTag {
   *******************************************************************************/
   int getT1tMaxMessageSize();
 
+  /*******************************************************************************
+  **
+  ** Function:        isNfcForumT2T
+  **
+  ** Description:     Whether tag is Nfc-Forum based and uses read command for
+  **                  presence check.
+  **
+  ** Returns:         True if tag is isNfcForumT2T.
+  **
+  *******************************************************************************/
+  bool isNfcForumT2T();
+
   /*******************************************************************************
   **
   ** Function:        isMifareUltralight
@@ -386,6 +411,28 @@ class NfcTag {
   *******************************************************************************/
   void setNumDiscNtf(int numDiscNtfValue);
 
+  /*******************************************************************************
+  **
+  ** Function:        isReselecting
+  **
+  ** Description:     used to check if a reSelect() procedure is ongoing
+  **
+  ** Returns:         value of mIsReselecting variable
+  **
+  *******************************************************************************/
+  bool isReselecting();
+
+  /*******************************************************************************
+  **
+  ** Function:        setReselect
+  **
+  ** Description:     Called by JNI to indicate status of reSelect() procedure
+  **
+  ** Returns:
+  **
+  *******************************************************************************/
+  void setReselect(bool isReselecting);
+
   /*******************************************************************************
   **
   ** Function:        getNumDiscNtf
diff --git a/nci/jni/NfceeManager.cpp b/nci/jni/NfceeManager.cpp
index 0278de39..524293ae 100644
--- a/nci/jni/NfceeManager.cpp
+++ b/nci/jni/NfceeManager.cpp
@@ -76,12 +76,18 @@ NfceeManager& NfceeManager::getInstance() { return sNfceeManager; }
 **
 *******************************************************************************/
 jobject NfceeManager::getActiveNfceeList(JNIEnv* e) {
-  ScopedLocalRef<jclass> listClass(e, e->FindClass(mArrayListClassName));
-  jmethodID listConstructor = e->GetMethodID(listClass.get(), "<init>", "()V");
-  jmethodID listAdd =
-      e->GetMethodID(listClass.get(), "add", "(Ljava/lang/Object;)Z");
-  jobject nfceeListObj = e->NewObject(listClass.get(), listConstructor);
-  if (!getNFCEeInfo()) return (nfceeListObj);
+  ScopedLocalRef<jclass> hashMapClass(e, e->FindClass(mHashMapClassName));
+  jmethodID hashMapConstructor =
+      e->GetMethodID(hashMapClass.get(), "<init>", "()V");
+  jmethodID hashMapPut = e->GetMethodID(
+      hashMapClass.get(), "put",
+      "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
+  jobject nfceeHashMaptObj =
+      e->NewObject(hashMapClass.get(), hashMapConstructor);
+  ScopedLocalRef<jclass> integerClass(e, e->FindClass("java/lang/Integer"));
+  jmethodID integerConstructor =
+      e->GetMethodID(integerClass.get(), "<init>", "(I)V");
+  if (!getNFCEeInfo()) return (nfceeHashMaptObj);
 
   vector<uint8_t> eSERoute;
   vector<uint8_t> uiccRoute;
@@ -109,11 +115,13 @@ jobject NfceeManager::getActiveNfceeList(JNIEnv* e) {
     if ((nfceeMap.find(id) != nfceeMap.end()) &&
         (status == NFC_NFCEE_STATUS_ACTIVE)) {
       jstring element = e->NewStringUTF(nfceeMap[id].c_str());
-      e->CallBooleanMethod(nfceeListObj, listAdd, element);
+      jobject jtechmask = e->NewObject(integerClass.get(), integerConstructor,
+                                       mNfceeData_t.mNfceeTechMask[i]);
+      e->CallObjectMethod(nfceeHashMaptObj, hashMapPut, element, jtechmask);
       e->DeleteLocalRef(element);
     }
   }
-  return nfceeListObj;
+  return nfceeHashMaptObj;
 }
 
 /*******************************************************************************
@@ -140,11 +148,16 @@ bool NfceeManager::getNFCEeInfo() {
     LOG(INFO) << StringPrintf("%s: num NFCEE discovered: %u", fn, mActualNumEe);
     if (mActualNumEe != 0) {
       for (uint8_t xx = 0; xx < mActualNumEe; xx++) {
+        tNFA_TECHNOLOGY_MASK eeTechnology = 0x00;
         if (mEeInfo[xx].ee_interface[0] != NCI_NFCEE_INTERFACE_HCI_ACCESS)
           mNumEePresent++;
 
         mNfceeData_t.mNfceeID[xx] = mEeInfo[xx].ee_handle;
         mNfceeData_t.mNfceeStatus[xx] = mEeInfo[xx].ee_status;
+        if (mEeInfo[xx].la_protocol) eeTechnology |= NFA_TECHNOLOGY_MASK_A;
+        if (mEeInfo[xx].lb_protocol) eeTechnology |= NFA_TECHNOLOGY_MASK_B;
+        if (mEeInfo[xx].lf_protocol) eeTechnology |= NFA_TECHNOLOGY_MASK_F;
+        mNfceeData_t.mNfceeTechMask[xx] = eeTechnology;
       }
     }
   }
diff --git a/nci/jni/NfceeManager.h b/nci/jni/NfceeManager.h
index f61ad076..bb49c8b0 100644
--- a/nci/jni/NfceeManager.h
+++ b/nci/jni/NfceeManager.h
@@ -27,6 +27,7 @@ using namespace std;
 struct mNfceeData {
   uint16_t mNfceeID[MAX_NUM_NFCEE];
   tNFA_EE_STATUS mNfceeStatus[MAX_NUM_NFCEE];
+  tNFA_TECHNOLOGY_MASK mNfceeTechMask[MAX_NUM_NFCEE];
   uint8_t mNfceePresent;
 };
 
@@ -106,5 +107,5 @@ class NfceeManager {
   uint8_t mNumEePresent;
   uint8_t mActualNumEe;
   mNfceeData mNfceeData_t;
-  const char* mArrayListClassName = "java/util/ArrayList";
-};
\ No newline at end of file
+  const char* mHashMapClassName = "java/util/HashMap";
+};
diff --git a/nci/jni/RoutingManager.cpp b/nci/jni/RoutingManager.cpp
index e7676089..27c2b59d 100755
--- a/nci/jni/RoutingManager.cpp
+++ b/nci/jni/RoutingManager.cpp
@@ -44,6 +44,9 @@ const JNINativeMethod RoutingManager::sMethods[] = {
     {"doGetDefaultOffHostRouteDestination", "()I",
      (void*)RoutingManager::
          com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination},
+    {"doGetDefaultFelicaRouteDestination", "()I",
+     (void*)RoutingManager::
+         com_android_nfc_cardemulation_doGetDefaultFelicaRouteDestination},
     {"doGetOffHostUiccDestination", "()[B",
      (void*)RoutingManager::
          com_android_nfc_cardemulation_doGetOffHostUiccDestination},
@@ -54,7 +57,10 @@ const JNINativeMethod RoutingManager::sMethods[] = {
      (void*)RoutingManager::com_android_nfc_cardemulation_doGetAidMatchingMode},
     {"doGetDefaultIsoDepRouteDestination", "()I",
      (void*)RoutingManager::
-         com_android_nfc_cardemulation_doGetDefaultIsoDepRouteDestination}};
+         com_android_nfc_cardemulation_doGetDefaultIsoDepRouteDestination},
+    {"doGetDefaultScRouteDestination", "()I",
+     (void*)RoutingManager::
+         com_android_nfc_cardemulation_doGetDefaultScRouteDestination}};
 
 static const int MAX_NUM_EE = 5;
 // SCBR from host works only when App is in foreground
@@ -174,6 +180,11 @@ bool RoutingManager::initialize(nfc_jni_native_data* native) {
   updateDefaultRoute();
   updateDefaultProtocolRoute();
 
+  // For startup case with NFC secure enabled.
+  if (mSecureNfcEnabled) {
+    NFA_SetNfcSecure(mSecureNfcEnabled);
+  }
+
   return true;
 }
 
@@ -391,7 +402,7 @@ bool RoutingManager::removeAidRouting(const uint8_t* aid, uint8_t aidLen) {
   }
 }
 
-bool RoutingManager::commitRouting() {
+tNFA_STATUS RoutingManager::commitRouting() {
   static const char fn[] = "RoutingManager::commitRouting";
   tNFA_STATUS nfaStat = 0;
   LOG(DEBUG) << fn;
@@ -406,7 +417,7 @@ bool RoutingManager::commitRouting() {
       mEeUpdateEvent.wait();  // wait for NFA_EE_UPDATED_EVT
     }
   }
-  return (nfaStat == NFA_STATUS_OK);
+  return nfaStat;
 }
 
 void RoutingManager::onNfccShutdown() {
@@ -466,6 +477,93 @@ void RoutingManager::notifyActivated(uint8_t technology) {
   }
 }
 
+bool RoutingManager::getNameOfEe(tNFA_HANDLE ee_handle, std::string& eeName) {
+  if (mOffHostRouteEse.size() == 0) {
+    return false;
+  }
+  ee_handle &= ~NFA_HANDLE_GROUP_EE;
+
+  for (uint8_t i = 0; i < mOffHostRouteEse.size(); i++) {
+    if (ee_handle == mOffHostRouteEse[i]) {
+      eeName = "eSE" + std::to_string(i + 1);
+      return true;
+    }
+  }
+  for (uint8_t i = 0; i < mOffHostRouteUicc.size(); i++) {
+    if (ee_handle == mOffHostRouteUicc[i]) {
+      eeName = "SIM" + std::to_string(i + 1);
+      return true;
+    }
+  }
+
+  LOG(WARNING) << "Incorrect EE Id";
+  return false;
+}
+
+void RoutingManager::notifyEeAidSelected(tNFC_AID& nfcaid,
+                                         tNFA_HANDLE ee_handle) {
+  std::vector<uint8_t> aid(nfcaid.aid, nfcaid.aid + nfcaid.len_aid);
+  if (aid.empty()) {
+    return;
+  }
+
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  CHECK(e);
+
+  ScopedLocalRef<jobject> aidJavaArray(e, e->NewByteArray(aid.size()));
+  CHECK(aidJavaArray.get());
+  e->SetByteArrayRegion((jbyteArray)aidJavaArray.get(), 0, aid.size(),
+                        (jbyte*)&aid[0]);
+  CHECK(!e->ExceptionCheck());
+
+  std::string evtSrc;
+  if (!getNameOfEe(ee_handle, evtSrc)) {
+    return;
+  }
+
+  ScopedLocalRef<jobject> srcJavaString(e, e->NewStringUTF(evtSrc.c_str()));
+  CHECK(srcJavaString.get());
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyEeAidSelected,
+                    aidJavaArray.get(), srcJavaString.get());
+}
+
+void RoutingManager::notifyEeProtocolSelected(uint8_t protocol,
+                                              tNFA_HANDLE ee_handle) {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  CHECK(e);
+
+  std::string evtSrc;
+  if (!getNameOfEe(ee_handle, evtSrc)) {
+    return;
+  }
+
+  ScopedLocalRef<jobject> srcJavaString(e, e->NewStringUTF(evtSrc.c_str()));
+  CHECK(srcJavaString.get());
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyEeProtocolSelected,
+                    protocol, srcJavaString.get());
+}
+
+void RoutingManager::notifyEeTechSelected(uint8_t tech, tNFA_HANDLE ee_handle) {
+  JNIEnv* e = NULL;
+  ScopedAttach attach(mNativeData->vm, &e);
+  CHECK(e);
+
+  std::string evtSrc;
+  if (!getNameOfEe(ee_handle, evtSrc)) {
+    return;
+  }
+
+  ScopedLocalRef<jobject> srcJavaString(e, e->NewStringUTF(evtSrc.c_str()));
+  CHECK(srcJavaString.get());
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyEeTechSelected, tech,
+                    srcJavaString.get());
+}
+
 void RoutingManager::notifyDeactivated(uint8_t technology) {
   mRxDataBuffer.clear();
   JNIEnv* e = NULL;
@@ -475,6 +573,14 @@ void RoutingManager::notifyDeactivated(uint8_t technology) {
     return;
   }
 
+  e->CallVoidMethod(mNativeData->manager,
+                    android::gCachedNfcManagerNotifyEeListenActivated,
+                    JNI_FALSE);
+  if (e->ExceptionCheck()) {
+    e->ExceptionClear();
+    LOG(ERROR) << StringPrintf("Fail to notify Ee listen active status.");
+  }
+
   e->CallVoidMethod(mNativeData->manager,
                     android::gCachedNfcManagerNotifyHostEmuDeactivated,
                     (int)technology);
@@ -621,6 +727,24 @@ void RoutingManager::updateIsoDepProtocolRoute(int route) {
   updateDefaultProtocolRoute();
 }
 
+/*******************************************************************************
+**
+** Function:        updateSystemCodeRoute
+**
+** Description:     Updates the route for System Code
+**
+** Returns:         None
+**
+*******************************************************************************/
+void RoutingManager::updateSystemCodeRoute(int route) {
+  static const char fn[] = "RoutingManager::updateSystemCodeRoute";
+  LOG(DEBUG) << StringPrintf("%s; New default SC route: 0x%x", fn,
+                             route);
+  mEeInfoChanged = true;
+  mDefaultSysCodeRoute = route;
+  updateDefaultRoute();
+}
+
 void RoutingManager::updateDefaultProtocolRoute() {
   static const char fn[] = "RoutingManager::updateDefaultProtocolRoute";
 
@@ -707,7 +831,8 @@ void RoutingManager::updateDefaultRoute() {
   }
 }
 
-tNFA_TECHNOLOGY_MASK RoutingManager::updateTechnologyABFRoute(int route) {
+tNFA_TECHNOLOGY_MASK RoutingManager::updateTechnologyABFRoute(int route,
+                                                              int felicaRoute) {
   static const char fn[] = "RoutingManager::updateTechnologyABFRoute";
 
   tNFA_STATUS nfaStat;
@@ -728,7 +853,7 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateTechnologyABFRoute(int route) {
   else
     LOG(ERROR) << fn << "Fail to clear Default Felica route";
 
-  mDefaultFelicaRoute = route;
+  mDefaultFelicaRoute = felicaRoute;
   mDefaultOffHostRoute = route;
   return updateEeTechRouteSetting();
 }
@@ -740,6 +865,13 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateEeTechRouteSetting() {
   LOG(DEBUG) << fn << ": Number of EE is " << (int)mEeInfo.num_ee;
 
   tNFA_STATUS nfaStat;
+
+  bool offHostRouteFound = false;
+  bool felicaRouteFound = false;
+
+  int defaultFelicaRoute = mDefaultFelicaRoute;
+  int defaultOffHostRoute = mDefaultOffHostRoute;
+
   for (uint8_t i = 0; i < mEeInfo.num_ee; i++) {
     tNFA_HANDLE eeHandle = mEeInfo.ee_disc_info[i].ee_handle;
     tNFA_TECHNOLOGY_MASK seTechMask = 0;
@@ -754,6 +886,7 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateEeTechRouteSetting() {
 
     if ((mDefaultOffHostRoute != 0) &&
         (eeHandle == (mDefaultOffHostRoute | NFA_HANDLE_GROUP_EE))) {
+      offHostRouteFound = true;
       if (mEeInfo.ee_disc_info[i].la_protocol != 0)
         seTechMask |= NFA_TECHNOLOGY_MASK_A;
       if (mEeInfo.ee_disc_info[i].lb_protocol != 0)
@@ -761,8 +894,11 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateEeTechRouteSetting() {
     }
     if ((mDefaultFelicaRoute != 0) &&
         (eeHandle == (mDefaultFelicaRoute | NFA_HANDLE_GROUP_EE))) {
+      felicaRouteFound = true;
       if (mEeInfo.ee_disc_info[i].lf_protocol != 0)
         seTechMask |= NFA_TECHNOLOGY_MASK_F;
+      else
+        defaultFelicaRoute = NFC_DH_ID;
     }
 
     // If OFFHOST_LISTEN_TECH_MASK exists,
@@ -795,13 +931,26 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateEeTechRouteSetting() {
     }
   }
 
-  if (mDefaultOffHostRoute == NFC_DH_ID) {
-    tNFA_TECHNOLOGY_MASK hostTechMask = 0;
-    LOG(DEBUG) << StringPrintf(
-        "%s: Setting technology route to host with A,B and F type", fn);
-    hostTechMask |= NFA_TECHNOLOGY_MASK_A;
-    hostTechMask |= NFA_TECHNOLOGY_MASK_B;
-    hostTechMask |= NFA_TECHNOLOGY_MASK_F;
+  if (!offHostRouteFound) {
+    defaultOffHostRoute = NFC_DH_ID;
+  }
+  if (!felicaRouteFound) {
+    defaultFelicaRoute = NFC_DH_ID;
+  }
+
+  tNFA_TECHNOLOGY_MASK hostTechMask = 0;
+  if (defaultOffHostRoute == NFC_DH_ID || defaultFelicaRoute == NFC_DH_ID) {
+    if (defaultOffHostRoute == NFC_DH_ID) {
+      LOG(DEBUG) << StringPrintf(
+          "%s: Setting technology route to host with A,B type", fn);
+      hostTechMask |= NFA_TECHNOLOGY_MASK_A;
+      hostTechMask |= NFA_TECHNOLOGY_MASK_B;
+    }
+    if (defaultFelicaRoute == NFC_DH_ID) {
+      LOG(DEBUG) << StringPrintf(
+          "%s: Setting technology route to host with F type", fn);
+      hostTechMask |= NFA_TECHNOLOGY_MASK_F;
+    }
     hostTechMask &= mHostListenTechMask;
     nfaStat = NFA_EeSetDefaultTechRouting(NFC_DH_ID, hostTechMask, 0, 0,
                                           mSecureNfcEnabled ? 0 : hostTechMask,
@@ -809,7 +958,9 @@ tNFA_TECHNOLOGY_MASK RoutingManager::updateEeTechRouteSetting() {
                                           mSecureNfcEnabled ? 0 : hostTechMask);
     if (nfaStat != NFA_STATUS_OK)
       LOG(ERROR) << fn << "Failed to configure DH technology routing.";
-    return hostTechMask;
+    nfaStat = NFA_CeConfigureUiccListenTech(NFC_DH_ID, hostTechMask);
+    if (nfaStat != NFA_STATUS_OK)
+      LOG(ERROR) << fn << "Failed to configure DH UICC listen technologies.";
   }
 
   // Clear DH technology route on NFC-A
@@ -912,26 +1063,32 @@ void RoutingManager::nfaEeCallback(tNFA_EE_EVT event,
 
     case NFA_EE_ACTION_EVT: {
       tNFA_EE_ACTION& action = eventData->action;
-      if (action.trigger == NFC_EE_TRIG_SELECT)
+      if (action.trigger == NFC_EE_TRIG_SELECT) {
+        tNFC_AID& aid = action.param.aid;
         LOG(DEBUG) << StringPrintf(
             "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=select (0x%X)", fn,
             action.ee_handle, action.trigger);
-      else if (action.trigger == NFC_EE_TRIG_APP_INIT) {
+        routingManager.notifyEeAidSelected(aid, action.ee_handle);
+      } else if (action.trigger == NFC_EE_TRIG_APP_INIT) {
         tNFC_APP_INIT& app_init = action.param.app_init;
         LOG(DEBUG) << StringPrintf(
             "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=app-init "
             "(0x%X); aid len=%u; data len=%u",
             fn, action.ee_handle, action.trigger, app_init.len_aid,
             app_init.len_data);
-      } else if (action.trigger == NFC_EE_TRIG_RF_PROTOCOL)
+      } else if (action.trigger == NFC_EE_TRIG_RF_PROTOCOL) {
         LOG(DEBUG) << StringPrintf(
             "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf protocol (0x%X)", fn,
             action.ee_handle, action.trigger);
-      else if (action.trigger == NFC_EE_TRIG_RF_TECHNOLOGY)
+        routingManager.notifyEeProtocolSelected(action.param.protocol,
+                                                  action.ee_handle);
+      } else if (action.trigger == NFC_EE_TRIG_RF_TECHNOLOGY) {
         LOG(DEBUG) << StringPrintf(
             "%s: NFA_EE_ACTION_EVT; h=0x%X; trigger=rf tech (0x%X)", fn,
             action.ee_handle, action.trigger);
-      else
+        routingManager.notifyEeTechSelected(action.param.technology,
+                                              action.ee_handle);
+      } else
         LOG(DEBUG) << StringPrintf(
             "%s: NFA_EE_ACTION_EVT; h=0x%X; unknown trigger (0x%X)", fn,
             action.ee_handle, action.trigger);
@@ -1144,9 +1301,19 @@ void RoutingManager::nfcFCeCallback(uint8_t event,
   }
 }
 
+/*******************************************************************************
+**
+** Function:        setNfcSecure
+**
+** Description:     get the NFC secure status
+**
+** Returns:         true
+**
+*******************************************************************************/
 bool RoutingManager::setNfcSecure(bool enable) {
   mSecureNfcEnabled = enable;
   LOG(INFO) << "setNfcSecure NfcService " << enable;
+  NFA_SetNfcSecure(enable);
   return true;
 }
 
@@ -1288,6 +1455,11 @@ int RoutingManager::
   return getInstance().mDefaultOffHostRoute;
 }
 
+int RoutingManager::
+    com_android_nfc_cardemulation_doGetDefaultFelicaRouteDestination(JNIEnv*) {
+  return getInstance().mDefaultFelicaRoute;
+}
+
 jbyteArray
 RoutingManager::com_android_nfc_cardemulation_doGetOffHostUiccDestination(
     JNIEnv* e) {
@@ -1325,3 +1497,17 @@ int RoutingManager::
     com_android_nfc_cardemulation_doGetDefaultIsoDepRouteDestination(JNIEnv*) {
   return getInstance().mDefaultIsoDepRoute;
 }
+
+/*******************************************************************************
+**
+** Function:        com_android_nfc_cardemulation_doGetDefaultScRouteDestination
+**
+** Description:     Retrieves the default NFCEE route
+**
+** Returns:         default NFCEE route
+**
+*******************************************************************************/
+int RoutingManager::com_android_nfc_cardemulation_doGetDefaultScRouteDestination(
+    JNIEnv*) {
+  return getInstance().mDefaultSysCodeRoute;
+}
diff --git a/nci/jni/RoutingManager.h b/nci/jni/RoutingManager.h
index 01198ab0..b0634446 100755
--- a/nci/jni/RoutingManager.h
+++ b/nci/jni/RoutingManager.h
@@ -39,7 +39,7 @@ class RoutingManager {
   bool addAidRouting(const uint8_t* aid, uint8_t aidLen, int route, int aidInfo,
                      int power);
   bool removeAidRouting(const uint8_t* aid, uint8_t aidLen);
-  bool commitRouting();
+  tNFA_STATUS commitRouting();
   int registerT3tIdentifier(uint8_t* t3tId, uint8_t t3tIdLen);
   void deregisterT3tIdentifier(int handle);
   void onNfccShutdown();
@@ -48,13 +48,19 @@ class RoutingManager {
   void updateRoutingTable();
   void eeSetPwrAndLinkCtrl(uint8_t config);
   void updateIsoDepProtocolRoute(int route);
-  tNFA_TECHNOLOGY_MASK updateTechnologyABFRoute(int route);
+  tNFA_TECHNOLOGY_MASK updateTechnologyABFRoute(int route, int felicaRoute);
+  void updateSystemCodeRoute(int route);
   void clearRoutingEntry(int clearFlags);
   void setEeTechRouteUpdateRequired();
+  void notifyEeAidSelected(tNFC_AID& aid, tNFA_HANDLE ee_handle);
+  void notifyEeProtocolSelected(uint8_t protocol, tNFA_HANDLE ee_handle);
+  void notifyEeTechSelected(uint8_t tech, tNFA_HANDLE ee_handle);
+  bool getNameOfEe(tNFA_HANDLE ee_handle, std::string& eeName);
 
   static const int CLEAR_AID_ENTRIES = 0x01;
   static const int CLEAR_PROTOCOL_ENTRIES = 0x02;
   static const int CLEAR_TECHNOLOGY_ENTRIES = 0x04;
+  SyncEvent mEeUpdateEvent;
 
  private:
   RoutingManager();
@@ -90,6 +96,10 @@ class RoutingManager {
       JNIEnv* e);
   static int com_android_nfc_cardemulation_doGetDefaultOffHostRouteDestination(
       JNIEnv* e);
+  static int com_android_nfc_cardemulation_doGetDefaultFelicaRouteDestination(
+      JNIEnv* e);
+  static int com_android_nfc_cardemulation_doGetDefaultScRouteDestination(
+      JNIEnv* e);
   static jbyteArray com_android_nfc_cardemulation_doGetOffHostUiccDestination(
       JNIEnv* e);
   static jbyteArray com_android_nfc_cardemulation_doGetOffHostEseDestination(
@@ -129,7 +139,6 @@ class RoutingManager {
   static const JNINativeMethod sMethods[];
   SyncEvent mEeRegisterEvent;
   SyncEvent mRoutingEvent;
-  SyncEvent mEeUpdateEvent;
   SyncEvent mEeInfoEvent;
   SyncEvent mEeSetModeEvent;
   SyncEvent mEePwrAndLinkCtrlEvent;
diff --git a/nci/jni/nfc_test_config_template.xml b/nci/jni/nfc_test_config_template.xml
new file mode 100644
index 00000000..2a49886c
--- /dev/null
+++ b/nci/jni/nfc_test_config_template.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2024 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Configuration for {MODULE} Rust tests">
+   <target_preparer class="com.android.tradefed.targetprep.RootTargetPreparer"/>
+   <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.nfcservices.apex" />
+   <target_preparer class="com.android.compatibility.common.tradefed.targetprep.FilePusher">
+       <option name="cleanup" value="true" />
+       <option name="push" value="{MODULE}->/data/local/tmp/{MODULE}" />
+       <option name="append-bitness" value="true" />
+   </target_preparer>
+   <test class="com.android.tradefed.testtype.rust.RustBinaryTest" >
+       <option name="test-device-path" value="/data/local/tmp" />
+       <option name="module-name" value="{MODULE}" />
+   </test>
+   <object type="module_controller"
+           class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+       <option name="mainline-module-package-name" value="com.google.android.nfcservices" />
+   </object>
+   <object type="module_controller"
+           class="com.android.tradefed.testtype.suite.module.DeviceFeatureModuleController">
+        <option name="required-feature" value="android.hardware.nfc.any" />
+   </object>
+</configuration>
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
old mode 100755
new mode 100644
index c994d6b6..9e9ee766
--- a/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcManager.java
@@ -31,10 +31,11 @@ import android.util.Log;
 
 import com.android.nfc.DeviceHost;
 import com.android.nfc.NfcDiscoveryParameters;
+import com.android.nfc.NfcProprietaryCaps;
 import com.android.nfc.NfcService;
 import com.android.nfc.NfcStatsLog;
 import com.android.nfc.NfcVendorNciResponse;
-import com.android.nfc.NfcProprietaryCaps;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -42,8 +43,9 @@ import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HexFormat;
 import java.util.Iterator;
-import java.util.List;
+import java.util.Map;
 
 /** Native interface to the NFC Manager functions */
 public class NativeNfcManager implements DeviceHost {
@@ -57,6 +59,7 @@ public class NativeNfcManager implements DeviceHost {
 
     private int mIsoDepMaxTransceiveLength;
     private final DeviceHostListener mListener;
+    private final NativeT4tNfceeManager mT4tNfceeMgr;
     private final Context mContext;
 
     private final Object mLock = new Object();
@@ -82,6 +85,7 @@ public class NativeNfcManager implements DeviceHost {
         loadLibrary();
         initializeNativeStructure();
         mContext = context;
+        mT4tNfceeMgr = new NativeT4tNfceeManager();
     }
 
     public native boolean initializeNativeStructure();
@@ -100,7 +104,7 @@ public class NativeNfcManager implements DeviceHost {
     @Override
     public boolean initialize() {
         boolean ret = doInitialize();
-        if (isProprietaryGetCapsSupported()) {
+        if (ret && isProprietaryGetCapsSupported()) {
             mProprietaryCaps = NfcProprietaryCaps.createFromByteArray(getProprietaryCaps());
             Log.i(TAG, "mProprietaryCaps: " + mProprietaryCaps);
             logProprietaryCaps(mProprietaryCaps);
@@ -183,7 +187,7 @@ public class NativeNfcManager implements DeviceHost {
     public native boolean unrouteAid(byte[] aid);
 
     @Override
-    public native boolean commitRouting();
+    public native int commitRouting();
 
     public native int doRegisterT3tIdentifier(byte[] t3tIdentifier);
 
@@ -214,10 +218,29 @@ public class NativeNfcManager implements DeviceHost {
         if (!NfcProperties.observe_mode_supported().orElse(true)) {
             return false;
         }
+        if (com.android.nfc.flags.Flags.observeModeWithoutRf()) {
+            if (isProprietaryGetCapsSupported()) {
+                return isObserveModeSupportedWithoutRfDeactivation();
+            }
+            return false;
+        } else {
+            if (isProprietaryGetCapsSupported()) {
+                return isObserveModeSupportedCaps(mProprietaryCaps);
+            }
+            return true;
+        }
+    }
+
+    @Override
+    public boolean isFirmwareExitFramesSupported() {
+        if (!com.android.nfc.flags.Flags.exitFrames()) {
+            return false;
+        }
         if (isProprietaryGetCapsSupported()) {
-            return isObserveModeSupportedCaps(mProprietaryCaps);
+            return mProprietaryCaps.isAutotransactPollingLoopFilterSupported()
+                    && mProprietaryCaps.getNumberOfExitFramesSupported() > 0;
         }
-        return true;
+        return false;
     }
 
     @Override
@@ -226,6 +249,41 @@ public class NativeNfcManager implements DeviceHost {
     @Override
     public native boolean isObserveModeEnabled();
 
+    @Override
+    public int   getT4TNfceePowerState() {
+        return mT4tNfceeMgr.getT4TNfceePowerState();
+    }
+
+    @Override
+    public int getNdefNfceeRouteId() {
+        return mT4tNfceeMgr.getNdefNfceeRouteId();
+    }
+
+    @Override
+    public int doWriteData(byte[] fileId, byte[] data) {
+        return mT4tNfceeMgr.doWriteData(fileId, data);
+    }
+
+    @Override
+    public byte[] doReadData(byte[] fileId) {
+        return mT4tNfceeMgr.doReadData(fileId);
+    }
+
+    @Override
+    public boolean doClearNdefData() {
+        return mT4tNfceeMgr.doClearNdefData();
+    }
+
+    @Override
+    public boolean isNdefOperationOngoing() {
+        return mT4tNfceeMgr.isNdefOperationOngoing();
+    }
+
+    @Override
+    public boolean isNdefNfceeEmulationSupported() {
+        return mT4tNfceeMgr.isNdefNfceeEmulationSupported();
+    }
+
     @Override
     public void registerT3tIdentifier(byte[] t3tIdentifier) {
         synchronized (mLock) {
@@ -389,7 +447,7 @@ public class NativeNfcManager implements DeviceHost {
     public native boolean isMultiTag();
 
     @Override
-    public native List<String> dofetchActiveNfceeList();
+    public native Map<String, Integer> dofetchActiveNfceeList();
 
     private native NfcVendorNciResponse nativeSendRawVendorCmd(
             int mt, int gid, int oid, byte[] payload);
@@ -437,6 +495,27 @@ public class NativeNfcManager implements DeviceHost {
         mListener.onHwErrorReported();
     }
 
+    private void notifyEeAidSelected(byte[] aid, String eventSrc) {
+        Log.i(TAG, "AID: " + HexFormat.of().formatHex(aid) + " selected by " + eventSrc);
+        if (com.android.nfc.flags.Flags.eeAidSelect()) {
+            mListener.onSeSelected();
+        }
+    }
+
+    private void notifyEeProtocolSelected(int protocol, String eventSrc) {
+        Log.i(TAG, "Protocol: " + protocol + " selected by " + eventSrc);
+        if (com.android.nfc.flags.Flags.eeAidSelect()) {
+            mListener.onSeSelected();
+        }
+    }
+
+    private void notifyEeTechSelected(int tech, String eventSrc) {
+        Log.i(TAG, "Tech: " + tech + " selected by " + eventSrc);
+        if (com.android.nfc.flags.Flags.eeAidSelect()) {
+            mListener.onSeSelected();
+        }
+    }
+
     public void notifyPollingLoopFrame(int data_len, byte[] p_data) {
         if (data_len < MIN_POLLING_FRAME_TLV_SIZE) {
             return;
@@ -521,6 +600,9 @@ public class NativeNfcManager implements DeviceHost {
     private void notifyWlcStopped(int wpt_end_condition) {
         mListener.onWlcStopped(wpt_end_condition);
     }
+    private void notifyTagDiscovered(boolean discovered) {
+        mListener.onTagRfDiscovered(discovered);
+    }
     private void notifyVendorSpecificEvent(int event, int dataLen, byte[] pData) {
         if (pData.length < NCI_HEADER_MIN_LEN || dataLen != pData.length) {
             Log.e(TAG, "Invalid data");
@@ -536,6 +618,10 @@ public class NativeNfcManager implements DeviceHost {
         mListener.onRfDiscoveryEvent(isDiscoveryStarted);
     }
 
+    private void notifyEeListenActivated(boolean isActivated) {
+        mListener.onEeListenActivated(isActivated);
+    }
+
     @Override
     public native void setDiscoveryTech(int pollTech, int listenTech);
 
@@ -549,7 +635,10 @@ public class NativeNfcManager implements DeviceHost {
     public native void setIsoDepProtocolRoute(int route);
 
     @Override
-    public native void setTechnologyABFRoute(int route);
+    public native void setTechnologyABFRoute(int route, int felicaRoute);
+
+    @Override
+    public native void setSystemCodeRoute(int route);
 
     private native byte[] getProprietaryCaps();
 
@@ -557,6 +646,9 @@ public class NativeNfcManager implements DeviceHost {
     public native void enableVendorNciNotifications(boolean enabled);
 
     private void notifyCommandTimeout() {
+        if (android.nfc.Flags.nfcEventListener()) {
+            mListener.onCommandTimeout();
+        }
         NfcService.getInstance().storeNativeCrashLogs();
     }
 
@@ -592,7 +684,8 @@ public class NativeNfcManager implements DeviceHost {
                 observeModeStatsd,
                 proprietaryCaps.isPollingFrameNotificationSupported(),
                 proprietaryCaps.isPowerSavingModeSupported(),
-                proprietaryCaps.isAutotransactPollingLoopFilterSupported());
+                proprietaryCaps.isAutotransactPollingLoopFilterSupported(),
+                proprietaryCaps.getNumberOfExitFramesSupported());
     }
 
     public void notifyObserveModeChanged(boolean enabled) {
diff --git a/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java b/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
index 2abc6f41..b4dd5374 100755
--- a/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
+++ b/nci/src/com/android/nfc/dhimpl/NativeNfcTag.java
@@ -159,47 +159,19 @@ public class NativeNfcTag implements TagEndpoint {
         int status = -1;
         for (int i = 0; i < mTechList.length; i++) {
             if (mTechList[i] == technology) {
-                // Get the handle and connect, if not already connected
-                if (mConnectedHandle != mTechHandles[i]) {
-                    // We're not yet connected to this handle, there are
-                    // a few scenario's here:
-                    // 1) We are not connected to anything yet - allow
-                    // 2) We are connected to a technology which has
-                    //    a different handle (multi-protocol tag); we support
-                    //    switching to that.
-                    if (mConnectedHandle == -1) {
-                        // Not connected yet
-                        // status = doConnect(mTechHandles[i]);
-                        status = doConnect(i);
-                    } else {
-                        // Connect to a tech with a different handle
-                        Log.d(TAG, "Connect to a tech with a different handle");
-                        // status = reconnectWithStatus(mTechHandles[i]);
-                        status = reconnectWithStatus(i);
-                    }
-                    if (status == 0) {
-                        mConnectedHandle = mTechHandles[i];
-                        mConnectedTechIndex = i;
-                    }
-                } else {
-                    // 1) We are connected to a technology which has the same
-                    //    handle; we do not support connecting at a different
-                    //    level (libnfc auto-activates to the max level on
-                    //    any handle).
-                    // 2) We are connecting to the ndef technology - always
-                    //    allowed.
-                    if ((technology == TagTechnology.NDEF)
-                            || (technology == TagTechnology.NDEF_FORMATABLE)) {
-                        // special case for NDEF, this will cause switch to ISO_DEP frame intf
-                        i = 0;
-                        // status = 0;
-                    }
-                    status = reconnectWithStatus(i);
-                    if (status == 0) {
-                        mConnectedTechIndex = i;
-                        // Handle was already identical
-                    }
+                if ((technology == TagTechnology.NDEF)
+                        || (technology == TagTechnology.NDEF_FORMATABLE)) {
+                    // special case for NDEF, this will cause switch to ISO_DEP frame intf
+                    i = 0;
+                }
+
+                status = doConnect(i);
+
+                if (status == 0) {
+                    mConnectedHandle = mTechHandles[i];
+                    mConnectedTechIndex = i;
                 }
+
                 break;
             }
         }
@@ -209,6 +181,33 @@ public class NativeNfcTag implements TagEndpoint {
         return status;
     }
 
+    /**
+     * connectWithIdx() is use by findAndReadNdef()
+     * Update of variables mConnectedTechIndex and mConnectedHandle when
+     * performing reconnect().
+     */
+    public synchronized int connectWithIdx(int idx) {
+        if (DBG) Log.d(TAG, "connectWithIdx() - idx: " + idx);
+        if (mWatchdog != null) {
+            mWatchdog.pause();
+        }
+        int status = -1;
+
+        // Not connected yet
+        // status = doConnect(mTechHandles[i]);
+        status = doConnect(idx);
+
+        if (status == 0) {
+            mConnectedHandle = mTechHandles[idx];
+            mConnectedTechIndex = idx;
+        }
+
+        if (mWatchdog != null) {
+            mWatchdog.doResume();
+        }
+        return status;
+    }
+
     @Override
     public synchronized boolean connect(int technology) {
         return connectWithStatus(technology) == 0;
@@ -275,33 +274,31 @@ public class NativeNfcTag implements TagEndpoint {
 
     native int doReconnect();
 
-    public synchronized int reconnectWithStatus() {
-        if (mWatchdog != null) {
-            mWatchdog.pause();
-        }
-        int status = doReconnect();
-        if (mWatchdog != null) {
-            mWatchdog.doResume();
-        }
-        return status;
-    }
-
     @Override
     public synchronized boolean reconnect() {
-        return reconnectWithStatus() == 0;
-    }
-
-    native int doHandleReconnect(int handle);
-
-    public synchronized int reconnectWithStatus(int handle) {
+        if (DBG) Log.d(TAG, "reconnect() ");
         if (mWatchdog != null) {
             mWatchdog.pause();
         }
-        int status = doHandleReconnect(handle);
+        int status = doReconnect();
+        if (status == 0x00) {
+            // Reconnection might change the current connected target idx
+            // If connected to frame RF/ISO-DEP it will got back to
+            // ISO-DEP/ISO-DEP
+            // If connected to frame RF/MIFARE it will got back to
+            // MIFARE/MIFARE
+            for (int i = 0; i < mTechLibNfcTypes.length; i++) {
+                if (mTechLibNfcTypes[mConnectedTechIndex] == mTechLibNfcTypes[i]) {
+                    mConnectedTechIndex = i;
+                    mConnectedHandle = mTechHandles[i];
+                    break;
+                }
+            }
+        }
         if (mWatchdog != null) {
             mWatchdog.doResume();
         }
-        return status;
+        return (status == 0);
     }
 
     private native byte[] doTransceive(byte[] data, boolean raw, int[] returnCode);
@@ -778,26 +775,40 @@ public class NativeNfcTag implements TagEndpoint {
         }
     }
 
+    private boolean isMifareDesfireTag() {
+        for (int i = 0; i < mTechList.length; i++) {
+            if (mTechList[i] != TagTechnology.NFC_A) {
+                continue;
+            } else if ((mTechActBytes[i] == null) || (mTechActBytes[i].length == 0)) {
+                continue;
+            } else if (((mTechActBytes[i][0] & (short) 0xFF) == 0x20)
+                    && (((mTechPollBytes[i][0] & (short) 0xFF) == 0x44)
+                            || (((mTechPollBytes[i][0] & (short) 0xFF) == 0x04)))
+                    && ((mTechPollBytes[i][1] & (short) 0xFF) == 0x03)) {
+                if (DBG) Log.d(TAG, "isMifareDesfireTag() - true, need reconnect()");
+                return true;
+            }
+        }
+        return false;
+    }
+
     @Override
     public NdefMessage findAndReadNdef() {
         // Try to find NDEF on any of the technologies.
         int[] technologies = getTechList();
-        int[] handles = mTechHandles;
         NdefMessage ndefMsg = null;
         boolean foundFormattable = false;
         int formattableHandle = 0;
         int formattableLibNfcType = 0;
         int status;
+        int currentTargetTech = 0;
 
         for (int techIndex = 0; techIndex < technologies.length; techIndex++) {
-            // have we seen this handle before?
-            for (int i = 0; i < techIndex; i++) {
-                if (handles[i] == handles[techIndex]) {
-                    continue; // don't check duplicate handles
-                }
+            if (currentTargetTech == technologies[techIndex]) {
+                continue;
             }
-
-            status = connectWithStatus(technologies[techIndex]);
+            currentTargetTech = technologies[techIndex];
+            status = connectWithIdx(techIndex);
             if (status != 0) {
                 Log.d(TAG, "Connect Failed - status = " + status);
                 if (status == STATUS_CODE_TARGET_LOST) {
@@ -814,8 +825,11 @@ public class NativeNfcTag implements TagEndpoint {
                     // We'll only add formattable tech if no ndef is
                     // found - this is because libNFC refuses to format
                     // an already NDEF formatted tag.
+                    if (isMifareDesfireTag()) {
+                        reconnect();
+                        connectWithIdx(techIndex);
+                    }
                 }
-                reconnect();
             }
 
             int[] ndefinfo = new int[2];
@@ -844,7 +858,6 @@ public class NativeNfcTag implements TagEndpoint {
                             getConnectedTechnology(),
                             supportedNdefLength,
                             cardState);
-                    reconnect();
                 } catch (FormatException e) {
                     // Create an intent anyway, without NDEF messages
                     generateEmptyNdef = true;
@@ -864,7 +877,6 @@ public class NativeNfcTag implements TagEndpoint {
                         supportedNdefLength,
                         cardState);
                 foundFormattable = false;
-                reconnect();
             }
             break;
         }
diff --git a/nci/src/com/android/nfc/dhimpl/NativeT4tNfceeManager.java b/nci/src/com/android/nfc/dhimpl/NativeT4tNfceeManager.java
new file mode 100644
index 00000000..bae35449
--- /dev/null
+++ b/nci/src/com/android/nfc/dhimpl/NativeT4tNfceeManager.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.dhimpl;
+
+import com.android.nfc.DeviceHost;
+
+public class NativeT4tNfceeManager {
+  public native int doWriteData(byte[] fileId, byte[] data);
+
+  public native byte[] doReadData(byte[] fileId);
+
+  public native boolean doClearNdefData();
+
+  public native boolean isNdefOperationOngoing();
+
+  public native boolean isNdefNfceeEmulationSupported();
+
+  public native int getNdefNfceeRouteId();
+
+  public native int getT4TNfceePowerState();
+}
diff --git a/proto/event.proto b/proto/event.proto
index 0aca4529..e79819c8 100644
--- a/proto/event.proto
+++ b/proto/event.proto
@@ -48,6 +48,11 @@ message EventType {
     NfcWlcStateChange wlc_state_change = 12;
     NfcReaderOptionChange reader_option_change = 13;
     NfcClearPreference clear_preference = 14;
+    NfcCeRoutedAid ce_routed_aid = 15;
+    NfcAidRegistration aid_registration = 16;
+    NfcPollingLoopRegistration polling_loop_registration = 17;
+    NfcDataMigrationInProgress data_migration_in_progress = 18;
+    NfcPaymentServiceBindState payment_service_bind_state = 19;
   }
 }
 
@@ -60,6 +65,11 @@ message NfcAppInfo {
   optional int32 uid = 2;
 }
 
+message NfcComponentInfo {
+  optional string package_name = 1;
+  optional string class_name = 2;
+}
+
 message NfcStateChange {
   required NfcAppInfo app_info = 1;
   required bool enabled = 2;
@@ -96,7 +106,7 @@ message NfcHostCardEmulationData {
 }
 
 message NfcRemoteFieldStateChange {
-  required bool enable = 1;
+  required bool field_on = 1;
 }
 
 message NfcDiscoveryTechnologyUpdate {
@@ -119,3 +129,38 @@ message NfcReaderOptionChange {
 }
 
 message NfcClearPreference {}
+
+message NfcCeRoutedAid {
+  required string aid = 1;
+  required NfcComponentInfo component_info = 2;
+}
+
+message NfcAidRegistration {
+  required NfcAppInfo app_info = 1;
+  required NfcComponentInfo component_info = 2;
+  required bool is_registration = 3;
+  repeated string aids = 4;
+}
+
+message NfcPollingLoopRegistration {
+  required NfcAppInfo app_info = 1;
+  required NfcComponentInfo component_info = 2;
+  required bool is_registration = 3;
+  required string polling_loop_filter = 4;
+}
+
+message NfcDataMigrationInProgress {
+  required NfcAppInfo app_info = 1;
+  required bool in_progress = 2;
+}
+
+enum BindState {
+  SERVICE_CONNECTED = 0;
+  SERVICE_DISCONNECTED = 1;
+  SERVICE_BINDING_DIED = 2;
+}
+
+message NfcPaymentServiceBindState {
+  required NfcComponentInfo component_info = 1;
+  required BindState bind_state = 2;
+}
diff --git a/res/color/nfc_icon.xml b/res/color/nfc_icon.xml
index 87a0d1e7..05ef593e 100644
--- a/res/color/nfc_icon.xml
+++ b/res/color/nfc_icon.xml
@@ -16,5 +16,5 @@
 -->
 <selector xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:androidprv="http://schemas.android.com/apk/prv/res/android">
-    <item android:color="?androidprv:attr/materialColorPrimaryContainer" />
+    <item android:color="@androidprv:color/materialColorPrimaryContainer" />
 </selector>
diff --git a/res/values-af/strings.xml b/res/values-af/strings.xml
index b4b4d030..139c687f 100644
--- a/res/values-af/strings.xml
+++ b/res/values-af/strings.xml
@@ -30,7 +30,7 @@
     <string name="tap_again_to_pay" msgid="5754988005412859897">"Tik weer om met <xliff:g id="APP">%1$s</xliff:g> te betaal"</string>
     <string name="tap_again_to_complete" msgid="5423640945118279123">"Tik weer om met <xliff:g id="APP">%1$s</xliff:g> te voltooi"</string>
     <string name="tap_again_description" msgid="3019101527041529661">"Hou teen leser"</string>
-    <string name="appchooser_description" msgid="2554187931814833244">"Kies program om te skandeer"</string>
+    <string name="appchooser_description" msgid="2554187931814833244">"Kies app om te skandeer"</string>
     <string name="transaction_failure" msgid="7828102078637936513">"Hierdie transaksie kon nie met <xliff:g id="APP">%1$s</xliff:g> voltooi word nie."</string>
     <string name="could_not_use_app" msgid="8137587876138569083">"Kon nie <xliff:g id="APP">%1$s</xliff:g> gebruik nie."</string>
     <string name="pay_with" msgid="5531545488795798945">"Betaal met"</string>
@@ -44,15 +44,17 @@
     <string name="prompt_connect_to_network" msgid="8511683573657516114">"Koppel aan die netwerk <xliff:g id="NETWORK_SSID">%1$s</xliff:g>?"</string>
     <string name="beam_requires_nfc_enabled" msgid="2800366967218600534">"Android Straal vereis dat NFC geaktiveer moet wees. Wil jy dit aktiveer?"</string>
     <string name="android_beam" msgid="1666446406999492763">"Android Straal"</string>
-    <string name="beam_requires_external_storage_permission" msgid="8798337545702206901">"Die program het nie toestemming vir eksterne berging nie. Dit word vereis om hierdie ler te straal"</string>
+    <string name="beam_requires_external_storage_permission" msgid="8798337545702206901">"Die app het nie toestemming vir eksterne berging nie. Dit word vereis om hierdie ler te straal"</string>
     <string name="title_confirm_url_open" msgid="8069968913244794478">"Maak skakel oop?"</string>
     <string name="summary_confirm_url_open" msgid="1246398412196449226">"Jou foon het \'n skakel deur NFC ontvang:"</string>
     <string name="summary_confirm_url_open_tablet" msgid="771152442325809851">"Jou tablet het n skakel deur NFC ontvang:"</string>
     <string name="action_confirm_url_open" msgid="3458322738812921189">"Maak skakel oop"</string>
     <string name="tag_read_error" msgid="2485274498885877547">"NFC-leesfout. Probeer weer."</string>
-    <string name="tag_dispatch_failed" msgid="3562984995049738400">"Geen gesteunde program vir hierdie NFC-merker nie"</string>
+    <string name="tag_dispatch_failed" msgid="3562984995049738400">"Geen gesteunde app vir hierdie NFC-merker nie"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC is dalk geblokkeer"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tik om uit te vind hoe om dit reg te stel."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> via NFC bekendgestel"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tik om uit te vind hoe om dit te deaktiveer."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-data word tans opgeneem"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tik om opname te stop."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Laat <xliff:g id="PKG">%1$s</xliff:g> toe om NFC te aktiveer?"</string>
diff --git a/res/values-am/strings.xml b/res/values-am/strings.xml
index 171fbaff..8e40a981 100644
--- a/res/values-am/strings.xml
+++ b/res/values-am/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC    "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"     "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>   "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"    "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"   "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>   ?"</string>
diff --git a/res/values-ar/strings.xml b/res/values-ar/strings.xml
index f6cc4653..06dd7b23 100644
--- a/res/values-ar/strings.xml
+++ b/res/values-ar/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"      NFC ."</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"   NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"  \"<xliff:g id="APPNAME">%1$s</xliff:g>\"    NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"    ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"       (NFC)"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"  ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"    \"<xliff:g id="PKG">%1$s</xliff:g>\"  NFC"</string>
diff --git a/res/values-as/strings.xml b/res/values-as/strings.xml
index 2721aa30..ec951b59 100644
--- a/res/values-as/strings.xml
+++ b/res/values-as/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC     "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>   "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"       "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC     "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC   ?"</string>
diff --git a/res/values-az/strings.xml b/res/values-az/strings.xml
index 890f6514..8fc3eb86 100644
--- a/res/values-az/strings.xml
+++ b/res/values-az/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"NFC Teq n dstklnn ttbiq yoxdur"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC bloklanm ola bilr"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Nec dzldcyinizi yrnmk n toxunun."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> NFC vasitsil baladld"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Bunu nec deaktiv edcyinizi yrnmk n toxunun."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC datas qeyd alnr"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Qeyd alman dayandrmaq n toxunun."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> n NFC-ni aktivldirmk icazsi verilsin?"</string>
diff --git a/res/values-b+sr+Latn/strings.xml b/res/values-b+sr+Latn/strings.xml
index 830ba363..95bc56f5 100644
--- a/res/values-b+sr+Latn/strings.xml
+++ b/res/values-b+sr+Latn/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nijedna aplikacija ne podrava ovu NFC oznaku"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC je moda blokiran"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Dodirnite da biste saznali kako da reite problem."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikacija <xliff:g id="APPNAME">%1$s</xliff:g> je pokrenuta preko NFC-a"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Dodirnite da biste saznali kako da onemoguite."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC podaci se snimaju"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Dodirnite da biste zaustavili snimanje."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"elite da dozvolite da <xliff:g id="PKG">%1$s</xliff:g> omogui NFC?"</string>
diff --git a/res/values-be/strings.xml b/res/values-be/strings.xml
index ee42a242..ec5d429f 100644
--- a/res/values-be/strings.xml
+++ b/res/values-be/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" ,      NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">", NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">",  ,   ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" \"<xliff:g id="APPNAME">%1$s</xliff:g>\"    NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">",  ,   ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">",   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"  \"<xliff:g id="PKG">%1$s</xliff:g>\"   NFC?"</string>
diff --git a/res/values-bg/strings.xml b/res/values-bg/strings.xml
index a05e65c5..06b77a31 100644
--- a/res/values-bg/strings.xml
+++ b/res/values-bg/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" ,      NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">" NFC    "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">",       ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>   NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">",      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"    NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"     <xliff:g id="PKG">%1$s</xliff:g>   NFC?"</string>
diff --git a/res/values-bn/strings.xml b/res/values-bn/strings.xml
index 2715531c..e096cdd7 100644
--- a/res/values-bn/strings.xml
+++ b/res/values-bn/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC       "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC    "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> NFC-    "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC    "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC    <xliff:g id="PKG">%1$s</xliff:g>-  ?"</string>
diff --git a/res/values-bs/strings.xml b/res/values-bs/strings.xml
index 6b2c6906..ccf854ec 100644
--- a/res/values-bs/strings.xml
+++ b/res/values-bs/strings.xml
@@ -4,17 +4,17 @@
     <string name="app_name" msgid="78565911793142902">"Usluga Nfc"</string>
     <string name="nfcUserLabel" msgid="7708535817084357357">"Nfc"</string>
     <string name="accessibility_nfc_enabled" msgid="7796246979948787735">"NFC je omoguen."</string>
-    <string name="tap_to_beam" msgid="5819197866281059878">"Dodirnite za prijenos"</string>
+    <string name="tap_to_beam" msgid="5819197866281059878">"Dodirnite za prenos"</string>
     <string name="beam_progress" msgid="7453634884807323920">"Dolazni prijenos..."</string>
     <string name="beam_outgoing" msgid="4679536649779123495">"Prenoenje..."</string>
-    <string name="beam_complete" msgid="477026736424637435">"Prijenos je zavren."</string>
-    <string name="beam_failed" msgid="5116241718189888630">"Prijenos nije zavren."</string>
-    <string name="beam_canceled" msgid="5425192751826544741">"Prijenos je otkazan."</string>
+    <string name="beam_complete" msgid="477026736424637435">"Prenos je zavren."</string>
+    <string name="beam_failed" msgid="5116241718189888630">"Prenos nije zavren."</string>
+    <string name="beam_canceled" msgid="5425192751826544741">"Prenos je otkazan."</string>
     <string name="cancel" msgid="61873902552555096">"Otkai"</string>
     <string name="beam_tap_to_view" msgid="7430394753262448349">"Dodirnite za prikaz"</string>
-    <string name="beam_handover_not_supported" msgid="4083165921751489015">"Ureaj primaoca ne podrava prijenos velikih fajlova putem emitiranja."</string>
+    <string name="beam_handover_not_supported" msgid="4083165921751489015">"Ureaj primaoca ne podrava prenos velikih fajlova putem emitiranja."</string>
     <string name="beam_try_again" msgid="3364677301009783455">"Opet spojite ureaje"</string>
-    <string name="beam_busy" msgid="5253335587620612576">"Prijenos je trenutno zauzet. Pokuajte ponovo kada se prethodni transfer zavri."</string>
+    <string name="beam_busy" msgid="5253335587620612576">"Prenos je trenutno zauzet. Pokuajte ponovo kada se prethodni transfer zavri."</string>
     <string name="device" msgid="4459621591392478151">"ureaj"</string>
     <string name="connecting_peripheral" msgid="1296182660525660935">"Povezivanje <xliff:g id="DEVICE_NAME">%1$s</xliff:g>"</string>
     <string name="connected_peripheral" msgid="20748648543160091">"<xliff:g id="DEVICE_NAME">%1$s</xliff:g> povezan"</string>
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nema podrane aplikacije za ovu NFC oznaku"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC je moda blokiran"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Dodirnite da saznate kako ispraviti problem."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikacija <xliff:g id="APPNAME">%1$s</xliff:g> je pokrenuta putem NFC-a"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Dodirnite da saznate kako ovo onemoguiti."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC podaci se trenutno biljee"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Dodirnite da zaustavite biljeenje."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Dozvoliti da <xliff:g id="PKG">%1$s</xliff:g> omogui NFC?"</string>
diff --git a/res/values-ca/strings.xml b/res/values-ca/strings.xml
index c5aab748..be07d4c3 100644
--- a/res/values-ca/strings.xml
+++ b/res/values-ca/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No hi ha cap aplicaci compatible amb aquesta etiquetaNFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"s possible que l\'NFC estigui bloquejada"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Toca per obtenir informaci sobre com pots resoldre-ho."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> s\'ha iniciat a travs d\'NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Toca per obtenir informaci sobre com pots desactivar-ho."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"S\'estan gravant les dades de l\'NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Toca per aturar la gravaci."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vols permetre que <xliff:g id="PKG">%1$s</xliff:g> activi la funci NFC?"</string>
diff --git a/res/values-cs/strings.xml b/res/values-cs/strings.xml
index c525c336..2e80516f 100644
--- a/res/values-cs/strings.xml
+++ b/res/values-cs/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Pro tuto znaku NFC nen kdispozici dn podporovan aplikace"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Funkce NFC me bt zablokovna"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Klepnutm zjistte, jak problm vyeit."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikace <xliff:g id="APPNAME">%1$s</xliff:g> byla sputna pes NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Klepnutm zobrazte pokyny kdeaktivovn."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Data funkce NFC jsou zaznamenvna"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Klepnutm ukonte nahrvn."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Povolit aplikaci <xliff:g id="PKG">%1$s</xliff:g> zapnout NFC?"</string>
diff --git a/res/values-da/strings.xml b/res/values-da/strings.xml
index 15907cb3..122cec28 100644
--- a/res/values-da/strings.xml
+++ b/res/values-da/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Der er ingen understttede apps til dette NFC-tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC kan vre blokeret"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tryk for at se, hvordan du lser problemet."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> er bnet via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tryk for at se, hvordan du deaktiverer den."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-data registreres"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tryk for at stoppe optagelsen."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vil du give <xliff:g id="PKG">%1$s</xliff:g> tilladelse til at aktivere NFC?"</string>
diff --git a/res/values-de/strings.xml b/res/values-de/strings.xml
index d8a95d1a..873a6f30 100644
--- a/res/values-de/strings.xml
+++ b/res/values-de/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Keine untersttzte Anwendung fr dieses NFC-Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC ist mglicherweise blockiert"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tippen, um das Problem zu beheben"</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> ber NFC gestartet"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tippe hier, um zu erfahren, wie du die App deaktivieren kannst."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-Daten werden aufgezeichnet"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tippen, um die Aufzeichnung zu beenden"</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Zulassen, dass <xliff:g id="PKG">%1$s</xliff:g> NFC aktiviert?"</string>
diff --git a/res/values-el/strings.xml b/res/values-el/strings.xml
index 20b85ddc..96dbb5d9 100644
--- a/res/values-el/strings.xml
+++ b/res/values-el/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"        NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"  NFC    ."</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"         ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"  <xliff:g id="APPNAME">%1$s</xliff:g>   NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"       ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"  NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"   <xliff:g id="PKG">%1$s</xliff:g>    NFC;"</string>
diff --git a/res/values-en-rAU/strings.xml b/res/values-en-rAU/strings.xml
index dac0cbd7..7722146f 100644
--- a/res/values-en-rAU/strings.xml
+++ b/res/values-en-rAU/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No supported application for this NFC Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC may be blocked"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tap to learn how to fix."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> launched via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tap to learn how to disable it."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC data is being recorded"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tap to stop recording."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Allow <xliff:g id="PKG">%1$s</xliff:g> to enable NFC?"</string>
diff --git a/res/values-en-rCA/strings.xml b/res/values-en-rCA/strings.xml
index bfe4cb26..ac277442 100644
--- a/res/values-en-rCA/strings.xml
+++ b/res/values-en-rCA/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No supported application for this NFC Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC may be blocked"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tap to learn how to fix."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> launched via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tap to learn how to disable it."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC data is being recorded"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tap to stop recording."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Allow <xliff:g id="PKG">%1$s</xliff:g> to enable NFC?"</string>
diff --git a/res/values-en-rGB/strings.xml b/res/values-en-rGB/strings.xml
index dac0cbd7..7722146f 100644
--- a/res/values-en-rGB/strings.xml
+++ b/res/values-en-rGB/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No supported application for this NFC Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC may be blocked"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tap to learn how to fix."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> launched via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tap to learn how to disable it."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC data is being recorded"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tap to stop recording."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Allow <xliff:g id="PKG">%1$s</xliff:g> to enable NFC?"</string>
diff --git a/res/values-en-rIN/strings.xml b/res/values-en-rIN/strings.xml
index dac0cbd7..7722146f 100644
--- a/res/values-en-rIN/strings.xml
+++ b/res/values-en-rIN/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No supported application for this NFC Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC may be blocked"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tap to learn how to fix."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> launched via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tap to learn how to disable it."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC data is being recorded"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tap to stop recording."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Allow <xliff:g id="PKG">%1$s</xliff:g> to enable NFC?"</string>
diff --git a/res/values-es-rUS/strings.xml b/res/values-es-rUS/strings.xml
index 9f902290..ec1b2cd2 100644
--- a/res/values-es-rUS/strings.xml
+++ b/res/values-es-rUS/strings.xml
@@ -29,7 +29,7 @@
     <string name="pair_no" msgid="5022308368904055020">"No"</string>
     <string name="tap_again_to_pay" msgid="5754988005412859897">"Presionar de nuevo para pagar con <xliff:g id="APP">%1$s</xliff:g>"</string>
     <string name="tap_again_to_complete" msgid="5423640945118279123">"Presionar de nuevo para completar con <xliff:g id="APP">%1$s</xliff:g>"</string>
-    <string name="tap_again_description" msgid="3019101527041529661">"Acerca al lector"</string>
+    <string name="tap_again_description" msgid="3019101527041529661">"Acercar al lector"</string>
     <string name="appchooser_description" msgid="2554187931814833244">"Elige una app para escanear"</string>
     <string name="transaction_failure" msgid="7828102078637936513">"No se pudo completar la transaccin con <xliff:g id="APP">%1$s</xliff:g>."</string>
     <string name="could_not_use_app" msgid="8137587876138569083">"No se pudo utilizar <xliff:g id="APP">%1$s</xliff:g>."</string>
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No hay apps compatibles con esta etiqueta NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Es posible que la funcin NFC est bloqueada"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Presiona para ver cmo corregir el problema."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> se inici a travs de NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Presiona aqu y descubre cmo deshabilitarlo."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Los datos de NFC se estn registrando"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Presiona para dejar de registrarlos."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Quieres permitir que <xliff:g id="PKG">%1$s</xliff:g> habilite la NFC?"</string>
diff --git a/res/values-es/strings.xml b/res/values-es/strings.xml
index 3e61a2ff..df9dc330 100644
--- a/res/values-es/strings.xml
+++ b/res/values-es/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No hay ninguna aplicacin compatible con esta etiqueta NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Es posible que el NFC est bloqueado"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Toca para saber cmo solucionarlo."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> se ha iniciado mediante NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Toca para consultar cmo inhabilitarlo."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Los datos de NFC se estn registrando"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Toca para detener el registro."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Permitir que <xliff:g id="PKG">%1$s</xliff:g> habilite la opcin NFC?"</string>
diff --git a/res/values-et/strings.xml b/res/values-et/strings.xml
index 657ba0ac..3d216707 100644
--- a/res/values-et/strings.xml
+++ b/res/values-et/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Selle NFC-kiibi puhul toetatud rakendus puudub"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC vib olla blokeeritud"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Puudutage, et hankida parandamise kohta lisateavet."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Rakendus <xliff:g id="APPNAME">%1$s</xliff:g> kivitati NFC kaudu"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Puudutage, et saada teavet selle keelamise kohta."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC andmeid salvestatakse"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Puudutage salvestamise alustamiseks."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Kas lubada paketil <xliff:g id="PKG">%1$s</xliff:g> vimaldada NFC kasutamine?"</string>
diff --git a/res/values-eu/strings.xml b/res/values-eu/strings.xml
index d66f296f..bdf64c36 100644
--- a/res/values-eu/strings.xml
+++ b/res/values-eu/strings.xml
@@ -35,7 +35,7 @@
     <string name="could_not_use_app" msgid="8137587876138569083">"Ezin izan da <xliff:g id="APP">%1$s</xliff:g> erabili."</string>
     <string name="pay_with" msgid="5531545488795798945">"Ordaindu honekin"</string>
     <string name="complete_with" msgid="6797459104103012992">"Ekintza osatzeko aplikazioak"</string>
-    <string name="default_pay_app_removed" msgid="4108250545457437360">"Ukitu eta ordaindu eginbidea erabiltzeko zerbitzu hobetsia kendu egin da. Beste bat aukeratu nahi duzu?"</string>
+    <string name="default_pay_app_removed" msgid="4108250545457437360">"Kontakturik gabe ordaintzeko eginbidea erabiltzeko zerbitzu hobetsia kendu egin da. Beste bat aukeratu nahi duzu?"</string>
     <string name="ask_nfc_tap" msgid="2925239870458286340">"Datuak bidaltzeko, ukitu beste gailu bat"</string>
     <string name="wifi_connect" msgid="6250727951843550671">"Konektatu"</string>
     <string name="status_unable_to_connect" msgid="9183908200295307657">"Ezin da sarera konektatu"</string>
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Ez dago NFC etiketa hau onartzen duen aplikaziorik"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Baliteke NFC bidezko konexioa blokeatzea"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Sakatu hau arazoa konpontzeko argibideak lortzeko."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> exekutatu da NFC bidez"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Desgaitzeko argibideak lortzeko, sakatu hau."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFCari buruzko datuak erregistratzen"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Sakatu hau grabatzeari uzteko."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC gaitzeko baimena eman nahi diozu <xliff:g id="PKG">%1$s</xliff:g> zerbitzuari?"</string>
diff --git a/res/values-fa/strings.xml b/res/values-fa/strings.xml
index 7a8e28dc..b0997ac8 100644
--- a/res/values-fa/strings.xml
+++ b/res/values-fa/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"    NFC  "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"    (NFC)  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"        ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC  "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>   NFC   "</string>
diff --git a/res/values-fi/strings.xml b/res/values-fi/strings.xml
index 5f110d05..3506be96 100644
--- a/res/values-fi/strings.xml
+++ b/res/values-fi/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Ei NFC-tagia tukevia sovelluksia"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC saattaa olla estetty"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Napauta, jos haluat oppia korjaamaan ongelman."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> kynnistetty NFC:ll"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Siirry kytstpoisto-ohjeisiin napauttamalla."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-dataa tallennetaan"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Lopeta tallennus napauttamalla."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Saako <xliff:g id="PKG">%1$s</xliff:g> ottaa NFC:n kyttn?"</string>
diff --git a/res/values-fr-rCA/strings.xml b/res/values-fr-rCA/strings.xml
index 421da1c3..fef82258 100644
--- a/res/values-fr-rCA/strings.xml
+++ b/res/values-fr-rCA/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Aucune appli prise en charge pour cette baliseCCP"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"La CCP est peut-tre bloque"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Touchez pour apprendre comment la dbloquer."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> lance via CCP"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Touchez pour la dsactiver."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Les donnes CCP sont enregistres"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Touchez pour cesser l\'enregistrement."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Autoriser <xliff:g id="PKG">%1$s</xliff:g>  activer la CCP?"</string>
diff --git a/res/values-fr/strings.xml b/res/values-fr/strings.xml
index 38bf2d73..a30d1c67 100644
--- a/res/values-fr/strings.xml
+++ b/res/values-fr/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Aucune application compatible avec ce tag NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"La fonctionnalit NFC est peut-tre bloque"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Appuyez pour savoir comment y remdier."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"L\'appli <xliff:g id="APPNAME">%1$s</xliff:g> a t lance via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Appuyez pour savoir comment la dsactiver."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Enregistrement de donnes NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Appuyez pour arrter l\'enregistrement."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Autoriser <xliff:g id="PKG">%1$s</xliff:g>  activer le NFC?"</string>
diff --git a/res/values-gl/strings.xml b/res/values-gl/strings.xml
index 32baef42..2649ca9a 100644
--- a/res/values-gl/strings.xml
+++ b/res/values-gl/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Non hai ningunha aplicacin compatible para esta etiqueta NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"A NFC pode estar bloqueada"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Toca para ver como podes solucionalo."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"A aplicacin <xliff:g id="APPNAME">%1$s</xliff:g> activouse a travs de NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Toca para saber como desactivala."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Estanse gravando os datos de NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Toca para deter a gravacin."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Queres permitir que <xliff:g id="PKG">%1$s</xliff:g> active a NFC?"</string>
diff --git a/res/values-gu/strings.xml b/res/values-gu/strings.xml
index ad869f23..ec8eb2c0 100644
--- a/res/values-gu/strings.xml
+++ b/res/values-gu/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC     "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>   "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC      "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g> NFC    ?"</string>
diff --git a/res/values-hi/strings.xml b/res/values-hi/strings.xml
index 94e67268..99c99db6 100644
--- a/res/values-hi/strings.xml
+++ b/res/values-hi/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"     ,        "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC       "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"           ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>       "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"         ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"       "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"      ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"       <xliff:g id="PKG">%1$s</xliff:g>    ?"</string>
diff --git a/res/values-hr/strings.xml b/res/values-hr/strings.xml
index e8d8225a..e1e2e203 100644
--- a/res/values-hr/strings.xml
+++ b/res/values-hr/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nema podrane aplikacije za ovu oznaku NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC je moda blokiran"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Dodirnite da biste saznali kako to ispraviti."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikacija <xliff:g id="APPNAME">%1$s</xliff:g> pokrenuta putem NFC-a"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Dodirnite da biste saznali kako to onemoguiti."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Snimaju se podaci NFC-a"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Dodirnite da biste zaustavili snimanje."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"elite li paketu <xliff:g id="PKG">%1$s</xliff:g> dopustiti da omogui NFC?"</string>
diff --git a/res/values-hu/strings.xml b/res/values-hu/strings.xml
index f3ba6777..bd92d225 100644
--- a/res/values-hu/strings.xml
+++ b/res/values-hu/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nem tallhat tmogatott alkalmazs ehhez az NFC-cmkhez"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Elfordulhat, hogy le van tiltva az NFC"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Koppintssal tovbbi informcikhoz juthat a problma elhrtsrl."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC-n keresztl elindtva"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Ide koppintva megtudhatja, hogyan tilthatja le a funkcit."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"A rendszer rgzti az NFC-adatokat"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Koppintson a rgzts lelltshoz."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Engedlyezi a(z) <xliff:g id="PKG">%1$s</xliff:g> szmra az NFC bekapcsolst?"</string>
diff --git a/res/values-hy/strings.xml b/res/values-hy/strings.xml
index 60f29440..ff3e994d 100644
--- a/res/values-hy/strings.xml
+++ b/res/values-hy/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC     "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"  NFC-  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"     "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>    NFC- "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">" ,      "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>-  NFC-"</string>
diff --git a/res/values-in/strings.xml b/res/values-in/strings.xml
index a91533bf..8ea468a3 100644
--- a/res/values-in/strings.xml
+++ b/res/values-in/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Aplikasi tidak didukung untuk Tag NFC ini"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC mungkin diblokir"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Ketuk untuk mempelajari cara memperbaikinya."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> diluncurkan melalui NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Ketuk untuk mempelajari cara menonaktifkannya."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Data NFC sedang direkam"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Ketuk untuk menghentikan perekaman."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Izinkan <xliff:g id="PKG">%1$s</xliff:g> untuk mengaktifkan NFC?"</string>
diff --git a/res/values-is/strings.xml b/res/values-is/strings.xml
index 0096620d..3e5bbe2f 100644
--- a/res/values-is/strings.xml
+++ b/res/values-is/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Ekkert stutt forrit fyrir etta NFC-merki"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Hugsanlega er loka  NFC"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"ttu til a kynna r hvernig m lagfra etta."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> rst me NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"ttu til a kynna r hvernig  a slkkva  v."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-ggn eru skr"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"ttu til a htta upptku."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Leyfa <xliff:g id="PKG">%1$s</xliff:g> a kveikja  NFC?"</string>
diff --git a/res/values-it/strings.xml b/res/values-it/strings.xml
index 915c5abf..1d118f5d 100644
--- a/res/values-it/strings.xml
+++ b/res/values-it/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nessuna app supportata per questo tag NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"La tecnologia NFC potrebbe essere bloccata"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tocca per scoprire come risolvere il problema."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"App <xliff:g id="APPNAME">%1$s</xliff:g> avviata tramite NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tocca per scoprire come disattivarla."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" in corso la registrazione dei dati NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tocca per interrompere la registrazione."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Consentire a <xliff:g id="PKG">%1$s</xliff:g> di attivare NFC?"</string>
diff --git a/res/values-iw/strings.xml b/res/values-iw/strings.xml
index 21cd0c16..caf9b6fd 100644
--- a/res/values-iw/strings.xml
+++ b/res/values-iw/strings.xml
@@ -4,14 +4,14 @@
     <string name="app_name" msgid="78565911793142902">" Nfc"</string>
     <string name="nfcUserLabel" msgid="7708535817084357357">"Nfc"</string>
     <string name="accessibility_nfc_enabled" msgid="7796246979948787735">"NFC ."</string>
-    <string name="tap_to_beam" msgid="5819197866281059878">"   "</string>
+    <string name="tap_to_beam" msgid="5819197866281059878">"   "</string>
     <string name="beam_progress" msgid="7453634884807323920">" "</string>
     <string name="beam_outgoing" msgid="4679536649779123495">"  ..."</string>
     <string name="beam_complete" msgid="477026736424637435">" "</string>
     <string name="beam_failed" msgid="5116241718189888630">"   "</string>
     <string name="beam_canceled" msgid="5425192751826544741">"  "</string>
     <string name="cancel" msgid="61873902552555096">""</string>
-    <string name="beam_tap_to_view" msgid="7430394753262448349">"   "</string>
+    <string name="beam_tap_to_view" msgid="7430394753262448349">"   "</string>
     <string name="beam_handover_not_supported" msgid="4083165921751489015">"        Beam."</string>
     <string name="beam_try_again" msgid="3364677301009783455">"    "</string>
     <string name="beam_busy" msgid="5253335587620612576">"Beam   .       ."</string>
@@ -27,8 +27,8 @@
     <string name="confirm_pairing" msgid="4112568077038265363">"     -Bluetooth <xliff:g id="DEVICE_NAME">%1$s</xliff:g>?"</string>
     <string name="pair_yes" msgid="3525614878559994448">""</string>
     <string name="pair_no" msgid="5022308368904055020">""</string>
-    <string name="tap_again_to_pay" msgid="5754988005412859897">"      <xliff:g id="APP">%1$s</xliff:g>"</string>
-    <string name="tap_again_to_complete" msgid="5423640945118279123">"      <xliff:g id="APP">%1$s</xliff:g>"</string>
+    <string name="tap_again_to_pay" msgid="5754988005412859897">"      <xliff:g id="APP">%1$s</xliff:g>"</string>
+    <string name="tap_again_to_complete" msgid="5423640945118279123">"      <xliff:g id="APP">%1$s</xliff:g>"</string>
     <string name="tap_again_description" msgid="3019101527041529661">"  "</string>
     <string name="appchooser_description" msgid="2554187931814833244">"  "</string>
     <string name="transaction_failure" msgid="7828102078637936513">"        <xliff:g id="APP">%1$s</xliff:g>."</string>
@@ -36,7 +36,7 @@
     <string name="pay_with" msgid="5531545488795798945">" "</string>
     <string name="complete_with" msgid="6797459104103012992">" "</string>
     <string name="default_pay_app_removed" msgid="4108250545457437360">"    \' \' .   ?"</string>
-    <string name="ask_nfc_tap" msgid="2925239870458286340">"     "</string>
+    <string name="ask_nfc_tap" msgid="2925239870458286340">"     "</string>
     <string name="wifi_connect" msgid="6250727951843550671">""</string>
     <string name="status_unable_to_connect" msgid="9183908200295307657">"   "</string>
     <string name="status_wifi_connected" msgid="5893022897732105739">" "</string>
@@ -52,7 +52,9 @@
     <string name="tag_read_error" msgid="2485274498885877547">"    NFC.   ."</string>
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"    NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">" -NFC "</string>
-    <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       ."</string>
+    <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>   NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" -NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"     ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" -<xliff:g id="PKG">%1$s</xliff:g>  NFC?"</string>
diff --git a/res/values-ja/strings.xml b/res/values-ja/strings.xml
index 953fe196..c7565f72 100644
--- a/res/values-ja/strings.xml
+++ b/res/values-ja/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">""</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g> "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">""</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC "</string>
diff --git a/res/values-ka/strings.xml b/res/values-ka/strings.xml
index a49f6ff0..7dcef213 100644
--- a/res/values-ka/strings.xml
+++ b/res/values-ka/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"  ,     ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC-"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">",  ,    ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC  "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"  ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC-  ?"</string>
diff --git a/res/values-kk/strings.xml b/res/values-kk/strings.xml
index 2f0bd57b..948d7241 100644
--- a/res/values-kk/strings.xml
+++ b/res/values-kk/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC   -    "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"     ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC   "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"     ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC     ?"</string>
diff --git a/res/values-km/strings.xml b/res/values-km/strings.xml
index 601618be..0aec0952 100644
--- a/res/values-km/strings.xml
+++ b/res/values-km/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">" "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>  NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">" "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC ?"</string>
diff --git a/res/values-kn/strings.xml b/res/values-kn/strings.xml
index 39d5887c..13e57c20 100644
--- a/res/values-kn/strings.xml
+++ b/res/values-kn/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC    "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"     ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC   <xliff:g id="PKG">%1$s</xliff:g>  ?"</string>
diff --git a/res/values-ko/strings.xml b/res/values-ko/strings.xml
index 3ea15701..7cd51759 100644
--- a/res/values-ko/strings.xml
+++ b/res/values-ko/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC    ."</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"   ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g> "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"    ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"  ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC  ?"</string>
diff --git a/res/values-ky/strings.xml b/res/values-ky/strings.xml
index dfbbe5ff..fde89937 100644
--- a/res/values-ky/strings.xml
+++ b/res/values-ky/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"    ,    ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> NFC  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC  "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC\'   ?"</string>
diff --git a/res/values-lo/strings.xml b/res/values-lo/strings.xml
index d97af90a..085d6809 100644
--- a/res/values-lo/strings.xml
+++ b/res/values-lo/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>  NFC "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC ?"</string>
diff --git a/res/values-lt/strings.xml b/res/values-lt/strings.xml
index ad1337b6..94f009fa 100644
--- a/res/values-lt/strings.xml
+++ b/res/values-lt/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nra i ALR ym palaikani program"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"ALR gali bti ublokuotas"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Palieskite, kad suinotumte, kaip sutvarkyti."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> paleista naudojant NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Palieskite, kad suinotumte, kaip tai ijungti."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC duomenys raomi"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Palieskite, kad sustabdytumte raym."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Leisti <xliff:g id="PKG">%1$s</xliff:g> norint galinti NFC?"</string>
diff --git a/res/values-lv/strings.xml b/res/values-lv/strings.xml
index 27523758..44c20e50 100644
--- a/res/values-lv/strings.xml
+++ b/res/values-lv/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFCatzme netiek atbalstta nevien lietojumprogramm"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Iespjams, NFC ir blots"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Pieskarieties, lai uzzintu, k to novrst."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Lietotne <xliff:g id="APPNAME">%1$s</xliff:g> tika palaista, izmantojot tehnoloijuNFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Lai uzzintu, k to atspjot, pieskarieties."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Notiek NFC datu reistrana"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Lai apturtu reistranu, pieskarieties."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vai ataut pakotnei <xliff:g id="PKG">%1$s</xliff:g> iespjot NFC?"</string>
diff --git a/res/values-mk/strings.xml b/res/values-mk/strings.xml
index 7ef54549..123e6f21 100644
--- a/res/values-mk/strings.xml
+++ b/res/values-mk/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"       NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"        ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>    NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"    NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"   <xliff:g id="PKG">%1$s</xliff:g>   NFC?"</string>
diff --git a/res/values-ml/strings.xml b/res/values-ml/strings.xml
index 3c6e4113..94dec8d9 100644
--- a/res/values-ml/strings.xml
+++ b/res/values-ml/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC   "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"    ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"     ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC  <xliff:g id="PKG">%1$s</xliff:g>  ?"</string>
diff --git a/res/values-mn/strings.xml b/res/values-mn/strings.xml
index 0ef6a209..922cbd4f 100644
--- a/res/values-mn/strings.xml
+++ b/res/values-mn/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC-   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>- NFC- "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>- NFC-   ?"</string>
diff --git a/res/values-mr/strings.xml b/res/values-mr/strings.xml
index 53acbefb..3f445881 100644
--- a/res/values-mr/strings.xml
+++ b/res/values-mr/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC       "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC     "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC     "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC     "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC      ?"</string>
diff --git a/res/values-ms/strings.xml b/res/values-ms/strings.xml
index 0adedc53..19e1d2ce 100644
--- a/res/values-ms/strings.xml
+++ b/res/values-ms/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Tiada aplikasi yang disokong untuk Teg NFC ini"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC mungkin disekat"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Ketik untuk mengetahui cara membetulkan perkara ini."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> dilancarkan melalui NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Ketik untuk mengetahui cara melumpuhkan ciri ini."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Data NFC sedang dirakamkan"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Ketik untuk menghentikan rakaman."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Benarkan <xliff:g id="PKG">%1$s</xliff:g> untuk mendayakan NFC?"</string>
diff --git a/res/values-my/strings.xml b/res/values-my/strings.xml
index 005a3437..4a656cb0 100644
--- a/res/values-my/strings.xml
+++ b/res/values-my/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" \'NFC \'    "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"  "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g> "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"   "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC  "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">" "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC  <xliff:g id="PKG">%1$s</xliff:g>  "</string>
diff --git a/res/values-nb/strings.xml b/res/values-nb/strings.xml
index d8058438..9b53235c 100644
--- a/res/values-nb/strings.xml
+++ b/res/values-nb/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Ingen apper stttes for denne NFC-brikken"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC kan vre blokkert"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Trykk for  finne ut hvordan du lser dette."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> ble startet via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Trykk for  finne ut hvordan du deaktiverer dette."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Det registreres NFC-data"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Trykk for  stoppe registreringen."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vil du tillate at <xliff:g id="PKG">%1$s</xliff:g> aktiverer NFC?"</string>
diff --git a/res/values-ne/strings.xml b/res/values-ne/strings.xml
index b894c81b..0f3d79c8 100644
--- a/res/values-ne/strings.xml
+++ b/res/values-ne/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC     "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC    "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"       "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC    "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC    ?"</string>
diff --git a/res/values-nl/strings.xml b/res/values-nl/strings.xml
index ec039b13..c4465169 100644
--- a/res/values-nl/strings.xml
+++ b/res/values-nl/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Geen ondersteunde app voor deze NFC-tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC wordt mogelijk geblokkeerd"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tik voor meer informatie over hoe je dit kunt verhelpen."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> gestart via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tik voor informatie over hoe je dit uitzet."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-gegevens worden opgenomen"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tik om te stoppen met opnemen."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Toestaan dat <xliff:g id="PKG">%1$s</xliff:g> NFC aanzet?"</string>
diff --git a/res/values-or/strings.xml b/res/values-or/strings.xml
index a7719086..a0870142 100644
--- a/res/values-or/strings.xml
+++ b/res/values-or/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"        "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>  "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"       "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC    <xliff:g id="PKG">%1$s</xliff:g>  ?"</string>
diff --git a/res/values-pa/strings.xml b/res/values-pa/strings.xml
index 2f526543..c6041285 100644
--- a/res/values-pa/strings.xml
+++ b/res/values-pa/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC       "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC      "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"         "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>  NFC    "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"        "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC       "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"     "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC      ?"</string>
diff --git a/res/values-pl/strings.xml b/res/values-pl/strings.xml
index 1593ebc8..7536d2d3 100644
--- a/res/values-pl/strings.xml
+++ b/res/values-pl/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Brak obsugiwanej aplikacji dla tego tagu NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Komunikacja NFC moe by zablokowana"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Kliknij, by dowiedzie si, jak to naprawi."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikacja <xliff:g id="APPNAME">%1$s</xliff:g> uruchomiona przez NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Kliknij, aby dowiedzie si, jak to wyczy."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Trwa rejestrowanie danych NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Kliknij, aby zatrzyma rejestrowanie."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Zezwoli pakietowi <xliff:g id="PKG">%1$s</xliff:g> na wczenie NFC?"</string>
diff --git a/res/values-pt-rPT/strings.xml b/res/values-pt-rPT/strings.xml
index 747bc7b1..25916c9d 100644
--- a/res/values-pt-rPT/strings.xml
+++ b/res/values-pt-rPT/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"No existe nenhuma app suportada para esta etiqueta NFC."</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"O NFC pode estar bloqueado"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Toque para saber como resolver."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"A app <xliff:g id="APPNAME">%1$s</xliff:g> foi iniciada por NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Toque para saber como desativ-lo."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Os dados de NFC esto a ser gravados"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Toque para parar a gravao."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Permitir que <xliff:g id="PKG">%1$s</xliff:g> ative o NFC?"</string>
diff --git a/res/values-pt/strings.xml b/res/values-pt/strings.xml
index 552aba40..0ce40b9b 100644
--- a/res/values-pt/strings.xml
+++ b/res/values-pt/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nenhum aplicativo compatvel com esta etiqueta NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"A NFC pode estar bloqueada"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Toque para aprender a resolver o problema."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"O app <xliff:g id="APPNAME">%1$s</xliff:g> foi aberto por NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Toque para aprender a desativar."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Os dados NFC esto sendo gravados"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Toque para parar a gravao."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Permitir que <xliff:g id="PKG">%1$s</xliff:g> ative a NFC?"</string>
diff --git a/res/values-ro/strings.xml b/res/values-ro/strings.xml
index 030356ec..9cc474a5 100644
--- a/res/values-ro/strings.xml
+++ b/res/values-ro/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nu exist aplicaii acceptate pentru aceast etichet NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Tehnologia NFC poate fi blocat"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Atinge ca s afli cum s remediezi problema."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> s-a lansat prin NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Atinge pentru a afla cum s o dezactivezi."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Se nregistreaz date NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Atinge ca s opreti nregistrarea."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Permii ca <xliff:g id="PKG">%1$s</xliff:g> s activeze NFC?"</string>
diff --git a/res/values-ru/strings.xml b/res/values-ru/strings.xml
index a5c5609d..e3c94662 100644
--- a/res/values-ru/strings.xml
+++ b/res/values-ru/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"  NFC-   "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">" NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">",  ,    ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" \"<xliff:g id="APPNAME">%1$s</xliff:g>\"    NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">" ,   ,    ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"   NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">",   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"  \"<xliff:g id="PKG">%1$s</xliff:g>\"  NFC?"</string>
diff --git a/res/values-si/strings.xml b/res/values-si/strings.xml
index edfb0b52..2c64b1e5 100644
--- a/res/values-si/strings.xml
+++ b/res/values-si/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC     "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"      ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> NFC    "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC    "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC   <xliff:g id="PKG">%1$s</xliff:g>    ?"</string>
diff --git a/res/values-sk/strings.xml b/res/values-sk/strings.xml
index d18f20ab..61ebfc27 100644
--- a/res/values-sk/strings.xml
+++ b/res/values-sk/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Pre tto znaku NFC nie je kdispozcii iadna podporovan aplikcia"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Rozhranie NFC me by blokovan"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Klepnutm zistite, ako to opravi."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikcia <xliff:g id="APPNAME">%1$s</xliff:g> bola spusten cez NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Klepnutm sa dozviete, ako ju deaktivova."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Nahrvaj sa daje NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Nahrvanie zastavte klepnutm."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Chcete povoli balku <xliff:g id="PKG">%1$s</xliff:g> aktivova NFC?"</string>
diff --git a/res/values-sl/strings.xml b/res/values-sl/strings.xml
index 60675a1f..82d7f4ca 100644
--- a/res/values-sl/strings.xml
+++ b/res/values-sl/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Za to oznako NFC ni podprta nobena aplikacija"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Vmesnik NFC je morda blokiran"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Dotaknite se, e elite izvedeti, kako odpravite to teavo."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Aplikacija <xliff:g id="APPNAME">%1$s</xliff:g> je bila zagnana prek NFC-ja"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Dotaknite se, da si ogledate navodila za onemogoanje."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Poteka snemanje podatkov NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Za ustavitev snemanja se dotaknite."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Ali dovolite, da paket <xliff:g id="PKG">%1$s</xliff:g> omogoi NFC?"</string>
diff --git a/res/values-sq/strings.xml b/res/values-sq/strings.xml
index 2478198d..8c4d250d 100644
--- a/res/values-sq/strings.xml
+++ b/res/values-sq/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Nuk ka asnj aplikacion t mbshtetur pr kt etiket NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC mund t jet bllokuar"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Trokit pr t msuar se si ta rregullosh."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> u hap nprmjet NFC-s"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Trokit pr t msuar si ta aktivizosh."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"T dhnat e lidhjes NFC po regjistrohen"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Trokit pr t ndaluar regjistrimin"</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"T lejohet q <xliff:g id="PKG">%1$s</xliff:g> t aktivizoj NFC-n?"</string>
diff --git a/res/values-sr/strings.xml b/res/values-sr/strings.xml
index b29473c6..d84f1c18 100644
--- a/res/values-sr/strings.xml
+++ b/res/values-sr/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"     NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>    NFC-"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"    <xliff:g id="PKG">%1$s</xliff:g>  NFC?"</string>
diff --git a/res/values-sv/strings.xml b/res/values-sv/strings.xml
index 80496701..28de705e 100644
--- a/res/values-sv/strings.xml
+++ b/res/values-sv/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Ingen app har std fr den hr NFC-etiketten"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC kanske blockeras"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Tryck hr fr att ta reda p hur du tgrdar detta."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> startades via NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Tryck hr fr att lsa mer om hur du inaktiverar den."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC-data spelas in"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Tryck fr att sluta inspelningen."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vill du tillta att <xliff:g id="PKG">%1$s</xliff:g> aktiverar NFC?"</string>
diff --git a/res/values-sw/strings.xml b/res/values-sw/strings.xml
index 3718ae7b..54a52875 100644
--- a/res/values-sw/strings.xml
+++ b/res/values-sw/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Hakuna programu inayotumika katika Tagi hii ya NFC"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Huenda NFC imezuiwa"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Gusa ili upate maelezo kuhusu jinsi ya kurekebisha."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> imefunguliwa kupitia NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Gusa upate maelezo kuhusu jinsi ya kuifunga."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Data ya NFC inarekodiwa"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Gusa ili usitishe kurekodi."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Ungependa kuruhusu <xliff:g id="PKG">%1$s</xliff:g> iwashe huduma ya NFC?"</string>
diff --git a/res/values-ta/strings.xml b/res/values-ta/strings.xml
index 06a53221..42d70586 100644
--- a/res/values-ta/strings.xml
+++ b/res/values-ta/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC    "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"    ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g> "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"     ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"  ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC  <xliff:g id="PKG">%1$s</xliff:g>  ?"</string>
diff --git a/res/values-te/strings.xml b/res/values-te/strings.xml
index fd68b7cb..2f7f61d5 100644
--- a/res/values-te/strings.xml
+++ b/res/values-te/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"NFC      "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"    ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g> "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"      ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC   "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"NFC   <xliff:g id="PKG">%1$s</xliff:g> ?"</string>
diff --git a/res/values-th/strings.xml b/res/values-th/strings.xml
index 942b3992..572230ed 100644
--- a/res/values-th/strings.xml
+++ b/res/values-th/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">" NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">""</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>  NFC "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">""</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC "</string>
diff --git a/res/values-tl/strings.xml b/res/values-tl/strings.xml
index 16dbc11d..7ba3ab8b 100644
--- a/res/values-tl/strings.xml
+++ b/res/values-tl/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Walang sinusuportahang application para sa Tag ng NFC na ito"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"Posibleng naka-block ang NFC"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"I-tap para malaman kung paano ayusin."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"Inilunsad ang <xliff:g id="APPNAME">%1$s</xliff:g> sa pamamagitan ng NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"I-tap para alamin kung paano ito i-disable."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Nagre-record ng data ng NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"I-tap para ihinto ang pag-record."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Payagan ang <xliff:g id="PKG">%1$s</xliff:g> na i-enable ang NFC?"</string>
diff --git a/res/values-tr/strings.xml b/res/values-tr/strings.xml
index f92781fa..aa9ceaba 100644
--- a/res/values-tr/strings.xml
+++ b/res/values-tr/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Bu NFC Etiketi iin desteklenen uygulama yok"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC engellenmi olabilir"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Nasl dzelteceinizi renmek iin dokunun."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g>, NFC araclyla balatld"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Nasl devre d brakacanz renmek iin dokunun."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC verileri kaydediliyor"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Kayd durdurmak iin dokunun."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> paketinin NFC\'yi etkinletirmesine izin verilsin mi?"</string>
diff --git a/res/values-uk/strings.xml b/res/values-uk/strings.xml
index d799e489..a399a963 100644
--- a/res/values-uk/strings.xml
+++ b/res/values-uk/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"     NFC-"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC   "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">",  ,   ."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" <xliff:g id="APPNAME">%1$s</xliff:g>   NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">",  ,   ."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"  NFC"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">",   ."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">" <xliff:g id="PKG">%1$s</xliff:g>  NFC?"</string>
diff --git a/res/values-ur/strings.xml b/res/values-ur/strings.xml
index 9e118dd1..40601592 100644
--- a/res/values-ur/strings.xml
+++ b/res/values-ur/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC         "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"  NFC  "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"       "</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"NFC  <xliff:g id="APPNAME">%1$s</xliff:g>   "</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"         "</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC      "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"    "</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g>  NFC     "</string>
diff --git a/res/values-uz/strings.xml b/res/values-uz/strings.xml
index 31065f44..f252189a 100644
--- a/res/values-uz/strings.xml
+++ b/res/values-uz/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Mazkur NFC yorliq bilan ishlaydigan hech qanday ilova topilmadi"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC bloklangan shekilli"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Muammo yechimini olish uchun bosing."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"<xliff:g id="APPNAME">%1$s</xliff:g> NFC orqali ishga tushirildi"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Uni qanday faolsizlantirish haqida bilib olish uchun bosing."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"NFC malumotlar yozib olinmoqda"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Yozib olishni toxtatish uchun bosing."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC aloqani yoqishiga ruxsat berilsinmi?"</string>
diff --git a/res/values-vi/strings.xml b/res/values-vi/strings.xml
index 4339d90d..1d1027fd 100644
--- a/res/values-vi/strings.xml
+++ b/res/values-vi/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Khng c ng dng no h tr th NFC ny"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC c th b chn"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Nhn  tm hiu cch khc phc."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" khi chy <xliff:g id="APPNAME">%1$s</xliff:g> qua NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Hy nhn  tm hiu cch tt ng dng ny."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"D liu v NFC ang c ghi li"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Nhn  dng ghi."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Cho php <xliff:g id="PKG">%1$s</xliff:g> bt NFC?"</string>
diff --git a/res/values-zh-rCN/strings.xml b/res/values-zh-rCN/strings.xml
index 87085e52..3f100bef 100644
--- a/res/values-zh-rCN/strings.xml
+++ b/res/values-zh-rCN/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">""</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" NFC <xliff:g id="APPNAME">%1$s</xliff:g>"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">""</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC"</string>
diff --git a/res/values-zh-rHK/strings.xml b/res/values-zh-rHK/strings.xml
index 4dd16146..d41df692 100644
--- a/res/values-zh-rHK/strings.xml
+++ b/res/values-zh-rHK/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">""</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" NFC <xliff:g id="APPNAME">%1$s</xliff:g>"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">""</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC "</string>
diff --git a/res/values-zh-rTW/strings.xml b/res/values-zh-rTW/strings.xml
index f8259044..7ab08bd3 100644
--- a/res/values-zh-rTW/strings.xml
+++ b/res/values-zh-rTW/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">" NFC "</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"NFC "</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">""</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">" NFC <xliff:g id="APPNAME">%1$s</xliff:g>"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">""</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">" NFC "</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">""</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"<xliff:g id="PKG">%1$s</xliff:g> NFC "</string>
diff --git a/res/values-zu/strings.xml b/res/values-zu/strings.xml
index 3a907de3..c6f3bfd1 100644
--- a/res/values-zu/strings.xml
+++ b/res/values-zu/strings.xml
@@ -53,6 +53,8 @@
     <string name="tag_dispatch_failed" msgid="3562984995049738400">"Uhlelo lokusebenza olungasekelwa lale thegi ye-NFC Tag"</string>
     <string name="nfc_blocking_alert_title" msgid="1086172436984457085">"I-NFC kungenzeka ivinjwe"</string>
     <string name="nfc_blocking_alert_message" msgid="7003156052570107490">"Thepha ukuze ufunde ukuthi ungalungisa kanjani."</string>
+    <string name="nfc_tag_alert_title" msgid="197917719004551090">"I-<xliff:g id="APPNAME">%1$s</xliff:g> iqalisiwe nge-NFC"</string>
+    <string name="nfc_tag_alert_message" msgid="3140894528184634873">"Thepha ukuze ufunde indlela yokuyikhubaza."</string>
     <string name="nfc_logging_alert_title" msgid="5300867034660942987">"Idatha ye-NFC iyarekhodwa"</string>
     <string name="nfc_logging_alert_message" msgid="1550187184825467942">"Thepha ukuze umise ukurekhoda."</string>
     <string name="title_package_enabling_nfc" msgid="5736481508428918024">"Vumela i-<xliff:g id="PKG">%1$s</xliff:g> ukunika amandla i-NFC?"</string>
diff --git a/res/values/config.xml b/res/values/config.xml
index 50d44f67..da274228 100644
--- a/res/values/config.xml
+++ b/res/values/config.xml
@@ -35,7 +35,7 @@
     <!-- Allow list that contains the package name which are allowed to use NFC -->
     <string-array name="nfc_allow_list" translatable="false" />
     <!-- Number of persistent events to store  -->
-    <integer name="max_event_log_num">50</integer>
+    <integer name="max_event_log_num">100</integer>
     <!-- Overlay to indicate that the OEM plans to use OEM extension -->
     <bool name="enable_oem_extension">false</bool>
     <string name="nfc_default_route" translatable="false"></string>
@@ -43,6 +43,8 @@
     <string name="nfc_default_isodep_route" translatable="false"></string>
     <!-- Default OffHost Route value -->
     <string name="nfc_default_offhost_route" translatable="false"></string>
+    <!-- Default System Code Route value -->
+    <string name="nfc_default_sc_route" translatable="false"></string>
     <!-- Overlay to enable NFC developer option notification-->
     <bool name="enable_developer_option_notification">true</bool>
     <!-- Whether to enable NFC by default on boot or not. -->
@@ -59,4 +61,5 @@
     <bool name="enable_euicc_support">false</bool>
     <!-- Whether to indicate user activity using PowerManager.userActivity for HCE activation -->
     <bool name="indicate_user_activity_for_hce">true</bool>
+    <integer name="max_pause_polling_time_out_ms">0</integer>
 </resources>
diff --git a/res/values/overlayable.xml b/res/values/overlayable.xml
index 1568df46..dfe44310 100644
--- a/res/values/overlayable.xml
+++ b/res/values/overlayable.xml
@@ -49,6 +49,7 @@
             <item name="nfc_default_route" type="string"/>
             <item name="nfc_default_isodep_route" type="string"/>
             <item name="nfc_default_offhost_route" type="string"/>
+            <item name="nfc_default_sc_route" type="string"/>
             <item name="enable_developer_option_notification" type="bool" />
             <!-- Allow list that contains the package name which are allowed to use NFC -->
             <item name="nfc_allow_list" type="array" />
@@ -62,6 +63,7 @@
             <item name="check_display_state_for_screen_state" type="bool" />
             <item name="enable_euicc_support" type="bool" />
             <item name="indicate_user_activity_for_hce" type="bool" />
+            <item name="max_pause_polling_time_out_ms" type="integer" />
           <!-- Params from config.xml that can be overlaid -->
 
           <!-- Params from strings.xml that can be overlaid -->
diff --git a/res/values/strings.xml b/res/values/strings.xml
index bb42514d..9bb12e70 100755
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -104,6 +104,10 @@
     <string name="nfc_blocking_alert_title">NFC may be blocked</string>
     <!-- Notification message string informing the user that NFC may be blocked -->
     <string name="nfc_blocking_alert_message">Tap to learn how to fix.</string>
+    <!-- Notification title string informing the user that the app launched via NFC -->
+    <string name="nfc_tag_alert_title"><xliff:g id="appName">%1$s</xliff:g> launched via NFC</string>
+    <!-- Notification message string informing the user that the app launched via NFC -->
+    <string name="nfc_tag_alert_message">Tap to learn how to disable it.</string>
     <!-- Notification title string informing the user that NFC data is being recorded -->
     <string name="nfc_logging_alert_title">NFC data is being recorded</string>
     <!-- Notification message string informing the user that NFC data is being recorded -->
diff --git a/src/com/android/nfc/ArrayUtils.java b/src/com/android/nfc/ArrayUtils.java
index 1ee5f74f..9a89af47 100644
--- a/src/com/android/nfc/ArrayUtils.java
+++ b/src/com/android/nfc/ArrayUtils.java
@@ -53,6 +53,13 @@ public class ArrayUtils {
         return array == null || array.length == 0;
     }
 
+    /**
+     * True if the byte array is null or has length 0.
+     */
+    public static boolean isEmpty(@Nullable Object[] array) {
+        return array == null || array.length == 0;
+    }
+
     /**
      * Converts from List of bytes to byte array
      * @param list
diff --git a/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java b/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
index a70117a6..06f325de 100644
--- a/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
+++ b/src/com/android/nfc/ConfirmConnectToWifiNetworkActivity.java
@@ -37,7 +37,12 @@ public class ConfirmConnectToWifiNetworkActivity extends Activity
         mCurrentWifiConfiguration =
                 intent.getParcelableExtra(NfcWifiProtectedSetup.EXTRA_WIFI_CONFIG);
 
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        registerReceiver(mBroadcastReceiver, intentFilter);
+
         if (mCurrentWifiConfiguration == null) {
+            super.onCreate(savedInstanceState);
             Log.e(TAG, "mCurrentWifiConfiguration is null.");
             finish();
             return;
@@ -56,10 +61,6 @@ public class ConfirmConnectToWifiNetworkActivity extends Activity
         mEnableWifiInProgress = false;
         mHandler = new Handler();
 
-        IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
-        registerReceiver(mBroadcastReceiver, intentFilter);
-
         mAlertDialog.show();
 
         super.onCreate(savedInstanceState);
@@ -143,7 +144,10 @@ public class ConfirmConnectToWifiNetworkActivity extends Activity
 
     @Override
     protected void onDestroy() {
-        mAlertDialog.dismiss();
+
+        if (mAlertDialog != null) {
+            mAlertDialog.dismiss();
+        }
         ConfirmConnectToWifiNetworkActivity.this.unregisterReceiver(mBroadcastReceiver);
         super.onDestroy();
     }
diff --git a/src/com/android/nfc/DeviceConfigFacade.java b/src/com/android/nfc/DeviceConfigFacade.java
index 3d80910e..ed29e712 100644
--- a/src/com/android/nfc/DeviceConfigFacade.java
+++ b/src/com/android/nfc/DeviceConfigFacade.java
@@ -50,6 +50,7 @@ public class DeviceConfigFacade {
     private String mDefaultRoute;
     private String mDefaultIsoDepRoute;
     private String mDefaultOffHostRoute;
+    private String mDefaultScRoute;
 
     private static DeviceConfigFacade sInstance;
     public static DeviceConfigFacade getInstance(Context context, Handler handler) {
@@ -108,6 +109,10 @@ public class DeviceConfigFacade {
         mDefaultOffHostRoute = DeviceConfig.getString(DEVICE_CONFIG_NAMESPACE_NFC,
                 "nfc_default_offhost_route",
                 mContext.getResources().getString(R.string.nfc_default_offhost_route));
+
+        mDefaultScRoute = DeviceConfig.getString(DEVICE_CONFIG_NAMESPACE_NFC,
+                "nfc_default_sc_route",
+                mContext.getResources().getString(R.string.nfc_default_sc_route));
     }
 
     private boolean isSecureNfcCapableDefault() {
@@ -139,4 +144,5 @@ public class DeviceConfigFacade {
     public String getDefaultRoute() { return mDefaultRoute; }
     public String getDefaultIsoDepRoute() { return mDefaultIsoDepRoute; }
     public String getDefaultOffHostRoute() { return mDefaultOffHostRoute; }
+    public String getDefaultScRoute() { return mDefaultScRoute; }
 }
diff --git a/src/com/android/nfc/DeviceHost.java b/src/com/android/nfc/DeviceHost.java
index da03a338..48a39289 100644
--- a/src/com/android/nfc/DeviceHost.java
+++ b/src/com/android/nfc/DeviceHost.java
@@ -22,9 +22,9 @@ import android.nfc.cardemulation.PollingFrame;
 import android.os.Bundle;
 
 import java.io.FileDescriptor;
-import java.io.IOException;
 import java.io.PrintWriter;
 import java.util.List;
+import java.util.Map;
 
 public interface DeviceHost {
     public interface DeviceHostListener {
@@ -50,11 +50,19 @@ public interface DeviceHost {
 
         public void onWlcStopped(int wpt_end_condition);
 
+        public void onTagRfDiscovered(boolean discovered);
+
         public void onVendorSpecificEvent(int gid, int oid, byte[] payload);
 
         public void onObserveModeStateChanged(boolean enable);
 
         public void onRfDiscoveryEvent(boolean isDiscoveryStarted);
+
+        public void onEeListenActivated(boolean isActivated);
+
+        public void onSeSelected();
+
+        public void onCommandTimeout();
     }
 
     public interface TagEndpoint {
@@ -157,7 +165,53 @@ public interface DeviceHost {
 
     public boolean unrouteAid(byte[] aid);
 
-    public boolean commitRouting();
+    public int commitRouting();
+
+    /**
+     * Get the T4T Nfcee power state supported.
+     * @return T4T Nfcee power state
+     */
+    int getT4TNfceePowerState();
+
+    /**
+     * Get the NDEF NFCEE Route ID.
+     * @return NDEF NFCEE Route ID
+     */
+    int getNdefNfceeRouteId();
+
+    /**
+     * Write the data into the NDEF NFCEE file of the specific file ID
+     * @param fileId
+     * @param data
+     * @return number of data bytes written
+     */
+    int doWriteData(byte[] fileId, byte[] data);
+
+    /**
+     * Read the data from the NDEF NFCEE file of the specific file ID.
+     * @param fileId
+     * @return read data buffer
+     */
+    byte[] doReadData(byte[] fileId);
+
+    /**
+     * This API will set all the NFCEE NDEF data to zero.
+     * @return "True" when operation is successful. else "False"
+     */
+    boolean doClearNdefData();
+
+    /**
+     * This API will get NDEF NFCEE status.
+     * @return Indicates whether NDEF NFCEE Read or write operation is under process
+     *         Return "True" when operation is in progress. else "False"
+     */
+    boolean isNdefOperationOngoing();
+
+    /**
+     * This API will tell whether NDEF NFCEE emulation is supported or not.
+     * @return "True" when feature supported. else "False"
+     */
+    boolean isNdefNfceeEmulationSupported();
 
     public void registerT3tIdentifier(byte[] t3tIdentifier);
 
@@ -205,6 +259,8 @@ public interface DeviceHost {
 
     public boolean isObserveModeEnabled();
 
+    public boolean isFirmwareExitFramesSupported();
+
     /**
     * Get the committed listen mode routing configuration
     */
@@ -233,7 +289,11 @@ public interface DeviceHost {
     boolean isMultiTag();
 
     void setIsoDepProtocolRoute(int route);
-    void setTechnologyABFRoute(int route);
+    /**
+    * Set NFCC technology routing for ABF listening
+    */
+    void setTechnologyABFRoute(int route, int felicaRoute);
+    void setSystemCodeRoute(int route);
     void clearRoutingEntry(int clearFlags);
 
     /**
@@ -251,5 +311,5 @@ public interface DeviceHost {
     /**
      * Get the active NFCEE list
      */
-    public List<String> dofetchActiveNfceeList();
+    public Map<String, Integer> dofetchActiveNfceeList();
 }
diff --git a/src/com/android/nfc/NfcApplication.java b/src/com/android/nfc/NfcApplication.java
index eea9d7e6..7855f6ac 100644
--- a/src/com/android/nfc/NfcApplication.java
+++ b/src/com/android/nfc/NfcApplication.java
@@ -31,8 +31,6 @@ import java.util.List;
 public class NfcApplication extends Application {
 
     static final String TAG = "NfcApplication";
-    static final String NFC_PROCESS = "com.android.nfc";
-
     NfcService mNfcService;
 
     public NfcApplication() {
@@ -59,7 +57,7 @@ public class NfcApplication extends Application {
         while (i.hasNext()) {
             RunningAppProcessInfo appInfo = (RunningAppProcessInfo)(i.next());
             if (appInfo.pid == Process.myPid()) {
-                isMainProcess =  (NFC_PROCESS.equals(appInfo.processName));
+                isMainProcess =  (getPackageName().equals(appInfo.processName));
                 break;
             }
         }
diff --git a/src/com/android/nfc/NfcCallbackResultReceiver.java b/src/com/android/nfc/NfcCallbackResultReceiver.java
new file mode 100644
index 00000000..7ad27649
--- /dev/null
+++ b/src/com/android/nfc/NfcCallbackResultReceiver.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import android.os.Bundle;
+import android.os.ResultReceiver;
+
+import java.util.concurrent.CountDownLatch;
+
+public class NfcCallbackResultReceiver extends ResultReceiver {
+    CountDownLatch mCountDownLatch;
+    OnReceiveResultListener mListener;
+    public NfcCallbackResultReceiver(CountDownLatch latch, OnReceiveResultListener listener) {
+        super(null);
+        mListener = listener;
+        mCountDownLatch = latch;
+    }
+
+    @Override
+    protected void onReceiveResult(int resultCode, Bundle resultData) {
+        mListener.onReceiveResult(resultCode, resultData);
+        mCountDownLatch.countDown();
+    }
+
+    public static class OnReceiveResultListener {
+        int resultCode;
+        Bundle resultData;
+        void onReceiveResult(int resultCode, Bundle resultData) {
+            this.resultCode = resultCode;
+            this.resultData = resultData;
+        }
+
+        public int getResultCode() {
+            return resultCode;
+        }
+
+        public Bundle getResultData() {
+            return resultData;
+        }
+    }
+}
diff --git a/src/com/android/nfc/NfcDispatcher.java b/src/com/android/nfc/NfcDispatcher.java
index 276bc8d6..742bff91 100644
--- a/src/com/android/nfc/NfcDispatcher.java
+++ b/src/com/android/nfc/NfcDispatcher.java
@@ -20,6 +20,8 @@ import static android.content.pm.PackageManager.MATCH_CLONE_PROFILE;
 import static android.content.pm.PackageManager.MATCH_DEFAULT_ONLY;
 import static android.nfc.Flags.enableNfcMainline;
 
+import static com.android.nfc.NfcService.WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS;
+
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.AlertDialog;
@@ -40,6 +42,7 @@ import android.content.pm.PackageManager.ResolveInfoFlags;
 import android.content.pm.ResolveInfo;
 import android.content.res.Resources.NotFoundException;
 import android.net.Uri;
+import android.nfc.INfcOemExtensionCallback;
 import android.nfc.NdefMessage;
 import android.nfc.NdefRecord;
 import android.nfc.NfcAdapter;
@@ -47,10 +50,13 @@ import android.nfc.Tag;
 import android.nfc.tech.Ndef;
 import android.nfc.tech.NfcBarcode;
 import android.os.Binder;
+import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
 import android.os.Messenger;
 import android.os.Process;
+import android.os.RemoteException;
+import android.os.ResultReceiver;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
@@ -64,6 +70,7 @@ import android.view.WindowManager;
 import android.widget.TextView;
 
 import com.android.nfc.RegisteredComponentCache.ComponentInfo;
+import com.android.nfc.flags.Flags;
 import com.android.nfc.handover.HandoverDataParser;
 import com.android.nfc.handover.PeripheralHandoverService;
 
@@ -77,8 +84,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringJoiner;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Collectors;
+import androidx.annotation.VisibleForTesting;
 
 /**
  * Dispatch of NFC events to start activities
@@ -103,7 +113,7 @@ class NfcDispatcher {
     private final NfcInjector mNfcInjector;
     private final Handler mMessageHandler = new MessageHandler();
     private final Messenger mMessenger = new Messenger(mMessageHandler);
-    private AtomicBoolean mBluetoothEnabledByNfc = new AtomicBoolean();
+    private final AtomicBoolean mBluetoothEnabledByNfc;
 
     // Locked on this
     private PendingIntent mOverrideIntent;
@@ -115,6 +125,8 @@ class NfcDispatcher {
     private NfcAdapter mNfcAdapter;
     private boolean mIsTagAppPrefSupported;
 
+    INfcOemExtensionCallback mNfcOemExtensionCallback;
+
     NfcDispatcher(Context context,
                   HandoverDataParser handoverDataParser,
                   NfcInjector nfcInjector,
@@ -134,6 +146,7 @@ class NfcDispatcher {
         synchronized (this) {
             mProvisioningOnly = provisionOnly;
         }
+        mBluetoothEnabledByNfc = mNfcInjector.createAtomicBoolean();
         String[] provisionMimes = null;
         if (provisionOnly) {
             try {
@@ -152,6 +165,9 @@ class NfcDispatcher {
         mContext.registerReceiver(mBluetoothStatusReceiver, filter);
     }
 
+    void setOemExtension(INfcOemExtensionCallback nfcOemExtensionCallback) {
+        mNfcOemExtensionCallback = nfcOemExtensionCallback;
+    }
     @Override
     protected void finalize() throws Throwable {
         mContext.unregisterReceiver(mBluetoothStatusReceiver);
@@ -332,25 +348,25 @@ class NfcDispatcher {
             int muteAppCount = 0;
             for (ResolveInfo resolveInfo : activities) {
                 ActivityInfo activityInfo = resolveInfo.activityInfo;
-                ComponentName cmp = new ComponentName(activityInfo.packageName, activityInfo.name);
-                if (DBG) {
-                    Log.d(TAG, "activityInfo.packageName= " + activityInfo.packageName);
-                    Log.d(TAG, "activityInfo.name= " + activityInfo.name);
-                    Log.d(TAG, "cmp.flattenToString= " + cmp.flattenToString());
-                }
+                String pkgName = activityInfo.packageName;
+                String appName = context.getPackageManager().getApplicationLabel(
+                        activityInfo.applicationInfo).toString();
+                if (DBG) Log.d(TAG, "activityInfo.packageName= " + pkgName);
                 Map<String, Boolean> preflist =
                         mNfcAdapter.getTagIntentAppPreferenceForUser(userId);
-                if (preflist.containsKey(activityInfo.packageName)) {
-                    if (!preflist.get(activityInfo.packageName)) {
-                        if (DBG) Log.d(TAG, "mute pkg:" + cmp.flattenToString());
+                if (preflist.containsKey(pkgName)) {
+                    if (!preflist.get(pkgName)) {
+                        if (DBG) Log.d(TAG, "mute pkg:" + pkgName);
                         muteAppCount++;
                         filtered.remove(resolveInfo);
                         logMuteApp(activityInfo.applicationInfo.uid);
                     }
                 } else {
                     // Default sets allow to the preference list
-                    mNfcAdapter.setTagIntentAppPreferenceForUser(userId, activityInfo.packageName,
-                            true);
+                    mNfcAdapter.setTagIntentAppPreferenceForUser(userId, pkgName, true);
+                    if (Flags.nfcAlertTagAppLaunch()) {
+                        new NfcTagAllowNotification(context, appName).startNotification();
+                    }
                 }
             }
             if (muteAppCount > 0) {
@@ -637,6 +653,9 @@ class NfcDispatcher {
             }
         }
 
+        if (tryOemPackage(tag, message)) {
+            return DISPATCH_SUCCESS;
+        }
         if (tryNdef(dispatch, message)) {
             return screenUnlocked ? DISPATCH_UNLOCK : DISPATCH_SUCCESS;
         }
@@ -810,6 +829,12 @@ class NfcDispatcher {
         return false;
     }
 
+    boolean tryOemPackage(Tag tag, NdefMessage message) {
+        if (message == null || mNfcOemExtensionCallback == null) {
+            return false;
+        }
+        return receiveOemCallbackResult(tag,message);
+    }
     boolean tryNdef(DispatchInfo dispatch, NdefMessage message) {
         if (message == null) {
             return false;
@@ -820,8 +845,8 @@ class NfcDispatcher {
         if (intent == null) return false;
 
         // Try to start AAR activity with matching filter
-        List<String> aarPackages = extractAarPackages(message);
-        for (String pkg : aarPackages) {
+        List<String> packages = extractAarPackages(message);
+        for (String pkg : packages) {
             dispatch.intent.setPackage(pkg);
             if (dispatch.tryStartActivity()) {
                 if (DBG) Log.i(TAG, "matched AAR to NDEF");
@@ -829,10 +854,24 @@ class NfcDispatcher {
             }
         }
 
+        // Try to start AAR activity (OEM proprietary format) with matching filter
+        List<String> oemPackages = extractOemPackages(message);
+        for (String pkg : packages) {
+            dispatch.intent.setPackage(pkg);
+            if (dispatch.tryStartActivity()) {
+                if (DBG) Log.i(TAG, "matched OEM package to NDEF");
+                return true;
+            }
+        }
+
         List<UserHandle> luh = dispatch.getCurrentActiveUserHandles();
+
+        String firstPackage = packages.size() > 0 ? packages.get(0) :
+                              oemPackages.size() > 0 ? oemPackages.get(0):
+                              null;
+
         // Try to perform regular launch of the first AAR
-        if (aarPackages.size() > 0) {
-            String firstPackage = aarPackages.get(0);
+        if (firstPackage != null) {
             PackageManager pm;
             for (UserHandle uh : luh) {
                 try {
@@ -914,6 +953,32 @@ class NfcDispatcher {
         return aarPackages;
     }
 
+    Intent getOemAppSearchIntent(String firstPackage) {
+        if (mNfcOemExtensionCallback != null) {
+            CountDownLatch latch = new CountDownLatch(1);
+            NfcCallbackResultReceiver.OnReceiveResultListener listener =
+                    new NfcCallbackResultReceiver.OnReceiveResultListener();
+            ResultReceiver receiver = new NfcCallbackResultReceiver(latch, listener);
+            try {
+                mNfcOemExtensionCallback.onGetOemAppSearchIntent(List.of(firstPackage), receiver);
+            } catch (RemoteException remoteException) {
+                return null;
+            }
+            try {
+                boolean success = latch.await(
+                        WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+                if (!success) {
+                    return null;
+                } else {
+                    Bundle bundle = listener.getResultData();
+                    return bundle.getParcelable("intent", Intent.class);
+                }
+            } catch (InterruptedException ie) {
+                return null;
+            }
+        }
+        return null;
+    }
     boolean tryTech(DispatchInfo dispatch, Tag tag) {
         dispatch.setTechIntent();
 
@@ -949,6 +1014,8 @@ class NfcDispatcher {
                             matches.add(info.resolveInfo);
                         } else {
                             String pkgName = info.resolveInfo.activityInfo.packageName;
+                            String appName = mContext.getPackageManager().getApplicationLabel(
+                                    info.resolveInfo.activityInfo.applicationInfo).toString();
                             int userId = uh.getIdentifier();
                             Map<String, Boolean> preflist =
                                     mNfcAdapter.getTagIntentAppPreferenceForUser(userId);
@@ -958,6 +1025,10 @@ class NfcDispatcher {
                                     // Default sets allow to the preference list
                                     mNfcAdapter.setTagIntentAppPreferenceForUser(userId,
                                             pkgName, true);
+                                    if (Flags.nfcAlertTagAppLaunch()) {
+                                        new NfcTagAllowNotification(mContext,
+                                                appName).startNotification();
+                                    }
                                 }
                             }
                         }
@@ -1030,7 +1101,8 @@ class NfcDispatcher {
         }
         intent.putExtra(PeripheralHandoverService.EXTRA_BT_ENABLED, mBluetoothEnabledByNfc.get());
         intent.putExtra(PeripheralHandoverService.EXTRA_CLIENT, mMessenger);
-        Context contextAsUser = mContext.createContextAsUser(UserHandle.CURRENT, /* flags= */ 0);
+        Context contextAsUser = mContext.createContextAsUser(
+            UserHandle.of(ActivityManager.getCurrentUser()), /* flags= */ 0);
         contextAsUser.startService(intent);
 
         int btClass = BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED;
@@ -1221,6 +1293,11 @@ class NfcDispatcher {
         }
     }
 
+    @VisibleForTesting
+    public Handler getHandler() {
+        return mMessageHandler;
+    }
+
     final BroadcastReceiver mBluetoothStatusReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -1238,4 +1315,59 @@ class NfcDispatcher {
             }
         }
     };
+
+    List<String> extractOemPackages(NdefMessage message) {
+        if (mNfcOemExtensionCallback != null) {
+            CountDownLatch latch = new CountDownLatch(1);
+            NfcCallbackResultReceiver.OnReceiveResultListener listener =
+                    new NfcCallbackResultReceiver.OnReceiveResultListener();
+            ResultReceiver receiver = new NfcCallbackResultReceiver(latch, listener);
+            try {
+                mNfcOemExtensionCallback.onExtractOemPackages(message, receiver);
+            } catch (RemoteException remoteException) {
+                return new LinkedList<String>();
+            }
+            try {
+                boolean success = latch.await(
+                        WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+                if (!success) {
+                    return new LinkedList<String>();
+                } else {
+                    Bundle bundle = listener.getResultData();
+                    String[] packageNames = bundle.getStringArray("packageNames");
+                    if (packageNames != null) {
+                        return List.of(packageNames);
+                    }
+                }
+            } catch (InterruptedException ie) {
+                return new LinkedList<String>();
+            }
+        }
+        return new LinkedList<String>();
+    }
+
+    boolean receiveOemCallbackResult(Tag tag, NdefMessage message) {
+        if (mNfcOemExtensionCallback == null) {
+            return false;
+        }
+        CountDownLatch latch = new CountDownLatch(1);
+        NfcCallbackResultReceiver.OnReceiveResultListener listener =
+                new NfcCallbackResultReceiver.OnReceiveResultListener();
+        ResultReceiver receiver = new NfcCallbackResultReceiver(latch, listener);
+        try {
+            mNfcOemExtensionCallback.onNdefMessage(tag, message, receiver);
+        } catch (RemoteException remoteException) {
+            return false;
+        }
+        try {
+            boolean success = latch.await(WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+            if (!success) {
+                return false;
+            } else {
+                return listener.getResultCode() == 1;
+            }
+        } catch (InterruptedException ie) {
+            return false;
+        }
+    }
 }
diff --git a/src/com/android/nfc/NfcEventLog.java b/src/com/android/nfc/NfcEventLog.java
index 2a0eaca1..64652a4b 100644
--- a/src/com/android/nfc/NfcEventLog.java
+++ b/src/com/android/nfc/NfcEventLog.java
@@ -117,7 +117,6 @@ public final class NfcEventLog {
             }
         }
         byte[] bytes = eventListBuilder.build().toByteArray();
-        Log.d(TAG, "writeListToLogFile: " + HexEncoding.encodeToString(bytes));
         try {
             writeLogFile(bytes);
         } catch (IOException e) {
@@ -157,7 +156,7 @@ public final class NfcEventLog {
                 // Cleanup the proto string output to make it more readable.
                 String eventTypeString = event.getEventType().toString()
                     .replaceAll("# com.android.nfc.proto.*", "")
-                    .replaceAll("\n", "");
+                    .replaceAll("\\s+", " ");
                 pw.println(event.getTimestamp() + ": " + eventTypeString);
             }
         }
diff --git a/src/com/android/nfc/NfcInjector.java b/src/com/android/nfc/NfcInjector.java
index fcdc0dfa..04076e86 100644
--- a/src/com/android/nfc/NfcInjector.java
+++ b/src/com/android/nfc/NfcInjector.java
@@ -18,6 +18,7 @@ package com.android.nfc;
 
 import android.annotation.NonNull;
 import android.app.ActivityManager;
+import android.app.KeyguardManager;
 import android.app.backup.BackupManager;
 import android.content.ApexEnvironment;
 import android.content.Context;
@@ -28,6 +29,7 @@ import android.nfc.NfcServiceManager;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.SystemProperties;
@@ -39,13 +41,17 @@ import android.se.omapi.SeServiceManager;
 import android.util.AtomicFile;
 import android.util.Log;
 
+import com.android.nfc.cardemulation.CardEmulationManager;
 import com.android.nfc.cardemulation.util.StatsdUtils;
 import com.android.nfc.dhimpl.NativeNfcManager;
 import com.android.nfc.flags.FeatureFlags;
+import com.android.nfc.flags.Flags;
 import com.android.nfc.handover.HandoverDataParser;
+import com.android.nfc.wlc.NfcCharging;
 
 import java.io.File;
 import java.time.LocalDateTime;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * To be used for dependency injection (especially helps mocking static dependencies).
@@ -74,13 +80,19 @@ public class NfcInjector {
     private final NfcDiagnostics mNfcDiagnostics;
     private final NfcServiceManager.ServiceRegisterer mNfcManagerRegisterer;
     private final NfcWatchdog mNfcWatchdog;
+    private final KeyguardManager mKeyguardManager;
     private static NfcInjector sInstance;
+    private CardEmulationManager mCardEmulationManager;
 
     public static NfcInjector getInstance() {
         if (sInstance == null) throw new IllegalStateException("Nfc injector instance null");
         return sInstance;
     }
 
+    static void setNfcInjector(NfcInjector nfcInjector) {
+        sInstance = nfcInjector;
+    }
+
 
     public NfcInjector(@NonNull Context context, @NonNull Looper mainLooper) {
         if (sInstance != null) throw new IllegalStateException("Nfc injector instance not null");
@@ -115,9 +127,21 @@ public class NfcInjector {
         mNfcEventLog = new NfcEventLog(mContext, this, eventLogThread.getLooper(),
                 new AtomicFile(new File(NFC_DATA_DIR, EVENT_LOG_FILE_NAME)));
         mNfcWatchdog = new NfcWatchdog(mContext);
+        mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
         sInstance = this;
     }
 
+    public CardEmulationManager getCardEmulationManager() {
+        if (mCardEmulationManager == null) {
+            mCardEmulationManager = new CardEmulationManager(mContext, sInstance, mDeviceConfigFacade);
+        }
+        return mCardEmulationManager;
+    }
+
+    public NfcCharging getNfcCharging(DeviceHost deviceHost) {
+        return new NfcCharging(mContext, deviceHost);
+    }
+
     public Context getContext() {
         return mContext;
     }
@@ -202,6 +226,10 @@ public class NfcInjector {
         return LocalDateTime.now();
     }
 
+    public String getNfcPackageName() {
+        return mContext.getPackageName();
+    }
+
     public boolean isInProvisionMode() {
         boolean isNfcProvisioningEnabled = false;
         try {
@@ -249,6 +277,11 @@ public class NfcInjector {
                 mContext.getContentResolver(), Constants.SETTINGS_SATELLITE_MODE_ENABLED, 0) == 1;
     }
 
+    public static boolean isPrivileged(int callingUid) {
+        // Check for root uid to help invoking privileged APIs from rooted shell only.
+        return callingUid == Process.SYSTEM_UID || callingUid == Process.NFC_UID
+                || callingUid == Process.ROOT_UID;
+    }
 
     /**
      * Get the current time of the clock in milliseconds.
@@ -277,6 +310,17 @@ public class NfcInjector {
         return SystemClock.elapsedRealtimeNanos();
     }
 
+    /**
+     * Ensure that the watchdog is monitoring the NFC process.
+     */
+    public void ensureWatchdogMonitoring() {
+        mNfcWatchdog.ensureWatchdogMonitoring();
+    }
+
+    public AtomicBoolean createAtomicBoolean() {
+        return new AtomicBoolean();
+    }
+
     /**
      * Temporary location to store nfc properties being added in Android 16 for OEM convergence.
      * Will move all of these together to libsysprop later to avoid multiple rounds of API reviews.
@@ -289,4 +333,13 @@ public class NfcInjector {
         }
 
     }
+
+    /**
+     * Returns whether the device unlocked or not.
+     */
+    public boolean isDeviceLocked() {
+        return (android.app.Flags.deviceUnlockListener() && Flags.useDeviceLockListener())
+                            ? mKeyguardManager.isDeviceLocked()
+                            : mKeyguardManager.isKeyguardLocked();
+    }
 }
\ No newline at end of file
diff --git a/src/com/android/nfc/NfcPermissions.java b/src/com/android/nfc/NfcPermissions.java
index ed92a76b..453843ff 100644
--- a/src/com/android/nfc/NfcPermissions.java
+++ b/src/com/android/nfc/NfcPermissions.java
@@ -4,6 +4,7 @@ import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 
 import android.annotation.Nullable;
 import android.app.ActivityManager;
+import android.app.AppOpsManager;
 import android.app.admin.DevicePolicyManager;
 import android.content.Context;
 import android.content.pm.PackageManager;
@@ -47,9 +48,12 @@ public class NfcPermissions {
             "NFC_SET_CONTROLLER_ALWAYS_ON permission required";
 
     private final Context mContext;
+    private final AppOpsManager mAppOpsManager;
+
 
     public NfcPermissions(Context context) {
         mContext = context;
+        mAppOpsManager = mContext.getSystemService(AppOpsManager.class);
     }
 
 
@@ -176,4 +180,19 @@ public class NfcPermissions {
         if (devicePolicyManager == null) return false;
         return devicePolicyManager.isProfileOwnerApp(packageName);
     }
+
+    /**
+     * API to validate if a package name belongs to a UID. Throws SecurityException
+     * if pkgName does not belongs to a UID
+     *
+     * @param pkgName package name of the application requesting access
+     * @param uid The uid of the package
+     *
+     */
+    public void checkPackage(int uid, String pkgName) throws SecurityException {
+        if (pkgName == null) {
+            throw new SecurityException("Checking UID " + uid + " but Package Name is Null");
+        }
+        mAppOpsManager.checkPackage(uid, pkgName);
+    }
 }
diff --git a/src/com/android/nfc/NfcProprietaryCaps.java b/src/com/android/nfc/NfcProprietaryCaps.java
index 9ad0de97..51e7c069 100644
--- a/src/com/android/nfc/NfcProprietaryCaps.java
+++ b/src/com/android/nfc/NfcProprietaryCaps.java
@@ -26,10 +26,12 @@ public class NfcProprietaryCaps {
     private static final int POLLING_FRAME_NTF = 1;
     private static final int POWER_SAVING_MODE = 2;
     private static final int AUTOTRANSACT_POLLING_LOOP_FILTER = 3;
+    private static final int NUMBER_OF_EXIT_FRAMES_SUPPORTED = 4;
     private final PassiveObserveMode mPassiveObserveMode;
     private final boolean mIsPollingFrameNotificationSupported;
     private final boolean mIsPowerSavingModeSupported;
     private final boolean mIsAutotransactPollingLoopFilterSupported;
+    private final int mNumberOfExitFramesSupported;
 
     public enum PassiveObserveMode {
         NOT_SUPPORTED,
@@ -53,13 +55,18 @@ public class NfcProprietaryCaps {
         return mIsAutotransactPollingLoopFilterSupported;
     }
 
+    public int getNumberOfExitFramesSupported() {
+        return mNumberOfExitFramesSupported;
+    }
+
     public NfcProprietaryCaps(PassiveObserveMode passiveObserveMode,
             boolean isPollingFrameNotificationSupported, boolean isPowerSavingModeSupported,
-            boolean isAutotransactPollingLoopFilterSupported) {
+            boolean isAutotransactPollingLoopFilterSupported, int numberOfExitFramesSupported) {
         mPassiveObserveMode = passiveObserveMode;
         mIsPollingFrameNotificationSupported = isPollingFrameNotificationSupported;
         mIsPowerSavingModeSupported = isPowerSavingModeSupported;
         mIsAutotransactPollingLoopFilterSupported = isAutotransactPollingLoopFilterSupported;
+        mNumberOfExitFramesSupported = numberOfExitFramesSupported;
     }
 
     public static NfcProprietaryCaps createFromByteArray(byte[] caps) {
@@ -68,6 +75,7 @@ public class NfcProprietaryCaps {
         boolean isPollingFrameNotificationSupported = false;
         boolean isPowerSavingModeSupported = false;
         boolean isAutotransactPollingLoopFilterSupported  = false;
+        int numberOfExitFramesSupported = 0;
         int offset = 0;
         while ((offset + 2) < caps.length) {
             int id = caps[offset++];
@@ -99,10 +107,14 @@ public class NfcProprietaryCaps {
                 case AUTOTRANSACT_POLLING_LOOP_FILTER:
                     isAutotransactPollingLoopFilterSupported = caps[value_offset] == 0x1;
                     break;
+                case NUMBER_OF_EXIT_FRAMES_SUPPORTED:
+                    numberOfExitFramesSupported = caps[value_offset];
+
             }
         }
         return new NfcProprietaryCaps(passiveObserveMode, isPollingFrameNotificationSupported,
-                isPowerSavingModeSupported, isAutotransactPollingLoopFilterSupported);
+                isPowerSavingModeSupported, isAutotransactPollingLoopFilterSupported,
+                numberOfExitFramesSupported);
     }
 
     @Override
diff --git a/src/com/android/nfc/NfcService.java b/src/com/android/nfc/NfcService.java
index a7e0a051..ed2ca46b 100644
--- a/src/com/android/nfc/NfcService.java
+++ b/src/com/android/nfc/NfcService.java
@@ -16,21 +16,28 @@
 
 package com.android.nfc;
 
+import static android.Manifest.permission.BIND_NFC_SERVICE;
+import static android.nfc.OemLogItems.EVENT_DISABLE;
+import static android.nfc.OemLogItems.EVENT_ENABLE;
+
 import static com.android.nfc.NfcStatsLog.NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__FOREGROUND_APP;
 import static com.android.nfc.NfcStatsLog.NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__TRIGGER_SOURCE_UNKNOWN;
 import static com.android.nfc.NfcStatsLog.NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__WALLET_ROLE_HOLDER;
 import static com.android.nfc.ScreenStateHelper.SCREEN_STATE_ON_LOCKED;
 import static com.android.nfc.ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.app.ActivityManager;
 import android.app.AlarmManager;
 import android.app.Application;
 import android.app.BroadcastOptions;
 import android.app.KeyguardManager;
+import android.app.KeyguardManager.DeviceLockedStateListener;
 import android.app.KeyguardManager.KeyguardLockedStateListener;
 import android.app.PendingIntent;
 import android.app.VrManager;
+import android.app.admin.SecurityLog;
 import android.app.backup.BackupManager;
 import android.app.role.RoleManager;
 import android.content.BroadcastReceiver;
@@ -51,9 +58,11 @@ import android.media.SoundPool.OnLoadCompleteListener;
 import android.net.Uri;
 import android.nfc.AvailableNfcAntenna;
 import android.nfc.Constants;
+import android.nfc.Entry;
 import android.nfc.ErrorCodes;
 import android.nfc.FormatException;
 import android.nfc.IAppCallback;
+import android.nfc.IT4tNdefNfcee;
 import android.nfc.INfcAdapter;
 import android.nfc.INfcAdapterExtras;
 import android.nfc.INfcCardEmulation;
@@ -70,6 +79,9 @@ import android.nfc.NdefMessage;
 import android.nfc.NfcAdapter;
 import android.nfc.NfcAntennaInfo;
 import android.nfc.NfcOemExtension;
+import android.nfc.T4tNdefNfcee;
+import android.nfc.OemLogItems;
+import android.nfc.T4tNdefNfceeCcFileInfo;
 import android.nfc.Tag;
 import android.nfc.TechListParcel;
 import android.nfc.TransceiveResult;
@@ -116,9 +128,11 @@ import com.android.nfc.cardemulation.CardEmulationManager;
 import com.android.nfc.cardemulation.util.StatsdUtils;
 import com.android.nfc.dhimpl.NativeNfcManager;
 import com.android.nfc.flags.FeatureFlags;
+import com.android.nfc.flags.Flags;
 import com.android.nfc.handover.HandoverDataParser;
 import com.android.nfc.proto.NfcEventProto;
 import com.android.nfc.wlc.NfcCharging;
+
 import com.google.protobuf.ByteString;
 
 import org.json.JSONException;
@@ -134,6 +148,7 @@ import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.file.Files;
 import java.security.SecureRandom;
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -151,6 +166,8 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
@@ -187,6 +204,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     static final String NATIVE_LOG_FILE_PATH = "/data/misc/nfc/logs";
     static final int NATIVE_CRASH_FILE_SIZE = 1024 * 1024;
     private static final String WAIT_FOR_OEM_ALLOW_BOOT_TIMER_TAG = "NfcWaitForSimTag";
+    static final String DEFAULT_T4T_NFCEE_AID = "D2760000850101";
+    static final byte[] T4T_NFCEE_CC_FILE_ID = {(byte) (0xE1), (byte) (0x03)};
     @VisibleForTesting
     public static final int WAIT_FOR_OEM_ALLOW_BOOT_TIMEOUT_MS = 5_000;
 
@@ -215,6 +234,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     static final int MSG_UPDATE_ISODEP_PROTOCOL_ROUTE = 22;
     static final int MSG_UPDATE_TECHNOLOGY_ABF_ROUTE = 23;
     static final int MSG_WATCHDOG_PING = 24;
+    static final int MSG_SE_SELECTED_EVENT = 25;
+    static final int MSG_UPDATE_SYSTEM_CODE_ROUTE = 26;
 
     static final String MSG_ROUTE_AID_PARAM_TAG = "power";
 
@@ -227,6 +248,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     static final int DISABLE_POLLING_FLAGS = 0x1000;
 
+    static final int RF_COALESCING_WINDOW = 50;
+
     static final int TASK_ENABLE = 1;
     static final int TASK_DISABLE = 2;
     static final int TASK_BOOT = 3;
@@ -310,8 +333,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     private static final int NCI_GID_PROP = 0x0F;
     private static final int NCI_MSG_PROP_ANDROID = 0x0C;
     private static final int NCI_MSG_PROP_ANDROID_POWER_SAVING = 0x01;
+    private static final int NCI_PROP_ANDROID_QUERY_POWER_SAVING_STATUS_CMD = 0x05;
+    private static final int POWER_STATE_SWITCH_ON = 0x01;
 
-    private static final int WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS = 3000;
+    public static final int WAIT_FOR_OEM_CALLBACK_TIMEOUT_MS = 3000;
+
+    private static final long TIME_TO_MONITOR_AFTER_FIELD_ON_MS = 10000L;
 
     private final Looper mLooper;
     private final UserManager mUserManager;
@@ -406,10 +433,13 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     private PowerManager.WakeLock mRoutingWakeLock;
     private PowerManager.WakeLock mRequireUnlockWakeLock;
 
+    private long mLastFieldOnTimestamp = 0;
+
     int mEndSound;
     int mErrorSound;
     SoundPool mSoundPool; // playback synchronized on this
     TagService mNfcTagService;
+    T4tNdefNfceeService mT4tNdefNfceeService;
     NfcAdapterService mNfcAdapter;
     NfcDtaService mNfcDtaService;
     RoutingTableParser mRoutingTableParser;
@@ -477,6 +507,10 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     private final Set<INfcControllerAlwaysOnListener> mAlwaysOnListeners =
             Collections.synchronizedSet(new HashSet<>());
 
+    private int mAidMatchingExactOnly = 0x02;
+    public static final int T4TNFCEE_STATUS_FAILED = -1;
+    private Object mT4tNdefNfcEeObj = new Object();
+    private Bundle mT4tNdefNfceeReturnBundle = new Bundle();
     private final FeatureFlags mFeatureFlags;
     private final Set<INfcWlcStateListener> mWlcStateListener =
             Collections.synchronizedSet(new HashSet<>());
@@ -502,9 +536,15 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
     };
 
+    private Object mDiscoveryLock = new Object();
+
     private boolean mCardEmulationActivated = false;
     private boolean mRfFieldActivated = false;
     private boolean mRfDiscoveryStarted = false;
+    private boolean mEeListenActivated = false;
+    // Scheduled executor for routing table update
+    private final ScheduledExecutorService mRtUpdateScheduler = Executors.newScheduledThreadPool(1);
+    private ScheduledFuture<?> mRtUpdateScheduledTask = null;
 
     private static final int STATUS_OK = NfcOemExtension.STATUS_OK;
     private static final int STATUS_UNKNOWN_ERROR = NfcOemExtension.STATUS_UNKNOWN_ERROR;
@@ -514,40 +554,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     private static final int ACTION_ON_TAG_DISPATCH = 2;
     private static final int ACTION_ON_READ_NDEF = 3;
     private static final int ACTION_ON_APPLY_ROUTING = 4;
+    private static final int ACTION_ON_ROUTING_CHANGED = 5;
 
     public static NfcService getInstance() {
         return sService;
     }
 
-    private static class NfcCallbackResultReceiver extends ResultReceiver {
-        CountDownLatch mCountDownLatch;
-        OnReceiveResultListener mOnReceiveResultListener;
-
-        public NfcCallbackResultReceiver(CountDownLatch latch, OnReceiveResultListener listener) {
-            super(null);
-            mCountDownLatch = latch;
-            mOnReceiveResultListener = listener;
-        }
-
-        @Override
-        protected void onReceiveResult(int resultCode, Bundle resultData) {
-            mOnReceiveResultListener.onReceiveResult(resultCode == 1);
-            mCountDownLatch.countDown();
-        }
-    }
-
-    private static class OnReceiveResultListener {
-        boolean result;
-
-        void onReceiveResult(boolean result) {
-            this.result = result;
-        }
-
-        boolean getResult() {
-            return result;
-        }
-    }
-
     @Override
     public void onRemoteEndpointDiscovered(TagEndpoint tag) {
         sendMessage(NfcService.MSG_NDEF_TAG, tag);
@@ -585,7 +597,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     public void onHostCardEmulationData(int technology, byte[] data) {
         if (mCardEmulationManager != null) {
             mCardEmulationManager.onHostCardEmulationData(technology, data);
-            if (android.nfc.Flags.nfcPersistLog()) {
+            if (android.nfc.Flags.nfcPersistLog() && NFC_VENDOR_DEBUG_ENABLED) {
                 mNfcEventLog.logEvent(
                         NfcEventProto.EventType.newBuilder()
                                 .setHostCardEmulationData(
@@ -626,6 +638,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     @Override
     public void onRemoteFieldActivated() {
         mRfFieldActivated = true;
+        mLastFieldOnTimestamp = mNfcInjector.getWallClockMillis();
+        mNfcInjector.ensureWatchdogMonitoring();
         try {
             if (mNfcOemExtensionCallback != null) {
                 mNfcOemExtensionCallback.onRfFieldActivated(mRfFieldActivated);
@@ -633,20 +647,26 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         } catch (RemoteException e) {
             Log.e(TAG, "Failed to send onRemoteFieldActivated", e);
         }
-        sendMessage(NfcService.MSG_RF_FIELD_ACTIVATED, null);
-
+        if (Flags.coalesceRfEvents() && mHandler.hasMessages(NfcService.MSG_RF_FIELD_DEACTIVATED)) {
+            mHandler.removeMessages(NfcService.MSG_RF_FIELD_DEACTIVATED);
+        } else {
+            sendMessage(NfcService.MSG_RF_FIELD_ACTIVATED, null);
+        }
         if (mStatsdUtils != null) {
             mStatsdUtils.logFieldChanged(true, 0);
         }
-        if (android.nfc.Flags.nfcPersistLog()) {
+        if (android.nfc.Flags.nfcPersistLog() && NFC_VENDOR_DEBUG_ENABLED) {
             mNfcEventLog.logEvent(
                     NfcEventProto.EventType.newBuilder()
                             .setRemoteFieldStateChange(
                                     NfcEventProto.NfcRemoteFieldStateChange.newBuilder()
-                                            .setEnable(true)
+                                            .setFieldOn(true)
                                             .build())
                             .build());
         }
+        if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+            mCardEmulationManager.onRemoteFieldChanged(true);
+        }
     }
 
     @Override
@@ -659,26 +679,44 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         } catch (RemoteException e) {
             Log.e(TAG, "Failed to send onRemoteFieldDeactivated", e);
         }
-        sendMessage(NfcService.MSG_RF_FIELD_DEACTIVATED, null);
-
+        if (Flags.coalesceRfEvents()) {
+            mHandler.sendMessageDelayed(
+                    mHandler.obtainMessage(NfcService.MSG_RF_FIELD_DEACTIVATED),
+                    RF_COALESCING_WINDOW);
+        } else {
+            sendMessage(NfcService.MSG_RF_FIELD_DEACTIVATED, null);
+        }
         if (mStatsdUtils != null) {
             mStatsdUtils.logFieldChanged(false, 0);
         }
-        if (android.nfc.Flags.nfcPersistLog()) {
+        if (android.nfc.Flags.nfcPersistLog() && NFC_VENDOR_DEBUG_ENABLED) {
             mNfcEventLog.logEvent(
                     NfcEventProto.EventType.newBuilder()
                             .setRemoteFieldStateChange(
                                     NfcEventProto.NfcRemoteFieldStateChange.newBuilder()
-                                            .setEnable(false)
+                                            .setFieldOn(false)
                                             .build())
                             .build());
         }
+
+        if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+            mCardEmulationManager.onRemoteFieldChanged(false);
+        }
     }
 
     @Override
     public void onPollingLoopDetected(List<PollingFrame> frames) {
-        if (mCardEmulationManager != null && android.nfc.Flags.nfcReadPollingLoop()) {
-            mCardEmulationManager.onPollingLoopDetected(frames);
+        if (mCardEmulationManager != null
+                && android.nfc.Flags.nfcReadPollingLoop()) {
+            if (Flags.postCallbacks()) {
+                mHandler.post(() -> {
+                    if (mCardEmulationManager != null) {
+                        mCardEmulationManager.onPollingLoopDetected(frames);
+                    }
+                });
+            } else {
+                mCardEmulationManager.onPollingLoopDetected((frames));
+            }
         }
     }
 
@@ -690,7 +728,26 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     @Override
     public void onEeUpdated() {
-        new ApplyRoutingTask().execute();
+        if (mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onEeUpdated();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to send onEeUpdated", e);
+            }
+        }
+        if (mRtUpdateScheduledTask != null && !mRtUpdateScheduledTask.isDone()) {
+            mRtUpdateScheduledTask.cancel(false);
+        }
+        // Delay routing table update to allow remove useless operations when several
+        // ntf are received
+        mRtUpdateScheduledTask =
+                mRtUpdateScheduler.schedule(
+                    () -> {
+                        if (DBG) Log.d(TAG, "onEeUpdated: ApplyRoutingTask");
+                        new ApplyRoutingTask().execute();
+                    },
+                    50,
+                    TimeUnit.MILLISECONDS);
     }
 
     private void restartStack() {
@@ -706,9 +763,22 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     @Override
     public void onHwErrorReported() {
+        if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+            mCardEmulationManager.onInternalErrorReported(
+                    CardEmulation.NFC_INTERNAL_ERROR_NFC_HARDWARE_ERROR);
+        }
         restartStack();
     }
 
+    @FlaggedApi(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    @Override
+    public void onCommandTimeout() {
+        if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+            mCardEmulationManager.onInternalErrorReported(
+                    CardEmulation.NFC_INTERNAL_ERROR_COMMAND_TIMEOUT);
+        }
+    }
+
     @Override
     public void onVendorSpecificEvent(int gid, int oid, byte[] payload) {
         mHandler.post(() -> mNfcAdapter.sendVendorNciNotification(gid, oid, payload));
@@ -716,14 +786,36 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     @Override
     public void onObserveModeStateChanged(boolean enable) {
-        if (mCardEmulationManager != null) {
-            mCardEmulationManager.onObserveModeStateChange(enable);
+        if (Flags.postCallbacks()) {
+            mHandler.post(() -> {
+                if (mCardEmulationManager != null) {
+                    mCardEmulationManager.onObserveModeStateChange(enable);
+                }
+            });
+        } else {
+            if (mCardEmulationManager != null) {
+                mCardEmulationManager.onObserveModeStateChange(enable);
+            }
+        }
+    }
+
+    @Override
+    public void onEeListenActivated(boolean isActivated) {
+        mEeListenActivated = isActivated;
+        try {
+            if (mNfcOemExtensionCallback != null) {
+                mNfcOemExtensionCallback.onEeListenActivated(isActivated);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to send onEeListenActivated", e);
         }
     }
 
     @Override
     public void onRfDiscoveryEvent(boolean isDiscoveryStarted) {
-        mRfDiscoveryStarted = isDiscoveryStarted;
+        synchronized (mDiscoveryLock) {
+            mRfDiscoveryStarted = isDiscoveryStarted;
+        }
         try {
             if (mNfcOemExtensionCallback != null) {
                 mNfcOemExtensionCallback.onRfDiscoveryStarted(mRfDiscoveryStarted);
@@ -733,6 +825,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
     }
 
+    @Override
+    public void onSeSelected() {
+        sendMessage(NfcService.MSG_SE_SELECTED_EVENT, null);
+    }
+
     /**
      * Enable or Disable PowerSaving Mode based on flag
      */
@@ -788,6 +885,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         mNfcCharging.onWlcStopped(wpt_end_condition);
     }
 
+    public void onTagRfDiscovered(boolean discovered) {
+        Log.d(TAG, "onTagRfDiscovered: " + discovered);
+        executeOemOnTagConnectedCallback(discovered);
+    }
+
     final class ReaderModeParams {
         public int flags;
         public IAppCallback callback;
@@ -874,7 +976,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     boolean receiveOemCallbackResult(int action) {
         CountDownLatch latch = new CountDownLatch(1);
-        OnReceiveResultListener listener = new OnReceiveResultListener();
+        NfcCallbackResultReceiver.OnReceiveResultListener listener =
+                new NfcCallbackResultReceiver.OnReceiveResultListener();
         ResultReceiver receiver = new NfcCallbackResultReceiver(latch, listener);
         try {
             switch (action) {
@@ -893,6 +996,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                 case ACTION_ON_APPLY_ROUTING:
                     mNfcOemExtensionCallback.onApplyRouting(receiver);
                     break;
+                case ACTION_ON_ROUTING_CHANGED:
+                    mNfcOemExtensionCallback.onRoutingChanged(receiver);
+                    break;
             }
         } catch (RemoteException remoteException) {
             return false;
@@ -902,7 +1008,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             if (!success) {
                 return false;
             } else {
-                return listener.getResult();
+                return listener.getResultCode() == 1;
             }
         } catch (InterruptedException ie) {
             return false;
@@ -930,6 +1036,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         mNfcTagService = new TagService();
         mNfcAdapter = new NfcAdapterService();
         mRoutingTableParser = mNfcInjector.getRoutingTableParser();
+        mT4tNdefNfceeService = new T4tNdefNfceeService();
         Log.i(TAG, "Starting NFC service");
 
         sService = this;
@@ -1023,7 +1130,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         ownerFilter.addDataScheme("package");
         mContext.registerReceiverForAllUsers(mOwnerReceiver, ownerFilter, null, null);
 
-        addKeyguardLockedStateListener();
+        addDeviceLockedStateListener();
 
         updatePackageCache();
 
@@ -1031,7 +1138,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         mIsWlcCapable = android.nfc.Flags.enableNfcCharging() &&
                 pm.hasSystemFeature(PackageManager.FEATURE_NFC_CHARGING);
         if (mIsWlcCapable) {
-            mNfcCharging = new NfcCharging(mContext, mDeviceHost);
+            mNfcCharging = mNfcInjector.getNfcCharging(mDeviceHost);
             mIsWlcEnabled = mPrefs.getBoolean(PREF_NFC_CHARGING_ON, NFC_CHARGING_ON_DEFAULT);
             // Register ThermalStatusChangedListener
             addThermalStatusListener();
@@ -1043,8 +1150,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         mIsHceFCapable =
                 pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION_NFCF);
         if (mIsHceCapable) {
-            mCardEmulationManager =
-                new CardEmulationManager(mContext, mNfcInjector, mDeviceConfigFacade);
+            mCardEmulationManager = mNfcInjector.getCardEmulationManager();
         }
         mForegroundUtils = mNfcInjector.getForegroundUtils();
         mIsSecureNfcCapable = mDeviceConfigFacade.isSecureNfcCapable();
@@ -1171,6 +1277,10 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         // If overlay is set, delay the NFC boot up until the OEM extension indicates it is ready to
         // proceed with NFC bootup.
         if (mContext.getResources().getBoolean(R.bool.enable_oem_extension)) {
+            // Send intent for OEM extension to initialize.
+            Intent intent = new Intent(NfcOemExtension.ACTION_OEM_EXTENSION_INIT);
+            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT, BIND_NFC_SERVICE);
+            Log.i(TAG, "Sent intent for OEM extension to initialize.");
             return;
         }
         new EnableDisableTask().execute(TASK_BOOT);
@@ -1834,6 +1944,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     return;
                 }
                 mState = newState;
+                if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+                    mCardEmulationManager.onNfcStateChanged(newState);
+                }
                 if (mState == NfcAdapter.STATE_ON && mCardEmulationManager != null) {
                     mCardEmulationManager.updateForShouldDefaultToObserveMode(getUserId());
                 }
@@ -1878,16 +1991,6 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                 }
             }
         }
-
-        int getAlwaysOnState() {
-            synchronized (NfcService.this) {
-                if (!mIsAlwaysOnSupported) {
-                    return NfcAdapter.STATE_OFF;
-                } else {
-                    return mAlwaysOnState;
-                }
-            }
-        }
     }
 
 
@@ -1989,15 +2092,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     }
 
     final class NfcAdapterService extends INfcAdapter.Stub {
-        private boolean isPrivileged(int callingUid) {
-            // Check for root uid to help invoking privileged APIs from rooted shell only.
-            return callingUid == Process.SYSTEM_UID
-                    || callingUid == Process.NFC_UID
-                    || callingUid == Process.ROOT_UID;
-        }
-
         @Override
         public boolean enable(String pkg) throws RemoteException {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), pkg);
+            }
             boolean isDeviceOrProfileOwner = isDeviceOrProfileOwner(Binder.getCallingUid(), pkg);
             if (!NfcPermissions.checkAdminPermissions(mContext)
                     && !isDeviceOrProfileOwner) {
@@ -2013,6 +2112,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                         NfcProperties.initialized().orElse(Boolean.FALSE)) ;
                 return false;
             }
+
+            notifyOemLogEvent(new OemLogItems.Builder(OemLogItems.LOG_ACTION_NFC_TOGGLE)
+                    .setCallingPid(Binder.getCallingPid())
+                    .setCallingEvent(EVENT_ENABLE)
+                    .build());
+
             Log.i(TAG, "Enabling Nfc service. Package:" + pkg);
             List<String> allowlist = new ArrayList<>(
                     Arrays.asList(mContext.getResources().getStringArray(R.array.nfc_allow_list)));
@@ -2034,12 +2139,19 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                                     .setEnabled(true)
                                     .build())
                             .build());
+            if (android.nfc.Flags.nfcStateChangeSecurityLogEventEnabled()) {
+                SecurityLog.writeEvent(SecurityLog.TAG_NFC_ENABLED);
+            }
             enableNfc();
             return true;
         }
 
         @Override
         public boolean disable(boolean saveState, String pkg) throws RemoteException {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), pkg);
+            }
+
             boolean isDeviceOrProfileOwner = isDeviceOrProfileOwner(Binder.getCallingUid(), pkg);
             if (!NfcPermissions.checkAdminPermissions(mContext)
                     && !isDeviceOrProfileOwner) {
@@ -2050,6 +2162,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                 throw new SecurityException("Change nfc state by system app is not allowed!");
             }
 
+            notifyOemLogEvent(new OemLogItems.Builder(OemLogItems.LOG_ACTION_NFC_TOGGLE)
+                    .setCallingPid(Binder.getCallingPid())
+                    .setCallingEvent(EVENT_DISABLE)
+                    .build());
+
             Log.i(TAG, "Disabling Nfc service. Package:" + pkg);
             if (saveState) {
                 saveNfcOnSetting(false);
@@ -2065,6 +2182,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                                     .setEnabled(false)
                                     .build())
                             .build());
+            if (android.nfc.Flags.nfcStateChangeSecurityLogEventEnabled()) {
+                SecurityLog.writeEvent(SecurityLog.TAG_NFC_DISABLED);
+            }
             new EnableDisableTask().execute(TASK_DISABLE);
 
             return true;
@@ -2099,24 +2219,27 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
         @Override
         public synchronized boolean setObserveMode(boolean enable, String packageName) {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), packageName);
+            }
             if (!isNfcEnabled()) {
                 Log.e(TAG, "setObserveMode: NFC must be enabled but is: " + mState);
                 return false;
             }
             int callingUid = Binder.getCallingUid();
+            UserHandle callingUser = Binder.getCallingUserHandle();
             int triggerSource =
                     NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__TRIGGER_SOURCE_UNKNOWN;
-            if (!isPrivileged(callingUid)) {
+            if (!NfcInjector.isPrivileged(callingUid)) {
                 NfcPermissions.enforceUserPermissions(mContext);
                 if (packageName == null) {
                     Log.e(TAG, "no package name associated with non-privileged calling UID");
                 }
                 if (mCardEmulationManager.isPreferredServicePackageNameForUser(packageName,
-                        UserHandle.getUserHandleForUid(callingUid).getIdentifier())) {
+                        callingUser.getIdentifier())) {
                     if (android.permission.flags.Flags.walletRoleEnabled()) {
-                        UserHandle user = Binder.getCallingUserHandle();
                         if (packageName != null) {
-                            triggerSource = packageName.equals(getWalletRoleHolder(user))
+                            triggerSource = packageName.equals(getWalletRoleHolder(callingUser))
                                 ? NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__WALLET_ROLE_HOLDER
                                 : NFC_OBSERVE_MODE_STATE_CHANGED__TRIGGER_SOURCE__FOREGROUND_APP;
                         }
@@ -2169,36 +2292,49 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
 
         @Override
-        public void pausePolling(int timeoutInMs) {
+        public int pausePolling(long timeoutInMs) {
             NfcPermissions.enforceAdminPermissions(mContext);
-
-            if (timeoutInMs <= 0 || timeoutInMs > MAX_POLLING_PAUSE_TIMEOUT) {
-                Log.e(TAG, "Refusing to pause polling for " + timeoutInMs + "ms.");
-                return;
+            synchronized (mDiscoveryLock) {
+                if (!mRfDiscoveryStarted) {
+                    if (DBG) Log.d(TAG, "Polling is already disabled!");
+                    return NfcOemExtension.POLLING_STATE_CHANGE_ALREADY_IN_REQUESTED_STATE;
+                }
             }
-
             synchronized (NfcService.this) {
                 mPollingPaused = true;
                 mDeviceHost.disableDiscovery();
+                if (timeoutInMs <= 0 || timeoutInMs > this.getMaxPausePollingTimeoutMs()) {
+                    throw new IllegalArgumentException(
+                        "Invalid timeout " + timeoutInMs + " ms!");
+                }
                 mHandler.sendMessageDelayed(
                         mHandler.obtainMessage(MSG_RESUME_POLLING), timeoutInMs);
+                return NfcOemExtension.POLLING_STATE_CHANGE_SUCCEEDED;
             }
         }
 
         @Override
-        public void resumePolling() {
+        public int resumePolling() {
             NfcPermissions.enforceAdminPermissions(mContext);
-
+            boolean rfDiscoveryStarted;
+            synchronized (mDiscoveryLock) {
+                rfDiscoveryStarted = mRfDiscoveryStarted;
+            }
             synchronized (NfcService.this) {
                 if (!mPollingPaused) {
-                    return;
+                    if (rfDiscoveryStarted) {
+                        if (DBG) Log.d(TAG, "Polling is already enabled!");
+                        return NfcOemExtension.POLLING_STATE_CHANGE_ALREADY_IN_REQUESTED_STATE;
+                    } else {
+                        if (DBG) Log.d(TAG, "Enable polling explicitly!");
+                    }
                 }
-
                 mHandler.removeMessages(MSG_RESUME_POLLING);
                 mPollingPaused = false;
                 new ApplyRoutingTask().execute();
+                if (DBG) Log.d(TAG, "Polling is resumed");
+                return NfcOemExtension.POLLING_STATE_CHANGE_SUCCEEDED;
             }
-            if (DBG) Log.d(TAG, "Polling is resumed");
         }
 
         @Override
@@ -2211,8 +2347,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         @Override
         public boolean setNfcSecure(boolean enable) {
             NfcPermissions.enforceAdminPermissions(mContext);
-            if(mKeyguard.isKeyguardLocked() && !enable) {
-                Log.i(TAG, "KeyGuard need to be unlocked before setting Secure NFC OFF");
+            if (mNfcInjector.isDeviceLocked() && !enable) {
+                Log.i(TAG, "Device need to be unlocked before setting Secure NFC OFF");
                 return false;
             }
 
@@ -2379,9 +2515,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         public void updateDiscoveryTechnology(
                 IBinder binder, int pollTech, int listenTech, String packageName)
                 throws RemoteException {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), packageName);
+            }
             NfcPermissions.enforceUserPermissions(mContext);
             int callingUid = Binder.getCallingUid();
-            boolean privilegedCaller = isPrivileged(callingUid)
+            boolean privilegedCaller = NfcInjector.isPrivileged(callingUid)
                     || NfcPermissions.checkAdminPermissions(mContext);
             // Allow non-foreground callers with system uid or systemui
             privilegedCaller |= packageName.equals(SYSTEM_UI);
@@ -2494,9 +2633,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         public void setReaderMode(
                 IBinder binder, IAppCallback callback, int flags, Bundle extras, String packageName)
                 throws RemoteException {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), packageName);
+            }
             int callingUid = Binder.getCallingUid();
             int callingPid = Binder.getCallingPid();
-            boolean privilegedCaller = isPrivileged(callingUid)
+            boolean privilegedCaller = NfcInjector.isPrivileged(callingUid)
                     || NfcPermissions.checkAdminPermissions(mContext);
             // Allow non-foreground callers with system uid or systemui
             privilegedCaller |= packageName.equals(SYSTEM_UI);
@@ -2598,6 +2740,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             return mNfcDtaService;
         }
 
+        @Override
+        public IT4tNdefNfcee getT4tNdefNfceeInterface() throws RemoteException {
+            return mT4tNdefNfceeService;
+        }
+
         @Override
         public void addNfcUnlockHandler(INfcUnlockHandler unlockHandler, int[] techList) {
             NfcPermissions.enforceAdminPermissions(mContext);
@@ -2756,17 +2903,6 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             return techMask;
         }
 
-        private String getPackageNameFromUid(int uid) {
-            PackageManager packageManager = mContext.getPackageManager();
-            if (packageManager != null) {
-                String[] packageName = packageManager.getPackagesForUid(uid);
-                if (packageName != null && packageName.length > 0) {
-                    return packageName[0];
-                }
-            }
-            return null;
-        }
-
         private void updateReaderModeParams(
                 IAppCallback callback, int flags, Bundle extras, IBinder binder, int uid) {
             synchronized (NfcService.this) {
@@ -2839,11 +2975,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
             mAlwaysOnListeners.remove(listener);
         }
+
         @Override
         public boolean isTagIntentAppPreferenceSupported() throws RemoteException {
-            NfcPermissions.enforceAdminPermissions(mContext);
             return mIsTagAppPrefSupported;
         }
+
         @Override
         public Map getTagIntentAppPreferenceForUser(int userId) throws RemoteException {
             NfcPermissions.enforceAdminPermissions(mContext);
@@ -2852,6 +2989,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                 return mTagAppPrefList.getOrDefault(userId, new HashMap<>());
             }
         }
+
         @Override
         public int setTagIntentAppPreferenceForUser(int userId,
                 String pkg, boolean allow) throws RemoteException {
@@ -2861,6 +2999,20 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
 
         @Override
+        public boolean isTagIntentAllowed(String pkg, int userId) throws RemoteException {
+            if (!android.nfc.Flags.nfcCheckTagIntentPreference()) {
+                return true;
+            }
+            if (!mIsTagAppPrefSupported) {
+                return true;
+            }
+            HashMap<String, Boolean> map;
+            synchronized (NfcService.this) {
+                map = mTagAppPrefList.getOrDefault(userId, new HashMap<>());
+            }
+            return map.getOrDefault(pkg, true);
+        }
+
         public boolean enableReaderOption(boolean enable, String pkg) {
             Log.d(TAG, "enableReaderOption enabled = " + enable + " calling uid = "
                     + Binder.getCallingUid());
@@ -3010,6 +3162,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     && payload[0] == NCI_MSG_PROP_ANDROID_POWER_SAVING;
         }
 
+        private static boolean isQueryPowerSavingStatusCmd(int gid, int oid, byte[] payload) {
+          return gid == NCI_GID_PROP && oid == NCI_MSG_PROP_ANDROID && payload.length > 0
+                    && payload[0] == NCI_PROP_ANDROID_QUERY_POWER_SAVING_STATUS_CMD;
+        }
+
         @Override
         public synchronized int sendVendorNciMessage(int mt, int gid, int oid, byte[] payload)
                 throws RemoteException {
@@ -3021,18 +3178,30 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
             FutureTask<Integer> sendVendorCmdTask = new FutureTask<>(
                 () -> {
-                   if(isPowerSavingModeCmd(gid, oid, payload)) {
-                        boolean status = setPowerSavingMode(payload[1] == 0x01 ? true : false);
-                        return status? NCI_STATUS_OK : NCI_STATUS_FAILED;
-                    } else {
-                       NfcVendorNciResponse response =
-                               mDeviceHost.sendRawVendorCmd(mt, gid, oid, payload);
-                       if (response.status == NCI_STATUS_OK) {
-                           mHandler.post(() -> mNfcAdapter.sendVendorNciResponse(
-                                             response.gid, response.oid, response.payload));
-                       }
-                       return Integer.valueOf(response.status);
-                   }
+                        if (isPowerSavingModeCmd(gid, oid, payload)) {
+                            boolean status = setPowerSavingMode(payload[1] == 0x01);
+                            return status ? NCI_STATUS_OK : NCI_STATUS_FAILED;
+                        } else if (isQueryPowerSavingStatusCmd(gid, oid, payload)) {
+                            NfcVendorNciResponse response = new NfcVendorNciResponse(
+                                    (byte) NCI_STATUS_OK, NCI_GID_PROP, NCI_MSG_PROP_ANDROID,
+                                    new byte[] {
+                                            (byte) NCI_PROP_ANDROID_QUERY_POWER_SAVING_STATUS_CMD,
+                                            0x00,
+                                            mIsPowerSavingModeEnabled ? (byte) 0x01 : (byte) 0x00});
+                            if (response.status == NCI_STATUS_OK) {
+                                mHandler.post(() -> mNfcAdapter.sendVendorNciResponse(
+                                        response.gid, response.oid, response.payload));
+                            }
+                            return Integer.valueOf(response.status);
+                        } else {
+                            NfcVendorNciResponse response =
+                                    mDeviceHost.sendRawVendorCmd(mt, gid, oid, payload);
+                            if (response.status == NCI_STATUS_OK) {
+                                mHandler.post(() -> mNfcAdapter.sendVendorNciResponse(
+                                        response.gid, response.oid, response.payload));
+                            }
+                            return Integer.valueOf(response.status);
+                        }
                 });
             int status = NCI_STATUS_FAILED;
             try {
@@ -3076,6 +3245,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             if (mCardEmulationManager != null) {
                 mCardEmulationManager.setOemExtension(mNfcOemExtensionCallback);
             }
+            if(mNfcDispatcher != null) {
+                mNfcDispatcher.setOemExtension(mNfcOemExtensionCallback);
+            }
         }
 
         @Override
@@ -3084,14 +3256,20 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             if (DBG) Log.i(TAG, "Unregister the oem extension callback");
             NfcPermissions.enforceAdminPermissions(mContext);
             mNfcOemExtensionCallback = null;
+            if (mCardEmulationManager != null) {
+                mCardEmulationManager.setOemExtension(mNfcOemExtensionCallback);
+            }
+            if (mNfcDispatcher != null) {
+                mNfcDispatcher.setOemExtension(mNfcOemExtensionCallback);
+            }
         }
         @Override
-        public List<String> fetchActiveNfceeList() throws RemoteException {
-            List<String> list = new ArrayList<String>();
+        public Map<String, Integer> fetchActiveNfceeList() throws RemoteException {
+            Map<String, Integer> map = new HashMap<String, Integer>();
             if (isNfcEnabled()) {
-                list = mDeviceHost.dofetchActiveNfceeList();
+                map = mDeviceHost.dofetchActiveNfceeList();
             }
-            return list;
+            return map;
         }
 
         @Override
@@ -3105,7 +3283,10 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                                                 .build())
                                 .build());
             }
-            // TODO: Implement this.
+            mPrefsEditor.clear();
+            mPrefsEditor.putBoolean(
+                PREF_NFC_READER_OPTION_ON, mDeviceConfigFacade.getDefaultReaderOption());
+            mPrefsEditor.commit();
         }
 
         @Override
@@ -3122,13 +3303,70 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             mDeviceHost.checkFirmware();
         }
 
-        // TODO(b/321304762): Add the OEM extension API.
+        @Override
         public void triggerInitialization() throws RemoteException {
             if (DBG) Log.i(TAG, "triggerInitialization");
             NfcPermissions.enforceAdminPermissions(mContext);
             new EnableDisableTask().execute(TASK_BOOT);
         }
 
+        @Override
+        public boolean getSettingStatus() throws RemoteException {
+            if (DBG) Log.i(TAG, "getSettingStatus");
+            NfcPermissions.enforceAdminPermissions(mContext);
+            return getNfcOnSetting();
+        }
+
+        @Override
+        public boolean isTagPresent() throws RemoteException {
+            if (DBG) Log.i(TAG, "isTagPresent");
+            NfcPermissions.enforceAdminPermissions(mContext);
+            return NfcService.this.isTagPresent();
+        }
+
+        @Override
+        public List<Entry> getRoutingTableEntryList() throws RemoteException {
+            if (DBG) Log.i(TAG, "getRoutingTableEntry");
+            NfcPermissions.enforceAdminPermissions(mContext);
+            return mRoutingTableParser.getRoutingTableEntryList(mDeviceHost);
+	}
+
+        @Override
+        public void indicateDataMigration(boolean inProgress, String pkg) throws RemoteException {
+            if (Flags.checkPassedInPackage()) {
+                mNfcPermissions.checkPackage(Binder.getCallingUid(), pkg);
+            }
+            if (DBG) Log.i(TAG, "indicateDataMigration inProgress: " + inProgress);
+            NfcPermissions.enforceAdminPermissions(mContext);
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setDataMigrationInProgress(NfcEventProto.NfcDataMigrationInProgress
+                                    .newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setPackageName(pkg)
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setInProgress(inProgress)
+                                    .build())
+                            .build());
+        }
+
+        @Override
+        public int commitRouting() throws RemoteException {
+            if (DBG) Log.i(TAG, "commitRouting");
+            NfcPermissions.enforceAdminPermissions(mContext);
+            return mDeviceHost.commitRouting();
+        }
+
+        @Override
+        public long getMaxPausePollingTimeoutMs() {
+            if (DBG) Log.i(TAG, "getMaxPausePollingTimeoutMs");
+            NfcPermissions.enforceAdminPermissions(mContext);
+            int timeoutOverlay = mContext.getResources()
+                    .getInteger(R.integer.max_pause_polling_time_out_ms);
+            return timeoutOverlay > 0 ? (long) timeoutOverlay : MAX_POLLING_PAUSE_TIMEOUT;
+        }
+
         private void updateNfCState() {
             if (mNfcOemExtensionCallback != null) {
                 try {
@@ -3136,6 +3374,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     mNfcOemExtensionCallback.onCardEmulationActivated(mCardEmulationActivated);
                     mNfcOemExtensionCallback.onRfFieldActivated(mRfFieldActivated);
                     mNfcOemExtensionCallback.onRfDiscoveryStarted(mRfDiscoveryStarted);
+                    mNfcOemExtensionCallback.onEeListenActivated(mEeListenActivated);
                 } catch (RemoteException e) {
                     Log.e(TAG, "Failed to update OemExtension with updateNfCState", e);
                 }
@@ -3647,6 +3886,97 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
 
     };
 
+    class T4tNdefNfceeService extends IT4tNdefNfcee.Stub {
+
+        @Override
+        public int writeData(final int fileId, byte[] data) {
+          NfcPermissions.enforceAdminPermissions(mContext);
+          int status = T4tNdefNfcee.WRITE_DATA_ERROR_INTERNAL;
+          try {
+            ByteBuffer fileIdInBytes = ByteBuffer.allocate(2);
+            fileIdInBytes.putShort((short)fileId);
+            status = mDeviceHost.doWriteData(fileIdInBytes.array(), data);
+            if(status > 0) status = T4tNdefNfcee.WRITE_DATA_SUCCESS;
+          } catch (Exception e) {
+            Log.e(TAG, "Exception occurred while writing NDEF NFCEE data", e);
+          }
+          Log.i(TAG, "writeData : " + status);
+          return status;
+        }
+
+        @Override
+        public byte[] readData(final int fileId) {
+          NfcPermissions.enforceAdminPermissions(mContext);
+          byte[] readData = {};
+          ByteBuffer fileIdInBytes = ByteBuffer.allocate(2);
+          fileIdInBytes.putShort((short)fileId);
+          readData = mDeviceHost.doReadData(fileIdInBytes.array());
+          if (readData == null) {
+            throw new IllegalStateException("Ndef Nfcee read failed");
+          }
+          return readData;
+        }
+
+        @Override
+        public T4tNdefNfceeCcFileInfo readCcfile() {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            T4tNdefNfceeCcFileInfo ccFileInfo = null;
+            byte[] readData = {};
+
+            try {
+                readData = mDeviceHost.doReadData(T4T_NFCEE_CC_FILE_ID);
+                if (readData.length >= 15) {
+                    int cclen = ((Byte.toUnsignedInt(readData[0])) << 8)
+                            + (Byte.toUnsignedInt(readData[1]));
+                    int version = Byte.toUnsignedInt(readData[2]);
+                    int maxLe = ((Byte.toUnsignedInt(readData[3])) << 8)
+                            + Byte.toUnsignedInt(readData[4]);
+                    int maxLc = ((Byte.toUnsignedInt(readData[5])) << 8)
+                            + Byte.toUnsignedInt(readData[6]);
+                    int ndefFileId = ((Byte.toUnsignedInt(readData[9])) << 8)
+                            + Byte.toUnsignedInt(readData[10]);
+                    int ndefMaxFileSize = ((Byte.toUnsignedInt(readData[11])) << 8)
+                            + Byte.toUnsignedInt(readData[12]);
+                    int ndefReadAccess = Byte.toUnsignedInt(readData[13]);
+                    int ndefWriteAccess = Byte.toUnsignedInt(readData[14]);
+                    ccFileInfo = new T4tNdefNfceeCcFileInfo(cclen,  version,  maxLe,  maxLc,
+                            ndefFileId,  ndefMaxFileSize, ndefReadAccess,  ndefWriteAccess);
+                } else {
+                    Log.e(TAG, "Empty data received while reading T4T NDEF NFCEE CC data");
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "Exception occurred while reading NDEF NFCEE CC File data", e);
+            }
+            return ccFileInfo;
+        }
+
+        @Override
+        public int clearNdefData() {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            boolean status  = mDeviceHost.doClearNdefData();
+            Log.i(TAG, "doClearNdefT4tData : " + status);
+            return status
+                    ? T4tNdefNfcee.CLEAR_DATA_SUCCESS
+                    : T4tNdefNfcee.CLEAR_DATA_FAILED_INTERNAL;
+        }
+
+        @Override
+        public boolean isNdefOperationOngoing() {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            boolean status  = mDeviceHost.isNdefOperationOngoing();
+            Log.i(TAG, "isNdefOperationOngoing : " + status);
+            return status;
+        }
+
+        @Override
+        public boolean isNdefNfceeEmulationSupported() {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            boolean status  = mDeviceHost.isNdefNfceeEmulationSupported();
+            Log.i(TAG, "isT4tNdefNfceeEmulationSupported : " + status);
+            return status;
+        }
+    }
+
     boolean isNfcEnabledOrShuttingDown() {
         synchronized (this) {
             return (mState == NfcAdapter.STATE_ON || mState == NfcAdapter.STATE_TURNING_OFF);
@@ -3696,6 +4026,10 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
             Log.e(TAG, "Watchdog triggered, aborting.");
             NfcStatsLog.write(NfcStatsLog.NFC_STATE_CHANGED,
                     NfcStatsLog.NFC_STATE_CHANGED__STATE__CRASH_RESTART);
+            if (android.nfc.Flags.nfcEventListener() && mCardEmulationManager != null) {
+                mCardEmulationManager.onInternalErrorReported(
+                        CardEmulation.NFC_INTERNAL_ERROR_NFC_CRASH_RESTART);
+            }
             storeNativeCrashLogs();
             mDeviceHost.doAbort(getName());
         }
@@ -3728,12 +4062,21 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         return data;
     }
 
-    private void addKeyguardLockedStateListener() {
-        try {
-            mKeyguard.addKeyguardLockedStateListener(mContext.getMainExecutor(),
-                    mIKeyguardLockedStateListener);
-        } catch (Exception e) {
-            Log.e(TAG, "Exception in addKeyguardLockedStateListener " + e);
+    private void addDeviceLockedStateListener() {
+        if (android.app.Flags.deviceUnlockListener() && Flags.useDeviceLockListener()) {
+            try {
+                mKeyguard.addDeviceLockedStateListener(
+                        mContext.getMainExecutor(), mDeviceLockedStateListener);
+            } catch (Exception e) {
+                Log.e(TAG, "Exception in addDeviceLockedStateListener " + e);
+            }
+        } else {
+            try {
+                mKeyguard.addKeyguardLockedStateListener(mContext.getMainExecutor(),
+                        mIKeyguardLockedStateListener);
+            } catch (Exception e) {
+                Log.e(TAG, "Exception in addKeyguardLockedStateListener " + e);
+            }
         }
     }
 
@@ -3750,6 +4093,20 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
     };
 
+    /**
+     * Receives Device lock state updates
+     */
+    private DeviceLockedStateListener mDeviceLockedStateListener =
+            new DeviceLockedStateListener() {
+        @Override
+        public void onDeviceLockedStateChanged(boolean isDeviceLocked) {
+            if (!mIsWlcCapable || !mNfcCharging.NfcChargingOnGoing) {
+                applyScreenState(mScreenStateHelper.checkScreenState(
+                                     mCheckDisplayStateForScreenState));
+            }
+        }
+    };
+
     private void addThermalStatusListener() {
         try {
             if (mPowerManager != null) {
@@ -3799,15 +4156,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                 Log.d(TAG, "applyRouting: skip due to oem callback");
                 return;
             }
-            if (mInProvisionMode) {
-                mInProvisionMode = Settings.Global.getInt(mContentResolver,
-                        Settings.Global.DEVICE_PROVISIONED, 0) == 0;
-                if (!mInProvisionMode) {
-                    // Notify dispatcher it's fine to dispatch to any package now
-                    // and allow handover transfers.
-                    mNfcDispatcher.disableProvisioningMode();
-                }
-            }
+            refreshTagDispatcherInProvisionMode();
             if (mPollingPaused) {
                 Log.d(TAG, "Not updating discovery parameters, polling paused.");
                 return;
@@ -3900,8 +4249,22 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         return false;
     }
 
+    private void refreshTagDispatcherInProvisionMode() {
+        if (mInProvisionMode) {
+            mInProvisionMode = mNfcInjector.isInProvisionMode();
+            if (!mInProvisionMode) {
+                mNfcDispatcher.disableProvisioningMode();
+            }
+        }
+    }
+
     private void StopPresenceChecking() {
         Object[] objectValues = mObjectMap.values().toArray();
+        if (!ArrayUtils.isEmpty(objectValues)) {
+            // If there are some tags connected, we need to execute the callback to indicate
+            // the tag is being forcibly disconnected.
+            executeOemOnTagConnectedCallback(false);
+        }
         for (Object object : objectValues) {
             if (object instanceof TagEndpoint) {
                 TagEndpoint tag = (TagEndpoint)object;
@@ -4056,7 +4419,24 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         return false;
     }
 
+    /**
+     * get default T4TNfcee power state supported
+     */
+    private int getT4tNfceePowerState() {
+        int powerState = mDeviceHost.getT4TNfceePowerState();
+        synchronized (NfcService.this) {
+            if (mIsSecureNfcEnabled) {
+                /* Secure nfc on,Setting power state screen on unlocked */
+                powerState = POWER_STATE_SWITCH_ON;
+            }
+        }
+        if (DBG) Log.d(TAG, "T4TNfceePowerState : " + powerState);
+        return powerState;
+    }
+
     public boolean sendData(byte[] data) {
+        notifyOemLogEvent(new OemLogItems.Builder(OemLogItems.LOG_ACTION_HCE_DATA)
+                .setApduResponse(data).build());
         return mDeviceHost.sendRawFrame(data);
     }
 
@@ -4072,8 +4452,19 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         sendMessage(MSG_UPDATE_ISODEP_PROTOCOL_ROUTE, route);
     }
 
-    public void setTechnologyABFRoute(int route) {
-        sendMessage(MSG_UPDATE_TECHNOLOGY_ABF_ROUTE, route);
+    /**
+     * Set NFCC technology routing for ABF listening
+     */
+    public void setTechnologyABFRoute(int route, int felicaRoute) {
+        Message msg = mHandler.obtainMessage();
+        msg.what = MSG_UPDATE_TECHNOLOGY_ABF_ROUTE;
+        msg.arg1 = route;
+        msg.arg2 = felicaRoute;
+        mHandler.sendMessage(msg);
+    }
+
+    public void setSystemCodeRoute(int route) {
+        sendMessage(MSG_UPDATE_SYSTEM_CODE_ROUTE, route);
     }
 
     void sendMessage(int what, Object obj) {
@@ -4087,7 +4478,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
      * Send require device unlock for NFC intent to system UI.
      */
     public void sendRequireUnlockIntent() {
-        if (!mIsRequestUnlockShowed && mKeyguard.isKeyguardLocked()) {
+        if (!mIsRequestUnlockShowed && mNfcInjector.isDeviceLocked()) {
             if (DBG) Log.d(TAG, "Request unlock");
             mIsRequestUnlockShowed = true;
             mRequireUnlockWakeLock.acquire();
@@ -4159,6 +4550,12 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                             return;
                         }
                         if (mCurrentDiscoveryParameters.shouldEnableDiscovery()) {
+                            if (mNfcOemExtensionCallback != null) {
+                                if (receiveOemCallbackResult(ACTION_ON_ROUTING_CHANGED)) {
+                                    Log.e(TAG, "Oem skip commitRouting");
+                                    return;
+                                }
+                            }
                             mDeviceHost.commitRouting();
                         } else {
                             Log.d(TAG, "Not committing routing because discovery is disabled.");
@@ -4209,12 +4606,14 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                                 @Override
                                 public void onTagDisconnected() {
                                     mCookieUpToDate = -1;
+                                    executeOemOnTagConnectedCallback(false);
                                     applyRouting(false);
                                 }
                             };
                     synchronized (NfcService.this) {
                         readerParams = mReaderModeParams;
                     }
+                    executeOemOnTagConnectedCallback(true);
                     if (mNfcOemExtensionCallback != null
                             && receiveOemCallbackResult(ACTION_ON_READ_NDEF)) {
                         Log.d(TAG, "MSG_NDEF_TAG: skip due to oem callback");
@@ -4256,6 +4655,7 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                         if (!tag.reconnect()) {
                             tag.disconnect();
                             if (DBG) Log.d(TAG, "Read NDEF error");
+                            executeOemOnTagConnectedCallback(false);
                             if (mScreenState == ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED) {
                                 if (mReadErrorCount < mReadErrorCountMax) {
                                     mReadErrorCount++;
@@ -4328,6 +4728,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     break;
 
                 case MSG_RF_FIELD_ACTIVATED:
+                    notifyOemLogEvent(new OemLogItems
+                            .Builder(OemLogItems.LOG_ACTION_RF_FIELD_STATE_CHANGED)
+                            .setRfFieldOnTime(Instant.now()).build());
                     if (mCardEmulationManager != null) {
                         mCardEmulationManager.onFieldChangeDetected(true);
                     }
@@ -4338,6 +4741,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     }
                     break;
                 case MSG_RF_FIELD_DEACTIVATED:
+                    notifyOemLogEvent(new OemLogItems
+                            .Builder(OemLogItems.LOG_ACTION_RF_FIELD_STATE_CHANGED)
+                            .setRfFieldOnTime(Instant.now()).build());
                     if (mCardEmulationManager != null) {
                         mCardEmulationManager.onFieldChangeDetected(false);
                     }
@@ -4377,6 +4783,9 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                         if (mState == NfcAdapter.STATE_TURNING_OFF)
                             return;
                     }
+                    notifyOemLogEvent(
+                            new OemLogItems.Builder(OemLogItems.LOG_ACTION_SCREEN_STATE_CHANGED)
+                                    .build());
 
                     mRoutingWakeLock.acquire();
                     try {
@@ -4408,6 +4817,11 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     sendOffHostTransactionEvent(data[0], data[1], data[2]);
                     break;
 
+                case MSG_SE_SELECTED_EVENT:
+                    if (mCardEmulationManager != null) {
+                        mCardEmulationManager.onOffHostAidSelected();
+                    }
+                    break;
                 case MSG_PREFERRED_PAYMENT_CHANGED:
                     Intent preferredPaymentChangedIntent =
                             new Intent(NfcAdapter.ACTION_PREFERRED_PAYMENT_CHANGED);
@@ -4442,11 +4856,21 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     break;
                 case MSG_UPDATE_TECHNOLOGY_ABF_ROUTE:
                     if (DBG) Log.d(TAG, "Update technology A,B&F route");
-                    mDeviceHost.setTechnologyABFRoute((Integer)msg.obj);
+                    int msgRoute = msg.arg1;
+                    int felicaRoute = msg.arg2;
+                    mDeviceHost.setTechnologyABFRoute(msgRoute, felicaRoute);
                     break;
                 case MSG_WATCHDOG_PING:
                     NfcWatchdog watchdog = (NfcWatchdog) msg.obj;
                     watchdog.notifyHasReturned();
+                    if (mLastFieldOnTimestamp + TIME_TO_MONITOR_AFTER_FIELD_ON_MS >
+                            mNfcInjector.getWallClockMillis()) {
+                        watchdog.stopMonitoring();
+                    }
+                    break;
+                case MSG_UPDATE_SYSTEM_CODE_ROUTE:
+                    if (DBG) Log.d(TAG, "Update system code");
+                    mDeviceHost.setSystemCodeRoute((Integer) msg.obj);
                     break;
                 default:
                     Log.e(TAG, "Unknown message received");
@@ -4751,13 +5175,15 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                         return;
                     }
                 }
+                refreshTagDispatcherInProvisionMode();
                 int dispatchResult = mNfcDispatcher.dispatchTag(tag);
                 if (dispatchResult == NfcDispatcher.DISPATCH_FAIL) {
                     if (DBG) Log.d(TAG, "Tag dispatch failed");
+                    executeOemOnTagConnectedCallback(false);
                     unregisterObject(tagEndpoint.getHandle());
                     if (mPollDelayTime > NO_POLL_DELAY) {
-                        tagEndpoint.stopPresenceChecking();
                         pollingDelay();
+                        tagEndpoint.stopPresenceChecking();
                     } else {
                         Log.d(TAG, "Keep presence checking.");
                     }
@@ -4795,6 +5221,8 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     mDispatchFailedCount = 0;
                     mVibrator.vibrate(mVibrationEffect, HARDWARE_FEEDBACK_VIBRATION_ATTRIBUTES);
                     playSound(SOUND_END);
+                    notifyOemLogEvent(new OemLogItems.Builder(OemLogItems.LOG_ACTION_TAG_DETECTED)
+                            .setTag(tag).build());
                 }
             } catch (Exception e) {
                 Log.e(TAG, "Tag creation exception, not dispatching.", e);
@@ -4803,6 +5231,16 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
     }
 
+    private void executeOemOnTagConnectedCallback(boolean connected) {
+        if (mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onTagConnected(connected);
+            } catch (RemoteException e) {
+                Log.e(TAG, e.toString());
+            }
+        }
+    }
+
     private NfcServiceHandler mHandler;
 
     class ApplyRoutingTask extends AsyncTask<Integer, Void, Void> {
@@ -4895,10 +5333,31 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
                     Context ceContext = mContext.createCredentialProtectedStorageContext();
                     SharedPreferences cePreferences =
                         ceContext.getSharedPreferences(PREF, Context.MODE_PRIVATE);
-                    Log.i(TAG, "CE Shared Pref values: " + cePreferences.getAll());
-                    if (!mContext.moveSharedPreferencesFrom(ceContext, PREF)) {
-                        Log.e(TAG, "Failed to migrate NFC Shared preferences to DE directory");
-                        return;
+                    SharedPreferences ceTagPreferences =
+                            ceContext.getSharedPreferences(PREF_TAG_APP_LIST, Context.MODE_PRIVATE);
+                    Log.d(TAG, "CE Shared Pref values: " + cePreferences.getAll() + ", "
+                            + ceTagPreferences.getAll());
+                    if (cePreferences.getAll().isEmpty()) {
+                        Log.d(TAG, "No NFC Shared preferences to migrate from CE data");
+                    } else {
+                        if (!mContext.moveSharedPreferencesFrom(ceContext, PREF)) {
+                            Log.e(TAG,
+                                    "Failed to migrate NFC Shared preferences to DE directory");
+                            return;
+                        }
+                    }
+                    if (ceTagPreferences.getAll().isEmpty()) {
+                        Log.d(TAG, "No NFC Shared preferences for tag app to migrate from CE data");
+                    } else {
+                        if (!mContext.moveSharedPreferencesFrom(ceContext, PREF_TAG_APP_LIST)) {
+                            Log.e(TAG, "Failed to migrate NFC Shared preferences for tag app "
+                                    + "list to DE directory");
+                            return;
+                        }
+                        initTagAppPrefList();
+                    }
+                    if (mIsHceCapable) {
+                        mCardEmulationManager.migrateSettingsFilesFromCe(ceContext);
                     }
                     // If the move is completed, refresh our reference to the shared preferences.
                     mPrefs = mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE);
@@ -5165,6 +5624,18 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
         }
     }
 
+    /**
+     * Add NDEF NFCEE into routing table
+     */
+    public void addT4tNfceeAid() {
+        if (!mDeviceHost.isNdefNfceeEmulationSupported()) return;
+        Log.i(TAG, "Add T4T Nfcee AID");
+        int ndefNfceeRouteId = mDeviceHost.getNdefNfceeRouteId();
+        routeAids(DEFAULT_T4T_NFCEE_AID, ndefNfceeRouteId,
+                mAidMatchingExactOnly,
+                getT4tNfceePowerState());
+    }
+
     /**
      * Dump debugging information as a NfcServiceDumpProto
      *
@@ -5230,4 +5701,16 @@ public class NfcService implements DeviceHostListener, ForegroundUtils.Callback
     public Handler getHandler() {
         return mHandler;
     }
+
+    public void notifyOemLogEvent(OemLogItems item) {
+        if (mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onLogEventNotified(item);
+            } catch (RemoteException e) {
+                Log.e(TAG, "notifyOemLogEvent failed e = " + e.toString());
+            }
+
+        }
+    }
+
 }
diff --git a/src/com/android/nfc/NfcShellCommand.java b/src/com/android/nfc/NfcShellCommand.java
index 30d0718c..2825f460 100644
--- a/src/com/android/nfc/NfcShellCommand.java
+++ b/src/com/android/nfc/NfcShellCommand.java
@@ -16,8 +16,10 @@
 
 package com.android.nfc;
 
+import android.content.ComponentName;
 import android.content.Context;
 import android.nfc.INfcDta;
+import android.nfc.cardemulation.AidGroup;
 import android.os.Binder;
 import android.os.Process;
 import android.os.RemoteException;
@@ -26,6 +28,8 @@ import android.text.TextUtils;
 import com.android.modules.utils.BasicShellCommandHandler;
 
 import java.io.PrintWriter;
+import java.util.Arrays;
+import androidx.annotation.VisibleForTesting;
 
 /**
  * Interprets and executes 'adb shell cmd nfc [args]'.
@@ -57,12 +61,25 @@ public class NfcShellCommand extends BasicShellCommandHandler {
     };
     private final NfcService mNfcService;
     private final Context mContext;
+    private PrintWriter mPrintWriter;
 
     NfcShellCommand(NfcService nfcService, Context context) {
         mNfcService = nfcService;
         mContext = context;
     }
 
+    @VisibleForTesting
+    NfcShellCommand(NfcService nfcService, Context context, PrintWriter printWriter) {
+       this(nfcService, context);
+       mPrintWriter = printWriter;
+    }
+
+    @VisibleForTesting
+    @Override
+    public PrintWriter getOutPrintWriter() {
+        return mPrintWriter;
+    }
+
     @Override
     public int onCommand(String cmd) {
         // Treat no command as help command.
@@ -121,6 +138,52 @@ public class NfcShellCommand extends BasicShellCommandHandler {
                     boolean enableDta = getNextArgRequiredTrueOrFalse("enable", "disable");
                     configureDta(enableDta);
                     return 0;
+                case "set-offhost-se": {
+                    int userId = Integer.parseInt(getNextArg());
+                    String packageName = getNextArg();
+                    String serviceClsName = getNextArg();
+                    ComponentName componentName = new ComponentName(packageName, serviceClsName);
+                    String offHostSe = getNextArg();
+                    mNfcService.mCardEmulationManager
+                            .getNfcCardEmulationInterface()
+                            .setOffHostForService(userId, componentName, offHostSe);
+                    return 0;
+                }
+                case "reset-offhost-se": {
+                    int userId = Integer.parseInt(getNextArg());
+                    String packageName = getNextArg();
+                    String serviceClsName = getNextArg();
+                    ComponentName componentName = new ComponentName(packageName, serviceClsName);
+                    mNfcService.mCardEmulationManager
+                            .getNfcCardEmulationInterface()
+                            .unsetOffHostForService(userId, componentName);
+                    return 0;
+                }
+                case "register-aid-group": {
+                    int userId = Integer.parseInt(getNextArg());
+                    String packageName = getNextArg();
+                    String serviceClsName = getNextArg();
+                    ComponentName componentName = new ComponentName(packageName, serviceClsName);
+                    String aids = getNextArg();
+                    String category = getNextArg();
+                    AidGroup aidGroup = new AidGroup(Arrays.asList(aids.split("\\s*,\\s*")),
+                            category);
+                    mNfcService.mCardEmulationManager
+                            .getNfcCardEmulationInterface()
+                            .registerAidGroupForService(userId, componentName, aidGroup);
+                    return 0;
+                }
+                case "remove-aid-group": {
+                    int userId = Integer.parseInt(getNextArg());
+                    String packageName = getNextArg();
+                    String serviceClsName = getNextArg();
+                    ComponentName componentName = new ComponentName(packageName, serviceClsName);
+                    String category = getNextArg();
+                    mNfcService.mCardEmulationManager
+                            .getNfcCardEmulationInterface()
+                            .removeAidGroupForService(userId, componentName, category);
+                    return 0;
+                }
                 default:
                     return handleDefaultCommands(cmd);
             }
@@ -196,6 +259,15 @@ public class NfcShellCommand extends BasicShellCommandHandler {
         pw.println("    set discovery technology for polling and listening.");
         pw.println("  configure-dta enable|disable");
         pw.println("    Enable or disable DTA");
+        pw.println("  set-offhost-se <userId> <package> <service_class> <offhost>");
+        pw.println("    Set offhost SE for a registered service");
+        pw.println("  reset-offhost-se <userId> <package> <service_class>");
+        pw.println("    Reset offhost SE for a registered service");
+        pw.println("  register-aid-group <userId> <package> <service_class> "
+                + "<aids(comma separated> <category>");
+        pw.println("    Register AID group for a registered service");
+        pw.println("  remove-aid-group <userId> <package> <service_class> <category>");
+        pw.println("    Remove AID group for a registered service");
     }
 
     @Override
diff --git a/src/com/android/nfc/NfcTagAllowNotification.java b/src/com/android/nfc/NfcTagAllowNotification.java
new file mode 100644
index 00000000..6ced92a0
--- /dev/null
+++ b/src/com/android/nfc/NfcTagAllowNotification.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.nfc.NfcAdapter;
+
+/**
+ * This class handles the Notification Manager for the tag app allowlist info
+ */
+
+public class NfcTagAllowNotification {
+    private static final String NFC_NOTIFICATION_CHANNEL = "nfc_tag_notification_channel";
+    private NotificationChannel mNotificationChannel;
+    public static final int NOTIFICATION_ID_NFC = -1000003;
+    Context mContext;
+    String mAppName;
+
+    /**
+     * Constructor
+     *
+     * @param ctx The context to use to obtain access to the resources
+     * @param appName The tag application name
+     */
+    public NfcTagAllowNotification(Context ctx, String appName) {
+        mContext = ctx;
+        mAppName = appName;
+    }
+
+    /**
+     * Start the notification.
+     */
+    public void startNotification() {
+        Intent infoIntent = new Intent().setAction(NfcAdapter.ACTION_CHANGE_TAG_INTENT_PREFERENCE);
+        Notification.Builder builder = new Notification.Builder(mContext, NFC_NOTIFICATION_CHANNEL);
+        String formatString = mContext.getString(R.string.nfc_tag_alert_title);
+        builder.setContentTitle(String.format(formatString, mAppName))
+                .setContentText(mContext.getString(R.string.nfc_tag_alert_message))
+                .setSmallIcon(R.drawable.nfc_icon)
+                .setPriority(NotificationManager.IMPORTANCE_DEFAULT)
+                .setAutoCancel(true)
+                .setContentIntent(PendingIntent.getActivity(mContext, 0, infoIntent,
+                      PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE));
+        mNotificationChannel = new NotificationChannel(NFC_NOTIFICATION_CHANNEL,
+                mContext.getString(R.string.nfcUserLabel), NotificationManager.IMPORTANCE_DEFAULT);
+        NotificationManager notificationManager =
+                mContext.getSystemService(NotificationManager.class);
+        notificationManager.createNotificationChannel(mNotificationChannel);
+        notificationManager.notify(NOTIFICATION_ID_NFC, builder.build());
+    }
+}
+
diff --git a/src/com/android/nfc/NfcWatchdog.java b/src/com/android/nfc/NfcWatchdog.java
index f9badbd5..e8e44bd1 100644
--- a/src/com/android/nfc/NfcWatchdog.java
+++ b/src/com/android/nfc/NfcWatchdog.java
@@ -39,21 +39,13 @@ public class NfcWatchdog extends BroadcastReceiver {
     static final String ACTION_WATCHDOG = "android.nfc.intent.action.WATCHDOG";
 
     CountDownLatch mCountDownLatch;
-    private Intent mWatchdogIntent = new Intent(ACTION_WATCHDOG);
+    Context mContext;
 
     NfcWatchdog(Context context) {
+        mContext = context;
         if (android.nfc.Flags.nfcWatchdog()) {
-            PendingIntent pendingIntent =
-                    PendingIntent.getBroadcast(
-                            context, 0, mWatchdogIntent, PendingIntent.FLAG_IMMUTABLE);
             context.registerReceiver(this, new IntentFilter(ACTION_WATCHDOG),
                     Context.RECEIVER_EXPORTED);
-            AlarmManager alarmManager = context.getSystemService(AlarmManager.class);
-            alarmManager.setInexactRepeating(
-                    AlarmManager.ELAPSED_REALTIME,
-                    SystemClock.elapsedRealtime() + NFC_MONITOR_INTERVAL,
-                    NFC_MONITOR_INTERVAL,
-                    pendingIntent);
         }
     }
 
@@ -122,4 +114,27 @@ public class NfcWatchdog extends BroadcastReceiver {
             }
         }
     }
+
+    void ensureWatchdogMonitoring() {
+        if (android.nfc.Flags.nfcWatchdog()) {
+            Intent watchdogIntent = new Intent(ACTION_WATCHDOG);
+            AlarmManager alarmManager = mContext.getSystemService(AlarmManager.class);
+            PendingIntent pendingIntent = PendingIntent.getBroadcast(
+                mContext, 0, watchdogIntent, PendingIntent.FLAG_IMMUTABLE);
+            if (alarmManager != null && alarmManager.getNextAlarmClock() == null) {
+                alarmManager.setInexactRepeating(
+                    AlarmManager.ELAPSED_REALTIME,
+                    SystemClock.elapsedRealtime() + NFC_MONITOR_INTERVAL,
+                    NFC_MONITOR_INTERVAL,
+                    pendingIntent);
+            }
+        }
+    }
+
+    void stopMonitoring() {
+        AlarmManager alarmManager = mContext.getSystemService(AlarmManager.class);
+        if (alarmManager != null) {
+            alarmManager.cancelAll();
+        }
+    }
 }
diff --git a/src/com/android/nfc/RoutingTableParser.java b/src/com/android/nfc/RoutingTableParser.java
index 56ee5dc2..64928bd7 100644
--- a/src/com/android/nfc/RoutingTableParser.java
+++ b/src/com/android/nfc/RoutingTableParser.java
@@ -16,13 +16,19 @@
 
 package com.android.nfc;
 
+import android.nfc.Entry;
 import android.sysprop.NfcProperties;
 import android.util.Log;
 
 import androidx.annotation.VisibleForTesting;
 
+import com.android.nfc.cardemulation.RoutingOptionManager;
+
 import java.io.PrintWriter;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
 import java.util.Vector;
 
@@ -34,7 +40,7 @@ public class RoutingTableParser {
     private static final String TAG = "RoutingTableParser";
     private static int sRoutingTableSize = 0;
     private static int sRoutingTableMaxSize = 0;
-    private static Vector<RoutingEntryInfo> sRoutingTable = new Vector<RoutingEntryInfo>(0);
+    private static final Vector<RoutingEntryInfo> sRoutingTable = new Vector<RoutingEntryInfo>(0);
 
     // Entry types
     static final byte TYPE_TECHNOLOGY = 0;
@@ -319,4 +325,21 @@ public class RoutingTableParser {
         Log.i(TAG, String.format("RoutingTableSize: %d", lmrt_cmd.length));
         Log.i(TAG, String.format("RoutingTable: %s", lmrt_str));
     }
+
+    public List<Entry> getRoutingTableEntryList(DeviceHost dh) {
+        update(dh);
+        List<Entry> entries = new ArrayList<>();
+        for (RoutingEntryInfo info : sRoutingTable) {
+            String entry = switch (info.mType) {
+                case TYPE_TECHNOLOGY -> getTechStr(info.mEntry);
+                case TYPE_PROTOCOL -> getProtoStr(info.mEntry);
+                case TYPE_AID -> getAidStr(info.mEntry);
+                case TYPE_SYSTEMCODE -> new String(info.mEntry, StandardCharsets.UTF_8);
+                default -> null;
+            };
+            entries.add(new Entry(entry, info.mType, info.mNfceeId,
+                    RoutingOptionManager.getInstance().getSecureElementForRoute(info.mNfceeId)));
+        }
+        return entries;
+    }
 }
diff --git a/src/com/android/nfc/ScreenStateHelper.java b/src/com/android/nfc/ScreenStateHelper.java
index b643f4a6..99c099cb 100644
--- a/src/com/android/nfc/ScreenStateHelper.java
+++ b/src/com/android/nfc/ScreenStateHelper.java
@@ -38,12 +38,12 @@ class ScreenStateHelper {
 
     int checkScreenState(boolean checkDisplayState) {
         if (!mPowerManager.isInteractive() || (checkDisplayState && !isDisplayOn())) {
-            if (mKeyguardManager.isKeyguardLocked()) {
+            if (NfcInjector.getInstance().isDeviceLocked()) {
                 return SCREEN_STATE_OFF_LOCKED;
             } else {
                 return SCREEN_STATE_OFF_UNLOCKED;
             }
-        } else if (mKeyguardManager.isKeyguardLocked()) {
+        } else if (NfcInjector.getInstance().isDeviceLocked()) {
             return SCREEN_STATE_ON_LOCKED;
         } else {
             return SCREEN_STATE_ON_UNLOCKED;
@@ -52,12 +52,12 @@ class ScreenStateHelper {
 
     int checkScreenStateProvisionMode() {
         if (!mPowerManager.isInteractive()) {
-            if (mKeyguardManager.isDeviceLocked()) {
+            if (NfcInjector.getInstance().isDeviceLocked()) {
                 return SCREEN_STATE_OFF_LOCKED;
             } else {
                 return SCREEN_STATE_OFF_UNLOCKED;
             }
-        } else if (mKeyguardManager.isDeviceLocked()) {
+        } else if (NfcInjector.getInstance().isDeviceLocked()) {
             return SCREEN_STATE_ON_LOCKED;
         } else {
             return SCREEN_STATE_ON_UNLOCKED;
diff --git a/src/com/android/nfc/cardemulation/AidRoutingManager.java b/src/com/android/nfc/cardemulation/AidRoutingManager.java
index 786302a5..ac54de15 100644
--- a/src/com/android/nfc/cardemulation/AidRoutingManager.java
+++ b/src/com/android/nfc/cardemulation/AidRoutingManager.java
@@ -20,6 +20,8 @@ import android.util.Log;
 import android.util.SparseArray;
 import android.util.proto.ProtoOutputStream;
 
+import androidx.annotation.VisibleForTesting;
+
 import com.android.nfc.NfcService;
 import com.android.nfc.NfcStatsLog;
 
@@ -34,7 +36,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import androidx.annotation.VisibleForTesting;
 
 public class AidRoutingManager {
 
@@ -66,6 +67,8 @@ public class AidRoutingManager {
     // SE
     int mDefaultOffHostRoute;
 
+    int mDefaultFelicaRoute;
+
     // How the NFC controller can match AIDs in the routing table;
     // see AID_MATCHING constants
     final int mAidMatchingSupport;
@@ -95,23 +98,19 @@ public class AidRoutingManager {
 
     public AidRoutingManager() {
         mDefaultRoute = mRoutingOptionManager.getDefaultRoute();
-        if (DBG)
-            Log.d(TAG, "mDefaultRoute=0x" + Integer.toHexString(mDefaultRoute));
+        if (DBG) Log.d(TAG, "mDefaultRoute=0x" + Integer.toHexString(mDefaultRoute));
         mDefaultOffHostRoute = mRoutingOptionManager.getDefaultOffHostRoute();
-        if (DBG)
-            Log.d(TAG, "mDefaultOffHostRoute=0x" + Integer.toHexString(mDefaultOffHostRoute));
+        if (DBG) Log.d(TAG, "mDefaultOffHostRoute=0x" + Integer.toHexString(mDefaultOffHostRoute));
+        mDefaultFelicaRoute = mRoutingOptionManager.getDefaultFelicaRoute();
+        if (DBG) Log.d(TAG, "mDefaultFelicaRoute=0x" + Integer.toHexString(mDefaultFelicaRoute));
         mOffHostRouteUicc = mRoutingOptionManager.getOffHostRouteUicc();
-        if (DBG)
-            Log.d(TAG, "mOffHostRouteUicc=" + Arrays.toString(mOffHostRouteUicc));
+        if (DBG) Log.d(TAG, "mOffHostRouteUicc=" + Arrays.toString(mOffHostRouteUicc));
         mOffHostRouteEse = mRoutingOptionManager.getOffHostRouteEse();
-        if (DBG)
-          Log.d(TAG, "mOffHostRouteEse=" + Arrays.toString(mOffHostRouteEse));
+        if (DBG) Log.d(TAG, "mOffHostRouteEse=" + Arrays.toString(mOffHostRouteEse));
         mAidMatchingSupport = mRoutingOptionManager.getAidMatchingSupport();
-        if (DBG)
-            Log.d(TAG, "mAidMatchingSupport=0x" + Integer.toHexString(mAidMatchingSupport));
+        if (DBG) Log.d(TAG, "mAidMatchingSupport=0x" + Integer.toHexString(mAidMatchingSupport));
         mDefaultIsoDepRoute = mRoutingOptionManager.getDefaultIsoDepRoute();
-        if (DBG)
-            Log.d(TAG, "mDefaultIsoDepRoute=0x" + Integer.toHexString(mDefaultIsoDepRoute));
+        if (DBG) Log.d(TAG, "mDefaultIsoDepRoute=0x" + Integer.toHexString(mDefaultIsoDepRoute));
     }
 
     public boolean supportsAidPrefixRouting() {
@@ -283,10 +282,12 @@ public class AidRoutingManager {
             mDefaultRoute = mRoutingOptionManager.getOverrideDefaultRoute();
             mDefaultIsoDepRoute = mRoutingOptionManager.getOverrideDefaultIsoDepRoute();
             mDefaultOffHostRoute = mRoutingOptionManager.getOverrideDefaultOffHostRoute();
+            mDefaultFelicaRoute = mRoutingOptionManager.getOverrideDefaultFelicaRoute();
         } else {
             mDefaultRoute = mRoutingOptionManager.getDefaultRoute();
             mDefaultIsoDepRoute = mRoutingOptionManager.getDefaultIsoDepRoute();
             mDefaultOffHostRoute = mRoutingOptionManager.getDefaultOffHostRoute();
+            mDefaultFelicaRoute = mRoutingOptionManager.getDefaultFelicaRoute();
         }
 
         boolean isPowerStateUpdated = false;
@@ -340,12 +341,14 @@ public class AidRoutingManager {
 
         synchronized (mLock) {
             if (routeForAid.equals(mRouteForAid) && powerForAid.equals(mPowerForAid) && !force) {
+                NfcService.getInstance().addT4tNfceeAid();
                 if (DBG) Log.d(TAG, "Routing table unchanged, not updating");
                 return false;
             }
 
             // Otherwise, update internal structures and commit new routing
             clearNfcRoutingTableLocked();
+            NfcService.getInstance().addT4tNfceeAid();
             prevRouteForAid = mRouteForAid;
             mRouteForAid = routeForAid;
             prevPowerForAid = mPowerForAid;
@@ -564,17 +567,17 @@ public class AidRoutingManager {
                     + " mDefaultRoute: " + mDefaultRoute);
                 mDefaultIsoDepRoute = mDefaultRoute;
                 mDefaultOffHostRoute = mDefaultRoute;
-            }
-            else {
+                mDefaultFelicaRoute = mDefaultRoute;
+            } else {
                 Log.d(TAG, "Default route is DeviceHost, use previous protocol, technology");
             }
 
             if (force || optionChanged) {
                 NfcService.getInstance().setIsoDepProtocolRoute(mDefaultIsoDepRoute);
-                NfcService.getInstance().setTechnologyABFRoute(mDefaultOffHostRoute);
+                NfcService.getInstance().setTechnologyABFRoute(mDefaultOffHostRoute,
+                        mDefaultFelicaRoute);
             }
-        }
-        else {
+        } else {
             Log.d(TAG, "Routing table is override, Do not send the protocol, tech");
         }
     }
diff --git a/src/com/android/nfc/cardemulation/CardEmulationManager.java b/src/com/android/nfc/cardemulation/CardEmulationManager.java
index e8c9da35..91b0f798 100644
--- a/src/com/android/nfc/cardemulation/CardEmulationManager.java
+++ b/src/com/android/nfc/cardemulation/CardEmulationManager.java
@@ -15,8 +15,12 @@
  */
 package com.android.nfc.cardemulation;
 
-import android.annotation.TargetApi;
+import static android.content.pm.PackageManager.FEATURE_TELEPHONY_SUBSCRIPTION;
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_FAILURE_FEATURE_UNSUPPORTED;
+
 import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
 import android.app.ActivityManager;
 import android.app.role.RoleManager;
 import android.content.ComponentName;
@@ -24,8 +28,10 @@ import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.nfc.ComponentNameAndUser;
 import android.nfc.Constants;
 import android.nfc.INfcCardEmulation;
+import android.nfc.INfcEventListener;
 import android.nfc.INfcFCardEmulation;
 import android.nfc.INfcOemExtensionCallback;
 import android.nfc.NfcAdapter;
@@ -36,25 +42,30 @@ import android.nfc.cardemulation.CardEmulation;
 import android.nfc.cardemulation.NfcFServiceInfo;
 import android.nfc.cardemulation.PollingFrame;
 import android.os.Binder;
-import android.os.Bundle;
+import android.os.Build;
 import android.os.Looper;
 import android.os.PowerManager;
 import android.os.Process;
+import android.os.RemoteCallbackList;
 import android.os.RemoteException;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.sysprop.NfcProperties;
+import android.telephony.SubscriptionManager;
 import android.util.Log;
 import android.util.proto.ProtoOutputStream;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.nfc.DeviceConfigFacade;
+import com.android.nfc.NfcEventLog;
 import com.android.nfc.ForegroundUtils;
 import com.android.nfc.NfcInjector;
 import com.android.nfc.NfcPermissions;
 import com.android.nfc.NfcService;
+import com.android.nfc.proto.NfcEventProto;
 import com.android.nfc.R;
 
 import java.io.FileDescriptor;
@@ -64,9 +75,7 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Collectors;
-
-import com.android.nfc.R;
-import android.permission.flags.Flags;
+import java.util.stream.IntStream;
 
 /**
  * CardEmulationManager is the central entity
@@ -85,7 +94,8 @@ import android.permission.flags.Flags;
  */
 public class CardEmulationManager implements RegisteredServicesCache.Callback,
         RegisteredNfcFServicesCache.Callback, PreferredServices.Callback,
-        EnabledNfcFServices.Callback, WalletRoleObserver.Callback {
+        EnabledNfcFServices.Callback, WalletRoleObserver.Callback,
+        HostEmulationManager.NfcAidRoutingListener {
     static final String TAG = "CardEmulationManager";
     static final boolean DBG = NfcProperties.debug_enabled().orElse(true);
 
@@ -129,6 +139,8 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     final byte[] mOffHostRouteUicc;
     final byte[] mOffHostRouteEse;
     private INfcOemExtensionCallback mNfcOemExtensionCallback;
+    private final NfcEventLog mNfcEventLog;
+    private final int mVendorApiLevel;
 
     // TODO: Move this object instantiation and dependencies to NfcInjector.
     public CardEmulationManager(Context context, NfcInjector nfcInjector,
@@ -158,6 +170,9 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
         mEnabledNfcFServices = new EnabledNfcFServices(
                 context, mNfcFServicesCache, mT3tIdentifiersCache, this);
         mPowerManager = context.getSystemService(PowerManager.class);
+        mNfcEventLog = nfcInjector.getNfcEventLog();
+        mVendorApiLevel = SystemProperties.getInt(
+                "ro.vendor.api_level", Build.VERSION.DEVICE_INITIAL_SDK_INT);
         initialize();
     }
 
@@ -174,7 +189,8 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             PreferredServices preferredServices,
             EnabledNfcFServices enabledNfcFServices,
             RoutingOptionManager routingOptionManager,
-            PowerManager powerManager) {
+            PowerManager powerManager,
+            NfcEventLog nfcEventLog) {
         mContext = context;
         mCardEmulationInterface = new CardEmulationInterface();
         mNfcFCardEmulationInterface = new NfcFCardEmulationInterface();
@@ -192,11 +208,16 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
         mRoutingOptionManager = routingOptionManager;
         mOffHostRouteEse = mRoutingOptionManager.getOffHostRouteEse();
         mOffHostRouteUicc = mRoutingOptionManager.getOffHostRouteUicc();
+        mNfcEventLog = nfcEventLog;
+        mVendorApiLevel = SystemProperties.getInt(
+                "ro.vendor.api_level", Build.VERSION.DEVICE_INITIAL_SDK_INT);
         initialize();
     }
 
-    public void setOemExtension(INfcOemExtensionCallback nfcOemExtensionCallback) {
+    public void setOemExtension(@Nullable INfcOemExtensionCallback nfcOemExtensionCallback) {
         mNfcOemExtensionCallback = nfcOemExtensionCallback;
+        mHostEmulationManager.setOemExtension(mNfcOemExtensionCallback);
+        mAidCache.setOemExtension(nfcOemExtensionCallback);
     }
 
     private void initialize() {
@@ -208,6 +229,10 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             onWalletRoleHolderChanged(
                     mWalletRoleObserver.getDefaultWalletRoleHolder(currentUser), currentUser);
         }
+
+        if (android.nfc.Flags.nfcEventListener()) {
+            mHostEmulationManager.setAidRoutingListener(this);
+        }
     }
 
     public INfcCardEmulation getNfcCardEmulationInterface() {
@@ -232,7 +257,7 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     }
 
     public void onHostCardEmulationActivated(int technology) {
-        if(mNfcOemExtensionCallback!=null) {
+        if(mNfcOemExtensionCallback != null) {
             try {
                 mNfcOemExtensionCallback.onHceEventReceived(NfcOemExtension.HCE_ACTIVATE);
             } catch (RemoteException e) {
@@ -314,6 +339,10 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
         mNfcFServicesCache.onUserSwitched();
     }
 
+    public void migrateSettingsFilesFromCe(Context ceContext) {
+        mServiceCache.migrateSettingsFilesFromCe(ceContext);
+    }
+
     public void onManagedProfileChanged() {
         // for HCE
         mServiceCache.onManagedProfileChanged();
@@ -712,6 +741,23 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             }
             NfcService.getInstance().onPreferredPaymentChanged(
                     NfcAdapter.PREFERRED_PAYMENT_UPDATED);
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setAidRegistration(NfcEventProto.NfcAidRegistration.newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(true)
+                                    .addAllAids(aidGroup.getAids())
+                                    .build())
+                            .build());
             return true;
         }
 
@@ -725,8 +771,29 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 Log.e(TAG, "service ("+ service + ") isn't registered for user " + userId);
                 return false;
             }
-            return mServiceCache.registerPollingLoopFilterForService(userId, Binder.getCallingUid(),
-                    service, pollingLoopFilter, autoTransact);
+            if (!mServiceCache.registerPollingLoopFilterForService(userId, Binder.getCallingUid(),
+                    service, pollingLoopFilter, autoTransact)) {
+                return false;
+            }
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPollingLoopRegistration(NfcEventProto.NfcPollingLoopRegistration
+                                                            .newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(true)
+                                    .setPollingLoopFilter(pollingLoopFilter)
+                                    .build())
+                            .build());
+            return true;
         }
 
         @Override
@@ -739,8 +806,29 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 Log.e(TAG, "service ("+ service + ") isn't registered for user " + userId);
                 return false;
             }
-            return mServiceCache.removePollingLoopFilterForService(userId, Binder.getCallingUid(),
-                    service, pollingLoopFilter);
+            if (!mServiceCache.removePollingLoopFilterForService(userId, Binder.getCallingUid(),
+                    service, pollingLoopFilter)) {
+                return false;
+            }
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPollingLoopRegistration(NfcEventProto.NfcPollingLoopRegistration
+                                                            .newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(false)
+                                    .setPollingLoopFilter(pollingLoopFilter)
+                                    .build())
+                            .build());
+            return true;
         }
 
         @Override
@@ -753,8 +841,29 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 Log.e(TAG, "service ("+ service + ") isn't registed for user " + userId);
                 return false;
             }
-            return mServiceCache.registerPollingLoopPatternFilterForService(userId,
-                    Binder.getCallingUid(), service, pollingLoopPatternFilter, autoTransact);
+            if (!mServiceCache.registerPollingLoopPatternFilterForService(userId,
+                    Binder.getCallingUid(), service, pollingLoopPatternFilter, autoTransact)) {
+                return false;
+            }
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPollingLoopRegistration(NfcEventProto.NfcPollingLoopRegistration
+                                                            .newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(true)
+                                    .setPollingLoopFilter(pollingLoopPatternFilter)
+                                    .build())
+                            .build());
+            return true;
         }
 
         @Override
@@ -767,8 +876,29 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 Log.e(TAG, "service ("+ service + ") isn't registed for user " + userId);
                 return false;
             }
-            return mServiceCache.removePollingLoopPatternFilterForService(userId,
-                    Binder.getCallingUid(), service, pollingLoopPatternFilter);
+            if (!mServiceCache.removePollingLoopPatternFilterForService(userId,
+                    Binder.getCallingUid(), service, pollingLoopPatternFilter)) {
+                return false;
+            }
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPollingLoopRegistration(NfcEventProto.NfcPollingLoopRegistration
+                                                            .newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(false)
+                                    .setPollingLoopFilter(pollingLoopPatternFilter)
+                                    .build())
+                            .build());
+            return true;
         }
 
         @Override
@@ -828,6 +958,22 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             }
             NfcService.getInstance().onPreferredPaymentChanged(
                     NfcAdapter.PREFERRED_PAYMENT_UPDATED);
+            mNfcEventLog.logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setAidRegistration(NfcEventProto.NfcAidRegistration.newBuilder()
+                                    .setAppInfo(NfcEventProto.NfcAppInfo.newBuilder()
+                                            .setUid(Binder.getCallingUid())
+                                            .build())
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                service.getPackageName())
+                                            .setClassName(
+                                                service.getClassName())
+                                            .build())
+                                    .setIsRegistration(false)
+                                    .build())
+                            .build());
             return true;
         }
 
@@ -869,14 +1015,15 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             NfcPermissions.validateUserId(userId);
             NfcPermissions.enforceUserPermissions(mContext);
             NfcPermissions.enforcePreferredPaymentInfoPermissions(mContext);
-            return mServiceCache.getService(userId, mAidCache.getPreferredService().second);
+            return mServiceCache.getService(userId,
+                        mAidCache.getPreferredService().getComponentName());
         }
 
         @Override
-        public boolean setServiceEnabledForCategoryOther(int userId,
+        public int setServiceEnabledForCategoryOther(int userId,
                 ComponentName app, boolean status) throws RemoteException {
             if (!mContext.getResources().getBoolean(R.bool.enable_service_for_category_other))
-              return false;
+              return SET_SERVICE_ENABLED_STATUS_FAILURE_FEATURE_UNSUPPORTED;
             NfcPermissions.enforceUserPermissions(mContext);
 
             return mServiceCache.registerOtherForService(userId, app, status);
@@ -900,6 +1047,14 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
             Log.d(TAG, "overrideRoutingTable. userHandle " + userHandle + ", protocol " + protocol +
                     ", technology " + technology);
 
+            NfcPermissions.enforceAdminPermissions(mContext);
+
+            if ((protocol != null && protocol.equals("default"))
+                    || (technology != null && technology.equals("default"))) {
+                Log.e(TAG, "overrideRoutingTable: override value cannot be set to default");
+                throw new IllegalArgumentException("default value is not allowed.");
+            }
+
             int callingUid = Binder.getCallingUid();
             if (android.nfc.Flags.nfcOverrideRecoverRoutingTable()) {
                 if (!isPreferredServicePackageNameForUser(pkg,
@@ -931,6 +1086,8 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
         public void recoverRoutingTable(int userHandle) {
             Log.d(TAG, "recoverRoutingTable. userHandle " + userHandle);
 
+            NfcPermissions.enforceAdminPermissions(mContext);
+
             if (!mForegroundUtils.isInForeground(Binder.getCallingUid())) {
                 if (DBG) Log.d(TAG, "recoverRoutingTable : not in foreground.");
                 throw new IllegalArgumentException("Caller is not in foreground.");
@@ -942,32 +1099,47 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
 //            NfcService.getInstance().commitRouting();
         }
 
-        // TODO: Need corresponding API
+        @Override
         public void overwriteRoutingTable(int userHandle, String aids,
-            String protocol, String technology) {
-            Log.d(TAG, "overwriteRoutingTable. userHandle " + userHandle
-                + ", emptyAid " + aids + ", protocol " + protocol
-                + ", technology " + technology);
+            String protocol, String technology, String sc) {
+            Log.d(TAG, "overwriteRoutingTable() - userHandle: " + userHandle
+                + ", emptyAid: " + aids + ", protocol: " + protocol
+                + ", technology: " + technology + ", systemCode: " + sc);
+
+            NfcPermissions.enforceAdminPermissions(mContext);
 
             int aidRoute = mRoutingOptionManager.getRouteForSecureElement(aids);
             int protocolRoute = mRoutingOptionManager.getRouteForSecureElement(protocol);
             int technologyRoute = mRoutingOptionManager.getRouteForSecureElement(technology);
+            int scRoute = mRoutingOptionManager.getRouteForSecureElement(sc);
 
             if (DBG) {
-                Log.d(TAG, "aidRoute " + aidRoute + ", protocolRoute "
-                    + protocolRoute + ", technologyRoute " + technologyRoute);
+                Log.d(TAG, "overwriteRoutingTable() - aidRoute: " + Integer.toHexString(aidRoute)
+                        + ", protocolRoute: " + Integer.toHexString(protocolRoute)
+                        + ", technologyRoute: " + Integer.toHexString(technologyRoute)
+                        + ", scRoute: " + Integer.toHexString(scRoute));
             }
             if (aids != null) {
                 mRoutingOptionManager.overrideDefaultRoute(aidRoute);
+            }
+            if (protocol != null) {
                 mRoutingOptionManager.overrideDefaultIsoDepRoute(protocolRoute);
+            }
+            if (technology != null) {
                 mRoutingOptionManager.overrideDefaultOffHostRoute(technologyRoute);
+            }
+            if (sc != null) {
+                mRoutingOptionManager.overrideDefaultScRoute(scRoute);
+            }
+            if (aids != null || protocol != null || technology != null || sc != null) {
                 mRoutingOptionManager.overwriteRoutingTable();
             }
             mAidCache.onRoutingOverridedOrRecovered();
         }
 
-        // TODO: Need corresponding API
+        @Override
         public List<String> getRoutingStatus() {
+            NfcPermissions.enforceAdminPermissions(mContext);
             List<Integer> routingList = new ArrayList<>();
 
             if (mRoutingOptionManager.isRoutingTableOverrided()) {
@@ -986,21 +1158,140 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 .collect(Collectors.toList());
         }
 
-        // TODO: Need corresponding API
+        @Override
         public void setAutoChangeStatus(boolean state) {
+            NfcPermissions.enforceAdminPermissions(mContext);
             mRoutingOptionManager.setAutoChangeStatus(state);
         }
 
-        // TODO: Need corresponding API
+        @Override
         public boolean isAutoChangeEnabled() {
+            NfcPermissions.enforceAdminPermissions(mContext);
             return mRoutingOptionManager.isAutoChangeEnabled();
         }
 
         @Override
         public boolean isEuiccSupported() {
+            NfcPermissions.enforceUserPermissions(mContext);
             return mContext.getResources().getBoolean(R.bool.enable_euicc_support)
                     && NfcInjector.NfcProperties.isEuiccSupported();
         }
+
+        /**
+         * Make sure the device has required telephony feature
+         *
+         * @throws UnsupportedOperationException if the device does not have required telephony feature
+         */
+        private void enforceTelephonySubscriptionFeatureWithException(
+                String callingPackage, String methodName) {
+            if (callingPackage == null) return;
+            if (mVendorApiLevel < Build.VERSION_CODES.VANILLA_ICE_CREAM) {
+                // Skip to check associated telephony feature,
+                // if compatibility change is not enabled for the current process or
+                // the SDK version of vendor partition is less than Android V.
+                return;
+            }
+            if (!mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY_SUBSCRIPTION)) {
+                throw new UnsupportedOperationException(
+                        methodName + " is unsupported without " + FEATURE_TELEPHONY_SUBSCRIPTION);
+            }
+        }
+
+        @Override
+        public int setDefaultNfcSubscriptionId(int subscriptionId, String pkgName) {
+            NfcPermissions.enforceAdminPermissions(mContext);
+            enforceTelephonySubscriptionFeatureWithException(pkgName, "setDefaultNfcSubscriptionId");
+            // TODO(b/321314635): Write to NFC persistent setting.
+            return CardEmulation.SET_SUBSCRIPTION_ID_STATUS_FAILED_INVALID_SUBSCRIPTION_ID;
+        }
+
+        @Override
+        public int getDefaultNfcSubscriptionId(String pkgName) {
+            NfcPermissions.enforceUserPermissions(mContext);
+            enforceTelephonySubscriptionFeatureWithException(pkgName, "getDefaultNfcSubscriptionId");
+            // TODO(b/321314635): Read NFC persistent setting.
+            return SubscriptionManager.INVALID_SUBSCRIPTION_ID;
+        }
+
+        @Override
+        public void registerNfcEventListener(INfcEventListener listener) {
+            if (!android.nfc.Flags.nfcEventListener()) {
+                return;
+            }
+            mNfcEventListeners.register(listener);
+        }
+
+        @Override
+        public void unregisterNfcEventListener(
+                INfcEventListener listener) {
+            if (!android.nfc.Flags.nfcEventListener()) {
+                return;
+            }
+            mNfcEventListeners.unregister(listener);
+        }
+    }
+
+    final RemoteCallbackList<INfcEventListener> mNfcEventListeners = new RemoteCallbackList<>();
+
+    private interface ListenerCall {
+        void invoke(INfcEventListener listener) throws RemoteException;
+    }
+
+    private void callNfcEventListeners(ListenerCall call) {
+        synchronized (mNfcEventListeners) {
+            int numListeners = mNfcEventListeners.beginBroadcast();
+            try {
+                IntStream.range(0, numListeners).forEach(i -> {
+                    try {
+                        call.invoke(mNfcEventListeners.getBroadcastItem(i));
+                    } catch (RemoteException re) {
+                        Log.i(TAG, "Service died", re);
+                    }
+                });
+
+            } finally {
+                mNfcEventListeners.finishBroadcast();
+            }
+        }
+    }
+
+    void notifyPreferredServiceListeners(ComponentNameAndUser preferredService) {
+        if (!android.nfc.Flags.nfcEventListener()) {
+            return;
+        }
+        callNfcEventListeners(listener -> listener.onPreferredServiceChanged(preferredService));
+    }
+
+    @Override
+    public void onAidConflict(@NonNull String aid) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onAidConflictOccurred(aid));
+        }
+    }
+
+    @Override
+    public void onAidNotRouted(@NonNull String aid) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onAidNotRouted(aid));
+        }
+    }
+
+    public void onNfcStateChanged(int state) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onNfcStateChanged(state));
+        }
+    }
+
+    public void onRemoteFieldChanged(boolean isDetected) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onRemoteFieldChanged(isDetected));
+        }
+    }
+
+    public void onInternalErrorReported(@CardEmulation.NfcInternalErrorType int errorType) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onInternalErrorReported(errorType));
+        }
     }
 
     final ForegroundUtils.Callback mForegroundCallback = new ForegroundCallbackImpl();
@@ -1153,31 +1444,33 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
     }
 
     @Override
-    public void onPreferredPaymentServiceChanged(int userId, ComponentName service) {
+    public void onPreferredPaymentServiceChanged(ComponentNameAndUser service) {
         Log.i(TAG, "onPreferredPaymentServiceChanged");
-        ComponentName oldPreferredService = mAidCache.getPreferredService().second;
-        mAidCache.onPreferredPaymentServiceChanged(userId, service);
-        mHostEmulationManager.onPreferredPaymentServiceChanged(userId, service);
-        ComponentName newPreferredService = mAidCache.getPreferredService().second;
+        ComponentNameAndUser oldPreferredService = mAidCache.getPreferredService();
+        mAidCache.onPreferredPaymentServiceChanged(service);
+        mHostEmulationManager.onPreferredPaymentServiceChanged(service);
+        ComponentNameAndUser newPreferredService = mAidCache.getPreferredService();
 
         NfcService.getInstance().onPreferredPaymentChanged(
                     NfcAdapter.PREFERRED_PAYMENT_CHANGED);
         if (!Objects.equals(oldPreferredService, newPreferredService)) {
-            updateForShouldDefaultToObserveMode(userId);
+            updateForShouldDefaultToObserveMode(newPreferredService.getUserId());
+            notifyPreferredServiceListeners(newPreferredService);
         }
     }
 
     @Override
-    public void onPreferredForegroundServiceChanged(int userId, ComponentName service) {
+    public void onPreferredForegroundServiceChanged(ComponentNameAndUser service) {
         Log.i(TAG, "onPreferredForegroundServiceChanged");
-        ComponentName oldPreferredService = mAidCache.getPreferredService().second;
-        mHostEmulationManager.onPreferredForegroundServiceChanged(userId, service);
-        ComponentName newPreferredService = mAidCache.getPreferredService().second;
+        ComponentNameAndUser oldPreferredService = mAidCache.getPreferredService();
+        mHostEmulationManager.onPreferredForegroundServiceChanged(service);
+        ComponentNameAndUser newPreferredService = mAidCache.getPreferredService();
 
         NfcService.getInstance().onPreferredPaymentChanged(
                 NfcAdapter.PREFERRED_PAYMENT_CHANGED);
         if (!Objects.equals(oldPreferredService, newPreferredService)) {
-            updateForShouldDefaultToObserveMode(userId);
+            updateForShouldDefaultToObserveMode(newPreferredService.getUserId());
+            notifyPreferredServiceListeners(newPreferredService);
         }
     }
 
@@ -1194,7 +1487,7 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
                 Log.e(TAG, "adapter is null, returning");
                 return;
             }
-            ComponentName preferredService = mAidCache.getPreferredService().second;
+            ComponentName preferredService = mAidCache.getPreferredService().getComponentName();
             boolean enableObserveMode = mServiceCache.doesServiceShouldDefaultToObserveMode(userId,
                     preferredService);
             mHostEmulationManager.updateForShouldDefaultToObserveMode(enableObserveMode);
@@ -1205,6 +1498,9 @@ public class CardEmulationManager implements RegisteredServicesCache.Callback,
 
     public void onObserveModeStateChange(boolean enabled) {
         mHostEmulationManager.onObserveModeStateChange(enabled);
+        if (android.nfc.Flags.nfcEventListener()) {
+            callNfcEventListeners(listener -> listener.onObserveModeStateChanged(enabled));
+        }
     }
 
     @Override
diff --git a/src/com/android/nfc/cardemulation/HostEmulationManager.java b/src/com/android/nfc/cardemulation/HostEmulationManager.java
index fdd7ebfc..741515bc 100644
--- a/src/com/android/nfc/cardemulation/HostEmulationManager.java
+++ b/src/com/android/nfc/cardemulation/HostEmulationManager.java
@@ -16,18 +16,22 @@
 
 package com.android.nfc.cardemulation;
 
-import android.annotation.TargetApi;
 import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.TargetApi;
+import android.annotation.UserIdInt;
 import android.app.ActivityManager;
 import android.app.KeyguardManager;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.ServiceConnection;
-import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
+import android.nfc.ComponentNameAndUser;
+import android.nfc.INfcOemExtensionCallback;
 import android.nfc.NfcAdapter;
+import android.nfc.OemLogItems;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
 import android.nfc.cardemulation.HostApduService;
@@ -72,7 +76,6 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Pattern;
 
-
 public class HostEmulationManager {
     static final String TAG = "HostEmulationManager";
     static final boolean DBG = NfcProperties.debug_enabled().orElse(true);
@@ -104,10 +107,10 @@ public class HostEmulationManager {
             NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_PAYMENT;
     static final int CE_HCE_OTHER =
             NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_OTHER;
-    static final String NFC_PACKAGE = "com.android.nfc";
     static final String DATA_KEY = "data";
     static final int FIELD_OFF_IDLE_DELAY_MS = 2000;
     static final int RE_ENABLE_OBSERVE_MODE_DELAY_MS = 2000;
+    static final int UNBIND_SERVICES_DELAY_MS = 10_000;
 
     final Context mContext;
     final RegisteredAidCache mAidCache;
@@ -119,14 +122,49 @@ public class HostEmulationManager {
 
     private final StatsdUtils mStatsdUtils;
 
+    INfcOemExtensionCallback mNfcOemExtensionCallback;
+
     // All variables below protected by mLock
 
     // Variables below are for a non-payment service,
     // that is typically only bound in the STATE_XFER state.
     Messenger mService;
+
+    static class HostEmulationConnection {
+        @UserIdInt int mUserId;
+        ComponentName mComponentName;
+        ServiceConnection mServiceConnection;
+        Messenger mMessenger;
+
+        HostEmulationConnection(@UserIdInt int userId,
+                                ComponentName componentName,
+                                ServiceConnection serviceConnection) {
+            this(userId, componentName, serviceConnection, null);
+        }
+
+        HostEmulationConnection(
+            @UserIdInt int userId,
+                ComponentName componentName,
+                ServiceConnection serviceConnection,
+                Messenger messenger) {
+            mUserId = userId;
+            mComponentName = componentName;
+            mServiceConnection = serviceConnection;
+            mMessenger = messenger;
+        }
+
+        @Override
+        public String toString() {
+            return "{" + mComponentName + "(" + mUserId + "): "
+                + mMessenger + ", " + mServiceConnection + "}";
+        }
+    }
+
+    Map<ComponentNameAndUser, HostEmulationConnection> mComponentNameToConnectionsMap =
+            new HashMap<>();
     boolean mServiceBound = false;
     ComponentName mServiceName = null;
-    int mServiceUserId; // The UserId of the non-payment service
+    @UserIdInt int mServiceUserId; // The UserId of the non-payment service
     ArrayList<PollingFrame> mPendingPollingLoopFrames = null;
     ArrayList<PollingFrame> mUnprocessedPollingFrames = null;
     Map<ComponentName, ArrayList<PollingFrame>> mPollingFramesToSend = null;
@@ -143,7 +181,7 @@ public class HostEmulationManager {
     boolean mEnableObserveModeAfterTransaction = false;
     boolean mEnableObserveModeOnFieldOff = false;
     ComponentName mPaymentServiceName = null;
-    int mPaymentServiceUserId; // The userId of the payment service
+    @UserIdInt int mPaymentServiceUserId; // The userId of the payment service
     ComponentName mLastBoundPaymentServiceName;
 
     // mActiveService denotes the service interface
@@ -152,7 +190,7 @@ public class HostEmulationManager {
     // On deactivation, mActiveService stops being valid.
     Messenger mActiveService;
     ComponentName mActiveServiceName;
-    int mActiveServiceUserId; // The UserId of the current active one
+    @UserIdInt int mActiveServiceUserId; // The UserId of the current active one
 
     String mLastSelectedAid;
     int mState;
@@ -180,6 +218,39 @@ public class HostEmulationManager {
         }
     };
 
+    Runnable mUnbindInactiveServicesRunnable =
+            new Runnable() {
+                @Override
+                public void run() {
+                    synchronized (mLock) {
+                        unbindInactiveServicesLocked();
+                    }
+                }
+
+                void unbindInactiveServicesLocked() {
+                    ComponentNameAndUser preferredNameAndUser = mAidCache.getPreferredService();
+                    Map<ComponentNameAndUser, HostEmulationConnection> retainedConnections =
+                            new HashMap<>();
+                    mComponentNameToConnectionsMap.keySet().forEach((key) -> {
+                        if (!preferredNameAndUser.equals(key)) {
+                            HostEmulationConnection connection =
+                                mComponentNameToConnectionsMap.get(key);
+                            if (connection.mMessenger != null) {
+                                try {
+                                    mContext.unbindService(connection.mServiceConnection);
+                                } catch (IllegalArgumentException iae) {
+                                    Log.wtf(TAG, "Exception while unbinding "
+                                        + key.getComponentName() + " service connection", iae);
+                                }
+                            }
+                        } else {
+                            retainedConnections.put(key, mComponentNameToConnectionsMap.get(key));
+                        }
+                    });
+                    mComponentNameToConnectionsMap = retainedConnections;
+                }
+            };
+
     // Runnable to re-enable observe mode after a transaction. This should be delayed after
     // HCE is deactivated to ensure we don't receive another select AID.
     Runnable mEnableObserveModeAfterTransactionRunnable = new Runnable() {
@@ -218,20 +289,28 @@ public class HostEmulationManager {
         mStatsdUtils = Flags.statsdCeEventsFlag() ? statsdUtils : null;
         mPollingLoopFilters = new HashMap<Integer, Map<String, List<ApduServiceInfo>>>();
         mPollingLoopPatternFilters = new HashMap<Integer, Map<Pattern, List<ApduServiceInfo>>>();
+        if (isMultipleBindingSupported()) {
+            mHandler.postDelayed(mUnbindInactiveServicesRunnable, UNBIND_SERVICES_DELAY_MS);
+        }
+    }
+
+    public void setOemExtension(@Nullable INfcOemExtensionCallback nfcOemExtensionCallback) {
+        mNfcOemExtensionCallback = nfcOemExtensionCallback;
     }
 
     /**
      *  Preferred payment service changed
      */
-    public void onPreferredPaymentServiceChanged(int userId, final ComponentName service) {
+    public void onPreferredPaymentServiceChanged(final ComponentNameAndUser service) {
         mHandler.post(() -> {
             synchronized (mLock) {
                 if (!isHostCardEmulationActivated()) {
                     Log.d(TAG, "onPreferredPaymentServiceChanged, resetting active service");
                     resetActiveService();
                 }
-                if (service != null) {
-                    bindPaymentServiceLocked(userId, service);
+
+                if (service != null && service.getComponentName() != null) {
+                    bindPaymentServiceLocked(service.getUserId(), service.getComponentName());
                 } else {
                     unbindPaymentServiceLocked();
                 }
@@ -248,10 +327,9 @@ public class HostEmulationManager {
     }
 
     private Pair<Messenger, ComponentName> getForegroundServiceAndNameOrDefault() {
-        Pair<Integer, ComponentName> preferredService = mAidCache.getPreferredService();
-        int preferredServiceUserId = preferredService.first != null ?
-                preferredService.first : -1;
-        ComponentName preferredServiceName = preferredService.second;
+        ComponentNameAndUser preferredService = mAidCache.getPreferredService();
+        int preferredServiceUserId = preferredService.getUserId();
+        ComponentName preferredServiceName = preferredService.getComponentName();
 
         if (preferredServiceName == null || preferredServiceUserId < 0) {
             return null;
@@ -278,7 +356,7 @@ public class HostEmulationManager {
 
     @TargetApi(35)
     @FlaggedApi(android.nfc.Flags.FLAG_NFC_READ_POLLING_LOOP)
-    public void updatePollingLoopFilters(int userId, List<ApduServiceInfo> services) {
+    public void updatePollingLoopFilters(@UserIdInt int userId, List<ApduServiceInfo> services) {
         HashMap<String, List<ApduServiceInfo>> pollingLoopFilters =
                 new HashMap<String, List<ApduServiceInfo>>();
         HashMap<Pattern, List<ApduServiceInfo>> pollingLoopPatternFilters =
@@ -306,19 +384,6 @@ public class HostEmulationManager {
 
     public void onObserveModeStateChange(boolean enabled) {
         synchronized(mLock) {
-            if (android.nfc.Flags.nfcEventListener()) {
-                Messenger service = getForegroundServiceOrDefault();
-                if (service != null) {
-                    Message msg = Message.obtain(null, HostApduService.MSG_OBSERVE_MODE_CHANGE);
-                    msg.arg1 = enabled ? 1 : 0;
-                    msg.replyTo = mMessenger;
-                    try {
-                        service.send(msg);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Remote service has died", e);
-                    }
-                }
-            }
             if (!enabled && mAutoDisableObserveModeRunnable != null) {
                 mHandler.removeCallbacks(mAutoDisableObserveModeRunnable);
                 mAutoDisableObserveModeRunnable = null;
@@ -412,12 +477,20 @@ public class HostEmulationManager {
         }
     }
 
+    void rescheduleInactivityChecks() {
+        mHandler.removeCallbacks(mReturnToIdleStateRunnable);
+        if (isMultipleBindingSupported()) {
+            mHandler.removeCallbacks(mUnbindInactiveServicesRunnable);
+            mHandler.postDelayed(mUnbindInactiveServicesRunnable, UNBIND_SERVICES_DELAY_MS);
+        }
+    }
+
     @TargetApi(35)
     @FlaggedApi(android.nfc.Flags.FLAG_NFC_READ_POLLING_LOOP)
     public void onPollingLoopDetected(List<PollingFrame> pollingFrames) {
         Log.d(TAG, "onPollingLoopDetected, size: " + pollingFrames.size());
         synchronized (mLock) {
-            mHandler.removeCallbacks(mReturnToIdleStateRunnable);
+            rescheduleInactivityChecks();
             // We need to have this check here in addition to the one in onFieldChangeDetected,
             // because we can receive an OFF frame after the field change is detected.
             if (!pollingFrames.isEmpty()
@@ -571,40 +644,12 @@ public class HostEmulationManager {
     /**
      *  Preferred foreground service changed
      */
-    public void onPreferredForegroundServiceChanged(int userId, ComponentName service) {
+    public void onPreferredForegroundServiceChanged(ComponentNameAndUser serviceAndUser) {
         synchronized (mLock) {
-            if (android.nfc.Flags.nfcEventListener()) {
-                Pair<Integer, ComponentName> oldServiceAndUser = mAidCache.getPreferredService();
-                Messenger oldPreferredService = null;
-                if (oldServiceAndUser != null && oldServiceAndUser.second != null) {
-                    if (mPaymentServiceName != null
-                        && mPaymentServiceName.equals(oldServiceAndUser.second)
-                        && mPaymentServiceUserId == oldServiceAndUser.first) {
-                        oldPreferredService = mPaymentService;
-                    } else if (mServiceName != null && mServiceName.equals(oldServiceAndUser.second)
-                            && mServiceUserId == oldServiceAndUser.first) {
-                        oldPreferredService = mService;
-                    } else {
-                        Log.w(TAG, oldServiceAndUser.second +
-                            " is no longer the preferred NFC service but isn't bound");
-                    }
-                    if (oldPreferredService != null) {
-                        Message msg =
-                        Message.obtain(null, HostApduService.MSG_PREFERRED_SERVICE_CHANGED);
-                        msg.arg1 = 0;
-                        msg.replyTo = mMessenger;
-                        try {
-                            oldPreferredService.send(msg);
-                        } catch (RemoteException e) {
-                            Log.e(TAG, "Remote service has died", e);
-                        }
-                    }
-                } else {
-                    Log.i(TAG, "old service is null");
-                }
-            }
+            int userId = serviceAndUser.getUserId();
+            ComponentName service = serviceAndUser.getComponentName();
 
-            mAidCache.onPreferredForegroundServiceChanged(userId, service);
+            mAidCache.onPreferredForegroundServiceChanged(serviceAndUser);
 
             if (!isHostCardEmulationActivated()) {
                 Log.d(TAG, "onPreferredForegroundServiceChanged, resetting active service");
@@ -619,7 +664,7 @@ public class HostEmulationManager {
      }
 
     public void onFieldChangeDetected(boolean fieldOn) {
-        mHandler.removeCallbacks(mReturnToIdleStateRunnable);
+        rescheduleInactivityChecks();
         if (!fieldOn) {
             mHandler.postDelayed(mReturnToIdleStateRunnable, FIELD_OFF_IDLE_DELAY_MS);
         }
@@ -633,11 +678,11 @@ public class HostEmulationManager {
     public void onHostEmulationActivated() {
         Log.d(TAG, "notifyHostEmulationActivated");
         synchronized (mLock) {
-            mHandler.removeCallbacks(mReturnToIdleStateRunnable);
+            rescheduleInactivityChecks();
             // Regardless of what happens, if we're having a tap again
             // activity up, close it
             Intent intent = new Intent(TapAgainDialog.ACTION_CLOSE);
-            intent.setPackage(NFC_PACKAGE);
+            intent.setPackage(NfcInjector.getInstance().getNfcPackageName());
             mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
             if (mState != STATE_IDLE && mState != STATE_POLLING_LOOP) {
                 Log.e(TAG, "Got activation event in non-idle state");
@@ -671,8 +716,8 @@ public class HostEmulationManager {
 
     public void onHostEmulationData(byte[] data) {
         Log.d(TAG, "notifyHostEmulationData");
-        mHandler.removeCallbacks(mReturnToIdleStateRunnable);
         mHandler.removeCallbacks(mEnableObserveModeAfterTransactionRunnable);
+        rescheduleInactivityChecks();
         String selectAid = findSelectAid(data);
         ComponentName resolvedService = null;
         ApduServiceInfo resolvedServiceInfo = null;
@@ -699,6 +744,9 @@ public class HostEmulationManager {
                           "Screen is off, sending AID_NOT_FOUND, but not triggering bug report");
                     } else {
                         Log.w(TAG, "Can't handle AID " + selectAid + " sending AID_NOT_FOUND");
+                        if (android.nfc.Flags.nfcEventListener()) {
+                            notifyAidNotRoutedListener(selectAid);
+                        }
                         if (mUnroutableAidBugReportRunnable != null) {
                             mUnroutableAidBugReportRunnable.addAid(selectAid);
                         } else {
@@ -733,10 +781,9 @@ public class HostEmulationManager {
                         mStatsdUtils.setCardEmulationEventCategory(resolveInfo.category);
                         mStatsdUtils.setCardEmulationEventUid(defaultServiceInfo.getUid());
                     }
-
                     if ((defaultServiceInfo.requiresUnlock()
                             || NfcService.getInstance().isSecureNfcEnabled())
-                          && mKeyguard.isKeyguardLocked()) {
+                          && NfcInjector.getInstance().isDeviceLocked()) {
                         NfcService.getInstance().sendRequireUnlockIntent();
                         NfcService.getInstance().sendData(AID_NOT_FOUND);
                         if (DBG) Log.d(TAG, "requiresUnlock()! show toast");
@@ -782,12 +829,15 @@ public class HostEmulationManager {
                     // Just ignore all future APDUs until we resolve to only one
                     mState = STATE_W4_DEACTIVATE;
                     NfcStatsLog.write(NfcStatsLog.NFC_AID_CONFLICT_OCCURRED, selectAid);
+                    if (android.nfc.Flags.nfcEventListener()) {
+                        notifyAidConflictListener(selectAid);
+                    }
                     if (mStatsdUtils != null) {
                         mStatsdUtils.setCardEmulationEventCategory(CardEmulation.CATEGORY_OTHER);
                         mStatsdUtils.logCardEmulationWrongSettingEvent();
                     }
-                    launchResolver((ArrayList<ApduServiceInfo>)resolveInfo.services, null,
-                            resolveInfo.category);
+                    launchResolver(selectAid, (ArrayList<ApduServiceInfo>)resolveInfo.services,
+                        null, resolveInfo.category);
                     return;
                 }
             }
@@ -804,7 +854,21 @@ public class HostEmulationManager {
                         Messenger existingService =
                                 bindServiceIfNeededLocked(user.getIdentifier(), resolvedService);
                         if (existingService != null) {
-                            Log.d(TAG, "Binding to existing service");
+                            Log.d(TAG, "Send data to existing service");
+                            NfcInjector.getInstance().getNfcEventLog().logEvent(
+                                    NfcEventProto.EventType.newBuilder()
+                                            .setCeRoutedAid(
+                                                NfcEventProto.NfcCeRoutedAid.newBuilder()
+                                                    .setAid(selectAid)
+                                                    .setComponentInfo(
+                                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                                            .setPackageName(
+                                                                resolvedService.getPackageName())
+                                                            .setClassName(
+                                                                resolvedService.getClassName())
+                                                            .build())
+                                                    .build())
+                                            .build());
                             sendDataToServiceLocked(existingService, data);
                         } else {
                             // Waiting for service to be bound
@@ -895,8 +959,8 @@ public class HostEmulationManager {
     public void onOffHostAidSelected() {
         Log.d(TAG, "notifyOffHostAidSelected");
         synchronized (mLock) {
-            mHandler.removeCallbacks(mReturnToIdleStateRunnable);
             mHandler.removeCallbacks(mEnableObserveModeAfterTransactionRunnable);
+            rescheduleInactivityChecks();
             if (mState != STATE_XFER || mActiveService == null) {
                 // Don't bother telling, we're not bound to any service yet
             } else {
@@ -912,22 +976,21 @@ public class HostEmulationManager {
 
             //close the TapAgainDialog
             Intent intent = new Intent(TapAgainDialog.ACTION_CLOSE);
-            intent.setPackage(NFC_PACKAGE);
+            intent.setPackage(NfcInjector.getInstance().getNfcPackageName());
             mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
         }
     }
 
-    Messenger bindServiceIfNeededLocked(int userId, ComponentName service) {
+    Messenger bindServiceIfNeededLocked(@UserIdInt int userId, ComponentName service) {
         if (service == null) {
             Log.e(TAG, "service ComponentName is null");
             return null;
         }
 
-        Pair<Integer, ComponentName> preferredPaymentService =
-                mAidCache.getPreferredPaymentService();
-        int preferredPaymentUserId = preferredPaymentService.first  != null ?
-                preferredPaymentService.first : -1;
-        ComponentName preferredPaymentServiceName = preferredPaymentService.second;
+        ComponentNameAndUser preferredPaymentService = mAidCache.getPreferredPaymentService();
+        int preferredPaymentUserId = preferredPaymentService.getUserId();
+        ComponentName preferredPaymentServiceName = preferredPaymentService.getComponentName();
+        ComponentNameAndUser newServiceAndUser = new ComponentNameAndUser(userId, service);
 
         if (mPaymentServiceName != null && mPaymentServiceName.equals(service)
                 && mPaymentServiceUserId == userId) {
@@ -939,10 +1002,17 @@ public class HostEmulationManager {
             Log.d(TAG, "Service should be bound as payment service but is not, binding now");
             bindPaymentServiceLocked(userId, preferredPaymentServiceName);
             return null;
-        } else if (mServiceName != null && mServiceName.equals(service)
+        } else if (!isMultipleBindingSupported()
+                && mServiceName != null
+                && mServiceName.equals(service)
                 && mServiceUserId == userId) {
             Log.d(TAG, "Service already bound as regular service.");
             return mService;
+        } else if (isMultipleBindingSupported()
+                && mComponentNameToConnectionsMap.containsKey(newServiceAndUser)
+                && mComponentNameToConnectionsMap.get(newServiceAndUser).mMessenger != null) {
+            Log.d(TAG, "Service" + service + " already bound as regular service.");
+            return mComponentNameToConnectionsMap.get(newServiceAndUser).mMessenger;
         } else {
             Log.d(TAG, "Binding to service " + service + " for userid:" + userId);
             if (mStatsdUtils != null) {
@@ -952,10 +1022,24 @@ public class HostEmulationManager {
             Intent aidIntent = new Intent(HostApduService.SERVICE_INTERFACE);
             aidIntent.setComponent(service);
             try {
-                mServiceBound = mContext.bindServiceAsUser(aidIntent, mConnection,
-                        Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS,
-                        UserHandle.of(userId));
-                if (!mServiceBound) {
+                ServiceConnection connection = mConnection;
+                if (isMultipleBindingSupported()) {
+                    connection = new HostEmulationServiceConnection(userId);
+                    mComponentNameToConnectionsMap.put(
+                        new ComponentNameAndUser(userId, service),
+                        new HostEmulationConnection(userId, service, connection));
+                }
+                boolean serviceBound =
+                        mContext.bindServiceAsUser(
+                                aidIntent,
+                                connection,
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS,
+                                UserHandle.of(userId));
+                if (!isMultipleBindingSupported()) {
+                    mServiceBound = serviceBound;
+                }
+                if (!serviceBound) {
                     Log.e(TAG, "Could not bind service.");
                 } else {
                     mServiceUserId = userId;
@@ -969,15 +1053,26 @@ public class HostEmulationManager {
 
     void sendDataToServiceLocked(Messenger service, byte[] data) {
         mState = STATE_XFER;
-        if (service != mActiveService) {
+        if (!Objects.equals(service, mActiveService)) {
             sendDeactivateToActiveServiceLocked(HostApduService.DEACTIVATION_DESELECTED);
             mActiveService = service;
             if (service.equals(mPaymentService)) {
                 mActiveServiceName = mPaymentServiceName;
                 mActiveServiceUserId = mPaymentServiceUserId;
             } else {
-                mActiveServiceName = mServiceName;
-                mActiveServiceUserId = mServiceUserId;
+                if (isMultipleBindingSupported()) {
+                    for (Map.Entry<ComponentNameAndUser, HostEmulationConnection> entry :
+                        mComponentNameToConnectionsMap.entrySet()) {
+                        if (service.equals(entry.getValue().mMessenger)) {
+                            mActiveServiceName = entry.getKey().getComponentName();
+                            mActiveServiceUserId = entry.getKey().getUserId();
+                            break;
+                        }
+                    }
+                } else {
+                    mActiveServiceName = mServiceName;
+                    mActiveServiceUserId = mServiceUserId;
+                }
             }
         }
         Message msg = Message.obtain(null, HostApduService.MSG_COMMAND_APDU);
@@ -986,16 +1081,26 @@ public class HostEmulationManager {
         msg.setData(dataBundle);
         msg.replyTo = mMessenger;
         try {
+            NfcService.getInstance().notifyOemLogEvent(new OemLogItems
+                    .Builder(OemLogItems.LOG_ACTION_HCE_DATA)
+                    .setApduCommand(data)
+                    .build());
             mActiveService.send(msg);
         } catch (RemoteException e) {
             Log.e(TAG, "Remote service " + mActiveServiceName + " has died, dropping APDU", e);
+            if (Objects.equals(mActiveService, mPaymentService)) {
+                Log.wtf(TAG, "Rebinding payment service", e);
+                bindPaymentServiceLocked(mPaymentServiceUserId, mLastBoundPaymentServiceName);
+            }
         }
     }
 
     void sendPollingFramesToServiceLocked(Messenger service,
             ArrayList<PollingFrame> pollingFrames) {
         if (!Objects.equals(service, mActiveService)) {
-            sendDeactivateToActiveServiceLocked(HostApduService.DEACTIVATION_DESELECTED);
+            if (!isMultipleBindingSupported()) {
+                sendDeactivateToActiveServiceLocked(HostApduService.DEACTIVATION_DESELECTED);
+            }
             mActiveService = service;
             if (service.equals(mPaymentService)) {
                 mActiveServiceName = mPaymentServiceName;
@@ -1019,6 +1124,10 @@ public class HostEmulationManager {
         } catch (RemoteException e) {
             Log.e(TAG, "Remote service " + mActiveServiceName + " has died, dropping frames", e);
             allowOneTransaction();
+            if (Objects.equals(mActiveService, mPaymentService)) {
+                Log.wtf(TAG, "Rebinding payment service", e);
+                bindPaymentServiceLocked(mPaymentServiceUserId, mLastBoundPaymentServiceName);
+            }
         }
     }
 
@@ -1034,21 +1143,14 @@ public class HostEmulationManager {
     }
 
     void unbindPaymentServiceLocked() {
-        if (android.nfc.Flags.nfcEventListener() &&
-            mPaymentService != null) {
-            Message msg = Message.obtain(null, HostApduService.MSG_PREFERRED_SERVICE_CHANGED);
-            msg.arg1 = 0;
-            msg.replyTo = mMessenger;
-            try {
-                mPaymentService.send(msg);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Remote service has died", e);
-            }
-        }
         Log.d(TAG, "Unbinding payment service");
         if (mPaymentServiceBound) {
             try {
                 mContext.unbindService(mPaymentConnection);
+                if (isMultipleBindingSupported()) {
+                    mComponentNameToConnectionsMap.remove(
+                        new ComponentNameAndUser(mPaymentServiceUserId, mPaymentServiceName));
+                }
             } catch (Exception e) {
                 Log.w(TAG, "Failed to unbind payment service: " + mPaymentServiceName, e);
             }
@@ -1060,19 +1162,24 @@ public class HostEmulationManager {
         mPaymentServiceUserId = -1;
     }
 
-    void bindPaymentServiceLocked(int userId, ComponentName service) {
+    void bindPaymentServiceLocked(@UserIdInt int userId, ComponentName serviceName) {
         unbindPaymentServiceLocked();
 
-        Log.d(TAG, "Binding to payment service " + service + " for userid:" + userId);
+        Log.d(TAG, "Binding to payment service " + serviceName + " for userid:" + userId);
         Intent intent = new Intent(HostApduService.SERVICE_INTERFACE);
-        intent.setComponent(service);
+        intent.setComponent(serviceName);
         try {
+            if (isMultipleBindingSupported()) {
+                mComponentNameToConnectionsMap.put(
+                        new ComponentNameAndUser(userId, serviceName),
+                        new HostEmulationConnection(userId, serviceName, mPaymentConnection));
+            }
             if (mContext.bindServiceAsUser(intent, mPaymentConnection,
                     Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS,
                     UserHandle.of(userId))) {
                 mPaymentServiceBound = true;
                 mPaymentServiceUserId = userId;
-                mLastBoundPaymentServiceName = service;
+                mLastBoundPaymentServiceName = serviceName;
             } else {
                 Log.e(TAG, "Could not bind (persistent) payment service.");
             }
@@ -1082,6 +1189,10 @@ public class HostEmulationManager {
     }
 
     void unbindServiceIfNeededLocked() {
+        if (isMultipleBindingSupported()) {
+            return;
+        }
+
         if (mServiceBound) {
             Log.d(TAG, "Unbinding from service " + mServiceName);
             try {
@@ -1098,6 +1209,14 @@ public class HostEmulationManager {
     }
 
     void launchTapAgain(ApduServiceInfo service, String category) {
+        if (mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onLaunchHceTapAgainActivity(service, category);
+                return;
+            } catch(RemoteException e){
+                Log.e(TAG, "onLaunchHceTapAgainActivity failed",e);
+            }
+        }
         Intent dialogIntent = new Intent(mContext, TapAgainDialog.class);
         dialogIntent.putExtra(TapAgainDialog.EXTRA_CATEGORY, category);
         dialogIntent.putExtra(TapAgainDialog.EXTRA_APDU_SERVICE, service);
@@ -1106,8 +1225,17 @@ public class HostEmulationManager {
                 UserHandle.getUserHandleForUid(service.getUid()));
     }
 
-    void launchResolver(ArrayList<ApduServiceInfo> services, ComponentName failedComponent,
-            String category) {
+    void launchResolver(String selectedAid, ArrayList<ApduServiceInfo> services,
+        ComponentName failedComponent, String category) {
+        if (mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onLaunchHceAppChooserActivity(
+                    selectedAid, services, failedComponent, category);
+                return;
+            }catch (RemoteException e){
+                Log.e(TAG, "onLaunchHceAppChooserActivity failed",e);
+            }
+        }
         Intent intent = new Intent(mContext, AppChooserActivity.class);
         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
         intent.putParcelableArrayListExtra(AppChooserActivity.EXTRA_APDU_SERVICES, services);
@@ -1142,6 +1270,34 @@ public class HostEmulationManager {
         return null;
     }
 
+    @FlaggedApi(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    interface NfcAidRoutingListener {
+        void onAidConflict(@NonNull String aid);
+        void onAidNotRouted(@NonNull String aid);
+    }
+
+    @Nullable
+    private NfcAidRoutingListener mAidRoutingListener = null;
+
+    @FlaggedApi(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    void setAidRoutingListener(@Nullable NfcAidRoutingListener listener) {
+        mAidRoutingListener = listener;
+    }
+
+    @FlaggedApi(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    private void notifyAidConflictListener(String aid) {
+        if (mAidRoutingListener != null && aid != null) {
+            mAidRoutingListener.onAidConflict(aid);
+        }
+    }
+
+    @FlaggedApi(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    private void notifyAidNotRoutedListener(String aid) {
+        if (mAidRoutingListener != null && aid != null) {
+            mAidRoutingListener.onAidNotRouted(aid);
+        }
+    }
+
     private void returnToIdleStateLocked() {
         mPendingPollingLoopFrames = null;
         mPollingFramesToSend = null;
@@ -1160,92 +1316,166 @@ public class HostEmulationManager {
     private ServiceConnection mPaymentConnection = new ServiceConnection() {
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
+            ComponentName paymentServiceName = new ComponentName("", "");
             synchronized (mLock) {
                 /* Preferred Payment Service has been changed. */
                 if (!mLastBoundPaymentServiceName.equals(name)) {
                     Log.i(TAG, "Ignoring bound payment service, " + name + " != "
-                            + mLastBoundPaymentServiceName);
+                    + mLastBoundPaymentServiceName);
                     return;
                 }
                 mPaymentServiceName = name;
                 mPaymentService = new Messenger(service);
-                Log.i(TAG, "Payment service bound: " + name);
-                if (android.nfc.Flags.nfcEventListener() &&
-                    mPaymentService != null) {
-                    Message msg =
-                        Message.obtain(null, HostApduService.MSG_PREFERRED_SERVICE_CHANGED);
-                    msg.arg1 = 1;
-                    msg.replyTo = mMessenger;
-                    try {
-                        mPaymentService.send(msg);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Remote service has died", e);
+                paymentServiceName = mPaymentServiceName;
+                if (isMultipleBindingSupported()) {
+                    if (mComponentNameToConnectionsMap.containsKey(
+                        new ComponentNameAndUser(mPaymentServiceUserId, name))) {
+                            mComponentNameToConnectionsMap.get(
+                            new ComponentNameAndUser(mPaymentServiceUserId, name)).mMessenger =
+                            mPaymentService;
+                    } else {
+                        mComponentNameToConnectionsMap.put(
+                            new ComponentNameAndUser(mPaymentServiceUserId, name),
+                            new HostEmulationConnection(mPaymentServiceUserId, name,
+                                    this, mPaymentService));
                     }
                 }
+                Log.i(TAG, "Payment service bound: " + name);
             }
+            NfcInjector.getInstance().getNfcEventLog().logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPaymentServiceBindState(
+                                NfcEventProto.NfcPaymentServiceBindState.newBuilder()
+                                    .setBindState(NfcEventProto.BindState.SERVICE_CONNECTED)
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                paymentServiceName.getPackageName())
+                                            .setClassName(
+                                                paymentServiceName.getClassName())
+                                            .build())
+                                    .build())
+                            .build());
         }
 
         @Override
         public void onServiceDisconnected(ComponentName name) {
             Log.i(TAG, "Payment service disconnected: " + name);
+            ComponentName paymentServiceName = new ComponentName("", "");
             synchronized (mLock) {
+                if (isMultipleBindingSupported()) {
+                    ComponentNameAndUser nameAndUser =
+                            new ComponentNameAndUser(mPaymentServiceUserId, name);
+                    mComponentNameToConnectionsMap.remove(nameAndUser);
+                }
+                paymentServiceName = mPaymentServiceName;
                 mPaymentService = null;
                 mPaymentServiceName = null;
             }
+            NfcInjector.getInstance().getNfcEventLog().logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPaymentServiceBindState(
+                                NfcEventProto.NfcPaymentServiceBindState.newBuilder()
+                                    .setBindState(NfcEventProto.BindState.SERVICE_DISCONNECTED)
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                paymentServiceName.getPackageName())
+                                            .setClassName(
+                                                paymentServiceName.getClassName())
+                                            .build())
+                                    .build())
+                            .build());
         }
 
         @Override
         public void onBindingDied(ComponentName name) {
             Log.i(TAG, "Payment service died: " + name);
+            ComponentName paymentServiceName = new ComponentName("", "");
             synchronized (mLock) {
+                if (mPaymentServiceName != null) paymentServiceName = mPaymentServiceName;
                 if (mPaymentServiceUserId >= 0) {
                     bindPaymentServiceLocked(mPaymentServiceUserId, mLastBoundPaymentServiceName);
                 }
             }
+            NfcInjector.getInstance().getNfcEventLog().logEvent(
+                    NfcEventProto.EventType.newBuilder()
+                            .setPaymentServiceBindState(
+                                NfcEventProto.NfcPaymentServiceBindState.newBuilder()
+                                    .setBindState(NfcEventProto.BindState.SERVICE_BINDING_DIED)
+                                    .setComponentInfo(
+                                        NfcEventProto.NfcComponentInfo.newBuilder()
+                                            .setPackageName(
+                                                paymentServiceName.getPackageName())
+                                            .setClassName(
+                                                paymentServiceName.getClassName())
+                                            .build())
+                                    .build())
+                            .build());
         }
     };
 
-    private ServiceConnection mConnection = new ServiceConnection() {
+    class HostEmulationServiceConnection implements ServiceConnection {
+        @UserIdInt int mUserId;
+
+        HostEmulationServiceConnection(@UserIdInt int userId) {
+            mUserId = userId;
+        }
+
         @Override
         public void onServiceConnected(ComponentName name, IBinder service) {
             synchronized (mLock) {
-                Pair<Integer, ComponentName> preferredUserAndService =
-                    mAidCache.getPreferredService();
+                ComponentNameAndUser preferredUserAndService = mAidCache.getPreferredService();
                 ComponentName preferredServiceName =
-                    preferredUserAndService == null ? null : preferredUserAndService.second;
+                        preferredUserAndService == null ? null :
+                                preferredUserAndService.getComponentName();
                 /* Service is already deactivated and not preferred, don't bind */
                 if (mState == STATE_IDLE && !name.equals(preferredServiceName)) {
-                  return;
+                    return;
                 }
-                mService = new Messenger(service);
-                mServiceName = name;
-                mServiceBound = true;
-                Log.d(TAG, "Service bound: " + name);
-                if (android.nfc.Flags.nfcEventListener() &&
-                    name.equals(preferredServiceName) &&
-                    mService != null) {
-                    Message msg =
-                        Message.obtain(null, HostApduService.MSG_PREFERRED_SERVICE_CHANGED);
-                    msg.arg1 = 1;
-                    msg.replyTo = mMessenger;
-                    try {
-                        mService.send(msg);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Remote service has died", e);
+                Messenger messenger = new Messenger(service);
+                if (isMultipleBindingSupported()) {
+                    ComponentNameAndUser key = new ComponentNameAndUser(mUserId, name);
+                    if (mComponentNameToConnectionsMap.containsKey(key)) {
+                        mComponentNameToConnectionsMap.get(key).mMessenger = messenger;
+                    } else {
+                        mComponentNameToConnectionsMap.put(key,
+                            new HostEmulationConnection(mUserId, name, this, messenger));
                     }
+                } else {
+                    mService = messenger;
+                    mServiceName = name;
+                    mServiceBound = true;
                 }
+
+                Log.d(TAG, "Service bound: " + name);
                 // Send pending select APDU
                 if (mSelectApdu != null) {
                     if (mStatsdUtils != null) {
                         mStatsdUtils.notifyCardEmulationEventServiceBound();
                     }
-                    sendDataToServiceLocked(mService, mSelectApdu);
+                    NfcInjector.getInstance().getNfcEventLog().logEvent(
+                            NfcEventProto.EventType.newBuilder()
+                                    .setCeRoutedAid(
+                                        NfcEventProto.NfcCeRoutedAid.newBuilder()
+                                            .setAid(mLastSelectedAid == null
+                                                        ? "" : mLastSelectedAid)
+                                            .setComponentInfo(
+                                                NfcEventProto.NfcComponentInfo.newBuilder()
+                                                    .setPackageName(
+                                                        name.getPackageName())
+                                                    .setClassName(
+                                                        name.getClassName())
+                                                    .build())
+                                            .build())
+                                    .build());
+                    sendDataToServiceLocked(messenger, mSelectApdu);
                     mSelectApdu = null;
                 } else if (mPollingFramesToSend != null && mPollingFramesToSend.containsKey(name)) {
-                    sendPollingFramesToServiceLocked(mService, mPollingFramesToSend.get(name));
+                    sendPollingFramesToServiceLocked(messenger, mPollingFramesToSend.get(name));
                     mPollingFramesToSend.remove(name);
                     if (android.nfc.Flags.nfcReadPollingLoop()
-                        && mUnprocessedPollingFrames != null) {
+                            && mUnprocessedPollingFrames != null) {
                         ArrayList unprocessedPollingFrames = mUnprocessedPollingFrames;
                         mUnprocessedPollingFrames = null;
                         onPollingLoopDetected(unprocessedPollingFrames);
@@ -1260,13 +1490,21 @@ public class HostEmulationManager {
         public void onServiceDisconnected(ComponentName name) {
             synchronized (mLock) {
                 Log.d(TAG, "Service unbound: " + name);
-                mService = null;
-                mServiceName = null;
-                mServiceBound = false;
+                if (isMultipleBindingSupported()) {
+                    ComponentNameAndUser nameAndUser = new ComponentNameAndUser(mUserId, name);
+                    mComponentNameToConnectionsMap.remove(nameAndUser);
+                } else {
+                    mService = null;
+                    mServiceName = null;
+                    mServiceBound = false;
+                }
             }
         }
     };
 
+    private ServiceConnection mConnection =
+        new HostEmulationServiceConnection(UserHandle.CURRENT.getIdentifier());
+
     class MessageHandler extends Handler {
         @Override
         public void handleMessage(Message msg) {
@@ -1306,11 +1544,15 @@ public class HostEmulationManager {
                 synchronized (mLock) {
                     Log.d(TAG, "Received MSG_UNHANDLED");
                     AidResolveInfo resolveInfo = mAidCache.resolveAid(mLastSelectedAid);
-                    boolean isPayment = false;
+
                     if (resolveInfo.services.size() > 0) {
                         NfcStatsLog.write(NfcStatsLog.NFC_AID_CONFLICT_OCCURRED, mLastSelectedAid);
-                        launchResolver((ArrayList<ApduServiceInfo>)resolveInfo.services,
-                                mActiveServiceName, resolveInfo.category);
+                        if (android.nfc.Flags.nfcEventListener()) {
+                            notifyAidConflictListener(mLastSelectedAid);
+                        }
+                        launchResolver(mLastSelectedAid,
+                            (ArrayList<ApduServiceInfo>)resolveInfo.services,
+                            mActiveServiceName, resolveInfo.category);
                     }
                 }
             }
@@ -1334,7 +1576,13 @@ public class HostEmulationManager {
         if (mPaymentServiceBound) {
             pw.println("    payment: " + mPaymentServiceName);
         }
-        if (mServiceBound) {
+        if (isMultipleBindingSupported() && !mComponentNameToConnectionsMap.isEmpty()) {
+            pw.println("    others: ");
+            for (Map.Entry<ComponentNameAndUser, HostEmulationConnection> entry :
+               mComponentNameToConnectionsMap.entrySet()) {
+                pw.println("            " + entry.getKey());
+            }
+        } else if (mServiceBound) {
             pw.println("    other: " + mServiceName);
         }
     }
@@ -1353,12 +1601,17 @@ public class HostEmulationManager {
             Utils.dumpDebugComponentName(
                     mPaymentServiceName, proto, HostEmulationManagerProto.PAYMENT_SERVICE_NAME);
         }
+        // TODO make this a repeated field and return all the services
         if (mServiceBound) {
             Utils.dumpDebugComponentName(
                     mServiceName, proto, HostEmulationManagerProto.SERVICE_NAME);
         }
     }
 
+    boolean isMultipleBindingSupported() {
+        return Flags.allowMultipleHceBindings();
+    }
+
     @VisibleForTesting
     public int getState(){
         return mState;
@@ -1393,8 +1646,13 @@ public class HostEmulationManager {
     }
 
     @VisibleForTesting
-    public Boolean isServiceBounded(){
-        return mServiceBound;
+    public Boolean isServiceBounded(@UserIdInt int userId, ComponentName componentName) {
+        if (isMultipleBindingSupported()) {
+            return mComponentNameToConnectionsMap.containsKey(
+                    new ComponentNameAndUser(userId, componentName));
+        } else {
+            return mServiceBound;
+        }
     }
 
     @VisibleForTesting
diff --git a/src/com/android/nfc/cardemulation/PreferredServices.java b/src/com/android/nfc/cardemulation/PreferredServices.java
index b0bc6b35..c470575a 100644
--- a/src/com/android/nfc/cardemulation/PreferredServices.java
+++ b/src/com/android/nfc/cardemulation/PreferredServices.java
@@ -21,6 +21,7 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.database.ContentObserver;
 import android.net.Uri;
+import android.nfc.ComponentNameAndUser;
 import android.nfc.Constants;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
@@ -108,11 +109,11 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
         /**
          * Notify when preferred payment service is changed
          */
-        void onPreferredPaymentServiceChanged(int userId, ComponentName service);
+        void onPreferredPaymentServiceChanged(ComponentNameAndUser service);
         /**
          * Notify when preferred foreground service is changed
          */
-        void onPreferredForegroundServiceChanged(int userId, ComponentName service);
+        void onPreferredForegroundServiceChanged(ComponentNameAndUser service);
     }
 
     public PreferredServices(Context context, RegisteredServicesCache serviceCache,
@@ -165,7 +166,8 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
     public void onWalletRoleHolderChanged(String defaultWalletHolderPackageName, int userId) {
         if (defaultWalletHolderPackageName == null) {
             mDefaultWalletHolderPaymentService = null;
-            mCallback.onPreferredPaymentServiceChanged(userId, null);
+            mUserIdDefaultWalletHolder = userId;
+            mCallback.onPreferredPaymentServiceChanged(new ComponentNameAndUser(userId, null));
             return;
         }
         List<ApduServiceInfo> serviceInfos = mServiceCache.getInstalledServices(userId);
@@ -188,13 +190,14 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
                 }
             }
         }
-        mUserIdDefaultWalletHolder = userId;
         ComponentName candidate = !roleHolderPaymentServices.isEmpty()
                 ? roleHolderPaymentServices.get(0) : null;
-        if (!Objects.equals(candidate, mDefaultWalletHolderPaymentService)) {
-            mCallback.onPreferredPaymentServiceChanged(userId, candidate);
+        if (!Objects.equals(candidate, mDefaultWalletHolderPaymentService) ||
+                userId != mUserIdDefaultWalletHolder) {
+            mDefaultWalletHolderPaymentService = candidate;
+            mUserIdDefaultWalletHolder = userId;
+            mCallback.onPreferredPaymentServiceChanged(new ComponentNameAndUser(userId, candidate));
         }
-        mDefaultWalletHolderPaymentService = candidate;
     }
 
     void loadDefaultsFromSettings(int userId, boolean force) {
@@ -216,7 +219,7 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
                         mContext.createContextAsUser(uh, 0).getContentResolver(),
                         Constants.SETTINGS_SECURE_NFC_PAYMENT_DEFAULT_COMPONENT);
             } catch (IllegalStateException e) {
-                Log.d(TAG, "Fail to get PackageManager for user: " + uh);
+                Log.d(TAG, "Fail to get default payment component for user: " + uh);
                 continue;
             }
 
@@ -267,7 +270,8 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
         }
         // Notify if anything changed
         if (!mWalletRoleObserver.isWalletRoleFeatureEnabled() && (paymentDefaultChanged || force)) {
-            mCallback.onPreferredPaymentServiceChanged(newUser.getIdentifier(), newDefault);
+            mCallback.onPreferredPaymentServiceChanged(
+                    new ComponentNameAndUser(newUser.getIdentifier(), newDefault));
         }
         if (paymentPreferForegroundChanged || force) {
             computePreferredForegroundService();
@@ -302,7 +306,8 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
         }
         // Notify if anything changed
         if (changed) {
-            mCallback.onPreferredForegroundServiceChanged(preferredServiceUserId, preferredService);
+            mCallback.onPreferredForegroundServiceChanged(
+                    new ComponentNameAndUser(preferredServiceUserId, preferredService));
         }
     }
 
@@ -413,7 +418,7 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
                     mForegroundUid = callingUid;
                     success = true;
                 } else {
-                    Log.e(TAG, "Calling UID is not in the foreground, ignorning!");
+                    Log.e(TAG, "Calling UID is not in the foreground, ignoring!");
                     success = false;
                 }
             } else {
@@ -446,7 +451,7 @@ public class PreferredServices implements com.android.nfc.ForegroundUtils.Callba
         if (mForegroundUtils.isInForeground(callingUid)) {
             return unregisterForegroundService(callingUid);
         } else {
-            Log.e(TAG, "Calling UID is not in the foreground, ignorning!");
+            Log.e(TAG, "Calling UID is not in the foreground, ignoring!");
             return false;
         }
     }
diff --git a/src/com/android/nfc/cardemulation/RegisteredAidCache.java b/src/com/android/nfc/cardemulation/RegisteredAidCache.java
index 538bff5c..48c6a8ec 100644
--- a/src/com/android/nfc/cardemulation/RegisteredAidCache.java
+++ b/src/com/android/nfc/cardemulation/RegisteredAidCache.java
@@ -16,25 +16,28 @@
 
 package com.android.nfc.cardemulation;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.TargetApi;
-import android.annotation.FlaggedApi;
 import android.app.ActivityManager;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.pm.PackageManager;
+import android.nfc.ComponentNameAndUser;
+import android.nfc.Flags;
+import android.nfc.INfcOemExtensionCallback;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
 import android.nfc.cardemulation.Utils;
+import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.sysprop.NfcProperties;
 import android.util.Log;
-import android.util.Pair;
 import android.util.proto.ProtoOutputStream;
 
-import com.android.nfc.NfcService;
-
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.nfc.NfcService;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -47,10 +50,12 @@ import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.PriorityQueue;
+import java.util.Set;
 import java.util.TreeMap;
 
 public class RegisteredAidCache {
     static final String TAG = "RegisteredAidCache";
+    private INfcOemExtensionCallback mNfcOemExtensionCallback;
 
     static final boolean DBG = NfcProperties.debug_enabled().orElse(true);
     private static final boolean VDBG = false; // turn on for local testing.
@@ -171,6 +176,8 @@ public class RegisteredAidCache {
     boolean mSupportsSubset = false;
     boolean mRequiresScreenOnServiceExist = false;
 
+    Set<ApduServiceInfo> mAssociatedRoleServices = new HashSet<>();
+
     public RegisteredAidCache(Context context, WalletRoleObserver walletRoleObserver) {
         this(context, walletRoleObserver, new AidRoutingManager());
     }
@@ -294,8 +301,7 @@ public class RegisteredAidCache {
                     userId == mUserIdPreferredForegroundService) {
                 matchedForeground = serviceInfo;
             } else if(mWalletRoleObserver.isWalletRoleFeatureEnabled()) {
-                if (userId == mUserIdDefaultWalletHolder &&
-                        componentName.getPackageName().equals(mDefaultWalletHolderPackageName)) {
+                if (isDefaultOrAssociatedWalletService(serviceInfo, userId)) {
                     roleHolderServices.add(serviceInfo);
                 }
             } else if (componentName.equals(mPreferredPaymentService) &&
@@ -360,6 +366,51 @@ public class RegisteredAidCache {
         }
     }
 
+    private boolean isDefaultOrAssociatedWalletService(ApduServiceInfo serviceInfo, int userId) {
+        synchronized (mLock) {
+            if (userId != mUserIdDefaultWalletHolder) {
+                return false;
+            }
+
+            if (serviceInfo.getComponent().getPackageName().equals(
+                    mDefaultWalletHolderPackageName)) {
+                return true;
+            }
+
+            if (Flags.nfcAssociatedRoleServices()) {
+                for (ApduServiceInfo associatedService : mAssociatedRoleServices) {
+                    if (associatedService.getComponent().equals(serviceInfo.getComponent())) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
+    private boolean isDefaultOrAssociatedWalletPackage(String packageName, int userId) {
+        synchronized (mLock) {
+            if (userId != mUserIdDefaultWalletHolder) {
+                return false;
+            }
+
+            if (packageName.equals(mDefaultWalletHolderPackageName)) {
+                return true;
+            }
+
+            if (Flags.nfcAssociatedRoleServices()) {
+                for (ApduServiceInfo associatedService : mAssociatedRoleServices) {
+                    if (associatedService.getComponent().getPackageName().equals(packageName)) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
     /**
      * Resolves a conflict between multiple services handling the same
      * AIDs. Note that the AID itself is not an input to the decision
@@ -402,9 +453,7 @@ public class RegisteredAidCache {
                 }
                 matchedForeground = serviceAidInfo.service;
             } else if(mWalletRoleObserver.isWalletRoleFeatureEnabled()) {
-                if(userId == mUserIdDefaultWalletHolder
-                    && componentName.getPackageName().equals(
-                    mDefaultWalletHolderPackageName)) {
+                if (isDefaultOrAssociatedWalletService(serviceAidInfo.service, userId)) {
                     if (VDBG) Log.d(TAG, "Prioritizing default wallet services.");
 
                     if (serviceClaimsPaymentAid ||
@@ -488,8 +537,7 @@ public class RegisteredAidCache {
                     userId == mUserIdPreferredForegroundService) {
                 defaultServiceInfo.foregroundDefault = serviceAidInfo;
             } else if(mWalletRoleObserver.isWalletRoleFeatureEnabled()) {
-                if(userId == mUserIdDefaultWalletHolder && componentName
-                        .getPackageName().equals(mDefaultWalletHolderPackageName)) {
+                if (isDefaultOrAssociatedWalletService(serviceAidInfo.service, userId)) {
                     defaultServiceInfo.walletDefaults.add(serviceAidInfo);
                 }
             }else if (componentName.equals(mPreferredPaymentService) &&
@@ -1071,6 +1119,10 @@ public class RegisteredAidCache {
         return power;
     }
 
+    public void setOemExtension(INfcOemExtensionCallback nfcOemExtensionCallback) {
+        mNfcOemExtensionCallback = nfcOemExtensionCallback;
+    }
+
     void updateRoutingLocked(boolean force) {
         if (!mNfcEnabled) {
             if (DBG) Log.d(TAG, "Not updating routing table because NFC is off.");
@@ -1192,7 +1244,14 @@ public class RegisteredAidCache {
             }
         }
         mRequiresScreenOnServiceExist = requiresScreenOnServiceExist;
-        mRoutingManager.configureRouting(routingEntries, force);
+        boolean isBufferFull = mRoutingManager.configureRouting(routingEntries, force);
+        if (isBufferFull && mNfcOemExtensionCallback != null) {
+            try {
+                mNfcOemExtensionCallback.onRoutingTableFull();
+            } catch (RemoteException exception) {
+                Log.e(TAG, "Error in onLaunchRoutingTableFullDialog: " + exception);
+            }
+        }
     }
 
     public void onServicesUpdated(int userId, List<ApduServiceInfo> services) {
@@ -1200,25 +1259,26 @@ public class RegisteredAidCache {
         synchronized (mLock) {
             generateUserApduServiceInfoLocked(userId, services);
             // Rebuild our internal data-structures
+            generateAssociatedRoleServicesLocked(userId);
             generateServiceMapLocked(services);
             generateAidCacheLocked();
         }
     }
 
-    public void onPreferredPaymentServiceChanged(int userId, ComponentName service) {
-        if (DBG) Log.d(TAG, "Preferred payment service changed for user:" + userId);
+    public void onPreferredPaymentServiceChanged(ComponentNameAndUser service) {
+        if (DBG) Log.d(TAG, "Preferred payment service changed for user:" + service.getUserId());
         synchronized (mLock) {
-            mPreferredPaymentService = service;
-            mUserIdPreferredPaymentService = userId;
+            mPreferredPaymentService = service.getComponentName();
+            mUserIdPreferredPaymentService = service.getUserId();
             generateAidCacheLocked();
         }
     }
 
-    public void onPreferredForegroundServiceChanged(int userId, ComponentName service) {
-        if (DBG) Log.d(TAG, "Preferred foreground service changed for user:" + userId);
+    public void onPreferredForegroundServiceChanged(ComponentNameAndUser service) {
+        if (DBG) Log.d(TAG, "Preferred foreground service changed for user:" + service.getUserId());
         synchronized (mLock) {
-            mPreferredForegroundService = service;
-            mUserIdPreferredForegroundService = userId;
+            mPreferredForegroundService = service.getComponentName();
+            mUserIdPreferredForegroundService = service.getUserId();
             generateAidCacheLocked();
         }
     }
@@ -1228,15 +1288,59 @@ public class RegisteredAidCache {
         synchronized (mLock) {
             mDefaultWalletHolderPackageName = defaultWalletHolderPackageName;
             mUserIdDefaultWalletHolder = userId;
+            generateAssociatedRoleServicesLocked(userId);
             generateAidCacheLocked();
         }
     }
 
+    private void generateAssociatedRoleServicesLocked(int userId) {
+        if (!Flags.nfcAssociatedRoleServices()) {
+            return;
+        }
+
+        mAssociatedRoleServices.clear();
+
+        if (mDefaultWalletHolderPackageName == null || userId != mUserIdDefaultWalletHolder) {
+            return;
+        }
+
+        List<ApduServiceInfo> apduServices = mUserApduServiceInfo.get(userId);
+        if (apduServices == null) {
+            return;
+        }
+
+        PackageManager pm = mContext.getPackageManager();
+
+        try {
+            PackageManager.Property prop = pm.getProperty(
+                    CardEmulation.PROPERTY_ALLOW_SHARED_ROLE_PRIORITY,
+                    mDefaultWalletHolderPackageName);
+            if (!prop.getBoolean()) {
+                return;
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            // Role owner does not want to share priority with anyone else
+            return;
+        }
+
+        for (ApduServiceInfo service : apduServices) {
+            if (service.getComponent().getPackageName().equals(mDefaultWalletHolderPackageName)) {
+                continue;
+            }
+
+            if (service.shareRolePriority() && pm.checkSignatures(mDefaultWalletHolderPackageName,
+                    service.getComponent().getPackageName()) == PackageManager.SIGNATURE_MATCH) {
+                mAssociatedRoleServices.add(service);
+            }
+        }
+    }
+
     @NonNull
-    public Pair<Integer, ComponentName> getPreferredService() {
+    public ComponentNameAndUser getPreferredService() {
         if (mPreferredForegroundService != null) {
             // return current foreground service
-            return new Pair<>(mUserIdPreferredForegroundService, mPreferredForegroundService);
+            return new ComponentNameAndUser(
+                    mUserIdPreferredForegroundService, mPreferredForegroundService);
         } else {
             // return current preferred service
             return getPreferredPaymentService();
@@ -1244,8 +1348,8 @@ public class RegisteredAidCache {
     }
 
     @NonNull
-    public Pair<Integer, ComponentName> getPreferredPaymentService() {
-         return new Pair<>(mUserIdPreferredPaymentService, mPreferredPaymentService);
+    public ComponentNameAndUser getPreferredPaymentService() {
+         return new ComponentNameAndUser(mUserIdPreferredPaymentService, mPreferredPaymentService);
     }
 
     public boolean isPreferredServicePackageNameForUser(String packageName, int userId) {
@@ -1260,9 +1364,7 @@ public class RegisteredAidCache {
                 return false;
             }
         } else if(mWalletRoleObserver.isWalletRoleFeatureEnabled()) {
-            if (mDefaultWalletHolderPackageName != null &&
-                mDefaultWalletHolderPackageName.equals(packageName) &&
-                userId == mUserIdDefaultWalletHolder) {
+            if (isDefaultOrAssociatedWalletPackage(packageName, userId)) {
                 return true;
             } else {
                 Log.i(TAG, "NfcService:" + packageName + "(" + userId
@@ -1337,6 +1439,12 @@ public class RegisteredAidCache {
         pw.println("    UserId: " + mUserIdPreferredForegroundService);
         pw.println("    Preferred payment service: " + mPreferredPaymentService);
         pw.println("    UserId: " + mUserIdPreferredPaymentService);
+        if (Flags.nfcAssociatedRoleServices()) {
+            pw.println("    Wallet role userId: " + mUserIdDefaultWalletHolder);
+            pw.println("    Wallet role package: " + mDefaultWalletHolderPackageName);
+            pw.println("    Associated role services: " + mAssociatedRoleServices.stream()
+                    .map(service -> service.getComponent().toString()).toList());
+        }
         pw.println("");
         mRoutingManager.dump(fd, pw, args);
         pw.println("");
diff --git a/src/com/android/nfc/cardemulation/RegisteredServicesCache.java b/src/com/android/nfc/cardemulation/RegisteredServicesCache.java
index 93770932..f2d88dbf 100644
--- a/src/com/android/nfc/cardemulation/RegisteredServicesCache.java
+++ b/src/com/android/nfc/cardemulation/RegisteredServicesCache.java
@@ -16,6 +16,11 @@
 
 package com.android.nfc.cardemulation;
 
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_FAILURE_ALREADY_SET;
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_FAILURE_INVALID_SERVICE;
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_FAILURE_UNKNOWN_ERROR;
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_OK;
+
 import android.annotation.TargetApi;
 import android.annotation.FlaggedApi;
 import android.app.ActivityManager;
@@ -50,7 +55,9 @@ import androidx.annotation.VisibleForTesting;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.util.FastXmlSerializer;
+import com.android.nfc.NfcInjector;
 import com.android.nfc.Utils;
+import com.android.nfc.cardemulation.util.NfcFileUtils;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
@@ -58,20 +65,23 @@ import org.xmlpull.v1.XmlSerializer;
 
 import java.io.File;
 import java.io.FileDescriptor;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Pattern;
 
 /**
  * This class is inspired by android.content.pm.RegisteredServicesCache
@@ -102,8 +112,8 @@ public class RegisteredServicesCache {
     // mUserServices holds the card emulation services that are running for each user
     final SparseArray<UserServices> mUserServices = new SparseArray<UserServices>();
     final Callback mCallback;
-    final SettingsFile mDynamicSettingsFile;
-    final SettingsFile mOthersFile;
+    SettingsFile mDynamicSettingsFile;
+    SettingsFile mOthersFile;
     final ServiceParser mServiceParser;
     final RoutingOptionManager mRoutingOptionManager;
 
@@ -120,6 +130,8 @@ public class RegisteredServicesCache {
 
     static class DynamicSettings {
         public final int uid;
+        public final Map<String, Boolean> pollingLoopFilters = new HashMap<>();
+        public final Map<String, Boolean> pollingLoopPatternFilters = new HashMap<>();
         public final HashMap<String, AidGroup> aidGroups = new HashMap<>();
         public String offHostSE;
         public String shouldDefaultToObserveModeStr;
@@ -337,6 +349,30 @@ public class RegisteredServicesCache {
         }
     }
 
+    void migrateFromCe(Context ceContext) {
+        File ceFilesDir = ceContext.getFilesDir();
+        File deFilesDir = mContext.getFilesDir();
+        if (NfcFileUtils.isEmptyDir(ceFilesDir)) {
+            Log.d(TAG, "Nothing to migrate from CE data");
+            return;
+        }
+        if (NfcFileUtils.moveFiles(ceFilesDir, deFilesDir) < 0) {
+            Log.e(TAG, "Failed to move directory from " + ceFilesDir + " to " + deFilesDir);
+            return;
+        }
+        Log.i(TAG, "Moved directory from " + ceFilesDir + " to " + deFilesDir
+            + ". Reinitializing cache.");
+        mDynamicSettingsFile = new SettingsFile(mContext, AID_XML_PATH);
+        mOthersFile = new SettingsFile(mContext, OTHER_STATUS_PATH);
+    }
+
+    public void migrateSettingsFilesFromCe(Context ceContext) {
+        synchronized (mLock) {
+            migrateFromCe(ceContext);
+            initialize();
+        }
+    }
+
     private void refreshUserProfilesLocked(boolean invalidateCache) {
         UserManager um = mContext.createContextAsUser(
                 UserHandle.of(ActivityManager.getCurrentUser()), /*flags=*/0)
@@ -505,13 +541,22 @@ public class RegisteredServicesCache {
                 ComponentName component = entry.getKey();
                 DynamicSettings dynamicSettings = entry.getValue();
                 ApduServiceInfo serviceInfo = userServices.services.get(component);
-                if (serviceInfo == null || (serviceInfo.getUid() != dynamicSettings.uid)) {
+                if (serviceInfo == null) {
                     toBeRemovedComponent.add(component);
                     continue;
                 } else {
                     for (AidGroup group : dynamicSettings.aidGroups.values()) {
                         serviceInfo.setDynamicAidGroup(group);
                     }
+                    for (Map.Entry<String, Boolean> filter : dynamicSettings.pollingLoopFilters
+                            .entrySet()) {
+                        serviceInfo.addPollingLoopFilter(filter.getKey(), filter.getValue());
+                    }
+                    for (Map.Entry<String, Boolean> filter : dynamicSettings
+                            .pollingLoopPatternFilters
+                            .entrySet()) {
+                        serviceInfo.addPollingLoopPatternFilter(filter.getKey(), filter.getValue());
+                    }
                     if (dynamicSettings.offHostSE != null) {
                         serviceInfo.setOffHostSecureElement(dynamicSettings.offHostSE);
                     }
@@ -662,6 +707,8 @@ public class RegisteredServicesCache {
                 String currentOffHostSE = null;
                 String shouldDefaultToObserveModeStr = null;
                 ArrayList<AidGroup> currentGroups = new ArrayList<AidGroup>();
+                Map<String, Boolean> plFilters = new HashMap<>();
+                Map<String, Boolean> plPatternFilters = new HashMap<>();
                 while (eventType != XmlPullParser.END_DOCUMENT) {
                     tagName = parser.getName();
                     if (eventType == XmlPullParser.START_TAG) {
@@ -694,6 +741,19 @@ public class RegisteredServicesCache {
                                 Log.e(TAG, "Could not parse AID group.");
                             }
                         }
+                        if ("pl_filter".equals(tagName) && parser.getDepth() == 4 && inService) {
+                            String filter = parser.getAttributeValue(null, "value");
+                            String autoTransact = parser
+                                    .getAttributeValue(null, "auto_transact");
+                            plFilters.put(filter, Boolean.parseBoolean(autoTransact));
+                        }
+                        if ("pl_pattern_filter".equals(tagName) && parser.getDepth() == 4
+                                && inService) {
+                            String pattern = parser.getAttributeValue(null, "value");
+                            String autoTransact = parser
+                                    .getAttributeValue(null, "auto_transact");
+                            plPatternFilters.put(pattern, Boolean.parseBoolean(autoTransact));
+                        }
                     } else if (eventType == XmlPullParser.END_TAG) {
                         if ("service".equals(tagName)) {
                             // See if we have a valid service
@@ -706,6 +766,8 @@ public class RegisteredServicesCache {
                                 for (AidGroup group : currentGroups) {
                                     dynSettings.aidGroups.put(group.getCategory(), group);
                                 }
+                                dynSettings.pollingLoopFilters.putAll(plFilters);
+                                dynSettings.pollingLoopPatternFilters.putAll(plPatternFilters);
                                 dynSettings.offHostSE = currentOffHostSE;
                                 dynSettings.shouldDefaultToObserveModeStr
                                         = shouldDefaultToObserveModeStr;
@@ -717,6 +779,8 @@ public class RegisteredServicesCache {
                             }
                             currentUid = -1;
                             currentComponent = null;
+                            plFilters.clear();
+                            plPatternFilters.clear();
                             currentGroups.clear();
                             inService = false;
                             currentOffHostSE = null;
@@ -884,6 +948,26 @@ public class RegisteredServicesCache {
                     for (AidGroup group : service.getValue().aidGroups.values()) {
                         group.writeAsXml(out);
                     }
+                    out.startTag(null , "pl_filters");
+                    for (Map.Entry<String, Boolean> filter
+                            : service.getValue().pollingLoopFilters.entrySet()) {
+                        out.startTag(null, "pl_filter");
+                        out.attribute(null, "value", filter.getKey());
+                        out.attribute(null, "auto_transact",
+                                Boolean.toString(filter.getValue()));
+                        out.endTag(null, "pl_filter");
+                    }
+                    out.endTag(null, "pl_filters");
+                    out.startTag(null , "pl_pattern_filters");
+                    for (Map.Entry<String, Boolean> filter
+                            : service.getValue().pollingLoopPatternFilters.entrySet()) {
+                        out.startTag(null, "pl_pattern_filter");
+                        out.attribute(null, "value", filter.getKey());
+                        out.attribute(null, "auto_transact",
+                                Boolean.toString(filter.getValue()));
+                        out.endTag(null, "pl_pattern_filter");
+                    }
+                    out.endTag(null, "pl_pattern_filters");
                     out.endTag(null, "service");
                 }
             }
@@ -970,7 +1054,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -985,7 +1069,7 @@ public class RegisteredServicesCache {
 
             DynamicSettings dynSettings = services.dynamicSettings.get(componentName);
             if (dynSettings == null) {
-                dynSettings = new DynamicSettings(uid);
+                dynSettings = new DynamicSettings(serviceInfo.getUid());
             }
             dynSettings.offHostSE = offHostSE;
             boolean success = writeDynamicSettingsLocked();
@@ -1013,7 +1097,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1054,7 +1138,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1065,7 +1149,7 @@ public class RegisteredServicesCache {
             serviceInfo.setShouldDefaultToObserveMode(enable);
             DynamicSettings dynSettings = services.dynamicSettings.get(componentName);
             if (dynSettings == null) {
-                dynSettings = new DynamicSettings(uid);
+                dynSettings = new DynamicSettings(serviceInfo.getUid());
                 dynSettings.offHostSE = null;
                 services.dynamicSettings.put(componentName, dynSettings);
             }
@@ -1087,7 +1171,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1098,6 +1182,10 @@ public class RegisteredServicesCache {
             if (!serviceInfo.isOnHost() && !autoTransact) {
                 return false;
             }
+            DynamicSettings dynamicSettings =
+                getOrCreateSettings(services, componentName, serviceInfo.getUid());
+            dynamicSettings.pollingLoopFilters.put(pollingLoopFilter,
+                    autoTransact);
             serviceInfo.addPollingLoopFilter(pollingLoopFilter, autoTransact);
             newServices = new ArrayList<ApduServiceInfo>(services.services.values());
         }
@@ -1117,7 +1205,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1145,7 +1233,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1156,6 +1244,10 @@ public class RegisteredServicesCache {
             if (!serviceInfo.isOnHost() && !autoTransact) {
                 return false;
             }
+            DynamicSettings dynamicSettings =
+                getOrCreateSettings(services, componentName, serviceInfo.getUid());
+            dynamicSettings.pollingLoopPatternFilters
+                    .put(pollingLoopPatternFilter, autoTransact);
             serviceInfo.addPollingLoopPatternFilter(pollingLoopPatternFilter, autoTransact);
             newServices = new ArrayList<ApduServiceInfo>(services.services.values());
         }
@@ -1175,7 +1267,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1204,7 +1296,7 @@ public class RegisteredServicesCache {
                 Log.e(TAG, "Service " + componentName + " does not exist.");
                 return false;
             }
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 // This is probably a good indication something is wrong here.
                 // Either newer service installed with different uid (but then
                 // we should have known about it), or somebody calling us from
@@ -1224,7 +1316,7 @@ public class RegisteredServicesCache {
             serviceInfo.setDynamicAidGroup(aidGroup);
             DynamicSettings dynSettings = services.dynamicSettings.get(componentName);
             if (dynSettings == null) {
-                dynSettings = new DynamicSettings(uid);
+                dynSettings = new DynamicSettings(serviceInfo.getUid());
                 dynSettings.offHostSE = null;
                 services.dynamicSettings.put(componentName, dynSettings);
             }
@@ -1249,12 +1341,12 @@ public class RegisteredServicesCache {
         return success;
     }
 
-    public boolean registerOtherForService(int userId,
+    public int registerOtherForService(int userId,
             ComponentName componentName, boolean checked) {
         if (DEBUG) Log.d(TAG, "[register other] checked:" + checked + ", "  + componentName);
 
         ArrayList<ApduServiceInfo> newServices = null;
-        boolean success = false;
+        int success = SET_SERVICE_ENABLED_STATUS_FAILURE_UNKNOWN_ERROR;
 
         synchronized (mLock) {
 
@@ -1263,12 +1355,14 @@ public class RegisteredServicesCache {
 
             if (serviceInfo == null) {
                 Log.e(TAG, "Service " + componentName + "does not exist");
-                return false;
+                return SET_SERVICE_ENABLED_STATUS_FAILURE_INVALID_SERVICE;
             }
 
-            success = updateOtherServiceStatus(userId, serviceInfo, checked);
+            success = updateOtherServiceStatus(userId, serviceInfo, checked)
+                    ? SET_SERVICE_ENABLED_STATUS_OK
+                    : SET_SERVICE_ENABLED_STATUS_FAILURE_ALREADY_SET;
 
-            if (success) {
+            if (success == SET_SERVICE_ENABLED_STATUS_OK) {
                 UserServices userService = findOrCreateUserLocked(userId);
                 newServices = new ArrayList<ApduServiceInfo>(userService.services.values());
             } else {
@@ -1276,7 +1370,7 @@ public class RegisteredServicesCache {
             }
         }
 
-        if (success) {
+        if (success == SET_SERVICE_ENABLED_STATUS_OK) {
             if (DEBUG) Log.d(TAG, "other list update due to User Select " + componentName);
             mCallback.onServicesUpdated(userId, Collections.unmodifiableList(newServices),false);
         }
@@ -1288,7 +1382,7 @@ public class RegisteredServicesCache {
             String category) {
         ApduServiceInfo serviceInfo = getService(userId, componentName);
         if (serviceInfo != null) {
-            if (serviceInfo.getUid() != uid) {
+            if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                 Log.e(TAG, "UID mismatch");
                 return null;
             }
@@ -1307,7 +1401,7 @@ public class RegisteredServicesCache {
             UserServices services = findOrCreateUserLocked(userId);
             ApduServiceInfo serviceInfo = getService(userId, componentName);
             if (serviceInfo != null) {
-                if (serviceInfo.getUid() != uid) {
+                if (!NfcInjector.isPrivileged(uid) && serviceInfo.getUid() != uid) {
                     // Calling from different uid
                     Log.e(TAG, "UID mismatch");
                     return false;
@@ -1360,7 +1454,7 @@ public class RegisteredServicesCache {
         OtherServiceStatus status = userServices.others.get(service.getComponent());
         // This is Error handling code if otherServiceStatus is null
         if (status == null) {
-            Log.d(TAG, service.getComponent() + " status is could not be null");
+            Log.d(TAG, service.getComponent() + " status is null");
             return false;
         }
 
@@ -1375,6 +1469,14 @@ public class RegisteredServicesCache {
         return writeOthersLocked();
     }
 
+    private DynamicSettings getOrCreateSettings(UserServices services, ComponentName componentName,
+            int uid) {
+        if (!services.dynamicSettings.containsKey(componentName)) {
+            services.dynamicSettings.put(componentName, new DynamicSettings(uid));
+        }
+        return services.dynamicSettings.get(componentName);
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("Registered HCE services for current user: ");
         ParcelFileDescriptor pFd;
diff --git a/src/com/android/nfc/cardemulation/RoutingOptionManager.java b/src/com/android/nfc/cardemulation/RoutingOptionManager.java
index f9b2f859..2d6c53e7 100644
--- a/src/com/android/nfc/cardemulation/RoutingOptionManager.java
+++ b/src/com/android/nfc/cardemulation/RoutingOptionManager.java
@@ -28,6 +28,7 @@ import com.android.nfc.NfcService;
 
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.Map;
 import java.util.Optional;
 
 public class RoutingOptionManager {
@@ -37,6 +38,8 @@ public class RoutingOptionManager {
 
     static final int ROUTE_UNKNOWN = -1;
 
+    static final int ROUTE_DEFAULT = -2;
+
     public static final String DEVICE_HOST = "DH";
     public static final String SE_PREFIX_SIM = "SIM";
     public static final String SE_PREFIX_ESE = "eSE";
@@ -45,6 +48,7 @@ public class RoutingOptionManager {
     public static final String KEY_DEFAULT_ROUTE = "default_route";
     public static final String KEY_DEFAULT_ISO_DEP_ROUTE = "default_iso_dep_route";
     public static final String KEY_DEFAULT_OFFHOST_ROUTE = "default_offhost_route";
+    public static final String KEY_DEFAULT_SC_ROUTE = "default_sc_route";
     public static final String KEY_AUTO_CHANGE_CAPABLE = "allow_auto_routing_changed";
     Context mContext;
     private SharedPreferences mPrefs;
@@ -53,6 +57,8 @@ public class RoutingOptionManager {
     int mDefaultRoute;
     int mDefaultIsoDepRoute;
     int mDefaultOffHostRoute;
+    int mDefaultFelicaRoute;
+    int mDefaultScRoute;
     final byte[] mOffHostRouteUicc;
     final byte[] mOffHostRouteEse;
     final int mAidMatchingSupport;
@@ -60,10 +66,11 @@ public class RoutingOptionManager {
     int mOverrideDefaultRoute = ROUTE_UNKNOWN;
     int mOverrideDefaultIsoDepRoute = ROUTE_UNKNOWN;
     int mOverrideDefaultOffHostRoute = ROUTE_UNKNOWN;
+    int mOverrideDefaultFelicaRoute = ROUTE_UNKNOWN;
+    int mOverrideDefaultScRoute = ROUTE_UNKNOWN;
 
     boolean mIsRoutingTableOverrided = false;
 
-
     boolean mIsAutoChangeCapable = true;
 
     // Look up table for secure element name to route id
@@ -80,6 +87,10 @@ public class RoutingOptionManager {
     @VisibleForTesting
     native int doGetDefaultOffHostRouteDestination();
     @VisibleForTesting
+    native int doGetDefaultFelicaRouteDestination();
+    @VisibleForTesting
+    native int doGetDefaultScRouteDestination();
+    @VisibleForTesting
     native byte[] doGetOffHostUiccDestination();
     @VisibleForTesting
     native byte[] doGetOffHostEseDestination();
@@ -97,20 +108,19 @@ public class RoutingOptionManager {
     @VisibleForTesting
     RoutingOptionManager() {
         mDefaultRoute = doGetDefaultRouteDestination();
-        if (DBG)
-            Log.d(TAG, "mDefaultRoute=0x" + Integer.toHexString(mDefaultRoute));
+        if (DBG) Log.d(TAG, "mDefaultRoute=0x" + Integer.toHexString(mDefaultRoute));
         mDefaultIsoDepRoute = doGetDefaultIsoDepRouteDestination();
-        if (DBG)
-            Log.d(TAG, "mDefaultIsoDepRoute=0x" + Integer.toHexString(mDefaultIsoDepRoute));
+        if (DBG) Log.d(TAG, "mDefaultIsoDepRoute=0x" + Integer.toHexString(mDefaultIsoDepRoute));
         mDefaultOffHostRoute = doGetDefaultOffHostRouteDestination();
-        if (DBG)
-            Log.d(TAG, "mDefaultOffHostRoute=0x" + Integer.toHexString(mDefaultOffHostRoute));
+        if (DBG) Log.d(TAG, "mDefaultOffHostRoute=0x" + Integer.toHexString(mDefaultOffHostRoute));
+        mDefaultFelicaRoute = doGetDefaultFelicaRouteDestination();
+        if (DBG) Log.d(TAG, "mDefaultFelicaRoute=0x" + Integer.toHexString(mDefaultFelicaRoute));
+        mDefaultScRoute = doGetDefaultScRouteDestination();
+        if (DBG) Log.d(TAG, "mDefaultScRoute=0x" + Integer.toHexString(mDefaultScRoute));
         mOffHostRouteUicc = doGetOffHostUiccDestination();
-        if (DBG)
-            Log.d(TAG, "mOffHostRouteUicc=" + Arrays.toString(mOffHostRouteUicc));
+        if (DBG) Log.d(TAG, "mOffHostRouteUicc=" + Arrays.toString(mOffHostRouteUicc));
         mOffHostRouteEse = doGetOffHostEseDestination();
-        if (DBG)
-            Log.d(TAG, "mOffHostRouteEse=" + Arrays.toString(mOffHostRouteEse));
+        if (DBG) Log.d(TAG, "mOffHostRouteEse=" + Arrays.toString(mOffHostRouteEse));
         mAidMatchingSupport = doGetAidMatchingMode();
         if (DBG) Log.d(TAG, "mAidMatchingSupport=0x" + Integer.toHexString(mAidMatchingSupport));
 
@@ -118,29 +128,61 @@ public class RoutingOptionManager {
     }
 
     public void overwriteRoutingTable() {
-        Log.e(TAG, "overwriteRoutingTable");
+        Log.d(TAG, "overwriteRoutingTable()");
         if (mOverrideDefaultRoute != ROUTE_UNKNOWN) {
-            Log.e(TAG, "overwrite mDefaultRoute : " + mOverrideDefaultRoute);
-            mDefaultRoute = mOverrideDefaultRoute;
+            if (mOverrideDefaultRoute == ROUTE_DEFAULT) {
+                Log.i(TAG, "overwrite mDefaultRoute with default config value");
+                mDefaultRoute = doGetDefaultRouteDestination();
+            } else {
+                Log.d(TAG, "overwriteRoutingTable() - mDefaultRoute : "
+                    + Integer.toHexString(mOverrideDefaultRoute));
+                mDefaultRoute = mOverrideDefaultRoute;
+            }
             writeRoutingOption(KEY_DEFAULT_ROUTE, getSecureElementForRoute(mDefaultRoute));
         }
 
         if (mOverrideDefaultIsoDepRoute != ROUTE_UNKNOWN) {
-            Log.e(TAG, "overwrite mDefaultIsoDepRoute : " + mOverrideDefaultIsoDepRoute);
-            mDefaultIsoDepRoute = mOverrideDefaultIsoDepRoute;
+            if (mOverrideDefaultIsoDepRoute == ROUTE_DEFAULT) {
+                Log.i(TAG, "overwrite mDefaultIsoDepRoute with default config value");
+                mDefaultIsoDepRoute = doGetDefaultIsoDepRouteDestination();
+            } else {
+                Log.d(TAG, "overwriteRoutingTable() - mDefaultIsoDepRoute : "
+                        + Integer.toHexString(mOverrideDefaultIsoDepRoute));
+                mDefaultIsoDepRoute = mOverrideDefaultIsoDepRoute;
+            }
             writeRoutingOption(
-                KEY_DEFAULT_ISO_DEP_ROUTE, getSecureElementForRoute(mDefaultIsoDepRoute));
+                    KEY_DEFAULT_ISO_DEP_ROUTE, getSecureElementForRoute(mDefaultIsoDepRoute));
         }
 
         if (mOverrideDefaultOffHostRoute != ROUTE_UNKNOWN) {
-            Log.e(TAG, "overwrite mDefaultOffHostRoute : " + mOverrideDefaultOffHostRoute);
-            mDefaultOffHostRoute = mOverrideDefaultOffHostRoute;
+            if (mOverrideDefaultOffHostRoute == ROUTE_DEFAULT) {
+                Log.i(TAG, "overwrite mDefaultOffHostRoute with default config value");
+                mDefaultOffHostRoute = doGetDefaultOffHostRouteDestination();
+            } else {
+                Log.d(TAG, "overwriteRoutingTable() - mDefaultOffHostRoute : "
+                        + Integer.toHexString(mOverrideDefaultOffHostRoute));
+                mDefaultOffHostRoute = mOverrideDefaultOffHostRoute;
+            }
             writeRoutingOption(
-                KEY_DEFAULT_OFFHOST_ROUTE, getSecureElementForRoute(mDefaultOffHostRoute));
+                    KEY_DEFAULT_OFFHOST_ROUTE, getSecureElementForRoute(mDefaultOffHostRoute));
         }
 
-        mOverrideDefaultRoute = mOverrideDefaultIsoDepRoute = mOverrideDefaultOffHostRoute
-                = ROUTE_UNKNOWN;
+        if (mOverrideDefaultScRoute != ROUTE_UNKNOWN) {
+            if (mOverrideDefaultScRoute == ROUTE_DEFAULT) {
+                Log.i(TAG, "overwriteRoutingTable() - mDefaultScRoute with default config value");
+                mDefaultScRoute = doGetDefaultScRouteDestination();
+            } else {
+                Log.d(TAG,
+                        "overwriteRoutingTable() - mDefaultScRoute : "
+                            + Integer.toHexString(mOverrideDefaultScRoute));
+                mDefaultScRoute = mOverrideDefaultScRoute;
+            }
+            writeRoutingOption(
+                    KEY_DEFAULT_SC_ROUTE, getSecureElementForRoute(mDefaultScRoute));
+        }
+
+        mOverrideDefaultRoute = mOverrideDefaultIsoDepRoute = mOverrideDefaultOffHostRoute =
+            mOverrideDefaultScRoute = ROUTE_UNKNOWN;
     }
 
     public void overrideDefaultRoute(int defaultRoute) {
@@ -154,14 +196,20 @@ public class RoutingOptionManager {
 
     public void overrideDefaultOffHostRoute(int offHostRoute) {
         mOverrideDefaultOffHostRoute = offHostRoute;
-        NfcService.getInstance().setTechnologyABFRoute(offHostRoute);
+        mOverrideDefaultFelicaRoute = offHostRoute;
+        NfcService.getInstance().setTechnologyABFRoute(offHostRoute, offHostRoute);
+    }
+
+    public void overrideDefaultScRoute(int scRoute) {
+        mOverrideDefaultScRoute = scRoute;
+        NfcService.getInstance().setSystemCodeRoute(scRoute);
     }
 
     public void recoverOverridedRoutingTable() {
         NfcService.getInstance().setIsoDepProtocolRoute(mDefaultIsoDepRoute);
-        NfcService.getInstance().setTechnologyABFRoute(mDefaultOffHostRoute);
-        mOverrideDefaultRoute = mOverrideDefaultIsoDepRoute = mOverrideDefaultOffHostRoute
-            = ROUTE_UNKNOWN;
+        NfcService.getInstance().setTechnologyABFRoute(mDefaultOffHostRoute, mDefaultFelicaRoute);
+        mOverrideDefaultRoute = mOverrideDefaultIsoDepRoute = mOverrideDefaultOffHostRoute =
+            mOverrideDefaultFelicaRoute = ROUTE_UNKNOWN;
     }
 
     public int getOverrideDefaultRoute() {
@@ -185,6 +233,20 @@ public class RoutingOptionManager {
         return mDefaultOffHostRoute;
     }
 
+    public int getDefaultFelicaRoute() {
+        return mDefaultFelicaRoute;
+    }
+
+    public int getOverrideDefaultFelicaRoute() {
+        return mOverrideDefaultFelicaRoute;
+    }
+    public int getOverrideDefaultScRoute() {
+        return mOverrideDefaultScRoute;
+    }
+    public int getDefaultScRoute() {
+        return mDefaultScRoute;
+    }
+
     public byte[] getOffHostRouteUicc() {
         return mOffHostRouteUicc;
     }
@@ -200,7 +262,9 @@ public class RoutingOptionManager {
     public boolean isRoutingTableOverrided() {
         return mOverrideDefaultRoute != ROUTE_UNKNOWN
             || mOverrideDefaultIsoDepRoute != ROUTE_UNKNOWN
-            || mOverrideDefaultOffHostRoute != ROUTE_UNKNOWN;
+            || mOverrideDefaultOffHostRoute != ROUTE_UNKNOWN
+            || mOverrideDefaultFelicaRoute != ROUTE_UNKNOWN
+            || mOverrideDefaultScRoute != ROUTE_UNKNOWN;
     }
 
     private void createLookUpTable() {
@@ -210,6 +274,9 @@ public class RoutingOptionManager {
         mRouteForSecureElement.putIfAbsent("UNKNOWN", ROUTE_UNKNOWN);
         mSecureElementForRoute.put(ROUTE_UNKNOWN, "UNKNOWN");
 
+        mRouteForSecureElement.putIfAbsent("default", ROUTE_DEFAULT);
+        mSecureElementForRoute.put(ROUTE_DEFAULT, "default");
+
         addOrUpdateTableItems(SE_PREFIX_SIM, mOffHostRouteUicc);
         addOrUpdateTableItems(SE_PREFIX_ESE, mOffHostRouteEse);
     }
@@ -219,6 +286,7 @@ public class RoutingOptionManager {
         return !TextUtils.isEmpty(deviceConfigFacade.getDefaultRoute())
                 || !TextUtils.isEmpty(deviceConfigFacade.getDefaultIsoDepRoute())
                 || !TextUtils.isEmpty(deviceConfigFacade.getDefaultOffHostRoute())
+                || !TextUtils.isEmpty(deviceConfigFacade.getDefaultScRoute())
                 || !prefs.getAll().isEmpty();
     }
 
@@ -260,6 +328,14 @@ public class RoutingOptionManager {
         mDefaultOffHostRoute =
             getRouteForSecureElement(mPrefs.getString(KEY_DEFAULT_OFFHOST_ROUTE, null));
 
+        // read default system code route
+        if (!mPrefs.contains(KEY_DEFAULT_SC_ROUTE)) {
+            writeRoutingOption(
+                KEY_DEFAULT_SC_ROUTE, deviceConfigFacade.getDefaultScRoute());
+        }
+        mDefaultScRoute =
+            getRouteForSecureElement(mPrefs.getString(KEY_DEFAULT_SC_ROUTE, null));
+
         // read auto change capable
         if (!mPrefs.contains(KEY_AUTO_CHANGE_CAPABLE)) {
             writeRoutingOption(KEY_AUTO_CHANGE_CAPABLE, true);
@@ -292,16 +368,22 @@ public class RoutingOptionManager {
 
 
     private void addOrUpdateTableItems(String prefix, byte[] routes) {
-        if (routes!= null && routes.length != 0) {
-            for (int index=1; index<=routes.length; index++) {
-                int route = routes[index-1] & 0xFF;
+        if (routes != null && routes.length != 0) {
+            for (int index = 1; index <= routes.length; index++) {
+                int route = routes[index - 1] & 0xFF;
                 String name = prefix + index;
                 mRouteForSecureElement.putIfAbsent(name, route);
                 mSecureElementForRoute.putIfAbsent(route, name);
             }
         }
 
-        Log.d(TAG, "RouteForSecureElement: " + mRouteForSecureElement.toString());
-        Log.d(TAG, "mSecureElementForRoute: " + mSecureElementForRoute.toString());
+        for (Map.Entry<String, Integer> entry : mRouteForSecureElement.entrySet()) {
+            Log.d(TAG, "addOrUpdateTableItems() - route: " + entry.getKey() + ", nfceeId: "
+                    + Integer.toHexString(entry.getValue()));
+        }
+        for (Map.Entry<Integer, String> entry : mSecureElementForRoute.entrySet()) {
+            Log.d(TAG, "addOrUpdateTableItems() - nfceeId: "
+                    + Integer.toHexString(entry.getKey()) + ", route: " + entry.getValue());
+        }
     }
 }
diff --git a/src/com/android/nfc/cardemulation/util/NfcFileUtils.java b/src/com/android/nfc/cardemulation/util/NfcFileUtils.java
new file mode 100644
index 00000000..88c6b85b
--- /dev/null
+++ b/src/com/android/nfc/cardemulation/util/NfcFileUtils.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.cardemulation.util;
+
+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
+
+import android.util.Log;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+
+public class NfcFileUtils {
+    private static final String TAG = "NfcFileUtils";
+
+    /**
+     * Check if there are any files in the provided directory.
+     * @return true if there are no files, false otherwise.
+     */
+    public static boolean isEmptyDir(File dir) {
+        final File[] files = dir.listFiles();
+        return files == null || files.length == 0;
+    }
+
+    /**
+     * Try our best to migrate all files from source to target.
+     *
+     * @return the number of files moved, or -1 if there was trouble.
+     */
+    public static int moveFiles(File sourceDir, File targetDir) {
+        final File[] sourceFiles = sourceDir.listFiles();
+        if (sourceFiles == null) return -1;
+        int res = 0;
+        for (File sourceFile : sourceFiles) {
+            final File targetFile = new File(targetDir, sourceFile.getName());
+            Log.d(TAG, "Migrating " + sourceFile + " to " + targetFile);
+            try {
+                Files.move(sourceFile.toPath(), targetFile.toPath(), REPLACE_EXISTING);
+                if (res != -1) {
+                    res++;
+                }
+            } catch (IOException e) {
+                Log.w(TAG, "Failed to migrate " + sourceFile + ": " + e);
+                res = -1;
+            }
+        }
+        return res;
+    }
+}
diff --git a/src/com/android/nfc/handover/BluetoothPeripheralHandover.java b/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
index bba08752..41674964 100644
--- a/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
+++ b/src/com/android/nfc/handover/BluetoothPeripheralHandover.java
@@ -41,6 +41,8 @@ import android.util.Log;
 import android.view.KeyEvent;
 import android.widget.Toast;
 
+import androidx.annotation.VisibleForTesting;
+
 import com.android.nfc.R;
 
 /**
@@ -125,6 +127,14 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
     public BluetoothPeripheralHandover(Context context, BluetoothDevice device, String name,
             int transport, OobData oobData, ParcelUuid[] uuids, BluetoothClass btClass,
             Callback callback) {
+        this(context, device, name, transport, oobData, uuids,
+                btClass, callback, BluetoothAdapter.getDefaultAdapter());
+    }
+
+    @VisibleForTesting
+    public BluetoothPeripheralHandover(Context context, BluetoothDevice device, String name,
+            int transport, OobData oobData, ParcelUuid[] uuids, BluetoothClass btClass,
+            Callback callback, BluetoothAdapter adapter) {
         checkMainThread();  // mHandler must get get constructed on Main Thread for toasts to work
         mContext = context;
         mDevice = device;
@@ -132,7 +142,7 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
         mTransport = transport;
         mOobData = oobData;
         mCallback = callback;
-        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        mBluetoothAdapter = adapter;
 
         ContentResolver contentResolver = mContext.getContentResolver();
         mProvisioning = Settings.Global.getInt(contentResolver,
@@ -721,4 +731,8 @@ public class BluetoothPeripheralHandover implements BluetoothProfile.ServiceList
             mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_RETRY), waitTime);
         }
     }
+
+    public int getTransport() {
+        return mTransport;
+    }
 }
diff --git a/src/com/android/nfc/handover/ConfirmConnectActivity.java b/src/com/android/nfc/handover/ConfirmConnectActivity.java
index 0ed9c6c8..9cdd8004 100644
--- a/src/com/android/nfc/handover/ConfirmConnectActivity.java
+++ b/src/com/android/nfc/handover/ConfirmConnectActivity.java
@@ -31,6 +31,7 @@ import android.content.res.Resources;
 import android.os.Bundle;
 import android.util.Log;
 
+import com.android.nfc.NfcInjector;
 import com.android.nfc.R;
 
 public class ConfirmConnectActivity extends Activity {
@@ -57,7 +58,7 @@ public class ConfirmConnectActivity extends Activity {
                    public void onClick(DialogInterface dialog, int id) {
                         Intent allowIntent = new Intent(BluetoothPeripheralHandover.ACTION_ALLOW_CONNECT);
                         allowIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
-                        allowIntent.setPackage("com.android.nfc");
+                        allowIntent.setPackage(NfcInjector.getInstance().getNfcPackageName());
                         sendBroadcast(allowIntent);
                         ConfirmConnectActivity.this.mAlert = null;
                         ConfirmConnectActivity.this.finish();
@@ -68,7 +69,7 @@ public class ConfirmConnectActivity extends Activity {
                    public void onClick(DialogInterface dialog, int id) {
                        Intent denyIntent = new Intent(BluetoothPeripheralHandover.ACTION_DENY_CONNECT);
                        denyIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
-                       denyIntent.setPackage("com.android.nfc");
+                       denyIntent.setPackage(NfcInjector.getInstance().getNfcPackageName());
                        sendBroadcast(denyIntent);
                        ConfirmConnectActivity.this.mAlert = null;
                        ConfirmConnectActivity.this.finish();
@@ -90,7 +91,7 @@ public class ConfirmConnectActivity extends Activity {
             mAlert.dismiss();
             Intent denyIntent = new Intent(BluetoothPeripheralHandover.ACTION_DENY_CONNECT);
             denyIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
-            denyIntent.setPackage("com.android.nfc");
+            denyIntent.setPackage(NfcInjector.getInstance().getNfcPackageName());
             sendBroadcast(denyIntent);
             mAlert = null;
         }
@@ -114,7 +115,7 @@ public class ConfirmConnectActivity extends Activity {
                 Intent denyIntent =
                         new Intent(BluetoothPeripheralHandover.ACTION_DENY_CONNECT);
                 denyIntent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
-                denyIntent.setPackage("com.android.nfc");
+                denyIntent.setPackage(NfcInjector.getInstance().getNfcPackageName());
                 context.sendBroadcast(denyIntent);
                 finish();
             }
diff --git a/src/com/android/nfc/handover/HandoverDataParser.java b/src/com/android/nfc/handover/HandoverDataParser.java
index 7b87ba1a..05797bf2 100644
--- a/src/com/android/nfc/handover/HandoverDataParser.java
+++ b/src/com/android/nfc/handover/HandoverDataParser.java
@@ -29,6 +29,8 @@ import android.os.ParcelUuid;
 import android.sysprop.NfcProperties;
 import android.util.Log;
 
+import androidx.annotation.VisibleForTesting;
+
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -111,7 +113,12 @@ public class HandoverDataParser {
     }
 
     public HandoverDataParser() {
-        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        this(BluetoothAdapter.getDefaultAdapter());
+    }
+
+    @VisibleForTesting
+    public HandoverDataParser(BluetoothAdapter adapter) {
+        mBluetoothAdapter = adapter;
     }
 
     static NdefRecord createCollisionRecord() {
diff --git a/src/com/android/nfc/handover/PeripheralHandoverService.java b/src/com/android/nfc/handover/PeripheralHandoverService.java
index 16a7f020..dcd599d8 100644
--- a/src/com/android/nfc/handover/PeripheralHandoverService.java
+++ b/src/com/android/nfc/handover/PeripheralHandoverService.java
@@ -39,6 +39,8 @@ import android.os.RemoteException;
 import android.text.TextUtils;
 import android.util.Log;
 
+import androidx.annotation.VisibleForTesting;
+
 import java.util.Objects;
 import java.util.Set;
 
@@ -238,7 +240,7 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
     @Override
     public void onBluetoothPeripheralHandoverComplete(boolean connected) {
         // Called on the main thread
-        int transport = mBluetoothPeripheralHandover.mTransport;
+        int transport = mBluetoothPeripheralHandover.getTransport();
         mBluetoothPeripheralHandover = null;
         mBluetoothHeadsetConnected = connected;
 
@@ -334,4 +336,22 @@ public class PeripheralHandoverService extends Service implements BluetoothPerip
         // prevent any future callbacks to the client, no rebind call needed.
         return false;
     }
+
+    @VisibleForTesting
+    public PeripheralHandoverService(BluetoothAdapter bluetoothAdapter, NfcAdapter nfcAdapter,
+            BluetoothPeripheralHandover bluetoothPeripheralHandover, MessageHandler handler,
+            Messenger messenger, BluetoothDevice device, boolean bluetoothEnabledByNfc) {
+        mBluetoothAdapter = bluetoothAdapter;
+        mNfcAdapter = nfcAdapter;
+        mBluetoothPeripheralHandover = bluetoothPeripheralHandover;
+        mHandler = handler;
+        mClient = messenger;
+        mMessenger = messenger;
+        mDevice = device;
+        mBluetoothEnabledByNfc = bluetoothEnabledByNfc;
+        mBluetoothHeadsetConnected = false;
+        mStartId = 0;
+        mPendingMsgData = null;
+        mName = "Test name";
+    }
 }
diff --git a/tests/instrumentation/Android.bp b/tests/instrumentation/Android.bp
index 87a20046..1b5e096f 100644
--- a/tests/instrumentation/Android.bp
+++ b/tests/instrumentation/Android.bp
@@ -35,10 +35,12 @@ android_test {
     platform_apis: true,
 
     test_suites: [
-        "device-tests",
+        "general-tests",
         "device-pixel-tests",
         "device-platinum-tests",
+        "mts-nfc",
     ],
+    min_sdk_version: "current",
 
     instrumentation_for: "NfcNci",
 }
diff --git a/tests/instrumentation/AndroidTest.xml b/tests/instrumentation/AndroidTest.xml
index 2d06ec5e..394e791d 100644
--- a/tests/instrumentation/AndroidTest.xml
+++ b/tests/instrumentation/AndroidTest.xml
@@ -25,10 +25,15 @@
     </target_preparer>
 
     <option name="test-tag" value="NfcNciInstrumentationTests" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.nfcservices.apex" />
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="com.android.nfc.tests.instrumentation" />
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
         <option name="hidden-api-checks" value="false"/>
         <option name="test-filter-dir" value="/data/data/com.android.nfc" />
     </test>
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.nfcservices" />
+    </object>
 </configuration>
diff --git a/tests/instrumentation/src/com/android/nfc/NfcFeatureFlagTest.java b/tests/instrumentation/src/com/android/nfc/NfcFeatureFlagTest.java
index fdb732f1..9a51fcb4 100644
--- a/tests/instrumentation/src/com/android/nfc/NfcFeatureFlagTest.java
+++ b/tests/instrumentation/src/com/android/nfc/NfcFeatureFlagTest.java
@@ -15,6 +15,8 @@
  */
 package com.android.nfc;
 
+import static android.content.pm.PackageManager.MATCH_ALL;
+
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertFalse;
@@ -22,9 +24,12 @@ import static org.junit.Assert.assertTrue;
 
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.PackageInfoFlags;
+import android.content.res.Resources;
 import android.nfc.NfcAdapter;
 import android.os.SystemProperties;
 import android.text.TextUtils;
+import android.util.Log;
 
 import androidx.test.InstrumentationRegistry;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -62,10 +67,32 @@ public final class NfcFeatureFlagTest {
     public void tearDown() throws Exception {
     }
 
+    private String getNfcApkPkgName() throws Exception {
+        // Check if "com.google.android.nfc" or "com.android.nfc" is installed on the device.
+        return mContext.getPackageManager()
+                .getInstalledPackages(PackageInfoFlags.of(MATCH_ALL))
+                .stream()
+                .filter(p -> p.packageName.equals("com.google.android.nfc"))
+                .findFirst()
+                .map(p -> p.packageName)
+                .orElse("com.android.nfc");
+    }
+
+    private Resources getResources() throws Exception {
+        return mContext.createPackageContext(getNfcApkPkgName(), 0).getResources();
+    }
+
+
     @Test
-    public void testIsSecureNfcSupported() {
+    public void testIsSecureNfcSupported() throws Exception {
         if (!mNfcSupported) return;
-        String[] skuList = mContext.getResources().getStringArray(
+        boolean allSupport = getResources().getBoolean(
+                R.bool.enable_secure_nfc_support);
+        if (allSupport) {
+            assertTrue(mNfcAdapter.isSecureNfcSupported());
+            return;
+        }
+        String[] skuList = getResources().getStringArray(
                 R.array.config_skuSupportsSecureNfc);
         String sku = SystemProperties.get("ro.boot.hardware.sku");
         if (TextUtils.isEmpty(sku) || !ArrayUtils.contains(skuList, sku)) {
@@ -76,17 +103,17 @@ public final class NfcFeatureFlagTest {
     }
 
     @Test
-    public void testIsControllerAlwaysOnSupported() {
+    public void testIsControllerAlwaysOnSupported() throws Exception {
         if (!mNfcSupported) return;
-        assertThat(mContext.getResources()
+        assertThat(getResources()
                 .getBoolean(R.bool.nfcc_always_on_allowed))
                 .isEqualTo(mNfcAdapter.isControllerAlwaysOnSupported());
     }
 
     @Test
-    public void testIsTagIntentAppPreferenceSupported() {
+    public void testIsTagIntentAppPreferenceSupported() throws Exception {
         if (!mNfcSupported) return;
-        assertThat(mContext.getResources()
+        assertThat(getResources()
                 .getBoolean(R.bool.tag_intent_app_pref_supported))
                 .isEqualTo(mNfcAdapter.isTagIntentAppPreferenceSupported());
     }
diff --git a/tests/instrumentation/src/com/android/nfc/NfcStateTest.java b/tests/instrumentation/src/com/android/nfc/NfcStateTest.java
index a109cc2d..9bc639fb 100644
--- a/tests/instrumentation/src/com/android/nfc/NfcStateTest.java
+++ b/tests/instrumentation/src/com/android/nfc/NfcStateTest.java
@@ -32,6 +32,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
@@ -292,6 +293,7 @@ public final class NfcStateTest {
     }
 
     @Test
+    @Ignore // TODO: rpius - Fix the test since this is flaky on cuttlefish.
     public void testDisableWhenDisabled() {
         if (!mNfcSupported) return;
         if (mNfcAdapter.isEnabled()) {
diff --git a/tests/instrumentation/src/com/android/nfc/handover/ConfirmConnectActivityTest.java b/tests/instrumentation/src/com/android/nfc/handover/ConfirmConnectActivityTest.java
new file mode 100644
index 00000000..c2462a8e
--- /dev/null
+++ b/tests/instrumentation/src/com/android/nfc/handover/ConfirmConnectActivityTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.handover;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertNotNull;
+
+import android.app.Activity;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.content.Intent;
+
+import androidx.lifecycle.Lifecycle;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+public class ConfirmConnectActivityTest {
+    private Context context;
+
+    @Before
+    public void setUp() {
+        context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    }
+
+    @Test
+    public void testOnCreate_createAlertDialog() {
+        Intent intent = new Intent(context,
+                ConfirmConnectActivity.class);
+        BluetoothDevice mockDevice = BluetoothAdapter.getDefaultAdapter()
+                .getRemoteDevice("00:11:22:33:44:55");
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mockDevice);
+        intent.putExtra(BluetoothDevice.EXTRA_NAME, "Mock Device");
+
+        try (ActivityScenario<ConfirmConnectActivity> scenario = ActivityScenario.launch(intent)) {
+            scenario.onActivity(activity -> {
+                assertNotNull(activity.mAlert);
+            });
+            assertThat(scenario.getState()).isAtLeast(Lifecycle.State.CREATED);
+        }
+    }
+
+    @Test
+    public void testOnCreate_NullBtDeviceFinishActivity() {
+        Intent intent = new Intent(context,
+                ConfirmConnectActivity.class);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, (android.os.Parcelable) null);
+        intent.putExtra(BluetoothDevice.EXTRA_NAME, "Mock Device");
+
+        try (ActivityScenario<ConfirmConnectActivity> scenario = ActivityScenario.launch(intent)) {
+            assertThat(scenario.getState()).isAtLeast(Lifecycle.State.DESTROYED);
+        }
+    }
+
+    @Test
+    public void testOnDestroy() {
+        Intent intent = new Intent(context,
+                ConfirmConnectActivity.class);
+        BluetoothDevice mockDevice = BluetoothAdapter.getDefaultAdapter()
+                .getRemoteDevice("00:11:22:33:44:55");
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mockDevice);
+        intent.putExtra(BluetoothDevice.EXTRA_NAME, "Mock Device");
+
+        try (ActivityScenario<ConfirmConnectActivity> scenario = ActivityScenario.launch(intent)) {
+            scenario.onActivity(Activity::finish);
+            assertThat(scenario.getState()).isAtLeast(Lifecycle.State.DESTROYED);
+        }
+    }
+}
diff --git a/tests/testcases/Android.bp b/tests/testcases/Android.bp
index 11e95b07..5164976b 100644
--- a/tests/testcases/Android.bp
+++ b/tests/testcases/Android.bp
@@ -5,13 +5,14 @@ package {
 
 android_test {
     name: "NfcTestCases",
-    defaults: ["NfcNciDefaults"],
     platform_apis: true,
-
+    sdk_version: "core_current",
     libs: [
+        "framework-nfc.impl",
+        "framework",
+        "framework-res",
         "android.test.runner.stubs.system",
         "android.test.base.stubs.system",
-        "framework-nfc.impl",
         "flag-junit",
         "platform-test-annotations",
         "testables",
@@ -26,13 +27,13 @@ android_test {
         "androidx.test.core",
         "androidx.test.rules",
         "androidx.test.ext.junit",
+        "com.android.nfc.flags-aconfig",
         "frameworks-base-testutils",
         "truth",
         "androidx.annotation_annotation",
         "androidx.appcompat_appcompat",
         "com.google.android.material_material",
         "nfc-event-log-proto",
-        "nfc_flags_lib",
         "flag-junit",
         "platform-test-annotations",
         "testables",
@@ -43,9 +44,12 @@ android_test {
     // Include all test java files.
     srcs: [
         "src/**/*.java",
-        ":framework-nfc-updatable-sources",
     ],
 
-    test_suites: ["general-tests"],
+    min_sdk_version: "current",
+    test_suites: [
+        "general-tests",
+        "mts-nfc",
+    ],
 
 }
diff --git a/tests/testcases/AndroidTest.xml b/tests/testcases/AndroidTest.xml
index e9a66391..52a08463 100644
--- a/tests/testcases/AndroidTest.xml
+++ b/tests/testcases/AndroidTest.xml
@@ -24,6 +24,7 @@
     <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
     <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
     <option name="config-descriptor:metadata" key="parameter" value="no_foldable_states" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.nfcservices.apex" />
     <option name="not-shardable" value="true" />
     <option name="install-arg" value="-t" />
     <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
@@ -35,4 +36,12 @@
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
         <option name="runtime-hint" value="10m10s"/>
     </test>
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.DeviceFeatureModuleController">
+        <option name="required-feature" value="android.hardware.nfc.any" />
+    </object>
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.nfcservices" />
+    </object>
 </configuration>
diff --git a/tests/testcases/src/android/nfc/test/TestUtils.java b/tests/testcases/src/android/nfc/test/TestUtils.java
index 762ab51d..6cc5fa90 100644
--- a/tests/testcases/src/android/nfc/test/TestUtils.java
+++ b/tests/testcases/src/android/nfc/test/TestUtils.java
@@ -96,7 +96,7 @@ public class TestUtils {
               return km != null && !km.isKeyguardLocked();
             });
       }
-    } catch (InterruptedException ie) {
+    } catch (InterruptedException|AssertionError e) {
     }
   }
 
@@ -108,7 +108,7 @@ public class TestUtils {
           "Default service hasn't updated",
           6,
           () -> serviceDesc.equals(cardEmulation.getDescriptionForPreferredPaymentService()));
-    } catch (InterruptedException ie) {
+    } catch (InterruptedException|AssertionError e) {
     }
   }
 
diff --git a/tests/unit/Android.bp b/tests/unit/Android.bp
index 6522f21a..aada9e98 100644
--- a/tests/unit/Android.bp
+++ b/tests/unit/Android.bp
@@ -20,6 +20,7 @@ android_test {
         "androidx.test.core",
         "androidx.test.rules",
         "androidx.test.ext.junit",
+        "com.android.nfc.flags-aconfig-java",
         "mockito-target-extended-minus-junit4",
         "frameworks-base-testutils",
         "truth",
@@ -27,7 +28,6 @@ android_test {
         "androidx.appcompat_appcompat",
         "com.google.android.material_material",
         "nfc-event-log-proto",
-        "nfc_flags_lib",
         "flag-junit",
         "platform-test-annotations",
         "testables",
@@ -49,8 +49,12 @@ android_test {
     ],
 
     platform_apis: true,
+    min_sdk_version: "current",
 
-    test_suites: ["device-tests"],
+    test_suites: [
+        "device-tests",
+        "mts-nfc",
+    ],
 
     instrumentation_for: "NfcNci",
 }
diff --git a/tests/unit/AndroidManifest.xml b/tests/unit/AndroidManifest.xml
index 9a45b163..506e798b 100644
--- a/tests/unit/AndroidManifest.xml
+++ b/tests/unit/AndroidManifest.xml
@@ -31,6 +31,11 @@
             android:theme="@style/Theme.AppCompat"
             android:exported="false"
             />
+        <activity
+            android:name="com.android.nfc.handover.ConfirmConnectActivity"
+            android:theme="@style/Theme.AppCompat"
+            android:exported="false"
+            />
     </application>
 
     <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
diff --git a/tests/unit/AndroidTest.xml b/tests/unit/AndroidTest.xml
index 428d05d4..b620f4f3 100644
--- a/tests/unit/AndroidTest.xml
+++ b/tests/unit/AndroidTest.xml
@@ -25,6 +25,7 @@
     </target_preparer>
 
     <option name="test-tag" value="NfcNciUnitTests" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.nfcservices.apex" />
     <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
         <option name="package" value="com.android.nfc.tests.unit" />
         <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
@@ -35,4 +36,8 @@
             class="com.android.tradefed.testtype.suite.module.DeviceFeatureModuleController">
         <option name="required-feature" value="android.hardware.nfc.any" />
     </object>
+    <object type="module_controller"
+            class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.nfcservices" />
+    </object>
 </configuration>
diff --git a/tests/unit/assets/dynamic_aids.xml b/tests/unit/assets/dynamic_aids.xml
index 9b3420a4..aa135e32 100644
--- a/tests/unit/assets/dynamic_aids.xml
+++ b/tests/unit/assets/dynamic_aids.xml
@@ -8,6 +8,12 @@
             <aid value="A000000004101012"/>
             <aid value="A000000004101013"/>
         </aid-group>
+        <pl_filters>
+            <pl_filter value="filter1" auto_transact="true"/>
+        </pl_filters>
+        <pl_pattern_filters>
+            <pl_pattern_filter value="filter2" auto_transact="false"/>
+        </pl_pattern_filters>
     </service>
     <service component="com.android.test.nonpaymentnfc/com.android.test.nonpaymentnfc.NonPaymentApduService"
         uid="1"
diff --git a/tests/unit/src/com/android/nfc/ArrayUtilsTest.java b/tests/unit/src/com/android/nfc/ArrayUtilsTest.java
new file mode 100644
index 00000000..b0539a9e
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/ArrayUtilsTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import java.util.List;
+
+public class ArrayUtilsTest {
+    @Test
+    public void testIsEmptyEmptyArray() {
+        assertTrue(ArrayUtils.isEmpty((int[]) null));
+        assertTrue(ArrayUtils.isEmpty(new int[0]));
+    }
+
+    @Test
+    public void testIsEmptyNonEmptyArray() {
+        assertFalse(ArrayUtils.isEmpty(new int[] {1, 2, 3}));
+    }
+
+    @Test
+    public void testIsEmptyByteArrayNonEmptyArray() {
+        assertFalse(ArrayUtils.isEmpty(new byte[] {1, 2, 3}));
+    }
+
+    @Test
+    public void testIsEmptyByteArrayNullArray() {
+        assertTrue(ArrayUtils.isEmpty((byte[]) null));
+    }
+
+    @Test
+    public void testToPrimitiveSingleElementList() {
+        List<byte[]> list = List.of(new byte[] {1, 2, 3});
+        byte[] result = ArrayUtils.toPrimitive(list);
+        assertArrayEquals(new byte[] {1, 2, 3}, result);
+    }
+
+    @Test
+    public void testToPrimitiveEmptyList() {
+        List<byte[]> list = List.of();
+        byte[] result = ArrayUtils.toPrimitive(list);
+        assertArrayEquals(new byte[0], result);
+    }
+
+    @Test
+    public void testToIndexOfNotNullArray() {
+        assertEquals(2, ArrayUtils.indexOf(new Integer[] {2, 0, -1, 5, 1}, -1));
+    }
+
+    @Test
+    public void testToIndexOfNullArray() {
+        assertEquals(-1, ArrayUtils.indexOf(null, 8));
+    }
+
+    @Test
+    public void testToIndexOfValueNotFound() {
+        assertEquals(-1, ArrayUtils.indexOf(new Character[] {'a', 'e', 'i', 'o', 'u'}, 'k'));
+    }
+}
\ No newline at end of file
diff --git a/tests/unit/src/com/android/nfc/DtaServiceConnectorTest.java b/tests/unit/src/com/android/nfc/DtaServiceConnectorTest.java
index 6172b073..a429f94d 100644
--- a/tests/unit/src/com/android/nfc/DtaServiceConnectorTest.java
+++ b/tests/unit/src/com/android/nfc/DtaServiceConnectorTest.java
@@ -16,7 +16,10 @@
 
 package com.android.nfc;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -30,11 +33,15 @@ import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.pm.ServiceInfo;
 import android.content.res.Resources;
 import android.os.Handler;
+import android.os.IBinder;
+import android.os.Messenger;
+import android.os.RemoteException;
 import android.util.Log;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -47,7 +54,10 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
 import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
@@ -57,60 +67,23 @@ import java.util.List;
 
 @RunWith(AndroidJUnit4.class)
 public class DtaServiceConnectorTest {
-
-    private static final String TAG = DtaServiceConnectorTest.class.getSimpleName();
+    @Mock
+    Context mContext;
+    @Mock
+    private PackageManager mPackageManager;
     private MockitoSession mStaticMockSession;
-    private Context mockContext;
     private DtaServiceConnector mDtaServiceConnector;
-    private Intent implicitIntent;
+
 
     @Before
     public void setUp() throws Exception {
         mStaticMockSession = ExtendedMockito.mockitoSession()
                 .strictness(Strictness.LENIENT)
                 .startMocking();
-        Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        Resources mockResources = Mockito.mock(Resources.class);
-        when(mockResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
-                .thenReturn(false);
-
-        implicitIntent = mock(Intent.class);
-
-        mockContext = new ContextWrapper(context) {
-
-            public PackageManager getPackageManager() {
-                Log.i(TAG, "[Mock] getPackageManager");
-                PackageManager packageManager = mock(PackageManager.class);
-                ResolveInfo resolveInfo = mock(ResolveInfo.class);
-                resolveInfo.serviceInfo = mock(ServiceInfo.class);
-                resolveInfo.serviceInfo.packageName = "com.android.nfc";
-                resolveInfo.serviceInfo.name = "Nfc";
-                List<ResolveInfo> resolveInfos = new ArrayList<>();
-                resolveInfos.add(resolveInfo);
-                when(implicitIntent.getAction()).thenReturn("nfcaction");
-                when(packageManager.queryIntentServices(implicitIntent, 0)).thenReturn(
-                        resolveInfos);
-                return packageManager;
-            }
-
-            @Override
-            public Resources getResources() {
-                Log.i(TAG, "[Mock] getResources");
-                return mockResources;
-            }
-
-            @Override
-            public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver,
-                    @NonNull IntentFilter filter, @Nullable String broadcastPermission,
-                    @Nullable Handler scheduler) {
-                Log.i(TAG, "[Mock] getIntent");
-                return Mockito.mock(Intent.class);
-            }
-        };
-
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(
-                () -> mDtaServiceConnector = new DtaServiceConnector(mockContext));
-        Assert.assertNotNull(mDtaServiceConnector);
+        MockitoAnnotations.initMocks(this);
+
+        when(mContext.getPackageManager()).thenReturn(mPackageManager);
+        mDtaServiceConnector = new DtaServiceConnector(mContext);
     }
 
     @After
@@ -120,11 +93,66 @@ public class DtaServiceConnectorTest {
 
     @Test
     public void testCreateExplicitFromImplicitIntent() {
-        Intent intent = DtaServiceConnector.createExplicitFromImplicitIntent(mockContext,
+        Intent implicitIntent = mock(Intent.class);
+        ResolveInfo resolveInfo = mock(ResolveInfo.class);
+        resolveInfo.serviceInfo = mock(ServiceInfo.class);
+        resolveInfo.serviceInfo.packageName = "com.android.nfc";
+        resolveInfo.serviceInfo.name = "Nfc";
+        List<ResolveInfo> resolveInfos = new ArrayList<>();
+        resolveInfos.add(resolveInfo);
+        when(mPackageManager.queryIntentServices(implicitIntent, 0)).thenReturn(resolveInfos);
+        Intent intent = DtaServiceConnector.createExplicitFromImplicitIntent(mContext,
                 implicitIntent);
         Assert.assertNotNull(intent);
         ComponentName componentName = intent.getComponent();
         Assert.assertNotNull(componentName);
         Assert.assertEquals("com.android.nfc", componentName.getPackageName());
     }
+
+    @Test
+    public void testBindService() {
+        mDtaServiceConnector.bindService();
+        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+        ArgumentCaptor<ServiceConnection> serviceConnectionArgumentCaptor = ArgumentCaptor.forClass(
+                ServiceConnection.class);
+        verify(mContext).bindService(intentArgumentCaptor.capture(),
+                serviceConnectionArgumentCaptor.capture(), anyInt());
+        ServiceConnection serviceConnection = serviceConnectionArgumentCaptor.getValue();
+        Assert.assertNotNull(serviceConnection);
+        ComponentName componentName = mock(ComponentName.class);
+        serviceConnection.onServiceConnected(componentName, mock(IBinder.class));
+        assertThat(mDtaServiceConnector.dtaMessenger).isNotNull();
+        assertThat(mDtaServiceConnector.isBound).isTrue();
+
+        serviceConnection.onServiceDisconnected(componentName);
+        assertThat(mDtaServiceConnector.dtaMessenger).isNull();
+        assertThat(mDtaServiceConnector.isBound).isFalse();
+    }
+
+    @Test
+    public void testSendMessage() throws RemoteException {
+        mDtaServiceConnector.dtaMessenger = mock(Messenger.class);
+        mDtaServiceConnector.isBound = true;
+        mDtaServiceConnector.sendMessage("message");
+        verify(mDtaServiceConnector.dtaMessenger).send(any());
+    }
+
+    @Test
+    public void testSetMessageService() {
+        mDtaServiceConnector.isBound = false;
+        DtaServiceConnector.setMessageService("test");
+        ResolveInfo resolveInfo = mock(ResolveInfo.class);
+        resolveInfo.serviceInfo = mock(ServiceInfo.class);
+        resolveInfo.serviceInfo.packageName = "com.android.nfc";
+        resolveInfo.serviceInfo.name = "Nfc";
+        List<ResolveInfo> resolveInfos = new ArrayList<>();
+        resolveInfos.add(resolveInfo);
+        when(mPackageManager.queryIntentServices(any(), anyInt())).thenReturn(resolveInfos);
+        mDtaServiceConnector.bindService();
+        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
+        verify(mContext).bindService(intentArgumentCaptor.capture(), any(), anyInt());
+        Intent intent = intentArgumentCaptor.getValue();
+        Assert.assertNotNull(intent);
+        assertThat(intent.getAction()).isEqualTo("test");
+    }
 }
diff --git a/tests/unit/src/com/android/nfc/NfcDiagnosticsTest.java b/tests/unit/src/com/android/nfc/NfcDiagnosticsTest.java
new file mode 100644
index 00000000..c31c88ec
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/NfcDiagnosticsTest.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.nfc.NfcAdapter;
+import android.os.BugreportManager;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(AndroidJUnit4.class)
+public class NfcDiagnosticsTest {
+
+    private MockitoSession mStaticMockSession;
+    private NfcDiagnostics mNfcDiagnostics;
+    @Mock
+    Context mContext;
+    @Mock
+    PackageManager mPackageManager;
+    @Mock
+    BugreportManager mBugreportManager;
+    @Captor
+    ArgumentCaptor<Intent> mIntentArgumentCaptor;
+
+    @Before
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+
+        MockitoAnnotations.initMocks(this);
+
+        when(mContext.getSystemService(BugreportManager.class)).thenReturn(mBugreportManager);
+        List<ResolveInfo> list = new ArrayList<>();
+        list.add(mock(ResolveInfo.class));
+        when(mPackageManager.queryIntentActivities(any(), anyInt())).thenReturn(list);
+        when(mContext.getPackageManager()).thenReturn(mPackageManager);
+
+        mNfcDiagnostics = new NfcDiagnostics(mContext);
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testTakeBugReport() {
+        mNfcDiagnostics.takeBugReport("test1", "test description");
+        verify(mPackageManager).queryIntentActivities(mIntentArgumentCaptor.capture(), anyInt());
+        Intent intent = mIntentArgumentCaptor.getValue();
+        assertThat(intent).isNotNull();
+        assertThat(intent.getStringExtra("EXTRA_ISSUE_TITLE")).isEqualTo("test1");
+        assertThat(intent.getAction())
+                .isEqualTo("com.google.android.apps.betterbug.intent.FILE_BUG_DEEPLINK");
+        verify(mContext).startActivity(any());
+    }
+
+    @Test
+    public void testTakeBugreportThroughBugreportManager() {
+        when(mPackageManager.queryIntentActivities(any(), anyInt())).thenReturn(new ArrayList<>());
+        mNfcDiagnostics.takeBugReport("test1", "test description");
+        verify(mPackageManager).queryIntentActivities(mIntentArgumentCaptor.capture(), anyInt());
+        Intent intent = mIntentArgumentCaptor.getValue();
+        assertThat(intent).isNotNull();
+        assertThat(intent.getStringExtra("EXTRA_ISSUE_TITLE")).isEqualTo("test1");
+        assertThat(intent.getAction())
+                .isEqualTo("com.google.android.apps.betterbug.intent.FILE_BUG_DEEPLINK");
+        verify(mBugreportManager).requestBugreport(any(), anyString(), anyString());
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/NfcDispatcherTest.java b/tests/unit/src/com/android/nfc/NfcDispatcherTest.java
index 0cb4738c..a3479305 100644
--- a/tests/unit/src/com/android/nfc/NfcDispatcherTest.java
+++ b/tests/unit/src/com/android/nfc/NfcDispatcherTest.java
@@ -17,47 +17,72 @@ package com.android.nfc;
 
 import static android.nfc.tech.Ndef.EXTRA_NDEF_MSG;
 
-import static org.junit.Assert.assertNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.annotation.NonNull;
-import android.annotation.Nullable;
+import android.app.ActivityManager;
+import android.app.KeyguardManager;
 import android.app.PendingIntent;
 import android.bluetooth.BluetoothProtoEnums;
 import android.content.BroadcastReceiver;
 import android.content.Context;
-import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.content.res.Resources;
+import android.hardware.display.DisplayManager;
+import android.nfc.INfcOemExtensionCallback;
 import android.nfc.NdefMessage;
 import android.nfc.NdefRecord;
+import android.nfc.NfcAdapter;
 import android.nfc.Tag;
 import android.nfc.tech.Ndef;
+import android.nfc.tech.NfcBarcode;
+import android.nfc.tech.TagTechnology;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.Message;
 import android.os.PowerManager;
-import android.util.Log;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.os.test.TestLooper;
+
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
+import com.android.nfc.flags.FeatureFlags;
 import com.android.nfc.handover.HandoverDataParser;
+import com.android.nfc.handover.PeripheralHandoverService;
 
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
-import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
 import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 
 @RunWith(AndroidJUnit4.class)
@@ -67,52 +92,68 @@ public final class NfcDispatcherTest {
     @Mock private NfcInjector mNfcInjector;
     private MockitoSession mStaticMockSession;
     private NfcDispatcher mNfcDispatcher;
+    TestLooper mLooper;
 
+    @Mock
     private Context mockContext;
+    @Mock
+    private Resources mResources;
+    @Mock
+    private PackageManager mPackageManager;
+    @Mock
+    private PowerManager mPowerManager;
+    @Mock
+    KeyguardManager mKeyguardManager;
+    @Mock
+    DisplayManager mDisplayManager;
+    @Mock
+    UserManager mUserManager;
+    @Mock
+    ActivityManager mActivityManager;
+    @Mock
+    NfcAdapter mNfcAdapter;
+    @Mock
+    ForegroundUtils mForegroundUtils;
+    @Mock
+    AtomicBoolean mAtomicBoolean;
 
     @Before
-    public void setUp() {
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mLooper = new TestLooper();
         mStaticMockSession = ExtendedMockito.mockitoSession()
                 .mockStatic(NfcStatsLog.class)
+                .mockStatic(android.nfc.Flags.class)
+                .mockStatic(com.android.nfc.flags.Flags.class)
+                .mockStatic(NfcAdapter.class)
                 .mockStatic(Ndef.class)
+                .mockStatic(ForegroundUtils.class)
                 .mockStatic(NfcWifiProtectedSetup.class)
                 .strictness(Strictness.LENIENT)
                 .startMocking();
-	Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        PowerManager mockPowerManager = Mockito.mock(PowerManager.class);
-        when(mockPowerManager.isInteractive()).thenReturn(false);
-        Resources mockResources = Mockito.mock(Resources.class);
-        when(mockResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
-                .thenReturn(false);
-
-        mockContext = new ContextWrapper(context) {
-            @Override
-            public Object getSystemService(String name) {
-              if (Context.POWER_SERVICE.equals(name)) {
-                  Log.i(TAG, "[Mock] mockPowerManager");
-                  return mockPowerManager;
-              }
-              return super.getSystemService(name);
-            }
-
-            @Override
-            public Resources getResources() {
-                Log.i(TAG, "[Mock] getResources");
-                return mockResources;
-            }
-            @Override
-            public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver,
-                    @NonNull IntentFilter filter, @Nullable String broadcastPermission,
-                    @Nullable Handler scheduler){
-                Log.i(TAG, "[Mock] getIntent");
-                return Mockito.mock(Intent.class);
-            }
-        };
-
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(
-              () -> mNfcDispatcher = new NfcDispatcher(mockContext,
-                      new HandoverDataParser(), mNfcInjector, false));
-        Assert.assertNotNull(mNfcDispatcher);
+
+        MockitoAnnotations.initMocks(this);
+
+        when(mPowerManager.isInteractive()).thenReturn(false);
+        when(mockContext.getSystemService(PowerManager.class)).thenReturn(mPowerManager);
+        when(mockContext.getSystemService(KeyguardManager.class)).thenReturn(mKeyguardManager);
+        when(mockContext.getSystemService(DisplayManager.class)).thenReturn(mDisplayManager);
+        when(mockContext.getSystemService(UserManager.class)).thenReturn(mUserManager);
+        when(mockContext.getSystemService(ActivityManager.class)).thenReturn(mActivityManager);
+        when(ForegroundUtils.getInstance(mActivityManager)).thenReturn(mForegroundUtils);
+        when(mockContext.createPackageContextAsUser(anyString(), anyInt(), any()))
+                .thenReturn(mockContext);
+        when(mockContext.createContextAsUser(any(), anyInt())).thenReturn(mockContext);
+        when(mockContext.getPackageManager()).thenReturn(mPackageManager);
+        when(mPackageManager.getApplicationLabel(any())).thenReturn("");
+        when(mockContext.getApplicationContext()).thenReturn(mockContext);
+        when(mResources.getBoolean(R.bool.tag_intent_app_pref_supported)).thenReturn(true);
+        when(mockContext.getResources()).thenReturn(mResources);
+        when(NfcAdapter.getDefaultAdapter(mockContext)).thenReturn(mNfcAdapter);
+        when(mNfcInjector.createAtomicBoolean()).thenReturn(mAtomicBoolean);
+
+        mNfcDispatcher = new NfcDispatcher(mockContext,
+                new HandoverDataParser(), mNfcInjector, true);
+        mLooper.dispatchAll();
     }
 
     @After
@@ -124,41 +165,42 @@ public final class NfcDispatcherTest {
     public void testLogOthers() {
         Tag tag = Tag.createMockTag(null, new int[0], new Bundle[0], 0L);
         mNfcDispatcher.dispatchTag(tag);
+        ExtendedMockito.verify(() ->  NfcStatsLog.write(
+                NfcStatsLog.NFC_TAG_OCCURRED,
+                NfcStatsLog.NFC_TAG_OCCURRED__TYPE__PROVISION,
+                -1,
+                tag.getTechCodeList(),
+                BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
+                ""));
+    }
+
+    @Test
+    public void testSetForegroundDispatchForWifiConnect() {
+        PendingIntent pendingIntent = mock(PendingIntent.class);
+        mNfcDispatcher.setForegroundDispatch(pendingIntent, new IntentFilter[]{},
+                new String[][]{});
+        Bundle bundle = mock(Bundle.class);
+        when(bundle.getParcelable(EXTRA_NDEF_MSG, android.nfc.NdefMessage.class)).thenReturn(
+                mock(
+                        NdefMessage.class));
+        Tag tag = Tag.createMockTag(null, new int[]{1}, new Bundle[]{bundle}, 0L);
+        Ndef ndef = mock(Ndef.class);
+        when(Ndef.get(tag)).thenReturn(ndef);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        when(ndef.getCachedNdefMessage()).thenReturn(ndefMessage);
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        NdefRecord[] records = {ndefRecord};
+        when(ndefMessage.getRecords()).thenReturn(records);
+        when(NfcWifiProtectedSetup.tryNfcWifiSetup(ndef, mockContext)).thenReturn(true);
+        mNfcDispatcher.dispatchTag(tag);
         ExtendedMockito.verify(() -> NfcStatsLog.write(
                 NfcStatsLog.NFC_TAG_OCCURRED,
-                NfcStatsLog.NFC_TAG_OCCURRED__TYPE__OTHERS,
+                NfcStatsLog.NFC_TAG_OCCURRED__TYPE__WIFI_CONNECT,
                 -1,
                 tag.getTechCodeList(),
                 BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
                 ""));
     }
-        @Test
-        public void testSetForegroundDispatchForWifiConnect() {
-            PendingIntent pendingIntent = mock(PendingIntent.class);
-            mNfcDispatcher.setForegroundDispatch(pendingIntent, new IntentFilter[]{},
-                    new String[][]{});
-            Bundle bundle = mock(Bundle.class);
-            when(bundle.getParcelable(EXTRA_NDEF_MSG, android.nfc.NdefMessage.class)).thenReturn(
-                    mock(
-                            NdefMessage.class));
-            Tag tag = Tag.createMockTag(null, new int[]{1}, new Bundle[]{bundle}, 0L);
-            Ndef ndef = mock(Ndef.class);
-            when(Ndef.get(tag)).thenReturn(ndef);
-            NdefMessage ndefMessage = mock(NdefMessage.class);
-            when(ndef.getCachedNdefMessage()).thenReturn(ndefMessage);
-            NdefRecord ndefRecord = mock(NdefRecord.class);
-            NdefRecord[] records = {ndefRecord};
-            when(ndefMessage.getRecords()).thenReturn(records);
-            when(NfcWifiProtectedSetup.tryNfcWifiSetup(ndef, mockContext)).thenReturn(true);
-            mNfcDispatcher.dispatchTag(tag);
-            ExtendedMockito.verify(() -> NfcStatsLog.write(
-                    NfcStatsLog.NFC_TAG_OCCURRED,
-                    NfcStatsLog.NFC_TAG_OCCURRED__TYPE__WIFI_CONNECT,
-                    -1,
-                    tag.getTechCodeList(),
-                    BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
-                    ""));
-        }
 
     @Test
     public void testPeripheralHandoverBTParing() {
@@ -185,4 +227,283 @@ public final class NfcDispatcherTest {
                 BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
                 ""));
     }
+
+    @Test
+    public void testCheckForAar() {
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        when(ndefRecord.getTnf()).thenReturn(NdefRecord.TNF_EXTERNAL_TYPE);
+        when(ndefRecord.getType()).thenReturn(NdefRecord.RTD_ANDROID_APP);
+        when(ndefRecord.getPayload()).thenReturn("test".getBytes(StandardCharsets.US_ASCII));
+        String result = NfcDispatcher.checkForAar(ndefRecord);
+        assertThat(result).isEqualTo("test");
+    }
+
+    @Test
+    public void testCreateNfcResolverIntent() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported))).thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        ResolveInfo activity = mock(ResolveInfo.class);
+        ActivityInfo activityInfo = mock(ActivityInfo.class);
+        activityInfo.packageName = "com.android.nfc";
+        activityInfo.name = "test";
+        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
+        applicationInfo.uid = 0;
+        activityInfo.applicationInfo = applicationInfo;
+        activity.activityInfo = activityInfo;
+
+        ResolveInfo activity2 = mock(ResolveInfo.class);
+        ActivityInfo activityInfo2 = mock(ActivityInfo.class);
+        activityInfo2.packageName = "com.android.nfc2";
+        activityInfo2.name = "test2";
+        ApplicationInfo applicationInfo2 = mock(ApplicationInfo.class);
+        applicationInfo2.uid = 1;
+        activityInfo2.applicationInfo = applicationInfo2;
+        activity2.activityInfo = activityInfo2;
+
+        List<ResolveInfo> activities = new ArrayList<>();
+        activities.add(activity);
+        activities.add(activity2);
+        Map<String, Boolean> prefList = new HashMap<>();
+        prefList.put("com.android.nfc", false);
+        when(mNfcAdapter.getTagIntentAppPreferenceForUser(0)).thenReturn(prefList);
+        Assert.assertNotNull(dispatchInfo.intent);
+        dispatchInfo.intent.setAction(NfcAdapter.ACTION_TECH_DISCOVERED);
+        when(android.nfc.Flags.enableNfcMainline()).thenReturn(true);
+        when(com.android.nfc.flags.Flags.nfcAlertTagAppLaunch()).thenReturn(false);
+        dispatchInfo.checkPrefList(activities, 0);
+
+        assertThat(dispatchInfo.rootIntent).isNotNull();
+        assertThat(dispatchInfo.rootIntent.getAction()).isNotNull();
+        assertThat(dispatchInfo.rootIntent.getAction())
+                .isEqualTo(NfcAdapter.ACTION_SHOW_NFC_RESOLVER);
+    }
+
+    @Test
+    public void testDecodeNfcBarcodeUri() {
+        PendingIntent pendingIntent = mock(PendingIntent.class);
+        IntentFilter[] intentFilters = {};
+        String[][] techLists = {{"Ndef"}};
+        mNfcDispatcher.setForegroundDispatch(pendingIntent, intentFilters, techLists);
+        ArgumentCaptor<Integer> callingUid = ArgumentCaptor.forClass(Integer.class);
+        verify(mForegroundUtils).registerUidToBackgroundCallback(any(), callingUid.capture());
+        Tag tag = mock(Tag.class);
+        Bundle bundle = new Bundle();
+        bundle.putInt(NfcBarcode.EXTRA_BARCODE_TYPE, NfcBarcode.TYPE_KOVIO);
+        when(tag.getTechExtras(TagTechnology.NFC_BARCODE)).thenReturn(bundle);
+        when(tag.hasTech(TagTechnology.NFC_BARCODE)).thenReturn(true);
+        when(tag.getId()).thenReturn(new byte[]{0x04, 0x01, 0x64, 0x0C});
+        when(tag.getTechList()).thenReturn(new String[]{"Ndef"});
+        mNfcDispatcher.dispatchTag(tag);
+        ExtendedMockito.verify(() -> NfcStatsLog.write(
+                NfcStatsLog.NFC_TAG_OCCURRED,
+                NfcStatsLog.NFC_TAG_OCCURRED__TYPE__FOREGROUND_DISPATCH,
+                callingUid.getValue(),
+                tag.getTechCodeList(),
+                BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
+                ""));
+    }
+
+    @Test
+    public void testExtractAarPackages() {
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        when(ndefRecord.getTnf()).thenReturn(NdefRecord.TNF_EXTERNAL_TYPE);
+        when(ndefRecord.getType()).thenReturn(NdefRecord.RTD_ANDROID_APP);
+        when(ndefRecord.getPayload())
+                .thenReturn("com.android.test".getBytes(StandardCharsets.US_ASCII));
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        List<String> aarPackages = NfcDispatcher.extractAarPackages(ndefMessage);
+        assertThat(aarPackages).isNotNull();
+        assertThat(aarPackages.size()).isGreaterThan(0);
+        assertThat(aarPackages.get(0)).isEqualTo("com.android.test");
+    }
+
+    @Test
+    public void testFinalize() throws Throwable {
+        mNfcDispatcher.finalize();
+        ArgumentCaptor<BroadcastReceiver> receiverArgumentCaptor = ArgumentCaptor.forClass(
+                BroadcastReceiver.class);
+        verify(mockContext).unregisterReceiver(receiverArgumentCaptor.capture());
+        BroadcastReceiver broadcastReceiver = receiverArgumentCaptor.getValue();
+        assertThat(broadcastReceiver).isNotNull();
+    }
+
+    @Test
+    public void testGetAppSearchIntent() {
+        Intent intent = NfcDispatcher.getAppSearchIntent("com.android.test");
+        assertThat(intent).isNotNull();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void testGetOemAppSearchIntent() throws RemoteException {
+        INfcOemExtensionCallback nfcOemExtensionCallback = mock(INfcOemExtensionCallback.class);
+        mNfcDispatcher.setOemExtension(nfcOemExtensionCallback);
+        Intent intent = mNfcDispatcher.getOemAppSearchIntent("com.android.test");
+        ArgumentCaptor<NfcCallbackResultReceiver> argumentCaptor = ArgumentCaptor.forClass(
+                NfcCallbackResultReceiver.class);
+        verify(nfcOemExtensionCallback).onGetOemAppSearchIntent(any(), argumentCaptor.capture());
+        NfcCallbackResultReceiver nfcCallbackResultReceiver = argumentCaptor.getValue();
+        assertThat(nfcCallbackResultReceiver).isNotNull();
+    }
+
+    @Test
+    public void testIsComponentEnabled() throws PackageManager.NameNotFoundException {
+        PackageManager packageManager = mock(PackageManager.class);
+        ResolveInfo resolveInfo = mock(ResolveInfo.class);
+        ActivityInfo activityInfo = mock(ActivityInfo.class);
+        activityInfo.packageName = "com.android.test";
+        activityInfo.name = "test";
+        resolveInfo.activityInfo = activityInfo;
+        when(packageManager.getActivityInfo(any(), anyInt())).thenReturn(activityInfo);
+        boolean result = NfcDispatcher.isComponentEnabled(packageManager, resolveInfo);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testQueryNfcIntentActivitiesAsUser() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        UserHandle userHandle = mock(UserHandle.class);
+        List<UserHandle> luh = new ArrayList<>();
+        luh.add(userHandle);
+        when(mUserManager.getEnabledProfiles()).thenReturn(luh);
+        when(mUserManager.isQuietModeEnabled(userHandle)).thenReturn(true);
+        dispatchInfo.hasIntentReceiver();
+        verify(mPackageManager).queryIntentActivitiesAsUser(any(), any(), any());
+    }
+
+    @Test
+    public void testReceiveOemCallbackResult() throws  RemoteException {
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        INfcOemExtensionCallback nfcOemExtensionCallback = mock(INfcOemExtensionCallback.class);
+        mNfcDispatcher.setOemExtension(nfcOemExtensionCallback);
+        mNfcDispatcher.receiveOemCallbackResult(tag, ndefMessage);
+        verify(nfcOemExtensionCallback).onNdefMessage(any(), any(), any());
+    }
+
+    @Test
+    public void testTryNdef() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        UserHandle userHandle = mock(UserHandle.class);
+        List<UserHandle> luh = new ArrayList<>();
+        luh.add(userHandle);
+        when(mUserManager.getEnabledProfiles()).thenReturn(luh);
+        when(mUserManager.isQuietModeEnabled(userHandle)).thenReturn(false);
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        FeatureFlags featureFlags = mock(FeatureFlags.class);
+        when(featureFlags.sendViewIntentForUrlTagDispatch()).thenReturn(false);
+        when(mNfcInjector.getFeatureFlags()).thenReturn(featureFlags);
+        ResolveInfo ri = mock(ResolveInfo.class);
+        when(mPackageManager.resolveActivity(any(), anyInt())).thenReturn(ri);
+        mNfcDispatcher.tryNdef(dispatchInfo, ndefMessage);
+        verify(mPackageManager).resolveActivity(any(), anyInt());
+    }
+
+    @Test
+    public void testGetUri() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        String uri = dispatchInfo.getUri();
+        assertThat(uri).isNotNull();
+        assertThat(uri).isEqualTo("https://www.example.com");
+    }
+
+    @Test
+    public void testIsWebIntent() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        boolean webIntent = dispatchInfo.isWebIntent();
+        assertThat(webIntent).isTrue();
+    }
+
+    @Test
+    public void testSetViewIntent() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        Intent intent = dispatchInfo.setViewIntent();
+        assertThat(intent).isNotNull();
+        assertThat(intent.getAction()).isEqualTo(Intent.ACTION_VIEW);
+    }
+
+    @Test
+    public void testTryStartActivity() {
+        when(mResources.getBoolean(eq(R.bool.tag_intent_app_pref_supported)))
+                .thenReturn(true);
+        Tag tag = mock(Tag.class);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = NdefRecord.createUri("https://www.example.com");
+        when(ndefMessage.getRecords()).thenReturn(new NdefRecord[]{ndefRecord});
+        NfcDispatcher.DispatchInfo dispatchInfo = new NfcDispatcher
+                .DispatchInfo(mockContext, tag, ndefMessage);
+        ResolveInfo ri = mock(ResolveInfo.class);
+        ActivityInfo ai = mock(ActivityInfo.class);
+        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
+        applicationInfo.uid = 0;
+        ai.applicationInfo = applicationInfo;
+        ai.packageName = "com.android.test";
+        ai.name = "test";
+        ai.exported = true;
+        ri.activityInfo = ai;
+        List<ResolveInfo> ris = new ArrayList<>();
+        ris.add(ri);
+        when(mPackageManager.queryIntentActivitiesAsUser(any(), any(), any())).thenReturn(ris);
+        boolean result = dispatchInfo.tryStartActivity();
+        assertThat(result).isTrue();
+        ExtendedMockito.verify(() -> NfcStatsLog.write(NfcStatsLog.NFC_TAG_OCCURRED,
+                NfcStatsLog.NFC_TAG_OCCURRED__TYPE__APP_LAUNCH,
+                0,
+                tag.getTechCodeList(),
+                BluetoothProtoEnums.MAJOR_CLASS_UNCATEGORIZED,
+                ""));
+
+    }
+
+    @Test
+    public void testMessageHandler() {
+        Handler handler = mNfcDispatcher.getHandler();
+        Message msg = new Message();
+        msg.arg1 = 1;
+        msg.what = PeripheralHandoverService.MSG_HEADSET_NOT_CONNECTED;
+        handler.handleMessage(msg);
+        verify(mAtomicBoolean).set(true);
+    }
 }
diff --git a/tests/unit/src/com/android/nfc/NfcReaderConflictOccurredTest.java b/tests/unit/src/com/android/nfc/NfcReaderConflictOccurredTest.java
index f18ab9f9..8f1218eb 100644
--- a/tests/unit/src/com/android/nfc/NfcReaderConflictOccurredTest.java
+++ b/tests/unit/src/com/android/nfc/NfcReaderConflictOccurredTest.java
@@ -20,6 +20,7 @@ import static com.android.nfc.NfcDispatcher.DISPATCH_SUCCESS;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.mockingDetails;
 import static org.mockito.Mockito.when;
 
@@ -50,6 +51,7 @@ import com.android.nfc.handover.HandoverDataParser;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.After;
@@ -66,7 +68,9 @@ import org.mockito.quality.Strictness;
 public final class NfcReaderConflictOccurredTest {
 
     private static final String TAG = NfcReaderConflictOccurredTest.class.getSimpleName();
-    @Mock private NfcInjector mNfcInjector;
+    private NfcInjector mNfcInjector;
+    AtomicBoolean mAtomicBoolean;
+
     private MockitoSession mStaticMockSession;
     private NfcDispatcher mNfcDispatcher;
 
@@ -118,7 +122,10 @@ public final class NfcReaderConflictOccurredTest {
                 return Mockito.mock(Intent.class);
             }
         };
-
+        mNfcInjector = mock(NfcInjector.class);
+        NfcInjector.setNfcInjector(mNfcInjector);
+        mAtomicBoolean = mock(AtomicBoolean.class);
+        when(mNfcInjector.createAtomicBoolean()).thenReturn(mAtomicBoolean);
         InstrumentationRegistry.getInstrumentation().runOnMainSync(
               () -> mNfcDispatcher = new NfcDispatcher(
                       mockContext, new HandoverDataParser(), mNfcInjector, false));
diff --git a/tests/unit/src/com/android/nfc/NfcServiceTest.java b/tests/unit/src/com/android/nfc/NfcServiceTest.java
index ffc14093..001ef1e3 100644
--- a/tests/unit/src/com/android/nfc/NfcServiceTest.java
+++ b/tests/unit/src/com/android/nfc/NfcServiceTest.java
@@ -18,10 +18,14 @@ package com.android.nfc;
 import static android.nfc.NfcAdapter.ACTION_PREFERRED_PAYMENT_CHANGED;
 
 import static com.android.nfc.NfcService.INVALID_NATIVE_HANDLE;
+import static com.android.nfc.NfcService.NCI_VERSION_1_0;
+import static com.android.nfc.NfcService.NFC_LISTEN_A;
+import static com.android.nfc.NfcService.NFC_LISTEN_B;
+import static com.android.nfc.NfcService.NFC_LISTEN_F;
+import static com.android.nfc.NfcService.NFC_POLL_V;
 import static com.android.nfc.NfcService.PREF_NFC_ON;
 import static com.android.nfc.NfcService.SOUND_END;
 import static com.android.nfc.NfcService.SOUND_ERROR;
-import static com.android.nfc.NfcService.SOUND_END;
 
 import static com.google.common.truth.Truth.assertThat;
 
@@ -29,14 +33,15 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyFloat;
 import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.isNull;
+import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
@@ -44,10 +49,17 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
 
+import android.app.VrManager;
+import android.app.role.RoleManager;
+import android.hardware.display.DisplayManager;
+import android.nfc.ErrorCodes;
+import android.nfc.INfcUnlockHandler;
+
 import android.app.ActivityManager;
 import android.app.AlarmManager;
 import android.app.Application;
 import android.app.KeyguardManager;
+import android.app.VrManager;
 import android.app.backup.BackupManager;
 import android.content.BroadcastReceiver;
 import android.content.ContentResolver;
@@ -59,44 +71,68 @@ import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.database.ContentObserver;
+import android.hardware.display.DisplayManager;
 import android.media.SoundPool;
+import android.nfc.INfcOemExtensionCallback;
+import android.nfc.INfcUnlockHandler;
+import android.nfc.INfcVendorNciCallback;
+import android.nfc.INfcWlcStateListener;
 import android.nfc.NdefMessage;
+import android.nfc.NdefRecord;
 import android.nfc.NfcAdapter;
 import android.nfc.NfcAntennaInfo;
+import android.nfc.NfcOemExtension;
 import android.nfc.NfcServiceManager;
 import android.nfc.Tag;
+import android.nfc.TransceiveResult;
+import android.nfc.WlcListenerDeviceInfo;
 import android.nfc.cardemulation.CardEmulation;
+import android.nfc.cardemulation.PollingFrame;
 import android.nfc.tech.Ndef;
 import android.nfc.tech.TagTechnology;
 import android.os.AsyncTask;
+import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.IBinder;
 import android.os.Message;
+import android.os.ParcelFileDescriptor;
 import android.os.PowerManager;
 import android.os.RemoteException;
 import android.os.ResultReceiver;
+import android.os.SystemClock;
+import android.os.UserHandle;
 import android.os.UserManager;
 import android.os.test.TestLooper;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.se.omapi.ISecureElementService;
 import android.sysprop.NfcProperties;
 import android.nfc.INfcOemExtensionCallback;
+import android.view.Display;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
-
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.cardemulation.CardEmulationManager;
+import com.android.nfc.cardemulation.util.StatsdUtils;
 import com.android.nfc.flags.FeatureFlags;
+import com.android.nfc.flags.Flags;
+import com.android.nfc.wlc.NfcCharging;
 
+import android.nfc.INfcVendorNciCallback;
 
 import org.junit.After;
 import org.junit.Assert;
+import org.junit.Assume;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
+import org.mockito.ArgumentMatchers;
 import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
@@ -105,10 +141,20 @@ import org.mockito.invocation.InvocationOnMock;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
 
+import java.io.FileDescriptor;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
+import android.nfc.INfcWlcStateListener;
+import android.nfc.INfcUnlockHandler;
+import android.nfc.INfcAdapterExtras;
+import android.nfc.INfcDta;
+import android.nfc.ITagRemovedCallback;
+import android.nfc.INfcControllerAlwaysOnListener;
 
 @RunWith(AndroidJUnit4.class)
 public final class NfcServiceTest {
@@ -142,29 +188,56 @@ public final class NfcServiceTest {
     @Mock AlarmManager mAlarmManager;
     @Mock SoundPool mSoundPool;
     @Mock FeatureFlags mFeatureFlags;
+    @Mock DisplayManager mDisplayManager;
+    @Mock CardEmulationManager mCardEmulationManager;
+    @Mock StatsdUtils mStatsdUtils;
+    @Mock NfcCharging mNfcCharging;
+    @Mock VrManager mVrManager;
+    @Mock RoleManager mRoleManager;
     @Captor ArgumentCaptor<DeviceHost.DeviceHostListener> mDeviceHostListener;
     @Captor ArgumentCaptor<BroadcastReceiver> mGlobalReceiver;
     @Captor ArgumentCaptor<IBinder> mIBinderArgumentCaptor;
     @Captor ArgumentCaptor<Integer> mSoundCaptor;
     @Captor ArgumentCaptor<Intent> mIntentArgumentCaptor;
     @Captor ArgumentCaptor<ContentObserver> mContentObserverArgumentCaptor;
+    @Captor ArgumentCaptor<BroadcastReceiver> mBroadcastReceiverArgumentCaptor;
     TestLooper mLooper;
     NfcService mNfcService;
     private MockitoSession mStaticMockSession;
     private ContentObserver mContentObserver;
+    private TestClock mClock = new TestClock();
+
+    class TestClock implements TestLooper.Clock {
+        long mOffset = 0;
+        public long uptimeMillis() {
+            return SystemClock.uptimeMillis() + mOffset;
+        }
+    }
+
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
 
     @Before
-    public void setUp() {
-        mLooper = new TestLooper();
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mLooper = new TestLooper(mClock);
         mStaticMockSession = ExtendedMockito.mockitoSession()
                 .mockStatic(NfcProperties.class)
                 .mockStatic(android.nfc.Flags.class)
+                .mockStatic(com.android.nfc.flags.Flags.class)
                 .mockStatic(NfcStatsLog.class)
+                .mockStatic(android.permission.flags.Flags.class)
+                .mockStatic(NfcInjector.class)
                 .strictness(Strictness.LENIENT)
                 .startMocking();
         MockitoAnnotations.initMocks(this);
         AsyncTask.setDefaultExecutor(new HandlerExecutor(new Handler(mLooper.getLooper())));
 
+        when(mPackageManager.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION))
+                .thenReturn(true);
+        when(mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH))
+                .thenReturn(false);
+        when(mPackageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE))
+                .thenReturn(true);
         when(mNfcInjector.getMainLooper()).thenReturn(mLooper.getLooper());
         when(mNfcInjector.getNfcEventLog()).thenReturn(mNfcEventLog);
         when(mNfcInjector.makeDeviceHost(any())).thenReturn(mDeviceHost);
@@ -177,6 +250,8 @@ public final class NfcServiceTest {
         when(mNfcInjector.getNfcUnlockManager()).thenReturn(mNfcUnlockManager);
         when(mNfcInjector.getFeatureFlags()).thenReturn(mFeatureFlags);
         when(mNfcInjector.isSatelliteModeSensitive()).thenReturn(true);
+        when(mNfcInjector.getCardEmulationManager()).thenReturn(mCardEmulationManager);
+        when(mNfcInjector.getNfcCharging(mDeviceHost)).thenReturn(mNfcCharging);
         when(mApplication.getSharedPreferences(anyString(), anyInt())).thenReturn(mPreferences);
         when(mApplication.getSystemService(PowerManager.class)).thenReturn(mPowerManager);
         when(mApplication.getSystemService(UserManager.class)).thenReturn(mUserManager);
@@ -184,19 +259,29 @@ public final class NfcServiceTest {
         when(mApplication.getSystemService(KeyguardManager.class)).thenReturn(mKeyguardManager);
         when(mApplication.getSystemService(AlarmManager.class)).thenReturn(mAlarmManager);
         when(mApplication.getPackageManager()).thenReturn(mPackageManager);
+        when(mResources.getBoolean(R.bool.check_display_state_for_screen_state)).thenReturn(true);
         when(mApplication.getResources()).thenReturn(mResources);
         when(mApplication.createContextAsUser(any(), anyInt())).thenReturn(mApplication);
         when(mApplication.getContentResolver()).thenReturn(mContentResolver);
+        when(mApplication.getSystemService(DisplayManager.class)).thenReturn(mDisplayManager);
+        when(mApplication.getSystemService(VrManager.class)).thenReturn(mVrManager);
+        when(mApplication.getSystemService(RoleManager.class)).thenReturn(mRoleManager);
         when(mUserManager.getUserRestrictions()).thenReturn(mUserRestrictions);
         when(mResources.getStringArray(R.array.nfc_allow_list)).thenReturn(new String[0]);
+        when(mResources.getBoolean(R.bool.tag_intent_app_pref_supported)).thenReturn(true);
+        when(mResources.getBoolean(R.bool.nfcc_always_on_allowed)).thenReturn(true);
         when(mPreferences.edit()).thenReturn(mPreferencesEditor);
         when(mPowerManager.newWakeLock(anyInt(), anyString()))
                 .thenReturn(mock(PowerManager.WakeLock.class));
         when(mResources.getIntArray(R.array.antenna_x)).thenReturn(new int[0]);
         when(mResources.getIntArray(R.array.antenna_y)).thenReturn(new int[0]);
+        when(mResources.getStringArray(R.array.tag_intent_blocked_app_list))
+                .thenReturn(new String[]{});
         when(NfcProperties.info_antpos_X()).thenReturn(List.of());
         when(NfcProperties.info_antpos_Y()).thenReturn(List.of());
         when(NfcProperties.initialized()).thenReturn(Optional.of(Boolean.TRUE));
+        when(NfcProperties.vendor_debug_enabled()).thenReturn(Optional.of(Boolean.TRUE));
+        when(mPackageManager.getPackageUid(PKG_NAME, 0)).thenReturn(Binder.getCallingUid());
         createNfcService();
     }
 
@@ -219,9 +304,16 @@ public final class NfcServiceTest {
         verify(mApplication).registerReceiverForAllUsers(
                 mGlobalReceiver.capture(),
                 argThat(intent -> intent.hasAction(Intent.ACTION_SCREEN_ON)), any(), any());
+        verify(mApplication).registerReceiver(mBroadcastReceiverArgumentCaptor.capture(),
+                argThat(intent -> intent.hasAction(UserManager.ACTION_USER_RESTRICTIONS_CHANGED)));
         clearInvocations(mDeviceHost, mNfcInjector, mApplication);
     }
 
+    private void createNfcServiceWithoutStatsdUtils() {
+        when(mNfcInjector.getStatsdUtils()).thenReturn(mStatsdUtils);
+        createNfcService();
+    }
+
     private void enableAndVerify() throws Exception {
         when(mDeviceHost.initialize()).thenReturn(true);
         when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
@@ -305,7 +397,7 @@ public final class NfcServiceTest {
     public void testSetObserveMode_nfcDisabled() throws Exception {
         mNfcService.mNfcAdapter.disable(true, PKG_NAME);
 
-        Assert.assertFalse(mNfcService.mNfcAdapter.setObserveMode(true, null));
+        Assert.assertFalse(mNfcService.mNfcAdapter.setObserveMode(true, PKG_NAME));
     }
 
     @Test
@@ -514,6 +606,13 @@ public final class NfcServiceTest {
         Assert.assertEquals(mNfcService.mErrorSound, (int) value);
     }
 
+    @Test
+    public void testReleaseSoundPool() {
+        mNfcService.mSoundPool = mSoundPool;
+        mNfcService.releaseSoundPool();
+        Assert.assertNull(mNfcService.mSoundPool);
+    }
+
     @Test
     public void testMsg_Rf_Field_Activated() {
         Handler handler = mNfcService.getHandler();
@@ -524,7 +623,7 @@ public final class NfcServiceTest {
         mNfcService.mNfcEventInstalledPackages.put(1, userlist);
         mNfcService.mIsSecureNfcEnabled = true;
         mNfcService.mIsRequestUnlockShowed = false;
-        when(mKeyguardManager.isKeyguardLocked()).thenReturn(true);
+        when(mNfcInjector.isDeviceLocked()).thenReturn(true);
         handler.handleMessage(msg);
         verify(mApplication).sendBroadcastAsUser(mIntentArgumentCaptor.capture(), any());
         Intent intent = mIntentArgumentCaptor.getValue();
@@ -726,12 +825,16 @@ public final class NfcServiceTest {
         Handler handler = mNfcService.getHandler();
         Assert.assertNotNull(handler);
         Message msg = handler.obtainMessage(NfcService.MSG_UPDATE_TECHNOLOGY_ABF_ROUTE);
-        msg.obj = 1;
+        msg.arg1 = 1;
+        msg.arg2 = 2;
         handler.handleMessage(msg);
         ArgumentCaptor<Integer> flagCaptor = ArgumentCaptor.forClass(Integer.class);
-        verify(mDeviceHost).setTechnologyABFRoute(flagCaptor.capture());
+        ArgumentCaptor<Integer> flagCaptor2 = ArgumentCaptor.forClass(Integer.class);
+        verify(mDeviceHost).setTechnologyABFRoute(flagCaptor.capture(), flagCaptor2.capture());
         int flag = flagCaptor.getValue();
         Assert.assertEquals(1, flag);
+        int flag2 = flagCaptor2.getValue();
+        Assert.assertEquals(2, flag2);
     }
 
     @Test
@@ -750,7 +853,16 @@ public final class NfcServiceTest {
         Context ceContext = mock(Context.class);
         when(mApplication.createCredentialProtectedStorageContext()).thenReturn(ceContext);
         when(ceContext.getSharedPreferences(anyString(), anyInt())).thenReturn(mPreferences);
+        doAnswer(new Answer() {
+            @Override
+            public Map<String, ?> answer(InvocationOnMock invocation) throws Throwable {
+                Map<String, Object> prefMap = Map.of(PREF_NFC_ON, true);
+                return prefMap;
+            }
+        }).when(mPreferences).getAll();
         when(mApplication.moveSharedPreferencesFrom(ceContext, NfcService.PREF)).thenReturn(true);
+        when(mApplication.moveSharedPreferencesFrom(ceContext, NfcService.PREF_TAG_APP_LIST))
+            .thenReturn(true);
         mGlobalReceiver.getValue().onReceive(mApplication, new Intent(Intent.ACTION_USER_UNLOCKED));
         verify(mApplication).moveSharedPreferencesFrom(ceContext, NfcService.PREF);
         verify(mApplication).getSharedPreferences(eq(NfcService.PREF), anyInt());
@@ -804,4 +916,1349 @@ public final class NfcServiceTest {
         ResultReceiver resultReceiver = receiverArgumentCaptor.getValue();
         Assert.assertNotNull(resultReceiver);
     }
+
+    @Test
+    public void testAllowOemOnNdefReadCallback() throws Exception {
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        Handler handler = mNfcService.getHandler();
+        Assert.assertNotNull(handler);
+        Message msg = handler.obtainMessage(NfcService.MSG_NDEF_TAG);
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getConnectedTechnology()).thenReturn(TagTechnology.NDEF);
+        when(tagEndpoint.getUid()).thenReturn(NfcService
+                .hexStringToBytes("0x040000010100000000000000"));
+        when(tagEndpoint.getTechList()).thenReturn(new int[]{Ndef.NDEF});
+        when(tagEndpoint.getTechExtras()).thenReturn(new Bundle[]{});
+        when(tagEndpoint.getHandle()).thenReturn(1);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        when(tagEndpoint.findAndReadNdef()).thenReturn(ndefMessage);
+        msg.obj = tagEndpoint;
+        mNfcService.mIsWlcEnabled = true;
+        mNfcService.mIsRWCapable = true;
+        handler.handleMessage(msg);
+        verify(tagEndpoint, atLeastOnce()).startPresenceChecking(anyInt(), any());
+        ArgumentCaptor<Tag> tagCaptor = ArgumentCaptor
+                .forClass(Tag.class);
+        verify(mNfcDispatcher).dispatchTag(tagCaptor.capture());
+        Tag tag = tagCaptor.getValue();
+        Assert.assertNotNull(tag);
+        Assert.assertEquals("android.nfc.tech.Ndef", tag.getTechList()[0]);
+
+        doAnswer(new Answer() {
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                ResultReceiver r = invocation.getArgument(0);
+                r.send(1, null);
+                return null;
+            }
+        }).when(callback).onNdefRead(any(ResultReceiver.class));
+        mContentObserver.onChange(true);
+        ArgumentCaptor<ResultReceiver> receiverArgumentCaptor = ArgumentCaptor
+                .forClass(ResultReceiver.class);
+        verify(callback).onNdefRead(receiverArgumentCaptor.capture());
+        ResultReceiver resultReceiver = receiverArgumentCaptor.getValue();
+        Assert.assertNotNull(resultReceiver);
+    }
+
+    @Test
+    public void testAllowOemOnApplyRoutingCallback() throws Exception {
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        INfcUnlockHandler binder = mock(INfcUnlockHandler.class);
+        mNfcService.mNfcAdapter.removeNfcUnlockHandler(binder);
+
+        doAnswer(new Answer() {
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                ResultReceiver r = invocation.getArgument(0);
+                r.send(1, null);
+                return null;
+            }
+        }).when(callback).onApplyRouting(any(ResultReceiver.class));
+        mContentObserver.onChange(true);
+        ArgumentCaptor<ResultReceiver> receiverArgumentCaptor = ArgumentCaptor
+                .forClass(ResultReceiver.class);
+        verify(callback).onApplyRouting(receiverArgumentCaptor.capture());
+        ResultReceiver resultReceiver = receiverArgumentCaptor.getValue();
+        Assert.assertNotNull(resultReceiver);
+    }
+
+    @Test
+    public void testThermalStatusChangeListener() {
+        Assert.assertNotNull(mPowerManager);
+        ArgumentCaptor<PowerManager.OnThermalStatusChangedListener> argumentCaptor =
+                ArgumentCaptor.forClass(PowerManager.OnThermalStatusChangedListener.class);
+        verify(mPowerManager).addThermalStatusListener(any(), argumentCaptor.capture());
+        PowerManager.OnThermalStatusChangedListener changedListener =
+                argumentCaptor.getValue();
+        Assert.assertNotNull(changedListener);
+        changedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_MODERATE);
+        changedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_SEVERE);
+        changedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_CRITICAL);
+        changedListener.onThermalStatusChanged(0);
+    }
+
+    @Test
+    public void testClearRoutingTable() {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.clearRoutingTable(1);
+        mLooper.dispatchAll();
+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
+        verify(mDeviceHost).clearRoutingEntry(captor.capture());
+        int flag = captor.getValue();
+        Assert.assertEquals(1, flag);
+    }
+
+    @Test
+    public void testDeregisterT3tIdentifier() {
+        NfcDiscoveryParameters nfcDiscoveryParameters = mock(NfcDiscoveryParameters.class);
+        when(nfcDiscoveryParameters.shouldEnableDiscovery()).thenReturn(true);
+        mNfcService.mCurrentDiscoveryParameters = nfcDiscoveryParameters;
+        mNfcService.deregisterT3tIdentifier("02FE", "02FEC1DE32456789", "F0010203");
+        mLooper.dispatchAll();
+        verify(mDeviceHost).disableDiscovery();
+        ArgumentCaptor<byte[]> t3tIdentifierByteArray = ArgumentCaptor.forClass(byte[].class);
+        verify(mDeviceHost).deregisterT3tIdentifier(t3tIdentifierByteArray.capture());
+        byte[] data = t3tIdentifierByteArray.getValue();
+        Assert.assertNotNull(data);
+        String msg = new String(data, StandardCharsets.UTF_8);
+        Assert.assertNotNull(msg);
+        verify(mDeviceHost).enableDiscovery(any(), anyBoolean());
+    }
+
+    @Test
+    public void testFindAndRemoveObject() {
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getHandle()).thenReturn(1);
+        mNfcService.registerTagObject(tagEndpoint);
+        DeviceHost.TagEndpoint device = (DeviceHost.TagEndpoint) mNfcService.mObjectMap.get(1);
+        Assert.assertNotNull(device);
+        Assert.assertEquals(tagEndpoint, device);
+        mNfcService.findAndRemoveObject(1);
+        Object obj = mNfcService.mObjectMap.get(1);
+        Assert.assertNull(obj);
+    }
+
+    @Test
+    public void testDisplayManagerCallback() {
+        ArgumentCaptor<DisplayManager.DisplayListener> displayListenerArgumentCaptor =
+                ArgumentCaptor.forClass(DisplayManager.DisplayListener.class);
+        ArgumentCaptor<NfcService.NfcServiceHandler> nfcServiceHandlerArgumentCaptor =
+                ArgumentCaptor.forClass(NfcService.NfcServiceHandler.class);
+        verify(mDisplayManager).registerDisplayListener(displayListenerArgumentCaptor.capture(),
+                nfcServiceHandlerArgumentCaptor.capture());
+        DisplayManager.DisplayListener displayListener = displayListenerArgumentCaptor.getValue();
+        Assert.assertNotNull(displayListener);
+        NfcService.NfcServiceHandler handler = nfcServiceHandlerArgumentCaptor.getValue();
+        Assert.assertNotNull(handler);
+        displayListener.onDisplayAdded(Display.DEFAULT_DISPLAY);
+        displayListener.onDisplayRemoved(Display.DEFAULT_DISPLAY);
+        mNfcService.mIsWlcCapable = false;
+        when(mScreenStateHelper.checkScreenState(anyBoolean()))
+                .thenReturn(ScreenStateHelper.SCREEN_STATE_ON_LOCKED);
+        mNfcService.mScreenState = ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED;
+        displayListener.onDisplayChanged(Display.DEFAULT_DISPLAY);
+        mLooper.dispatchAll();
+        Assert.assertFalse(handler.hasMessages(NfcService.MSG_DELAY_POLLING));
+        Assert.assertFalse(mNfcService.mIsRequestUnlockShowed);
+        verify(mDeviceHost).doSetScreenState(anyInt(), anyBoolean());
+    }
+
+    @Test
+    public void testThermalStatusListener() {
+        Assert.assertNotNull(mPowerManager);
+        ArgumentCaptor<PowerManager.OnThermalStatusChangedListener> argumentCaptor =
+                ArgumentCaptor.forClass(PowerManager.OnThermalStatusChangedListener.class);
+        verify(mPowerManager).addThermalStatusListener(any(), argumentCaptor.capture());
+        PowerManager.OnThermalStatusChangedListener thermalStatusChangedListener =
+                argumentCaptor.getValue();
+        Assert.assertNotNull(thermalStatusChangedListener);
+        thermalStatusChangedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_MODERATE);
+        thermalStatusChangedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_SEVERE);
+        thermalStatusChangedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_CRITICAL);
+        thermalStatusChangedListener.onThermalStatusChanged(PowerManager.THERMAL_STATUS_SHUTDOWN);
+    }
+
+    @Test
+    public void testGetAppName() throws RemoteException, PackageManager.NameNotFoundException {
+        String[] packages = {"com.android.test1"};
+        when(mResources.getStringArray(R.array.nfc_allow_list)).thenReturn(packages);
+        mNfcService.mNfcAdapter.enable(PKG_NAME);
+        ArgumentCaptor<String> stringArgumentCaptor = ArgumentCaptor.forClass(String.class);
+        verify(mPackageManager).getApplicationInfoAsUser(stringArgumentCaptor.capture(), anyInt(),
+                any());
+        assertThat(PKG_NAME).isEqualTo(stringArgumentCaptor.getValue());
+        verify(mPackageManager, atLeastOnce()).getApplicationLabel(any());
+    }
+
+    @Test
+    public void testFindObject() {
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getHandle()).thenReturn(1);
+        mNfcService.registerTagObject(tagEndpoint);
+        DeviceHost.TagEndpoint device = (DeviceHost.TagEndpoint) mNfcService.mObjectMap.get(1);
+        Assert.assertNotNull(device);
+        Assert.assertEquals(tagEndpoint, device);
+        Object obj = mNfcService.findObject(1);
+        Assert.assertNotNull(obj);
+        Object object = mNfcService.mObjectMap.get(1);
+        Assert.assertNotNull(object);
+        assertThat(obj).isEqualTo(object);
+    }
+
+    @Test
+    public void testGetEnabledUserIds() {
+        when(mPreferences.getBoolean(anyString(), anyBoolean())).thenReturn(true);
+        Assert.assertTrue(mNfcService.getNfcOnSetting());
+        when(mNfcInjector.isSatelliteModeOn()).thenReturn(false);
+        when(mUserRestrictions.getBoolean(UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO))
+                .thenReturn(false);
+        NfcService.sIsNfcRestore = true;
+        UserHandle uh = mock(UserHandle.class);
+        when(uh.getIdentifier()).thenReturn(1);
+        List<UserHandle> luh = new ArrayList<>();
+        luh.add(uh);
+        when(mUserManager.getEnabledProfiles()).thenReturn(luh);
+        mNfcService.enableNfc();
+        verify(mPreferences).edit();
+        verify(mPreferencesEditor).putBoolean(PREF_NFC_ON, true);
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+        mLooper.dispatchAll();
+        verify(mUserManager, atLeastOnce()).getEnabledProfiles();
+    }
+
+    @Test
+    public void testGetLfT3tMax() {
+        int lfT3t = mNfcService.getLfT3tMax();
+        assertThat(lfT3t).isEqualTo(0);
+        when(mDeviceHost.getLfT3tMax()).thenReturn(100);
+        lfT3t = mNfcService.getLfT3tMax();
+        assertThat(lfT3t).isEqualTo(100);
+        verify(mDeviceHost, atLeastOnce()).getLfT3tMax();
+    }
+
+    @Test
+    public void testGetNfcPollTech() {
+        int pollTech = mNfcService.getNfcPollTech();
+        assertThat(pollTech).isEqualTo(0);
+        when(mPreferences.getInt(NfcService.PREF_POLL_TECH, NfcService.DEFAULT_POLL_TECH))
+                .thenReturn(NfcService.DEFAULT_LISTEN_TECH);
+        pollTech = mNfcService.getNfcPollTech();
+        assertThat(pollTech).isEqualTo(0xf);
+        verify(mPreferences, atLeastOnce()).getInt(anyString(), anyInt());
+    }
+
+    @Test
+    public void testIsPackageInstalled() {
+        when(mPreferences.getBoolean(anyString(), anyBoolean())).thenReturn(true);
+        String jsonString = "{}";
+        when(mPreferences.getString(anyString(), anyString())).thenReturn(jsonString);
+        Assert.assertTrue(mNfcService.getNfcOnSetting());
+        when(mNfcInjector.isSatelliteModeOn()).thenReturn(false);
+        when(mUserRestrictions.getBoolean(UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO))
+                .thenReturn(false);
+        NfcService.sIsNfcRestore = true;
+        UserHandle uh = mock(UserHandle.class);
+        when(uh.getIdentifier()).thenReturn(1);
+        List<UserHandle> luh = new ArrayList<>();
+        luh.add(uh);
+        when(mUserManager.getEnabledProfiles()).thenReturn(luh);
+        mNfcService.mTagAppDefaultBlockList.add("com.android.test");
+        mNfcService.enableNfc();
+        verify(mPreferences).edit();
+        verify(mPreferencesEditor).putBoolean(PREF_NFC_ON, true);
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+        mLooper.dispatchAll();
+        verify(mUserManager, atLeastOnce()).getEnabledProfiles();
+        verify(mApplication, atLeastOnce()).createContextAsUser(any(), anyInt());
+    }
+
+    @Test
+    public void testIsSecureNfcEnabled() {
+        mNfcService.mIsSecureNfcEnabled = true;
+        boolean isSecureNfcEnabled = mNfcService.isSecureNfcEnabled();
+        assertThat(isSecureNfcEnabled).isTrue();
+        mNfcService.mIsSecureNfcEnabled = false;
+        isSecureNfcEnabled = mNfcService.isSecureNfcEnabled();
+        assertThat(isSecureNfcEnabled).isFalse();
+    }
+
+    @Test
+    public void testIsTagPresent() throws RemoteException {
+        boolean isTagPresent = mNfcService.mNfcAdapter.isTagPresent();
+        assertThat(isTagPresent).isFalse();
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.isPresent()).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        isTagPresent = mNfcService.mNfcAdapter.isTagPresent();
+        assertThat(isTagPresent).isTrue();
+
+    }
+
+    @Test
+    public void testOnObserveModeStateChanged() {
+        when(com.android.nfc.flags.Flags.postCallbacks()).thenReturn(true);
+        mNfcService.onObserveModeStateChanged(true);
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager, atLeastOnce()).onObserveModeStateChange(anyBoolean());
+        when(com.android.nfc.flags.Flags.postCallbacks()).thenReturn(false);
+        mNfcService.onObserveModeStateChanged(false);
+        verify(mCardEmulationManager, atLeastOnce()).onObserveModeStateChange(anyBoolean());
+    }
+
+    @Test
+    public void testOnPollingLoopDetected() {
+        PollingFrame pollingFrame = mock(PollingFrame.class);
+        List<PollingFrame> frames = new ArrayList<>();
+        frames.add(pollingFrame);
+        when(android.nfc.Flags.nfcReadPollingLoop()).thenReturn(true);
+        when(com.android.nfc.flags.Flags.postCallbacks()).thenReturn(true);
+        mNfcService.onPollingLoopDetected(frames);
+        mLooper.dispatchAll();
+        ArgumentCaptor<List<PollingFrame>> listArgumentCaptor = ArgumentCaptor.forClass(List.class);
+        verify(mCardEmulationManager).onPollingLoopDetected(listArgumentCaptor.capture());
+        assertThat(frames).isEqualTo(listArgumentCaptor.getValue());
+        when(com.android.nfc.flags.Flags.postCallbacks()).thenReturn(false);
+        mNfcService.onPollingLoopDetected(frames);
+        verify(mCardEmulationManager, atLeastOnce()).onPollingLoopDetected(listArgumentCaptor.capture());
+        assertThat(frames).isEqualTo(listArgumentCaptor.getValue());
+    }
+
+    @Test
+    public void testOnVendorSpecificEvent() throws RemoteException {
+        INfcVendorNciCallback callback = mock(INfcVendorNciCallback.class);
+        mNfcService.mNfcAdapter.registerVendorExtensionCallback(callback);
+        verify(mDeviceHost).enableVendorNciNotifications(true);
+        mNfcService.onVendorSpecificEvent(1, 2, "test".getBytes());
+        mLooper.dispatchAll();
+        verify(callback).onVendorNotificationReceived(anyInt(), anyInt(), any());
+    }
+
+    @Test
+    public void testOnHostCardEmulationActivated() throws RemoteException {
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        verify(callback).onCardEmulationActivated(anyBoolean());
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.onHostCardEmulationActivated(1);
+        verify(mCardEmulationManager).onHostCardEmulationActivated(anyInt());
+        verify(mNfcEventLog, times(2)).logEvent(any());
+    }
+
+    @Test
+    public void testOnHostCardEmulationDeactivated()  throws RemoteException {
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        verify(callback).onCardEmulationActivated(false);
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.onHostCardEmulationDeactivated(1);
+        verify(mCardEmulationManager).onHostCardEmulationDeactivated(anyInt());
+        verify(mNfcEventLog, times(2)).logEvent(any());
+    }
+
+    @Test
+    public void testOnEeUpdated() {
+        mNfcService.onEeUpdated();
+        mLooper.dispatchAll();
+        Assert.assertEquals(0, mNfcService.mScreenState);
+    }
+
+    @Test
+    public void testOnHwErrorReported() {
+        when(mPreferences.getBoolean(anyString(), anyBoolean())).thenReturn(true);
+        Assert.assertTrue(mNfcService.getNfcOnSetting());
+        when(mNfcInjector.isSatelliteModeOn()).thenReturn(false);
+        when(mUserRestrictions.getBoolean(UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO))
+                .thenReturn(false);
+        NfcService.sIsNfcRestore = true;
+        mNfcService.mState = NfcAdapter.STATE_OFF;
+        mNfcService.onHwErrorReported();
+        verify(mApplication).unregisterReceiver(any());
+        assertThat(mNfcService.mIsRecovering).isTrue();
+        mLooper.dispatchAll();
+        verify(mUserManager, atLeastOnce()).getEnabledProfiles();
+    }
+
+    @Test
+    public void testOnNfcTransactionEvent() throws RemoteException {
+        ISecureElementService iSecureElementService = mock(ISecureElementService.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(iSecureElementService.asBinder()).thenReturn(iBinder);
+        boolean[] nfcAccess = {true};
+        when(iSecureElementService.isNfcEventAllowed(anyString(), any(), any(), anyInt()))
+                .thenReturn(nfcAccess);
+        when(mNfcInjector.connectToSeService()).thenReturn(iSecureElementService);
+        List<String> packages = new ArrayList<>();
+        packages.add("com.android.test");
+        mNfcService.mNfcEventInstalledPackages.put(1, packages);
+        when(mCardEmulationManager.getRegisteredAidCategory(anyString()))
+                .thenReturn(CardEmulation.CATEGORY_PAYMENT);
+        byte[] aid = { 0x0A, 0x00, 0x00, 0x00 };
+        byte[] data = { 0x12, 0x34, 0x56, 0x78, 0x78 };
+        mNfcService.onNfcTransactionEvent(aid, data, "SecureElement1");
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager).onOffHostAidSelected();
+        verify(mPackageManager).queryBroadcastReceiversAsUser(any(), anyInt(), any());
+        verify(mApplication).sendBroadcastAsUser(any(), any(), ArgumentMatchers.isNull(), any());
+    }
+
+    @Test
+    public void testOnRemoteEndpointDiscovered() {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        NfcService.ReaderModeParams readerModeParams = mock(NfcService.ReaderModeParams.class);
+        readerModeParams.presenceCheckDelay = 1;
+        readerModeParams.flags = 129;
+        mNfcService.mReaderModeParams = readerModeParams;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        mNfcService.onRemoteEndpointDiscovered(tagEndpoint);
+        mLooper.dispatchAll();
+        verify(tagEndpoint).startPresenceChecking(anyInt(), any());
+    }
+
+    @Test
+    public void testOnRemoteFieldActivated() throws RemoteException {
+        createNfcServiceWithoutStatsdUtils();
+        List<String> userlist = new ArrayList<>();
+        userlist.add("com.android.nfc");
+        mNfcService.mIsSecureNfcEnabled = true;
+        mNfcService.mIsRequestUnlockShowed = false;
+        when(mNfcInjector.isDeviceLocked()).thenReturn(true);
+        mNfcService.mNfcEventInstalledPackages.put(1, userlist);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.onRemoteFieldActivated();
+        verify(callback, atLeastOnce()).onRfFieldActivated(anyBoolean());
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager).onFieldChangeDetected(anyBoolean());
+        verify(mApplication).sendBroadcastAsUser(any(), any());
+        verify(mApplication).sendBroadcast(any());
+        verify(mStatsdUtils).logFieldChanged(anyBoolean(), anyInt());
+        verify(mNfcEventLog, atLeast(2)).logEvent(any());
+    }
+
+    @Test
+    public void testOnRemoteFieldDeactivated() throws RemoteException {
+        createNfcServiceWithoutStatsdUtils();
+        List<String> userlist = new ArrayList<>();
+        userlist.add("com.android.nfc");
+        mNfcService.mIsSecureNfcEnabled = true;
+        mNfcService.mIsRequestUnlockShowed = false;
+        when(mKeyguardManager.isKeyguardLocked()).thenReturn(true);
+        mNfcService.mNfcEventInstalledPackages.put(1, userlist);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.onRemoteFieldDeactivated();
+        verify(callback, atLeastOnce()).onRfFieldActivated(anyBoolean());
+        mClock.mOffset += 60;
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager).onFieldChangeDetected(anyBoolean());
+        verify(mApplication).sendBroadcastAsUser(any(), any());
+        verify(mStatsdUtils).logFieldChanged(anyBoolean(), anyInt());
+        verify(mNfcEventLog, atLeast(2)).logEvent(any());
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_COALESCE_RF_EVENTS)
+    public void testOnRemoteFieldCoalessing() throws RemoteException {
+        Assume.assumeTrue(com.android.nfc.flags.Flags.coalesceRfEvents());
+        createNfcServiceWithoutStatsdUtils();
+        List<String> userlist = new ArrayList<>();
+        userlist.add("com.android.nfc");
+        mNfcService.mIsSecureNfcEnabled = true;
+        mNfcService.mIsRequestUnlockShowed = false;
+        when(mKeyguardManager.isKeyguardLocked()).thenReturn(true);
+        mNfcService.mNfcEventInstalledPackages.put(1, userlist);
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.onRemoteFieldActivated();
+        mNfcService.onRemoteFieldDeactivated();
+        mNfcService.onRemoteFieldActivated();
+        mNfcService.onRemoteFieldDeactivated();
+        mClock.mOffset += 60;
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager).onFieldChangeDetected(true);
+        verify(mCardEmulationManager).onFieldChangeDetected(false);
+        verify(mApplication, times(2)).sendBroadcastAsUser(any(), any());
+        verify(mStatsdUtils, times(4)).logFieldChanged(anyBoolean(), anyInt());
+        verify(mNfcEventLog, atLeast(2)).logEvent(any());
+    }
+
+    @Test
+    public void testOnSeSelected() {
+        mNfcService.onSeSelected();
+        mLooper.dispatchAll();
+        verify(mCardEmulationManager).onOffHostAidSelected();
+    }
+
+    @Test
+    public void testOnUidToBackground() throws RemoteException {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mNfcAdapter.disable(false, PKG_NAME);
+        mLooper.dispatchAll();
+        NfcService.ReaderModeParams readerModeParams = mock(NfcService.ReaderModeParams.class);
+        mNfcService.mReaderModeParams = readerModeParams;
+        readerModeParams.uid = 1;
+        IBinder binder = mock(IBinder.class);
+        readerModeParams.binder = binder;
+        NfcService.DiscoveryTechParams discoveryTechParams =
+                mock(NfcService.DiscoveryTechParams.class);
+        discoveryTechParams.uid = 1;
+        discoveryTechParams.binder = binder;
+        mNfcService.mDiscoveryTechParams = discoveryTechParams;
+        mNfcService.onUidToBackground(1);
+        verify(binder, times(2)).unlinkToDeath(any(), anyInt());
+        Assert.assertNull(mNfcService.mReaderModeParams);
+        verify(binder, times(2)).unlinkToDeath(any(), anyInt());
+        verify(mDeviceHost).resetDiscoveryTech();
+        Assert.assertNull(mNfcService.mDiscoveryTechParams);
+    }
+
+    @Test
+    public void testOnWlcData() throws RemoteException {
+        mNfcService.mIsWlcCapable = true;
+        INfcWlcStateListener listener = mock(INfcWlcStateListener.class);
+        mNfcService.mNfcAdapter.registerWlcStateListener(listener);
+        Map<String, Integer> wlcDeviceInfo = new HashMap<>();
+        wlcDeviceInfo.put(NfcCharging.VendorId, 1);
+        wlcDeviceInfo.put(NfcCharging.TemperatureListener, 1);
+        wlcDeviceInfo.put(NfcCharging.BatteryLevel, 1);
+        wlcDeviceInfo.put(NfcCharging.State, 1);
+        mNfcService.onWlcData(wlcDeviceInfo);
+        ArgumentCaptor<WlcListenerDeviceInfo> argumentCaptor = ArgumentCaptor
+                .forClass(WlcListenerDeviceInfo.class);
+        verify(listener).onWlcStateChanged(argumentCaptor.capture());
+        WlcListenerDeviceInfo deviceInfo = argumentCaptor.getValue();
+        Assert.assertNotNull(deviceInfo);
+        assertThat(deviceInfo.getBatteryLevel()).isEqualTo(1);
+    }
+
+    @Test
+    public void testOnWlcStopped() {
+        mNfcService.onWlcStopped(0x0);
+        verify(mNfcCharging).onWlcStopped(anyInt());
+    }
+
+    @Test
+    public void testRenewTagAppPrefList() throws PackageManager.NameNotFoundException {
+        BroadcastReceiver receiver = mGlobalReceiver.getValue();
+        Assert.assertNotNull(receiver);
+        Intent intent = new Intent();
+        intent.setAction(Intent.ACTION_USER_SWITCHED);
+        UserHandle uh = mock(UserHandle.class);
+        when(uh.getIdentifier()).thenReturn(5);
+        List<UserHandle> luh = new ArrayList<>();
+        luh.add(uh);
+        when(mUserManager.getEnabledProfiles()).thenReturn(luh);
+        String jsonString = "{}";
+        when(mPreferences.getString(anyString(), anyString())).thenReturn(jsonString);
+        mNfcService.mTagAppDefaultBlockList.add("com.android.test");
+        PackageInfo info = mock(PackageInfo.class);
+        when(mPackageManager.getPackageInfo(anyString(), anyInt())).thenReturn(info);
+        when(mPreferencesEditor.remove(any())).thenReturn(mPreferencesEditor);
+        when(mPreferencesEditor.putString(anyString(), anyString())).thenReturn(mPreferencesEditor);
+        receiver.onReceive(mApplication, intent);
+        verify(mUserManager, atLeastOnce()).getEnabledProfiles();
+        verify(mPreferencesEditor).putString(anyString(), anyString());
+    }
+
+    @Test
+    public void testSaveNfcPollTech() {
+        mNfcService.saveNfcPollTech(NfcService.DEFAULT_POLL_TECH);
+        verify(mPreferencesEditor).putInt(anyString(), anyInt());
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+    }
+
+    @Test
+    public void testSendData() {
+        mNfcService.sendData("test".getBytes());
+        ArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);
+        verify(mDeviceHost).sendRawFrame(captor.capture());
+        assertThat(captor.getValue()).isNotNull();
+        assertThat(captor.getValue()).isEqualTo("test".getBytes());
+    }
+
+    @Test
+    public void testSendMockNdefTag() {
+        NdefMessage msg = mock(NdefMessage.class);
+        when(mNfcDispatcher.dispatchTag(any())).thenReturn(NfcDispatcher.DISPATCH_SUCCESS);
+        when(mVrManager.isVrModeEnabled()).thenReturn(false);
+        mNfcService.mSoundPool = mSoundPool;
+        mNfcService.sendMockNdefTag(msg);
+        mLooper.dispatchAll();
+        ArgumentCaptor<Tag> captor = ArgumentCaptor.forClass(Tag.class);
+        verify(mNfcDispatcher).dispatchTag(captor.capture());
+        Tag tag = captor.getValue();
+        assertThat(tag).isNotNull();
+        verify(mSoundPool)
+                .play(anyInt(), anyFloat(), anyFloat(), anyInt(), anyInt(), anyFloat());
+
+        when(mNfcDispatcher.dispatchTag(any())).thenReturn(NfcDispatcher.DISPATCH_FAIL);
+        mNfcService.sendMockNdefTag(msg);
+        mLooper.dispatchAll();
+        verify(mNfcDispatcher, atLeastOnce()).dispatchTag(captor.capture());
+        tag = captor.getValue();
+        assertThat(tag).isNotNull();
+        verify(mSoundPool, times(2))
+                .play(anyInt(), anyFloat(), anyFloat(), anyInt(), anyInt(), anyFloat());
+    }
+
+    @Test
+    public void testSendScreenMessageAfterNfcCharging() {
+        mNfcService.mPendingPowerStateUpdate = true;
+        when(mScreenStateHelper.checkScreenState(anyBoolean()))
+                .thenReturn(ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED);
+        boolean result = mNfcService.sendScreenMessageAfterNfcCharging();
+        mLooper.dispatchAll();
+        assertThat(mNfcService.mIsRequestUnlockShowed).isFalse();
+        assertThat(result).isTrue();
+        assertThat(mNfcService.mPendingPowerStateUpdate).isFalse();
+        verify(mDeviceHost).doSetScreenState(anyInt(), anyBoolean());
+    }
+
+    @Test
+    public void testSetPowerSavingMode() throws RemoteException {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        byte[] payload = { 0x01, 0x01, 0x00, 0x00 };
+        when(mDeviceHost.setPowerSavingMode(true)).thenReturn(true);
+        int result = mNfcService.mNfcAdapter.sendVendorNciMessage(1,0x0f,0x0c, payload);
+        mLooper.dispatchAll();
+        assertThat(result).isEqualTo(0x00);
+        verify(mDeviceHost).setPowerSavingMode(anyBoolean());
+    }
+
+    @Test
+    public void testSetSystemCodeRoute() {
+        mNfcService.setSystemCodeRoute(1);
+        mLooper.dispatchAll();
+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
+        verify(mDeviceHost).setSystemCodeRoute(captor.capture());
+        assertThat(captor.getValue()).isEqualTo(1);
+    }
+
+    @Test
+    public void testStateToProtoEnum() {
+        int result = NfcService.stateToProtoEnum(NfcAdapter.STATE_OFF);
+        assertThat(result).isEqualTo(NfcServiceDumpProto.STATE_OFF);
+        result = NfcService.stateToProtoEnum(NfcAdapter.STATE_TURNING_ON);
+        assertThat(result).isEqualTo(NfcServiceDumpProto.STATE_TURNING_ON);
+        result = NfcService.stateToProtoEnum(NfcAdapter.STATE_ON);
+        assertThat(result).isEqualTo(NfcServiceDumpProto.STATE_ON);
+        result = NfcService.stateToProtoEnum(NfcAdapter.STATE_TURNING_OFF);
+        assertThat(result).isEqualTo(NfcServiceDumpProto.STATE_TURNING_OFF);
+        result = NfcService.stateToProtoEnum(0);
+        assertThat(result).isEqualTo(NfcServiceDumpProto.STATE_UNKNOWN);
+    }
+    @Test
+    public void testUnregisterObject() {
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getHandle()).thenReturn(1);
+        mNfcService.registerTagObject(tagEndpoint);
+        mNfcService.unregisterObject(1);
+        assertThat(mNfcService.mObjectMap.get(1)).isNull();
+    }
+
+    @Test
+    public void testNfcServiceOnReceive() {
+        BroadcastReceiver receiver = mBroadcastReceiverArgumentCaptor.getValue();
+        Bundle bundle = new Bundle();
+        bundle.putBoolean(UserManager.DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO, true);
+        when(mUserManager.getUserRestrictions()).thenReturn(bundle);
+        Assert.assertNotNull(receiver);
+        mNfcService.mIsNfcUserRestricted = false;
+        when(mPreferences.getBoolean(anyString(), anyBoolean())).thenReturn(true);
+        when(mNfcInjector.isSatelliteModeOn()).thenReturn(false);
+        receiver.onReceive(mApplication, new Intent(UserManager.ACTION_USER_RESTRICTIONS_CHANGED));
+        verify(mUserManager, atLeastOnce()).getUserRestrictions();
+
+    }
+
+    @Test
+    public void testDiscoveryTechDeathRecipient_BinderDied() {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mDiscoveryTechParams = mock(NfcService.DiscoveryTechParams.class);
+        NfcService.DiscoveryTechDeathRecipient discoveryTechDeathRecipient = mNfcService
+                .new DiscoveryTechDeathRecipient();
+        discoveryTechDeathRecipient.binderDied();
+        verify(mDeviceHost).resetDiscoveryTech();
+        assertThat(mNfcService.mDiscoveryTechParams).isNull();
+    }
+
+    @Test
+    public void testDisableAlwaysOnInternal() throws RemoteException {
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.DISABLE);
+        mLooper.dispatchAll();
+
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_TURNING_OFF;
+        mNfcService.mAlwaysOnMode = NfcOemExtension.DISABLE;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.DISABLE);
+        mLooper.dispatchAll();
+        assertThat(mNfcService.mAlwaysOnMode).isEqualTo(NfcOemExtension.DISABLE);
+
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_TURNING_ON;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.DISABLE);
+        mLooper.dispatchAll();
+        verify(mDeviceHost).setNfceePowerAndLinkCtrl(false);
+
+        mNfcService.mState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.DISABLE);
+        mLooper.dispatchAll();
+        verify(mDeviceHost).setNfceePowerAndLinkCtrl(false);
+
+    }
+
+    @Test
+    public void testEnableAlwaysOnInternal() throws RemoteException {
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_ON;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_EE);
+        mLooper.dispatchAll();
+
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_TURNING_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_EE);
+        mLooper.dispatchAll();
+
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_EE);
+        mLooper.dispatchAll();
+        verify(mDeviceHost).setNfceePowerAndLinkCtrl(true);
+
+        mNfcService.mState = NfcAdapter.STATE_OFF;
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_EE);
+        mLooper.dispatchAll();
+        verify(mDeviceHost, times(2)).setPartialInitMode(anyInt());
+        verify(mDeviceHost).setNfceePowerAndLinkCtrl(true);
+    }
+
+    @Test
+    public void testAddNfcUnlockHandler() {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        mNfcService.mNfcAdapter.addNfcUnlockHandler(unlockHandler, new int[]{NfcService.NFC_POLL_A,
+                NfcService.NFC_POLL_B, NFC_POLL_V});
+        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
+        verify(mNfcUnlockManager).addUnlockHandler(any(), captor.capture());
+        assertThat(captor.getValue()).isNotNull();
+        assertThat(captor.getValue()).isEqualTo(3);
+    }
+
+    @Test
+    public void testCheckFirmware() throws RemoteException {
+        mNfcService.mNfcAdapter.checkFirmware();
+        verify(mDeviceHost).checkFirmware();
+    }
+
+    @Test
+    public void testClearPreference() throws RemoteException {
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.mNfcAdapter.clearPreference();
+        verify(mNfcEventLog, times(2)).logEvent(any());
+    }
+
+    @Test
+    public void testEnableReaderOption() throws RemoteException {
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        mNfcService.mReaderOptionCapable = true;
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        boolean result = mNfcService.mNfcAdapter
+                .enableReaderOption(true, "com.android.test");
+        assertThat(mNfcService.mIsReaderOptionEnabled).isTrue();
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+        verify(callback).onReaderOptionChanged(true);
+        verify(mNfcEventLog, times(2)).logEvent(any());
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testFetchActiveNfceeList() throws RemoteException {
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        Map<String, Integer> nfceeMap = new HashMap<>();
+        nfceeMap.put("test1", Integer.valueOf(NFC_LISTEN_A));
+        nfceeMap.put("test2", Integer.valueOf(NFC_LISTEN_B));
+        nfceeMap.put("test3", Integer.valueOf(NFC_LISTEN_F));
+        when(mDeviceHost.dofetchActiveNfceeList()).thenReturn(nfceeMap);
+        Map<String, Integer> map = mNfcService.mNfcAdapter.fetchActiveNfceeList();
+        verify(mDeviceHost).dofetchActiveNfceeList();
+        Assert.assertEquals(map, nfceeMap);
+    }
+
+    @Test
+    public void testGetNfcAdapterExtrasInterface() throws RemoteException {
+        INfcAdapterExtras adpExtras = mNfcService.mNfcAdapter
+                .getNfcAdapterExtrasInterface("com.android.test");
+        assertThat(adpExtras).isNull();
+    }
+
+    @Test
+    public void testGetNfcDtaInterface() throws RemoteException {
+        mNfcService.mNfcDtaService = null;
+        INfcDta nfcData = mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        assertThat(nfcData).isNotNull();
+
+        NfcService.NfcDtaService nfcDtaService = mock(NfcService.NfcDtaService.class);
+        mNfcService.mNfcDtaService = nfcDtaService;
+        INfcDta resultDtaService = mNfcService.mNfcAdapter
+                .getNfcDtaInterface("com.android.test");
+        Assert.assertNotNull(resultDtaService);
+        assertThat(nfcDtaService).isEqualTo(resultDtaService);
+    }
+
+    @Test
+    public void testGetSettingStatus() throws RemoteException {
+        when(mDeviceConfigFacade.getNfcDefaultState()).thenReturn(true);
+        when(mPreferences.getBoolean(PREF_NFC_ON, true)).thenReturn(true);
+        boolean result = mNfcService.mNfcAdapter.getSettingStatus();
+        assertThat(result).isTrue();
+        verify(mPreferences, atLeastOnce()).getBoolean(anyString(), anyBoolean());
+    }
+
+    @Test
+    public void testSetTagIntentAppPreferenceForUser()
+            throws RemoteException, PackageManager.NameNotFoundException {
+        PackageInfo info = mock(PackageInfo.class);
+        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
+        applicationInfo.flags = 1;
+        info.applicationInfo = applicationInfo;
+        when(mPackageManager.getPackageInfo(anyString(), anyInt())).thenReturn(info);
+        int result = mNfcService.mNfcAdapter
+                .setTagIntentAppPreferenceForUser(1, "com.android.test", true);
+        assertThat(result).isEqualTo(NfcAdapter.TAG_INTENT_APP_PREF_RESULT_SUCCESS);
+        when(mPackageManager.getPackageInfo(anyString(), anyInt())).thenReturn(null);
+        result = mNfcService.mNfcAdapter
+                .setTagIntentAppPreferenceForUser(1, "com.android.test", true);
+        assertThat(result).isEqualTo(NfcAdapter.TAG_INTENT_APP_PREF_RESULT_PACKAGE_NOT_FOUND);
+    }
+
+    @Test
+    public void testCanMakeReadOnly() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        tagService.canMakeReadOnly(Ndef.TYPE_1);
+        verify(mDeviceHost).canMakeReadOnly(anyInt());
+    }
+
+    @Test
+    public void testConnect() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.isPresent()).thenReturn(true);
+        when(tagEndpoint.connect(anyInt())).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int resultCode = tagService.connect(1, Ndef.TYPE_1);
+       assertThat(resultCode).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testReConnect() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.isPresent()).thenReturn(true);
+        when(tagEndpoint.reconnect()).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int resultCode = tagService.reconnect(1);
+        assertThat(resultCode).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testFormatNdef() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.formatNdef(any())).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int resultCode = tagService.formatNdef(1, "test".getBytes());
+        assertThat(resultCode).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testRediscover() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getUid()).thenReturn(new byte[]{4, 18, 52, 86});
+        when(tagEndpoint.getTechList()).thenReturn(new int[]{Ndef.NDEF});
+        when(tagEndpoint.getTechExtras()).thenReturn(new Bundle[]{});
+        when(tagEndpoint.getHandle()).thenReturn(1);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        Tag tag = tagService.rediscover(1);
+        assertThat(tag).isNotNull();
+    }
+
+    @Test
+    public void testGetExtendedLengthApdusSupported() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        tagService.getExtendedLengthApdusSupported();
+        verify(mDeviceHost).getExtendedLengthApdusSupported();
+    }
+
+    @Test
+    public void testGetMaxTransceiveLength() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        tagService.getMaxTransceiveLength(Ndef.NDEF);
+        verify(mDeviceHost).getMaxTransceiveLength(Ndef.NDEF);
+    }
+
+    @Test
+    public void testTechList() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getTechList()).thenReturn(new int[]{Ndef.NDEF, Ndef.TYPE_OTHER});
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int[] techList = tagService.getTechList(1);
+        assertThat(techList).isNotNull();
+        assertThat(techList).hasLength(2);
+    }
+
+    @Test
+    public void testGetTimeOut() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        tagService.getTimeout(Ndef.NDEF);
+        verify(mDeviceHost).getTimeout(Ndef.NDEF);
+    }
+
+    @Test
+    public void testIsNdef() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.checkNdef(any())).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        boolean result = tagService.isNdef(1);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testIsPresent() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.isPresent()).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        boolean result = tagService.isPresent(1);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testIsTagUpToDate() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mCookieUpToDate = 0;
+        boolean result = tagService.isTagUpToDate(0);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testNdefMakeReadOnly() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.makeReadOnly()).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int result = tagService.ndefMakeReadOnly(1);
+        assertThat(result).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testNdefRead() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        NdefRecord record = NdefRecord.createTextRecord("en", "ndef");
+        NdefMessage ndefMessage = new NdefMessage(new NdefRecord[]{record});
+        when(tagEndpoint.readNdef()).thenReturn(ndefMessage.toByteArray());
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        NdefMessage resultMessage = tagService.ndefRead(1);
+        assertThat(resultMessage).isNotNull();
+        assertThat(resultMessage.getRecords()).hasLength(1);
+    }
+
+    @Test
+    public void testNdefWrite() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        NdefRecord record = NdefRecord.createTextRecord("en", "ndef");
+        NdefMessage ndefMessage = new NdefMessage(new NdefRecord[]{record});
+        when(tagEndpoint.writeNdef(any())).thenReturn(true);
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        int result = tagService.ndefWrite(1, ndefMessage);
+        assertThat(result).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testResetTimeouts() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        tagService.resetTimeouts();
+        verify(mDeviceHost).resetTimeouts();
+    }
+
+    @Test
+    public void testSetTimeout() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        when(mDeviceHost.setTimeout(Ndef.NDEF, 100)).thenReturn(true);
+        int result = tagService.setTimeout(Ndef.NDEF, 100);
+        verify(mDeviceHost).setTimeout(Ndef.NDEF, 100);
+        assertThat(result).isEqualTo(ErrorCodes.SUCCESS);
+    }
+
+    @Test
+    public void testTransceive() throws RemoteException {
+        NfcService.TagService tagService = mNfcService.new TagService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        mNfcService.mIsReaderOptionEnabled = true;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        NdefRecord record = NdefRecord.createTextRecord("en", "ndef");
+        NdefMessage ndefMessage = new NdefMessage(new NdefRecord[]{record});
+        when(mDeviceHost.getMaxTransceiveLength(anyInt())).thenReturn(100);
+        when(tagEndpoint.getConnectedTechnology()).thenReturn(Ndef.NDEF);
+        when(tagEndpoint.transceive(any(), anyBoolean(), any()))
+                .thenReturn(ndefMessage.toByteArray());
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+
+        TransceiveResult result = tagService.transceive(1, ndefMessage
+                .toByteArray(), true);
+        assertThat(result).isNotNull();
+    }
+
+    @Test
+    public void testGetWlcListenerDeviceInfo() {
+        Map<String, Integer> wlcDeviceInfo = new HashMap<>();
+        wlcDeviceInfo.put(NfcCharging.VendorId, 1);
+        wlcDeviceInfo.put(NfcCharging.TemperatureListener, 1);
+        wlcDeviceInfo.put(NfcCharging.BatteryLevel, 1);
+        wlcDeviceInfo.put(NfcCharging.State, 1);
+        mNfcService.onWlcData(wlcDeviceInfo);
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mIsWlcCapable = true;
+        WlcListenerDeviceInfo wlcListenerDeviceInfo = adapterService.getWlcListenerDeviceInfo();
+        assertThat(wlcListenerDeviceInfo).isNotNull();
+        assertThat(wlcListenerDeviceInfo.getBatteryLevel()).isEqualTo(1);
+    }
+
+    @Test
+    public void testHandleShellCommand() {
+        ParcelFileDescriptor in = mock(ParcelFileDescriptor.class);
+        when(in.getFileDescriptor()).thenReturn(mock(FileDescriptor.class));
+        ParcelFileDescriptor out = mock(ParcelFileDescriptor.class);
+        when(out.getFileDescriptor()).thenReturn(mock(FileDescriptor.class));
+        ParcelFileDescriptor err = mock(ParcelFileDescriptor.class);
+        when(err.getFileDescriptor()).thenReturn(mock(FileDescriptor.class));
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        int result = adapterService.handleShellCommand(in, out, err, new String[]{"test"});
+        assertThat(result).isEqualTo(-1);
+    }
+
+    @Test
+    public void testIgnore() throws RemoteException {
+        mNfcService.mDebounceTagNativeHandle = 0;
+        ITagRemovedCallback callback = mock(ITagRemovedCallback.class);
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        boolean result = adapterService.ignore(0,0, callback);
+        mLooper.dispatchAll();
+        assertThat(result).isTrue();
+
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getUid()).thenReturn(new byte[]{4, 18 ,52, 86});
+        mNfcService.mObjectMap.put(1, tagEndpoint);
+        result = adapterService.ignore(1,1, callback);
+        verify(tagEndpoint).disconnect();
+        mLooper.dispatchAll();
+        assertThat(result).isTrue();
+
+    }
+
+    @Test
+    public void testIsNfcSecureEnabled() throws RemoteException {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mIsSecureNfcEnabled = true;
+        boolean result = adapterService.isNfcSecureEnabled();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testIsReaderOptionSupported() {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mReaderOptionCapable = true;
+        boolean result = adapterService.isReaderOptionSupported();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testGetTagIntentAppPreferenceForUser() throws RemoteException {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mTagAppPrefList.put(1, new HashMap<>());
+        Map result = adapterService.getTagIntentAppPreferenceForUser(1);
+        assertThat(result).isNotNull();
+    }
+
+    @Test
+    public void testGetWalletRoleHolder() {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        when(NfcInjector.isPrivileged(anyInt())).thenReturn(false);
+        when(mCardEmulationManager.isPreferredServicePackageNameForUser(anyString(), anyInt()))
+                .thenReturn(true);
+        when(android.permission.flags.Flags.walletRoleEnabled()).thenReturn(true);
+        List<String> list = new ArrayList<>();
+        list.add("com.android.test");
+        when(mRoleManager.getRoleHolders(anyString())).thenReturn(list);
+        boolean result = adapterService.setObserveMode(true, "com.android.test");
+        assertThat(result).isFalse();
+        verify(mDeviceHost).setObserveMode(anyBoolean());
+    }
+
+    @Test
+    public void testIsWlcEnabled() throws RemoteException {
+        mNfcService.mIsWlcCapable = true;
+        mNfcService.mIsWlcEnabled = true;
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        boolean result = adapterService.isWlcEnabled();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testNotifyTestHceData() {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        doNothing().when(mCardEmulationManager).onHostCardEmulationData(anyInt(), any());
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        adapterService.notifyTestHceData(Ndef.NDEF, "test".getBytes());
+        verify(mCardEmulationManager).onHostCardEmulationData(anyInt(), any());
+        verify(mNfcEventLog, atLeastOnce()).logEvent(any());
+    }
+
+    @Test
+    public void testPausePolling() {
+        mNfcService.onRfDiscoveryEvent(true);
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        adapterService.pausePolling(100);
+        verify(mDeviceHost).disableDiscovery();
+        mLooper.dispatchAll();
+    }
+
+    @Test
+    public void testRegisterControllerAlwaysOnListener() throws RemoteException {
+        INfcControllerAlwaysOnListener iNfcControllerAlwaysOnListener
+                = mock(INfcControllerAlwaysOnListener.class);
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        adapterService.registerControllerAlwaysOnListener(iNfcControllerAlwaysOnListener);
+
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_TURNING_ON;
+        mNfcService.mState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_DEFAULT);
+        mLooper.dispatchAll();
+
+        verify(iNfcControllerAlwaysOnListener).onControllerAlwaysOnChanged(anyBoolean());
+    }
+
+    @Test
+    public void testSetNfcSecure() {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        when(mKeyguardManager.isKeyguardLocked()).thenReturn(false);
+        mNfcService.mIsSecureNfcEnabled = false;
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        mNfcService.mIsHceCapable = true;
+        adapterService.setNfcSecure(true);
+        verify(mPreferencesEditor).putBoolean(anyString(), anyBoolean());
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+        verify(mDeviceHost).setNfcSecure(true);
+        verify(mNfcEventLog, times(2)).logEvent(any());
+        verify(mCardEmulationManager).onSecureNfcToggled();
+    }
+
+    @Test
+    public void testSetScreenState() throws RemoteException {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        when(mScreenStateHelper.checkScreenState(anyBoolean()))
+                .thenReturn(ScreenStateHelper.SCREEN_STATE_OFF_LOCKED);
+        mNfcService.mScreenState = ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED;
+        when(mDeviceHost.getNciVersion()).thenReturn(NCI_VERSION_1_0);
+        when(mFeatureFlags.reduceStateTransition()).thenReturn(true);
+        mNfcService.mIsWatchType = true;
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        when(mCardEmulationManager.isRequiresScreenOnServiceExist()).thenReturn(false);
+        adapterService.setScreenState();
+        mLooper.dispatchAll();
+        verify(mDeviceHost).doSetScreenState(anyInt(), anyBoolean());
+    }
+
+    @Test
+    public void testSetWlcEnabled() {
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        mNfcService.mIsWlcCapable = true;
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        when(android.nfc.Flags.nfcPersistLog()).thenReturn(true);
+        adapterService.setWlcEnabled(true);
+        verify(mPreferencesEditor).putBoolean(anyString(), anyBoolean());
+        verify(mPreferencesEditor).apply();
+        verify(mBackupManager).dataChanged();
+        verify(mBackupManager).dataChanged();
+    }
+
+    @Test
+    public void testUnregisterControllerAlwaysOnListener() throws RemoteException {
+        INfcControllerAlwaysOnListener iNfcControllerAlwaysOnListener
+                = mock(INfcControllerAlwaysOnListener.class);
+        NfcService.NfcAdapterService adapterService = mNfcService.new NfcAdapterService();
+        adapterService.unregisterControllerAlwaysOnListener(iNfcControllerAlwaysOnListener);
+
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_TURNING_ON;
+        mNfcService.mState = NfcAdapter.STATE_OFF;
+        mNfcService.mNfcAdapter.setControllerAlwaysOn(NfcOemExtension.ENABLE_DEFAULT);
+        mLooper.dispatchAll();
+
+        verify(iNfcControllerAlwaysOnListener, never()).onControllerAlwaysOnChanged(anyBoolean());
+    }
+
+    @Test
+    public void testUnregisterOemExtensionCallback() throws RemoteException {
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback callback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(callback);
+        ArgumentCaptor<INfcOemExtensionCallback> captor = ArgumentCaptor
+                .forClass(INfcOemExtensionCallback.class);
+        verify(mCardEmulationManager).setOemExtension(captor.capture());
+        assertThat(captor.getValue()).isEqualTo(callback);
+
+        mNfcService.mNfcAdapter.unregisterOemExtensionCallback(callback);
+        mNfcService.onHostCardEmulationActivated(Ndef.NDEF);
+        verify(callback, times(1)).onCardEmulationActivated(anyBoolean());
+    }
+
+    @Test
+    public void testUnregisterWlcStateListener() throws RemoteException {
+        mNfcService.mIsWlcCapable = true;
+        INfcWlcStateListener listener = mock(INfcWlcStateListener.class);
+        mNfcService.mNfcAdapter.registerWlcStateListener(listener);
+        Map<String, Integer> wlcDeviceInfo = new HashMap<>();
+        wlcDeviceInfo.put(NfcCharging.VendorId, 1);
+        wlcDeviceInfo.put(NfcCharging.TemperatureListener, 1);
+        wlcDeviceInfo.put(NfcCharging.BatteryLevel, 1);
+        wlcDeviceInfo.put(NfcCharging.State, 1);
+        mNfcService.onWlcData(wlcDeviceInfo);
+        verify(listener).onWlcStateChanged(any());
+
+        mNfcService.mNfcAdapter.unregisterWlcStateListener(listener);
+        mNfcService.onWlcData(wlcDeviceInfo);
+        verify(listener, times(1)).onWlcStateChanged(any());
+    }
+
+    @Test
+    public void testIsControllerAlwaysOn() throws RemoteException {
+        mNfcService.mAlwaysOnState = NfcAdapter.STATE_ON;
+        boolean result = mNfcService.mNfcAdapter.isControllerAlwaysOn();
+        assertThat(result).isTrue();
+    }
+
+
+    @Test
+    public void testDisableDta() throws RemoteException {
+        mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        NfcService.sIsDtaMode = true;
+        mNfcService.mNfcDtaService.disableDta();
+        verify(mDeviceHost).disableDtaMode();
+        assertThat(NfcService.sIsDtaMode).isFalse();
+    }
+
+    @Test
+    public void testEnableClient() throws RemoteException {
+        mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        boolean result = mNfcService.mNfcDtaService.enableClient("com.android.test",
+                0, 0, 0);
+        assertThat(result).isFalse();
+
+    }
+
+    @Test
+    public void testEnableDta() throws RemoteException {
+        mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        NfcService.sIsDtaMode = false;
+        mNfcService.mNfcDtaService.enableDta();
+        verify(mDeviceHost).enableDtaMode();
+        assertThat(NfcService.sIsDtaMode).isTrue();
+    }
+
+    @Test
+    public void testEnableServer() throws RemoteException {
+        mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        boolean result = mNfcService.mNfcDtaService.enableServer("com.android.test",
+                0, 0, 0, 0);
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void testRegisterMessageService() throws RemoteException {
+        mNfcService.mNfcAdapter.getNfcDtaInterface("com.android.test");
+        boolean result = mNfcService.mNfcDtaService
+                .registerMessageService("com.android.test");
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testPollingDelay() {
+        Handler handler = mNfcService.getHandler();
+        Assert.assertNotNull(handler);
+        Message msg = handler.obtainMessage(NfcService.MSG_NDEF_TAG);
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getConnectedTechnology()).thenReturn(TagTechnology.NDEF);
+        when(tagEndpoint.reconnect()).thenReturn(false);
+        mNfcService.mScreenState = ScreenStateHelper.SCREEN_STATE_ON_UNLOCKED;
+        msg.obj = tagEndpoint;
+        handler.handleMessage(msg);
+        verify(tagEndpoint).disconnect();
+        verify(mDeviceHost).startStopPolling(false);
+    }
+
+    @Test
+    public void testOnTagDisconnected() throws RemoteException {
+        Handler handler = mNfcService.getHandler();
+        Assert.assertNotNull(handler);
+        Message msg = handler.obtainMessage(NfcService.MSG_NDEF_TAG);
+        mNfcService.mState = NfcAdapter.STATE_ON;
+        DeviceHost.TagEndpoint tagEndpoint = mock(DeviceHost.TagEndpoint.class);
+        when(tagEndpoint.getConnectedTechnology()).thenReturn(TagTechnology.NDEF);
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        when(tagEndpoint.findAndReadNdef()).thenReturn(ndefMessage);
+        msg.obj = tagEndpoint;
+        handler.handleMessage(msg);
+        ArgumentCaptor<DeviceHost.TagDisconnectedCallback> callbackArgumentCaptor
+                = ArgumentCaptor.forClass(DeviceHost.TagDisconnectedCallback.class);
+        verify(tagEndpoint, atLeastOnce()).startPresenceChecking(anyInt(),
+                callbackArgumentCaptor.capture());
+
+        DeviceHost.TagDisconnectedCallback callback = callbackArgumentCaptor.getValue();
+        Assert.assertNotNull(callback);
+        when(mPreferences.getBoolean(eq(PREF_NFC_ON), anyBoolean())).thenReturn(true);
+        INfcOemExtensionCallback oemExtensionCallback = mock(INfcOemExtensionCallback.class);
+        mNfcService.mNfcAdapter.registerOemExtensionCallback(oemExtensionCallback);
+        callback.onTagDisconnected();
+        assertThat(mNfcService.mCookieUpToDate).isLessThan(0);
+        verify(oemExtensionCallback).onTagConnected(anyBoolean());
+    }
 }
diff --git a/tests/unit/src/com/android/nfc/NfcShellCommandTest.java b/tests/unit/src/com/android/nfc/NfcShellCommandTest.java
new file mode 100644
index 00000000..cfc8a263
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/NfcShellCommandTest.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.RemoteException;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+import com.android.nfc.cardemulation.CardEmulationManager;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import static org.mockito.ArgumentMatchers.isNull;
+import android.nfc.INfcDta;
+import android.nfc.INfcCardEmulation;
+
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+@RunWith(AndroidJUnit4.class)
+public class NfcShellCommandTest {
+    @Mock
+    Context mContext;
+    @Mock
+    NfcService mNfcService;
+    @Mock
+    PrintWriter mPrintWriter;
+    @Mock
+    Binder mBinder;
+    @Mock
+    FileDescriptor mFileDescriptorIn;
+    @Mock
+    FileDescriptor mFileDescriptorOut;
+    @Mock
+    FileDescriptor mFileDescriptorErr;
+
+    private NfcShellCommand mNfcShellCommand;
+
+    private MockitoSession mStaticMockSession;
+
+    @Before
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .mockStatic(ArrayUtils.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+        MockitoAnnotations.initMocks(this);
+
+        mNfcShellCommand = new NfcShellCommand(mNfcService, mContext, mPrintWriter);
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr,
+                        new String[]{"test", "enable-polling", "disable-polling"}, 0);
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testOnCommandStatus() {
+        when(mNfcService.isNfcEnabled()).thenReturn(true);
+        int status = mNfcShellCommand.onCommand("status");
+        assertThat(status).isEqualTo(0);
+        verify(mPrintWriter).println("Nfc is enabled");
+    }
+
+    @Test
+    public void testOnCommandDisableNfc() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        int status = mNfcShellCommand.onCommand("disable-nfc");
+        verify(nfcAdapterService).disable(anyBoolean(), any());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandEnableNfc() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        when(mContext.getPackageName()).thenReturn("com.android.test");
+        int status = mNfcShellCommand.onCommand("enable-nfc");
+        verify(nfcAdapterService).enable("com.android.test");
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandSetReaderMode() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        when(ArrayUtils.indexOf(any(), anyString())).thenReturn(0);
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"enable-polling"}, 0);
+        int status = mNfcShellCommand.onCommand("set-reader-mode");
+        verify(nfcAdapterService).setReaderMode(any(), isNull(), anyInt(), isNull(), isNull());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandSetObserveMode() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        when(ArrayUtils.indexOf(any(), anyString())).thenReturn(0);
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"enable"}, 0);
+        int status = mNfcShellCommand.onCommand("set-observe-mode");
+        verify(nfcAdapterService).setObserveMode(anyBoolean(), isNull());
+        assertThat(status).isEqualTo(0);
+    }
+
+
+    @Test
+    public void testOnCommandSetControllerAlwaysOn() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1"}, 0);
+        int status = mNfcShellCommand.onCommand("set-controller-always-on");
+        verify(nfcAdapterService).setControllerAlwaysOn(anyInt());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandSetDiscoveryTech() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1", "2"}, 0);
+        when(mContext.getPackageName()).thenReturn("com.android.test");
+        int status = mNfcShellCommand.onCommand("set-discovery-tech");
+        verify(nfcAdapterService).updateDiscoveryTechnology(any(), anyInt(), anyInt(), anyString());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandConfigureDta() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"enable"}, 0);
+        when(mContext.getPackageName()).thenReturn("com.android.test");
+        INfcDta dtaService = mock(INfcDta.class);
+        when(nfcAdapterService.getNfcDtaInterface("com.android.test")).thenReturn(dtaService);
+        int status = mNfcShellCommand.onCommand("configure-dta");
+        verify(mPrintWriter).println("  configure-dta");
+        verify(mPrintWriter).println("  enableDta()");
+        verify(dtaService).enableDta();
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandSetOffHostSe() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1", "com.android.test",
+                                "NfcTest", "test"}, 0);
+        CardEmulationManager cardEmulationManager = mock(CardEmulationManager.class);
+        INfcCardEmulation iNfcCardEmulation = mock(INfcCardEmulation.class);
+        when(cardEmulationManager.getNfcCardEmulationInterface()).thenReturn(iNfcCardEmulation);
+        mNfcService.mCardEmulationManager = cardEmulationManager;
+        int status = mNfcShellCommand.onCommand("set-offhost-se");
+        verify(cardEmulationManager).getNfcCardEmulationInterface();
+        verify(iNfcCardEmulation).setOffHostForService(anyInt(), any(), anyString());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandResetOffHostSe() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1", "com.android.test",
+                                "NfcTest"}, 0);
+        CardEmulationManager cardEmulationManager = mock(CardEmulationManager.class);
+        INfcCardEmulation iNfcCardEmulation = mock(INfcCardEmulation.class);
+        when(cardEmulationManager.getNfcCardEmulationInterface()).thenReturn(iNfcCardEmulation);
+        mNfcService.mCardEmulationManager = cardEmulationManager;
+        int status = mNfcShellCommand.onCommand("reset-offhost-se");
+        verify(cardEmulationManager).getNfcCardEmulationInterface();
+        verify(iNfcCardEmulation).unsetOffHostForService(anyInt(), any());
+        assertThat(status).isEqualTo(0);
+    }
+
+    @Test
+    public void testOnCommandRegisterAidGroup() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1", "com.android.test",
+                                "NfcTest", "325041592E5359532E4444463031", "payment"}, 0);
+        CardEmulationManager cardEmulationManager = mock(CardEmulationManager.class);
+        INfcCardEmulation iNfcCardEmulation = mock(INfcCardEmulation.class);
+        when(cardEmulationManager.getNfcCardEmulationInterface()).thenReturn(iNfcCardEmulation);
+        mNfcService.mCardEmulationManager = cardEmulationManager;
+        int status = mNfcShellCommand.onCommand("register-aid-group");
+        verify(cardEmulationManager).getNfcCardEmulationInterface();
+        verify(iNfcCardEmulation).registerAidGroupForService(anyInt(), any(), any());
+        assertThat(status).isEqualTo(0);
+    }
+
+
+    @Test
+    public void testOnCommandRemoveAidGroup() throws RemoteException {
+        NfcService.NfcAdapterService nfcAdapterService = mock(NfcService.NfcAdapterService.class);
+        mNfcService.mNfcAdapter = nfcAdapterService;
+        mNfcShellCommand
+                .init(mBinder, mFileDescriptorIn, mFileDescriptorOut,
+                        mFileDescriptorErr, new String[]{"1", "com.android.test",
+                                "NfcTest", "payment"}, 0);
+        CardEmulationManager cardEmulationManager = mock(CardEmulationManager.class);
+        INfcCardEmulation iNfcCardEmulation = mock(INfcCardEmulation.class);
+        when(cardEmulationManager.getNfcCardEmulationInterface()).thenReturn(iNfcCardEmulation);
+        mNfcService.mCardEmulationManager = cardEmulationManager;
+        int status = mNfcShellCommand.onCommand("remove-aid-group");
+        verify(cardEmulationManager).getNfcCardEmulationInterface();
+        verify(iNfcCardEmulation).removeAidGroupForService(anyInt(), any(), any());
+        assertThat(status).isEqualTo(0);
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/NfcTagAllowNotificationTest.java b/tests/unit/src/com/android/nfc/NfcTagAllowNotificationTest.java
new file mode 100644
index 00000000..cf6fc64b
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/NfcTagAllowNotificationTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.NotificationManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.os.Handler;
+import android.util.Log;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+
+@RunWith(AndroidJUnit4.class)
+public class NfcTagAllowNotificationTest {
+
+    private static final String TAG = NfcTagAllowNotificationTest.class.getSimpleName();
+    private static final String NAME = "name";
+    private static final String TITLE = "title";
+    private MockitoSession mStaticMockSession;
+    private Context mMockContext;
+    private NfcTagAllowNotification mNfcTagAllowNotification;
+    private NotificationManager mMockNotificationManager;
+
+    @Before
+    public void setUp() throws Exception {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+        mMockNotificationManager = Mockito.mock(NotificationManager.class);
+        Resources mockResources = Mockito.mock(Resources.class);
+        when(mockResources.getString(eq(R.string.nfc_tag_alert_title))).thenReturn(TITLE);
+
+        Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mMockContext = new ContextWrapper(context) {
+            @Override
+            public Object getSystemService(String name) {
+                if (Context.NOTIFICATION_SERVICE.equals(name)) {
+                    Log.i(TAG, "[Mock] mMockNotificationManager");
+                    return mMockNotificationManager;
+                }
+                return super.getSystemService(name);
+            }
+
+            @Override
+            public Resources getResources() {
+                Log.i(TAG, "[Mock] getResources");
+                return mockResources;
+            }
+
+            @Override
+            public Intent registerReceiverForAllUsers(@Nullable BroadcastReceiver receiver,
+                    @NonNull IntentFilter filter, @Nullable String broadcastPermission,
+                    @Nullable Handler scheduler) {
+                Log.i(TAG, "[Mock] getIntent");
+                return Mockito.mock(Intent.class);
+            }
+        };
+
+        InstrumentationRegistry.getInstrumentation().runOnMainSync(
+                () -> mNfcTagAllowNotification = new NfcTagAllowNotification(mMockContext, NAME));
+        Assert.assertNotNull(mNfcTagAllowNotification);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testStartNotification() {
+        mNfcTagAllowNotification.startNotification();
+        verify(mMockNotificationManager).createNotificationChannel(any());
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/NfcUnlockManagerTest.java b/tests/unit/src/com/android/nfc/NfcUnlockManagerTest.java
new file mode 100644
index 00000000..4c5ee511
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/NfcUnlockManagerTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.pm.PackageManager;
+import android.nfc.INfcUnlockHandler;
+import android.nfc.Tag;
+import android.os.IBinder;
+import android.os.RemoteException;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+@RunWith(AndroidJUnit4.class)
+public class NfcUnlockManagerTest {
+    private MockitoSession mStaticMockSession;
+    private NfcUnlockManager mNfcUnlockManager;
+
+
+    @Before
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+
+        MockitoAnnotations.initMocks(this);
+        mNfcUnlockManager = NfcUnlockManager.getInstance();
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testAddUnlockHandler() {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(unlockHandler.asBinder()).thenReturn(iBinder);
+        int result = mNfcUnlockManager.addUnlockHandler(unlockHandler, 1);
+        assertThat(result).isEqualTo(1);
+    }
+
+    @Test
+    public void testRemoveUnlockHandler() {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(unlockHandler.asBinder()).thenReturn(iBinder);
+        int result = mNfcUnlockManager.addUnlockHandler(unlockHandler, 1);
+        assertThat(result).isEqualTo(1);
+
+        int pollMask = mNfcUnlockManager.getLockscreenPollMask();
+        assertThat(pollMask).isEqualTo(result);
+        result = mNfcUnlockManager.removeUnlockHandler(iBinder);
+        assertThat(pollMask).isEqualTo(1);
+    }
+
+    @Test
+    public void testTryUnlock() throws RemoteException {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(unlockHandler.asBinder()).thenReturn(iBinder);
+        int result = mNfcUnlockManager.addUnlockHandler(unlockHandler, 1);
+        assertThat(result).isEqualTo(1);
+
+        Tag tag = mock(Tag.class);
+        when(unlockHandler.onUnlockAttempted(tag)).thenReturn(true);
+        boolean status = mNfcUnlockManager.tryUnlock(tag);
+        assertThat(status).isTrue();
+    }
+
+    @Test
+    public void testIsLockScreenPollingEnabled() {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(unlockHandler.asBinder()).thenReturn(iBinder);
+        int result = mNfcUnlockManager.addUnlockHandler(unlockHandler, 1);
+        assertThat(result).isEqualTo(1);
+
+        boolean lockScreenPollMask = mNfcUnlockManager.isLockscreenPollingEnabled();
+        assertThat(lockScreenPollMask).isTrue();
+    }
+
+    @Test
+    public void testGetLockScreenPollMask() {
+        INfcUnlockHandler unlockHandler = mock(INfcUnlockHandler.class);
+        IBinder iBinder = mock(IBinder.class);
+        when(unlockHandler.asBinder()).thenReturn(iBinder);
+        int result = mNfcUnlockManager.addUnlockHandler(unlockHandler, 1);
+        assertThat(result).isEqualTo(1);
+
+        int status = mNfcUnlockManager.getLockscreenPollMask();
+        assertThat(status).isEqualTo(result);
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/cardemulation/CardEmulationManagerTest.java b/tests/unit/src/com/android/nfc/cardemulation/CardEmulationManagerTest.java
index aafd3f74..fb174259 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/CardEmulationManagerTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/CardEmulationManagerTest.java
@@ -16,6 +16,10 @@
 
 package com.android.nfc.cardemulation;
 
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_FAILURE_FEATURE_UNSUPPORTED;
+import static android.nfc.cardemulation.CardEmulation.SET_SERVICE_ENABLED_STATUS_OK;
+
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -28,6 +32,7 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
@@ -38,6 +43,8 @@ import android.app.ActivityManager;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.res.Resources;
+import android.nfc.ComponentNameAndUser;
+import android.nfc.INfcCardEmulation;
 import android.nfc.NfcAdapter;
 import android.nfc.cardemulation.AidGroup;
 import android.nfc.cardemulation.ApduServiceInfo;
@@ -49,10 +56,11 @@ import android.os.PowerManager;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
-import android.util.Pair;
+import android.provider.Settings;
 
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.ForegroundUtils;
+import com.android.nfc.NfcEventLog;
 import com.android.nfc.NfcPermissions;
 import com.android.nfc.NfcService;
 import com.android.nfc.R;
@@ -68,6 +76,7 @@ import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class CardEmulationManagerTest {
@@ -76,87 +85,95 @@ public class CardEmulationManagerTest {
     private static final UserHandle USER_HANDLE = UserHandle.of(USER_ID);
     private static final byte[] TEST_DATA_1 = new byte[] {(byte) 0xd2};
     private static final byte[] TEST_DATA_2 = new byte[] {(byte) 0xd3};
-    private static final byte[] PROPER_SKIP_DATA_NDF1_HEADER = new byte[]
-            {0x00, (byte) 0xa4, 0x04, 0x00, (byte)0x07, (byte) 0xd2, 0x76, 0x00, 0x00,
-                    (byte) 0x85, 0x01, 0x00};
-    private static final byte[] PROPER_SKIP_DATA_NDF2_HEADER = new byte[]
-            {0x00, (byte) 0xa4, 0x04, 0x00, (byte)0x07, (byte) 0xd2, 0x76, 0x00, 0x00,
-                    (byte) 0x85, 0x01, 0x01};
+    private static final byte[] PROPER_SKIP_DATA_NDF1_HEADER =
+            new byte[] {
+                    0x00,
+                    (byte) 0xa4,
+                    0x04,
+                    0x00,
+                    (byte) 0x07,
+                    (byte) 0xd2,
+                    0x76,
+                    0x00,
+                    0x00,
+                    (byte) 0x85,
+                    0x01,
+                    0x00
+            };
+    private static final byte[] PROPER_SKIP_DATA_NDF2_HEADER =
+            new byte[] {
+                    0x00,
+                    (byte) 0xa4,
+                    0x04,
+                    0x00,
+                    (byte) 0x07,
+                    (byte) 0xd2,
+                    0x76,
+                    0x00,
+                    0x00,
+                    (byte) 0x85,
+                    0x01,
+                    0x01
+            };
     private static final String WALLET_HOLDER_PACKAGE_NAME = "com.android.test.walletroleholder";
     private static final List<PollingFrame> POLLING_LOOP_FRAMES = List.of();
     private static final List<ApduServiceInfo> UPDATED_SERVICES = List.of();
     private static final List<NfcFServiceInfo> UPDATED_NFC_SERVICES = List.of();
-    private static final ComponentName WALLET_PAYMENT_SERVICE
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.WalletRoleHolderApduService");
+    private static final ComponentName WALLET_PAYMENT_SERVICE =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.WalletRoleHolderApduService");
     private static final String PAYMENT_AID_1 = "A000000004101012";
 
-    @Mock
-    private Context mContext;
-    @Mock
-    private Resources mResources;
-    @Mock
-    private ForegroundUtils mForegroundUtils;
-    @Mock
-    private WalletRoleObserver mWalletRoleObserver;
-    @Mock
-    private RegisteredAidCache mRegisteredAidCache;
-    @Mock
-    private RegisteredT3tIdentifiersCache mRegisteredT3tIdentifiersCache;
-    @Mock
-    private HostEmulationManager mHostEmulationManager;
-    @Mock
-    private HostNfcFEmulationManager mHostNfcFEmulationManager;
-    @Mock
-    private RegisteredServicesCache mRegisteredServicesCache;
-    @Mock
-    private RegisteredNfcFServicesCache mRegisteredNfcFServicesCache;
-    @Mock
-    private PreferredServices mPreferredServices;
-    @Mock
-    private EnabledNfcFServices mEnabledNfcFServices;
-    @Mock
-    private RoutingOptionManager mRoutingOptionManager;
-    @Mock
-    private PowerManager mPowerManager;
-    @Mock
-    private NfcService mNfcService;
-    @Mock
-    private UserManager mUserManager;
-    @Mock
-    private NfcAdapter mNfcAdapter;
-    @Captor
-    private ArgumentCaptor<List<PollingFrame>> mPollingLoopFrameCaptor;
-    @Captor
-    private ArgumentCaptor<byte[]> mDataCaptor;
-    @Captor
-    private ArgumentCaptor<List<ApduServiceInfo>> mServiceListCaptor;
-    @Captor
-    private ArgumentCaptor<List<NfcFServiceInfo>> mNfcServiceListCaptor;
+    @Mock private Context mContext;
+    @Mock private Resources mResources;
+    @Mock private ForegroundUtils mForegroundUtils;
+    @Mock private WalletRoleObserver mWalletRoleObserver;
+    @Mock private RegisteredAidCache mRegisteredAidCache;
+    @Mock private RegisteredT3tIdentifiersCache mRegisteredT3tIdentifiersCache;
+    @Mock private HostEmulationManager mHostEmulationManager;
+    @Mock private HostNfcFEmulationManager mHostNfcFEmulationManager;
+    @Mock private RegisteredServicesCache mRegisteredServicesCache;
+    @Mock private RegisteredNfcFServicesCache mRegisteredNfcFServicesCache;
+    @Mock private PreferredServices mPreferredServices;
+    @Mock private EnabledNfcFServices mEnabledNfcFServices;
+    @Mock private RoutingOptionManager mRoutingOptionManager;
+    @Mock private PowerManager mPowerManager;
+    @Mock private NfcService mNfcService;
+    @Mock private UserManager mUserManager;
+    @Mock private NfcAdapter mNfcAdapter;
+    @Mock private NfcEventLog mNfcEventLog;
+    @Captor private ArgumentCaptor<List<PollingFrame>> mPollingLoopFrameCaptor;
+    @Captor private ArgumentCaptor<byte[]> mDataCaptor;
+    @Captor private ArgumentCaptor<List<ApduServiceInfo>> mServiceListCaptor;
+    @Captor private ArgumentCaptor<List<NfcFServiceInfo>> mNfcServiceListCaptor;
     private MockitoSession mStaticMockSession;
     private CardEmulationManager mCardEmulationManager;
+
     @Before
     public void setUp() {
-        mStaticMockSession = ExtendedMockito.mockitoSession()
-                .mockStatic(ActivityManager.class)
-                .mockStatic(NfcPermissions.class)
-                .mockStatic(android.nfc.Flags.class)
-                .strictness(Strictness.LENIENT)
-                .mockStatic(NfcService.class)
-                .mockStatic(Binder.class)
-                .mockStatic(UserHandle.class)
-                .mockStatic(NfcAdapter.class)
-                .startMocking();
+        mStaticMockSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(ActivityManager.class)
+                        .mockStatic(NfcPermissions.class)
+                        .mockStatic(android.nfc.Flags.class)
+                        .mockStatic(Settings.Secure.class)
+                        .strictness(Strictness.LENIENT)
+                        .mockStatic(NfcService.class)
+                        .mockStatic(Binder.class)
+                        .mockStatic(UserHandle.class)
+                        .mockStatic(NfcAdapter.class)
+                        .startMocking();
         MockitoAnnotations.initMocks(this);
         when(NfcAdapter.getDefaultAdapter(mContext)).thenReturn(mNfcAdapter);
         when(NfcService.getInstance()).thenReturn(mNfcService);
         when(ActivityManager.getCurrentUser()).thenReturn(USER_ID);
         when(UserHandle.getUserHandleForUid(anyInt())).thenReturn(USER_HANDLE);
-        when(mContext.createContextAsUser(
-                any(), anyInt())).thenReturn(mContext);
+        when(mContext.createContextAsUser(any(), anyInt())).thenReturn(mContext);
         when(mContext.getResources()).thenReturn(mResources);
         when(mContext.getSystemService(eq(UserManager.class))).thenReturn(mUserManager);
         when(mResources.getBoolean(R.bool.indicate_user_activity_for_hce)).thenReturn(true);
+        when(android.nfc.Flags.nfcEventListener()).thenReturn(true);
         mCardEmulationManager = createInstanceWithMockParams();
     }
 
@@ -177,10 +194,10 @@ public class CardEmulationManagerTest {
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mWalletRoleObserver).isWalletRoleFeatureEnabled();
         verify(mWalletRoleObserver).getDefaultWalletRoleHolder(eq(USER_ID));
-        verify(mPreferredServices).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mPreferredServices)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
     }
 
     @Test
@@ -201,8 +218,11 @@ public class CardEmulationManagerTest {
     public void testOnHostCardEmulationActivated_technologyApdu() {
         mCardEmulationManager.onHostCardEmulationActivated(CardEmulationManager.NFC_HCE_APDU);
 
-        verify(mPowerManager).userActivity(anyLong(), eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH),
-                eq(PowerManager.USER_ACTIVITY_FLAG_INDIRECT));
+        verify(mPowerManager)
+                .userActivity(
+                        anyLong(),
+                        eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH),
+                        eq(PowerManager.USER_ACTIVITY_FLAG_INDIRECT));
         verify(mHostEmulationManager).onHostEmulationActivated();
         verify(mPreferredServices).onHostEmulationActivated();
         assertFalse(mCardEmulationManager.mNotSkipAid);
@@ -215,11 +235,15 @@ public class CardEmulationManagerTest {
         mCardEmulationManager.onHostCardEmulationActivated(CardEmulationManager.NFC_HCE_NFCF);
 
         assertConstructorMethodCalls();
-        verify(mPowerManager).userActivity(anyLong(), eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH),
-                eq(PowerManager.USER_ACTIVITY_FLAG_INDIRECT));
+        verify(mPowerManager)
+                .userActivity(
+                        anyLong(),
+                        eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH),
+                        eq(PowerManager.USER_ACTIVITY_FLAG_INDIRECT));
         verify(mHostNfcFEmulationManager).onHostEmulationActivated();
         verify(mRegisteredNfcFServicesCache).onHostEmulationActivated();
         verify(mEnabledNfcFServices).onHostEmulationActivated();
+        verify(mHostEmulationManager).setAidRoutingListener(any());
         verifyZeroInteractions(mHostEmulationManager);
         verifyZeroInteractions(mPreferredServices);
     }
@@ -256,8 +280,8 @@ public class CardEmulationManagerTest {
 
     @Test
     public void testOnHostCardEmulationData_technologyApdu_skipData() {
-        mCardEmulationManager.onHostCardEmulationData(CardEmulationManager.NFC_HCE_APDU,
-                PROPER_SKIP_DATA_NDF1_HEADER);
+        mCardEmulationManager.onHostCardEmulationData(
+                CardEmulationManager.NFC_HCE_APDU, PROPER_SKIP_DATA_NDF1_HEADER);
 
         verify(mHostEmulationManager).onHostEmulationData(mDataCaptor.capture());
         assertEquals(PROPER_SKIP_DATA_NDF1_HEADER, mDataCaptor.getValue());
@@ -267,14 +291,15 @@ public class CardEmulationManagerTest {
 
     @Test
     public void testOnHostCardEmulationData_technologyNfcf_DontSkipData() {
-        mCardEmulationManager.onHostCardEmulationData(CardEmulationManager.NFC_HCE_NFCF,
-                PROPER_SKIP_DATA_NDF1_HEADER);
+        mCardEmulationManager.onHostCardEmulationData(
+                CardEmulationManager.NFC_HCE_NFCF, PROPER_SKIP_DATA_NDF1_HEADER);
 
         verify(mHostNfcFEmulationManager).onHostEmulationData(mDataCaptor.capture());
         assertEquals(PROPER_SKIP_DATA_NDF1_HEADER, mDataCaptor.getValue());
+        verify(mHostEmulationManager).setAidRoutingListener(any());
         verifyZeroInteractions(mHostEmulationManager);
-        verify(mPowerManager).userActivity(anyLong(), eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH),
-                eq(0));
+        verify(mPowerManager)
+                .userActivity(anyLong(), eq(PowerManager.USER_ACTIVITY_EVENT_TOUCH), eq(0));
     }
 
     @Test
@@ -297,6 +322,7 @@ public class CardEmulationManagerTest {
         verify(mHostNfcFEmulationManager).onHostEmulationDeactivated();
         verify(mRegisteredNfcFServicesCache).onHostEmulationDeactivated();
         verify(mEnabledNfcFServices).onHostEmulationDeactivated();
+        verify(mHostEmulationManager).setAidRoutingListener(any());
         verifyZeroInteractions(mHostEmulationManager);
         verifyZeroInteractions(mPreferredServices);
     }
@@ -372,6 +398,7 @@ public class CardEmulationManagerTest {
         verify(mRegisteredAidCache).onServicesUpdated(eq(USER_ID), mServiceListCaptor.capture());
         verify(mPreferredServices).onServicesUpdated();
         assertEquals(UPDATED_SERVICES, mServiceListCaptor.getValue());
+        verify(mHostEmulationManager).setAidRoutingListener(any());
         verifyZeroInteractions(mHostEmulationManager);
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_UPDATED));
     }
@@ -386,8 +413,8 @@ public class CardEmulationManagerTest {
         verify(mWalletRoleObserver, times(2)).isWalletRoleFeatureEnabled();
         verify(mRegisteredAidCache).onServicesUpdated(eq(USER_ID), mServiceListCaptor.capture());
         verify(mPreferredServices).onServicesUpdated();
-        verify(mHostEmulationManager).updatePollingLoopFilters(eq(USER_ID),
-                mServiceListCaptor.capture());
+        verify(mHostEmulationManager)
+                .updatePollingLoopFilters(eq(USER_ID), mServiceListCaptor.capture());
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_UPDATED));
         assertEquals(UPDATED_SERVICES, mServiceListCaptor.getAllValues().getFirst());
         assertEquals(UPDATED_SERVICES, mServiceListCaptor.getAllValues().getLast());
@@ -397,8 +424,8 @@ public class CardEmulationManagerTest {
     public void testOnNfcFServicesUpdated() {
         mCardEmulationManager.onNfcFServicesUpdated(USER_ID, UPDATED_NFC_SERVICES);
 
-        verify(mRegisteredT3tIdentifiersCache).onServicesUpdated(eq(USER_ID),
-                mNfcServiceListCaptor.capture());
+        verify(mRegisteredT3tIdentifiersCache)
+                .onServicesUpdated(eq(USER_ID), mNfcServiceListCaptor.capture());
         assertEquals(UPDATED_NFC_SERVICES, mNfcServiceListCaptor.getValue());
     }
 
@@ -406,46 +433,42 @@ public class CardEmulationManagerTest {
     public void testIsServiceRegistered_serviceExists() {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager
-                .isServiceRegistered(USER_ID, WALLET_PAYMENT_SERVICE));
+        assertTrue(mCardEmulationManager.isServiceRegistered(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
     public void testIsServiceRegistered_serviceDoesNotExists() {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
-        assertFalse(mCardEmulationManager
-                .isServiceRegistered(USER_ID, WALLET_PAYMENT_SERVICE));
+        assertFalse(mCardEmulationManager.isServiceRegistered(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
     public void testIsNfcServiceInstalled_serviceExists() {
         when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager
-                .isNfcFServiceInstalled(USER_ID, WALLET_PAYMENT_SERVICE));
+        assertTrue(mCardEmulationManager.isNfcFServiceInstalled(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
     public void testIsNfcServiceInstalled_serviceDoesNotExists() {
         when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
-        assertFalse(mCardEmulationManager
-                .isNfcFServiceInstalled(USER_ID, WALLET_PAYMENT_SERVICE));
+        assertFalse(mCardEmulationManager.isNfcFServiceInstalled(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
@@ -453,8 +476,7 @@ public class CardEmulationManagerTest {
         when(mPreferredServices.packageHasPreferredService(eq(WALLET_HOLDER_PACKAGE_NAME)))
                 .thenReturn(true);
 
-        assertTrue(mCardEmulationManager
-                .packageHasPreferredService(WALLET_HOLDER_PACKAGE_NAME));
+        assertTrue(mCardEmulationManager.packageHasPreferredService(WALLET_HOLDER_PACKAGE_NAME));
 
         verify(mPreferredServices).packageHasPreferredService(eq(WALLET_HOLDER_PACKAGE_NAME));
     }
@@ -467,18 +489,22 @@ public class CardEmulationManagerTest {
         when(mWalletRoleObserver.getDefaultWalletRoleHolder(eq(USER_ID)))
                 .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultServiceForCategory(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .isDefaultServiceForCategory(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
@@ -487,43 +513,49 @@ public class CardEmulationManagerTest {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
         assertConstructorMethodCalls();
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultServiceForCategory(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .isDefaultServiceForCategory(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verifyZeroInteractions(mWalletRoleObserver);
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
-    public void testCardEmulationIsDefaultServiceForAid_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationIsDefaultServiceForAid_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
         when(mRegisteredAidCache.isDefaultServiceForAid(eq(USER_ID), any(), eq(PAYMENT_AID_1)))
                 .thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultServiceForAid(USER_ID, WALLET_PAYMENT_SERVICE,
-                        PAYMENT_AID_1));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        verify(mRegisteredAidCache).isDefaultServiceForAid(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE),
-                eq(PAYMENT_AID_1));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .isDefaultServiceForAid(USER_ID, WALLET_PAYMENT_SERVICE, PAYMENT_AID_1));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        verify(mRegisteredAidCache)
+                .isDefaultServiceForAid(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE), eq(PAYMENT_AID_1));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
@@ -531,42 +563,48 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultServiceForAid(USER_ID, WALLET_PAYMENT_SERVICE,
-                        PAYMENT_AID_1));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .isDefaultServiceForAid(USER_ID, WALLET_PAYMENT_SERVICE, PAYMENT_AID_1));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyZeroInteractions(mRegisteredAidCache);
     }
 
     @Test
-    public void testCardEmulationSetDefaultForNextTap_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationSetDefaultForNextTap_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
         when(mPreferredServices.setDefaultForNextTap(anyInt(), any())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setDefaultForNextTap(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateProfileId(mContext, USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceAdminPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setDefaultForNextTap(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateProfileId(mContext, USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceAdminPermissions(mContext);
+                });
         verify(mPreferredServices).setDefaultForNextTap(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
     }
 
     @Test
@@ -574,20 +612,24 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setDefaultForNextTap(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateProfileId(mContext, USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceAdminPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setDefaultForNextTap(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateProfileId(mContext, USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceAdminPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mPreferredServices).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mPreferredServices)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verifyZeroInteractions(mPreferredServices);
     }
 
@@ -595,28 +637,33 @@ public class CardEmulationManagerTest {
     public void testCardEmulationSetShouldDefaultToObserveModeForService_serviceExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.setShouldDefaultToObserveModeForService(anyInt(), anyInt(),
-                any(), anyBoolean())).thenReturn(true);
-        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(),
-                any())).thenReturn(false);
-
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setShouldDefaultToObserveModeForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        true));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        when(mRegisteredServicesCache.setShouldDefaultToObserveModeForService(
+                anyInt(), anyInt(), any(), anyBoolean()))
+                .thenReturn(true);
+        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
+                .thenReturn(false);
+
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setShouldDefaultToObserveModeForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, true));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
+        verify(mRegisteredServicesCache).doesServiceShouldDefaultToObserveMode(anyInt(), any());
         verify(mRegisteredServicesCache)
-                .doesServiceShouldDefaultToObserveMode(anyInt(), any());
-        verify(mRegisteredServicesCache).setShouldDefaultToObserveModeForService(eq(USER_ID),
-                anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(true));
+                .setShouldDefaultToObserveModeForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -624,22 +671,27 @@ public class CardEmulationManagerTest {
     public void testCardEmulationSetShouldDefaultToObserveModeForService_ignoreNoopStateChange()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.setShouldDefaultToObserveModeForService(anyInt(), anyInt(),
-                any(), anyBoolean())).thenReturn(true);
-        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(),
-                any())).thenReturn(false);
+        when(mRegisteredServicesCache.setShouldDefaultToObserveModeForService(
+                anyInt(), anyInt(), any(), anyBoolean()))
+                .thenReturn(true);
+        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
+                .thenReturn(false);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setShouldDefaultToObserveModeForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        true));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setShouldDefaultToObserveModeForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, true));
 
-        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(),
-                any())).thenReturn(true);
+        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
+                .thenReturn(true);
 
         // Called twice with the same value. Calls to update should be ignored.
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setShouldDefaultToObserveModeForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        true));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setShouldDefaultToObserveModeForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, true));
 
         ExtendedMockito.verify(() -> NfcPermissions.validateUserId(USER_ID), times(2));
         ExtendedMockito.verify(() -> NfcPermissions.enforceUserPermissions(mContext), times(2));
@@ -651,8 +703,8 @@ public class CardEmulationManagerTest {
 
         // Importantly this should only be called once.
         verify(mRegisteredServicesCache, times(1))
-                .setShouldDefaultToObserveModeForService(eq(USER_ID), anyInt(),
-                        eq(WALLET_PAYMENT_SERVICE), eq(true));
+                .setShouldDefaultToObserveModeForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(true));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -661,45 +713,54 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setShouldDefaultToObserveModeForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        false));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setShouldDefaultToObserveModeForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, false));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationRegisterAidGroupForService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationRegisterAidGroupForService_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.registerAidGroupForService(eq(USER_ID), anyInt(), any(),
-                any())).thenReturn(true);
+        when(mRegisteredServicesCache.registerAidGroupForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         AidGroup aidGroup = Mockito.mock(AidGroup.class);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE, aidGroup));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE, aidGroup));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).registerAidGroupForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE), eq(aidGroup));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .registerAidGroupForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(aidGroup));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -707,24 +768,29 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRegisterAidGroupForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.registerAidGroupForService(eq(USER_ID), anyInt(), any(),
-                any())).thenReturn(true);
+        when(mRegisteredServicesCache.registerAidGroupForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         AidGroup aidGroup = Mockito.mock(AidGroup.class);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE, aidGroup));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                        eq(USER_ID));
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE, aidGroup));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredAidCache);
     }
 
@@ -732,25 +798,35 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRegisterPollingLoopFilterForService_serviceExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.registerPollingLoopFilterForService(eq(USER_ID), anyInt(),
-                any(), any(),anyBoolean())).thenReturn(true);
+        when(mRegisteredServicesCache.registerPollingLoopFilterForService(
+                eq(USER_ID), anyInt(), any(), any(), anyBoolean()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerPollingLoopFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter, true));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerPollingLoopFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter, true));
 
         verify(mRegisteredServicesCache).initialize();
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).registerPollingLoopFilterForService(eq(USER_ID),
-                anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter), eq(true));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .registerPollingLoopFilterForService(
+                        eq(USER_ID),
+                        anyInt(),
+                        eq(WALLET_PAYMENT_SERVICE),
+                        eq(pollingLoopFilter),
+                        eq(true));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -758,24 +834,29 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRegisterPollingLoopFilterForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.registerPollingLoopFilterForService(eq(USER_ID), anyInt(),
-                any(), any(),anyBoolean())).thenReturn(true);
+        when(mRegisteredServicesCache.registerPollingLoopFilterForService(
+                eq(USER_ID), anyInt(), any(), any(), anyBoolean()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerPollingLoopFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter, true));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerPollingLoopFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter, true));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -783,25 +864,31 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRemovePollingLoopFilterForService_serviceExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.removePollingLoopFilterForService(eq(USER_ID), anyInt(),
-                any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removePollingLoopFilterForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removePollingLoopFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removePollingLoopFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).removePollingLoopFilterForService(eq(USER_ID),
-                anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .removePollingLoopFilterForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -809,24 +896,29 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRemovePollingLoopFilterForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.removePollingLoopFilterForService(eq(USER_ID), anyInt(),
-                any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removePollingLoopFilterForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removePollingLoopFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removePollingLoopFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -834,25 +926,35 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRegisterPollingLoopPatternFilterForService_serviceExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.registerPollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), any(), any(), anyBoolean())).thenReturn(true);
+        when(mRegisteredServicesCache.registerPollingLoopPatternFilterForService(
+                eq(USER_ID), anyInt(), any(), any(), anyBoolean()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerPollingLoopPatternFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter, true));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerPollingLoopPatternFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter, true));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).registerPollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter), eq(true));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .registerPollingLoopPatternFilterForService(
+                        eq(USER_ID),
+                        anyInt(),
+                        eq(WALLET_PAYMENT_SERVICE),
+                        eq(pollingLoopFilter),
+                        eq(true));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -860,24 +962,29 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRegisterPollingLoopPatternFilterForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.registerPollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), any(), any(), anyBoolean())).thenReturn(true);
+        when(mRegisteredServicesCache.registerPollingLoopPatternFilterForService(
+                eq(USER_ID), anyInt(), any(), any(), anyBoolean()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .registerPollingLoopPatternFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter, true));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .registerPollingLoopPatternFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter, true));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -885,25 +992,31 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRemovePollingLoopPatternFilterForService_serviceExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.removePollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removePollingLoopPatternFilterForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removePollingLoopPatternFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removePollingLoopPatternFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).removePollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .removePollingLoopPatternFilterForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(pollingLoopFilter));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -911,49 +1024,58 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRemovePollingLoopPatternFilterForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.removePollingLoopPatternFilterForService(eq(USER_ID),
-                anyInt(), any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removePollingLoopPatternFilterForService(
+                eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String pollingLoopFilter = "filter";
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removePollingLoopPatternFilterForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        pollingLoopFilter));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removePollingLoopPatternFilterForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, pollingLoopFilter));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationSetOffHostForService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationSetOffHostForService_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.setOffHostSecureElement(eq(USER_ID),
-                anyInt(), any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.setOffHostSecureElement(eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String offhostse = "offhostse";
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE, offhostse));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE, offhostse));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).setOffHostSecureElement(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE) , eq(offhostse));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .setOffHostSecureElement(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(offhostse));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -961,47 +1083,54 @@ public class CardEmulationManagerTest {
     public void testCardEmulationSetOffHostForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.setOffHostSecureElement(eq(USER_ID),
-                anyInt(), any(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.setOffHostSecureElement(eq(USER_ID), anyInt(), any(), any()))
+                .thenReturn(true);
         String offhostse = "offhostse";
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE, offhostse));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE, offhostse));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationUnsetOffHostForService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationUnsetOffHostForService_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.resetOffHostSecureElement(eq(USER_ID),
-                anyInt(), any())).thenReturn(true);
-
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .unsetOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE));
+        when(mRegisteredServicesCache.resetOffHostSecureElement(eq(USER_ID), anyInt(), any()))
+                .thenReturn(true);
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .unsetOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).resetOffHostSecureElement(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .resetOffHostSecureElement(eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_UPDATED));
     }
@@ -1010,48 +1139,61 @@ public class CardEmulationManagerTest {
     public void testCardEmulationUnsetOffHostForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.resetOffHostSecureElement(eq(USER_ID),
-                anyInt(), any())).thenReturn(true);
-
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .unsetOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE));
+        when(mRegisteredServicesCache.resetOffHostSecureElement(eq(USER_ID), anyInt(), any()))
+                .thenReturn(true);
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .unsetOffHostForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationGetAidGroupForService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationGetAidGroupForService_serviceExists() throws RemoteException {
         AidGroup aidGroup = Mockito.mock(AidGroup.class);
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.getAidGroupForService(eq(USER_ID),
-                anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(aidGroup);
-
-        assertEquals(aidGroup, mCardEmulationManager.getNfcCardEmulationInterface()
-                .getAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        when(mRegisteredServicesCache.getAidGroupForService(
+                eq(USER_ID), anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(aidGroup);
+
+        assertEquals(
+                aidGroup,
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .getAidGroupForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).getAidGroupForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE), eq(CardEmulation.CATEGORY_PAYMENT));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .getAidGroupForService(
+                        eq(USER_ID),
+                        anyInt(),
+                        eq(WALLET_PAYMENT_SERVICE),
+                        eq(CardEmulation.CATEGORY_PAYMENT));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -1060,48 +1202,61 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         AidGroup aidGroup = Mockito.mock(AidGroup.class);
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.getAidGroupForService(eq(USER_ID),
-                anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(aidGroup);
-
-        assertNull(mCardEmulationManager.getNfcCardEmulationInterface()
-                .getAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        when(mRegisteredServicesCache.getAidGroupForService(
+                eq(USER_ID), anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(aidGroup);
+
+        assertNull(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .getAidGroupForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationRemoveAidGroupForService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationRemoveAidGroupForService_serviceExists() throws RemoteException {
         AidGroup aidGroup = Mockito.mock(AidGroup.class);
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mRegisteredServicesCache.removeAidGroupForService(eq(USER_ID),
-                anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(true);
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removeAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        when(mRegisteredServicesCache.removeAidGroupForService(
+                eq(USER_ID), anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(true);
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removeAidGroupForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredServicesCache).removeAidGroupForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE), eq(CardEmulation.CATEGORY_PAYMENT));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredServicesCache)
+                .removeAidGroupForService(
+                        eq(USER_ID),
+                        anyInt(),
+                        eq(WALLET_PAYMENT_SERVICE),
+                        eq(CardEmulation.CATEGORY_PAYMENT));
         verifyNoMoreInteractions(mRegisteredServicesCache);
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_UPDATED));
     }
@@ -1110,110 +1265,124 @@ public class CardEmulationManagerTest {
     public void testCardEmulationRemoveAidGroupForService_serviceDoesNotExists()
             throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.removeAidGroupForService(eq(USER_ID),
-                anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(true);
-
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .removeAidGroupForService(USER_ID, WALLET_PAYMENT_SERVICE,
-                        CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
+        when(mRegisteredServicesCache.removeAidGroupForService(
+                eq(USER_ID), anyInt(), any(), eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(true);
+
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .removeAidGroupForService(
+                                USER_ID, WALLET_PAYMENT_SERVICE, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationGetServices()
-            throws RemoteException {
+    public void testCardEmulationGetServices() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mRegisteredServicesCache.getServicesForCategory(eq(USER_ID),
-                eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(UPDATED_SERVICES);
-
-        assertEquals(UPDATED_SERVICES, mCardEmulationManager.getNfcCardEmulationInterface()
-                .getServices(USER_ID, CardEmulation.CATEGORY_PAYMENT));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateProfileId(mContext, USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceAdminPermissions(mContext);
-        });
+        when(mRegisteredServicesCache.getServicesForCategory(
+                eq(USER_ID), eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(UPDATED_SERVICES);
+
+        assertEquals(
+                UPDATED_SERVICES,
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .getServices(USER_ID, CardEmulation.CATEGORY_PAYMENT));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateProfileId(mContext, USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceAdminPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
-        verify(mRegisteredServicesCache).getServicesForCategory(eq(USER_ID),
-                eq(CardEmulation.CATEGORY_PAYMENT));
+        verify(mRegisteredServicesCache)
+                .getServicesForCategory(eq(USER_ID), eq(CardEmulation.CATEGORY_PAYMENT));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
     @Test
-    public void testCardEmulationSetPreferredService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationSetPreferredService_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mPreferredServices.registerPreferredForegroundService(eq(WALLET_PAYMENT_SERVICE),
-                anyInt())).thenReturn(true);
+        when(mPreferredServices.registerPreferredForegroundService(
+                eq(WALLET_PAYMENT_SERVICE), anyInt()))
+                .thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setPreferredService(WALLET_PAYMENT_SERVICE));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setPreferredService(WALLET_PAYMENT_SERVICE));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
-        verify(mPreferredServices).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
-        verify(mPreferredServices).registerPreferredForegroundService(eq(WALLET_PAYMENT_SERVICE),
-                anyInt());
+        verify(mPreferredServices)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mPreferredServices)
+                .registerPreferredForegroundService(eq(WALLET_PAYMENT_SERVICE), anyInt());
         verifyNoMoreInteractions(mPreferredServices);
     }
 
     @Test
-    public void testCardEmulationSetPreferredService_serviceDoesNotExists()
-            throws RemoteException {
+    public void testCardEmulationSetPreferredService_serviceDoesNotExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
-        when(mPreferredServices.registerPreferredForegroundService(eq(WALLET_PAYMENT_SERVICE),
-                anyInt())).thenReturn(false);
+        when(mPreferredServices.registerPreferredForegroundService(
+                eq(WALLET_PAYMENT_SERVICE), anyInt()))
+                .thenReturn(false);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setPreferredService(WALLET_PAYMENT_SERVICE));
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setPreferredService(WALLET_PAYMENT_SERVICE));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
         verify(mRegisteredServicesCache).invalidateCache(eq(USER_ID), eq(true));
         verify(mRegisteredServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredServicesCache);
-        verify(mPreferredServices).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mPreferredServices)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verifyNoMoreInteractions(mPreferredServices);
     }
 
     @Test
-    public void testCardEmulationUnsetPreferredService_serviceExists()
-            throws RemoteException {
+    public void testCardEmulationUnsetPreferredService_serviceExists() throws RemoteException {
         when(mRegisteredServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
-        when(mPreferredServices.unregisteredPreferredForegroundService(anyInt()))
-                .thenReturn(true);
+        when(mPreferredServices.unregisteredPreferredForegroundService(anyInt())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .unsetPreferredService());
+        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface().unsetPreferredService());
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        verify(mPreferredServices).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        verify(mPreferredServices)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mPreferredServices).unregisteredPreferredForegroundService(anyInt());
         verifyNoMoreInteractions(mPreferredServices);
     }
@@ -1221,14 +1390,14 @@ public class CardEmulationManagerTest {
     @Test
     public void testCardEmulationUnsetPreferredService_serviceDoesNotExists()
             throws RemoteException {
-        when(mPreferredServices.unregisteredPreferredForegroundService(anyInt()))
-                .thenReturn(false);
+        when(mPreferredServices.unregisteredPreferredForegroundService(anyInt())).thenReturn(false);
 
         assertFalse(mCardEmulationManager.getNfcCardEmulationInterface().unsetPreferredService());
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mPreferredServices).unregisteredPreferredForegroundService(anyInt());
     }
 
@@ -1237,8 +1406,10 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mRegisteredAidCache.supportsAidPrefixRegistration()).thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .supportsAidPrefixRegistration());
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .supportsAidPrefixRegistration());
 
         verify(mRegisteredAidCache).supportsAidPrefixRegistration();
     }
@@ -1248,39 +1419,46 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mRegisteredAidCache.supportsAidPrefixRegistration()).thenReturn(false);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .supportsAidPrefixRegistration());
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .supportsAidPrefixRegistration());
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRegisteredAidCache).supportsAidPrefixRegistration();
         verifyNoMoreInteractions(mRegisteredAidCache);
     }
 
     @Test
-    public void testCardEmulationGetPreferredPaymentService()
-            throws RemoteException {
+    public void testCardEmulationGetPreferredPaymentService() throws RemoteException {
         ApduServiceInfo apduServiceInfo = Mockito.mock(ApduServiceInfo.class);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(mRegisteredServicesCache.getService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE)))
                 .thenReturn(apduServiceInfo);
 
-        assertEquals(apduServiceInfo, mCardEmulationManager.getNfcCardEmulationInterface()
-                .getPreferredPaymentService(USER_ID));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforcePreferredPaymentInfoPermissions(mContext);
-        });
+        assertEquals(
+                apduServiceInfo,
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .getPreferredPaymentService(USER_ID));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforcePreferredPaymentInfoPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRegisteredAidCache).getPreferredService();
         verify(mRegisteredServicesCache).getService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredAidCache);
@@ -1292,17 +1470,21 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mResources.getBoolean(R.bool.enable_service_for_category_other)).thenReturn(true);
         when(mRegisteredServicesCache.registerOtherForService(anyInt(), any(), anyBoolean()))
-                .thenReturn(true);
-
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setServiceEnabledForCategoryOther(USER_ID, WALLET_PAYMENT_SERVICE, true));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+                .thenReturn(SET_SERVICE_ENABLED_STATUS_OK);
+
+        assertEquals(SET_SERVICE_ENABLED_STATUS_OK,
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setServiceEnabledForCategoryOther(USER_ID, WALLET_PAYMENT_SERVICE, true)
+        );
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredServicesCache).initialize();
-        verify(mRegisteredServicesCache).registerOtherForService(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE), eq(true));
+        verify(mRegisteredServicesCache)
+                .registerOtherForService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE), eq(true));
         verifyNoMoreInteractions(mRegisteredServicesCache);
     }
 
@@ -1311,10 +1493,13 @@ public class CardEmulationManagerTest {
             throws RemoteException {
         when(mResources.getBoolean(R.bool.enable_service_for_category_other)).thenReturn(false);
         when(mRegisteredServicesCache.registerOtherForService(anyInt(), any(), anyBoolean()))
-                .thenReturn(true);
+                .thenReturn(SET_SERVICE_ENABLED_STATUS_OK);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .setServiceEnabledForCategoryOther(USER_ID, WALLET_PAYMENT_SERVICE, true));
+        assertEquals(SET_SERVICE_ENABLED_STATUS_FAILURE_FEATURE_UNSUPPORTED,
+                mCardEmulationManager
+                        .getNfcCardEmulationInterface()
+                        .setServiceEnabledForCategoryOther(USER_ID, WALLET_PAYMENT_SERVICE, true)
+        );
 
         verify(mRegisteredServicesCache).initialize();
         verifyNoMoreInteractions(mRegisteredServicesCache);
@@ -1328,44 +1513,43 @@ public class CardEmulationManagerTest {
                 .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
         when(Binder.getCallingUserHandle()).thenReturn(USER_HANDLE);
 
-        assertTrue(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultPaymentRegistered());
+        assertTrue(
+                mCardEmulationManager.getNfcCardEmulationInterface().isDefaultPaymentRegistered());
 
         verify(mWalletRoleObserver, times(2)).isWalletRoleFeatureEnabled();
-        verify(mWalletRoleObserver, times(2))
-                .getDefaultWalletRoleHolder(eq(USER_ID));
+        verify(mWalletRoleObserver, times(2)).getDefaultWalletRoleHolder(eq(USER_ID));
     }
 
     @Test
     public void testCardEmulationIsDefaultPaymentRegistered_walletRoleEnabledWalletNone()
             throws RemoteException {
         when(mWalletRoleObserver.isWalletRoleFeatureEnabled()).thenReturn(true);
-        when(mWalletRoleObserver.getDefaultWalletRoleHolder(anyInt()))
-                .thenReturn(null);
+        when(mWalletRoleObserver.getDefaultWalletRoleHolder(anyInt())).thenReturn(null);
         when(Binder.getCallingUserHandle()).thenReturn(USER_HANDLE);
 
-        assertFalse(mCardEmulationManager.getNfcCardEmulationInterface()
-                .isDefaultPaymentRegistered());
+        assertFalse(
+                mCardEmulationManager.getNfcCardEmulationInterface().isDefaultPaymentRegistered());
 
         verify(mWalletRoleObserver, times(2)).isWalletRoleFeatureEnabled();
-        verify(mWalletRoleObserver, times(2))
-                .getDefaultWalletRoleHolder(eq(USER_ID));
+        verify(mWalletRoleObserver, times(2)).getDefaultWalletRoleHolder(eq(USER_ID));
     }
 
     @Test
-    public void testCardEmulationOverrideRoutingTable_callerNotForeground()
-            throws RemoteException {
-        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt()))
-                .thenReturn(false);
+    public void testCardEmulationOverrideRoutingTable_callerNotForeground() throws RemoteException {
+        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt())).thenReturn(false);
         String protocol = "DH";
         String technology = "DH";
 
-        assertThrows(IllegalArgumentException.class,
-                () -> mCardEmulationManager.getNfcCardEmulationInterface()
-                .overrideRoutingTable(USER_ID, protocol, technology, WALLET_HOLDER_PACKAGE_NAME));
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        mCardEmulationManager
+                                .getNfcCardEmulationInterface()
+                                .overrideRoutingTable(
+                                        USER_ID, protocol, technology, WALLET_HOLDER_PACKAGE_NAME));
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).getOffHostRouteEse();
         verify(mRoutingOptionManager).getOffHostRouteUicc();
         verifyNoMoreInteractions(mRoutingOptionManager);
@@ -1375,14 +1559,14 @@ public class CardEmulationManagerTest {
     @Test
     public void testCardEmulationOverrideRoutingTable_callerForegroundRouteNull()
             throws RemoteException {
-        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt()))
-                .thenReturn(true);
+        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt())).thenReturn(true);
 
-        mCardEmulationManager.getNfcCardEmulationInterface()
+        mCardEmulationManager
+                .getNfcCardEmulationInterface()
                 .overrideRoutingTable(USER_ID, null, null, WALLET_HOLDER_PACKAGE_NAME);
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).overrideDefaultIsoDepRoute(eq(-1));
         verify(mRoutingOptionManager).overrideDefaultOffHostRoute(eq(-1));
         verify(mRoutingOptionManager).getOffHostRouteEse();
@@ -1395,16 +1579,16 @@ public class CardEmulationManagerTest {
     @Test
     public void testCardEmulationOverrideRoutingTable_callerForegroundRouteDH()
             throws RemoteException {
-        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt()))
-                .thenReturn(true);
+        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt())).thenReturn(true);
         String protocol = "DH";
         String technology = "DH";
 
-        mCardEmulationManager.getNfcCardEmulationInterface()
+        mCardEmulationManager
+                .getNfcCardEmulationInterface()
                 .overrideRoutingTable(USER_ID, protocol, technology, WALLET_HOLDER_PACKAGE_NAME);
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).overrideDefaultIsoDepRoute(eq(0));
         verify(mRoutingOptionManager).overrideDefaultOffHostRoute(eq(0));
         verify(mRoutingOptionManager).getOffHostRouteEse();
@@ -1417,16 +1601,16 @@ public class CardEmulationManagerTest {
     @Test
     public void testCardEmulationOverrideRoutingTable_callerForegroundRouteeSE()
             throws RemoteException {
-        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt()))
-                .thenReturn(true);
+        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt())).thenReturn(true);
         String protocol = "eSE1";
         String technology = "eSE1";
 
-        mCardEmulationManager.getNfcCardEmulationInterface()
+        mCardEmulationManager
+                .getNfcCardEmulationInterface()
                 .overrideRoutingTable(USER_ID, protocol, technology, WALLET_HOLDER_PACKAGE_NAME);
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).overrideDefaultIsoDepRoute(eq(TEST_DATA_1[0] & 0xFF));
         verify(mRoutingOptionManager).overrideDefaultOffHostRoute(eq(TEST_DATA_1[0] & 0xFF));
         verify(mRoutingOptionManager).getOffHostRouteEse();
@@ -1439,16 +1623,16 @@ public class CardEmulationManagerTest {
     @Test
     public void testCardEmulationOverrideRoutingTable_callerForegroundRouteSIM()
             throws RemoteException {
-        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt()))
-                .thenReturn(true);
+        when(mForegroundUtils.registerUidToBackgroundCallback(any(), anyInt())).thenReturn(true);
         String protocol = "SIM1";
         String technology = "SIM1";
 
-        mCardEmulationManager.getNfcCardEmulationInterface()
+        mCardEmulationManager
+                .getNfcCardEmulationInterface()
                 .overrideRoutingTable(USER_ID, protocol, technology, WALLET_HOLDER_PACKAGE_NAME);
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).overrideDefaultIsoDepRoute(eq(TEST_DATA_2[0] & 0xFF));
         verify(mRoutingOptionManager).overrideDefaultOffHostRoute(eq(TEST_DATA_2[0] & 0xFF));
         verify(mRoutingOptionManager).getOffHostRouteEse();
@@ -1459,16 +1643,13 @@ public class CardEmulationManagerTest {
     }
 
     @Test
-    public void testCardEmulationRecoverRoutingTable_callerForeground()
-            throws RemoteException {
-        when(mForegroundUtils.isInForeground(anyInt()))
-                .thenReturn(true);
+    public void testCardEmulationRecoverRoutingTable_callerForeground() throws RemoteException {
+        when(mForegroundUtils.isInForeground(anyInt())).thenReturn(true);
 
-        mCardEmulationManager.getNfcCardEmulationInterface()
-                .recoverRoutingTable(USER_ID);
+        mCardEmulationManager.getNfcCardEmulationInterface().recoverRoutingTable(USER_ID);
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).recoverOverridedRoutingTable();
         verify(mRoutingOptionManager).getOffHostRouteEse();
         verify(mRoutingOptionManager).getOffHostRouteUicc();
@@ -1478,17 +1659,18 @@ public class CardEmulationManagerTest {
     }
 
     @Test
-    public void testCardEmulationRecoverRoutingTable_callerNotForeground()
-            throws RemoteException {
-        when(mForegroundUtils.isInForeground(anyInt()))
-                .thenReturn(false);
+    public void testCardEmulationRecoverRoutingTable_callerNotForeground() throws RemoteException {
+        when(mForegroundUtils.isInForeground(anyInt())).thenReturn(false);
 
-        assertThrows(IllegalArgumentException.class,
-                () -> mCardEmulationManager.getNfcCardEmulationInterface()
-                .recoverRoutingTable(USER_ID));
+        assertThrows(
+                IllegalArgumentException.class,
+                () ->
+                        mCardEmulationManager
+                                .getNfcCardEmulationInterface()
+                                .recoverRoutingTable(USER_ID));
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME),
-                eq(USER_ID));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRoutingOptionManager).getOffHostRouteEse();
         verify(mRoutingOptionManager).getOffHostRouteUicc();
         verifyNoMoreInteractions(mRoutingOptionManager);
@@ -1499,25 +1681,29 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationGetSystemCodeForService_serviceExists()
             throws RemoteException {
         String systemCode = "systemCode";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(true);
-        when(mRegisteredNfcFServicesCache.getSystemCodeForService(anyInt(),
-                anyInt(), any())).thenReturn(systemCode);
-
-        assertEquals(systemCode, mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.getSystemCodeForService(anyInt(), anyInt(), any()))
+                .thenReturn(systemCode);
+
+        assertEquals(
+                systemCode,
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .getSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredNfcFServicesCache).getSystemCodeForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredNfcFServicesCache)
+                .getSystemCodeForService(eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
@@ -1525,24 +1711,27 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationGetSystemCodeForService_serviceDoesNotExists()
             throws RemoteException {
         String systemCode = "systemCode";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mRegisteredNfcFServicesCache.getSystemCodeForService(anyInt(),
-                anyInt(), any())).thenReturn(systemCode);
-
-        assertNull(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mRegisteredNfcFServicesCache.getSystemCodeForService(anyInt(), anyInt(), any()))
+                .thenReturn(systemCode);
+
+        assertNull(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .getSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
@@ -1550,25 +1739,30 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationRegisterSystemCodeForService_serviceExists()
             throws RemoteException {
         String systemCode = "systemCode";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.registerSystemCodeForService(
+                anyInt(), anyInt(), any(), anyString()))
                 .thenReturn(true);
-        when(mRegisteredNfcFServicesCache.registerSystemCodeForService(anyInt(),
-                anyInt(), any(), anyString())).thenReturn(true);
-
-        assertTrue(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .registerSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE, systemCode));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .registerSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE, systemCode));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredNfcFServicesCache).registerSystemCodeForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE), eq(systemCode));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredNfcFServicesCache)
+                .registerSystemCodeForService(
+                        eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(systemCode));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
@@ -1576,99 +1770,112 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationRegisterSystemCodeForService_serviceDoesNotExists()
             throws RemoteException {
         String systemCode = "systemCode";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mRegisteredNfcFServicesCache.registerSystemCodeForService(anyInt(),
-                anyInt(), any(), anyString())).thenReturn(true);
-
-        assertFalse(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .registerSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE, systemCode));
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mRegisteredNfcFServicesCache.registerSystemCodeForService(
+                anyInt(), anyInt(), any(), anyString()))
+                .thenReturn(true);
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .registerSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE, systemCode));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
     public void testNfcFCardEmulationRemoveSystemCodeForService_serviceExists()
             throws RemoteException {
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.removeSystemCodeForService(anyInt(), anyInt(), any()))
                 .thenReturn(true);
-        when(mRegisteredNfcFServicesCache.removeSystemCodeForService(anyInt(),
-                anyInt(), any())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .removeSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .removeSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredNfcFServicesCache).removeSystemCodeForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredNfcFServicesCache)
+                .removeSystemCodeForService(eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
     public void testNfcFCardEmulationRemoveSystemCodeForService_serviceDoesNotExists()
             throws RemoteException {
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mRegisteredNfcFServicesCache.removeSystemCodeForService(anyInt(),
-                anyInt(), any())).thenReturn(true);
-
-        assertFalse(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .removeSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mRegisteredNfcFServicesCache.removeSystemCodeForService(anyInt(), anyInt(), any()))
+                .thenReturn(true);
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .removeSystemCodeForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
-    public void testNfcFCardEmulationGetNfcid2ForService_serviceExists()
-            throws RemoteException {
+    public void testNfcFCardEmulationGetNfcid2ForService_serviceExists() throws RemoteException {
         String nfcid2 = "nfcid2";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(true);
-        when(mRegisteredNfcFServicesCache.getNfcid2ForService(anyInt(),
-                anyInt(), any())).thenReturn(nfcid2);
-
-        assertEquals(nfcid2, mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.getNfcid2ForService(anyInt(), anyInt(), any()))
+                .thenReturn(nfcid2);
+
+        assertEquals(
+                nfcid2,
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .getNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredNfcFServicesCache).getNfcid2ForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredNfcFServicesCache)
+                .getNfcid2ForService(eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
@@ -1676,50 +1883,56 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationGetNfcid2ForService_serviceDoesNotExists()
             throws RemoteException {
         String nfcid2 = "nfcid2";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mRegisteredNfcFServicesCache.getNfcid2ForService(anyInt(),
-                anyInt(), any())).thenReturn(nfcid2);
-
-        assertNull(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mRegisteredNfcFServicesCache.getNfcid2ForService(anyInt(), anyInt(), any()))
+                .thenReturn(nfcid2);
+
+        assertNull(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .getNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
-    public void testNfcFCardEmulationSetNfcid2ForService_serviceExists()
-            throws RemoteException {
+    public void testNfcFCardEmulationSetNfcid2ForService_serviceExists() throws RemoteException {
         String nfcid2 = "nfcid2";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.setNfcid2ForService(
+                anyInt(), anyInt(), any(), anyString()))
                 .thenReturn(true);
-        when(mRegisteredNfcFServicesCache.setNfcid2ForService(anyInt(),
-                anyInt(), any(), anyString())).thenReturn(true);
-
-        assertTrue(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .setNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE, nfcid2));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .setNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE, nfcid2));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredNfcFServicesCache).setNfcid2ForService(eq(USER_ID), anyInt(),
-                eq(WALLET_PAYMENT_SERVICE), eq(nfcid2));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredNfcFServicesCache)
+                .setNfcid2ForService(eq(USER_ID), anyInt(), eq(WALLET_PAYMENT_SERVICE), eq(nfcid2));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
@@ -1727,68 +1940,76 @@ public class CardEmulationManagerTest {
     public void testNfcFCardEmulationSetNfcid2ForService_serviceDoesNotExists()
             throws RemoteException {
         String nfcid2 = "nfcid2";
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mRegisteredNfcFServicesCache.setNfcid2ForService(anyInt(),
-                anyInt(), any(), anyString())).thenReturn(true);
-
-        assertFalse(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .setNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE, nfcid2));
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mRegisteredNfcFServicesCache.setNfcid2ForService(
+                anyInt(), anyInt(), any(), anyString()))
+                .thenReturn(true);
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateUserId(USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .setNfcid2ForService(USER_ID, WALLET_PAYMENT_SERVICE, nfcid2));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateUserId(USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
     public void testNfcFCardEmulationEnableNfcFForegroundService_serviceExists()
             throws RemoteException {
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(true);
+        when(mEnabledNfcFServices.registerEnabledForegroundService(any(), anyInt()))
                 .thenReturn(true);
-        when(mEnabledNfcFServices.registerEnabledForegroundService(any(),
-                anyInt())).thenReturn(true);
         when(Binder.getCallingUserHandle()).thenReturn(USER_HANDLE);
 
-        assertTrue(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .enableNfcFForegroundService(WALLET_PAYMENT_SERVICE));
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .enableNfcFForegroundService(WALLET_PAYMENT_SERVICE));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
-        verify(mEnabledNfcFServices).registerEnabledForegroundService(eq(WALLET_PAYMENT_SERVICE),
-                anyInt());
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
+        verify(mEnabledNfcFServices)
+                .registerEnabledForegroundService(eq(WALLET_PAYMENT_SERVICE), anyInt());
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
     public void testNfcFCardEmulationEnableNfcFForegroundService_serviceDoesNotExists()
             throws RemoteException {
-        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any()))
-                .thenReturn(false);
-        when(mEnabledNfcFServices.registerEnabledForegroundService(any(),
-                anyInt())).thenReturn(true);
+        when(mRegisteredNfcFServicesCache.hasService(eq(USER_ID), any())).thenReturn(false);
+        when(mEnabledNfcFServices.registerEnabledForegroundService(any(), anyInt()))
+                .thenReturn(true);
 
-        assertFalse(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .enableNfcFForegroundService(WALLET_PAYMENT_SERVICE));
+        assertFalse(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .enableNfcFForegroundService(WALLET_PAYMENT_SERVICE));
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).invalidateCache(eq(USER_ID));
         verify(mRegisteredNfcFServicesCache, times(2))
-                .hasService(eq(USER_ID),eq(WALLET_PAYMENT_SERVICE));
+                .hasService(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
         verifyNoMoreInteractions(mEnabledNfcFServices);
     }
@@ -1796,51 +2017,57 @@ public class CardEmulationManagerTest {
     @Test
     public void testNfcFCardEmulationDisableNfcFForegroundService_serviceDoesNotExists()
             throws RemoteException {
-        when(mEnabledNfcFServices.unregisteredEnabledForegroundService(anyInt()))
-                .thenReturn(true);
+        when(mEnabledNfcFServices.unregisteredEnabledForegroundService(anyInt())).thenReturn(true);
 
-        assertTrue(mCardEmulationManager.getNfcFCardEmulationInterface()
-                .disableNfcFForegroundService());
+        assertTrue(
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .disableNfcFForegroundService());
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mEnabledNfcFServices).unregisteredEnabledForegroundService(anyInt());
         verifyNoMoreInteractions(mEnabledNfcFServices);
     }
 
     @Test
-    public void testNfcFCardEmulationGetServices()
-            throws RemoteException {
-        when(mRegisteredNfcFServicesCache.getServices(anyInt()))
-                .thenReturn(UPDATED_NFC_SERVICES);
-
-        assertEquals(UPDATED_NFC_SERVICES, mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getNfcFServices(USER_ID));
-
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.validateProfileId(mContext, USER_ID);
-        });
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+    public void testNfcFCardEmulationGetServices() throws RemoteException {
+        when(mRegisteredNfcFServicesCache.getServices(anyInt())).thenReturn(UPDATED_NFC_SERVICES);
+
+        assertEquals(
+                UPDATED_NFC_SERVICES,
+                mCardEmulationManager.getNfcFCardEmulationInterface().getNfcFServices(USER_ID));
+
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.validateProfileId(mContext, USER_ID);
+                });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mRegisteredNfcFServicesCache).initialize();
         verify(mRegisteredNfcFServicesCache).getServices(eq(USER_ID));
         verifyNoMoreInteractions(mRegisteredNfcFServicesCache);
     }
 
     @Test
-    public void testNfcFCardEmulationGetMaxNumOfRegisterableSystemCodes()
-            throws RemoteException {
+    public void testNfcFCardEmulationGetMaxNumOfRegisterableSystemCodes() throws RemoteException {
         int MAX = 3;
         when(mNfcService.getLfT3tMax()).thenReturn(MAX);
 
-        assertEquals(MAX, mCardEmulationManager.getNfcFCardEmulationInterface()
-                .getMaxNumOfRegisterableSystemCodes());
+        assertEquals(
+                MAX,
+                mCardEmulationManager
+                        .getNfcFCardEmulationInterface()
+                        .getMaxNumOfRegisterableSystemCodes());
 
-        ExtendedMockito.verify(() -> {
-            NfcPermissions.enforceUserPermissions(mContext);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcPermissions.enforceUserPermissions(mContext);
+                });
         verify(mNfcService).getLfT3tMax();
         verifyNoMoreInteractions(mNfcService);
     }
@@ -1848,23 +2075,21 @@ public class CardEmulationManagerTest {
     @Test
     public void testOnPreferredPaymentServiceChanged_observeModeEnabled() {
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(-1, null));
-        mCardEmulationManager.onPreferredPaymentServiceChanged(0, null);
+                .thenReturn(new ComponentNameAndUser(-1, null));
+        mCardEmulationManager.onPreferredPaymentServiceChanged(new ComponentNameAndUser(0, null));
 
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(true);
+        ComponentNameAndUser componentNameAndUser =
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE);
+        mCardEmulationManager.onPreferredPaymentServiceChanged(componentNameAndUser);
+        when(mRegisteredAidCache.getPreferredService()).thenReturn(componentNameAndUser);
 
-        mCardEmulationManager.onPreferredPaymentServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
-        when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
-
-        verify(mHostEmulationManager).onPreferredPaymentServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(
-                eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
-        verify(mRegisteredAidCache).onPreferredPaymentServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
+        verify(mHostEmulationManager).onPreferredPaymentServiceChanged(eq(componentNameAndUser));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mRegisteredAidCache).onPreferredPaymentServiceChanged(eq(componentNameAndUser));
         verify(mRegisteredServicesCache).initialize();
         verify(mNfcService, times(2))
                 .onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_CHANGED));
@@ -1872,20 +2097,19 @@ public class CardEmulationManagerTest {
 
     @Test
     public void testOnPreferredPaymentServiceChanged_observeModeDisabled() {
+
+        ComponentNameAndUser componentNameAndUser =
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE);
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
-        when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+        when(mRegisteredAidCache.getPreferredService()).thenReturn(componentNameAndUser);
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(false);
+        mCardEmulationManager.onPreferredPaymentServiceChanged(componentNameAndUser);
 
-        mCardEmulationManager.onPreferredPaymentServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
-
-        verify(mHostEmulationManager).onPreferredPaymentServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(
-                eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
-        verify(mRegisteredAidCache).onPreferredPaymentServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
+        verify(mHostEmulationManager).onPreferredPaymentServiceChanged(eq(componentNameAndUser));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mRegisteredAidCache).onPreferredPaymentServiceChanged(eq(componentNameAndUser));
         verify(mRegisteredServicesCache).initialize();
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_CHANGED));
         assertUpdateForShouldDefaultToObserveMode(false);
@@ -1896,15 +2120,17 @@ public class CardEmulationManagerTest {
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(true);
 
-        mCardEmulationManager.onPreferredForegroundServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mCardEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
 
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(
-                eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
-        verify(mHostEmulationManager).onPreferredForegroundServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mHostEmulationManager)
+                .onPreferredForegroundServiceChanged(
+                        eq(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE)));
         verify(mRegisteredServicesCache).initialize();
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_CHANGED));
     }
@@ -1914,15 +2140,17 @@ public class CardEmulationManagerTest {
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(false);
 
-        mCardEmulationManager.onPreferredForegroundServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mCardEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
 
-        verify(mHostEmulationManager).onPreferredForegroundServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
-        verify(mRegisteredAidCache).onWalletRoleHolderChanged(
-                eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
+        verify(mHostEmulationManager)
+                .onPreferredForegroundServiceChanged(
+                        eq(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE)));
+        verify(mRegisteredAidCache)
+                .onWalletRoleHolderChanged(eq(WALLET_HOLDER_PACKAGE_NAME), eq(USER_ID));
         verify(mRegisteredServicesCache).initialize();
         verify(mNfcService).onPreferredPaymentChanged(eq(NfcAdapter.PREFERRED_PAYMENT_CHANGED));
         assertUpdateForShouldDefaultToObserveMode(false);
@@ -1933,10 +2161,11 @@ public class CardEmulationManagerTest {
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(true);
 
-        mCardEmulationManager.onPreferredPaymentServiceChanged(USER_ID, null);
+        mCardEmulationManager.onPreferredPaymentServiceChanged(
+                new ComponentNameAndUser(USER_ID, null));
 
         verify(mRegisteredServicesCache).initialize();
         assertUpdateForShouldDefaultToObserveMode(false);
@@ -1947,10 +2176,11 @@ public class CardEmulationManagerTest {
         when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(anyInt(), any()))
                 .thenReturn(true);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(android.nfc.Flags.nfcObserveMode()).thenReturn(true);
 
-        mCardEmulationManager.onPreferredForegroundServiceChanged(USER_ID, null);
+        mCardEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, null));
 
         verify(mRegisteredServicesCache).initialize();
         assertUpdateForShouldDefaultToObserveMode(false);
@@ -1970,28 +2200,28 @@ public class CardEmulationManagerTest {
 
     @Test
     public void testOnEnabledForegroundNfcFServiceChanged() {
-        mCardEmulationManager.onEnabledForegroundNfcFServiceChanged(USER_ID,
-                WALLET_PAYMENT_SERVICE);
+        mCardEmulationManager.onEnabledForegroundNfcFServiceChanged(
+                USER_ID, WALLET_PAYMENT_SERVICE);
 
-        verify(mRegisteredT3tIdentifiersCache).onEnabledForegroundNfcFServiceChanged(eq(USER_ID),
-                eq(WALLET_PAYMENT_SERVICE));
+        verify(mRegisteredT3tIdentifiersCache)
+                .onEnabledForegroundNfcFServiceChanged(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verify(mHostNfcFEmulationManager)
-                .onEnabledForegroundNfcFServiceChanged(eq(USER_ID),
-                        eq(WALLET_PAYMENT_SERVICE));
+                .onEnabledForegroundNfcFServiceChanged(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
         verifyNoMoreInteractions(mRegisteredT3tIdentifiersCache);
         verifyNoMoreInteractions(mHostNfcFEmulationManager);
     }
 
     @Test
     public void testGetRegisteredAidCategory() {
-        RegisteredAidCache.AidResolveInfo aidResolveInfo = Mockito.mock(
-                RegisteredAidCache.AidResolveInfo.class);
+        RegisteredAidCache.AidResolveInfo aidResolveInfo =
+                Mockito.mock(RegisteredAidCache.AidResolveInfo.class);
         when(aidResolveInfo.getCategory()).thenReturn(CardEmulation.CATEGORY_PAYMENT);
 
         when(mRegisteredAidCache.resolveAid(anyString())).thenReturn(aidResolveInfo);
 
-        assertEquals(CardEmulation.CATEGORY_PAYMENT,
-            mCardEmulationManager.getRegisteredAidCategory(PAYMENT_AID_1));
+        assertEquals(
+                CardEmulation.CATEGORY_PAYMENT,
+                mCardEmulationManager.getRegisteredAidCategory(PAYMENT_AID_1));
 
         verify(mRegisteredAidCache).resolveAid(eq(PAYMENT_AID_1));
         verify(aidResolveInfo).getCategory();
@@ -2004,15 +2234,15 @@ public class CardEmulationManagerTest {
         assertTrue(mCardEmulationManager.isRequiresScreenOnServiceExist());
     }
 
-
     private void assertUpdateForShouldDefaultToObserveMode(boolean flagEnabled) {
         if (flagEnabled) {
-            ExtendedMockito.verify(() -> {
-                NfcAdapter.getDefaultAdapter(mContext);
-            });
+            ExtendedMockito.verify(
+                    () -> {
+                        NfcAdapter.getDefaultAdapter(mContext);
+                    });
             verify(mRegisteredAidCache).getPreferredService();
-            verify(mRegisteredServicesCache).doesServiceShouldDefaultToObserveMode(eq(USER_ID),
-                    eq(WALLET_PAYMENT_SERVICE));
+            verify(mRegisteredServicesCache)
+                    .doesServiceShouldDefaultToObserveMode(eq(USER_ID), eq(WALLET_PAYMENT_SERVICE));
             verify(mNfcAdapter).setObserveModeEnabled(eq(true));
         }
         verifyNoMoreInteractions(mNfcAdapter);
@@ -2026,9 +2256,242 @@ public class CardEmulationManagerTest {
         when(mWalletRoleObserver.getDefaultWalletRoleHolder(eq(USER_ID)))
                 .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
 
-        return new CardEmulationManager(mContext, mForegroundUtils, mWalletRoleObserver,
-                mRegisteredAidCache, mRegisteredT3tIdentifiersCache, mHostEmulationManager,
-                mHostNfcFEmulationManager, mRegisteredServicesCache, mRegisteredNfcFServicesCache,
-                mPreferredServices, mEnabledNfcFServices, mRoutingOptionManager, mPowerManager);
+        return new CardEmulationManager(
+                mContext,
+                mForegroundUtils,
+                mWalletRoleObserver,
+                mRegisteredAidCache,
+                mRegisteredT3tIdentifiersCache,
+                mHostEmulationManager,
+                mHostNfcFEmulationManager,
+                mRegisteredServicesCache,
+                mRegisteredNfcFServicesCache,
+                mPreferredServices,
+                mEnabledNfcFServices,
+                mRoutingOptionManager,
+                mPowerManager,
+                mNfcEventLog);
+    }
+
+    @Test
+    public void testIsDefaultServiceForCategory() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mWalletRoleObserver.isWalletRoleFeatureEnabled()).thenReturn(false);
+        when(Settings.Secure.getString(any(), anyString()))
+                .thenReturn("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation
+                .isDefaultServiceForCategory(1, componentName, "payment");
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testIsDefaultServiceForAid() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mRegisteredAidCache.isDefaultServiceForAid(1, componentName, "test"))
+                .thenReturn(true);
+        boolean result = iNfcCardEmulation
+                .isDefaultServiceForAid(1, componentName, "test");
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testSetDefaultServiceForCategory() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mRegisteredAidCache.isDefaultServiceForAid(1, componentName, "test"))
+                .thenReturn(true);
+        boolean result = iNfcCardEmulation
+                .setDefaultServiceForCategory(1, componentName, "payment");
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testSetDefaultForNextTap() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mRegisteredAidCache.isDefaultServiceForAid(1, componentName, "test"))
+                .thenReturn(true);
+        iNfcCardEmulation.setDefaultForNextTap(1, componentName);
+        verify(mPreferredServices).setDefaultForNextTap(1, componentName);
+    }
+
+    @Test
+    public void testSetShouldDefaultToObserveModeForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mRegisteredAidCache.isDefaultServiceForAid(1, componentName, "test"))
+                .thenReturn(true);
+        when(mRegisteredServicesCache.doesServiceShouldDefaultToObserveMode(1, componentName))
+                .thenReturn(true);
+        boolean result = iNfcCardEmulation
+                .setShouldDefaultToObserveModeForService(1, componentName, true);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testRegisterAidGroupForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.registerAidGroupForService(anyInt(), anyInt(), any(), any()))
+                .thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        AidGroup aidGroup = mock(AidGroup.class);
+        boolean result = iNfcCardEmulation
+                .registerAidGroupForService(1, componentName, aidGroup);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testRegisterPollingLoopFilterForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.registerPollingLoopFilterForService(anyInt(),
+                anyInt(), any(), anyString(), anyBoolean())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation.registerPollingLoopFilterForService(1,
+                componentName, "test", true);
+        assertThat(true).isTrue();
+    }
+
+    @Test
+    public void testRemovePollingLoopPatternFilterForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removePollingLoopFilterForService(anyInt(),
+                anyInt(), any(), anyString())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation.removePollingLoopPatternFilterForService(1,
+                componentName, "test");
+        assertThat(true).isTrue();
+    }
+
+    @Test
+    public void testSetOffHostForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.setOffHostSecureElement(anyInt(),
+                anyInt(), any(), anyString())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation
+                .setOffHostForService(1, componentName, "test");
+        assertThat(result).isTrue();
+        verify(mNfcService).onPreferredPaymentChanged(NfcAdapter.PREFERRED_PAYMENT_UPDATED);
+    }
+
+    @Test
+    public void testUnsetOffHostForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.resetOffHostSecureElement(anyInt(),
+                anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation.unsetOffHostForService(1, componentName);
+        assertThat(result).isTrue();
+        verify(mNfcService).onPreferredPaymentChanged(NfcAdapter.PREFERRED_PAYMENT_UPDATED);
+    }
+
+    @Test
+    public void testGetAidGroupForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        AidGroup aidGroup = mock(AidGroup.class);
+        when(mRegisteredServicesCache.getAidGroupForService(anyInt(),
+                anyInt(), any(), anyString())).thenReturn(aidGroup);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        AidGroup result = iNfcCardEmulation
+                .getAidGroupForService(1, componentName, "test");
+        assertThat(result).isEqualTo(aidGroup);
+    }
+
+    @Test
+    public void testRemoveAidGroupForService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        when(mRegisteredServicesCache.removeAidGroupForService(anyInt(),
+                anyInt(), any(), anyString())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        boolean result = iNfcCardEmulation
+                .removeAidGroupForService(1, componentName, "payment");
+        assertThat(result).isTrue();
+        verify(mNfcService).onPreferredPaymentChanged(NfcAdapter.PREFERRED_PAYMENT_UPDATED);
+        verify(mNfcEventLog).logEvent(any());
+    }
+
+    @Test
+    public void testSetServices() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredServicesCache.hasService(anyInt(), any())).thenReturn(true);
+        ComponentName componentName = ComponentName
+                .unflattenFromString("com.android.test.component/.Component");
+        when(mPreferredServices.registerPreferredForegroundService(any(), anyInt()))
+                .thenReturn(true);
+        boolean result = iNfcCardEmulation.setPreferredService(componentName);
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testGetServices() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        ApduServiceInfo apduServiceInfo = mock(ApduServiceInfo.class);
+        List<ApduServiceInfo> apduServiceInfoList =  new ArrayList<>();
+        apduServiceInfoList.add(apduServiceInfo);
+        when(mRegisteredServicesCache.getServicesForCategory(1, "payment"))
+                .thenReturn(apduServiceInfoList);
+        List<ApduServiceInfo> result = iNfcCardEmulation
+                .getServices(1, "payment");
+        assertThat(result).isEqualTo(apduServiceInfoList);
+    }
+
+    @Test
+    public void testUnsetPreferredService() throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mPreferredServices
+                .unregisteredPreferredForegroundService(anyInt())).thenReturn(true);
+        boolean result = iNfcCardEmulation.unsetPreferredService();
+        assertThat(result).isTrue();
+    }
+
+    @Test
+    public void testSupportsAidPrefixRegistration()  throws RemoteException {
+        INfcCardEmulation iNfcCardEmulation = mCardEmulationManager.getNfcCardEmulationInterface();
+        assertThat(iNfcCardEmulation).isNotNull();
+        when(mRegisteredAidCache
+                .supportsAidPrefixRegistration()).thenReturn(true);
+        boolean result = iNfcCardEmulation.supportsAidPrefixRegistration();
+        assertThat(result).isTrue();
     }
 }
diff --git a/tests/unit/src/com/android/nfc/cardemulation/HostEmulationManagerTest.java b/tests/unit/src/com/android/nfc/cardemulation/HostEmulationManagerTest.java
index dbfec389..cf8ce958 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/HostEmulationManagerTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/HostEmulationManagerTest.java
@@ -24,13 +24,13 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyList;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
-import static org.mockito.ArgumentMatchers.eq;
 
 import android.app.KeyguardManager;
 import android.content.ComponentName;
@@ -39,6 +39,7 @@ import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.nfc.ComponentNameAndUser;
 import android.nfc.NfcAdapter;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
@@ -54,7 +55,6 @@ import android.os.RemoteException;
 import android.os.UserHandle;
 import android.testing.AndroidTestingRunner;
 import android.testing.TestableLooper;
-import android.util.Pair;
 
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.NfcEventLog;
@@ -86,51 +86,38 @@ import java.util.regex.Pattern;
 public class HostEmulationManagerTest {
 
     private static final String WALLET_HOLDER_PACKAGE_NAME = "com.android.test.walletroleholder";
-    private static final ComponentName WALLET_PAYMENT_SERVICE
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.WalletRoleHolderApduService");
-    private static final ComponentName ANOTHER_WALLET_SERVICE
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.XRoleHolderApduService");
+    private static final String NFC_PACKAGE = "com.android.nfc";
+    private static final ComponentName WALLET_PAYMENT_SERVICE =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.WalletRoleHolderApduService");
+    private static final ComponentName ANOTHER_WALLET_SERVICE =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.XRoleHolderApduService");
     private static final int USER_ID = 0;
     private static final UserHandle USER_HANDLE = UserHandle.of(USER_ID);
     private static final String PL_FILTER = "66696C746572";
     private static final Pattern PL_PATTERN = Pattern.compile("66696C*46572");
     private static final List<String> POLLING_LOOP_FILTER = List.of(PL_FILTER);
-    private static final List<Pattern> POLLING_LOOP_PATTEN_FILTER
-            = List.of(PL_PATTERN);
+    private static final List<Pattern> POLLING_LOOP_PATTEN_FILTER = List.of(PL_PATTERN);
     private static final String MOCK_AID = "A000000476416E64726F6964484340";
 
-    @Mock
-    private Context mContext;
-    @Mock
-    private RegisteredAidCache mRegisteredAidCache;
-    @Mock
-    private PowerManager mPowerManager;
-    @Mock
-    private KeyguardManager mKeyguardManager;
-    @Mock
-    private PackageManager mPackageManager;
-    @Mock
-    private NfcAdapter mNfcAdapter;
-    @Mock
-    private Messenger mMessenger;
-    @Mock
-    private NfcService mNfcService;
-    @Mock
-    private NfcInjector mNfcInjector;
-    @Mock
-    private NfcEventLog mNfcEventLog;
-    @Mock
-    private StatsdUtils mStatsUtils;
-    @Captor
-    private ArgumentCaptor<Intent> mIntentArgumentCaptor;
-    @Captor
-    private ArgumentCaptor<ServiceConnection> mServiceConnectionArgumentCaptor;
-    @Captor
-    private ArgumentCaptor<List<ApduServiceInfo>> mServiceListArgumentCaptor;
-    @Captor
-    private ArgumentCaptor<Message> mMessageArgumentCaptor;
+    @Mock private Context mContext;
+    @Mock private RegisteredAidCache mRegisteredAidCache;
+    @Mock private PowerManager mPowerManager;
+    @Mock private KeyguardManager mKeyguardManager;
+    @Mock private PackageManager mPackageManager;
+    @Mock private NfcAdapter mNfcAdapter;
+    @Mock private Messenger mMessenger;
+    @Mock private NfcService mNfcService;
+    @Mock private NfcInjector mNfcInjector;
+    @Mock private NfcEventLog mNfcEventLog;
+    @Mock private StatsdUtils mStatsUtils;
+    @Captor private ArgumentCaptor<Intent> mIntentArgumentCaptor;
+    @Captor private ArgumentCaptor<ServiceConnection> mServiceConnectionArgumentCaptor;
+    @Captor private ArgumentCaptor<List<ApduServiceInfo>> mServiceListArgumentCaptor;
+    @Captor private ArgumentCaptor<Message> mMessageArgumentCaptor;
 
     private MockitoSession mStaticMockSession;
     private TestableLooper mTestableLooper;
@@ -138,15 +125,16 @@ public class HostEmulationManagerTest {
 
     @Before
     public void setUp() {
-        mStaticMockSession = ExtendedMockito.mockitoSession()
-                .mockStatic(com.android.nfc.flags.Flags.class)
-                .mockStatic(NfcStatsLog.class)
-                .mockStatic(UserHandle.class)
-                .mockStatic(NfcAdapter.class)
-                .mockStatic(NfcService.class)
-                .mockStatic(NfcInjector.class)
-                .strictness(Strictness.LENIENT)
-                .startMocking();
+        mStaticMockSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(com.android.nfc.flags.Flags.class)
+                        .mockStatic(NfcStatsLog.class)
+                        .mockStatic(UserHandle.class)
+                        .mockStatic(NfcAdapter.class)
+                        .mockStatic(NfcService.class)
+                        .mockStatic(NfcInjector.class)
+                        .strictness(Strictness.LENIENT)
+                        .startMocking();
         MockitoAnnotations.initMocks(this);
         mTestableLooper = TestableLooper.get(this);
         when(NfcAdapter.getDefaultAdapter(mContext)).thenReturn(mNfcAdapter);
@@ -155,12 +143,15 @@ public class HostEmulationManagerTest {
         when(NfcService.getInstance()).thenReturn(mNfcService);
         when(NfcInjector.getInstance()).thenReturn(mNfcInjector);
         when(mNfcInjector.getNfcEventLog()).thenReturn(mNfcEventLog);
+        when(mNfcInjector.getNfcPackageName()).thenReturn(NFC_PACKAGE);
         when(com.android.nfc.flags.Flags.statsdCeEventsFlag()).thenReturn(true);
         when(mContext.getSystemService(eq(PowerManager.class))).thenReturn(mPowerManager);
         when(mContext.getSystemService(eq(KeyguardManager.class))).thenReturn(mKeyguardManager);
-        when(mRegisteredAidCache.getPreferredPaymentService()).thenReturn(new Pair<>(null, null));
-        mHostEmulationManager = new HostEmulationManager(mContext, mTestableLooper.getLooper(),
-                mRegisteredAidCache, mStatsUtils);
+        when(mRegisteredAidCache.getPreferredPaymentService())
+                .thenReturn(new ComponentNameAndUser(0, null));
+        mHostEmulationManager =
+                new HostEmulationManager(
+                        mContext, mTestableLooper.getLooper(), mRegisteredAidCache, mStatsUtils);
     }
 
     @After
@@ -179,7 +170,8 @@ public class HostEmulationManagerTest {
     public void testOnPreferredPaymentServiceChanged_nullService() {
         mHostEmulationManager.mPaymentServiceBound = true;
 
-        mHostEmulationManager.onPreferredPaymentServiceChanged(USER_ID, null);
+        mHostEmulationManager.onPreferredPaymentServiceChanged(
+                new ComponentNameAndUser(USER_ID, null));
         mTestableLooper.processAllMessages();
 
         verify(mContext).getSystemService(eq(PowerManager.class));
@@ -193,15 +185,20 @@ public class HostEmulationManagerTest {
         when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);
         UserHandle userHandle = UserHandle.of(USER_ID);
 
-        mHostEmulationManager.onPreferredPaymentServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mHostEmulationManager.onPreferredPaymentServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         mTestableLooper.processAllMessages();
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
         verifyNoMoreInteractions(mContext);
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
@@ -217,16 +214,21 @@ public class HostEmulationManagerTest {
         UserHandle userHandle = UserHandle.of(USER_ID);
         mHostEmulationManager.mPaymentServiceBound = true;
 
-        mHostEmulationManager.onPreferredPaymentServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mHostEmulationManager.onPreferredPaymentServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         mTestableLooper.processAllMessages();
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
         verify(mContext).unbindService(eq(mHostEmulationManager.getPaymentConnection()));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
         verifyNoMoreInteractions(mContext);
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
@@ -247,18 +249,18 @@ public class HostEmulationManagerTest {
         when(serviceWithPatternFilter.getPollingLoopPatternFilters())
                 .thenReturn(POLLING_LOOP_PATTEN_FILTER);
 
-        mHostEmulationManager.updatePollingLoopFilters(USER_ID, List.of(serviceWithFilter,
-                serviceWithPatternFilter));
+        mHostEmulationManager.updatePollingLoopFilters(
+                USER_ID, List.of(serviceWithFilter, serviceWithPatternFilter));
 
-        Map<Integer, Map<String, List<ApduServiceInfo>>> pollingLoopFilters
-                = mHostEmulationManager.getPollingLoopFilters();
-        Map<Integer, Map<Pattern, List<ApduServiceInfo>>> pollingLoopPatternFilters
-                = mHostEmulationManager.getPollingLoopPatternFilters();
+        Map<Integer, Map<String, List<ApduServiceInfo>>> pollingLoopFilters =
+                mHostEmulationManager.getPollingLoopFilters();
+        Map<Integer, Map<Pattern, List<ApduServiceInfo>>> pollingLoopPatternFilters =
+                mHostEmulationManager.getPollingLoopPatternFilters();
         assertTrue(pollingLoopFilters.containsKey(USER_ID));
         assertTrue(pollingLoopPatternFilters.containsKey(USER_ID));
         Map<String, List<ApduServiceInfo>> filtersForUser = pollingLoopFilters.get(USER_ID);
-        Map<Pattern, List<ApduServiceInfo>> patternFiltersForUser = pollingLoopPatternFilters
-                .get(USER_ID);
+        Map<Pattern, List<ApduServiceInfo>> patternFiltersForUser =
+                pollingLoopPatternFilters.get(USER_ID);
         assertTrue(filtersForUser.containsKey(PL_FILTER));
         assertTrue(patternFiltersForUser.containsKey(PL_PATTERN));
         assertTrue(filtersForUser.get(PL_FILTER).contains(serviceWithFilter));
@@ -283,21 +285,23 @@ public class HostEmulationManagerTest {
                 .thenReturn(POLLING_LOOP_PATTEN_FILTER);
         when(mRegisteredAidCache.resolvePollingLoopFilterConflict(anyList()))
                 .thenReturn(serviceWithFilter);
-        mHostEmulationManager.updatePollingLoopFilters(USER_ID, List.of(serviceWithFilter,
-                serviceWithPatternFilter, overlappingServiceWithFilter));
+        mHostEmulationManager.updatePollingLoopFilters(
+                USER_ID,
+                List.of(serviceWithFilter, serviceWithPatternFilter, overlappingServiceWithFilter));
         when(mContext.getPackageManager()).thenReturn(mPackageManager);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         ApplicationInfo applicationInfo = new ApplicationInfo();
         applicationInfo.uid = USER_ID;
         mHostEmulationManager.mPaymentServiceName = WALLET_PAYMENT_SERVICE;
         when(mPackageManager.getApplicationInfo(eq(WALLET_HOLDER_PACKAGE_NAME), eq(0)))
                 .thenReturn(applicationInfo);
         String data = "filter";
-        PollingFrame frame1 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_UNKNOWN,
-                data.getBytes(), 0, 0, false);
-        PollingFrame frame2 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF,
-                null, 0, 0, false);
+        PollingFrame frame1 =
+                new PollingFrame(
+                        PollingFrame.POLLING_LOOP_TYPE_UNKNOWN, data.getBytes(), 0, 0, false);
+        PollingFrame frame2 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF, null, 0, 0, false);
 
         mHostEmulationManager.mActiveService = mMessenger;
 
@@ -328,19 +332,19 @@ public class HostEmulationManagerTest {
         mHostEmulationManager.updatePollingLoopFilters(USER_ID, List.of(serviceWithFilter));
         when(mContext.getPackageManager()).thenReturn(mPackageManager);
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         ApplicationInfo applicationInfo = new ApplicationInfo();
         applicationInfo.uid = USER_ID;
         when(mPackageManager.getApplicationInfo(eq(WALLET_HOLDER_PACKAGE_NAME), eq(0)))
                 .thenReturn(applicationInfo);
-        PollingFrame frame1 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON,
-                null, 0, 0, false);
-        PollingFrame frame2 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON,
-                null, 0, 0, false);
-        PollingFrame frame3 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF,
-                null, 0, 0, false);
-        PollingFrame frame4 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF,
-                null, 0, 0, false);
+        PollingFrame frame1 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON, null, 0, 0, false);
+        PollingFrame frame2 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON, null, 0, 0, false);
+        PollingFrame frame3 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF, null, 0, 0, false);
+        PollingFrame frame4 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF, null, 0, 0, false);
         mHostEmulationManager.mPaymentService = mMessenger;
         mHostEmulationManager.mPaymentServiceName = WALLET_PAYMENT_SERVICE;
 
@@ -353,8 +357,8 @@ public class HostEmulationManagerTest {
         Bundle bundle = message.getData();
         assertEquals(HostApduService.MSG_POLLING_LOOP, message.what);
         assertTrue(bundle.containsKey(HostApduService.KEY_POLLING_LOOP_FRAMES_BUNDLE));
-        ArrayList<PollingFrame> sentFrames = bundle
-                .getParcelableArrayList(HostApduService.KEY_POLLING_LOOP_FRAMES_BUNDLE);
+        ArrayList<PollingFrame> sentFrames =
+                bundle.getParcelableArrayList(HostApduService.KEY_POLLING_LOOP_FRAMES_BUNDLE);
         assertTrue(sentFrames.contains(frame1));
         assertTrue(sentFrames.contains(frame2));
         assertTrue(sentFrames.contains(frame3));
@@ -367,14 +371,19 @@ public class HostEmulationManagerTest {
         when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);
         UserHandle userHandle = UserHandle.of(USER_ID);
 
-        mHostEmulationManager.onPreferredForegroundServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mHostEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
         verifyNoMoreInteractions(mContext);
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
@@ -387,7 +396,8 @@ public class HostEmulationManagerTest {
     public void testOnPreferredForegroundServiceChanged_nullService() {
         mHostEmulationManager.mServiceBound = true;
 
-        mHostEmulationManager.onPreferredForegroundServiceChanged(USER_ID, null);
+        mHostEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, null));
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
@@ -401,15 +411,20 @@ public class HostEmulationManagerTest {
         UserHandle userHandle = UserHandle.of(USER_ID);
         mHostEmulationManager.mServiceBound = true;
 
-        mHostEmulationManager.onPreferredForegroundServiceChanged(USER_ID, WALLET_PAYMENT_SERVICE);
+        mHostEmulationManager.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
         verify(mContext).unbindService(eq(mHostEmulationManager.getServiceConnection()));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
         verifyNoMoreInteractions(mContext);
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
@@ -434,10 +449,10 @@ public class HostEmulationManagerTest {
 
     @Test
     public void testOnPollingLoopDetected_fieldOff_returnToIdle() {
-        PollingFrame frame1 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON,
-                null, 0, 0, false);
-        PollingFrame frame2 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF,
-                null, 0, 0, false);
+        PollingFrame frame1 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_ON, null, 0, 0, false);
+        PollingFrame frame2 =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF, null, 0, 0, false);
         mHostEmulationManager.onPollingLoopDetected(List.of(frame1, frame2));
         assertEquals(HostEmulationManager.STATE_POLLING_LOOP, mHostEmulationManager.getState());
 
@@ -452,12 +467,11 @@ public class HostEmulationManagerTest {
 
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verify(mContext).sendBroadcastAsUser(mIntentArgumentCaptor.capture(),
-                eq(UserHandle.ALL));
+        verify(mContext).sendBroadcastAsUser(mIntentArgumentCaptor.capture(), eq(UserHandle.ALL));
         verifyNoMoreInteractions(mContext);
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(TapAgainDialog.ACTION_CLOSE, intent.getAction());
-        assertEquals(HostEmulationManager.NFC_PACKAGE, intent.getPackage());
+        assertEquals(NFC_PACKAGE, intent.getPackage());
         assertEquals(HostEmulationManager.STATE_W4_SELECT, mHostEmulationManager.getState());
     }
 
@@ -554,7 +568,7 @@ public class HostEmulationManagerTest {
         when(apduServiceInfo.requiresUnlock()).thenReturn(true);
         when(apduServiceInfo.getUid()).thenReturn(USER_ID);
         when(mNfcService.isSecureNfcEnabled()).thenReturn(false);
-        when(mKeyguardManager.isKeyguardLocked()).thenReturn(true);
+        when(mNfcInjector.isDeviceLocked()).thenReturn(true);
         aidResolveInfo.defaultService = apduServiceInfo;
         when(mRegisteredAidCache.resolveAid(eq(MOCK_AID))).thenReturn(aidResolveInfo);
 
@@ -584,7 +598,7 @@ public class HostEmulationManagerTest {
         aidResolveInfo.category = CardEmulation.CATEGORY_PAYMENT;
         when(apduServiceInfo.requiresUnlock()).thenReturn(false);
         when(mNfcService.isSecureNfcEnabled()).thenReturn(true);
-        when(mKeyguardManager.isKeyguardLocked()).thenReturn(true);
+        when(mNfcInjector.isDeviceLocked()).thenReturn(true);
         aidResolveInfo.defaultService = apduServiceInfo;
         when(mRegisteredAidCache.resolveAid(eq(MOCK_AID))).thenReturn(aidResolveInfo);
 
@@ -678,17 +692,18 @@ public class HostEmulationManagerTest {
 
         mHostEmulationManager.onHostEmulationData(mockAidData);
 
-        ExtendedMockito.verify(() -> {
-            NfcStatsLog.write(NfcStatsLog.NFC_AID_CONFLICT_OCCURRED, MOCK_AID);
-        });
+        ExtendedMockito.verify(
+                () -> {
+                    NfcStatsLog.write(NfcStatsLog.NFC_AID_CONFLICT_OCCURRED, MOCK_AID);
+                });
         verify(mStatsUtils).setCardEmulationEventCategory(eq(CardEmulation.CATEGORY_OTHER));
         verify(mStatsUtils).logCardEmulationWrongSettingEvent();
         assertEquals(HostEmulationManager.STATE_W4_DEACTIVATE, mHostEmulationManager.getState());
         verify(mRegisteredAidCache).resolveAid(eq(MOCK_AID));
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verifyResolverLaunched((ArrayList)aidResolveInfo.services, null,
-                CardEmulation.CATEGORY_PAYMENT);
+        verifyResolverLaunched(
+                (ArrayList) aidResolveInfo.services, null, CardEmulation.CATEGORY_PAYMENT);
         verifyNoMoreInteractions(mContext);
     }
 
@@ -772,14 +787,19 @@ public class HostEmulationManagerTest {
         verify(mRegisteredAidCache).resolveAid(eq(MOCK_AID));
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(USER_HANDLE));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(USER_HANDLE));
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
         assertEquals(WALLET_PAYMENT_SERVICE, intent.getComponent());
-        assertEquals(mHostEmulationManager.getServiceConnection(),
+        assertEquals(
+                mHostEmulationManager.getServiceConnection(),
                 mServiceConnectionArgumentCaptor.getValue());
         assertTrue(mHostEmulationManager.mServiceBound);
         assertEquals(USER_ID, mHostEmulationManager.mServiceUserId);
@@ -832,6 +852,7 @@ public class HostEmulationManagerTest {
         assertTrue(bundle.containsKey(HostEmulationManager.DATA_KEY));
         assertEquals(data, bundle.getByteArray(HostEmulationManager.DATA_KEY));
         assertEquals(mHostEmulationManager.getLocalMessenger(), message.replyTo);
+        verify(mNfcService).notifyOemLogEvent(any());
         verifyNoMoreInteractions(mNfcService);
         verifyNoMoreInteractions(mContext);
     }
@@ -877,7 +898,8 @@ public class HostEmulationManagerTest {
     }
 
     @Test
-    public void testOnHostEmulationData_stateXfer_selectAid_noActiveService() throws RemoteException {
+    public void testOnHostEmulationData_stateXfer_selectAid_noActiveService()
+            throws RemoteException {
         when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(true);
         byte[] mockAidData = createSelectAidData(MOCK_AID);
         mHostEmulationManager.mState = HostEmulationManager.STATE_XFER;
@@ -904,14 +926,19 @@ public class HostEmulationManagerTest {
         assertEquals(HostEmulationManager.STATE_W4_SERVICE, mHostEmulationManager.getState());
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(USER_HANDLE));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(USER_HANDLE));
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(HostApduService.SERVICE_INTERFACE, intent.getAction());
         assertEquals(WALLET_PAYMENT_SERVICE, intent.getComponent());
-        assertEquals(mHostEmulationManager.getServiceConnection(),
+        assertEquals(
+                mHostEmulationManager.getServiceConnection(),
                 mServiceConnectionArgumentCaptor.getValue());
         assertTrue(mHostEmulationManager.mServiceBound);
         assertEquals(USER_ID, mHostEmulationManager.mServiceUserId);
@@ -959,7 +986,8 @@ public class HostEmulationManagerTest {
         verify(mContext).getSystemService(eq(PowerManager.class));
         verify(mContext).getSystemService(eq(KeyguardManager.class));
         verify(mContext).unbindService(mServiceConnectionArgumentCaptor.capture());
-        assertEquals(mHostEmulationManager.getServiceConnection(),
+        assertEquals(
+                mHostEmulationManager.getServiceConnection(),
                 mServiceConnectionArgumentCaptor.getValue());
         verify(mStatsUtils).logCardEmulationDeactivatedEvent();
 
@@ -1016,7 +1044,7 @@ public class HostEmulationManagerTest {
         assertEquals(HostEmulationManager.STATE_W4_SELECT, mHostEmulationManager.getState());
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(TapAgainDialog.ACTION_CLOSE, intent.getAction());
-        assertEquals(HostEmulationManager.NFC_PACKAGE, intent.getPackage());
+        assertEquals(NFC_PACKAGE, intent.getPackage());
         verifyNoMoreInteractions(mContext);
     }
 
@@ -1039,7 +1067,7 @@ public class HostEmulationManagerTest {
         assertEquals(HostEmulationManager.STATE_W4_SELECT, mHostEmulationManager.getState());
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(TapAgainDialog.ACTION_CLOSE, intent.getAction());
-        assertEquals(HostEmulationManager.NFC_PACKAGE, intent.getPackage());
+        assertEquals(NFC_PACKAGE, intent.getPackage());
         verify(mMessenger).send(mMessageArgumentCaptor.capture());
         Message message = mMessageArgumentCaptor.getValue();
         assertEquals(HostApduService.MSG_DEACTIVATED, message.what);
@@ -1066,7 +1094,7 @@ public class HostEmulationManagerTest {
         assertEquals(HostEmulationManager.STATE_W4_SELECT, mHostEmulationManager.getState());
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(TapAgainDialog.ACTION_CLOSE, intent.getAction());
-        assertEquals(HostEmulationManager.NFC_PACKAGE, intent.getPackage());
+        assertEquals(NFC_PACKAGE, intent.getPackage());
         verifyZeroInteractions(mMessenger);
         verifyNoMoreInteractions(mContext);
     }
@@ -1078,8 +1106,9 @@ public class HostEmulationManagerTest {
         mHostEmulationManager.mState = HostEmulationManager.STATE_W4_SELECT;
         mHostEmulationManager.mSelectApdu = new byte[3];
 
-        mHostEmulationManager.getServiceConnection().onServiceConnected(WALLET_PAYMENT_SERVICE,
-                service);
+        mHostEmulationManager
+                .getServiceConnection()
+                .onServiceConnected(WALLET_PAYMENT_SERVICE, service);
 
         assertEquals(WALLET_PAYMENT_SERVICE, mHostEmulationManager.mServiceName);
         assertNotNull(mHostEmulationManager.mService);
@@ -1097,11 +1126,12 @@ public class HostEmulationManagerTest {
         mHostEmulationManager.mState = HostEmulationManager.STATE_W4_SELECT;
         mHostEmulationManager.mSelectApdu = null;
         mHostEmulationManager.mPollingFramesToSend = new HashMap();
-        mHostEmulationManager.mPollingFramesToSend.put(WALLET_PAYMENT_SERVICE,
-                new ArrayList<>(List.of()));
+        mHostEmulationManager.mPollingFramesToSend.put(
+                WALLET_PAYMENT_SERVICE, new ArrayList<>(List.of()));
 
-        mHostEmulationManager.getServiceConnection().onServiceConnected(WALLET_PAYMENT_SERVICE,
-                service);
+        mHostEmulationManager
+                .getServiceConnection()
+                .onServiceConnected(WALLET_PAYMENT_SERVICE, service);
 
         assertEquals(WALLET_PAYMENT_SERVICE, mHostEmulationManager.mServiceName);
         assertNotNull(mHostEmulationManager.mService);
@@ -1116,8 +1146,9 @@ public class HostEmulationManagerTest {
         IBinder service = mock(IBinder.class);
         mHostEmulationManager.mState = HostEmulationManager.STATE_IDLE;
 
-        mHostEmulationManager.getServiceConnection().onServiceConnected(WALLET_PAYMENT_SERVICE,
-                service);
+        mHostEmulationManager
+                .getServiceConnection()
+                .onServiceConnected(WALLET_PAYMENT_SERVICE, service);
 
         verifyZeroInteractions(service);
     }
@@ -1140,8 +1171,9 @@ public class HostEmulationManagerTest {
         IBinder service = mock(IBinder.class);
         mHostEmulationManager.mLastBoundPaymentServiceName = WALLET_PAYMENT_SERVICE;
 
-        mHostEmulationManager.getPaymentConnection().onServiceConnected(WALLET_PAYMENT_SERVICE,
-                service);
+        mHostEmulationManager
+                .getPaymentConnection()
+                .onServiceConnected(WALLET_PAYMENT_SERVICE, service);
 
         assertNotNull(mHostEmulationManager.mPaymentServiceName);
         assertEquals(WALLET_PAYMENT_SERVICE, mHostEmulationManager.mPaymentServiceName);
@@ -1176,10 +1208,14 @@ public class HostEmulationManagerTest {
         mHostEmulationManager.getPaymentConnection().onBindingDied(WALLET_PAYMENT_SERVICE);
 
         verify(mContext).unbindService(eq(mHostEmulationManager.getPaymentConnection()));
-        verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext)
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
 
         assertEquals(USER_ID, mHostEmulationManager.mPaymentServiceUserId);
         assertTrue(mHostEmulationManager.mPaymentServiceBound);
@@ -1188,8 +1224,8 @@ public class HostEmulationManagerTest {
     @Test
     public void testPaymentServiceConnectionOnBindingDied_rebindOnTap() {
         when(mContext.bindServiceAsUser(any(), any(), anyInt(), any())).thenReturn(false);
-        when(mRegisteredAidCache.getPreferredPaymentService()).
-                thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+        when(mRegisteredAidCache.getPreferredPaymentService())
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
 
         UserHandle userHandle = UserHandle.of(USER_ID);
 
@@ -1204,10 +1240,15 @@ public class HostEmulationManagerTest {
         mHostEmulationManager.getPaymentConnection().onBindingDied(WALLET_PAYMENT_SERVICE);
 
         verify(mContext).unbindService(eq(mHostEmulationManager.getPaymentConnection()));
-        assertFalse(verify(mContext).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle)));
+        assertFalse(
+                verify(mContext)
+                        .bindServiceAsUser(
+                                mIntentArgumentCaptor.capture(),
+                                mServiceConnectionArgumentCaptor.capture(),
+                                eq(
+                                        Context.BIND_AUTO_CREATE
+                                                | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                                eq(userHandle)));
 
         assertFalse(mHostEmulationManager.mPaymentServiceBound);
 
@@ -1215,10 +1256,14 @@ public class HostEmulationManagerTest {
 
         mHostEmulationManager.bindServiceIfNeededLocked(USER_ID, WALLET_PAYMENT_SERVICE);
 
-        verify(mContext, times(2)).bindServiceAsUser(mIntentArgumentCaptor.capture(),
-                mServiceConnectionArgumentCaptor.capture(),
-                eq(Context.BIND_AUTO_CREATE | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
-                eq(userHandle));
+        verify(mContext, times(2))
+                .bindServiceAsUser(
+                        mIntentArgumentCaptor.capture(),
+                        mServiceConnectionArgumentCaptor.capture(),
+                        eq(
+                                Context.BIND_AUTO_CREATE
+                                        | Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS),
+                        eq(userHandle));
 
         assertEquals(USER_ID, mHostEmulationManager.mPaymentServiceUserId);
         assertTrue(mHostEmulationManager.mPaymentServiceBound);
@@ -1252,8 +1297,11 @@ public class HostEmulationManagerTest {
     @Test
     public void testFindSelectAid_longAidLength() {
         final byte[] aidData = createSelectAidData(MOCK_AID);
-        aidData[4] = (byte)(HostEmulationManager.SELECT_APDU_HDR_LENGTH
-                + HexFormat.of().parseHex(MOCK_AID).length + 1);
+        aidData[4] =
+                (byte)
+                        (HostEmulationManager.SELECT_APDU_HDR_LENGTH
+                                + HexFormat.of().parseHex(MOCK_AID).length
+                                + 1);
 
         String aidString = mHostEmulationManager.findSelectAid(aidData);
 
@@ -1269,17 +1317,22 @@ public class HostEmulationManagerTest {
 
         // Preferred payment service is defined, but not bound
         when(mRegisteredAidCache.getPreferredService())
-                .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         when(mRegisteredAidCache.getPreferredPaymentService())
-            .thenReturn(new Pair<>(USER_ID, WALLET_PAYMENT_SERVICE));
+                .thenReturn(new ComponentNameAndUser(USER_ID, WALLET_PAYMENT_SERVICE));
         mHostEmulationManager.mPaymentServiceName = WALLET_PAYMENT_SERVICE;
         assertNull(mHostEmulationManager.mPaymentService);
         assertFalse(mHostEmulationManager.mPaymentServiceBound);
 
-        PollingFrame frame1 = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_UNKNOWN,
-                HexFormat.of().parseHex("42"), 0, 0, false);
-        PollingFrame offFrame = new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF,
-                null, 0, 0, false);
+        PollingFrame frame1 =
+                new PollingFrame(
+                        PollingFrame.POLLING_LOOP_TYPE_UNKNOWN,
+                        HexFormat.of().parseHex("42"),
+                        0,
+                        0,
+                        false);
+        PollingFrame offFrame =
+                new PollingFrame(PollingFrame.POLLING_LOOP_TYPE_OFF, null, 0, 0, false);
 
         mHostEmulationManager.onPollingLoopDetected(List.of(frame1, offFrame));
 
@@ -1304,40 +1357,45 @@ public class HostEmulationManagerTest {
         assertEquals(service, intent.getParcelableExtra(TapAgainDialog.EXTRA_APDU_SERVICE));
         int flags = Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK;
         assertEquals(flags, intent.getFlags());
-        assertEquals(TapAgainDialog.class.getCanonicalName(),
-                intent.getComponent().getClassName());
+        assertEquals(TapAgainDialog.class.getCanonicalName(), intent.getComponent().getClassName());
     }
 
-    private void verifyResolverLaunched(ArrayList<ApduServiceInfo> services,
-                                        ComponentName failedComponent, String category) {
+    private void verifyResolverLaunched(
+            ArrayList<ApduServiceInfo> services, ComponentName failedComponent, String category) {
         verify(mContext).getPackageName();
-        verify(mContext).startActivityAsUser(mIntentArgumentCaptor.capture(), eq(UserHandle.CURRENT));
+        verify(mContext)
+                .startActivityAsUser(mIntentArgumentCaptor.capture(), eq(UserHandle.CURRENT));
         Intent intent = mIntentArgumentCaptor.getValue();
         assertEquals(category, intent.getStringExtra(AppChooserActivity.EXTRA_CATEGORY));
-        assertEquals(services,
+        assertEquals(
+                services,
                 intent.getParcelableArrayListExtra(AppChooserActivity.EXTRA_APDU_SERVICES));
         if (failedComponent != null) {
-            assertEquals(failedComponent,
+            assertEquals(
+                    failedComponent,
                     intent.getParcelableExtra(AppChooserActivity.EXTRA_FAILED_COMPONENT));
         }
         int flags = Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK;
         assertEquals(flags, intent.getFlags());
-        assertEquals(AppChooserActivity.class.getCanonicalName(),
-                intent.getComponent().getClassName());
+        assertEquals(
+                AppChooserActivity.class.getCanonicalName(), intent.getComponent().getClassName());
     }
 
     private static byte[] createSelectAidData(String aid) {
         byte[] aidStringData = HexFormat.of().parseHex(aid);
-        byte[] aidData = new byte[HostEmulationManager.SELECT_APDU_HDR_LENGTH
-                + aidStringData.length];
+        byte[] aidData =
+                new byte[HostEmulationManager.SELECT_APDU_HDR_LENGTH + aidStringData.length];
         aidData[0] = 0x00;
         aidData[1] = HostEmulationManager.INSTR_SELECT;
         aidData[2] = 0x04;
         aidData[3] = 0x00;
-        aidData[4] = (byte)aidStringData.length;
-        System.arraycopy(aidStringData, 0, aidData, HostEmulationManager.SELECT_APDU_HDR_LENGTH,
+        aidData[4] = (byte) aidStringData.length;
+        System.arraycopy(
+                aidStringData,
+                0,
+                aidData,
+                HostEmulationManager.SELECT_APDU_HDR_LENGTH,
                 aidData.length - HostEmulationManager.SELECT_APDU_HDR_LENGTH);
         return aidData;
     }
-
 }
diff --git a/tests/unit/src/com/android/nfc/cardemulation/NfcAidConflictOccurredTest.java b/tests/unit/src/com/android/nfc/cardemulation/NfcAidConflictOccurredTest.java
index 047a82a6..a9344e0a 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/NfcAidConflictOccurredTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/NfcAidConflictOccurredTest.java
@@ -18,6 +18,7 @@ package com.android.nfc.cardemulation;
 import static org.junit.Assert.assertNotNull;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.verify;
 
 import android.bluetooth.BluetoothProtoEnums;
 import android.content.Context;
@@ -37,6 +38,7 @@ import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.cardemulation.RegisteredAidCache.AidResolveInfo;
+import com.android.nfc.NfcInjector;
 import com.android.nfc.NfcStatsLog;
 import com.android.nfc.flags.Flags;
 
@@ -50,8 +52,10 @@ import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
 
 @RunWith(AndroidJUnit4.class)
 public final class NfcAidConflictOccurredTest {
@@ -59,6 +63,7 @@ public final class NfcAidConflictOccurredTest {
     private static final String TAG = NfcAidConflictOccurredTest.class.getSimpleName();
     private MockitoSession mStaticMockSession;
     private HostEmulationManager mHostEmulation;
+    private HostEmulationManager.NfcAidRoutingListener mMockNfcAidRoutingListener;
     @Rule
     public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
     private final TestLooper mTestLooper = new TestLooper();
@@ -68,6 +73,8 @@ public final class NfcAidConflictOccurredTest {
         Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
         mStaticMockSession = ExtendedMockito.mockitoSession()
                 .mockStatic(NfcStatsLog.class)
+                .mockStatic(NfcInjector.class)
+                .strictness(Strictness.LENIENT)
                 .startMocking();
         RegisteredAidCache mockAidCache = Mockito.mock(RegisteredAidCache.class);
         ApduServiceInfo apduServiceInfo = Mockito.mock(ApduServiceInfo.class);
@@ -76,6 +83,7 @@ public final class NfcAidConflictOccurredTest {
         aidResolveInfo.services = new ArrayList<ApduServiceInfo>();
         aidResolveInfo.services.add(apduServiceInfo);
         when(mockAidCache.resolveAid(anyString())).thenReturn(aidResolveInfo);
+        when(NfcInjector.getInstance()).thenReturn(Mockito.mock(NfcInjector.class));
 
         Context mockContext = new ContextWrapper(context) {
             @Override
@@ -93,6 +101,11 @@ public final class NfcAidConflictOccurredTest {
                       mockContext, mTestLooper.getLooper(), mockAidCache));
         assertNotNull(mHostEmulation);
 
+        if (android.nfc.Flags.nfcEventListener()) {
+            mMockNfcAidRoutingListener =
+                    Mockito.mock(HostEmulationManager.NfcAidRoutingListener.class);
+            mHostEmulation.setAidRoutingListener(mMockNfcAidRoutingListener);
+        }
         mHostEmulation.onHostEmulationActivated();
     }
 
@@ -117,6 +130,20 @@ public final class NfcAidConflictOccurredTest {
                 "A000000003000000"));
     }
 
+    @Test
+    @RequiresFlagsEnabled(android.nfc.Flags.FLAG_NFC_EVENT_LISTENER)
+    public void testHCEOther_eventListener() {
+        byte[] aidBytes = new byte[] {
+            0x00, (byte)0xA4, 0x04, 0x00,  // command
+            0x08,  // data length
+            (byte)0xA0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+            0x00,  // card manager AID
+            0x00  // trailer
+        };
+        mHostEmulation.onHostEmulationData(aidBytes);
+        verify(mMockNfcAidRoutingListener).onAidConflict("A000000003000000");
+    }
+
     @Test
     @RequiresFlagsEnabled(Flags.FLAG_TEST_FLAG)
     public void testHCEOtherWithTestFlagEnabled() {
diff --git a/tests/unit/src/com/android/nfc/cardemulation/NfcCardEmulationOccurredTest.java b/tests/unit/src/com/android/nfc/cardemulation/NfcCardEmulationOccurredTest.java
index 5fe77f64..497b2437 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/NfcCardEmulationOccurredTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/NfcCardEmulationOccurredTest.java
@@ -27,51 +27,46 @@ import static org.mockito.Mockito.when;
 
 import android.annotation.NonNull;
 import android.annotation.RequiresPermission;
-import android.bluetooth.BluetoothProtoEnums;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.ServiceConnection;
-import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
+import android.nfc.ComponentNameAndUser;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
 import android.nfc.cardemulation.PollingFrame;
 import android.os.Binder;
-import android.os.Handler;
 import android.os.IBinder;
-import android.os.Looper;
 import android.os.UserHandle;
 import android.os.test.TestLooper;
 import android.platform.test.annotations.RequiresFlagsDisabled;
 import android.platform.test.flag.junit.CheckFlagsRule;
 import android.platform.test.flag.junit.DeviceFlagsValueProvider;
 import android.util.Log;
-import android.util.Pair;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
 
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
-import com.android.nfc.flags.Flags;
+import com.android.nfc.NfcInjector;
 import com.android.nfc.NfcService;
-import com.android.nfc.cardemulation.RegisteredAidCache.AidResolveInfo;
 import com.android.nfc.NfcStatsLog;
-
-import java.util.ArrayList;
-import java.util.List;
+import com.android.nfc.cardemulation.RegisteredAidCache.AidResolveInfo;
+import com.android.nfc.flags.Flags;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
+import java.util.ArrayList;
+
 @RunWith(AndroidJUnit4.class)
 public final class NfcCardEmulationOccurredTest {
 
@@ -91,12 +86,14 @@ public final class NfcCardEmulationOccurredTest {
     @Before
     public void setUp() {
         Context context = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        mStaticMockSession = ExtendedMockito.mockitoSession()
-                .mockStatic(NfcStatsLog.class)
-                .mockStatic(Flags.class)
-                .mockStatic(NfcService.class)
-                .strictness(Strictness.LENIENT)
-                .startMocking();
+        mStaticMockSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(NfcStatsLog.class)
+                        .mockStatic(Flags.class)
+                        .mockStatic(NfcService.class)
+                        .mockStatic(NfcInjector.class)
+                        .strictness(Strictness.LENIENT)
+                        .startMocking();
         initMockContext(context);
 
         mockAidCache = Mockito.mock(RegisteredAidCache.class);
@@ -112,42 +109,51 @@ public final class NfcCardEmulationOccurredTest {
         aidResolveInfo.services = new ArrayList<ApduServiceInfo>();
         aidResolveInfo.services.add(apduServiceInfo);
         when(mockAidCache.resolveAid(anyString())).thenReturn(aidResolveInfo);
-        when(mockAidCache.getPreferredPaymentService()).thenReturn(new Pair<>(null, null));
+        when(mockAidCache.getPreferredPaymentService())
+                .thenReturn(new ComponentNameAndUser(0, null));
         when(NfcService.getInstance()).thenReturn(mock(NfcService.class));
         when(Flags.statsdCeEventsFlag()).thenReturn(false);
+        when(NfcInjector.getInstance()).thenReturn(mock(NfcInjector.class));
 
-        InstrumentationRegistry.getInstrumentation().runOnMainSync(
-                () -> mHostEmulation = new HostEmulationManager(
-                        mockContext, mTestLooper.getLooper(), mockAidCache));
+        InstrumentationRegistry.getInstrumentation()
+                .runOnMainSync(
+                        () ->
+                                mHostEmulation =
+                                        new HostEmulationManager(
+                                                mockContext,
+                                                mTestLooper.getLooper(),
+                                                mockAidCache));
         assertNotNull(mHostEmulation);
         mHostEmulation.onHostEmulationActivated();
     }
 
     private void initMockContext(Context context) {
-        mockContext = new ContextWrapper(context) {
-            @Override
-            public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-                Log.i(TAG, "[Mock] sendBroadcastAsUser");
-            }
+        mockContext =
+                new ContextWrapper(context) {
+                    @Override
+                    public void sendBroadcastAsUser(Intent intent, UserHandle user) {
+                        Log.i(TAG, "[Mock] sendBroadcastAsUser");
+                    }
 
-            @Override
-            public PackageManager getPackageManager() {
-                Log.i(TAG, "[Mock] getPackageManager");
-                return packageManager;
-            }
+                    @Override
+                    public PackageManager getPackageManager() {
+                        Log.i(TAG, "[Mock] getPackageManager");
+                        return packageManager;
+                    }
 
-            public boolean bindServiceAsUser(
-                    @NonNull @RequiresPermission Intent service,
-                    @NonNull ServiceConnection conn, int flags,
-                    @NonNull UserHandle user) {
-                Log.i(TAG, "[Mock] bindServiceAsUser");
-                return true;
-            }
+                    public boolean bindServiceAsUser(
+                            @NonNull @RequiresPermission Intent service,
+                            @NonNull ServiceConnection conn,
+                            int flags,
+                            @NonNull UserHandle user) {
+                        Log.i(TAG, "[Mock] bindServiceAsUser");
+                        return true;
+                    }
 
-            public void unbindService(@NonNull ServiceConnection conn){
-                Log.i(TAG, "[Mock] unbindService");
-            }
-        };
+                    public void unbindService(@NonNull ServiceConnection conn) {
+                        Log.i(TAG, "[Mock] unbindService");
+                    }
+                };
     }
 
     @After
@@ -159,19 +165,31 @@ public final class NfcCardEmulationOccurredTest {
     @RequiresFlagsDisabled(Flags.FLAG_STATSD_CE_EVENTS_FLAG)
     @Test
     public void testHCEOther() {
-        byte[] aidBytes = new byte[] {
-                0x00, (byte)0xA4, 0x04, 0x00,  // command
-                0x08,  // data length
-                (byte)0xA0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
-                0x00,  // card manager AID
-                0x00  // trailer
-        };
+        byte[] aidBytes =
+                new byte[] {
+                    0x00,
+                    (byte) 0xA4,
+                    0x04,
+                    0x00, // command
+                    0x08, // data length
+                    (byte) 0xA0,
+                    0x00,
+                    0x00,
+                    0x00,
+                    0x03,
+                    0x00,
+                    0x00,
+                    0x00, // card manager AID
+                    0x00 // trailer
+                };
         mHostEmulation.onHostEmulationData(aidBytes);
-        ExtendedMockito.verify(() -> NfcStatsLog.write(
-                NfcStatsLog.NFC_CARDEMULATION_OCCURRED,
-                NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_OTHER,
-                "HCE",
-                UID_1));
+        ExtendedMockito.verify(
+                () ->
+                        NfcStatsLog.write(
+                                NfcStatsLog.NFC_CARDEMULATION_OCCURRED,
+                                NfcStatsLog.NFC_CARDEMULATION_OCCURRED__CATEGORY__HCE_OTHER,
+                                "HCE",
+                                UID_1));
     }
 
     @Test
@@ -189,7 +207,7 @@ public final class NfcCardEmulationOccurredTest {
         ComponentName componentName = mock(ComponentName.class);
         when(componentName.getPackageName()).thenReturn("com.android.nfc");
         when(mockAidCache.getPreferredService())
-                .thenReturn(new Pair<>(0, componentName));
+                .thenReturn(new ComponentNameAndUser(0, componentName));
         mHostEmulation.onPollingLoopDetected(pollingFrames);
         PollingFrame resultPollingFrame = mHostEmulation.mPendingPollingLoopFrames.get(0);
         assertEquals(pollingFrame, resultPollingFrame);
@@ -203,14 +221,12 @@ public final class NfcCardEmulationOccurredTest {
         PollingFrame pollingLoopTypeOffFrame = mock(PollingFrame.class);
         ArrayList<PollingFrame> pollingLoopTypeOffFrames = new ArrayList<PollingFrame>();
         pollingLoopTypeOffFrames.add(pollingLoopTypeOffFrame);
-        when(pollingLoopTypeOnFrame.getType())
-                .thenReturn(PollingFrame.POLLING_LOOP_TYPE_ON);
-        when(pollingLoopTypeOffFrame.getType())
-                .thenReturn(PollingFrame.POLLING_LOOP_TYPE_OFF);
+        when(pollingLoopTypeOnFrame.getType()).thenReturn(PollingFrame.POLLING_LOOP_TYPE_ON);
+        when(pollingLoopTypeOffFrame.getType()).thenReturn(PollingFrame.POLLING_LOOP_TYPE_OFF);
         ComponentName componentName = mock(ComponentName.class);
         when(componentName.getPackageName()).thenReturn("com.android.nfc");
         when(mockAidCache.getPreferredService())
-                .thenReturn(new Pair<>(0, componentName));
+                .thenReturn(new ComponentNameAndUser(0, componentName));
         IBinder iBinder = new Binder();
         ServiceConnection serviceConnection = mHostEmulation.getServiceConnection();
         serviceConnection.onServiceConnected(componentName, iBinder);
@@ -231,15 +247,25 @@ public final class NfcCardEmulationOccurredTest {
         ServiceConnection serviceConnection = mHostEmulation.getServiceConnection();
         serviceConnection.onServiceConnected(componentName, iBinder);
         int state = mHostEmulation.getState();
-        Log.d(TAG, "testOnPollingLoopDetectedSTATE_XFER() - state = "+state);
+        Log.d(TAG, "testOnPollingLoopDetectedSTATE_XFER() - state = " + state);
 
-        byte[] aidBytes = new byte[] {
-                0x00, (byte)0xA4, 0x04, 0x00,  // command
-                0x08,  // data length
-                (byte)0xA0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
-                0x00,  // card manager AID
-                0x00  // trailer
-        };
+        byte[] aidBytes =
+                new byte[] {
+                    0x00,
+                    (byte) 0xA4,
+                    0x04,
+                    0x00, // command
+                    0x08, // data length
+                    (byte) 0xA0,
+                    0x00,
+                    0x00,
+                    0x00,
+                    0x03,
+                    0x00,
+                    0x00,
+                    0x00, // card manager AID
+                    0x00 // trailer
+                };
         mHostEmulation.onHostEmulationData(aidBytes);
         state = mHostEmulation.getState();
         assertEquals(STATE_W4_SERVICE, state);
@@ -257,7 +283,8 @@ public final class NfcCardEmulationOccurredTest {
         ComponentName componentName = mock(ComponentName.class);
         when(componentName.getPackageName()).thenReturn("com.android.nfc");
         int userId = 0;
-        mHostEmulation.onPreferredPaymentServiceChanged(userId, componentName);
+        mHostEmulation.onPreferredPaymentServiceChanged(
+                new ComponentNameAndUser(userId, componentName));
         mTestLooper.dispatchAll();
         ComponentName serviceName = mHostEmulation.getServiceName();
         assertNotNull(serviceName);
@@ -269,8 +296,9 @@ public final class NfcCardEmulationOccurredTest {
         ComponentName componentName = mock(ComponentName.class);
         when(componentName.getPackageName()).thenReturn("com.android.nfc");
         int userId = 0;
-        mHostEmulation.onPreferredForegroundServiceChanged(userId, componentName);
-        Boolean isServiceBounded = mHostEmulation.isServiceBounded();
+        mHostEmulation.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(userId, componentName));
+        Boolean isServiceBounded = mHostEmulation.isServiceBounded(userId, componentName);
         assertNotNull(isServiceBounded);
         assertTrue(isServiceBounded);
     }
diff --git a/tests/unit/src/com/android/nfc/cardemulation/PreferredServicesTest.java b/tests/unit/src/com/android/nfc/cardemulation/PreferredServicesTest.java
index a77f76f8..83d62752 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/PreferredServicesTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/PreferredServicesTest.java
@@ -17,6 +17,7 @@
 package com.android.nfc.cardemulation;
 
 import static com.google.common.truth.Truth.assertThat;
+
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
@@ -25,8 +26,6 @@ import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -35,19 +34,19 @@ import static org.mockito.Mockito.when;
 
 import android.app.ActivityManager;
 import android.content.ComponentName;
-import android.content.Context;
 import android.content.ContentResolver;
+import android.content.Context;
 import android.content.ContextWrapper;
 import android.database.ContentObserver;
+import android.net.Uri;
+import android.nfc.ComponentNameAndUser;
 import android.nfc.Constants;
+import android.nfc.cardemulation.ApduServiceInfo;
+import android.nfc.cardemulation.CardEmulation;
 import android.os.Process;
 import android.os.UserHandle;
 import android.os.UserManager;
-import android.net.Uri;
-import android.nfc.cardemulation.ApduServiceInfo;
-import android.nfc.cardemulation.CardEmulation;
 import android.provider.Settings;
-import android.util.Log;
 
 import androidx.test.platform.app.InstrumentationRegistry;
 import androidx.test.runner.AndroidJUnit4;
@@ -55,10 +54,6 @@ import androidx.test.runner.AndroidJUnit4;
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.ForegroundUtils;
 
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -66,11 +61,14 @@ import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
-import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.List;
+
 @RunWith(AndroidJUnit4.class)
 public class PreferredServicesTest {
 
@@ -78,90 +76,80 @@ public class PreferredServicesTest {
     private MockitoSession mStaticMockSession;
     private Context mContext;
 
-    @Mock
-    private RegisteredServicesCache mServicesCache;
-    @Mock
-    private PreferredServices.Callback mCallback;
-    @Mock
-    private RegisteredAidCache mAidCache;
-    @Mock
-    private WalletRoleObserver mObserver;
-    @Mock
-    private ForegroundUtils mForegroundUtils;
-    @Mock
-    private ContentResolver mContentResolver;
-    @Mock
-    private UserManager mUserManager;
-    @Mock
-    private ActivityManager mActivityManager;
-    @Mock
-    private ApduServiceInfo mServiceInfoPayment;
-    @Mock
-    private ApduServiceInfo mServiceInfoNonPayment;
-    @Mock
-    private UserHandle mUserHandle;
-    @Mock
-    private PrintWriter mPrintWriter;
-    @Mock
-    private RegisteredAidCache.AidResolveInfo mResolveInfo;
-    @Captor
-    private ArgumentCaptor<Integer> userIdCaptor;
-    @Captor
-    private ArgumentCaptor<ComponentName> candidateCaptor;
-    @Captor
-    private ArgumentCaptor<ContentObserver> mSettingsObserverCaptor;
+    @Mock private RegisteredServicesCache mServicesCache;
+    @Mock private PreferredServices.Callback mCallback;
+    @Mock private RegisteredAidCache mAidCache;
+    @Mock private WalletRoleObserver mObserver;
+    @Mock private ForegroundUtils mForegroundUtils;
+    @Mock private ContentResolver mContentResolver;
+    @Mock private UserManager mUserManager;
+    @Mock private ActivityManager mActivityManager;
+    @Mock private ApduServiceInfo mServiceInfoPayment;
+    @Mock private ApduServiceInfo mServiceInfoNonPayment;
+    @Mock private UserHandle mUserHandle;
+    @Mock private PrintWriter mPrintWriter;
+    @Mock private RegisteredAidCache.AidResolveInfo mResolveInfo;
+
+    @Captor private ArgumentCaptor<ComponentNameAndUser> candidateCaptor;
+    @Captor private ArgumentCaptor<ContentObserver> mSettingsObserverCaptor;
 
     private static final String WALLET_HOLDER_PACKAGE_NAME = "com.android.test.walletroleholder";
-    private static final ComponentName TEST_COMPONENT
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.WalletRoleHolderApduService");
+    private static final ComponentName TEST_COMPONENT =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.WalletRoleHolderApduService");
     private static final int USER_ID = 1;
+    private static final int USER_ID_2 = 2;
     private static final int FOREGROUND_UID = 7;
 
     @Before
     public void setUp() throws Exception {
-        mStaticMockSession = ExtendedMockito.mockitoSession()
-                .mockStatic(ForegroundUtils.class)
-                .mockStatic(ActivityManager.class)
-                .mockStatic(UserHandle.class)
-                .mockStatic(Settings.Secure.class)
-                .mockStatic(ComponentName.class)
-                .strictness(Strictness.LENIENT)
-                .startMocking();
+        mStaticMockSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(ForegroundUtils.class)
+                        .mockStatic(ActivityManager.class)
+                        .mockStatic(UserHandle.class)
+                        .mockStatic(Settings.Secure.class)
+                        .mockStatic(ComponentName.class)
+                        .strictness(Strictness.LENIENT)
+                        .startMocking();
         MockitoAnnotations.initMocks(this);
-        mContext = new ContextWrapper(
-                InstrumentationRegistry.getInstrumentation().getTargetContext()) {
-            @Override
-            public Object getSystemService(String name) {
-                if (Context.ACTIVITY_SERVICE.equals(name)) {
-                    return (ActivityManager) mActivityManager;
-                } else if (Context.USER_SERVICE.equals(name)) {
-                    return (UserManager) mUserManager;
-                } else {
-                    return null;
-                }
-            }
-
-            @Override
-            public Context createContextAsUser(UserHandle user, int flags) {
-                return mContext;
-            }
-
-            @Override
-            public ContentResolver getContentResolver() {
-                return mContentResolver;
-            }
-        };
+        mContext =
+                new ContextWrapper(
+                        InstrumentationRegistry.getInstrumentation().getTargetContext()) {
+                    @Override
+                    public Object getSystemService(String name) {
+                        if (Context.ACTIVITY_SERVICE.equals(name)) {
+                            return (ActivityManager) mActivityManager;
+                        } else if (Context.USER_SERVICE.equals(name)) {
+                            return (UserManager) mUserManager;
+                        } else {
+                            return null;
+                        }
+                    }
+
+                    @Override
+                    public Context createContextAsUser(UserHandle user, int flags) {
+                        return mContext;
+                    }
+
+                    @Override
+                    public ContentResolver getContentResolver() {
+                        return mContentResolver;
+                    }
+                };
 
         when(ForegroundUtils.getInstance(any(ActivityManager.class))).thenReturn(mForegroundUtils);
         when(ActivityManager.getCurrentUser()).thenReturn(USER_ID);
-        doNothing().when(mContentResolver)
-                .registerContentObserverAsUser(any(Uri.class), anyBoolean(), any(),
-                        any(UserHandle.class));
-        doNothing().when(mCallback).onPreferredPaymentServiceChanged(anyInt(), any());
+        doNothing()
+                .when(mContentResolver)
+                .registerContentObserverAsUser(
+                        any(Uri.class), anyBoolean(), any(), any(UserHandle.class));
+        doNothing().when(mCallback).onPreferredPaymentServiceChanged(any());
         when(Settings.Secure.getString(any(ContentResolver.class), anyString()))
-                .thenReturn("com.android.test.walletroleholder/com.android"
-                        + ".test.walletroleholder.WalletRoleHolderApduService");
+                .thenReturn(
+                        "com.android.test.walletroleholder/com.android"
+                                + ".test.walletroleholder.WalletRoleHolderApduService");
         when(Settings.Secure.getInt(any(ContentResolver.class), anyString())).thenReturn(USER_ID);
         when(UserHandle.getUserHandleForUid(anyInt())).thenReturn(mUserHandle);
         when(UserHandle.of(anyInt())).thenReturn(mUserHandle);
@@ -169,12 +157,11 @@ public class PreferredServicesTest {
         when(mObserver.getDefaultWalletRoleHolder(anyInt())).thenReturn(null);
         when(mServiceInfoPayment.getComponent()).thenReturn(TEST_COMPONENT);
         when(mServiceInfoPayment.getAids()).thenReturn(getAids());
-        when(mServiceInfoPayment
-                .getCategoryForAid(anyString())).thenReturn(CardEmulation.CATEGORY_PAYMENT);
-        when(mServiceInfoPayment.hasCategory(eq(CardEmulation.CATEGORY_PAYMENT)))
-                .thenReturn(true);
-        when(mServiceInfoNonPayment.hasCategory(eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(
-                false);
+        when(mServiceInfoPayment.getCategoryForAid(anyString()))
+                .thenReturn(CardEmulation.CATEGORY_PAYMENT);
+        when(mServiceInfoPayment.hasCategory(eq(CardEmulation.CATEGORY_PAYMENT))).thenReturn(true);
+        when(mServiceInfoNonPayment.hasCategory(eq(CardEmulation.CATEGORY_PAYMENT)))
+                .thenReturn(false);
         when(mServiceInfoNonPayment.getAids()).thenReturn(getAids());
         when(mAidCache.resolveAid(anyString())).thenReturn(mResolveInfo);
         when(mUserManager.getEnabledProfiles()).thenReturn(getUserHandles());
@@ -222,25 +209,26 @@ public class PreferredServicesTest {
         verify(mUserManager).getEnabledProfiles();
         verify(mObserver).getDefaultWalletRoleHolder(anyInt());
         assertThat(services.mDefaultWalletHolderPaymentService).isNull();
-        verify(mCallback).onPreferredPaymentServiceChanged(anyInt(), any());
+        verify(mCallback).onPreferredPaymentServiceChanged(any());
     }
 
     @Test
     public void testOnWalletRoleHolderChangedWithNullPackageName() {
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
+        services.mUserIdDefaultWalletHolder = 42;
+        services.mDefaultWalletHolderPaymentService = TEST_COMPONENT;
 
         services.onWalletRoleHolderChanged(null, USER_ID);
 
-        verify(mCallback, times(2))
-                .onPreferredPaymentServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        List<Integer> userIds = userIdCaptor.getAllValues();
-        assertThat(userIds.get(0)).isEqualTo(USER_ID);
-        assertThat(userIds.get(1)).isEqualTo(USER_ID);
-        List<ComponentName> candidates = candidateCaptor.getAllValues();
-        assertThat(candidates.get(0)).isNull();
-        assertThat(candidates.get(1)).isNull();
+        verify(mCallback, times(2)).onPreferredPaymentServiceChanged(candidateCaptor.capture());
+        List<ComponentNameAndUser> candidates = candidateCaptor.getAllValues();
+        assertThat(candidates.get(0).getUserId()).isEqualTo(USER_ID);
+        assertThat(candidates.get(1).getUserId()).isEqualTo(USER_ID);
+
+        assertThat(candidates.get(0).getComponentName()).isNull();
+        assertThat(candidates.get(1).getComponentName()).isNull();
         assertThat(services.mDefaultWalletHolderPaymentService).isNull();
+        assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID);
     }
 
     @Test
@@ -251,15 +239,13 @@ public class PreferredServicesTest {
         services.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
 
         assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID);
-        verify(mCallback, times(2))
-                .onPreferredPaymentServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        List<Integer> userIds = userIdCaptor.getAllValues();
-        assertThat(userIds.get(0)).isEqualTo(USER_ID);
-        assertThat(userIds.get(1)).isEqualTo(USER_ID);
-        List<ComponentName> candidates = candidateCaptor.getAllValues();
-        assertThat(candidates.get(0)).isNull();
-        assertThat(candidates.get(1)).isEqualTo(TEST_COMPONENT);
+        verify(mCallback, times(2)).onPreferredPaymentServiceChanged(candidateCaptor.capture());
+        List<ComponentNameAndUser> candidates = candidateCaptor.getAllValues();
+        assertThat(candidates.get(0).getUserId()).isEqualTo(USER_ID);
+        assertThat(candidates.get(1).getUserId()).isEqualTo(USER_ID);
+
+        assertThat(candidates.get(0).getComponentName()).isNull();
+        assertThat(candidates.get(1).getComponentName()).isEqualTo(TEST_COMPONENT);
         assertThat(services.mDefaultWalletHolderPaymentService).isEqualTo(TEST_COMPONENT);
     }
 
@@ -272,7 +258,7 @@ public class PreferredServicesTest {
         services.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
 
         assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID);
-        verify(mCallback).onPreferredPaymentServiceChanged(anyInt(), any());
+        verify(mCallback).onPreferredPaymentServiceChanged(any());
         assertThat(services.mDefaultWalletHolderPaymentService).isNull();
     }
 
@@ -281,13 +267,37 @@ public class PreferredServicesTest {
         when(mServicesCache.getInstalledServices(eq(USER_ID))).thenReturn(getPaymentServices());
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
 
-        services.onWalletRoleHolderChanged(/* defaultWalletHolderPackageName = */ "", USER_ID);
+        services.onWalletRoleHolderChanged(/* defaultWalletHolderPackageName= */ "", USER_ID);
 
         assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID);
-        verify(mCallback).onPreferredPaymentServiceChanged(anyInt(), any());
+        verify(mCallback).onPreferredPaymentServiceChanged(any());
         assertThat(services.mDefaultWalletHolderPaymentService).isNull();
     }
 
+    @Test
+    public void testOnWalletRoleHolderChangedSamePackageDifferentUser() {
+        when(mServicesCache.getInstalledServices(eq(USER_ID))).thenReturn(getPaymentServices());
+        when(mServicesCache.getInstalledServices(eq(USER_ID_2))).thenReturn(getPaymentServices());
+
+        services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
+
+        services.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
+        services.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID_2);
+
+        assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID_2);
+
+        verify(mCallback, times(3)).onPreferredPaymentServiceChanged(candidateCaptor.capture());
+        List<ComponentNameAndUser> candidates = candidateCaptor.getAllValues();
+        assertThat(candidates.get(0).getUserId()).isEqualTo(USER_ID);
+        assertThat(candidates.get(1).getUserId()).isEqualTo(USER_ID);
+        assertThat(candidates.get(2).getUserId()).isEqualTo(USER_ID_2);
+
+        assertThat(candidates.get(0).getComponentName()).isNull();
+        assertThat(candidates.get(1).getComponentName()).isEqualTo(TEST_COMPONENT);
+        assertThat(candidates.get(2).getComponentName()).isEqualTo(TEST_COMPONENT);
+        assertThat(services.mDefaultWalletHolderPaymentService).isEqualTo(TEST_COMPONENT);
+    }
+
     @Test
     public void testSetDefaultForNextTapWithNonNullService_NotifyChange() {
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
@@ -300,11 +310,9 @@ public class PreferredServicesTest {
         assertThat(services.mNextTapDefaultUserId).isEqualTo(USER_ID);
         assertThat(services.mForegroundCurrent).isEqualTo(TEST_COMPONENT);
         assertThat(services.mForegroundCurrentUid).isEqualTo(FOREGROUND_UID);
-        verify(mCallback)
-                .onPreferredForegroundServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        assertThat(userIdCaptor.getValue()).isEqualTo(USER_ID);
-        assertThat(candidateCaptor.getValue()).isEqualTo(TEST_COMPONENT);
+        verify(mCallback).onPreferredForegroundServiceChanged(candidateCaptor.capture());
+        assertThat(candidateCaptor.getValue().getUserId()).isEqualTo(USER_ID);
+        assertThat(candidateCaptor.getValue().getComponentName()).isEqualTo(TEST_COMPONENT);
     }
 
     @Test
@@ -314,14 +322,14 @@ public class PreferredServicesTest {
         services.mForegroundRequested = null;
         services.mForegroundCurrent = null;
 
-        boolean result = services.setDefaultForNextTap(USER_ID, /* service = */ null);
+        boolean result = services.setDefaultForNextTap(USER_ID, /* service= */ null);
 
         assertThat(result).isTrue();
         assertThat(services.mNextTapDefault).isNull();
         assertThat(services.mNextTapDefaultUserId).isEqualTo(USER_ID);
         assertThat(services.mForegroundCurrent).isEqualTo(null);
         assertThat(services.mForegroundCurrentUid).isEqualTo(0);
-        verify(mCallback, never()).onPreferredForegroundServiceChanged(anyInt(), any());
+        verify(mCallback, never()).onPreferredForegroundServiceChanged(any());
     }
 
     @Test
@@ -336,7 +344,7 @@ public class PreferredServicesTest {
         assertThat(services.mNextTapDefaultUserId).isEqualTo(FOREGROUND_UID);
         assertThat(services.mForegroundCurrent).isEqualTo(TEST_COMPONENT);
         assertThat(services.mForegroundCurrentUid).isEqualTo(0);
-        verify(mCallback, never()).onPreferredForegroundServiceChanged(anyInt(), any());
+        verify(mCallback, never()).onPreferredForegroundServiceChanged(any());
     }
 
     @Test
@@ -346,18 +354,16 @@ public class PreferredServicesTest {
         services.mForegroundRequested = null;
         services.mForegroundCurrent = TEST_COMPONENT;
 
-        boolean result = services.setDefaultForNextTap(USER_ID, /* service = */ null);
+        boolean result = services.setDefaultForNextTap(USER_ID, /* service= */ null);
 
         assertThat(result).isTrue();
         assertThat(services.mNextTapDefault).isNull();
         assertThat(services.mNextTapDefaultUserId).isEqualTo(USER_ID);
         assertThat(services.mForegroundCurrent).isEqualTo(null);
         assertThat(services.mForegroundCurrentUid).isEqualTo(FOREGROUND_UID);
-        verify(mCallback)
-                .onPreferredForegroundServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        assertThat(userIdCaptor.getValue()).isEqualTo(FOREGROUND_UID);
-        assertThat(candidateCaptor.getValue()).isNull();
+        verify(mCallback).onPreferredForegroundServiceChanged(candidateCaptor.capture());
+        assertThat(candidateCaptor.getValue().getUserId()).isEqualTo(FOREGROUND_UID);
+        assertThat(candidateCaptor.getValue().getComponentName()).isNull();
     }
 
     @Test
@@ -377,8 +383,8 @@ public class PreferredServicesTest {
         when(mObserver.isWalletRoleFeatureEnabled()).thenReturn(true);
         when(mServicesCache.getInstalledServices(eq(USER_ID))).thenReturn(getPaymentServices());
         when(mServicesCache.getService(anyInt(), any())).thenReturn(mServiceInfoPayment);
-        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID))).thenReturn(
-                WALLET_HOLDER_PACKAGE_NAME);
+        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID)))
+                .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
         services.mUserIdDefaultWalletHolder = USER_ID;
         services.mForegroundCurrent = TEST_COMPONENT;
@@ -399,8 +405,8 @@ public class PreferredServicesTest {
         when(mObserver.isWalletRoleFeatureEnabled()).thenReturn(true);
         when(mServicesCache.getInstalledServices(eq(USER_ID))).thenReturn(getPaymentServices());
         when(mServicesCache.getService(anyInt(), any())).thenReturn(mServiceInfoNonPayment);
-        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID))).thenReturn(
-                WALLET_HOLDER_PACKAGE_NAME);
+        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID)))
+                .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
         mResolveInfo.category = CardEmulation.CATEGORY_PAYMENT;
         mResolveInfo.defaultService = mServiceInfoNonPayment;
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
@@ -424,8 +430,8 @@ public class PreferredServicesTest {
         when(mObserver.isWalletRoleFeatureEnabled()).thenReturn(true);
         when(mServicesCache.getInstalledServices(eq(USER_ID))).thenReturn(getPaymentServices());
         when(mServicesCache.getService(anyInt(), any())).thenReturn(mServiceInfoNonPayment);
-        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID))).thenReturn(
-                WALLET_HOLDER_PACKAGE_NAME);
+        when(mObserver.getDefaultWalletRoleHolder(eq(USER_ID)))
+                .thenReturn(WALLET_HOLDER_PACKAGE_NAME);
         mResolveInfo.category = CardEmulation.CATEGORY_PAYMENT;
         mResolveInfo.defaultService = null;
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
@@ -563,11 +569,9 @@ public class PreferredServicesTest {
         assertThat(services.mPaymentDefaults.settingsDefault).isEqualTo(null);
         assertThat(services.mPaymentDefaults.currentPreferred).isEqualTo(null);
         assertThat(services.mPaymentDefaults.mUserHandle).isEqualTo(mUserHandle);
-        verify(mCallback)
-                .onPreferredPaymentServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        assertThat(userIdCaptor.getValue()).isEqualTo(FOREGROUND_UID);
-        assertThat(candidateCaptor.getValue()).isEqualTo(null);
+        verify(mCallback).onPreferredPaymentServiceChanged(candidateCaptor.capture());
+        assertThat(candidateCaptor.getValue().getUserId()).isEqualTo(FOREGROUND_UID);
+        assertThat(candidateCaptor.getValue().getComponentName()).isEqualTo(null);
     }
 
     @Test
@@ -576,7 +580,7 @@ public class PreferredServicesTest {
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
         services.mPaymentDefaults.preferForeground = false;
         services.mPaymentDefaults.currentPreferred = null;
-        verify(mCallback).onPreferredPaymentServiceChanged(anyInt(), any());
+        verify(mCallback).onPreferredPaymentServiceChanged(any());
 
         services.onUserSwitched(USER_ID);
 
@@ -591,7 +595,7 @@ public class PreferredServicesTest {
     public void testPackageHasPreferredServiceWithNullPackageName_ReturnsFalse() {
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
 
-        boolean result = services.packageHasPreferredService(/* packageName = */ null);
+        boolean result = services.packageHasPreferredService(/* packageName= */ null);
 
         assertThat(result).isFalse();
     }
@@ -641,13 +645,11 @@ public class PreferredServicesTest {
         verify(mObserver, times(4)).isWalletRoleFeatureEnabled();
         verify(mObserver, times(2)).getDefaultWalletRoleHolder(eq(USER_ID));
         assertThat(services.mUserIdDefaultWalletHolder).isEqualTo(USER_ID);
-        verify(mCallback)
-                .onPreferredPaymentServiceChanged(userIdCaptor.capture(),
-                        candidateCaptor.capture());
-        List<Integer> userIds = userIdCaptor.getAllValues();
-        assertThat(userIds.get(0)).isEqualTo(USER_ID);
-        List<ComponentName> candidates = candidateCaptor.getAllValues();
-        assertThat(candidates.get(0)).isEqualTo(TEST_COMPONENT);
+        verify(mCallback).onPreferredPaymentServiceChanged(candidateCaptor.capture());
+        List<ComponentNameAndUser> candidates = candidateCaptor.getAllValues();
+        assertThat(candidates.get(0).getUserId()).isEqualTo(USER_ID);
+
+        assertThat(candidates.get(0).getComponentName()).isEqualTo(TEST_COMPONENT);
         assertThat(services.mDefaultWalletHolderPaymentService).isEqualTo(TEST_COMPONENT);
     }
 
@@ -673,10 +675,11 @@ public class PreferredServicesTest {
     public void testSettingObserverOnChange() {
         when(mUserManager.getUserName()).thenReturn("");
         services = new PreferredServices(mContext, mServicesCache, mAidCache, mObserver, mCallback);
-        verify(mContentResolver, times(2)).registerContentObserverAsUser(
-                any(), anyBoolean(), mSettingsObserverCaptor.capture(), any());
-        Uri uri = Settings.Secure.getUriFor(
-                Constants.SETTINGS_SECURE_NFC_PAYMENT_DEFAULT_COMPONENT);
+        verify(mContentResolver, times(2))
+                .registerContentObserverAsUser(
+                        any(), anyBoolean(), mSettingsObserverCaptor.capture(), any());
+        Uri uri =
+                Settings.Secure.getUriFor(Constants.SETTINGS_SECURE_NFC_PAYMENT_DEFAULT_COMPONENT);
         mSettingsObserverCaptor.getValue().onChange(true, uri);
         verify(mObserver, atLeast(1)).isWalletRoleFeatureEnabled();
         assertTrue(services.mPaymentDefaults.preferForeground);
@@ -689,13 +692,14 @@ public class PreferredServicesTest {
         services.mForegroundUid = FOREGROUND_UID;
         boolean result = services.setDefaultForNextTap(USER_ID, TEST_COMPONENT);
         assertThat(result).isTrue();
-        verify(mContentResolver, times(2)).registerContentObserverAsUser(
-                any(), anyBoolean(), mSettingsObserverCaptor.capture(), any());
-        Uri uri = Settings.Secure.getUriFor(
-                Constants.SETTINGS_SECURE_NFC_PAYMENT_DEFAULT_COMPONENT);
+        verify(mContentResolver, times(2))
+                .registerContentObserverAsUser(
+                        any(), anyBoolean(), mSettingsObserverCaptor.capture(), any());
+        Uri uri =
+                Settings.Secure.getUriFor(Constants.SETTINGS_SECURE_NFC_PAYMENT_DEFAULT_COMPONENT);
         mSettingsObserverCaptor.getValue().onChange(true, uri);
         verify(mObserver, atLeast(1)).isWalletRoleFeatureEnabled();
         assertTrue(services.mPaymentDefaults.preferForeground);
-        verify(mCallback).onPreferredForegroundServiceChanged(anyInt(), any());
+        verify(mCallback).onPreferredForegroundServiceChanged(any());
     }
-}
\ No newline at end of file
+}
diff --git a/tests/unit/src/com/android/nfc/cardemulation/RegisteredAidCacheTest.java b/tests/unit/src/com/android/nfc/cardemulation/RegisteredAidCacheTest.java
index 27138d83..2f20ba1c 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/RegisteredAidCacheTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/RegisteredAidCacheTest.java
@@ -18,6 +18,7 @@ package com.android.nfc.cardemulation;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
@@ -30,11 +31,13 @@ import static org.mockito.Mockito.when;
 import android.app.ActivityManager;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.pm.PackageManager;
+import android.nfc.ComponentNameAndUser;
+import android.nfc.Flags;
 import android.nfc.cardemulation.ApduServiceInfo;
 import android.nfc.cardemulation.CardEmulation;
 import android.os.UserHandle;
 import android.os.UserManager;
-import android.util.Pair;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
@@ -50,12 +53,12 @@ import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
 import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 
 @RunWith(AndroidJUnit4.class)
@@ -73,37 +76,39 @@ public class RegisteredAidCacheTest {
     private static final String WALLET_HOLDER_PACKAGE_NAME = "com.android.test.walletroleholder";
     private static final String WALLET_HOLDER_2_PACKAGE_NAME = "com.android.test.walletroleholder2";
 
-    private static final ComponentName WALLET_PAYMENT_SERVICE
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.WalletRoleHolderApduService");
-
-    private static final ComponentName WALLET_PAYMENT_SERVICE_2
-            = new ComponentName(WALLET_HOLDER_PACKAGE_NAME,
-            "com.android.test.walletroleholder.XWalletRoleHolderApduService");
-    private static final ComponentName FOREGROUND_SERVICE
-            = new ComponentName(NFC_FOREGROUND_PACKAGE_NAME,
-            "com.android.test.foregroundnfc.ForegroundApduService");
+    private static final ComponentName WALLET_PAYMENT_SERVICE =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.WalletRoleHolderApduService");
+
+    private static final ComponentName WALLET_PAYMENT_SERVICE_2 =
+            new ComponentName(
+                    WALLET_HOLDER_PACKAGE_NAME,
+                    "com.android.test.walletroleholder.XWalletRoleHolderApduService");
+    private static final ComponentName FOREGROUND_SERVICE =
+            new ComponentName(
+                    NFC_FOREGROUND_PACKAGE_NAME,
+                    "com.android.test.foregroundnfc.ForegroundApduService");
     private static final ComponentName NON_PAYMENT_SERVICE =
-            new ComponentName(NON_PAYMENT_NFC_PACKAGE_NAME,
+            new ComponentName(
+                    NON_PAYMENT_NFC_PACKAGE_NAME,
                     "com.android.test.nonpaymentnfc.NonPaymentApduService");
 
     private static final ComponentName PAYMENT_SERVICE =
-            new ComponentName(WALLET_HOLDER_2_PACKAGE_NAME,
+            new ComponentName(
+                    WALLET_HOLDER_2_PACKAGE_NAME,
                     "com.android.test.walletroleholder.WalletRoleHolderXApduService");
 
     private static final int USER_ID = 0;
     private static final UserHandle USER_HANDLE = UserHandle.of(USER_ID);
 
-    @Mock
-    private Context mContext;
-    @Mock
-    private WalletRoleObserver mWalletRoleObserver;
-    @Mock
-    private AidRoutingManager mAidRoutingManager;
-    @Mock
-    private UserManager mUserManager;
-    @Mock
-    private NfcService mNfcService;
+    @Mock private Context mContext;
+    @Mock private WalletRoleObserver mWalletRoleObserver;
+    @Mock private AidRoutingManager mAidRoutingManager;
+    @Mock private UserManager mUserManager;
+    @Mock private PackageManager mPackageManager;
+    @Mock private NfcService mNfcService;
+
     @Captor
     private ArgumentCaptor<HashMap<String, AidRoutingManager.AidEntry>> mRoutingEntryMapCaptor;
 
@@ -113,19 +118,21 @@ public class RegisteredAidCacheTest {
 
     @Before
     public void setUp() {
-        mStaticMockSession = ExtendedMockito.mockitoSession()
-                .mockStatic(ActivityManager.class)
-                .mockStatic(NfcService.class)
-                .strictness(Strictness.LENIENT)
-                .initMocks(this)
-                .startMocking();
+        mStaticMockSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(ActivityManager.class)
+                        .mockStatic(NfcService.class)
+                        .mockStatic(Flags.class)
+                        .strictness(Strictness.LENIENT)
+                        .initMocks(this)
+                        .startMocking();
         when(ActivityManager.getCurrentUser()).thenReturn(USER_ID);
         when(NfcService.getInstance()).thenReturn(mNfcService);
         when(mNfcService.getNciVersion()).thenReturn(NfcService.NCI_VERSION_1_0);
         when(mUserManager.getProfileParent(eq(USER_HANDLE))).thenReturn(USER_HANDLE);
-        when(mContext.createContextAsUser(
-                any(), anyInt())).thenReturn(mContext);
+        when(mContext.createContextAsUser(any(), anyInt())).thenReturn(mContext);
         when(mContext.getSystemService(eq(UserManager.class))).thenReturn(mUserManager);
+        when (mContext.getPackageManager()).thenReturn(mPackageManager);
     }
 
     @After
@@ -136,8 +143,8 @@ public class RegisteredAidCacheTest {
     @Test
     public void testConstructor_supportsPrefixAndSubset() {
         supportPrefixAndSubset(true);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         verify(mAidRoutingManager).supportsAidPrefixRouting();
         verify(mAidRoutingManager).supportsAidSubsetRouting();
@@ -148,8 +155,8 @@ public class RegisteredAidCacheTest {
     @Test
     public void testConstructor_doesNotSupportsPrefixAndSubset() {
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         verify(mAidRoutingManager).supportsAidPrefixRouting();
         verify(mAidRoutingManager).supportsAidSubsetRouting();
@@ -177,49 +184,54 @@ public class RegisteredAidCacheTest {
     public void testAidConflictResolution_walletRoleEnabledNfcDisabled_foregroundWins() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = false;
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                FOREGROUND_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        FOREGROUND_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
-        mRegisteredAidCache.onPreferredForegroundServiceChanged(USER_ID, FOREGROUND_SERVICE);
-        RegisteredAidCache.AidResolveInfo resolveInfo
-                = mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
+        mRegisteredAidCache.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, FOREGROUND_SERVICE));
+        RegisteredAidCache.AidResolveInfo resolveInfo =
+                mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
 
         verify(mAidRoutingManager).supportsAidPrefixRouting();
         verify(mAidRoutingManager).supportsAidSubsetRouting();
         assertEquals(FOREGROUND_SERVICE, resolveInfo.defaultService.getComponent());
-        assertEquals(new Pair<>(USER_ID, FOREGROUND_SERVICE),
+        assertEquals(
+                new ComponentNameAndUser(USER_ID, FOREGROUND_SERVICE),
                 mRegisteredAidCache.getPreferredService());
         assertEquals(1, resolveInfo.services.size());
         assertEquals(CardEmulation.CATEGORY_PAYMENT, resolveInfo.category);
@@ -230,46 +242,49 @@ public class RegisteredAidCacheTest {
     public void testAidConflictResolution_walletRoleEnabledNfcEnabled_walletWins() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = true;
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                true,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                true,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
-        RegisteredAidCache.AidResolveInfo paymentResolveInfo
-                = mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
-        RegisteredAidCache.AidResolveInfo nonPaymentResolveInfo
-                = mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo paymentResolveInfo =
+                mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo nonPaymentResolveInfo =
+                mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
 
         assertEquals(WALLET_PAYMENT_SERVICE, paymentResolveInfo.defaultService.getComponent());
         assertEquals(1, paymentResolveInfo.services.size());
@@ -277,8 +292,7 @@ public class RegisteredAidCacheTest {
         assertEquals(NON_PAYMENT_SERVICE, nonPaymentResolveInfo.defaultService.getComponent());
         assertEquals(1, nonPaymentResolveInfo.services.size());
         assertEquals(CardEmulation.CATEGORY_OTHER, nonPaymentResolveInfo.category);
-        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(),
-                eq(false));
+        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(), eq(false));
         HashMap<String, AidRoutingManager.AidEntry> routingEntries =
                 mRoutingEntryMapCaptor.getValue();
         assertTrue(routingEntries.containsKey(PAYMENT_AID_1));
@@ -291,9 +305,18 @@ public class RegisteredAidCacheTest {
     }
 
     @Test
-    public void testAidConflictResolution_walletRoleEnabledNfcEnabledPreFixAid_walletWins() {
+    public void testAidConflictResolution_walletRoleEnabledNfcEnabled_associatedRoleServices()
+            throws PackageManager.NameNotFoundException {
         setWalletRoleFlag(true);
-        supportPrefixAndSubset(true);
+        supportPrefixAndSubset(false);
+        when(Flags.nfcAssociatedRoleServices()).thenReturn(true);
+        when(mPackageManager.getProperty(
+                eq(CardEmulation.PROPERTY_ALLOW_SHARED_ROLE_PRIORITY),
+                eq(WALLET_HOLDER_PACKAGE_NAME)))
+                .thenReturn(new PackageManager.Property(
+                        CardEmulation.PROPERTY_ALLOW_SHARED_ROLE_PRIORITY,
+                        true, WALLET_HOLDER_PACKAGE_NAME, null));
+
         mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
                 mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = true;
@@ -302,38 +325,92 @@ public class RegisteredAidCacheTest {
         apduServiceInfos.add(createServiceInfoForAidRouting(
                 WALLET_PAYMENT_SERVICE,
                 true,
-                List.of(PREFIX_PAYMENT_AID),
+                List.of(PAYMENT_AID_1),
                 List.of(CardEmulation.CATEGORY_PAYMENT),
                 false,
                 true,
                 USER_ID,
+                true,
                 true));
         apduServiceInfos.add(createServiceInfoForAidRouting(
                 PAYMENT_SERVICE,
                 true,
-                List.of(PAYMENT_AID_1),
+                List.of(PAYMENT_AID_2),
                 List.of(CardEmulation.CATEGORY_PAYMENT),
                 false,
                 true,
                 USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
                 true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
                 true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
+
+        mRegisteredAidCache.mAssociatedRoleServices = new HashSet<>(apduServiceInfos);
+        mRegisteredAidCache.generateAidCacheLocked();
+
         RegisteredAidCache.AidResolveInfo paymentResolveInfo
-                = mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
-        RegisteredAidCache.AidResolveInfo nonPaymentResolveInfo
-                = mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
+                = mRegisteredAidCache.resolveAid(PAYMENT_AID_2);
+
+        assertNotNull(paymentResolveInfo.defaultService);
+        assertEquals(PAYMENT_SERVICE, paymentResolveInfo.defaultService.getComponent());
+        assertEquals(CardEmulation.CATEGORY_PAYMENT, paymentResolveInfo.category);
+        assertEquals(1, paymentResolveInfo.services.size());
+
+        assertTrue(mRegisteredAidCache.isPreferredServicePackageNameForUser(
+                WALLET_HOLDER_PACKAGE_NAME, USER_ID));
+        assertTrue(mRegisteredAidCache.isPreferredServicePackageNameForUser(
+                WALLET_HOLDER_2_PACKAGE_NAME, USER_ID));
+    }
+
+    @Test
+    public void testAidConflictResolution_walletRoleEnabledNfcEnabledPreFixAid_walletWins() {
+        setWalletRoleFlag(true);
+        supportPrefixAndSubset(true);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
+        mRegisteredAidCache.mNfcEnabled = true;
+
+        List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PREFIX_PAYMENT_AID),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+
+        mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
+        mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
+        mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
+        RegisteredAidCache.AidResolveInfo paymentResolveInfo =
+                mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo nonPaymentResolveInfo =
+                mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
 
         assertEquals(WALLET_PAYMENT_SERVICE, paymentResolveInfo.defaultService.getComponent());
         assertEquals(1, paymentResolveInfo.services.size());
@@ -347,43 +424,46 @@ public class RegisteredAidCacheTest {
     public void testAidConflictResolution_walletRoleEnabled_twoServicesOnWallet_firstServiceWins() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE_2,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE_2,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
-        RegisteredAidCache.AidResolveInfo resolveInfo
-                = mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo resolveInfo =
+                mRegisteredAidCache.resolveAid(PAYMENT_AID_1);
         assertEquals(WALLET_PAYMENT_SERVICE, resolveInfo.defaultService.getComponent());
         assertEquals(2, resolveInfo.services.size());
         assertEquals(CardEmulation.CATEGORY_PAYMENT, resolveInfo.category);
@@ -393,34 +473,36 @@ public class RegisteredAidCacheTest {
     public void testAidConflictResolution_walletOtherServiceDisabled_nonDefaultServiceWins() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                false));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        false));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
-        RegisteredAidCache.AidResolveInfo resolveInfo
-                = mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo resolveInfo =
+                mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
         assertEquals(PAYMENT_SERVICE, resolveInfo.defaultService.getComponent());
         assertEquals(1, resolveInfo.services.size());
     }
@@ -429,25 +511,26 @@ public class RegisteredAidCacheTest {
     public void testAidConflictResolution_walletOtherServiceDisabled_emptyServices() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                false));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        false));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
-        RegisteredAidCache.AidResolveInfo resolveInfo
-                = mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
+        RegisteredAidCache.AidResolveInfo resolveInfo =
+                mRegisteredAidCache.resolveAid(NON_PAYMENT_AID_1);
         assertNull(resolveInfo.defaultService);
         assertTrue(resolveInfo.services.isEmpty());
     }
@@ -456,38 +539,41 @@ public class RegisteredAidCacheTest {
     public void testOnServicesUpdated_walletRoleEnabled() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = true;
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                true,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                true,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                true,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        true,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.onServicesUpdated(USER_ID, apduServiceInfos);
 
@@ -497,12 +583,13 @@ public class RegisteredAidCacheTest {
         assertTrue(mRegisteredAidCache.mAidServices.containsKey(NON_PAYMENT_AID_1));
         assertEquals(2, mRegisteredAidCache.mAidServices.get(PAYMENT_AID_1).size());
         assertEquals(1, mRegisteredAidCache.mAidServices.get(NON_PAYMENT_AID_1).size());
-        assertEquals(WALLET_PAYMENT_SERVICE,
-            mRegisteredAidCache.mAidServices.get(PAYMENT_AID_1).get(0).service.getComponent());
-        assertEquals(PAYMENT_SERVICE,
-            mRegisteredAidCache.mAidServices.get(PAYMENT_AID_1).get(1).service.getComponent());
-        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(),
-                eq(false));
+        assertEquals(
+                WALLET_PAYMENT_SERVICE,
+                mRegisteredAidCache.mAidServices.get(PAYMENT_AID_1).get(0).service.getComponent());
+        assertEquals(
+                PAYMENT_SERVICE,
+                mRegisteredAidCache.mAidServices.get(PAYMENT_AID_1).get(1).service.getComponent());
+        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(), eq(false));
         HashMap<String, AidRoutingManager.AidEntry> routingEntries =
                 mRoutingEntryMapCaptor.getValue();
         assertTrue(routingEntries.containsKey(NON_PAYMENT_AID_1));
@@ -515,37 +602,40 @@ public class RegisteredAidCacheTest {
     public void testOnNfcEnabled() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.generateUserApduServiceInfoLocked(USER_ID, apduServiceInfos);
         mRegisteredAidCache.generateServiceMapLocked(apduServiceInfos);
@@ -553,8 +643,7 @@ public class RegisteredAidCacheTest {
 
         verify(mAidRoutingManager).supportsAidPrefixRouting();
         verify(mAidRoutingManager).supportsAidSubsetRouting();
-        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(),
-                eq(false));
+        verify(mAidRoutingManager).configureRouting(mRoutingEntryMapCaptor.capture(), eq(false));
         assertFalse(mRegisteredAidCache.isRequiresScreenOnServiceExist());
     }
 
@@ -562,8 +651,8 @@ public class RegisteredAidCacheTest {
     public void testOnNfcDisabled() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.onNfcDisabled();
 
         verify(mAidRoutingManager).supportsAidPrefixRouting();
@@ -575,41 +664,45 @@ public class RegisteredAidCacheTest {
     public void testPollingLoopFilterToForeground_walletRoleEnabled_walletSet() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = true;
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                FOREGROUND_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        FOREGROUND_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.onWalletRoleHolderChanged(WALLET_HOLDER_PACKAGE_NAME, USER_ID);
-        mRegisteredAidCache.onPreferredForegroundServiceChanged(USER_ID, FOREGROUND_SERVICE);
+        mRegisteredAidCache.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, FOREGROUND_SERVICE));
 
         ApduServiceInfo resolvedApdu =
                 mRegisteredAidCache.resolvePollingLoopFilterConflict(apduServiceInfos);
@@ -621,38 +714,41 @@ public class RegisteredAidCacheTest {
     public void testPollingLoopFilterToWallet_walletRoleEnabled_walletSet() {
         setWalletRoleFlag(true);
         supportPrefixAndSubset(false);
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
         mRegisteredAidCache.mNfcEnabled = true;
 
         List<ApduServiceInfo> apduServiceInfos = new ArrayList<>();
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                WALLET_PAYMENT_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                FOREGROUND_SERVICE,
-                true,
-                List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
-        apduServiceInfos.add(createServiceInfoForAidRouting(
-                NON_PAYMENT_SERVICE,
-                true,
-                List.of(NON_PAYMENT_AID_1),
-                List.of(CardEmulation.CATEGORY_OTHER),
-                false,
-                false,
-                USER_ID,
-                true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        WALLET_PAYMENT_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        FOREGROUND_SERVICE,
+                        true,
+                        List.of(PAYMENT_AID_1, NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_PAYMENT, CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
+        apduServiceInfos.add(
+                createServiceInfoForAidRouting(
+                        NON_PAYMENT_SERVICE,
+                        true,
+                        List.of(NON_PAYMENT_AID_1),
+                        List.of(CardEmulation.CATEGORY_OTHER),
+                        false,
+                        false,
+                        USER_ID,
+                        true));
 
         mRegisteredAidCache.mDefaultWalletHolderPackageName = WALLET_HOLDER_PACKAGE_NAME;
 
@@ -671,10 +767,36 @@ public class RegisteredAidCacheTest {
         when(mAidRoutingManager.supportsAidSubsetRouting()).thenReturn(support);
     }
 
-    private static ApduServiceInfo createServiceInfoForAidRouting(ComponentName componentName,
+    private static ApduServiceInfo createServiceInfoForAidRouting(
+            ComponentName componentName,
+            boolean onHost,
+            List<String> aids,
+            List<String> categories,
+            boolean requiresUnlock,
+            boolean requiresScreenOn,
+            int uid,
+            boolean isCategoryOtherServiceEnabled) {
+        return createServiceInfoForAidRouting(componentName,
+                onHost,
+                aids,
+                categories,
+                requiresUnlock,
+                requiresScreenOn,
+                uid,
+                isCategoryOtherServiceEnabled,
+                false);
+    }
+
+    private static ApduServiceInfo createServiceInfoForAidRouting(
+            ComponentName componentName,
             boolean onHost,
-            List<String> aids,List<String> categories, boolean requiresUnlock, boolean requiresScreenOn,
-            int uid, boolean isCategoryOtherServiceEnabled) {
+            List<String> aids,
+            List<String> categories,
+            boolean requiresUnlock,
+            boolean requiresScreenOn,
+            int uid,
+            boolean isCategoryOtherServiceEnabled,
+            boolean shareRolePriority) {
         ApduServiceInfo apduServiceInfo = Mockito.mock(ApduServiceInfo.class);
         when(apduServiceInfo.isOnHost()).thenReturn(onHost);
         when(apduServiceInfo.getAids()).thenReturn(aids);
@@ -684,6 +806,7 @@ public class RegisteredAidCacheTest {
         when(apduServiceInfo.isCategoryOtherServiceEnabled())
                 .thenReturn(isCategoryOtherServiceEnabled);
         when(apduServiceInfo.getComponent()).thenReturn(componentName);
+        when(apduServiceInfo.shareRolePriority()).thenReturn(shareRolePriority);
         for (int i = 0; i < aids.size(); i++) {
             String aid = aids.get(i);
             String category = categories.get(i);
@@ -695,14 +818,14 @@ public class RegisteredAidCacheTest {
     @Test
     public void testGetPreferredService() {
 
-        mRegisteredAidCache = new RegisteredAidCache(mContext, mWalletRoleObserver,
-                mAidRoutingManager);
-        Pair<Integer, ComponentName> servicePair = mRegisteredAidCache.getPreferredService();
-        Assert.assertNull(servicePair.second);
-        mRegisteredAidCache.onPreferredForegroundServiceChanged(USER_ID, FOREGROUND_SERVICE);
+        mRegisteredAidCache =
+                new RegisteredAidCache(mContext, mWalletRoleObserver, mAidRoutingManager);
+        ComponentNameAndUser servicePair = mRegisteredAidCache.getPreferredService();
+        Assert.assertNull(servicePair.getComponentName());
+        mRegisteredAidCache.onPreferredForegroundServiceChanged(
+                new ComponentNameAndUser(USER_ID, FOREGROUND_SERVICE));
         servicePair = mRegisteredAidCache.getPreferredService();
-        Assert.assertNotNull(servicePair.second);
-        assertEquals(new Pair<>(USER_ID, FOREGROUND_SERVICE), servicePair);
+        Assert.assertNotNull(servicePair.getComponentName());
+        assertEquals(new ComponentNameAndUser(USER_ID, FOREGROUND_SERVICE), servicePair);
     }
-
 }
diff --git a/tests/unit/src/com/android/nfc/cardemulation/RegisteredServicesCacheTest.java b/tests/unit/src/com/android/nfc/cardemulation/RegisteredServicesCacheTest.java
index 83f3f2de..25a590ec 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/RegisteredServicesCacheTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/RegisteredServicesCacheTest.java
@@ -20,6 +20,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
@@ -116,6 +117,8 @@ public class RegisteredServicesCacheTest {
     private static final List<String> PAYMENT_AIDS = List.of("A000000004101011",
             "A000000004101012", "A000000004101013");
     private static final List<String> NON_PAYMENT_AID = List.of("F053414950454D");
+    private static final String POLLING_LOOP_FILTER1 = "filter1";
+    private static final String POLLING_LOOP_FILTER2 = "filter2";
 
     @Mock
     private Context mContext;
@@ -310,6 +313,8 @@ public class RegisteredServicesCacheTest {
         // Verify the details of service 1
         RegisteredServicesCache.DynamicSettings walletHolderSettings =
                 userServices.dynamicSettings.get(WALLET_HOLDER_SERVICE_COMPONENT);
+        assertTrue(walletHolderSettings.pollingLoopFilters.get(POLLING_LOOP_FILTER1));
+        assertFalse(walletHolderSettings.pollingLoopPatternFilters.get(POLLING_LOOP_FILTER2));
         assertEquals(OFFHOST_SE_STRING + "1", walletHolderSettings.offHostSE);
         assertEquals(1, walletHolderSettings.uid);
         assertEquals(TRUE_STRING, walletHolderSettings.shouldDefaultToObserveModeStr);
@@ -608,6 +613,8 @@ public class RegisteredServicesCacheTest {
         assertEquals(WALLET_HOLDER_SERVICE_COMPONENT,
                 readDynamicSettingsFromFile.get(USER_ID).get(1).first);
         assertEquals(newOffHostValue, dynamicSettings.offHostSE);
+        assertFalse(dynamicSettings.pollingLoopFilters.isEmpty());
+        assertFalse(dynamicSettings.pollingLoopPatternFilters.isEmpty());
     }
 
     @Test
@@ -691,6 +698,8 @@ public class RegisteredServicesCacheTest {
         assertEquals(ANOTHER_SERVICE_COMPONENT,
                 readDynamicSettingsFromFile.get(USER_ID).get(0).first);
         assertNull(dynamicSettings.offHostSE);
+        assertTrue(dynamicSettings.pollingLoopFilters.isEmpty());
+        assertTrue(dynamicSettings.pollingLoopPatternFilters.isEmpty());
     }
 
     @Test
@@ -775,6 +784,11 @@ public class RegisteredServicesCacheTest {
         assertEquals(WALLET_HOLDER_SERVICE_COMPONENT, apduServiceInfos.get(1)
                 .getComponent());
         verify(apduServiceInfos.get(1)).addPollingLoopFilter(eq(plFilter), eq(true));
+        RegisteredServicesCache.UserServices services =
+                mRegisteredServicesCache.mUserServices.get(USER_ID);
+        RegisteredServicesCache.DynamicSettings dynamicSettings = services.dynamicSettings
+                .get(WALLET_HOLDER_SERVICE_COMPONENT);
+        assertTrue(dynamicSettings.pollingLoopFilters.get(plFilter));
     }
 
     @Test
@@ -857,6 +871,11 @@ public class RegisteredServicesCacheTest {
         assertEquals(ANOTHER_SERVICE_COMPONENT, apduServiceInfos.get(0).getComponent());
         assertEquals(WALLET_HOLDER_SERVICE_COMPONENT, apduServiceInfos.get(1).getComponent());
         verify(apduServiceInfos.get(1)).addPollingLoopPatternFilter(eq(plFilter), eq(true));
+        RegisteredServicesCache.UserServices services =
+                mRegisteredServicesCache.mUserServices.get(USER_ID);
+        RegisteredServicesCache.DynamicSettings dynamicSettings = services.dynamicSettings
+                .get(WALLET_HOLDER_SERVICE_COMPONENT);
+        assertTrue(dynamicSettings.pollingLoopPatternFilters.get(plFilter));
     }
 
     @Test
diff --git a/tests/unit/src/com/android/nfc/cardemulation/RoutingOptionManagerTest.java b/tests/unit/src/com/android/nfc/cardemulation/RoutingOptionManagerTest.java
index b80e9023..3eadd0f5 100644
--- a/tests/unit/src/com/android/nfc/cardemulation/RoutingOptionManagerTest.java
+++ b/tests/unit/src/com/android/nfc/cardemulation/RoutingOptionManagerTest.java
@@ -33,7 +33,6 @@ import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
-import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
@@ -41,155 +40,170 @@ import org.mockito.quality.Strictness;
 @RunWith(AndroidJUnit4.class)
 public class RoutingOptionManagerTest {
 
-  @Mock
-  private NfcService mNfcService;
-
-  @Captor
-  private ArgumentCaptor<Integer> routeCaptor;
-
-  private static final int DEFAULT_ROUTE = 0;
-  private static final int DEFAULT_ISO_DEP_ROUTE = 1;
-  private static final int OVERRIDDEN_ISO_DEP_ROUTE = 10;
-  private static final int OVERRIDDEN_OFF_HOST_ROUTE = 20;
-  private static final int DEFAULT_OFF_HOST_ROUTE = 2;
-  private static final byte[] OFF_HOST_UICC = new byte[] {1, 2};
-  private static final byte[] OFF_HOST_ESE = new byte[] {3, 4};
-  private static final int AID_MATCHING_MODE = 3;
-
-  private static class TestRoutingOptionManager extends RoutingOptionManager {
-    @Override
-    int doGetDefaultRouteDestination() {
-      return DEFAULT_ROUTE;
+    @Mock
+    private NfcService mNfcService;
+
+    @Captor
+    private ArgumentCaptor<Integer> mRouteCaptor;
+
+    private static final int DEFAULT_ROUTE = 0;
+    private static final int DEFAULT_ISO_DEP_ROUTE = 1;
+    private static final int OVERRIDDEN_ISO_DEP_ROUTE = 10;
+    private static final int OVERRIDDEN_OFF_HOST_ROUTE = 20;
+    private static final int DEFAULT_OFF_HOST_ROUTE = 2;
+    private static final int DEFAULT_FELICA_ROUTE = 3;
+    private static final int DEFAULT_SC_ROUTE = 2;
+    private static final byte[] OFF_HOST_UICC = new byte[] {1, 2};
+    private static final byte[] OFF_HOST_ESE = new byte[] {3, 4};
+    private static final int AID_MATCHING_MODE = 3;
+
+    private static class TestRoutingOptionManager extends RoutingOptionManager {
+        @Override
+        int doGetDefaultRouteDestination() {
+            return DEFAULT_ROUTE;
+        }
+
+        @Override
+        int doGetDefaultIsoDepRouteDestination() {
+            return DEFAULT_ISO_DEP_ROUTE;
+        }
+
+        @Override
+        int doGetDefaultOffHostRouteDestination() {
+            return DEFAULT_OFF_HOST_ROUTE;
+        }
+
+        @Override
+        int doGetDefaultFelicaRouteDestination() {
+            return DEFAULT_FELICA_ROUTE;
+        }
+
+        @Override
+        int doGetDefaultScRouteDestination() {
+            return DEFAULT_SC_ROUTE;
+        }
+
+        @Override
+        byte[] doGetOffHostUiccDestination() {
+            return OFF_HOST_UICC;
+        }
+
+        @Override
+        byte[] doGetOffHostEseDestination() {
+            return OFF_HOST_ESE;
+        }
+
+        @Override
+        int doGetAidMatchingMode() {
+            return AID_MATCHING_MODE;
+        }
     }
 
-    @Override
-    int doGetDefaultIsoDepRouteDestination() {
-      return DEFAULT_ISO_DEP_ROUTE;
+    private TestRoutingOptionManager mManager;
+    private MockitoSession mStaticMockSession;
+
+    @Before
+    public void setUp() throws Exception {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .mockStatic(NfcService.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+        MockitoAnnotations.initMocks(this);
+
+        when(NfcService.getInstance()).thenReturn(mNfcService);
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testConstructor() {
+        mManager = new TestRoutingOptionManager();
+
+        assertEquals(DEFAULT_ROUTE, mManager.mDefaultRoute);
+        assertEquals(DEFAULT_ISO_DEP_ROUTE, mManager.mDefaultIsoDepRoute);
+        assertEquals(DEFAULT_OFF_HOST_ROUTE, mManager.mDefaultOffHostRoute);
+        assertEquals(DEFAULT_FELICA_ROUTE, mManager.mDefaultFelicaRoute);
+        assertEquals(OFF_HOST_UICC, mManager.mOffHostRouteUicc);
+        assertEquals(OFF_HOST_ESE, mManager.mOffHostRouteEse);
+        assertEquals(AID_MATCHING_MODE, mManager.mAidMatchingSupport);
+    }
+
+    @Test
+    public void testOverrideDefaultIsoDepRoute() {
+        mManager = new TestRoutingOptionManager();
+
+        mManager.overrideDefaultIsoDepRoute(OVERRIDDEN_ISO_DEP_ROUTE);
+
+        assertEquals(OVERRIDDEN_ISO_DEP_ROUTE, mManager.getOverrideDefaultIsoDepRoute());
+        verify(mNfcService).setIsoDepProtocolRoute(mRouteCaptor.capture());
+        assertEquals(Integer.valueOf(OVERRIDDEN_ISO_DEP_ROUTE), mRouteCaptor.getValue());
     }
 
-    @Override
-    int doGetDefaultOffHostRouteDestination() {
-      return DEFAULT_OFF_HOST_ROUTE;
+    @Test
+    public void testOverrideDefaultOffHostRoute() {
+        mManager = new TestRoutingOptionManager();
+
+        mManager.overrideDefaultOffHostRoute(OVERRIDDEN_OFF_HOST_ROUTE);
+
+        assertEquals(OVERRIDDEN_OFF_HOST_ROUTE, mManager.getOverrideDefaultOffHostRoute());
+        verify(mNfcService).setTechnologyABFRoute(mRouteCaptor.capture(), mRouteCaptor.capture());
+        assertEquals(Integer.valueOf(OVERRIDDEN_OFF_HOST_ROUTE), mRouteCaptor.getValue());
+    }
+
+    @Test
+    public void testOverrideDefaulttRoute() {
+        mManager = new TestRoutingOptionManager();
+
+        mManager.overrideDefaultRoute(OVERRIDDEN_OFF_HOST_ROUTE);
+
+        assertEquals(OVERRIDDEN_OFF_HOST_ROUTE, mManager.getOverrideDefaultRoute());
     }
 
-    @Override
-    byte[] doGetOffHostUiccDestination() {
-      return OFF_HOST_UICC;
+    @Test
+    public void testRecoverOverridedRoutingTable() {
+        mManager = new TestRoutingOptionManager();
+
+        mManager.recoverOverridedRoutingTable();
+
+        verify(mNfcService).setIsoDepProtocolRoute(anyInt());
+        verify(mNfcService).setTechnologyABFRoute(anyInt(), anyInt());
+        assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, mManager.mOverrideDefaultRoute);
+        assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, mManager.mOverrideDefaultIsoDepRoute);
+        assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, mManager.mOverrideDefaultOffHostRoute);
     }
 
-    @Override
-    byte[] doGetOffHostEseDestination() {
-      return OFF_HOST_ESE;
+    @Test
+    public void testGetters() {
+        mManager = new TestRoutingOptionManager();
+
+        int overrideDefaultRoute = mManager.getOverrideDefaultRoute();
+        int defaultRoute = mManager.getDefaultRoute();
+        int defaultIsoDepRoute = mManager.getDefaultIsoDepRoute();
+        int defaultOffHostRoute = mManager.getDefaultOffHostRoute();
+        int defaultFelicaRoute = mManager.getDefaultFelicaRoute();
+        byte[] offHostRouteUicc = mManager.getOffHostRouteUicc();
+        byte[] offHostRouteEse = mManager.getOffHostRouteEse();
+        int aidMatchingSupport = mManager.getAidMatchingSupport();
+
+        assertEquals(-1, overrideDefaultRoute);
+        assertEquals(DEFAULT_ROUTE, defaultRoute);
+        assertEquals(DEFAULT_ISO_DEP_ROUTE, defaultIsoDepRoute);
+        assertEquals(DEFAULT_OFF_HOST_ROUTE, defaultOffHostRoute);
+        assertEquals(DEFAULT_FELICA_ROUTE, defaultFelicaRoute);
+        assertEquals(OFF_HOST_UICC, offHostRouteUicc);
+        assertEquals(OFF_HOST_ESE, offHostRouteEse);
+        assertEquals(AID_MATCHING_MODE, aidMatchingSupport);
     }
 
-    @Override
-    int doGetAidMatchingMode() {
-      return AID_MATCHING_MODE;
+    @Test
+    public void testIsRoutingTableOverrided() {
+        mManager = new TestRoutingOptionManager();
+
+        boolean result = mManager.isRoutingTableOverrided();
+
+        assertFalse(result);
     }
-  }
-
-  private TestRoutingOptionManager manager;
-  private MockitoSession mStaticMockSession;
-
-  @Before
-  public void setUp() throws Exception {
-    mStaticMockSession = ExtendedMockito.mockitoSession()
-        .mockStatic(NfcService.class)
-        .strictness(Strictness.LENIENT)
-        .startMocking();
-    MockitoAnnotations.initMocks(this);
-
-    when(NfcService.getInstance()).thenReturn(mNfcService);
-  }
-
-  @After
-  public void tearDown() {
-    mStaticMockSession.finishMocking();
-  }
-
-  @Test
-  public void testConstructor() {
-    manager = new TestRoutingOptionManager();
-
-    assertEquals(DEFAULT_ROUTE, manager.mDefaultRoute);
-    assertEquals(DEFAULT_ISO_DEP_ROUTE, manager.mDefaultIsoDepRoute);
-    assertEquals(DEFAULT_OFF_HOST_ROUTE, manager.mDefaultOffHostRoute);
-    assertEquals(OFF_HOST_UICC, manager.mOffHostRouteUicc);
-    assertEquals(OFF_HOST_ESE, manager.mOffHostRouteEse);
-    assertEquals(AID_MATCHING_MODE, manager.mAidMatchingSupport);
-  }
-
-  @Test
-  public void testOverrideDefaultIsoDepRoute() {
-    manager = new TestRoutingOptionManager();
-
-    manager.overrideDefaultIsoDepRoute(OVERRIDDEN_ISO_DEP_ROUTE);
-
-    assertEquals(OVERRIDDEN_ISO_DEP_ROUTE, manager.getOverrideDefaultIsoDepRoute());
-    verify(mNfcService).setIsoDepProtocolRoute(routeCaptor.capture());
-    assertEquals(Integer.valueOf(OVERRIDDEN_ISO_DEP_ROUTE), routeCaptor.getValue());
-  }
-
-  @Test
-  public void testOverrideDefaultOffHostRoute() {
-    manager = new TestRoutingOptionManager();
-
-    manager.overrideDefaultOffHostRoute(OVERRIDDEN_OFF_HOST_ROUTE);
-
-    assertEquals(OVERRIDDEN_OFF_HOST_ROUTE, manager.getOverrideDefaultOffHostRoute());
-    verify(mNfcService).setTechnologyABFRoute(routeCaptor.capture());
-    assertEquals(Integer.valueOf(OVERRIDDEN_OFF_HOST_ROUTE), routeCaptor.getValue());
-  }
-
-  @Test
-  public void testOverrideDefaulttRoute() {
-    manager = new TestRoutingOptionManager();
-
-    manager.overrideDefaultRoute(OVERRIDDEN_OFF_HOST_ROUTE);
-
-    assertEquals(OVERRIDDEN_OFF_HOST_ROUTE, manager.getOverrideDefaultRoute());
-  }
-
-  @Test
-  public void testRecoverOverridedRoutingTable() {
-    manager = new TestRoutingOptionManager();
-
-    manager.recoverOverridedRoutingTable();
-
-    verify(mNfcService).setIsoDepProtocolRoute(anyInt());
-    verify(mNfcService).setTechnologyABFRoute(anyInt());
-    assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, manager.mOverrideDefaultRoute);
-    assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, manager.mOverrideDefaultIsoDepRoute);
-    assertEquals(RoutingOptionManager.ROUTE_UNKNOWN, manager.mOverrideDefaultOffHostRoute);
-  }
-
-  @Test
-  public void testGetters() {
-    manager = new TestRoutingOptionManager();
-
-    int overrideDefaultRoute = manager.getOverrideDefaultRoute();
-    int defaultRoute = manager.getDefaultRoute();
-    int defaultIsoDepRoute = manager.getDefaultIsoDepRoute();
-    int defaultOffHostRoute = manager.getDefaultOffHostRoute();
-    byte[] offHostRouteUicc = manager.getOffHostRouteUicc();
-    byte[] offHostRouteEse = manager.getOffHostRouteEse();
-    int aidMatchingSupport = manager.getAidMatchingSupport();
-
-    assertEquals(-1, overrideDefaultRoute);
-    assertEquals(DEFAULT_ROUTE, defaultRoute);
-    assertEquals(DEFAULT_ISO_DEP_ROUTE, defaultIsoDepRoute);
-    assertEquals(DEFAULT_OFF_HOST_ROUTE, defaultOffHostRoute);
-    assertEquals(OFF_HOST_UICC, offHostRouteUicc);
-    assertEquals(OFF_HOST_ESE, offHostRouteEse);
-    assertEquals(AID_MATCHING_MODE, aidMatchingSupport);
-  }
-
-  @Test
-  public void testIsRoutingTableOverrided() {
-    manager = new TestRoutingOptionManager();
-
-    boolean result = manager.isRoutingTableOverrided();
-
-    assertFalse(result);
-  }
 }
diff --git a/tests/unit/src/com/android/nfc/cardemulation/util/NfcFileUtilsTest.java b/tests/unit/src/com/android/nfc/cardemulation/util/NfcFileUtilsTest.java
new file mode 100644
index 00000000..da8486f5
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/cardemulation/util/NfcFileUtilsTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.cardemulation.util;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.content.pm.PackageManager;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+@RunWith(AndroidJUnit4.class)
+public class NfcFileUtilsTest {
+
+    private MockitoSession mStaticMockSession;
+
+    @Before
+    public void setUp() throws PackageManager.NameNotFoundException {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .mockStatic(Files.class)
+                .strictness(Strictness.LENIENT)
+                .startMocking();
+
+        MockitoAnnotations.initMocks(this);
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+
+    @Test
+    public void testIsEmptyDir() {
+        File fileDir = mock(File.class);
+        File file = mock(File.class);
+        when(fileDir.listFiles()).thenReturn(new File[]{file});
+        boolean isEmptyDir = NfcFileUtils.isEmptyDir(fileDir);
+        assertThat(isEmptyDir).isFalse();
+    }
+
+    @Test
+    public void testMoveFiles() throws IOException {
+        File sourceDir = mock(File.class);
+        File file = mock(File.class);
+        when(file.getName()).thenReturn("test");
+        when(sourceDir.listFiles()).thenReturn(new File[]{file});
+        File targetDir = new File("test");
+        when(sourceDir.toPath()).thenReturn(mock(Path.class));
+        when(Files.move(any(), any(), any())).thenReturn(mock(Path.class));
+        int result = NfcFileUtils.moveFiles(sourceDir, targetDir);
+        assertThat(result).isEqualTo(1);
+
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/handover/BluetoothPeripheralHandoverTest.java b/tests/unit/src/com/android/nfc/handover/BluetoothPeripheralHandoverTest.java
new file mode 100644
index 00000000..ae120347
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/handover/BluetoothPeripheralHandoverTest.java
@@ -0,0 +1,838 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.handover;
+
+import static com.android.nfc.handover.BluetoothPeripheralHandover.ACTION_ALLOW_CONNECT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.ACTION_CONNECT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.ACTION_DENY_CONNECT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.ACTION_DISCONNECT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.ACTION_INIT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.RESULT_CONNECTED;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.RESULT_DISCONNECTED;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.RESULT_PENDING;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_BONDING;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_COMPLETE;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_CONNECTING;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_DISCONNECTING;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_INIT;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_INIT_COMPLETE;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_WAITING_FOR_BOND_CONFIRMATION;
+import static com.android.nfc.handover.BluetoothPeripheralHandover.STATE_WAITING_FOR_PROXIES;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothClass;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothHeadset;
+import android.bluetooth.BluetoothHidHost;
+import android.bluetooth.BluetoothProfile;
+import android.bluetooth.BluetoothUuid;
+import android.bluetooth.OobData;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.media.AudioManager;
+import android.os.ParcelUuid;
+import android.provider.Settings;
+import android.widget.Toast;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+import java.util.Collections;
+
+@RunWith(AndroidJUnit4.class)
+public class BluetoothPeripheralHandoverTest {
+
+    @Mock
+    BluetoothPeripheralHandover mBluetoothPeripheralHandover;
+    @Mock
+    private Context mockContext;
+    @Mock
+    private BluetoothDevice mockDevice;
+    @Mock
+    private BluetoothAdapter mockBluetoothAdapter;
+    @Mock
+    private AudioManager mockAudioManager;
+    @Mock
+    private ContentResolver mockContentResolver;
+    @Mock
+    private BluetoothClass mockBtClass;
+    @Mock
+    private BluetoothPeripheralHandover.Callback mockCallback;
+    @Mock
+    private BluetoothHidHost mockInput;
+    @Mock
+    private Toast mockToast;
+    @Mock
+    OobData mockOobData;
+    @Mock
+    private Resources mockResources;
+    @Mock
+    BluetoothHeadset mockHeadset;
+    @Mock
+    Intent mockIntent;
+    @Mock
+    BluetoothA2dp mockA2dp;
+    private MockitoSession mStaticMockSession;
+    BluetoothPeripheralHandover bluetoothPeripheralHandover;
+
+    @Before
+    public void setUp() {
+        mStaticMockSession = ExtendedMockito.mockitoSession().mockStatic(
+                Settings.Global.class).mockStatic(Toast.class).strictness(
+                Strictness.LENIENT).startMocking();
+        MockitoAnnotations.initMocks(this);
+        when(mockContext.getSystemService(AudioManager.class)).thenReturn(mockAudioManager);
+        when(mockContext.getContentResolver()).thenReturn(mockContentResolver);
+        when(mockContext.getResources()).thenReturn(mockResources);
+        when(Toast.makeText(any(), anyString(), anyInt())).thenReturn(mockToast);
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_LE);
+    }
+
+    private BluetoothPeripheralHandover createBluetoothPerHandOvrInstance(int transport) {
+        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
+
+            ParcelUuid[] testUuids = new ParcelUuid[]{};
+            boolean testHasHeadsetCapability = true;
+            boolean testHasA2dpCapability = true;
+
+            when(mBluetoothPeripheralHandover.hasHeadsetCapability(testUuids,
+                    mockBtClass)).thenReturn(testHasHeadsetCapability);
+            when(mBluetoothPeripheralHandover.hasA2dpCapability(testUuids, mockBtClass)).thenReturn(
+                    testHasA2dpCapability);
+            when(Settings.Global.getInt(mockContentResolver, Settings.Global.DEVICE_PROVISIONED,
+                    0)).thenReturn(0);
+
+            bluetoothPeripheralHandover = new BluetoothPeripheralHandover(mockContext, mockDevice,
+                    "Test Device", transport, mockOobData, new ParcelUuid[]{}, mockBtClass,
+                    mockCallback, mockBluetoothAdapter);
+        });
+        return bluetoothPeripheralHandover;
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testComplete() {
+        bluetoothPeripheralHandover.complete(true);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(true);
+    }
+
+    @Test
+    public void testComplete_mA2dp() {
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.complete(true);
+
+        assertNull(bluetoothPeripheralHandover.mA2dp);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(true);
+    }
+
+    @Test
+    public void testComplete_mInput() {
+        bluetoothPeripheralHandover.mInput = mockInput;
+        bluetoothPeripheralHandover.complete(true);
+
+        assertNull(bluetoothPeripheralHandover.mInput);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(true);
+    }
+
+    @Test
+    public void testComplete_mHeadset() {
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.complete(true);
+
+        assertNull(bluetoothPeripheralHandover.mHeadset);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_INIT_COMPLETE() {
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(STATE_WAITING_FOR_BOND_CONFIRMATION, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_INIT_COMPLETE_TRANSPORT_LE() {
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDED);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(STATE_WAITING_FOR_BOND_CONFIRMATION, bluetoothPeripheralHandover.mState);
+        verify(mockDevice).removeBond();
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_WAITING_FOR_BOND_CONFIRMATION() {
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_BOND_CONFIRMATION;
+        bluetoothPeripheralHandover.mRetryCount = 1;
+        bluetoothPeripheralHandover.mOobData = null;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+        when(mockDevice.createBond(anyInt())).thenReturn(true);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(STATE_BONDING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_RETRY_CONNECT_WAIT_TIME_MS() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        bluetoothPeripheralHandover.mIsHeadsetAvailable = true;
+        bluetoothPeripheralHandover.mIsA2dpAvailable = true;
+        bluetoothPeripheralHandover.mRetryCount = 1;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTING);
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTING);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(STATE_CONNECTING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_mRetryCount_Zero() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        bluetoothPeripheralHandover.mIsHeadsetAvailable = true;
+        bluetoothPeripheralHandover.mIsA2dpAvailable = true;
+        bluetoothPeripheralHandover.mRetryCount = 0;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTING);
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTING);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(STATE_CONNECTING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_TRANSPORT_LE_STATE_CONNECTING() {
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTING);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHidResult);
+        assertEquals(STATE_CONNECTING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_TRANSPORT_LE_STATE_CONNECTED() {
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mHidResult);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(anyBoolean());
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_notTRANSPORT_LE_HeadsetNotAvailable() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        bluetoothPeripheralHandover.mIsHeadsetAvailable = false;
+        bluetoothPeripheralHandover.mIsA2dpAvailable = false;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTING);
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTING);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_BONDING_notTRANSPORT_LE_STATE_CONNECTED() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTED);
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepConnect_STATE_CONNECTING_TRANSPORT_LE_RESULT_DISCONNECTED() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        bluetoothPeripheralHandover.mHidResult = RESULT_DISCONNECTED;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepConnect();
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(anyBoolean());
+    }
+
+    @Test
+    public void testHasA2dpCapability_withUuidsContainingA2dpSink() {
+        ParcelUuid[] uuids = new ParcelUuid[]{BluetoothUuid.A2DP_SINK};
+        boolean result = bluetoothPeripheralHandover.hasA2dpCapability(uuids, null);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasA2dpCapability_withUuidsContainingAdvAudioDist() {
+        ParcelUuid[] uuids = new ParcelUuid[]{BluetoothUuid.ADV_AUDIO_DIST};
+
+        boolean result = bluetoothPeripheralHandover.hasA2dpCapability(uuids, null);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasA2dpCapability_withBluetoothClassMatchingA2dp() {
+        BluetoothClass mockBtClass = mock(BluetoothClass.class);
+        when(mockBtClass.doesClassMatch(BluetoothClass.PROFILE_A2DP)).thenReturn(true);
+
+        boolean result = bluetoothPeripheralHandover.hasA2dpCapability(null, mockBtClass);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasA2dpCapability_withNoUuidsAndNonMatchingBluetoothClass() {
+        BluetoothClass mockBtClass = mock(BluetoothClass.class);
+        when(mockBtClass.doesClassMatch(BluetoothClass.PROFILE_A2DP)).thenReturn(false);
+
+        boolean result = bluetoothPeripheralHandover.hasA2dpCapability(null, mockBtClass);
+        assertFalse(result);
+    }
+
+    @Test
+    public void testHasHeadsetCapability_withUuidsContainingHfp() {
+        ParcelUuid[] uuids = new ParcelUuid[]{BluetoothUuid.HFP};
+
+        boolean result = bluetoothPeripheralHandover.hasHeadsetCapability(uuids, null);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasHeadsetCapability_withUuidsContainingHsp() {
+        ParcelUuid[] uuids = new ParcelUuid[]{BluetoothUuid.HSP};
+
+        boolean result = bluetoothPeripheralHandover.hasHeadsetCapability(uuids, null);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasHeadsetCapability_withNoMatchingUuids() {
+        ParcelUuid[] uuids = new ParcelUuid[]{ParcelUuid.fromString(
+                "0000110D-0000-1000-8000-00805F9B34FB")}; // Some other UUID
+
+        boolean result = bluetoothPeripheralHandover.hasHeadsetCapability(uuids, null);
+        assertFalse(result);
+    }
+
+    @Test
+    public void testHasHeadsetCapability_withBluetoothClassMatchingHeadset() {
+        BluetoothClass mockBtClass = mock(BluetoothClass.class);
+        when(mockBtClass.doesClassMatch(BluetoothClass.PROFILE_HEADSET)).thenReturn(true);
+
+        boolean result = bluetoothPeripheralHandover.hasHeadsetCapability(null, mockBtClass);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasHeadsetCapability_withNoUuidsAndNonMatchingBluetoothClass() {
+        BluetoothClass mockBtClass = mock(BluetoothClass.class);
+        when(mockBtClass.doesClassMatch(BluetoothClass.PROFILE_HEADSET)).thenReturn(false);
+
+        boolean result = bluetoothPeripheralHandover.hasHeadsetCapability(null, mockBtClass);
+        assertFalse(result);
+    }
+
+    @Test
+    public void testGetProfileProxys_withTransportLE_success() {
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.HID_HOST))).thenReturn(true);
+
+        boolean result = bluetoothPeripheralHandover.getProfileProxys();
+        assertTrue(result);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.HID_HOST);
+    }
+
+    @Test
+    public void testGetProfileProxys_withTransportLE_failure() {
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.HID_HOST))).thenReturn(false);
+
+        boolean result = bluetoothPeripheralHandover.getProfileProxys();
+        assertFalse(result);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.HID_HOST);
+    }
+
+    @Test
+    public void testGetProfileProxys_withClassicTransport_success() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.HEADSET))).thenReturn(true);
+
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.A2DP))).thenReturn(true);
+
+        boolean result = bluetoothPeripheralHandover.getProfileProxys();
+        assertTrue(result);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.HEADSET);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.A2DP);
+    }
+
+    @Test
+    public void testGetProfileProxys_withClassicTransport_failureInHeadset() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.HEADSET))).thenReturn(false);
+
+        boolean result = bluetoothPeripheralHandover.getProfileProxys();
+        assertFalse(result);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.HEADSET);
+        verify(mockBluetoothAdapter, never()).getProfileProxy(mockContext,
+                bluetoothPeripheralHandover, BluetoothProfile.A2DP);
+    }
+
+    @Test
+    public void testGetProfileProxys_withClassicTransport_failureInA2dp() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.HEADSET))).thenReturn(true);
+        when(mockBluetoothAdapter.getProfileProxy(eq(mockContext), eq(bluetoothPeripheralHandover),
+                eq(BluetoothProfile.A2DP))).thenReturn(false);
+        boolean result = bluetoothPeripheralHandover.getProfileProxys();
+
+        assertFalse(result);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.HEADSET);
+        verify(mockBluetoothAdapter).getProfileProxy(mockContext, bluetoothPeripheralHandover,
+                BluetoothProfile.A2DP);
+    }
+
+    @Test
+    public void testNextStep_NextStepInit() {
+        bluetoothPeripheralHandover.mAction = ACTION_INIT;
+        bluetoothPeripheralHandover.mA2dp = null;
+        bluetoothPeripheralHandover.mState = STATE_INIT;
+
+        bluetoothPeripheralHandover.nextStep();
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStep_ACTION_CONNECT() {
+        bluetoothPeripheralHandover.mAction = ACTION_CONNECT;
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+
+        bluetoothPeripheralHandover.nextStep();
+        assertEquals(STATE_WAITING_FOR_BOND_CONFIRMATION, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStep_NextStepDisconnect() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mAction = ACTION_DISCONNECT;
+        bluetoothPeripheralHandover.mState = STATE_DISCONNECTING;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        bluetoothPeripheralHandover.mHidResult = RESULT_CONNECTED;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_DISCONNECTED);
+
+        bluetoothPeripheralHandover.nextStep();
+        assertEquals(STATE_DISCONNECTING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testHandleIntent_ACTION_PAIRING_REQUEST() {
+        when(mockIntent.getAction()).thenReturn(BluetoothDevice.ACTION_PAIRING_REQUEST);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        verify(mockDevice).setPairingConfirmation(true);
+        assertTrue(bluetoothPeripheralHandover.mShouldAbortBroadcast);
+    }
+
+    @Test
+    public void testHandleIntent_ACTION_ALLOW_CONNECT() {
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+        when(mockIntent.getAction()).thenReturn(ACTION_ALLOW_CONNECT);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(STATE_WAITING_FOR_BOND_CONFIRMATION, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testHandleIntent_ACTION_DENY_CONNECT() {
+        when(mockIntent.getAction()).thenReturn(ACTION_DENY_CONNECT);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(false);
+    }
+
+    @Test
+    public void testHandleIntentHidHostStateChangedToBluetoothConnected() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mHidResult);
+    }
+
+    @Test
+    public void testHandleIntentHidHostStateChangedToBluetoothDisconnected() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mHidResult);
+    }
+
+    @Test
+    public void testHandleIntent_A2dpACTION_CONNECTION_STATE_CHANGED_BLUETOOTH_STATE_CONNECTED() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mA2dpResult);
+    }
+
+    //STATE_DISCONNECTED
+    @Test
+    public void testHandleIntentA2dpStateChangedToBluetoothDisconnected() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mA2dpResult);
+    }
+
+    @Test
+    public void testHandleIntentHeadsetStateChangedToBluetoothConnected() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_CONNECTED, bluetoothPeripheralHandover.mHfpResult);
+    }
+
+    @Test
+    public void testHandleIntentHeadsetStateChangedToBluetoothDisconnected() {
+        bluetoothPeripheralHandover.mState = STATE_CONNECTING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothProfile.EXTRA_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mHfpResult);
+    }
+
+    @Test
+    public void testHandleIntent_BluetoothDevice_ACTION_BOND_STATE_CHANGED_STATE_BONDING() {
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.BOND_BONDED);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(0, bluetoothPeripheralHandover.mRetryCount);
+    }
+
+    @Test
+    public void testHandleBondStateChangedToBondingAndBondNone() {
+        bluetoothPeripheralHandover.mState = STATE_BONDING;
+        when(mockIntent.getAction()).thenReturn(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
+        when(mockIntent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)).thenReturn(mockDevice);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.PAIRING_VARIANT_CONSENT);
+        when(mockIntent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,
+                BluetoothDevice.ERROR)).thenReturn(BluetoothDevice.BOND_NONE);
+
+        bluetoothPeripheralHandover.handleIntent(mockIntent);
+        assertEquals(0, bluetoothPeripheralHandover.mRetryCount);
+    }
+
+    @Test
+    public void testNextStepInit_STATE_WAITING_FOR_PROXIES_ACTION_DISCONNECT() {
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_PROXIES;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+
+        bluetoothPeripheralHandover.nextStepInit();
+        assertEquals(ACTION_CONNECT, bluetoothPeripheralHandover.mAction);
+    }
+
+    @Test
+    public void testNextStepInit_STATE_WAITING_FOR_PROXIES_BlDeviceNonTRANSPORT_LE_COMPLETE() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_PROXIES;
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mInput = mockInput;
+
+        when(mockHeadset.getConnectionPolicy(mockDevice)).thenReturn(
+                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
+        when(mockA2dp.getConnectionPolicy(mockDevice)).thenReturn(
+                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
+
+        bluetoothPeripheralHandover.nextStepInit();
+        assertNull(bluetoothPeripheralHandover.mA2dp);
+        assertNull(bluetoothPeripheralHandover.mHeadset);
+        assertNull(bluetoothPeripheralHandover.mInput);
+        verify(mockCallback).onBluetoothPeripheralHandoverComplete(false);
+    }
+
+    @Test
+    public void testNextStepInit_STATE_WAITING_FOR_PROXIES_BlDeviceNonTRANSPORT_LE_ACTION_CONNECT() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_PROXIES;
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockHeadset.getConnectionPolicy(mockDevice)).thenReturn(
+                BluetoothProfile.CONNECTION_POLICY_FORBIDDEN);
+        when(mockA2dp.getConnectionPolicy(mockDevice)).thenReturn(
+                BluetoothProfile.CONNECTION_POLICY_ALLOWED);
+
+        bluetoothPeripheralHandover.nextStepInit();
+        assertEquals(ACTION_CONNECT, bluetoothPeripheralHandover.mAction);
+    }
+
+    @Test
+    public void testNextStepInitWaitingForProxiesTransportLeDisconnect() {
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_PROXIES;
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockInput.getConnectedDevices()).thenReturn(Collections.singletonList(mockDevice));
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepInit();
+        assertEquals(ACTION_DISCONNECT, bluetoothPeripheralHandover.mAction);
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHidResult);
+        verify(mockDevice).disconnect();
+    }
+
+    @Test
+    public void testNextStepInit_STATE_WAITING_FOR_PROXIES_BlDeviceTRANSPORT_LE_ACTION_CONNECT() {
+        bluetoothPeripheralHandover.mState = STATE_WAITING_FOR_PROXIES;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockDevice.getBondState()).thenReturn(BluetoothDevice.BOND_BONDING);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepInit();
+        assertEquals(ACTION_CONNECT, bluetoothPeripheralHandover.mAction);
+        assertEquals(STATE_WAITING_FOR_BOND_CONFIRMATION, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testHasStarted() {
+        bluetoothPeripheralHandover.mState = STATE_INIT;
+
+        assertFalse(bluetoothPeripheralHandover.hasStarted());
+    }
+
+    @Test
+    public void testStartBonding_STATE_BONDING() {
+        bluetoothPeripheralHandover.mOobData = mockOobData;
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+        when(mockDevice.createBondOutOfBand(bluetoothPeripheralHandover.mTransport, null,
+                mockOobData)).thenReturn(false);
+
+        bluetoothPeripheralHandover.startBonding();
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testStartBonding_STATE_BONDING_oobDataNull() {
+        bluetoothPeripheralHandover.mOobData = null;
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+        when(mockDevice.createBond(bluetoothPeripheralHandover.mTransport)).thenReturn(false);
+
+        bluetoothPeripheralHandover.startBonding();
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepDisconnect_STATE_INIT_COMPLETE_TRANSPORT_LE_STATE_CONNECTED() {
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepDisconnect();
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHidResult);
+    }
+
+    @Test
+    public void testNextStepDisconnect_STATE_INIT_COMPLETE_TRANSPORT_LE_STATE_DISCONNECTED() {
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        bluetoothPeripheralHandover.mInput = mockInput;
+        when(mockInput.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_DISCONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepDisconnect();
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mHidResult);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepDisconnect_STATE_INIT_COMPLETE_Not_TRANSPORT_LE_STATE_CONNECTED() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_CONNECTED);
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(BluetoothProfile.STATE_CONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepDisconnect();
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(RESULT_PENDING, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(STATE_DISCONNECTING, bluetoothPeripheralHandover.mState);
+    }
+
+    @Test
+    public void testNextStepDisconnect_STATE_INIT_COMPLETE_Not_TRANSPORT_LE_STATE_DISCONNECTED() {
+        bluetoothPeripheralHandover = createBluetoothPerHandOvrInstance(
+                BluetoothDevice.TRANSPORT_AUTO);
+        bluetoothPeripheralHandover.mState = STATE_INIT_COMPLETE;
+        bluetoothPeripheralHandover.mHeadset = mockHeadset;
+        bluetoothPeripheralHandover.mA2dp = mockA2dp;
+        when(mockHeadset.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_DISCONNECTED);
+        when(mockA2dp.getConnectionState(mockDevice)).thenReturn(
+                BluetoothProfile.STATE_DISCONNECTED);
+        when(Toast.makeText(mockContext, eq(any()), anyInt())).thenReturn(mockToast);
+
+        bluetoothPeripheralHandover.nextStepDisconnect();
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mA2dpResult);
+        assertEquals(RESULT_DISCONNECTED, bluetoothPeripheralHandover.mHfpResult);
+        assertEquals(STATE_COMPLETE, bluetoothPeripheralHandover.mState);
+    }
+}
diff --git a/tests/unit/src/com/android/nfc/handover/HandoverDataParserTest.java b/tests/unit/src/com/android/nfc/handover/HandoverDataParserTest.java
new file mode 100644
index 00000000..fecbf8cb
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/handover/HandoverDataParserTest.java
@@ -0,0 +1,493 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.handover;
+
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.nfc.NdefMessage;
+import android.nfc.NdefRecord;
+
+import com.android.nfc.handover.HandoverDataParser.BluetoothHandoverData;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+
+public class HandoverDataParserTest {
+    @Mock
+    private BluetoothAdapter mBluetoothAdapter;
+    @Mock
+    private NdefMessage mNdefMessage;
+    @Mock
+    private NdefRecord mNdefRecord;
+    @Mock
+    private BluetoothDevice mBluetoothDevice;
+    @Mock
+    private HandoverDataParser mockHandoverDataParser;
+    private HandoverDataParser mHandoverDataParser;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        when(mNdefMessage.getRecords()).thenReturn(new NdefRecord[]{mNdefRecord});
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        mHandoverDataParser = new HandoverDataParser(mBluetoothAdapter) {
+            @Override
+            boolean isCarrierActivating(NdefRecord handoverRec, byte[] carrierId) {
+                return true;
+            }
+        };
+    }
+
+    @Test
+    public void testCreateCollisionRecord() {
+        NdefRecord result = HandoverDataParser.createCollisionRecord();
+        assertNotNull(result);
+        assertEquals(NdefRecord.TNF_WELL_KNOWN, result.getTnf());
+    }
+
+    @Test
+    public void testIsHandoverSupportedAdapterAvailable() {
+        assertTrue(mHandoverDataParser.isHandoverSupported());
+    }
+
+    @Test
+    public void testCreateBluetoothAlternateCarrierRecord() {
+        NdefRecord ndefRecord = mHandoverDataParser.createBluetoothAlternateCarrierRecord(true);
+        byte[] payload = ndefRecord.getPayload();
+        assertNotNull(ndefRecord);
+        assertEquals(1, payload[1]);
+    }
+
+    @Test
+    public void testCreateHandoverRequestRecord() {
+        NdefRecord ndefRecord = mHandoverDataParser.createHandoverRequestRecord();
+        byte[] payload = ndefRecord.getPayload();
+        assertNotNull(ndefRecord);
+        assertArrayEquals(NdefRecord.RTD_HANDOVER_REQUEST, ndefRecord.getType());
+        assertEquals((byte) 0x12, payload[0]);
+    }
+
+    @Test
+    public void testIsHandoverNotSupported() {
+        mHandoverDataParser = new HandoverDataParser(null);
+        assertFalse(mHandoverDataParser.isHandoverSupported());
+    }
+
+    @Test
+    public void testCreateHandoverSelectRecord() {
+        NdefRecord alternateCarrier = mHandoverDataParser.createBluetoothAlternateCarrierRecord
+                (true);
+        NdefRecord result = mHandoverDataParser.createHandoverSelectRecord(alternateCarrier);
+        byte[] payload = result.getPayload();
+        assertNotNull(result);
+        assertEquals((byte) 0x12, payload[0]);
+    }
+
+    @Test
+    public void testParseNokiaValidPayload() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        String deviceName = "NokiaDevice";
+        ByteBuffer payload = ByteBuffer.allocate(30);
+        payload.put((byte) 0);
+        payload.position(1);
+        payload.put(macAddress);
+        payload.position(14);
+        payload.put((byte) deviceName.length());
+        payload.put(deviceName.getBytes(StandardCharsets.UTF_8));
+        payload.flip();
+        BluetoothHandoverData result = mHandoverDataParser.parseNokia(payload);
+        assertTrue(result.valid);
+        assertEquals(deviceName, result.name);
+    }
+
+    @Test
+    public void testParseNokiaWithInvalidBluetoothAddress() {
+        byte[] invalidMacAddress = new byte[]{(byte) 0xFF};
+        ByteBuffer payload = ByteBuffer.allocate(24);
+        payload.put((byte) 0x00);
+        payload.put(invalidMacAddress);
+        payload.flip();
+        BluetoothHandoverData result = mHandoverDataParser.parseNokia(payload);
+        assertFalse(result.valid);
+        assertNull(result.device);
+        assertNull(result.name);
+    }
+
+    @Test
+    public void testParseNokiaWithShortPayload() {
+        ByteBuffer payload = ByteBuffer.allocate(10);
+        payload.put((byte) 0x00);
+        payload.flip();
+        BluetoothHandoverData result = mHandoverDataParser.parseNokia(payload);
+        assertFalse(result.valid);
+        assertNull(result.device);
+        assertNull(result.name);
+    }
+
+    @Test
+    public void testParseBtOobValidShortName() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        String deviceName = "TestDevice";
+        ByteBuffer payload = ByteBuffer.allocate(20);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) (deviceName.length() + 1));
+        payload.put((byte) 0x08);
+        payload.put(deviceName.getBytes(StandardCharsets.UTF_8));
+        payload.flip();
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(payload);
+        assertTrue(result.valid);
+        assertEquals(deviceName, result.name);
+    }
+
+    @Test
+    public void testParseBtOobWithEmptyPayload() {
+        ByteBuffer emptyPayload = ByteBuffer.allocate(2);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(
+                emptyPayload);
+        assertFalse(result.valid);
+        assertNull(result.device);
+        assertNull(result.name);
+    }
+
+    @Test
+    public void testParseBtOobWithInvalidPayload() {
+        ByteBuffer invalidPayload = ByteBuffer.allocate(10);
+        invalidPayload.put((byte) 0x00);
+        invalidPayload.put((byte) 0x00);
+        invalidPayload.flip();
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(
+                invalidPayload);
+        assertFalse(result.valid);
+        assertNull(result.device);
+        assertNull(result.name);
+    }
+
+    @Test
+    public void testParseBtOobWithLongLocalName() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        String deviceName = "TestLongDeviceName";
+        ByteBuffer payload = ByteBuffer.allocate(30);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) (deviceName.length() + 1));
+        payload.put((byte) 0x09);
+        payload.put(deviceName.getBytes(StandardCharsets.UTF_8));
+        payload.flip();
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(payload);
+        assertTrue(result.valid);
+        assertEquals(deviceName, result.name);
+    }
+
+    @Test
+    public void testParseBtOobWith16BitUuidsPartial() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        ByteBuffer payload = ByteBuffer.allocate(20);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) 3);
+        payload.put((byte) 0x02);
+        payload.put((byte) 0x12);
+        payload.put((byte) 0x34);
+        payload.flip();
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(payload);
+        assertTrue(result.valid);
+        assertNotNull(result.uuids);
+        assertEquals(1, result.uuids.length);
+    }
+
+    @Test
+    public void testParseBtOobWithClassOfDevice() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        ByteBuffer payload = ByteBuffer.allocate(20);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) 4);
+        payload.put((byte) 0x0D);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x1F);
+        payload.put((byte) 0x00);
+        payload.flip();
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(payload);
+        assertTrue(result.valid);
+        assertNotNull(result.btClass);
+    }
+
+    @Test
+    public void testParseBtOobWithUnknownType() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        ByteBuffer payload = ByteBuffer.allocate(20);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) 3);
+        payload.put((byte) 0xFF);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.flip();
+        when(mBluetoothAdapter.getRemoteDevice(macAddress)).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBtOob(payload);
+        assertTrue(result.valid);
+        assertEquals("", result.name);
+        assertNull(result.uuids);
+        assertNull(result.btClass);
+    }
+
+    @Test
+    public void testParseBleOobWithMacAddress() {
+        when(mBluetoothAdapter.getRemoteDevice(any(byte[].class))).thenReturn(mBluetoothDevice);
+        BluetoothHandoverData result = mHandoverDataParser.parseBleOob(blePayload());
+        assertNotNull(result);
+        assertTrue(result.valid);
+        assertNotNull(result.device);
+        assertEquals(mBluetoothDevice, result.device);
+        verify(mBluetoothAdapter).getRemoteDevice(any(byte[].class));
+    }
+
+    @Test
+    public void testParseBleOobWithCentralRoleOnly() {
+        ByteBuffer payload = ByteBuffer.allocate(10);
+        payload.put((byte) 2);
+        payload.put((byte) 0x1C);
+        payload.put((byte) 0x01);
+        payload.flip();
+        BluetoothHandoverData result = mHandoverDataParser.parseBleOob(payload);
+        assertFalse(result.valid);
+    }
+
+    @Test
+    public void testParseBluetoothWithBtOobRecord() {
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn("application/vnd.bluetooth.ep.oob"
+                .getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(btPayload().array());
+        when(mNdefRecord.getId()).thenReturn(new byte[]{0x10});
+        BluetoothHandoverData result = mHandoverDataParser.parseBluetooth(mNdefMessage);
+        assertNotNull(result);
+    }
+
+    @Test
+    public void testParseBluetoothWithBleOobRecord() {
+        when(mBluetoothAdapter.getRemoteDevice(any(byte[].class))).thenReturn(mBluetoothDevice);
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn("application/vnd.bluetooth.le.oob"
+                .getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(blePayload().array());
+        BluetoothHandoverData result = mHandoverDataParser.parseBluetooth(mNdefMessage);
+        assertNotNull(result);
+    }
+
+    @Test
+    public void testParseBluetoothWithNokiaRecord() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        String deviceName = "NokiaDevice";
+        ByteBuffer payload = ByteBuffer.allocate(30);
+        payload.put((byte) 0);
+        payload.position(1);
+        payload.put(macAddress);
+        payload.position(14);
+        payload.put((byte) deviceName.length());
+        payload.put(deviceName.getBytes(StandardCharsets.UTF_8));
+        payload.flip();
+
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_EXTERNAL_TYPE);
+        when(mNdefRecord.getType()).thenReturn(
+                "nokia.com:bt".getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(payload.array());
+        BluetoothHandoverData result = mHandoverDataParser.parseBluetooth(mNdefMessage);
+        assertNotNull(result);
+        assertTrue(result.valid);
+        assertEquals(deviceName, result.name);
+    }
+
+    @Test
+    public void testParseBluetoothWithUnknownType() {
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn(new byte[]{0x03, 0x04});
+        BluetoothHandoverData result = mockHandoverDataParser.parseBluetooth(mNdefMessage);
+        verify(mockHandoverDataParser, never()).parseBtOob(any(ByteBuffer.class));
+        verify(mockHandoverDataParser, never()).parseBleOob(any(ByteBuffer.class));
+        verify(mockHandoverDataParser, never()).parseBluetoothHandoverSelect(
+                any(NdefMessage.class));
+        verify(mockHandoverDataParser, never()).parseNokia(any(ByteBuffer.class));
+        assertNull(result);
+    }
+
+    @Test
+    public void testParseBluetoothHandoverSelectWithBtOobRecordAndCarrierActivating() {
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn("application/vnd.bluetooth.ep.oob"
+                .getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(btPayload().array());
+        when(mNdefRecord.getId()).thenReturn(new byte[]{0x10});
+        BluetoothHandoverData result = mHandoverDataParser.parseBluetoothHandoverSelect(
+                mNdefMessage);
+        assertNotNull(result);
+        assertTrue(result.carrierActivating);
+    }
+
+    @Test
+    public void testParseBluetoothHandoverSelectWithBleOobRecord() {
+        when(mBluetoothAdapter.getRemoteDevice(any(byte[].class))).thenReturn(mBluetoothDevice);
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn("application/vnd.bluetooth.le.oob"
+                .getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(blePayload().array());
+        BluetoothHandoverData result = mHandoverDataParser.parseBluetoothHandoverSelect(
+                mNdefMessage);
+        assertNotNull(result);
+        assertTrue(result.valid);
+    }
+
+    @Test
+    public void testParseBluetoothHandoverSelectWithNoMatchingRecord() {
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn(new byte[]{0x03, 0x04});
+        BluetoothHandoverData result = mockHandoverDataParser.parseBluetoothHandoverSelect(
+                mNdefMessage);
+        verify(mockHandoverDataParser, never()).parseBtOob(any(ByteBuffer.class));
+        verify(mockHandoverDataParser, never()).parseBleOob(any(ByteBuffer.class));
+        verify(mockHandoverDataParser, never()).isCarrierActivating(any(NdefRecord.class),
+                any(byte[].class));
+        assertNull(result);
+    }
+
+    @Test
+    public void testGetOutgoingHandoverData() {
+        when(mBluetoothAdapter.getRemoteDevice(any(byte[].class))).thenReturn(mBluetoothDevice);
+        when(mNdefRecord.getTnf()).thenReturn(NdefRecord.TNF_MIME_MEDIA);
+        when(mNdefRecord.getType()).thenReturn("application/vnd.bluetooth.le.oob"
+                .getBytes(StandardCharsets.US_ASCII));
+        when(mNdefRecord.getPayload()).thenReturn(blePayload().array());
+        BluetoothHandoverData result = mHandoverDataParser.getOutgoingHandoverData(
+                mNdefMessage);
+        assertNotNull(result);
+        assertTrue(result.valid);
+    }
+
+    @Test
+    public void testAddressToReverseBytesWithValidAddress() {
+        String address = "01:23:45:67:89:AB";
+        byte[] result = HandoverDataParser.addressToReverseBytes(address);
+        assertNotNull(result);
+        assertEquals(6, result.length);
+        assertArrayEquals(
+                new byte[]{(byte) 0xAB, (byte) 0x89, (byte) 0x67, (byte) 0x45, (byte) 0x23,
+                        (byte) 0x01}, result);
+    }
+
+    @Test
+    public void testAddressToReverseBytesWithNullAddress() {
+        byte[] result = HandoverDataParser.addressToReverseBytes(null);
+        assertNull(result);
+    }
+
+    @Test
+    public void testAddressToReverseBytesWithInvalidAddress() {
+        String address = "01:23:45:67:89";
+        byte[] result = HandoverDataParser.addressToReverseBytes(address);
+        assertNull(result);
+    }
+
+    @Test
+    public void testAddressToReverseBytesWithInvalidHexValues() {
+        String address = "01:23:45:67:89:GZ";
+        try {
+            HandoverDataParser.addressToReverseBytes(address);
+            fail("Expected NumberFormatException to be thrown");
+        } catch (NumberFormatException e) {
+            assertTrue(e.getMessage().contains("For input string: \"GZ\""));
+        }
+    }
+
+    private ByteBuffer blePayload() {
+        ByteBuffer payload = ByteBuffer.allocate(20);
+        payload.put((byte) 0x07); // Length
+        payload.put((byte) 0x1B); // Type
+        payload.put((byte) 0x01); // MAC Address Byte 1
+        payload.put((byte) 0x02); // MAC Address Byte 2
+        payload.put((byte) 0x03); // MAC Address Byte 3
+        payload.put((byte) 0x04); // MAC Address Byte 4
+        payload.put((byte) 0x05); // MAC Address Byte 5
+        payload.put((byte) 0x06); // MAC Address Byte 6
+        payload.put((byte) 8);
+        payload.put((byte) 0x04);
+        byte[] leScC = new byte[]{0x11, 0x22, 0x33, 0x44, 0x55, 0x66};
+        payload.put(leScC);
+        payload.flip(); // Reset position to read from the beginning
+        return payload;
+    }
+
+    private ByteBuffer btPayload() {
+        byte[] macAddress =
+                new byte[]{(byte) 0x01, (byte) 0x23, (byte) 0x45, (byte) 0x67, (byte) 0x89,
+                        (byte) 0xAB};
+        String deviceName = "TestLongDeviceName";
+        ByteBuffer payload = ByteBuffer.allocate(30);
+        payload.put((byte) 0x00);
+        payload.put((byte) 0x00);
+        payload.put(macAddress);
+        payload.put((byte) (deviceName.length() + 1));
+        payload.put((byte) 0x09);
+        payload.put(deviceName.getBytes(StandardCharsets.UTF_8));
+        payload.flip();
+        return payload;
+    }
+}
\ No newline at end of file
diff --git a/tests/unit/src/com/android/nfc/handover/PeripheralHandoverServiceTest.java b/tests/unit/src/com/android/nfc/handover/PeripheralHandoverServiceTest.java
new file mode 100644
index 00000000..2b6a602a
--- /dev/null
+++ b/tests/unit/src/com/android/nfc/handover/PeripheralHandoverServiceTest.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.handover;
+
+import static android.app.Service.START_NOT_STICKY;
+import static android.app.Service.START_STICKY;
+
+import static com.android.nfc.handover.PeripheralHandoverService.EXTRA_PERIPHERAL_DEVICE;
+import static com.android.nfc.handover.PeripheralHandoverService.EXTRA_PERIPHERAL_NAME;
+import static com.android.nfc.handover.PeripheralHandoverService.MSG_PAUSE_POLLING;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.nfc.NfcAdapter;
+import android.os.Bundle;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.provider.Settings;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+import org.mockito.quality.Strictness;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class PeripheralHandoverServiceTest {
+    @Mock
+    private BluetoothAdapter mMockBluetoothAdapter;
+    @Mock
+    private NfcAdapter mMockNfcAdapter;
+    @Mock
+    private Context mMockContext;
+    @Mock
+    private BluetoothDevice mMockDevice1;
+    @Mock
+    private BluetoothDevice mMockDevice2;
+    @Mock
+    private Messenger mMockClient;
+    @Mock
+    private PeripheralHandoverService.MessageHandler mMockHandler;
+    @Mock
+    private BluetoothPeripheralHandover mMockBluetoothPeripheralHandover;
+    @Mock
+    private ContentResolver mMockContentResolver;
+    @Mock
+    private BluetoothDevice mMockDevice;
+    @Mock
+    private Resources mMockResources;
+    private MockitoSession mStaticMockSession;
+    private PeripheralHandoverService mService;
+
+    @Before
+    public void setUp() {
+        mStaticMockSession = ExtendedMockito.mockitoSession()
+                .mockStatic(NfcAdapter.class)
+                .strictness(Strictness.LENIENT).startMocking();
+        MockitoAnnotations.initMocks(this);
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice1, false);
+        when(mMockContext.getApplicationContext()).thenReturn(mMockContext);
+        when(mMockContext.getContentResolver()).thenReturn(mMockContentResolver);
+        when(mMockContext.getResources()).thenReturn(mMockResources);
+        when(NfcAdapter.getDefaultAdapter(mMockContext)).thenReturn(mMockNfcAdapter);
+    }
+
+    private PeripheralHandoverService createServiceInstance(BluetoothAdapter bluetoothAdapter,
+            NfcAdapter nfcAdapter,
+            BluetoothPeripheralHandover bluetoothPeripheralHandover,
+            PeripheralHandoverService.MessageHandler handler,
+            Messenger messenger, BluetoothDevice device, boolean bluetoothEnabledByNfc) {
+        mService = new PeripheralHandoverService(bluetoothAdapter, nfcAdapter,
+                bluetoothPeripheralHandover, handler, messenger, device, bluetoothEnabledByNfc);
+        return mService;
+    }
+
+    @After
+    public void tearDown() {
+        mStaticMockSession.finishMocking();
+    }
+
+    @Test
+    public void testEnableBluetoothAdapterDisabled() {
+        when(mMockBluetoothAdapter.isEnabled()).thenReturn(false);
+        when(mMockBluetoothAdapter.enableNoAutoConnect()).thenReturn(true);
+
+        boolean result = mService.enableBluetooth();
+        verify(mMockBluetoothAdapter).enableNoAutoConnect();
+        assertTrue(mService.mBluetoothEnabledByNfc);
+        assertTrue(result);
+    }
+
+    @Test
+    public void testEnableBluetoothAdapterEnabled() {
+        when(mMockBluetoothAdapter.isEnabled()).thenReturn(true);
+
+        boolean result = mService.enableBluetooth();
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasConnectedBluetoothDevices_DeviceConnected() {
+        Set<BluetoothDevice> bondedDevices = new HashSet<>();
+        bondedDevices.add(mMockDevice1);
+        bondedDevices.add(mMockDevice2);
+        when(mMockBluetoothAdapter.getBondedDevices()).thenReturn(bondedDevices);
+        when(mMockDevice2.isConnected()).thenReturn(true);
+
+        boolean result = mService.hasConnectedBluetoothDevices();
+        assertTrue(result);
+    }
+
+    @Test
+    public void testHasConnectedBluetoothDevices_DeviceNotConnected() {
+        Set<BluetoothDevice> bondedDevices = new HashSet<>();
+        bondedDevices.add(mMockDevice1);
+        bondedDevices.add(mMockDevice2);
+        when(mMockBluetoothAdapter.getBondedDevices()).thenReturn(bondedDevices);
+        when(mMockDevice2.isConnected()).thenReturn(false);
+
+        boolean result = mService.hasConnectedBluetoothDevices();
+        assertFalse(result);
+    }
+
+    @Test
+    public void testDisableBluetoothIfNeededWhenBluetoothDisabledByNfc() {
+        mService.disableBluetoothIfNeeded();
+        verify(mMockBluetoothAdapter, never()).disable();
+    }
+
+    @Test
+    public void testDisableBluetoothIfNeededWhenConnectedBluetoothDevices() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice1, true);
+        Set<BluetoothDevice> bondedDevices = new HashSet<>();
+        bondedDevices.add(mMockDevice1);
+        bondedDevices.add(mMockDevice2);
+        when(mMockBluetoothAdapter.getBondedDevices()).thenReturn(bondedDevices);
+        when(mMockDevice2.isConnected()).thenReturn(true);
+
+        mService.disableBluetoothIfNeeded();
+        verify(mMockBluetoothAdapter, never()).disable();
+        verify(mMockBluetoothAdapter).getBondedDevices();
+    }
+
+    @Test
+    public void testDisableBluetoothIfNeededWhenBluetoothHeadsetNotConnected() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice1, true);
+        Set<BluetoothDevice> bondedDevices = new HashSet<>();
+        bondedDevices.add(mMockDevice1);
+        bondedDevices.add(mMockDevice2);
+        when(mMockBluetoothAdapter.getBondedDevices()).thenReturn(bondedDevices);
+        when(mMockDevice2.isConnected()).thenReturn(false);
+
+        mService.disableBluetoothIfNeeded();
+        verify(mMockBluetoothAdapter).disable();
+        assertFalse(mService.mBluetoothEnabledByNfc);
+    }
+
+    @Test
+    public void testReplyToClient_ClientIsNull() throws RemoteException {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, null, mMockDevice1, false);
+
+        mService.replyToClient(true);
+        verify(mMockClient, never()).send(any(Message.class));
+    }
+
+    @Test
+    public void testReplyToClient_ClientReceivesConnectedMessage() throws RemoteException {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice1, true);
+
+        mService.replyToClient(true);
+        verify(mMockClient).send(any(Message.class));
+    }
+
+    @Test
+    public void testReplyToClient_ClientReceivesNotConnectedMessage() throws RemoteException {
+        mService.replyToClient(false);
+        verify(mMockClient).send(any(Message.class));
+    }
+
+    @Test
+    public void testOnBluetoothPeripheralHandoverComplete_Connected() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, null, mMockDevice1, false);
+        when(mMockBluetoothPeripheralHandover.getTransport()).thenReturn(
+                BluetoothDevice.TRANSPORT_LE);
+
+        mService.onBluetoothPeripheralHandoverComplete(true);
+        assertEquals(0, mService.mStartId);
+        verify(mMockNfcAdapter, never()).resumePolling();
+        verify(mMockHandler, never()).removeMessages(MSG_PAUSE_POLLING);
+    }
+
+    @Test
+    public void testOnBluetoothPeripheralHandoverComplete_NotConnected() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, null, mMockDevice1, false);
+        when(mMockHandler.hasMessages(MSG_PAUSE_POLLING)).thenReturn(true);
+        when(mMockBluetoothPeripheralHandover.getTransport()).thenReturn(
+                BluetoothDevice.TRANSPORT_LE);
+
+        mService.onBluetoothPeripheralHandoverComplete(false);
+        verify(mMockNfcAdapter).resumePolling();
+        verify(mMockHandler).removeMessages(MSG_PAUSE_POLLING);
+    }
+
+    @Test
+    public void testBluetoothStatusReceiver_onReceive() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, null, mMockDevice1, false);
+        Intent mockIntent = mock(Intent.class);
+        when(mockIntent.getAction()).thenReturn(BluetoothAdapter.ACTION_STATE_CHANGED);
+        when(mockIntent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                BluetoothAdapter.ERROR)).thenReturn(BluetoothAdapter.STATE_ON);
+        when(mMockBluetoothPeripheralHandover.hasStarted()).thenReturn(true);
+        when(mMockBluetoothPeripheralHandover.start()).thenReturn(true);
+
+        mService.mBluetoothStatusReceiver.onReceive(mMockContext, mockIntent);
+        assertEquals(0, mService.mStartId);
+        verify(mockIntent).getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                BluetoothAdapter.ERROR);
+    }
+
+    @Test
+    public void testOnBind() {
+        assertNull(mService.onBind(null));
+    }
+
+    @Test
+    public void testUnBind() {
+        assertFalse(mService.onUnbind(null));
+    }
+
+    @Test
+    public void testOnStartCommand_START_NOT_STICKY() {
+        assertEquals(START_NOT_STICKY, mService.onStartCommand(null, 0, 0));
+    }
+
+    @Test
+    public void testOnStartCommand_START_STICKY() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice, false);
+        Bundle mockBundle = mock(Bundle.class);
+        Intent mockIntent = mock(Intent.class);
+        int mStartId = 0;
+        when(mockIntent.getExtras()).thenReturn(mockBundle);
+
+        assertEquals(START_STICKY, mService.onStartCommand(mockIntent, 0, mStartId));
+        assertEquals(mStartId, mService.mStartId);
+    }
+
+    @Test
+    public void testOnStartCommand_CancelOnGoingHandover() {
+        mService = createServiceInstance(mMockBluetoothAdapter, mMockNfcAdapter,
+                mMockBluetoothPeripheralHandover, mMockHandler, mMockClient, mMockDevice, false);
+        Bundle mockBundle = mock(Bundle.class);
+        Intent mockIntent = mock(Intent.class);
+        int mStartId = 1;
+        when(mockIntent.getExtras()).thenReturn(mockBundle);
+        when(mockBundle.getParcelable(EXTRA_PERIPHERAL_DEVICE)).thenReturn(mMockDevice);
+        when(mockBundle.getString(EXTRA_PERIPHERAL_NAME)).thenReturn("Test name");
+
+        assertEquals(START_STICKY, mService.onStartCommand(mockIntent, 0, mStartId));
+        assertEquals(mStartId, mService.mStartId);
+    }
+
+    @Test
+    public void testOnStartCommandNonPeripheralHandover_START_NOT_STICKY() {
+        InstrumentationRegistry.getInstrumentation().runOnMainSync(() -> {
+            PeripheralHandoverService peripheralServ = new PeripheralHandoverService(
+                    mMockBluetoothAdapter, mMockNfcAdapter,
+                    mMockBluetoothPeripheralHandover, mMockHandler, null, mMockDevice, false) {
+                @Override
+                boolean doPeripheralHandover(Bundle extras) {
+                    return false; // Override to return false
+                }
+            };
+            Bundle mockBundle = mock(Bundle.class);
+            Intent mockIntent = mock(Intent.class);
+            when(mockIntent.getExtras()).thenReturn(mockBundle).thenReturn(null);
+            when(mockBundle.getParcelable(EXTRA_PERIPHERAL_DEVICE)).thenReturn(mMockDevice);
+            when(mockBundle.getString(EXTRA_PERIPHERAL_NAME)).thenReturn("Test name");
+            when(mMockBluetoothPeripheralHandover.getTransport()).thenReturn(
+                    BluetoothDevice.TRANSPORT_LE);
+
+            int result = peripheralServ.onStartCommand(mockIntent, 0, 0);
+            assertEquals(START_NOT_STICKY, result);
+            assertEquals(0, peripheralServ.mStartId);
+        });
+    }
+}
\ No newline at end of file
diff --git a/tests/unit/src/com/android/nfc/wlc/NfcChargingTest.java b/tests/unit/src/com/android/nfc/wlc/NfcChargingTest.java
index d9b9486c..1d490522 100644
--- a/tests/unit/src/com/android/nfc/wlc/NfcChargingTest.java
+++ b/tests/unit/src/com/android/nfc/wlc/NfcChargingTest.java
@@ -21,18 +21,17 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import android.app.ActivityManager;
-import android.content.ContentResolver;
 import android.content.Context;
 import android.content.ContextWrapper;
+import android.nfc.FormatException;
 import android.nfc.NdefMessage;
 import android.nfc.NdefRecord;
-import android.os.UserHandle;
-import android.os.UserManager;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -41,21 +40,17 @@ import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.nfc.DeviceHost;
 import com.android.nfc.NfcService;
 
-import com.google.common.truth.Truth;
-
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 import org.mockito.quality.Strictness;
 
-import java.util.HashMap;
-import java.util.Map;
-
 @RunWith(AndroidJUnit4.class)
 public class NfcChargingTest {
     private static String TAG = NfcChargingTest.class.getSimpleName();
@@ -177,5 +172,176 @@ public class NfcChargingTest {
         Assert.assertEquals(1, mNfcCharging.WLCState);
     }
 
+    @Test
+    public void testHandleWlcCap_ModeReq_State8() {
+        mNfcCharging.WLCState = 2;
+        mNfcCharging.WlcCap_NegoWait = 1;
+        mNfcCharging.mNretry = 1;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(0, mNfcCharging.WLCState);
+        Assert.assertFalse(mNfcCharging.WLCL_Presence);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State8_Retry() {
+        mNfcCharging.WLCState = 2;
+        mNfcCharging.WlcCap_NegoWait = 1;
+        mNfcCharging.mNretry = 0;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(0, mNfcCharging.WLCState);
+        mNfcCharging.WLCState = 2;
+        mNfcCharging.WlcCap_NegoWait = 2;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(3, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State11() throws FormatException {
+        mNfcCharging.WLCState = 3;
+        mNfcCharging.HandleWLCState();
+        ArgumentCaptor<byte[]> argumentCaptor = ArgumentCaptor.forClass(byte[].class);
+        verify(mTagEndpoint).writeNdef(argumentCaptor.capture());
+        byte[] messageArray = argumentCaptor.getValue();
+        Assert.assertNotNull(messageArray);
+        NdefMessage ndefMessage = new NdefMessage(messageArray);
+        Assert.assertNotNull(ndefMessage);
+        Assert.assertEquals(4, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State12() {
+        mNfcCharging.WLCState = 4;
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        when(ndefRecord.getType()).thenReturn(NfcCharging.WLCCTL);
+        byte[] payload = {0x57, 0x4c, 0x43, 0x43, 0x54, 0x4C};
+        when(ndefRecord.getPayload()).thenReturn(payload);
+
+        NdefRecord ndefRecordWLCSTAI = mock(NdefRecord.class);
+        when(ndefRecordWLCSTAI.getType()).thenReturn(NfcCharging.WLCSTAI);
+        byte[] payloadWLCSTAI = {0x57, 0x4c, 0x43, 0x43, 0x54, 0x4C};
+        when(ndefRecordWLCSTAI.getPayload()).thenReturn(payloadWLCSTAI);
+
+        NdefRecord[] records = {ndefRecord, ndefRecordWLCSTAI};
+        when(ndefMessage.getRecords()).thenReturn(records);
+        when(mTagEndpoint.getNdef()).thenReturn(ndefMessage);
+        NfcService nfcService = mock(NfcService.class);
+        when(NfcService.getInstance()).thenReturn(nfcService);
+        mNfcCharging.HandleWLCState();
+        verify(nfcService).onWlcData(any());
+        Assert.assertEquals(6, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State12_WlcCtlMsgFalse() {
+        mNfcCharging.WLCState = 4;
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        when(ndefRecord.getType()).thenReturn(NfcCharging.WLCPI);
+
+        NdefRecord[] records = {ndefRecord};
+        when(ndefMessage.getRecords()).thenReturn(records);
+        when(mTagEndpoint.getNdef()).thenReturn(ndefMessage);
+        mNfcCharging.mNwcc_retry = 3;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(0, mNfcCharging.mNwcc_retry);
+        Assert.assertFalse(mNfcCharging.WLCL_Presence);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State12_WlcCtlMsgFalse_Retry() {
+        mNfcCharging.WLCState = 4;
+        NdefMessage ndefMessage = mock(NdefMessage.class);
+        NdefRecord ndefRecord = mock(NdefRecord.class);
+        when(ndefRecord.getType()).thenReturn(NfcCharging.WLCPI);
+
+        NdefRecord[] records = {ndefRecord};
+        when(ndefMessage.getRecords()).thenReturn(records);
+        when(mTagEndpoint.getNdef()).thenReturn(ndefMessage);
+        mNfcCharging.mNwcc_retry = 0;
+        mNfcCharging.HandleWLCState();
+        Assert.assertTrue(mNfcCharging.mNwcc_retry > 0);
+        Assert.assertFalse(mNfcCharging.WLCL_Presence);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State16() {
+        mNfcCharging.WLCState = 5;
+        mNfcCharging.HandleWLCState();
+        ArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);
+        verify(mNfcCharging.TagHandler).writeNdef(captor.capture());
+        Assert.assertNotNull(captor.getValue());
+        Assert.assertEquals(6, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State17() {
+        mNfcCharging.WLCState = 6;
+        mNfcCharging.WlcCtl_WptReq = 0x0;
+        mNfcCharging.TWptDuration = 5000;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(9, mNfcCharging.WLCState);
+        ArgumentCaptor<DeviceHost.TagDisconnectedCallback> captor = ArgumentCaptor
+                .forClass(DeviceHost.TagDisconnectedCallback.class);
+        verify(mNfcCharging.TagHandler).startPresenceChecking(anyInt(), captor.capture());
+        Assert.assertNotNull(captor.getValue());
+    }
+
+    @Test
+    public void testTagDisconnectedCallback() {
+        mNfcCharging.WLCState = 6;
+        mNfcCharging.WlcCtl_WptReq = 0x0;
+        mNfcCharging.TWptDuration = 5000;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(9, mNfcCharging.WLCState);
+        ArgumentCaptor<DeviceHost.TagDisconnectedCallback> captor = ArgumentCaptor
+                .forClass(DeviceHost.TagDisconnectedCallback.class);
+        verify(mNfcCharging.TagHandler).startPresenceChecking(anyInt(), captor.capture());
+        DeviceHost.TagDisconnectedCallback callback = captor.getValue();
+        Assert.assertNotNull(callback);
+        NfcService nfcService = mock(NfcService.class);
+        when(NfcService.getInstance()).thenReturn(nfcService);
+        callback.onTagDisconnected();
+        verify(nfcService).sendScreenMessageAfterNfcCharging();
+        Assert.assertFalse(mNfcCharging.NfcChargingOnGoing);
+        Assert.assertEquals(0, mNfcCharging.WLCState);
+        verify(mNfcCharging.TagHandler).disconnect();
+        Assert.assertTrue(mNfcCharging.mFirstOccurrence);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State22() {
+        mNfcCharging.WLCState = 8;
+        mNfcCharging.WlcCtl_WptInfoReq = 1;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(3, mNfcCharging.WLCState);
+        mNfcCharging.WLCState = 8;
+        mNfcCharging.WlcCtl_WptInfoReq = 0;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(4, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_State24() {
+        mNfcCharging.WLCState = 9;
+        mNfcCharging.HandleWLCState();
+        verify(mNfcCharging.TagHandler).stopPresenceChecking();
+        Assert.assertEquals(0, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_TimeCompleted() {
+        mNfcCharging.WLCState = 10;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(8, mNfcCharging.WLCState);
+    }
+
+    @Test
+    public void testHandleWlcCap_ModeReq_TimeCompleted_Exit() {
+        mNfcCharging.WLCState = 11;
+        mNfcCharging.HandleWLCState();
+        Assert.assertEquals(0, mNfcCharging.WLCState);
+        Assert.assertFalse(mNfcCharging.NfcChargingOnGoing);
+    }
 }
 
diff --git a/testutils/Android.bp b/testutils/Android.bp
index 994bce17..e50fd0bd 100644
--- a/testutils/Android.bp
+++ b/testutils/Android.bp
@@ -17,6 +17,27 @@ android_library {
     ],
 }
 
+android_app {
+    name: "emulatorapp",
+    min_sdk_version: "33",
+    sdk_version: "35",
+    certificate: "nfc",
+    srcs: [
+        "src/com/android/nfc/emulatorapp/**/*.kt",
+    ],
+    assets: ["src/com/android/nfc/emulatorapp/parsed_files/**/*.txt"],
+    resource_dirs: ["src/com/android/nfc/emulatorapp/res"],
+    manifest: "src/com/android/nfc/emulatorapp/AndroidManifest.xml",
+    static_libs: [
+        "guava",
+        "androidx.appcompat_appcompat",
+        "kotlinx-coroutines-android",
+        "androidx.annotation_annotation",
+        "androidx.compose.ui_ui",
+        "com.google.android.material_material",
+    ],
+}
+
 android_test {
     name: "NfcEmulatorTestApp",
     sdk_version: "test_current",
@@ -29,8 +50,8 @@ android_test {
         "framework-nfc.impl",
         "compatibility-device-util-axt",
         "nfc-multidevice-utils",
+        "android.nfc.flags-aconfig-java",
         "androidx.test.runner",
-
     ],
     min_sdk_version: "35",
 }
@@ -67,5 +88,28 @@ android_library {
     ],
     manifest: "src/com/android/nfc/utils/AndroidManifest.xml",
     sdk_version: "test_current",
+    static_libs: [
+        "error_prone_annotations",
+    ],
+}
 
+python_defaults {
+    name: "GeneratedTestsPythonDefaults",
+    libs: [
+        "mobly",
+        "pyserial",
+        "pn532-python",
+    ],
+    test_suites: [
+        "general-tests",
+    ],
+    device_common_data: [
+        ":NfcEmulatorTestApp",
+        "config.yaml",
+    ],
+    version: {
+        py3: {
+            embedded_launcher: true,
+        },
+    },
 }
diff --git a/testutils/AndroidTest.xml b/testutils/AndroidTest.xml
new file mode 100644
index 00000000..2953f857
--- /dev/null
+++ b/testutils/AndroidTest.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="Config for multi device test cases generated by the NFC Replay Tool">
+  <!-- Only run tests if the device under test is SDK version 35 (Android 15) or above. -->
+  <object type="module_controller" class="com.android.tradefed.testtype.suite.module.Sdk35ModuleController" />
+  <option name="config-descriptor:metadata" key="component" value="misc" />
+
+  <device name="emulator">
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+      <option name="cleanup-apks" value="true" />
+      <option name="force-install-mode" value="FULL"/>
+      <option name="test-file-name" value="NfcEmulatorTestApp.apk" />
+    </target_preparer>
+  </device>
+
+  <test class="com.android.tradefed.testtype.mobly.MoblyBinaryHostTest">
+    <!-- The mobly-par-file-name should match the module name -->
+    <option name="mobly-par-file-name" value="GeneratedMultiDeviceTestCases" />
+    <option name="mobly-config-file-name" value="config.yaml" />
+    <!-- Timeout limit in milliseconds for all test cases of the python binary -->
+    <option name="mobly-test-timeout" value="180000" />
+  </test>
+</configuration>
\ No newline at end of file
diff --git a/testutils/README.md b/testutils/README.md
new file mode 100644
index 00000000..ecd161db
--- /dev/null
+++ b/testutils/README.md
@@ -0,0 +1,106 @@
+### NFC Replay Utility
+
+The NFC Replay tool allows a PN 532 module to reenact a NFC transaction from a
+snoop log. Currently, the tool is capable of replaying polling loop transactions
+and APDU exchanges. Once the transaction has been replayed, a test can
+optionally be generated based on the interaction between the module and
+emulator.
+
+The detailed design for this feature can be found at go/nfc-replay-utility-dd.
+
+### Using the tool
+
+#### Generating and replaying a test
+
+1\. Obtain a snoop log from the device (see instructions below for how to do this).
+
+2\. Connect the PN532 module via a serial port.
+
+3\. To replay the transaction, substitute the name of the snoop file and the
+serial port that the PN 532 module is using.
+
+```
+python3 nfcreplay.py -f $SNOOP_FILE -p $READER_PATH
+```
+
+Alternatively, to replay a specific section of the snoop log, additional
+arguments should be added to denote the desired start and end time frame of the
+transaction. For instance:
+
+```
+python3 nfcreplay.py -f $SNOOP_FILE -p $READER_PATH --start "2024-07-17 12:00:00" --end "2024-07-17 15:00:00"
+```
+
+Information about the transaction will be printed out to console, including a
+list of all polling loop and APDU exchanges that took place.
+
+5\. To generate and run a test from the snoop log, use the command:
+```
+python3 nfcreplay.py -f $SNOOP_FILE -p $READER_PATH --generate_and_replay_test
+```
+
+A Python file will be created, representing the test, along with a JSON file
+that contains all information pertaining to APDUs transacted.
+
+### Using the Emulator App
+
+The emulator app (located at src/com/android/nfc/emulatorapp/) is meant to
+handle APDU transactions between the PN 532 reader and the Android emulator in
+cases where the replayed transaction involves a third party app that the
+emulator does not access to. To guarantee that the emulator app is able to
+handle the transaction, all AIDs sent in the original transaction will be
+replaced with AIDs that the app is registered to handle (the specific values
+are located in @xml/aids). To use the app in conjunction with the replay tool,
+enter the following commands.
+
+1\. To prepare a snoop log to be replayed with the app:
+
+```
+python3 nfcreplay.py -f $SNOOP_FILE --parse_only
+```
+
+The script will produce the name of the parsed log, which will be located within
+the folder emulatorapp/parsed_files. Save the name for Step 3.
+
+2\. Build and install the emulator app. The following commands are specific to
+the Pixel 6 Pro (Raven). Non-Raven devices should substitute "raven" for the
+appropriate value.
+
+```
+mma emulatorapp
+adb install -r -g ~/aosp-main-with-phones/out/target/product/raven/system/app/emulatorapp/emulatorapp.apk
+
+```
+
+3\. Start the activity. Make sure that $PARSED_SNOOP_FILE is the name of the
+file, rather than its path. It is assumed that this file is located within
+emulatorapp/parsed_files, where it was originally created.
+
+```
+adb shell am start -n com.android.nfc.emulatorapp/.MainActivity --es "snoop_file" "$PARSED_SNOOP_FILE"
+```
+
+When you are ready to start the transaction, press the "Start Host APDU Service"
+button.
+
+4\. To replay the transaction with the PN532 module, follow the steps above to
+generate and replay a test case, though you should make sure to append the flag
+`--replay_with_app` to the end of each command.
+
+When the transaction is replayed, you should be able to see a list of APDU
+commands and responses received and sent by the Host APDU service displayed on
+the emulator app. Additionally, the replay script will output similar
+information.
+
+### Creating a Snoop Log
+
+To create a snoop log from your Android device, you should first go to Developer
+Options in Settings to make sure that "NFC NCI unfiltered log" is enabled. This
+will ensure that the data packets sent during NFC transactions are not truncated
+in the snoop log.
+
+After the NFC transaction is complete, enter the command `adb shell dumpsys
+nfc`. This will output the snoop log, which will begin with the line `---
+BEGIN:NFCSNOOP_VS_LOG_SUMMARY` and end with the line `---
+END:NFCSNOOP_VS_LOG_SUMMARY ---`. Copy the snoop log into a text file, and make
+sure to include both the start and end lines.
\ No newline at end of file
diff --git a/testutils/cli.py b/testutils/cli.py
new file mode 100755
index 00000000..5a724dde
--- /dev/null
+++ b/testutils/cli.py
@@ -0,0 +1,58 @@
+#!/usr/bin/env python3
+
+import argparse
+import binascii
+import logging
+import sys
+
+from pn532 import PN532
+
+logger = logging.getLogger()
+
+
+def die(msg, exc=None):
+  logger.error(msg)
+  sys.exit(1)
+
+
+def main():
+  parser = argparse.ArgumentParser(prog='pn532')
+  parser.add_argument(
+      '-p',
+      '--path',
+      action='store',
+      required=True,
+      help='Path to the PN532 serial device, e.g. /dev/ttyUSB0',
+  )
+  parser.add_argument(
+      '-f',
+      '--polling-frame',
+      action='store',
+      help='Optional custom polling frame in hex',
+  )
+
+  args = parser.parse_args()
+
+  polling_frame = None
+  if args.polling_frame:
+    try:
+      polling_frame = binascii.unhexlify(args.polling_frame)
+    except Exception as e:
+      die('Failed to parse polling frame hex: ' + str(e))
+
+  try:
+    pn = PN532(path=args.path)
+
+    while True:
+      pn.poll_a()
+      if polling_frame:
+        pn.send_broadcast(polling_frame)
+
+      pn.poll_b()
+      pn.mute()
+  except Exception as e:
+    die('Polling failed: ' + str(e))
+
+
+if __name__ == '__main__':
+  main()
diff --git a/testutils/config.yaml b/testutils/config.yaml
new file mode 100644
index 00000000..cdcbc027
--- /dev/null
+++ b/testutils/config.yaml
@@ -0,0 +1,9 @@
+TestBeds:
+- Name: TestBed
+  Controllers:
+    AndroidDevice: '*'
+  TestParams:
+    # Set the device path of the PN532 device used for this test here. This should
+    # be a uart device and the PN532 should be physically mounted on the DUT's NFC
+    # antenna.
+    pn532_serial_path: /dev/ttyUSB0
\ No newline at end of file
diff --git a/testutils/generate_test.py b/testutils/generate_test.py
new file mode 100644
index 00000000..5fe3523b
--- /dev/null
+++ b/testutils/generate_test.py
@@ -0,0 +1,427 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+"""Generates a Python test case from a snoop log."""
+
+import json
+import math
+import os
+
+from parse_log import FullApduEntry, NfcType, PollingLoopEntry
+
+INDENT_SIZE = 4
+
+
+def generate_test(
+    log: list[FullApduEntry | PollingLoopEntry], name: str
+) -> str:
+  """Generates a Python test case from a snoop log parsed by the replay tool.
+
+  The generated test will be placed in the current directory.
+
+  Args:
+    log: The parsed snoop log.
+    name: The name of the file containing the snoop log.
+
+  Returns:
+    The name of the JSON file containing APDUs needed to run the test.
+  """
+  # The name of the test file is based on the name of the snoop log
+  python_local_file = name + "_test.py"
+  file_path = (
+      os.path.dirname(os.path.realpath(__file__)) + "/" + python_local_file
+  )
+
+  try:
+    file = open(file_path, "wt")
+  except Exception as e:
+    raise RuntimeError(
+        "Error occurred while opening file: {}".format(file_path)
+    ) from e
+  file.write(create_imports())
+  file.write(create_replace_aids_method())
+  file.write(create_polling_loop_methods())
+  file.write(create_apdu_exchange_method())
+  file.write(create_setup())
+  file.write(create_test_opening(name))
+
+  last_timestamp = log[0].ts
+  json_list = []
+  for entry in log:
+    if isinstance(entry, PollingLoopEntry):
+      file.write(create_polling_loop_test(entry, last_timestamp))
+    else:  # isinstance(entry, FullApduEntry):
+      file.write(create_apdu_test(entry, last_timestamp))
+      json_list.append(create_apdu_dict(entry))
+    last_timestamp = entry.ts
+
+  json_dump = json.dumps(json_list)
+  apdu_local_file = name + "_apdus.json"
+  apdu_file_path = (
+      os.path.dirname(os.path.realpath(__file__)) + "/" + apdu_local_file
+  )
+  apdu_file = open(apdu_file_path, "wt")
+  apdu_file.write(json_dump)
+
+  file.write(create_teardown_test())
+  file.write(create_main_function())
+
+  print()
+  print(
+      "Test generated at {}. To run the test, copy the test file to"
+      " packages/apps/Nfc/tests/testcases/multidevices/.".format(file_path)
+  )
+  update_android_bp(python_local_file, name)
+
+  return apdu_local_file
+
+
+def update_android_bp(local_file_path, test_name):
+  """Creates a new python_test_host entry in Android.bp for the generated test."""
+  try:
+    android_bp = open("Android.bp", "a")
+  except Exception as e:
+    raise RuntimeError("Error occurred while opening Android.bp") from e
+
+  s = create_line()
+  s += create_line()
+  s += create_line("python_test_host {")
+  s += create_line('name: "{}",'.format(test_name), indent=1)
+  s += create_line('main: "{}",'.format(local_file_path), indent=1)
+  s += create_line('srcs: ["{}"],'.format(local_file_path), indent=1)
+  s += create_line('test_config: "AndroidTest.xml",', indent=1)
+  s += create_line("test_options: {", indent=1)
+  s += create_line("unit_test: false,", indent=2)
+  s += create_line('tags: ["mobly"],', indent=2)
+  s += create_line("},", indent=1)
+  s += create_line('defaults: ["GeneratedTestsPythonDefaults"],', indent=1)
+  s += create_line("}")
+  android_bp.write(s)
+
+
+def create_apdu_dict(entry: FullApduEntry):
+  """Creates a dictionary representation of an APDU entry."""
+  command_arr = []
+  for cmd in entry.command:
+    command_arr.append(cmd.hex())
+  response_arr = []
+  for rsp in entry.response:
+    if isinstance(rsp, str):
+      response_arr.append(rsp)
+    else:
+      response_arr.append(rsp.hex())
+  apdu_dict = {
+      "commands": command_arr,
+      "responses": response_arr,
+  }
+  return apdu_dict
+
+
+def create_test_opening(name: str):
+  """Creates the opening of the test file."""
+  s = create_line("def test_{}(self):".format(name), indent=1)
+  s += create_line("# Read in APDU commands and responses from file", indent=2)
+  s += create_line(
+      'file_path_name = self.user_params.get("file_path", "")', indent=2
+  )
+  s += create_line("apdu_cmds = []", indent=2)
+  s += create_line("apdu_rsps = []", indent=2)
+  s += create_line("if file_path_name:", indent=2)
+  s += create_line('with open(file_path_name, "r") as json_data:', indent=3)
+  s += create_line("d = json.load(json_data)", indent=4)
+  s += create_line("for entry in d:", indent=4)
+  s += create_line("apdu_cmds.append(", indent=5)
+  s += create_line(
+      '[bytearray.fromhex(cmd) for cmd in entry["commands"]]', indent=6
+  )
+  s += create_line(")", indent=5)
+  s += create_line("apdu_rsps.append(", indent=5)
+  s += create_line(
+      '[bytearray.fromhex(rsp) for rsp in entry["responses"]]', indent=6
+  )
+  s += create_line(")", indent=5)
+  s += create_line()
+  return s
+
+
+def create_polling_loop_test(entry: PollingLoopEntry, last_timestamp: int):
+  """Adds code to send a polling loop from the reader to the emulator.
+
+  The test will check to ensure that the polling loop is successfully received.
+  """
+  s = create_line(
+      "# Sending {} polling loop".format(entry.type),
+      indent=2,
+  )
+
+  sleep_time = calculate_time_to_sleep(entry.ts, last_timestamp)
+  s += create_line("time.sleep({})".format(sleep_time), indent=2)
+
+  match entry.type:
+    case NfcType.NFC_A:
+      s += create_line("saw_loop = send_polling_loop_a(self.reader)", indent=2)
+    case NfcType.NFC_B:
+      s += create_line("saw_loop = send_polling_loop_b(self.reader)", indent=2)
+    case _:  # NfcType.UNKNOWN
+      s += create_line('custom_data = "{}"'.format(entry.data.hex()), indent=2)
+      s += create_line(
+          "saw_loop = send_custom_polling_loop(self.reader, custom_data)",
+          indent=2,
+      )
+  s += create_line(
+      'asserts.assert_true(saw_loop, "Did not see polling loop")', indent=2
+  )
+  s += create_line()
+  return s
+
+
+def create_apdu_test(entry: FullApduEntry, last_timestamp: int):
+  """Adds code to conduct an APDU exchange between the reader and emulator.
+
+  The test will check to ensure that the expected response is received from the
+  emulator.
+  """
+  s = create_line("# Conducting APDU exchange", indent=2)
+
+  sleep_time = calculate_time_to_sleep(entry.ts, last_timestamp)
+  s += create_line("time.sleep({})".format(sleep_time), indent=2)
+
+  s += create_line("commands = apdu_cmds[0]", indent=2)
+  s += create_line("if self.with_emulator_app:", indent=2)
+  s += create_line("commands = replace_aids(commands)", indent=3)
+  s += create_line("responses = apdu_rsps[0]", indent=2)
+  s += create_line(
+      "tag_found, transacted = conduct_apdu_exchange(self.reader, commands,"
+      " responses)",
+      indent=2,
+  )
+  s += create_line()
+  s += create_line("asserts.assert_true(", indent=2)
+  s += create_line(
+      'tag_found, "Reader did not detect tag, transaction not attempted."',
+      indent=3,
+  )
+  s += create_line(")", indent=2)
+  s += create_line("asserts.assert_true(", indent=2)
+  s += create_line("transacted,", indent=3)
+  s += create_line(
+      '"Transaction failed, check device logs for more information."', indent=3
+  )
+  s += create_line(")", indent=2)
+  s += create_line()
+  s += create_line("apdu_cmds.pop(0)", indent=2)
+  s += create_line("apdu_rsps.pop(0)", indent=2)
+  s += create_line()
+  return s
+
+
+def create_imports():
+  s = create_line('"""Test generated from the NFC Replay Tool."""')
+  s += create_line()
+  s += create_line("import json")
+  s += create_line("import time")
+  s += create_line("from mobly import asserts")
+  s += create_line("from mobly import base_test")
+  s += create_line("from mobly import test_runner")
+  s += create_line("from mobly.controllers import android_device")
+  s += create_line("import pn532")
+  s += create_line()
+  s += create_line("# Number of polling loops to perform.")
+  s += create_line("_NUM_POLLING_LOOPS = 50")
+  s += create_line()
+  return s
+
+
+def create_replace_aids_method():
+  """Create a method that replaces the AIDs sent by the test with the ones
+
+  that are used by the emulator app.
+  """
+  s = create_line("_EMULATOR_AIDS = [")
+  s += create_line('bytearray.fromhex("00a4040008a000000151000000"),', indent=1)
+  s += create_line('bytearray.fromhex("00a4040008a000000003000000"),', indent=1)
+  s += create_line("]")
+  s += create_line()
+  s += create_line()
+  s += create_line("def replace_aids(commands: list[bytearray]):")
+  s += create_line(
+      '"""Replaces SELECT AID commands with AIDs from the emulator app."""',
+      indent=1,
+  )
+  s += create_line("new_commands = []", indent=1)
+  s += create_line("is_first_aid = True", indent=1)
+  s += create_line("for command in commands:", indent=1)
+  s += create_line(
+      'if command.startswith(bytearray.fromhex("00a40400")):', indent=2
+  )
+  s += create_line("if is_first_aid:", indent=3)
+  s += create_line(
+      "new_commands.append(_EMULATOR_AIDS[0])",
+      indent=4,
+  )
+  s += create_line("is_first_aid = False", indent=4)
+  s += create_line("else:", indent=3)
+  s += create_line("new_commands.append(_EMULATOR_AIDS[1])", indent=4)
+  s += create_line("else:", indent=2)
+  s += create_line("new_commands.append(command)", indent=3)
+  s += create_line("return new_commands", indent=1)
+  return s
+
+
+def create_polling_loop_methods():
+  """Create methods that send polling loops to the reader.
+
+  Specifically, three methods are created: send_polling_loop_a(),
+  send_polling_loop_b(), and send_custom_polling_loop().
+  """
+  s = create_line()
+  s += create_line()
+  s += create_line("def send_polling_loop_a(reader: pn532.PN532) -> bool:")
+  s += create_line("saw_loop = False", indent=1)
+  s += create_line("for i in range(_NUM_POLLING_LOOPS):", indent=1)
+  s += create_line("tag = reader.poll_a()", indent=2)
+  s += create_line("if tag is not None:", indent=2)
+  s += create_line("saw_loop = True", indent=3)
+  s += create_line("break", indent=3)
+  s += create_line("reader.mute()", indent=2)
+  s += create_line("return saw_loop", indent=1)
+  s += create_line()
+  s += create_line()
+  s += create_line("def send_polling_loop_b(reader: pn532.PN532) -> bool:")
+  s += create_line("saw_loop = False", indent=1)
+  s += create_line("for i in range(_NUM_POLLING_LOOPS):", indent=1)
+  s += create_line("tag = reader.poll_b()", indent=2)
+  s += create_line("if tag is not None:", indent=2)
+  s += create_line("saw_loop = True", indent=3)
+  s += create_line("break", indent=3)
+  s += create_line("reader.mute()", indent=2)
+  s += create_line("return saw_loop", indent=1)
+  s += create_line()
+  s += create_line()
+  s += create_line(
+      "def send_custom_polling_loop(reader: pn532.PN532, custom_data_hex: str)"
+      " -> bool:"
+  )
+  s += create_line("saw_loop = False", indent=1)
+  s += create_line("for i in range(_NUM_POLLING_LOOPS):", indent=1)
+  s += create_line("tag = reader.poll_a()", indent=2)
+  s += create_line("if tag is not None:", indent=2)
+  s += create_line(
+      "reader.send_broadcast(bytearray.fromhex(custom_data_hex))", indent=3
+  )
+  s += create_line("saw_loop = True", indent=3)
+  s += create_line("break", indent=3)
+  s += create_line("reader.poll_b()", indent=2)
+  s += create_line("reader.mute()", indent=2)
+  s += create_line("return saw_loop", indent=1)
+  return s
+
+
+def create_apdu_exchange_method():
+  """Creates method to conduct an APDU exchange between the emulator and reader."""
+  s = create_line()
+  s += create_line()
+  s += create_line("def conduct_apdu_exchange(")
+  s += create_line(
+      "reader: pn532.PN532, commands: list[bytearray], responses:"
+      " list[bytearray]",
+      indent=2,
+  )
+  s += create_line(") -> tuple[bool, bool]:")
+  s += create_line(
+      '"""Conducts an APDU exchange with the PN532 reader."""', indent=1
+  )
+  s += create_line("transacted = False", indent=1)
+  s += create_line("tag = None", indent=1)
+  s += create_line("for _ in range(_NUM_POLLING_LOOPS):", indent=1)
+  s += create_line("tag = reader.poll_a()", indent=2)
+  s += create_line("if tag is not None:", indent=2)
+  s += create_line("transacted = tag.transact(commands, responses)", indent=3)
+  s += create_line("reader.mute()", indent=3)
+  s += create_line("break", indent=3)
+  s += create_line("reader.mute()", indent=2)
+  s += create_line("return tag, transacted", indent=1)
+  return s
+
+
+def create_setup():
+  """Creates methods to prepare the PN532 reader and emulator before the test.
+
+  This involves checking to ensure that the raeder and emulator are both
+  present, and enabling NFC on the emulator.
+
+  Args:
+    name: The name of the original snoop log file.
+  """
+  s = create_line()
+  s += create_line()
+  s += create_line(
+      "class GeneratedMultiDeviceTestCases(base_test.BaseTestClass):"
+  )
+  s += create_line()
+  s += create_line("def setup_class(self):", indent=1)
+  s += create_line(
+      "self.emulator = self.register_controller(android_device)[0]", indent=2
+  )
+  s += create_line('self.emulator.debug_tag = "emulator"', indent=2)
+  s += create_line(
+      'pn532_serial_path = self.user_params.get("pn532_serial_path", "")',
+      indent=2,
+  )
+  s += create_line(
+      'self.with_emulator_app = self.user_params.get("with_emulator_app",'
+      " False)",
+      indent=2,
+  )
+  s += create_line(
+      'self.emulator.adb.shell(["svc", "nfc", "disable"])', indent=2
+  )
+  s += create_line(
+      'self.emulator.adb.shell(["svc", "nfc", "enable"])', indent=2
+  )
+  s += create_line("self.reader = pn532.PN532(pn532_serial_path)", indent=2)
+  s += create_line("self.reader.mute()", indent=2)
+  s += create_line()
+  return s
+
+
+def create_teardown_test():
+  s = create_line("def teardown_test(self):", indent=1)
+  s += create_line("self.reader.mute()", indent=2)
+  return s
+
+
+def create_main_function():
+  s = create_line()
+  s += create_line('if __name__ == "__main__":')
+  s += create_line("test_runner.main()", indent=1)
+  s += create_line()
+  return s
+
+
+def create_line(s: str = "", indent: int = 0):
+  return "{}{}\n".format(create_indent(indent), s)
+
+
+def create_indent(multiplier: int):
+  return " " * multiplier * INDENT_SIZE
+
+
+def calculate_time_to_sleep(current_ts: int, last_ts: int) -> int:
+  num_seconds = math.ceil((current_ts - last_ts) / 1000000)
+  if num_seconds < 1:
+    return 1
+  return num_seconds
diff --git a/testutils/nfcreplay.py b/testutils/nfcreplay.py
new file mode 100644
index 00000000..3fb55fca
--- /dev/null
+++ b/testutils/nfcreplay.py
@@ -0,0 +1,372 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+import argparse
+import datetime
+import os
+import subprocess
+import time
+from generate_test import generate_test
+from parse_log import FullApduEntry, NfcType, PollingLoopEntry, open_and_parse_file, parse_timeframe, replace_aids
+from pn532 import PN532
+
+# Minimum amount of time between successive NFC transactions, to prevent the
+# reader from being overloaded.
+_MIN_SLEEP_TIME_SECONDS = 0.5
+
+# Maximum amount of time allowed between successive NFC transactions, to allow
+# for ease of use.
+_MAX_SLEEP_TIME_SECONDS = 5
+
+_EXPECTED_ERROR_INDEX = 0
+_ACTUAL_ERROR_INDEX = 1
+
+# Number of times to try to obtain a tag before declaring failure.
+_NUM_RETRIES = 50
+
+# String templates for the output of a test case or snoop log.
+_APDU_OUTPUT_STR = "{}: APDU exchange: sent {}, received {}"
+_APDU_OUTPUT_TEST_STR = "{}: APDU exchange: sent {} APDUs, received {} APDUs"
+_POLLING_OUTPUT_STR = "{}: sent NFC data of type {}"
+_ERROR_STR = "     ERROR: {}"
+
+# Width of the column for outputting the results of a test case.
+_COLUMN_WIDTH = 80
+
+# Directory for generated test cases and files for the emulator app.
+_EMULATOR_APP_PARSED_DIR = "src/com/android/nfc/emulatorapp/parsed_files/"
+
+
+def send_nfc_a_data(reader: PN532) -> str | None:
+  """Calls poll_a() on the reader.
+
+  Args:
+    reader: The PN532 reader.
+
+  Returns:
+    the error, if one occurs
+  """
+  try:
+    reader.poll_a()
+  except Exception as e:
+    return e.__str__()
+
+
+def send_nfc_b_data(reader: PN532) -> str | None:
+  """Calls poll_b() on the reader.
+
+  Args:
+    reader: The PN532 reader.
+
+  Returns:
+    the error, if one occurs
+  """
+  try:
+    reader.poll_b()
+  except Exception as e:
+    return e.__str__()
+
+
+def send_unknown_data(reader: PN532, data: bytes) -> str | None:
+  """Sends a custom polling frame to the reader.
+
+  Args:
+    reader: The PN532 reader.
+    data: The custom polling frame to be sent to the reader.
+
+  Returns:
+    the error, if one occurs
+  """
+  try:
+    reader.poll_a()
+    reader.send_broadcast(data)
+    reader.mute()
+  except Exception as e:
+    return e.__str__()
+
+
+def conduct_apdu_exchange(reader: PN532, current: FullApduEntry) -> str | None:
+  """Conducts an APDU exchange between the emulator and the PN 532 module.
+
+  Once the device is detected by the reader, the reader will send the APDU
+  commands to the device and receive the responses. If an error occurs -- for
+  instance, if the response from the emulator differs from the expected response
+  -- the error is logged in the output.
+
+  Args:
+    reader: The PN532 reader.
+    current: A data object containing the APDU commands to be sent to the
+      emulator and the expected responses.
+
+  Returns:
+    the error, if one occurs
+  """
+  try:
+    for i in range(_NUM_RETRIES):
+      tag = reader.poll_a()
+      if tag is not None:
+        transacted = tag.transact(current.command, current.response)
+
+        if not transacted:
+          return "Received incorrect response. Expected: ".format(
+              current.response
+          )
+        return None
+      reader.mute()
+    return "No tag received"
+  except Exception as e:
+    return e.__str__()
+
+
+def replay_transaction(log, module_path: str):
+  """Replays the given transaction log on the PN 532 module.
+
+  Args:
+    log: The transaction log to be replayed.
+    module_path: The serial path to the PN 532 module.
+  """
+  try:
+    reader = PN532(module_path)
+  except Exception as e:
+    print("Could not connect to PN532 module")
+    return
+
+  if not log:
+    return
+
+  prev_time = log[0].ts
+
+  for current in log:
+    num_seconds = (current.ts - prev_time) / 1000000
+    if num_seconds < _MIN_SLEEP_TIME_SECONDS:
+      time.sleep(_MIN_SLEEP_TIME_SECONDS)
+    elif num_seconds > _MAX_SLEEP_TIME_SECONDS:
+      time.sleep(_MAX_SLEEP_TIME_SECONDS)
+    else:
+      time.sleep(num_seconds)
+
+    error = None
+
+    if isinstance(current, PollingLoopEntry):
+      if current.type == NfcType.NFC_A:
+        error = send_nfc_a_data(reader)
+      elif current.type == NfcType.NFC_B:
+        error = send_nfc_b_data(reader)
+      elif current.type == NfcType.UNKNOWN:
+        error = send_unknown_data(reader, current.data)
+    elif isinstance(current, FullApduEntry):
+      error = conduct_apdu_exchange(reader, current)
+
+    output_line_for_snoop_log(current, error)
+
+    # adjust timestamp
+    prev_time = current.ts
+
+  reader.mute()
+
+
+def parse_snoop_log(args: argparse.Namespace):
+  """Parses the given snoop log file.
+
+  If the file will be used for replaying a transaction with the emulator app,
+  the AIDs will be replaced with the ones used by the app. Additionally, if the
+  user specifies a start and end time, the log will be filtered to only include
+  transactions that fall within that timeframe.
+
+  Args:
+    snoop_file: The local path to the snoop log file.
+
+  Returns:
+    The parsed snoop log.
+  """
+  parsed = open_and_parse_file(args.file)
+
+  # replace the AIDs with the ones used by the emulator app
+  if args.replay_with_app or args.parse_only:
+    parsed = replace_aids(parsed)
+
+  return parse_timeframe(parsed, args.start, args.end)
+
+
+def output_line_for_snoop_log(
+    entry: PollingLoopEntry | FullApduEntry,
+    error: str | None,
+):
+  """Outputs a summary of an interaction from a snoop log.
+
+  Args:
+    entry: The current interaction to be replayed from the snoop log.
+    error: Whether or not an error occurred during the replayed (actual)
+      transaction.
+  """
+  cur_time = int(float(datetime.datetime.now().timestamp() * 1000000))
+  cur_time_str = datetime.datetime.fromtimestamp(cur_time / 1000000).strftime(
+      "%Y-%m-%d %H:%M:%S.%f"
+  )
+  if isinstance(entry, FullApduEntry):
+    print(
+        _APDU_OUTPUT_STR.format(
+            cur_time_str,
+            [command.hex() for command in entry.command],
+            [response.hex() for response in entry.response],
+        )
+    )
+  else:  # isinstance(entry, PollingLoopEntry)
+    print(_POLLING_OUTPUT_STR.format(cur_time_str, entry.type.name))
+
+  if error is not None:
+    print(_ERROR_STR.format(error))
+
+
+def print_opening_sequence(
+    file_name: str,
+    start: str | None = None,
+    end: str | None = None,
+):
+  """Prints the opening sequence for a test case or snoop log.
+
+  The name of the file to be replayed is displayed, along with the timeframe
+  that will be replayed, if specified by the user.
+
+  Args:
+    file_name: The name of the file to be replayed.
+    start: The start of the timeframe to be replayed.
+    end: The end of the timeframe to be replayed.
+  """
+  print()
+  print("Replaying transaction from snoop log: {}".format(file_name))
+  if start is not None and end is not None:
+    print("Timeframe: {} - {}".format(start, end))
+  elif start is not None:
+    print("Timeframe: {} - end".format(start))
+  elif end is not None:
+    print("Timeframe: start - {}".format(end))
+  else:
+    print()
+
+
+def create_file_for_emulator_app(
+    output: list[PollingLoopEntry | FullApduEntry], filename: str
+):
+  """Creates a file containing the parsed APDU exchanges from a snoop log.
+
+  This will be to replay the transaction with an Android app installed on the
+  emulator.
+
+  Args:
+    output: A list of polling loop entries and APDU exchanges parsed from the
+      snoop log.
+    filename: The name of the file to be created. This is near-identical to the
+      name of the snoop log file.
+  """
+  local_path = _EMULATOR_APP_PARSED_DIR + filename.replace("/", "_")
+  full_path = os.path.dirname(os.path.realpath(__file__)) + "/" + local_path
+  try:
+    file = open(full_path, "wt")
+  except Exception as e:
+    raise RuntimeError(
+        "Error occurred while opening file: {}".format(full_path)
+    ) from e
+  for entry in output:
+    if isinstance(entry, FullApduEntry):
+      file.write(
+          "{};{}".format(
+              [command.hex() for command in entry.command],
+              [response.hex() for response in entry.response],
+          )
+      )
+      file.write("\n")
+  print()
+  print("File for third party app generated at: {}".format(local_path))
+
+
+def get_name_for_test_case(filename: str) -> str:
+  return "Generated" + filename.replace("/", "").replace(".txt", "")
+
+
+def main():
+  parser = argparse.ArgumentParser(prog="pn532")
+  parser.add_argument(
+      "-p",
+      "--path",
+      action="store",
+      help="Path to the PN532 serial device, e.g. /dev/ttyUSB0",
+  )
+  parser.add_argument(
+      "-f",
+      "--file",
+      action="store",
+      required=True,
+      help="Path to the file of the snoop log",
+  )
+  parser.add_argument(
+      "--start",
+      action="store",
+      help="Start of the timeframe to be replayed",
+  )
+  parser.add_argument(
+      "--end",
+      action="store",
+      help="End of the timeframe to be replayed",
+  )
+  parser.add_argument(
+      "--parse_only",
+      action="store_true",
+      help="Parse the log without replaying the transaction",
+  )
+  parser.add_argument(
+      "--replay_with_app",
+      action="store_true",
+      help="Replay the transaction with the emulator app",
+  )
+  parser.add_argument(
+      "--generate_and_replay_test",
+      action="store_true",
+      help="Generate a test case from the log and then immediately run it",
+  )
+  args = parser.parse_args()
+
+  parsed_snoop_log = parse_snoop_log(args)
+  if args.parse_only:  # scenario 1: parse snoop log for the emulator app
+    create_file_for_emulator_app(parsed_snoop_log, args.file)
+  else:  # scenario 2: replay transaction from a snoop log
+    print_opening_sequence(
+        file_name=args.file,
+        start=args.start,
+        end=args.end,
+    )
+    if args.generate_and_replay_test:  # Replay the test that was just generated
+      test_case_name = get_name_for_test_case(args.file)
+      apdu_local_file = generate_test(parsed_snoop_log, test_case_name)
+      test_command = [
+          "atest",
+          "-v",
+          test_case_name,
+          "--",
+          "--testparam",
+          "pn532_serial_path=" + args.path,
+          "--testparam",
+          "file_path=" + apdu_local_file,
+      ]
+      if args.replay_with_app:
+        test_command += ["--testparam", "with_emulator_app=True"]
+      subprocess.run(test_command)
+    else:  # Default: replay the transaction
+      replay_transaction(parsed_snoop_log, args.path)
+
+
+if __name__ == "__main__":
+  main()
diff --git a/testutils/parse_log.py b/testutils/parse_log.py
new file mode 100644
index 00000000..b299657f
--- /dev/null
+++ b/testutils/parse_log.py
@@ -0,0 +1,440 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+"""Parses the snoop log to extract polling loop data and APDU exchanges."""
+
+import base64
+import dataclasses
+import datetime
+import enum
+import os
+import zlib
+
+PREAMBLE_LENGTH = 9
+HEADER_LENGTH = 7
+SNOOP_LOG_START = "BEGIN:NFCSNOOP_"
+SNOOP_LOG_END = "END:NFCSNOOP_"
+
+# Bytes identifying the starts of polling loop and APDU transactions
+POLLING_LOOP_START_BYTES = bytes.fromhex("6f0c")
+APDU_START_BYTES = bytes.fromhex("6f02")
+
+# Index corresponding to the total length of the APDU data packet
+APDU_LEN_INDEX = 2
+
+# Size of the main APDU header, which precedes either a list of APDU exchanges
+# or a single APDU exchange
+APDU_MAIN_HEADER_SIZE = 5
+
+# Start of the APDU data, which follows the main header
+APDU_DATA_START_INDEX = 6
+
+# Minimum lengths of a valid APDU command and response
+APDU_COMMAND_MIN_LENGTH = 13
+APDU_RESPONSE_MIN_LENGTH = 10
+
+# Sequence of bytes that identifies an APDU transaction
+APDU_IDENTIFIER = bytes([0x20, 0x00])
+
+# Byte that identifies an APDU command
+APDU_COMMAND_IDENTIFIER = 0x19
+
+# Byte that identifies an APDU response
+APDU_RESPONSE_IDENTIFIER = 0x08
+
+# Sequence of bytes that identifies whether the APDU command or response was
+# the first command or response in a longer list of APDU commands or responses
+APDU_ORDER_FIRST = 0x02
+APDU_ORDER_FIRST_ALT = bytes([0x0A, 0x00])
+APDU_ORDER_SECOND = 0x03
+APDU_ORDER_SECOND_ALT = bytes([0x0B, 0x00])
+
+# Sequence of bytes that identifies the start of a "SELECT AID" APDU command
+AID_START_BYTES = bytes.fromhex("00A40400")
+
+# AID groups that are used by the emulator app
+SELECT_AID_FIRST = bytes.fromhex("00A4040008A000000151000000")
+SELECT_AID_SECOND = bytes.fromhex("00A4040008A000000003000000")
+
+
+class NfcType(enum.Enum):
+  NFC_A = 0
+  NFC_B = 1
+  NFC_F = 2
+  NFC_V = 3
+  REMOTE_FIELD = 4
+  UNKNOWN = 5
+
+
+@dataclasses.dataclass
+class PollingLoopEntry:
+  ts: int = 0
+  type: NfcType = NfcType.UNKNOWN
+  data: bytes = b""
+  error: str | None = None
+
+
+@dataclasses.dataclass
+class PartialApduEntry:
+  ts: int = 0
+  is_command: bool = False
+  data: bytes = b""  # data sent by the APDU command or response
+  is_first: bool = (
+      True
+      # whether this is the first entry in the list of APDU commands or responses sent together
+  )
+
+
+@dataclasses.dataclass
+class FullApduEntry:
+  ts: int = 0
+  command: list[bytes] = dataclasses.field(default_factory=lambda: [])
+  response: list[bytes] = dataclasses.field(default_factory=lambda: [])
+  error: str | None = None
+
+
+def replace_aids(
+    log: list[PollingLoopEntry | FullApduEntry],
+) -> list[PollingLoopEntry | FullApduEntry]:
+  """Replaces the AIDs in the log with the AIDs that are used by the emulator app."""
+  new_log: list[PollingLoopEntry | FullApduEntry] = []
+  for cur in log:
+    is_first_aid = True
+    if isinstance(cur, FullApduEntry):
+      new_apdu_entry = FullApduEntry(
+          ts=cur.ts, command=[], response=cur.response
+      )
+      for cmd in cur.command:
+        if cmd.startswith(AID_START_BYTES):
+          if is_first_aid:
+            new_apdu_entry.command.append(SELECT_AID_FIRST)
+            is_first_aid = False
+          else:
+            new_apdu_entry.command.append(SELECT_AID_SECOND)
+        else:
+          new_apdu_entry.command.append(cmd)
+      new_log.append(new_apdu_entry)
+    else:
+      new_log.append(cur)
+  return new_log
+
+
+def parse_timeframe(log, start, end):
+  """Returns a subset of the log that falls within the given timeframe."""
+  if start is None and end is None:
+    return log
+  parsed_log = log
+  if start is not None:
+    start_dt = datetime.datetime.strptime(start, "%Y-%m-%d %H:%M:%S.%f")
+    start_ts = int(float(datetime.datetime.timestamp(start_dt)) * 1000000)
+    parsed_log = list(filter(lambda x: x.ts >= start_ts, log))
+  if end is not None:
+    end_dt = datetime.datetime.strptime(end, "%Y-%m-%d %H:%M:%S.%f")
+    end_ts = int(float(datetime.datetime.timestamp(end_dt)) * 1000000)
+    parsed_log = list(filter(lambda x: x.ts <= end_ts, parsed_log))
+  return parsed_log
+
+
+def standardize_log(
+    log: list[PollingLoopEntry | PartialApduEntry],
+) -> list[PollingLoopEntry | FullApduEntry]:
+  """Standardizes the log to ensure that it can be replayed by the PN 532 module.
+
+  This includes removing redundant calls to polling loop A and combining APDU
+  commands and responses into a single entry.
+
+  Args:
+    log: The log to be standardized.
+
+  Returns:
+    The standardized log.
+  """
+  cmds = []
+  rsps = []
+  last_ts = 0
+  standardized: list[PollingLoopEntry | FullApduEntry] = []
+  for cur in log:
+    if isinstance(cur, PollingLoopEntry):
+      if cur.type == NfcType.NFC_A or cur.type == NfcType.NFC_B:
+        standardized.append(cur)
+      elif cur.type == NfcType.UNKNOWN:
+        if not standardized:
+          standardized.append(cur)
+        else:
+          standardized[-1] = cur
+    elif isinstance(cur, PartialApduEntry):
+      if cur.is_command:
+        if len(cmds) == len(rsps) + 1:  # extra command without response
+          rsps.append(b"")
+        if len(cmds) == len(rsps) != 0 and cur.data.startswith(AID_START_BYTES):
+          standardized.append(FullApduEntry(last_ts, cmds, rsps))
+          cmds = []
+          rsps = []
+        cmds.append(cur.data)
+      else:
+        if len(cmds) == len(rsps):  # extra response without command
+          continue
+        rsps.append(cur.data)
+      last_ts = cur.ts
+  # handle last command and response
+  if len(cmds) == len(rsps) + 1:
+    rsps.append(b"")
+  if len(cmds) == len(rsps) != 0:
+    standardized.append(FullApduEntry(last_ts, cmds, rsps))
+  return standardized
+
+
+def parse_file(data: bytes) -> list[PollingLoopEntry | PartialApduEntry]:
+  """Parses the file to extract polling loop data and APDU exchanges."""
+  if not data:
+    raise RuntimeError("No data found in file")
+  version = data[0]
+  if version != 1:
+    raise RuntimeError("Unsupported version: {}".format(version))
+
+  offset = PREAMBLE_LENGTH
+  header_length = HEADER_LENGTH
+  pts_offset = 2
+  polling_list = []
+  ts = calculate_timestamp(data)
+  while len(data) - offset > header_length:
+
+    # length of the current transaction in bytes
+    length = data[offset] + (data[offset + 1] << 8)
+
+    # duration between the last transaction and the current one
+    pts = bytearray(data[offset + pts_offset : offset + pts_offset + 4])
+    pts_real = pts[0] + (pts[1] << 8) + (pts[2] << 16) + (pts[3] << 24)
+    ts += pts_real
+
+    transaction_type = (data[offset + header_length] & 0xE0) >> 5
+    if transaction_type == 3:  # ST_NTF or NCI_NTF transactions
+      cur_data = data[offset + header_length : offset + header_length + length]
+      if cur_data.startswith(POLLING_LOOP_START_BYTES):
+        polling_list.extend(add_polling_data(cur_data, ts))
+      elif cur_data.startswith(APDU_START_BYTES):
+        apdu_transactions = find_apdu_transactions(cur_data, ts)
+        polling_list.extend(apdu_transactions)
+    offset += header_length + length
+  return polling_list
+
+
+def open_and_parse_file(
+    file_path: str,
+) -> list[PollingLoopEntry | FullApduEntry]:
+  """Opens the file that contains the unparsed snoop log and parses it.
+
+  Args:
+    file_path: The path of the file containing the unparsed snoop log.
+
+  Returns:
+    A list of polling loop entries and APDU exchanges parsed from the file.
+
+  Raises:
+    RuntimeError: If the file cannot be found.
+  """
+  snoop_file = open_read_file(file_path)
+  str_data = ""
+  found_log = False
+  while line := snoop_file.readline():
+    if not found_log and SNOOP_LOG_START in line:
+      found_log = True
+    elif found_log:
+      if SNOOP_LOG_END in line:
+        break
+      str_data += line
+  snoop_bytes = inflate(base64.b64decode(str_data))
+  parsed = parse_file(snoop_bytes)
+  return standardize_log(parsed)
+
+
+def find_apdu_transactions(data: bytes, ts: int) -> list[PartialApduEntry]:
+  """Finds all APDU transactions in the given data."""
+  total_size = data[APDU_LEN_INDEX]
+  if total_size < APDU_MAIN_HEADER_SIZE or data[4:6] != APDU_IDENTIFIER:
+    return []
+
+  apdus: list[PartialApduEntry] = []
+  index = APDU_DATA_START_INDEX
+  while index < len(data):
+    cur_size = data[index + 1]
+    cur_data = data[index : index + cur_size + 2]
+    cmd, is_first = parse_apdu_command(cur_data) or (None, None)
+    if cmd is not None:
+      apdus.append(
+          PartialApduEntry(ts=ts, is_command=True, data=cmd, is_first=is_first)
+      )
+    else:
+      rsp, is_first = parse_apdu_response(cur_data) or (None, None)
+      if rsp is not None:
+        apdus.append(
+            PartialApduEntry(
+                ts=ts, is_command=False, data=rsp, is_first=is_first
+            )
+        )
+    index += cur_size + 2
+  return apdus
+
+
+def parse_apdu_command(data: bytes):
+  """Isolate the bytes sent from the reader to the emulator.
+
+  Args:
+    data: The raw APDU command in bytes.
+
+  Returns:
+    the data sent by the APDU command, or none if it is not a valid APDU
+    command.
+  """
+  if len(data) < APDU_COMMAND_MIN_LENGTH:
+    return None
+  if data[0] != APDU_COMMAND_IDENTIFIER:
+    return None
+  if data[1] != len(data) - 2:
+    return None
+  if data[5:7] != bytes.fromhex("0000"):
+    return None
+  if data[8] in [APDU_ORDER_FIRST, APDU_ORDER_SECOND]:
+    is_first = True if data[8] == APDU_ORDER_FIRST else False
+    return data[9:-4], is_first
+  elif data[8:10] in [APDU_ORDER_FIRST_ALT, APDU_ORDER_SECOND_ALT]:
+    is_first = True if data[8:10] == APDU_ORDER_FIRST_ALT else False
+    return data[10:-4], is_first
+  return None
+
+
+def parse_apdu_response(data: bytes):
+  """Isolates the data sent from the emulator to the reader.
+
+  Args:
+    data: The raw APDU response in bytes.
+
+  Returns:
+    the data sent by the APDU response, or none if it is not a valid APDU
+    response.
+  """
+  if len(data) < APDU_RESPONSE_MIN_LENGTH:
+    return None
+  if data[0] != APDU_RESPONSE_IDENTIFIER:
+    return None
+  if data[1] != len(data) - 2:
+    return None
+  if data[5] in [APDU_ORDER_FIRST, APDU_ORDER_SECOND]:
+    is_first = True if data[5] == APDU_ORDER_FIRST else False
+    return data[6:-4], is_first
+  elif data[5:7] in [APDU_ORDER_FIRST_ALT, APDU_ORDER_SECOND_ALT]:
+    is_first = True if data[5:7] == APDU_ORDER_FIRST_ALT else False
+    return data[7:-4], is_first
+  elif data[7] in [APDU_ORDER_FIRST, APDU_ORDER_SECOND]:
+    is_first = True if data[7] == APDU_ORDER_FIRST else False
+    return data[8:-4], is_first
+  return None
+
+
+def add_polling_data(data: bytes, ts: int) -> list[PollingLoopEntry]:
+  """Adds polling data to the list of transactions.
+
+  Each entry may contain multiple polling data transactions.
+
+  Args:
+    data: The raw polling data in bytes.
+    ts: The timestamp of the polling transaction.
+
+  Returns:
+    A list of polling data transactions.
+  """
+  transaction_list = []
+  count = 4
+  while count < len(data):
+    flag = data[count]
+    match flag:
+      case 0:
+        entry_type = NfcType.REMOTE_FIELD
+      case 1:
+        entry_type = NfcType.NFC_A
+      case 2:
+        entry_type = NfcType.NFC_B
+      case _:
+        entry_type = NfcType.UNKNOWN
+    length = data[count + 2] - 5
+    polling_data = data[count + 8 : count + 8 + length]
+    transaction_list.append(
+        PollingLoopEntry(
+            ts=ts,
+            type=entry_type,
+            data=polling_data,
+        )
+    )
+    count += 8 + length
+  return transaction_list
+
+
+def calculate_timestamp(data: bytes) -> int:
+  """Calculates the timestamp of the first frame in the log."""
+  ts = data[1:9]
+  ts_real = (
+      ts[0]
+      + (ts[1] << 8)
+      + (ts[2] << 16)
+      + (ts[3] << 24)
+      + (ts[4] << 32)
+      + (ts[5] << 40)
+      + (ts[6] << 48)
+      + (ts[7] << 56)
+  )
+  offset = PREAMBLE_LENGTH
+  while (len(data) - offset) > HEADER_LENGTH:
+    length = data[offset] + (data[offset + 1] << 8)
+    pts = bytearray(data[offset + 2 : offset + 6])
+    pts_real = pts[0] + (pts[1] << 8) + (pts[2] << 16) + (pts[3] << 24)
+    ts_real -= pts_real
+    offset += HEADER_LENGTH + length
+  return ts_real
+
+
+def inflate(data: bytes) -> bytes:
+  """Inflates decompressed data."""
+  decompressed = zlib.decompressobj().decompress(data[PREAMBLE_LENGTH:])
+  return data[0:PREAMBLE_LENGTH] + decompressed
+
+
+def open_read_file(file_path: str):
+  """Opens the file at the given path.
+
+  Args:
+    file_path: The path of the file to be opened. This can be either a local
+      path or an absolute path.
+
+  Returns:
+    An object representing the opened file.
+
+  Raises:
+    RuntimeError: If the file cannot be opened.
+  """
+  full_path = os.path.dirname(os.path.realpath(__file__)) + "/" + file_path
+  if os.path.exists(file_path):
+    file_to_open = file_path
+  elif os.path.exists(full_path):
+    file_to_open = full_path
+  else:
+    raise RuntimeError("File not found: {}".format(file_path))
+
+  try:
+    return open(file_to_open, "rt")
+  except Exception as e:
+    raise RuntimeError(
+        "Error occurred while opening file: {}".format(file_path)
+    ) from e
diff --git a/testutils/pn532/__init__.py b/testutils/pn532/__init__.py
index 0a4bafce..0c19e9e8 100644
--- a/testutils/pn532/__init__.py
+++ b/testutils/pn532/__init__.py
@@ -16,3 +16,4 @@
 
 from .pn532 import *
 from .tag import *
+from .casimir import *
diff --git a/testutils/pn532/casimir.py b/testutils/pn532/casimir.py
new file mode 100644
index 00000000..93857c15
--- /dev/null
+++ b/testutils/pn532/casimir.py
@@ -0,0 +1,184 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+import logging
+from . import tag
+from binascii import hexlify
+from mobly import logger as mobly_logger
+import http
+from urllib.parse import urlparse
+from http.client import HTTPSConnection
+from .nfcutils.reader import Reader, ReaderTag, CONFIGURATION_A_LONG
+import ssl
+import json
+
+
+def responses_match(expected: bytes, actual: bytes) -> bool:
+    if expected == actual:
+        return True
+    if expected is None or actual is None:
+        return False
+    if len(expected) == 0 or len(actual) == 0:
+        return False
+    if expected[0] != 0x00 and actual[0] == 0x00:
+        if expected == actual[1:]:
+            return True
+    return False
+
+
+class CasimirTag(ReaderTag):
+    def __init__(self, casimir, sender_id):
+        """Empty init"""
+        self.casimir = casimir
+        self.sender_id = sender_id
+        self.sel_res = 0x60
+        self.ats = [0x70, 0x80, 0x08, 0x00]
+        self.log = casimir.log
+
+    def transact(self, command_apdus, expected_response_apdus):
+        response_apdus = self.casimir.transceive_multiple(self.sender_id, command_apdus)
+        if response_apdus is None:
+            self.log.info("received None for response APDUs")
+            return False
+        if len(response_apdus) < len(expected_response_apdus):
+            self.log.info(f"received {len(response_apdus)} responses, expected {len(expected_response_apdus)}")
+            return False
+
+        for i in range(len(expected_response_apdus)):
+            if expected_response_apdus[i] != "*" and len(response_apdus) > i and not responses_match(expected_response_apdus[i], response_apdus[i]):
+                received_apdu = hexlify(response_apdus[i]).decode() if type(response_apdus[i]) is bytes else "None"
+                self.log.error(
+                    "Unexpected APDU: received %s, expected %s",
+                    received_apdu,
+                    hexlify(expected_response_apdus[i]).decode(),
+                )
+                return False
+        return True
+
+
+class Casimir(Reader):
+    def __init__(self, id):
+        """ Init """
+        self.id = id
+        self.host = 'localhost'
+        self.conn = None
+        self.rf_on = False
+        self.log = mobly_logger.PrefixLoggerAdapter(
+            logging.getLogger(),
+            {
+                mobly_logger.PrefixLoggerAdapter.EXTRA_KEY_LOG_PREFIX: (
+                    f"[Casimir|{id}]"
+                )
+            },
+        )
+
+    def __del__(self):
+        self.mute()
+
+    def poll_a(self):
+        """Attempts to detect target for NFC type A."""
+        response = self._send_command("PollA", {})
+        if response is None:
+            return None
+        if response == {}:
+            sender_id = 0
+        else:
+            sender_id = response["sender_id"]
+        self.log.debug("got sender_id: " + str(sender_id))
+        return CasimirTag(self, sender_id)
+
+    def poll_b(self):
+        """Attempts to detect target for NFC type B."""
+        raise RuntimeError("not implemented")
+
+    def send_broadcast(
+        self,
+        data,
+        *,
+        configuration=CONFIGURATION_A_LONG,
+    ):
+        """Emits broadcast frame"""
+        if configuration.power != 100:
+            self._send_command(
+                "SetPowerLevel", {"power_level": configuration.power / 10}
+            )
+        return self.transceive(data)
+
+    def transceive(self, apdu):
+        ret = self.transceive_multiple(None, [apdu])
+        if isinstance(ret, list) and len(ret) > 0:
+            return ret[0]
+        return None
+
+    def transceive_multiple(self, sender_id, command_apdus):
+        self.unmute()
+        data = {"apdu_hex_strings": [c.hex() for c in command_apdus]}
+        if isinstance(sender_id, int):
+            data["sender_id"] = sender_id
+        response = self._send_command('SendApdu', data)
+        if response in (None, {}):
+            return []
+        return [
+            bytes.fromhex(apdu) for apdu in response["responseHexStrings"]
+        ]
+
+    def unmute(self):
+        """Turns on device's RF antenna."""
+        if self.rf_on:
+            return
+        self._send_command('SetRadioState', {"radio_on": True})
+        self.rf_on = True
+
+    def mute(self):
+        """Turns off device's RF antenna."""
+        if self.conn is None:
+            self.rf_on = False
+            return
+        if self.rf_on:
+            self.rf_on = False
+            self._send_command('SetRadioState', {"radio_on": False})
+        self._send_command("Close", {})
+        self.conn.close()
+        self.conn = None
+
+    def reset(self):
+        """Nothing to reset"""
+
+    def _ensure_connected(self):
+        if self.conn is not None:
+            return
+        self.conn = HTTPSConnection(
+            self.host, 1443,
+            context=ssl._create_unverified_context()
+        )
+        self._send_command("Init", {})
+        self.rf_on = False
+
+    def _send_command(self, command, data):
+        self._ensure_connected()
+        self.conn.request(
+            method="POST",
+            url=f"/devices/{self.id}/services/CasimirControlService/{command}",
+            body= json.dumps(data),
+            headers={'Content-type': 'application/json'}
+        )
+        response = self.conn.getresponse()
+        response_data = response.read()
+        self.log.debug(f"response_data: {response_data}")
+        if str(response_data).startswith("b'rpc error"):
+            return None
+        response_string = json.loads(response_data)
+        return json.loads(response_string)
diff --git a/testutils/pn532/nfcutils/__init__.py b/testutils/pn532/nfcutils/__init__.py
index 0639bc66..50c078e9 100644
--- a/testutils/pn532/nfcutils/__init__.py
+++ b/testutils/pn532/nfcutils/__init__.py
@@ -15,3 +15,6 @@
 # Lint as: python3
 
 from .nfcutils import *
+from .polling_frame_utils import *
+from .data import *
+from .other import *
diff --git a/testutils/pn532/nfcutils/data.py b/testutils/pn532/nfcutils/data.py
new file mode 100644
index 00000000..a312ab1d
--- /dev/null
+++ b/testutils/pn532/nfcutils/data.py
@@ -0,0 +1,137 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+# String transformations
+
+from .other import classproperty
+
+
+def snake_to_camel(string, lower=True) -> str:
+    """Converts snake_case string to camelcase"""
+    pref, *other = string.split("_")
+    return (pref if lower else pref.capitalize()) + "".join(
+        x.capitalize() or "_" for x in other
+    )
+
+
+# Time conversion
+def ns_to_ms(t):
+    """Converts nanoseconds (10^9) to milliseconds (10^3)"""
+    return round(t / 1000000)
+
+
+def ns_to_us(t):
+    """Converts nanoseconds (10^9) to microseconds (10^6)"""
+    return round(t / 1000)
+
+
+def us_to_ms(t):
+    """Converts microseconds (10^6) to milliseconds (10^3)"""
+    return round(t / 1000)
+
+
+def s_to_us(t):
+    """Converts seconds (10^0) to microseconds (10^6)"""
+    return round(t * 1000000)
+
+
+class ByteStruct(int):
+    """This class enables an ability to assign attribute names to specific bit
+    offsets in a byte, making access more approachable
+    """
+
+    def __new__(cls, *args, **kwargs):
+        fields: dict = {**cls.fields}
+
+        for kwarg, _ in kwargs.items():
+            if kwarg not in fields:
+                raise ValueError(f"{cls.__name__} does not have field {kwarg}")
+
+        value = 0
+        if len(args) == 1 and isinstance(args[0], int):
+            # Initialize from bitmask
+            value = args[0]
+        else:
+            for key, bit_position in fields.items():
+                start, end = bit_position
+                bit_value = int(kwargs.get(key, 0))
+                bit_size = start - end + 1
+                if bit_value > 2**bit_size - 1:
+                    raise ValueError(f"{key} size in bits exceeds {bit_size}")
+                value |= (bit_value & ((1 << bit_size) - 1)) << end
+
+        values = {}
+        for name in fields.keys():
+            start, end = fields[name]
+            values[name] = (value >> end) & ((1 << (start - end + 1)) - 1)
+
+        instance = super().__new__(cls, value)
+        instance._values = values
+
+        return instance
+
+    def replace(self, **kwargs):
+        """Return a new instance with specific values replaced by name."""
+        return self.__class__(**{**self.values, **kwargs})
+
+    def __getattribute__(self, item):
+        values = super().__getattribute__("_values")
+        if item == "values":
+            return {**values}
+        if item not in values:
+            return super().__getattribute__(item)
+        return values[item]
+
+    @classmethod
+    def of(cls, name=None, **kwargs):
+        """Create a subclass with the specified name and parameters"""
+        if name is None:
+            name = "ByteStructOf" + ''.join(k.upper() for k in kwargs)
+        subclass = type(name, (cls,), kwargs)
+        return subclass
+
+    @classproperty
+    def fields(cls) -> dict:  # pylint: disable=no-self-argument
+        return {
+            k: sorted((v, v) if isinstance(v, int) else v)[::-1]
+            for k, v in cls.__dict__.items()
+            if not k.startswith("_")
+        }
+
+    def __repr__(self):
+        fields = self.fields
+        result = []
+        for name, value in self.values.items():
+            start, end = fields[name]
+            length = start - end + 1
+            result.append(f"{name}={bin(value)[2:].zfill(length)}")
+        return f"{self.__class__.__name__}({', '.join(result)})"
+
+
+# CRC Calculation
+def crc16a(data):
+    w_crc = 0x6363
+    for byte in data:
+        byte = byte ^ (w_crc & 0x00FF)
+        byte = (byte ^ (byte << 4)) & 0xFF
+        w_crc = (
+            (w_crc >> 8) ^ (byte << 8) ^ (byte << 3) ^ (byte >> 4)
+        ) & 0xFFFF
+    return bytes([w_crc & 0xFF, (w_crc >> 8) & 0xFF])
+
+
+def with_crc16a(data):
+    return bytes(data) + crc16a(data)
diff --git a/testutils/pn532/nfcutils/nfcutils.py b/testutils/pn532/nfcutils/nfcutils.py
index 38ca5829..53f69bc4 100644
--- a/testutils/pn532/nfcutils/nfcutils.py
+++ b/testutils/pn532/nfcutils/nfcutils.py
@@ -14,6 +14,8 @@
 
 # Lint as: python3
 
+from binascii import hexlify
+
 _NUM_POLLING_LOOPS = 50
 
 def create_select_apdu(aid_hex):
@@ -48,7 +50,7 @@ def parse_protocol_params(sak, ats):
     """
     Helper function to check whether protocol parameters are properly set.
     :param sak: SAK byte
-    :param ats: ATS byte
+    :param ats: ATS bytearray
     :return: whether bits are set correctly, message to print
     """
     msg = ""
@@ -138,7 +140,8 @@ def parse_protocol_params(sak, ats):
             msg += "        (OK) NAD bit is not set.\n"
         atsIndex += 1
         if atsIndex + 1 < len(ats):
-            historical_bytes = len(ats) - atsIndex
+            bytes_to_copy = len(ats) - atsIndex
+            historical_bytes = bytearray(ats[atsIndex:atsIndex + bytes_to_copy])
             msg +=  "\n(OK) Historical bytes: " + hexlify(historical_bytes).decode()
     return success, msg
 
diff --git a/testutils/pn532/nfcutils/other.py b/testutils/pn532/nfcutils/other.py
new file mode 100644
index 00000000..b3f33a6f
--- /dev/null
+++ b/testutils/pn532/nfcutils/other.py
@@ -0,0 +1,57 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+
+import time
+import functools
+
+
+class classproperty(property):
+    """Inherits from property descriptor as shown in documentation
+    https://docs.python.org/3/howto/descriptor.html
+    """
+
+    def __get__(self, owner_self, owner_cls):
+        return self.fget(owner_cls)
+
+
+class TimedWrapper:
+    """Proxies attribute access operation target
+    If accessed attribute is callable, wraps the original callable
+    into a function which tracks execution time
+    """
+
+    def __init__(self, target):
+        self._target = target
+        self.timings = []
+
+    def __getattr__(self, name):
+        attr = getattr(self._target, name)
+
+        if not callable(attr):
+            return attr
+
+        @functools.wraps(attr)
+        def wrapped_method(*args, **kwargs):
+            start_time = time.monotonic_ns()
+            result = attr(*args, **kwargs)
+            end_time = time.monotonic_ns()
+
+            # Store the timing
+            self.timings.append((start_time, end_time))
+
+            return result
+
+        return wrapped_method
diff --git a/testutils/pn532/nfcutils/polling_frame_utils.py b/testutils/pn532/nfcutils/polling_frame_utils.py
new file mode 100644
index 00000000..d0af1553
--- /dev/null
+++ b/testutils/pn532/nfcutils/polling_frame_utils.py
@@ -0,0 +1,519 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+# Lint as: python3
+"""Utility classes and functions used for testing polling frame notifications
+"""
+
+import time
+from typing import Collection
+from dataclasses import dataclass
+from .reader import TransceiveConfiguration
+
+
+@dataclass
+class PollingFrameTestCase:
+    """Defines a test case for polling frame tests,
+    containing data and transceive configuration to send the frame with
+    To verify against lists of expected types and data values
+    """
+    configuration: TransceiveConfiguration
+    data: str
+
+    success_types: Collection = ()
+    success_data: Collection = ()
+    warning_data: Collection = ()
+
+    def __init__(
+        self,
+        configuration,
+        data,
+        success_types=(),
+        success_data=(),
+        warning_data=()
+    ):
+        self.configuration = configuration
+        self.data = data
+        if len(success_types) == 0:
+            success_types = (configuration.type,)
+        # If no success data variations were given,
+        # assume only original is allowed
+        if len(success_data) == 0:
+            success_data = (data,)
+        self.success_types = success_types
+        self.success_data = success_data
+        self.warning_data = warning_data
+
+    def format_for_error(self, **kwargs):
+        """Formats testcase value for pretty reporting in errors"""
+        extras = {**kwargs}
+        if self.configuration.type not in {"O", "X"}:
+            extras["crc"] = self.configuration.crc
+            extras["bits"] = self.configuration.bits
+        if self.configuration.bitrate != 106:
+            extras["bitrate"] = self.configuration.bitrate
+        return {"type": self.configuration.type, "data": self.data, **extras}
+
+    @property
+    def expected_data(self):
+        """Returns all data variations that should not cause a test to fail"""
+        return [*self.success_data, *self.warning_data]
+
+    @property
+    def expected_types(self):
+        """Returns all types that should not cause a test to fail"""
+        return self.success_types
+
+
+@dataclass
+class PollingFrame:
+    """Represents PollingFrame object returned from an Android device"""
+    type: str
+    data: bytes = b""
+    timestamp: int = 0
+    triggered_auto_transact: bool = False
+    vendor_specific_gain: int = 0
+
+    @staticmethod
+    def from_dict(json: dict):
+        """Creates a PollingFrame object from dict"""
+        return PollingFrame(
+            type=json.get("type"),
+            data=bytes.fromhex(json.get("data")),
+            timestamp=json.get("timestamp"),
+            triggered_auto_transact=json.get(
+                "triggeredAutoTransact", json.get("triggered_auto_transact")
+            ),
+            vendor_specific_gain=json.get(
+                "vendorSpecificGain", json.get("vendor_specific_gain")
+            ),
+        )
+
+    def to_dict(self):
+        """Dumps PollingFrame object into a dict"""
+        return {
+            "type": self.type,
+            "data": self.data.hex().upper(),
+            "timestamp": self.timestamp,
+            "triggeredAutoTransact": self.triggered_auto_transact,
+            "vendorSpecificGain": self.vendor_specific_gain,
+        }
+
+    def __repr__(self) -> str:
+        return (
+            f"{self.__class__.__name__}"
+            + f"({', '.join(f'{k}={v}' for k, v in self.to_dict().items())})"
+        )
+
+
+_CARRIER = 13.56e6
+_A_TIMEOUT = (1236 + 384) / _CARRIER
+_B_TIMEOUT = 7680 / _CARRIER
+_F_TIMEOUT = 6800 / _CARRIER
+
+
+_GUARD_TIME_A = 0.0051
+_GUARD_TIME_B = 0.0051
+_GUARD_TIME_F = 0.02
+_GUARD_TIME = max(_GUARD_TIME_A, _GUARD_TIME_B, _GUARD_TIME_F)
+GUARD_TIME_PER_TECH = {
+    "O": _GUARD_TIME,
+    "X": _GUARD_TIME,
+    "A": _GUARD_TIME_A,
+    "B": _GUARD_TIME_B,
+    "F": _GUARD_TIME_F,
+}
+
+
+# Placeholder values for ON and OFF events
+_O = TransceiveConfiguration(type="O")
+_X = TransceiveConfiguration(type="X")
+
+# Possible transceive configurations for polling frames
+CONFIGURATION_A_LONG = _A = TransceiveConfiguration(
+    type="A", crc=True, bits=8, timeout=_A_TIMEOUT
+)
+_A_SHORT = TransceiveConfiguration(
+    type="A", crc=False, bits=7, timeout=_A_TIMEOUT
+)
+_A_NOCRC = TransceiveConfiguration(
+    type="A", crc=False, bits=8, timeout=_A_TIMEOUT
+)
+
+CONFIGURATION_B_LONG = _B = TransceiveConfiguration(
+    type="B", crc=True, bits=8, timeout=_B_TIMEOUT
+)
+_B_NOCRC = TransceiveConfiguration(
+    type="B", crc=False, bits=8, timeout=_B_TIMEOUT
+)
+
+_F = TransceiveConfiguration(
+    type="F", crc=True, bits=8, bitrate=212, timeout=_F_TIMEOUT
+)
+_F_424 = TransceiveConfiguration(
+    type="F", crc=True, bits=8, bitrate=424, timeout=_F_TIMEOUT
+)
+
+
+# Possible polling frame configurations
+# 1) Frames with special meaning like wakeup/request:
+#    - WUPA/REQA WUPB/REQB, SENSF_REQ, etc.
+# 2) Special cases:
+#    - 7-bit short frames (Type A only);
+#    - 424 kbps (Type F only)
+# 3) Full frames without CRC (Types A,B only)
+# 4) Full frames with CRC (Types A,B only, F does not use PLF, no need to test)
+
+# Placeholder test cases for ON/OFF
+POLLING_FRAME_ON = PollingFrameTestCase(_O, "01", ["O"], ["01"])
+POLLING_FRAME_OFF = PollingFrameTestCase(_X, "00", ["X"], ["00"])
+
+# Type A
+# 1)
+POLLING_FRAMES_TYPE_A_SPECIAL = [
+    # WUPA
+    PollingFrameTestCase(_A_SHORT, "26", ["A"], ["26"], ["52"]),
+    # REQA
+    PollingFrameTestCase(_A_SHORT, "52", ["A"], ["52"], ["26"]),
+    # Some readers send SLP_REQ in the polling loop
+    PollingFrameTestCase(_A, "5000", ["A", "U"], ["5000"]),
+]
+# 2) 7-bit short frames
+POLLING_FRAMES_TYPE_A_SHORT = [
+    PollingFrameTestCase(_A_SHORT, "20", ["U"]),
+    PollingFrameTestCase(_A_SHORT, "06", ["U"]),
+    PollingFrameTestCase(_A_SHORT, "50", ["U"]),
+    PollingFrameTestCase(_A_SHORT, "02", ["U"]),
+    PollingFrameTestCase(_A_SHORT, "70", ["U"]),
+    PollingFrameTestCase(_A_SHORT, "7a", ["U"]),
+]
+# 3)
+POLLING_FRAMES_TYPE_A_NOCRC = [
+    PollingFrameTestCase(_A_NOCRC, "aa", ["U"], ["aa"], [""]),
+    PollingFrameTestCase(_A_NOCRC, "55aa", ["U"], ["55aa"], [""]),
+    PollingFrameTestCase(_A_NOCRC, "aa55aa", ["U"], ["aa55aa"], ["aa"]),
+    PollingFrameTestCase(_A_NOCRC, "55aa55aa", ["U"], ["55aa55aa"], ["55aa"]),
+]
+# 4)
+POLLING_FRAMES_TYPE_A_LONG = [
+    PollingFrameTestCase(_A, "02f1", ["U"]),
+    PollingFrameTestCase(_A, "ff00", ["U"]),
+    PollingFrameTestCase(_A, "ff001122", ["U"]),
+    PollingFrameTestCase(_A, "ff00112233445566", ["U"]),
+    PollingFrameTestCase(_A, "ff00112233445566778899aa", ["U"]),
+    PollingFrameTestCase(_A, "000102030405060708090a0b0c0d", ["U"]),
+    PollingFrameTestCase(_A, "101112131415161718191a1b1c1d1e", ["U"]),
+    PollingFrameTestCase(_A, "202122232425262728292a2b2c2d2e2f", ["U"]),
+    PollingFrameTestCase(_A, "303132333435363738393a3b3c3d3e3f30", ["U"]),
+    PollingFrameTestCase(_A, "404142434445464748494a4b4c4d4e4f4041", ["U"]),
+    PollingFrameTestCase(_A, "505152535455565758595a5b5c5d5e5f505152", ["U"]),
+    PollingFrameTestCase(_A, "606162636465666768696a6b6c6d6e6f60616263", ["U"]),
+]
+
+# Type B
+# 1)
+POLLING_FRAMES_TYPE_B_SPECIAL = [
+    # 1.1) Common cases
+    #   REQB, AFI 0x00, TS 0x00
+    PollingFrameTestCase(_B, "050000", ["B"]),
+    #   WUPB, AFI 0x00, TS 0x00
+    PollingFrameTestCase(_B, "050008", ["B"]),
+    # 1.2) Different AFI values
+    #   REQB, AFI 0x01, TS 0x00
+    PollingFrameTestCase(_B, "050100", ["B"]),
+    #   WUPB, AFI 0x02, TS 0x00
+    PollingFrameTestCase(_B, "050208", ["B"]),
+    # 1.3) Different Timeslot counts
+    #   REQB, AFI 0x00, TS 0x01 (2)
+    PollingFrameTestCase(_B, "050001", ["B"]),
+    #   WUPB, AFI 0x00, TS 0x02 (4)
+    PollingFrameTestCase(_B, "05000a", ["B"]),
+]
+# 3)
+POLLING_FRAMES_TYPE_B_NOCRC = [
+    PollingFrameTestCase(_B_NOCRC, "aa", ["U"]),
+    PollingFrameTestCase(_B_NOCRC, "55aa", ["U"]),
+    PollingFrameTestCase(_B_NOCRC, "aa55aa", ["U"]),
+    PollingFrameTestCase(_B_NOCRC, "55aa55aa", ["U"]),
+]
+# 4)
+POLLING_FRAMES_TYPE_B_LONG = [
+    PollingFrameTestCase(_B, "02f1", ["U"]),
+    # 2 bytes
+    PollingFrameTestCase(_B, "ff00", ["U"]),
+    # 4 bytes
+    PollingFrameTestCase(_B, "ff001122", ["U"]),
+    # 8 bytes
+    PollingFrameTestCase(_B, "ff00112233445566", ["U"]),
+    # 12 bytes
+    PollingFrameTestCase(_B, "ff00112233445566778899aa", ["U"]),
+    # 16 bytes
+    PollingFrameTestCase(_B, "ff00112233445566778899aabbccddee", ["U"]),
+    # 20 bytes
+    PollingFrameTestCase(_B, "ff00112233445566778899aabbccddeeff001122", ["U"]),
+]
+
+# Type F
+# 1)
+POLLING_FRAMES_TYPE_F_SPECIAL = [
+    # 1.0) Common
+    #   SENSF_REQ, SC, 0xffff, RC 0x00, TS 0x00
+    PollingFrameTestCase(_F, "00ffff0000", ["F"]),
+    #   SENSF_REQ, SC, 0x0003, RC 0x00, TS 0x00
+    PollingFrameTestCase(_F, "0000030000", ["F"]),
+    # 1.1) Different request codes
+    #   SENSF_REQ, SC, 0xffff, RC 0x01, TS 0x00
+    PollingFrameTestCase(_F, "00ffff0100", ["F"]),
+    #   SENSF_REQ, SC, 0x0003, RC 0x01, TS 0x00
+    PollingFrameTestCase(_F, "0000030100", ["F"]),
+    # 1.2) Different Timeslot counts
+    #   SENSF_REQ, SC, 0xffff, RC 0x00, TS 0x01 (2)
+    PollingFrameTestCase(_F, "00ffff0001", ["F"]),
+    #   SENSF_REQ, SC, 0x0003, RC 0x00, TS 0x02 (4)
+    PollingFrameTestCase(_F, "0000030002", ["F"]),
+    # 2) 424 kbps
+    #   SENSF_REQ, SC, 0xffff
+    PollingFrameTestCase(_F_424, "00ffff0100", ["F"]),
+    #   SENSF_REQ, SC, 0x0003
+    PollingFrameTestCase(_F_424, "00ffff0100", ["F"]),
+]
+
+POLLING_FRAME_ALL_TEST_CASES = [
+    POLLING_FRAME_ON,
+    *POLLING_FRAMES_TYPE_A_SPECIAL,
+    *POLLING_FRAMES_TYPE_A_SHORT,
+    *POLLING_FRAMES_TYPE_A_NOCRC,
+    *POLLING_FRAMES_TYPE_A_LONG,
+    *POLLING_FRAMES_TYPE_B_SPECIAL,
+    *POLLING_FRAMES_TYPE_B_NOCRC,
+    *POLLING_FRAMES_TYPE_B_LONG,
+    *POLLING_FRAMES_TYPE_F_SPECIAL,
+    POLLING_FRAME_OFF,
+]
+
+
+EXPEDITABLE_POLLING_LOOP_EVENT_TYPES = ["F", "U"]
+
+
+def get_expedited_frames(frames):
+    """Finds and collects all expedited polling frames.
+    Expedited frames belong to F, U types and they get reported
+    to the service while the OS might still be evaluating the loop
+    """
+    expedited_frames = []
+    # Expedited frames come at the beginning
+    for frame in frames:
+        if frame.type not in EXPEDITABLE_POLLING_LOOP_EVENT_TYPES:
+            break
+        expedited_frames.append(frame)
+    return expedited_frames
+
+
+def split_frames_by_timestamp_wrap(frames, pivot_timestamp=None):
+    """Returns two lists of polling frames
+    split based on the timestamp value wrapping over to lower value
+    assuming that frames were provided in the way they arrived
+    """
+    if not frames:
+        return [], []
+    # Take the first timestamp from first frame (or the one provided)
+    # And check that timestamp for all frames that come afterwards is bigger
+    # otherwise consider them wrapped
+    pivot_timestamp = pivot_timestamp or frames[0].timestamp
+    not_wrapped = []
+    for frame in frames:
+        if frame.timestamp < pivot_timestamp:
+            break
+        not_wrapped.append(frame)
+    wrapped = frames[len(not_wrapped) :]
+    return not_wrapped, wrapped
+
+
+def apply_expedited_frame_ordering(frames, limit=3):
+    """Attempts to replicate expedited frame delivery behavior
+    of HostEmulationManager for type F, U events
+    """
+    leave, expedite = [], []
+
+    for frame in frames:
+        if frame.type in EXPEDITABLE_POLLING_LOOP_EVENT_TYPES \
+            and len(expedite) < limit:
+            expedite.append(frame)
+        else:
+            leave.append(frame)
+    return expedite + leave
+
+
+def apply_original_frame_ordering(frames):
+    """Reverts expedited frame ordering caused by HostEmulationManager,
+    useful when having the original polling frame order is preferable in a test
+
+    Call this function ONLY with a list of frames resembling a full polling loop
+    with possible expedited F, U events at the beginning.
+    """
+    if len(frames) == 0:
+        return []
+
+    expedited_frames = get_expedited_frames(frames)
+    # If no expedited frames were found at the beginning, leave
+    if len(expedited_frames) == 0:
+        return frames
+
+    # Original frames come after expedited ones
+    original_frames = frames[len(expedited_frames) :]
+
+    # In between expedited and original frames,
+    # which should be pre-sorted in their category
+    # there might be a timestamp wrap
+    original_not_wrapped, original_wrapped = split_frames_by_timestamp_wrap(
+        original_frames
+    )
+    # Non-expedited, original frame should be the first one in the loop
+    # so we can use the timestamp of the first expedited frame as a pivot
+    expedited_not_wrapped, expedited_wrapped = split_frames_by_timestamp_wrap(
+        expedited_frames,
+        pivot_timestamp=(
+            original_not_wrapped[0].timestamp
+            if len(original_not_wrapped) > 0 else None
+        ),
+    )
+
+    return sorted(
+        original_not_wrapped + expedited_not_wrapped, key=lambda f: f.timestamp
+    ) + sorted(original_wrapped + expedited_wrapped, key=lambda f: f.timestamp)
+
+
+def _test_apply_original_frame_ordering():
+    """Verifies that 'apply_original_frame_ordering' works properly"""
+    testcases = [
+        # Overflow after Normal B
+        (
+            ("O", 4), ("A", 5), ("U", 6), ("B", 7),
+            ("U", 0), ("F", 1), ("U", 2), ("X", 3)
+        ),
+        # Overflow after Expeditable
+        (
+            ("O", 4), ("A", 5), ("U", 6), ("B", 7),
+            ("U", 8), ("F", 0), ("U", 1), ("X", 2)
+        ),
+        # Overflow after Normal O
+        (("O", 4), ("A", 0), ("B", 1), ("F", 2), ("X", 3)),
+        # Overflow after Normal A
+        (("O", 4), ("A", 5), ("B", 0), ("F", 1), ("X", 2)),
+        # Overflow after Expeditable U
+        (("O", 4), ("U", 5), ("A", 0), ("B", 1), ("F", 2), ("X", 3)),
+        # No overflow
+        (("O", 0), ("A", 1), ("B", 2), ("X", 3)),
+        # No overflow
+        (("O", 0), ("A", 1), ("B", 2), ("F", 3), ("X", 4)),
+        # No overflow
+        (("O", 0), ("A", 1), ("U", 2), ("B", 3), ("U", 4), ("F", 5), ("X", 6)),
+    ]
+
+    for testcase in testcases:
+        original_frames = [
+            PollingFrame(type_, b"", timestamp)
+            for (type_, timestamp) in testcase
+        ]
+        # Test for case where none or all frames get expedited
+        for limit in range(len(original_frames)):
+            expedited_frames = apply_expedited_frame_ordering(
+                original_frames, limit=limit
+            )
+            restored_frames = apply_original_frame_ordering(expedited_frames)
+            assert original_frames == restored_frames
+
+
+# This should not raise anything when module is imported
+_test_apply_original_frame_ordering()
+
+
+_FRAME_EVENT_TIMEOUT_SEC = 1
+
+
+def poll_and_observe_frames(
+    pn532,
+    emulator,
+    testcases,
+    *,
+    restore_original_frame_ordering=False,
+    ignore_field_off_event_timeout=False,
+    **kwargs,
+):
+    """Handles broadcasting polling loop events for provided list of test cases.
+    Provided set of test cases MUST contain a complete polling loop, starting
+    with 'O' and ending with 'X' event.
+    """
+
+    assert len(testcases) > 2
+    assert testcases[0].configuration.type == "O"
+    assert testcases[-1].configuration.type == "X"
+
+    off_event_handler = None
+    for idx, testcase in enumerate(testcases):
+        configuration = testcase.configuration
+
+        # On last 'X' Event, create handler
+        if idx == len(testcases) - 1 and configuration.type == "X":
+            off_event_handler = emulator.asyncWaitForPollingFrameOff("XEvent")
+
+        time.sleep(GUARD_TIME_PER_TECH[configuration.type])
+
+        if configuration.type == "O":
+            pn532.unmute()
+        elif configuration.type == "X":
+            pn532.mute()
+        else:
+            if "power_level" in kwargs:
+                configuration = configuration.replace(
+                    power=kwargs["power_level"]
+                )
+            pn532.send_broadcast(
+                data=bytes.fromhex(testcase.data),
+                configuration=configuration
+            )
+        if configuration.type in {"O", "X"}:
+            time.sleep(GUARD_TIME_PER_TECH[configuration.type])
+
+    try:
+        if off_event_handler is not None:
+            off_event_handler.waitAndGet("XEvent", _FRAME_EVENT_TIMEOUT_SEC)
+    except (Exception, ) as e:
+        if not ignore_field_off_event_timeout:
+            emulator.log.warning( f"Timed out waiting for 'X' event due to {e}")
+
+    frames = [PollingFrame.from_dict(f) for f in emulator.getPollingFrames()]
+
+    if restore_original_frame_ordering:
+        # Attempt to revert expedited frame delivery ordering for U and F frames
+        # while keeping timestamp wrapping into account
+        frames = apply_original_frame_ordering(frames)
+
+    return frames
+
+
+def get_frame_test_stats(testcases, frames, timestamps=()):
+    """Creates a dict containing test info for error output"""
+    if len(timestamps) == 0:
+        timestamps = [-1] * len(testcases)
+
+    return  {
+        "frames_sent_count": len(testcases),
+        "frames_received_count": len(frames),
+        "frames_sent": [
+            testcase.format_for_error(timestamp=timestamp)
+            for timestamp, testcase in zip(timestamps, testcases)
+        ],
+        "frames_received": [frame.to_dict() for frame in frames],
+    }
diff --git a/testutils/pn532/nfcutils/reader.py b/testutils/pn532/nfcutils/reader.py
new file mode 100644
index 00000000..04d5cbfb
--- /dev/null
+++ b/testutils/pn532/nfcutils/reader.py
@@ -0,0 +1,88 @@
+from dataclasses import dataclass
+from typing import Optional
+from abc import ABCMeta, abstractmethod
+
+
+@dataclass
+class TransceiveConfiguration:
+    """Defines settings used for NFC communication"""
+    type: str
+    crc: int = True
+    bits: int = 8
+    bitrate: int = 106
+    timeout: float = None
+    # Output power as a percentage of maximum supported by the reader
+    power: float = 100
+
+    def replace(self, **kwargs):
+        """Return a new instance with specific values replaced by name."""
+        return self.__class__(**{
+            "type": self.type,
+            "crc": self.crc,
+            "bits": self.bits,
+            "bitrate": self.bitrate,
+            "timeout": self.timeout,
+            "power": self.power,
+            **kwargs
+        })
+
+
+CARRIER = 13.56e6
+A_TIMEOUT = (1236 + 384) / CARRIER
+CONFIGURATION_A_LONG = TransceiveConfiguration(
+    type="A", crc=True, bits=8, timeout=A_TIMEOUT
+)
+
+
+class ReaderTag(metaclass=ABCMeta):
+    """Describes a generic target which implements ISODEP protocol"""
+
+    @abstractmethod
+    def transact(self, command_apdus, response_apdus):
+        """Sends command_apdus and verifies reception of matching response_apdus
+        """
+
+
+class Reader(metaclass=ABCMeta):
+    """Describes a generic NFC reader which can be used for running tests"""
+
+    @abstractmethod
+    def poll_a(self) -> Optional[ReaderTag]:
+        """Attempts to perform target discovery by issuing Type A WUP/REQ
+        and performing anticollision in case one is detected.
+        Returns a tag object if one was found, None otherwise
+        """
+
+    @abstractmethod
+    def poll_b(self) -> Optional[ReaderTag]:
+        """Attempts to perform target discovery by issuing Type B WUP/REQ
+        and performing anticollision in case one is detected.
+        Returns a tag object if one was found, None otherwise
+        """
+
+    @abstractmethod
+    def send_broadcast(
+        self,
+        data: bytes, *,
+        configuration: TransceiveConfiguration = CONFIGURATION_A_LONG
+    ):
+        """Broadcasts a custom data frame into the RF field.
+        Does not require an active target to be detected to do that.
+        By default, uses 'Long A' frame configuration, which can be overridden.
+        """
+
+    @abstractmethod
+    def mute(self):
+        """Disables the RF field generated by the reader"""
+
+    @abstractmethod
+    def unmute(self):
+        """Enables the RF field generated by the reader"""
+
+    @abstractmethod
+    def reset(self):
+        """Auxiliary function to reset reader to starting conditions"""
+
+    def reset_buffers(self):
+        """Forwards a call to .reset() for compatibility reasons"""
+        self.reset()
diff --git a/testutils/pn532/pn532.py b/testutils/pn532/pn532.py
index 7c8d9a27..18b68c56 100644
--- a/testutils/pn532/pn532.py
+++ b/testutils/pn532/pn532.py
@@ -15,45 +15,300 @@
 # Lint as: python3
 
 import logging
-import serial
-from . import tag
+import struct
+from typing import Optional, Dict
+from enum import IntEnum
 from binascii import hexlify
+
+import serial
+
 from serial.tools.list_ports import comports
 from mobly import logger as mobly_logger
 
-GET_FIRMWARE_VERSION = 0x02
-SAM_CONFIGURATION = 0x14
-RF_CONFIGURATION = 0x32
-IN_DATA_EXCHANGE = 0x40
-IN_COMMUNICATE_THRU = 0x42
-IN_LIST_PASSIVE_TARGET = 0x4A
-WRITE_REGISTER = 0x08
-LONG_PREAMBLE = bytearray(20)
-TG_INIT_AS_TARGET = 0x8C
+from .tag import TypeATag, TypeBTag
+from .nfcutils import ByteStruct, snake_to_camel, s_to_us
+from .nfcutils.reader import Reader, CONFIGURATION_A_LONG
+
+
+_LONG_PREAMBLE = bytes(20)
+_ACK_FRAME = bytes.fromhex("0000ff00ff00")
+_SOF = bytes.fromhex("0000ff")
+
+
+_BITRATE = {106: 0b000, 212: 0b001, 424: 0b010, 848: 0b011}
+# Framing values defined in PN532_C1, 8.6.23
+_FRAMING = {"A": 0b00, "DEP": 0b01, "F": 0b10, "B": 0b11}
+# Timeout values defined in UM0701-02, Table 17,
+# from 100 s (n=1) up to 3.28 sec (n=16)
+_TIMEOUT = {n: 100 * 2 ** (n - 1) for n in range(0x01, 0x10)}
+
+
+# Picked manually, might not be the best combinations
+_POWER_LEVELS_TO_P_N_DRIVER_CONFIGS = {
+    # No frames should be detected
+    0: (0b000000, 0b0000),
+    # A, F detected with gain 1-3
+    20: (0b000001, 0b0001),
+    # A, F detected with gain 4-5
+    40: (0b000010, 0b0010),
+    # A, F detected with gain 5-6
+    60: (0b000011, 0b0100),
+    # A, F, detected with gain 7-8
+    80: (0b001000, 0b1000),
+    # A, B, F detected with gain 9
+    100: (0b111111, 0b1111)
+}
+
+
+class Command(IntEnum):
+    """https://www.nxp.com/docs/en/user-guide/141520.pdf
+    UM0701-02
+    """
+
+    DIAGNOSE = 0x00
+    GET_FIRMWARE_VERSION = 0x02
+    GET_GENERAL_STATUS = 0x04
+
+    READ_REGISTER = 0x06
+    WRITE_REGISTER = 0x08
+
+    SAM_CONFIGURATION = 0x14
+    POWER_DOWN = 0x16
+
+    RF_CONFIGURATION = 0x32
 
-def crc16a(data):
-    w_crc = 0x6363
-    for byte in data:
-        byte = byte ^ (w_crc & 0x00FF)
-        byte = (byte ^ (byte << 4)) & 0xFF
-        w_crc = ((w_crc >> 8) ^ (byte << 8) ^ (byte << 3) ^ (byte >> 4)) & 0xFFFF
-    return bytes([w_crc & 0xFF, (w_crc >> 8) & 0xFF])
+    IN_JUMP_FOR_DEP = 0x56
+    IN_JUMP_FOR_PSL = 0x46
+    IN_LIST_PASSIVE_TARGET = 0x4A
 
+    IN_DATA_EXCHANGE = 0x40
+    IN_COMMUNICATE_THRU = 0x42
 
-def with_crc16a(data):
-    return bytes(data) + crc16a(data)
+    IN_DESELECT = 0x44
+    IN_RELEASE = 0x52
+    IN_SELECT = 0x54
 
+    IN_AUTO_POLL = 0x60
 
-class PN532:
+    TG_INIT_AS_TARGET = 0x8C
+    TG_SET_GENERAL_BYTES = 0x92
+    TG_GET_DATA = 0x86
+    TG_SET_DATA = 0x8E
+    TG_SET_METADATA = 0x94
+    TG_GET_INITIATOR_COMMAND = 0x88
+    TG_RESPONSE_TO_INITIATOR = 0x90
+    TG_GET_TARGET_STATUS = 0x8A
+
+
+_BS = ByteStruct.of
+
+
+class Register(IntEnum):
+    """https://www.nxp.com/docs/en/nxp/data-sheets/PN532_C1.pdf
+    PN532/C1
+    8.6.22 CIU memory map
+    8.7.1  Standard registers
+    """
+
+    structure: ByteStruct
+
+    def __new__(cls, address: int, structure: Optional[ByteStruct] = None):
+        obj = int.__new__(cls, address)
+        obj._value_ = address
+        obj.structure = None
+        return obj
+
+    def __init__(self, _, structure: Optional[ByteStruct] = None):
+        # When initializing, we already know the name, so we're able to
+        # generate a nice name for matching ByteStruct
+        name = snake_to_camel(self.name.lower(), lower=False)
+        self.structure = ByteStruct.of(
+            name, **(structure.fields if structure else {"value": (7, 0)})
+        )
+
+    COMMAND = 0x6331
+    COMM_I_EN = 0x6332
+    DIV_I_EN = 0x6333
+    COMM_I_RQ = 0x6334
+    DIV_I_RQ = 0x6335
+    ERROR = 0x6336
+    WATER_LEVEL = 0x633B
+    # (8.6.23.14) Control
+    CONTROL = 0x633C, _BS(
+        t_stop_now=7,
+        t_start_now=6,
+        wr_nfcip1_id_to_fifo=5,
+        initiator=4,
+        rfu=3,
+        rx_last_bits=(2, 0),
+    )
+    # (8.6.23.15) BitFraming
+    BIT_FRAMING = 0x633D, _BS(
+        start_send=7, rx_align=(6, 4), rfu=3, tx_last_bits=(2, 0)
+    )
+    # (8.6.23.16) Coll
+    COLL = 0x633E, _BS(
+        values_after_coll=7,
+        rfu=6,
+        coll_pos_not_valid=5,
+        coll_pos=(4, 0),
+    )
+    # (8.6.23.17) Mode
+    MODE = 0x6301, _BS(
+        msb_first=7,
+        detect_sync=6,
+        tx_wait_rf=5,
+        rx_wait_rf=4,
+        pol_sigin=3,
+        mode_det_off=2,
+        crc_preset=(1, 0),
+    )
+    # (8.6.23.18) TxMode
+    TX_MODE = 0x6302, _BS(
+        crc_en=7, speed=(6, 4), inv_mod=3, mix=2, framing=(1, 0)
+    )
+    # (8.6.23.19) RxMode
+    RX_MODE = 0x6303, _BS(
+        crc_en=7, speed=(6, 4), no_err=3, multiple=2, framing=(1, 0)
+    )
+    # (8.6.23.20) TxControl
+    TX_CONTROL = 0x6304, _BS(
+        inv_tx2_rf_on=7,
+        inv_tx1_rf_on=6,
+        inv_tx2_rf_off=5,
+        inv_tx1_rf_off=4,
+        tx2_cw=3,
+        check_rf=2,
+        tx2_rf_en=1,
+        tx1_rf_en=0,
+    )
+    # (8.6.23.21) TxAuto
+    TX_AUTO = 0x6305, _BS(
+        auto_rf_off=7,
+        force_100_ask=6,
+        auto_wake_up=5,
+        rfu=4,
+        ca_on=3,
+        initial_rf_on=2,
+        tx2_rf_auto_en=1,
+        tx1_rf_auto_en=0,
+    )
+    TX_SEL = 0x6306
+    RX_SEL = 0x6307
+    # (8.6.23.24) RxThreshold
+    RX_THRESHOLD = 0x6308, _BS(min_level=(7, 4), rfu=3, col_level=(2, 0))
+    # (8.6.23.25) Demod
+    DEMOD = 0x6309, _BS(
+        add_iq=(7, 6), fix_iq=5, tau_rcv=(3, 2), tau_sync=(1, 0)
+    )
+    MANUAL_RCV = 0x630D
+    TYPE_B = 0x630E
+    # (8.6.23.33) GsNOff
+    GS_N_OFF = 0x6313, _BS(cw_gs_n_off=(7, 4), mod_gs_n_off=(3, 0))
+    # (8.6.23.34) ModWidth
+    MOD_WIDTH = 0x6314, _BS(mod_width=(7, 0))
+    # (8.6.23.35) TxBitPhase
+    TX_BIT_PHASE = 0x6315, _BS(rcv_clk_change=7, tx_bit_phase=(6, 0))
+    # (8.6.23.36) RfCfg
+    RF_CFG = 0x6316, _BS(rf_level_amp=7, rx_gain=(6, 4), rf_level=(3, 0))
+    # (8.6.23.37) GsNOn
+    GS_N_ON = 0x6317, _BS(cw_gs_n_on=(7, 4), mod_gs_n_on=(3, 0))
+    # (8.6.23.38) CWGsP
+    CW_GS_P = 0x6318, _BS(rfu=(7, 6), cw_gs_p=(5, 0))
+    # (8.6.23.39) ModGsP
+    MOD_GS_P = 0x6319, _BS(rfu=(7, 6), mod_gs_p=(5, 0))
+
+
+REG = Register
+
+
+REGISTER_VALUES_FOR_TRANSCEIVE = {
+    # The following registers are configured for transmit
+    # based on register states after using IN_LIST_PASSIVE_TARGET
+    REG.CONTROL: REG.CONTROL.structure(initiator=True),
+    REG.TX_CONTROL: REG.TX_CONTROL.structure(
+        inv_tx2_rf_on=True,
+        tx2_rf_en=True,
+        tx1_rf_en=True,
+    ),
+    REG.RX_THRESHOLD: REG.RX_THRESHOLD.structure(
+        min_level=0b1000, col_level=0b101
+    ),
+    REG.GS_N_OFF: REG.GS_N_OFF.structure(
+        cw_gs_n_off=0b0110, mod_gs_n_off=0b1111
+    ),
+}
+
+
+class RFConfigItem(IntEnum):
+    """https://www.nxp.com/docs/en/user-guide/141520.pdf
+    UM0701-02
+    7.3.1 RFConfiguration
+    """
+
+    RF_FIELD = 0x01  # ConfigurationData
+    VARIOUS_TIMINGS = 0x02  # RFU, fATR_RES_Timeout, fRetryTimeout
+    # 0x03 RFU
+    MAX_RTY_COM = 0x04  # MaxRtyCOM
+    MAX_RETRIES = 0x05  # MxRtyATR, MxRtyPSL, MxRtyPassiveActivation
+
+
+class BrTy(IntEnum):
+    """https://www.nxp.com/docs/en/user-guide/141520.pdf
+    UM0701-02
+    7.3.5 InListPassiveTarget
+    """
+
+    # InitiatorData is optional and may contain a UID to initialize
+    TYPE_A_106 = 0x00
+    # InitiatorData contains "Polling" command payload
+    TYPE_F_212 = 0x01
+    TYPE_F_424 = 0x02
+    # InitiatorData contains AFI and optional polling method byte
+    TYPE_B_106 = 0x03
+    # InitiatorData field unused
+    TYPE_A_JEWEL = 0x04
+
+
+class Status(IntEnum):
+    """https://www.nxp.com/docs/en/user-guide/141520.pdf
+    UM0701-02
+    7.1 Error Handling
+    """
+
+    OK = 0x00
+    TIME_OUT = 0x01
+    CRC_ERROR = 0x02
+    PARITY_ERROR = 0x03
+    ERRONEOUS_BIT_COUNT = 0x04
+    MIFARE_FRAMING_ERROR = 0x05
+    BIT_COLLISION = 0x06
+    COMMUNICATION_BUFFER_SIZE_INSUFFICIENT = 0x07
+    RF_BUFFER_OVERFLOW = 0x09
+    RF_PROTOCOL_ERROR = 0x0B
+    TEMPERATURE_ERROR = 0x0D
+    INTERNAL_BUFFER_OVERFLOW = 0x0E
+    INVALID_PARAMETER = 0x10
+
+
+class PN532(Reader):
+    """Implements an NFC reader with a PN532 chip"""
 
     def __init__(self, path):
-        """Initializes device on path, or first available serial port if none is provided."""
+        """Initializes device on path,
+        or first available serial port if none is provided."""
         if len(comports()) == 0:
             raise IndexError(
-                "Could not find device on serial port, make sure reader is plugged in."
+                "Could not find device on serial port"
+                + ", make sure reader is plugged in."
             )
         if len(path) == 0:
             path = comports()[0].device
+
+        self.register_cache = {}
+        self.rf_configuration_cache = {}
+        self.write_long_preamble = True
+
         self.log = mobly_logger.PrefixLoggerAdapter(
             logging.getLogger(),
             {
@@ -66,203 +321,416 @@ class PN532:
         self.device = serial.Serial(path, 115200, timeout=0.5)
 
         self.device.flush()
-        self.device.write(LONG_PREAMBLE + bytearray.fromhex("0000ff00ff00"))
+        self._send_ack_frame()
         self.device.flushInput()
         if not self.verify_firmware_version():
-            raise RuntimeError("Could not verify PN532 firmware on serial path " + path)
-        rsp = self.send_frame(
-            LONG_PREAMBLE + self.construct_frame([SAM_CONFIGURATION, 0x01, 0x00]),
-            1,
+            raise RuntimeError(
+                "Could not verify PN532 firmware on serial path " + path
             )
-        if not rsp:
-            raise RuntimeError("No response for SAM configuration.")
+        self.sam_configuration(mode=0x01, timeout_value=0x00)
+
+        self.write_long_preamble = False
 
         # Disable retries
         self.device.flushInput()
-        rsp = self.send_frame(
-            self.construct_frame(
-                [
-                    RF_CONFIGURATION,
-                    0x05,
-                    0x00,  # MxRtyATR
-                    0x00,  # MxRtyPSL
-                    0x00,  # MxRtyPassiveActivation
-                ]
-            ),
-            1,
+        self.rf_configuration(
+            RFConfigItem.MAX_RETRIES,
+            [
+                0x00,  # MxRtyATR
+                0x00,  # MxRtyPSL
+                0x00,  # MxRtyPassiveActivation
+            ],
         )
-        if not rsp:
-            raise RuntimeError("No response for RF configuration.")
 
-    def verify_firmware_version(self):
-        """Verifies we are talking to a PN532."""
-        self.log.debug("Checking firmware version")
-        rsp = self.send_frame(
-            LONG_PREAMBLE + self.construct_frame([GET_FIRMWARE_VERSION])
+    # Custom functions
+
+    def poll_a(self):
+        """Attempts to detect target for NFC type A."""
+        self.log.debug("Polling A")
+        tag = self.in_list_passive_target(br_ty=BrTy.TYPE_A_106)
+        if tag:
+            self.log.debug(f"Got Type A tag, SEL_RES={tag.sel_res}")
+        return tag
+
+    def poll_b(self):
+        """Attempts to detect target for NFC type B."""
+        self.log.debug("Polling B")
+        afi = 0x00
+        tag = self.in_list_passive_target(
+            br_ty=BrTy.TYPE_B_106, initiator_data=(afi,)
+        )
+        if tag:
+            self.log.debug(f"Got Type B tag {tag.sensb_res}")
+        return tag
+
+    def send_broadcast(
+        self,
+        data: bytes,
+        *,
+        configuration=CONFIGURATION_A_LONG
+    ):
+        """Emits a broadcast frame into the polling loop"""
+        self.log.debug("Sending broadcast %s", hexlify(data).decode())
+        return self.transceive_raw(
+            data=data,
+            type_=configuration.type,
+            crc=configuration.crc,
+            bits=configuration.bits,
+            bitrate=configuration.bitrate,
+            timeout=configuration.timeout or 0.25,
+            power_level=configuration.power,
         )
 
-        if not rsp:
-            raise RuntimeError("No response for GetFirmwareVersion")
+    def mute(self):
+        """Turns off device's RF antenna."""
+        self.log.debug("Muting")
+        self.rf_configuration(RFConfigItem.RF_FIELD, [0b10])
 
-        if rsp[0] != GET_FIRMWARE_VERSION + 1 or len(rsp) != 5:
-            self.log.error("Got unexpected response for GetFirmwareVersion")
-            return False
+    def unmute(self, auto_rf_ca=False):
+        """Turns on device's RF antenna."""
+        self.log.debug("Unmuting")
+        self.rf_configuration(RFConfigItem.RF_FIELD, [(auto_rf_ca << 1) + 0b01])
 
-        return rsp[1] == 0x32
+    def reset(self):
+        """Clears out input and output buffers to expunge leftover data"""
+        self.device.reset_input_buffer()
+        self.device.reset_output_buffer()
 
-    def poll_a(self):
-        """Attempts to detect target for NFC type A."""
-        self.log.debug("Polling A")
-        rsp = self.send_frame(
-            self.construct_frame([IN_LIST_PASSIVE_TARGET, 0x01, 0x00])
+    # Special commands
+
+    def transceive_raw(
+        self,
+        data,
+        type_="A",
+        crc=True,
+        bits=8,
+        bitrate=106,
+        *,
+        timeout=1,
+        power_level=100,
+        cache_configuration=True,
+    ):
+        """Configures the CIU with specified configuration and sends raw data
+        :param timeout: Timeout in seconds
+        :param cache_configuration: if true, prevents redundant writes & reads
+        """
+        # Choose the least index of timeout duration
+        # where result >= given value. Timeout is in s.
+        # If timeout value is too big, or <= 0,
+        # fall back to maximum timeout duration
+        timeout_index = next(
+            (idx for idx, t in _TIMEOUT.items() if t >= s_to_us(timeout)), 0x10
+        )
+        self.rf_configuration(
+            RFConfigItem.VARIOUS_TIMINGS,
+            [
+                0x00,  # RFU
+                0x0B,  # ATR_RES TimeOut, default value is 0x0B
+                timeout_index,
+            ],
+            cache=cache_configuration,
         )
-        if not rsp:
-            raise RuntimeError("No response for send poll_a frame.")
 
-        if rsp[0] != IN_LIST_PASSIVE_TARGET + 1:
-            self.log.error("Got unexpected command code in response")
-        del rsp[0]
 
-        num_targets = rsp[0]
-        if num_targets == 0:
-            return None
-        del rsp[0]
+        p_n_config = next(
+            (
+                config
+                for power, config in _POWER_LEVELS_TO_P_N_DRIVER_CONFIGS.items()
+                if power >= power_level
+            ),
+            _POWER_LEVELS_TO_P_N_DRIVER_CONFIGS[0]
+        )
+        p_driver_conductance_level, n_driver_conductance_level = p_n_config
+
+
+        (
+            tx_mode, rx_mode, tx_auto, bit_frm,
+            gs_n_on, cw_gs_p, md_gs_p,
+            rf_cfg, tx_bit_phase, demod,
+        ) = self.read_registers(
+            REG.TX_MODE, REG.RX_MODE, REG.TX_AUTO, REG.BIT_FRAMING,
+            REG.GS_N_ON, REG.CW_GS_P, REG.MOD_GS_P,
+            REG.RF_CFG, REG.TX_BIT_PHASE, REG.DEMOD,
+            cache=cache_configuration,
+        )
 
-        target_id = rsp[0]
-        del rsp[0]
+        # The following register modifications are based on register state
+        # modifications when performing IN_LIST_PASSIVE_TARGET and communication
+        registers_to_write = {
+            REG.TX_MODE: tx_mode.replace(
+                crc_en=crc, speed=_BITRATE[bitrate], framing=_FRAMING[type_]
+            ),
+            REG.RX_MODE: rx_mode.replace(
+                crc_en=crc, speed=_BITRATE[bitrate], framing=_FRAMING[type_]
+            ),
+            REG.TX_AUTO: tx_auto.replace(force_100_ask=type_ == "A"),
+            REG.BIT_FRAMING: bit_frm.replace(tx_last_bits=bits & 0b111),
+            REG.GS_N_ON: gs_n_on.replace(
+                mod_gs_n_on=0b0100 if type_ == "A" else 0b1111,
+                cw_gs_n_on=n_driver_conductance_level & 0b1111,
+            ),
+            REG.CW_GS_P: cw_gs_p.replace(
+                cw_gs_p=p_driver_conductance_level & 0b111111
+            ),
+            REG.MOD_GS_P: md_gs_p.replace(
+                mod_gs_p=0b010111 if type_ == "B" else 0b010001
+            ),
+            REG.RF_CFG: rf_cfg.replace(
+                rx_gain=0b110 if type_ == "F" else 0b101,
+                rf_level=0b1001,
+            ),
+            REG.TX_BIT_PHASE: tx_bit_phase.replace(
+                rcv_clk_change=1,
+                tx_bit_phase=0b1111 if type_ == "F" else 0b0111,
+            ),
+            REG.DEMOD: demod.replace(
+                add_iq=0b01,
+                tau_rcv=0b00 if type_ == "F" else 0b11,
+                tau_sync=0b01,
+            ),
+            **REGISTER_VALUES_FOR_TRANSCEIVE,
+        }
 
-        sense_res = rsp[0:2]
-        del rsp[0:2]
+        self.write_registers(registers_to_write, cache=cache_configuration)
 
-        sel_res = rsp[0]
-        self.log.debug("Got tag, SEL_RES is %02x", sel_res)
-        del rsp[0]
+        # Handle a special case for FeliCa, where length byte has to be present
+        if type_ == "F":
+            data = [len(data) + 1, *data]
 
-        nfcid_len = rsp[0]
-        del rsp[0]
-        nfcid = rsp[0:nfcid_len]
-        del rsp[0:nfcid_len]
+        # No data is OK for this use case
+        return self.in_communicate_thru(data, raise_on_error_status=False)
 
-        ats_len = rsp[0]
-        del rsp[0]
-        ats = rsp[0 : ats_len - 1]
-        del rsp[0 : ats_len - 1]
+    def verify_firmware_version(self):
+        """Verifies we are talking to a PN532."""
+        self.log.debug("Checking firmware version")
+        rsp = self.get_firmware_version()
+        return rsp[0] == 0x32
 
-        return tag.TypeATag(self, target_id, sense_res, sel_res, nfcid, ats)
+    # PN532 defined commands
 
     def initialize_target_mode(self):
         """Configures the PN532 as target."""
         self.log.debug("Initializing target mode")
-        self.send_frame(
-            self.construct_frame([TG_INIT_AS_TARGET,
-                                  0x05, #Mode
-                                  0x04, #SENS_RES (2 bytes)
-                                  0x00,
-                                  0x12, #nfcid1T (3 BYTES)
-                                  0x34,
-                                  0x56,
-                                  0x20, #SEL_RES
-                                  0x00, #FeliCAParams[] (18 bytes)
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,#NFCID3T[] (10 bytes)
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00,
-                                  0x00, #LEN Gt
-                                  0x00, #LEN Tk
-                                  ]))
+        self._execute_command(
+            Command.TG_INIT_AS_TARGET,
+            [
+                0x05,  # Mode
+                0x04,  # SENS_RES (2 bytes)
+                0x00,
+                0x12,  # nfcid1T (3 BYTES)
+                0x34,
+                0x56,
+                0x20,  # SEL_RES
+                0x00,  # FeliCAParams[] (18 bytes)
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,  # NFCID3T[] (10 bytes)
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,
+                0x00,  # LEN Gt
+                0x00,  # LEN Tk
+            ],
+        )
 
-    def poll_b(self):
-        """Attempts to detect target for NFC type B."""
-        self.log.debug("Polling B")
-        rsp = self.send_frame(
-            self.construct_frame([IN_LIST_PASSIVE_TARGET, 0x01, 0x03, 0x00])
+    def sam_configuration(self, mode=0x01, timeout_value=0x00):
+        """(7.2.10) SAMConfiguration"""
+        return self._execute_command(
+            Command.SAM_CONFIGURATION,
+            [mode, timeout_value],
+            timeout=1,
+            min_response=0,
         )
-        if not rsp:
-            raise RuntimeError("No response for send poll_b frame.")
 
-        if rsp[0] != IN_LIST_PASSIVE_TARGET + 1:
-            self.log.error("Got unexpected command code in response")
-        del rsp[0]
+    def get_firmware_version(self):
+        """(7.2.2) GetFirmwareVersion"""
+        return self._execute_command(
+            Command.GET_FIRMWARE_VERSION, min_response=4
+        )
+
+    def in_data_exchange(
+        self, tg, data, *, timeout=3, raise_on_error_status=True
+    ):
+        """(7.3.8) InDataExchange"""
+        rsp = self._execute_command(
+            Command.IN_DATA_EXCHANGE,
+            [tg, *data],
+            timeout=timeout,
+        )
+        if rsp is None or rsp[0] != Status.OK:
+            if raise_on_error_status:
+                raise RuntimeError(f"No response to {data}; {rsp}")
+            self.log.error("Got error exchanging data")
+            return None
+        return rsp[1:]
+
+    def in_communicate_thru(
+        self, data, *, timeout=1, raise_on_error_status=True
+    ):
+        """(7.3.9) InCommunicateThru"""
+        rsp = self._execute_command(
+            Command.IN_COMMUNICATE_THRU, data, min_response=1, timeout=timeout
+        )
+        if rsp[0] != Status.OK:
+            if raise_on_error_status:
+                raise RuntimeError(f"No response to {data}; {rsp}")
+            return None
+        return rsp[1:]
+
+    def in_list_passive_target(
+        self, br_ty: BrTy, initiator_data: bytes = b"", max_tg=1
+    ):
+        """(7.3.5) InListPassiveTarget
+        If max_tg=1, returns a tag or None if none was found,
+        Otherwise, returns a list
+        """
+        # Reset cache values as IN_LIST_PASSIVE_TARGET modifies them
+        self.register_cache = {}
+        self.rf_configuration_cache = {}
+
+        rsp = self._execute_command(
+            Command.IN_LIST_PASSIVE_TARGET,
+            [max_tg, br_ty, *initiator_data],
+            min_response=1,
+        )
 
-        afi = rsp[0]
+        if rsp[0] == 0:
+            return [] if max_tg > 1 else None
 
-        deselect_command = 0xC2
-        self.send_broadcast(bytearray(deselect_command))
+        data = rsp[1:]
 
-        wupb_command = [0x05, afi, 0x08]
-        self.send_frame(
-            self.construct_frame([WRITE_REGISTER, 0x63, 0x3D, 0x00])
-        )
-        rsp = self.send_frame(
-            self.construct_frame(
-                [IN_COMMUNICATE_THRU] + list(with_crc16a(wupb_command))
+        tags = []
+        offset = 0
+
+        tag_for_brty = {
+            BrTy.TYPE_A_106: TypeATag,
+            BrTy.TYPE_B_106: TypeBTag
+        }
+
+        if br_ty not in tag_for_brty:
+            raise RuntimeError(f"BrTy {br_ty} not supported yet")
+
+        while offset <= len(data) - 1:
+            tag, offset = tag_for_brty[br_ty].from_target_data(
+                self, data[offset:]
             )
-        )
-        if not rsp:
-            raise RuntimeError("No response for WUPB command")
+            tags.append(tag)
 
-        return tag.TypeBTag(self, 0x03, rsp)
+        if max_tg == 1:
+            return tags[0]
+        return tags
 
-    def send_broadcast(self, broadcast):
-        """Emits broadcast frame with CRC. This should be called after poll_a()."""
-        self.log.debug("Sending broadcast %s", hexlify(broadcast).decode())
+    def read_registers(self, *registers: Register, cache=False):
+        """(7.2.4) ReadRegister:
+        Reads CIU registers
+         :param registers: an iterable containing addresses of registers to read
+         :param cache: prevents redundant register reads
+        """
+        if cache and all(
+            Register(register) in self.register_cache for register in registers
+        ):
+            return [self.register_cache[register] for register in registers]
+        data = b"".join(struct.pack(">H", register) for register in registers)
+        rsp = self._execute_command(Command.READ_REGISTER, data)
+        if not rsp:
+            raise RuntimeError(f"No response for read registers {registers}.")
+        return list(
+            register.structure(byte) for byte, register in zip(rsp, registers)
+        )
 
-        # Adjust bit framing so all bytes are transmitted
-        self.send_frame(self.construct_frame([WRITE_REGISTER, 0x63, 0x3D, 0x00]))
-        rsp = self.send_frame(
-            self.construct_frame([IN_COMMUNICATE_THRU] + list(with_crc16a(broadcast)))
+    def write_registers(
+        self, registers: Dict[Register, int], cache=False
+    ) -> None:
+        """(7.2.5) WriteRegister:
+        Writes CIU registers
+         :param registers: dictionary containing key-value pairs
+         of register addresses and values to be written
+         :param cache: prevents redundant register writes
+        """
+        # If not caching, assume all are different
+        difference = {
+            reg: val
+            for reg, val in registers.items()
+            if not cache or self.register_cache.get(reg) != val
+        }
+        if not difference:
+            return
+        data = b"".join(
+            struct.pack(">HB", reg, val) for reg, val in difference.items()
         )
-        if not rsp:
-            raise RuntimeError("No response for send broadcast.")
+        self._execute_command(Command.WRITE_REGISTER, data)
+        self.register_cache = {**self.register_cache, **registers}
+
+    def rf_configuration(
+        self, cfg_item: RFConfigItem, value: int, *, cache=False
+    ):
+        """(7.3.1) RFConfiguration
+        Applies settings to one of the available configuration items
+        :param cache: prevents redundant config writes
+        """
+        if cache and self.rf_configuration_cache.get(cfg_item) == value:
+            return
+        self._execute_command(
+            Command.RF_CONFIGURATION, [cfg_item, *value], min_response=0
+        )
+        self.rf_configuration_cache[cfg_item] = value
 
-    def transceive(self, data):
-        """Sends data to device and returns response."""
-        self.log.debug("Transceive")
-        rsp = self.send_frame(self.construct_frame([IN_DATA_EXCHANGE] + list(data)), 5)
+    # Internal communication commands
+
+    def _execute_command(
+        self, command: Command, data=b"", *, timeout=0.5, min_response=None
+    ):
+        """Executes the provided command
+        Verifies that response code matches the command code if response arrived
+        If min_response is set, checks if enough data was returned
+        """
+        rsp = self._send_frame(
+            self._construct_frame([command, *data]), timeout=timeout
+        )
 
         if not rsp:
+            if min_response is not None:
+                raise RuntimeError(f"No response for {command.name}; {rsp}")
             return None
-
-        if rsp[0] != IN_DATA_EXCHANGE + 1:
-            self.log.error("Got unexpected command code in response")
+        if rsp[0] != command + 1:
+            raise RuntimeError(
+                f"Response code {rsp[0]} does not match the command {command}"
+            )
         del rsp[0]
 
-        if rsp[0] != 0:
-            self.log.error("Got error exchanging data")
-            return None
-        del rsp[0]
+        if isinstance(min_response, int) and len(rsp) < min_response:
+            raise RuntimeError(
+                f"Got unexpected response for {command.name}"
+                + f"; Length mismatch {len(rsp)} < {min_response}"
+                + f"; {bytes(rsp).hex()}"
+            )
 
         return rsp
 
-    def mute(self):
-        """Turns off device's RF antenna."""
-        self.log.debug("Muting")
-        self.send_frame(self.construct_frame([RF_CONFIGURATION, 0x01, 0x02]))
+    # Protocol communication methods
 
-    def construct_frame(self, data):
+    def _construct_frame(self, data):
         """Construct a data fram to be sent to the PN532."""
         # Preamble, start code, length, length checksum, TFI
         frame = [
@@ -272,7 +740,7 @@ class PN532:
             (len(data) + 1) & 0xFF,
             ((~(len(data) + 1) & 0xFF) + 0x01) & 0xFF,
             0xD4,
-            ]
+        ]
         data_sum = 0xD4
 
         # Add data to frame
@@ -282,24 +750,31 @@ class PN532:
         frame.append(((~data_sum & 0xFF) + 0x01) & 0xFF)  # Data checksum
 
         frame.append(0x00)  # Postamble
-        self.log.debug("Constructed frame " + hexlify(bytearray(frame)).decode())
-
+        self.log.debug(
+            "Constructed frame " + hexlify(bytearray(frame)).decode()
+        )
         return bytearray(frame)
 
-    def send_frame(self, frame, timeout=0.5):
-        """
-        Writes a frame to the device and returns the response.
-        """
+    def _write(self, frame):
+        """Performs serial writes
+        while handling config for sending long preambles"""
+        if self.write_long_preamble:
+            frame = _LONG_PREAMBLE + frame
         self.device.write(frame)
-        return self.get_device_response(timeout)
 
-    def reset_buffers(self):
-        self.device.reset_input_buffer()
-        self.device.reset_output_buffer()
+    def _send_frame(self, frame, timeout=0.5):
+        """Writes a frame to the device and returns the response."""
+        self._write(frame)
+        return self._get_device_response(timeout)
 
-    def get_device_response(self, timeout=0.5):
-        """
-        Confirms we get an ACK frame from device, reads response frame, and writes ACK.
+    def _send_ack_frame(self, timeout=0.5):
+        """Send ACK frame, there is no response."""
+        self.device.timeout = timeout
+        self._write(_ACK_FRAME)
+
+    def _get_device_response(self, timeout=0.5):
+        """onfirms we get an ACK frame from device.
+        Reads response frame, and writes ACK.
         """
         self.device.timeout = timeout
         frame = bytearray(self.device.read(6))
@@ -308,17 +783,20 @@ class PN532:
             self.log.error("Did not get response from PN532")
             return None
 
-        if hexlify(frame).decode() != "0000ff00ff00":
-            self.log.error("Did not get ACK frame, got %s", hexlify(frame).decode())
+        if bytes(frame) != _ACK_FRAME:
+            self.log.error(
+                "Did not get ACK frame, got %s", hexlify(frame).decode()
+            )
 
         frame = bytearray(self.device.read(6))
 
         if (len(frame)) == 0:
             return None
 
-        if hexlify(frame[0:3]).decode() != "0000ff":
+        if bytes(frame[0:3]) != _SOF:
             self.log.error(
-                "Unexpected start to frame, got %s", hexlify(frame[0:3]).decode()
+                "Unexpected start to frame, got %s",
+                hexlify(frame[0:3]).decode(),
             )
 
         data_len = frame[3]
@@ -345,13 +823,11 @@ class PN532:
         if postamble != 0x00:
             if tfi != 0xD5:
                 self.log.error(
-                    "Unexpected postamble byte when performing read, got %02x", frame[4]
+                    "Unexpected postamble byte when performing read, got %02x",
+                    frame[4],
                 )
 
-        self.device.timeout = 0.5
-        self.device.write(
-            bytearray.fromhex("0000ff00ff00")
-        )  # send ACK frame, there is no response.
+        self._send_ack_frame()
 
         self.log.debug(
             "Received frame %s%s",
diff --git a/testutils/pn532/src/com/android/nfc/pn532/PN532.kt b/testutils/pn532/src/com/android/nfc/pn532/PN532.kt
index 7a84d7cd..c4958956 100644
--- a/testutils/pn532/src/com/android/nfc/pn532/PN532.kt
+++ b/testutils/pn532/src/com/android/nfc/pn532/PN532.kt
@@ -18,6 +18,7 @@ package com.android.nfc.pn532
 import android.hardware.usb.UsbDevice
 import android.hardware.usb.UsbDeviceConnection
 import android.util.Log
+import com.google.errorprone.annotations.CanIgnoreReturnValue
 
 /**
  * Handles communication with PN532 given a UsbDevice and UsbDeviceConnection object. Relevant
@@ -31,9 +32,18 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
         transportLayer = TransportLayer(device, connection)
 
         // Wake up device and send initial configs
-        transportLayer.write(LONG_PREAMBLE + ACK)
-        sendFrame(constructFrame(byteArrayOf(SAM_CONFIGURATION, 0x01, 0x00)))
-        sendFrame(constructFrame(byteArrayOf(RF_CONFIGURATION, 0x05, 0x01, 0x00, 0x01)))
+        val rsp = transportLayer.write(LONG_PREAMBLE + ACK)
+        if (!rsp) {
+            Log.e(TAG, "Got error while waking device up.")
+        }
+        val samRsp = sendFrame(constructFrame(byteArrayOf(SAM_CONFIGURATION, 0x01, 0x00)))
+        if (samRsp == null) {
+            Log.e(TAG, "Did not get a response after sending SAM config command")
+        }
+        val rfRsp = sendFrame(constructFrame(byteArrayOf(RF_CONFIGURATION, 0x05, 0x01, 0x00, 0x01)))
+        if (rfRsp == null) {
+            Log.e(TAG, "Did not get a response after sending RF config command")
+        }
     }
 
     /** Polls for NFC Type-A. Returns tag if discovered. */
@@ -95,20 +105,30 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
     /** Polls for NFC Type-B */
     fun pollB() {
         Log.d(TAG, "Polling B")
-        sendFrame(constructFrame(byteArrayOf(IN_LIST_PASSIVE_TARGET, 0x01, 0x03, 0x00)))
+        val rsp = sendFrame(constructFrame(byteArrayOf(IN_LIST_PASSIVE_TARGET, 0x01, 0x03, 0x00)))
+        if (rsp == null) {
+            Log.e(TAG, "Did not get a  response after sending polling command.")
+        }
     }
 
     /** Emits broadcast frame with CRC. Call this after pollA() to send a custom frame */
     fun sendBroadcast(broadcast: ByteArray) {
         Log.d(TAG, "sendBroadcast: " + broadcast.toHex())
-        sendFrame(constructFrame(byteArrayOf(WRITE_REGISTER, 0X63, 0X3D, 0X00)))
-        sendFrame(constructFrame(byteArrayOf(IN_COMMUNICATE_THRU) + withCrc16a(broadcast)))
+        val writeRsp = sendFrame(constructFrame(byteArrayOf(WRITE_REGISTER, 0X63, 0X3D, 0X00)))
+        if (writeRsp == null) {
+            Log.e(TAG, "Did not get valid response after sending WRITE_REGISTER command")
+        }
+        val broadcastRsp = sendFrame(constructFrame(byteArrayOf(IN_COMMUNICATE_THRU) +
+                withCrc16a(broadcast)))
+        if (broadcastRsp == null) {
+            Log.e(TAG, "Did not get valid response after sending broadcast")
+        }
     }
 
     /** Send command to PN-532 and receive response. */
     fun transceive(data: ByteArray): ByteArray? {
         Log.d(TAG, "Transceiving: " + data.toHex())
-        var response = sendFrame(constructFrame(byteArrayOf(IN_DATA_EXCHANGE) + data))
+        val response = sendFrame(constructFrame(byteArrayOf(IN_DATA_EXCHANGE) + data))
         if (response == null) return null
         Log.d(TAG, "Response: " + response.toHex())
 
@@ -125,9 +145,13 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
     /** Mute reader. Should be called after each polling loop. */
     fun mute() {
         Log.d(TAG, "Muting PN532")
-        sendFrame(constructFrame(byteArrayOf(RF_CONFIGURATION, 0x01, 0x02)))
+        val rsp = sendFrame(constructFrame(byteArrayOf(RF_CONFIGURATION, 0x01, 0x02)))
+        if (rsp == null) {
+            Log.e(TAG, "Did not get valid response after muting.")
+        }
     }
 
+    @CanIgnoreReturnValue
     private fun sendFrame(frame: ByteArray, timeout: Long = 500.toLong()): ByteArray? {
         transportLayer.write(frame)
         return getDeviceResponse(timeout)
@@ -139,7 +163,7 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
 
     private fun getDeviceResponse(timeoutMs: Long = 500.toLong()): ByteArray? {
         // First response from device should be ACK frame
-        var data = transportLayer.read(timeoutMs, numBytes = 255)
+        val data = transportLayer.read(timeoutMs, numBytes = MAX_READ_BUFFER_SIZE)
         if (data == null || data.size < 6) return null
 
         val firstFrame = data.slice(0..5).toByteArray()
@@ -156,7 +180,7 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
         // Some instances require a second read of data
         var secondRead = false
         if (responseFrame?.size == 0) {
-            responseFrame = transportLayer.read(timeoutMs, numBytes = 255)
+            responseFrame = transportLayer.read(timeoutMs, numBytes = MAX_READ_BUFFER_SIZE)
             secondRead = true
         }
         if (responseFrame == null || responseFrame.size == 0) {
@@ -185,48 +209,105 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
             Log.d(TAG, "Correct start to frame")
         }
 
-        val dataLength = responseFrame[3]
-        val lengthChecksum = responseFrame[4]
+        val isExtendedFrame = responseFrame.slice(3..4).toByteArray().toHex().contentEquals("ffff")
+        val expectedDataLength: UInt
+        if (isExtendedFrame) {
+            if (responseFrame.size < EXTENDED_FRAME_MIN_SIZE) {
+                Log.e(
+                TAG,
+                "Expected at least " +
+                    EXTENDED_FRAME_MIN_SIZE +
+                    " bytes of response data for extended frame. Got " +
+                    responseFrame.size,
+                )
+                return null
+            }
+            val dataLengthM = responseFrame[5]
+            val dataLengthL = responseFrame[6]
+            val lengthChecksum = responseFrame[7]
+            expectedDataLength = (dataLengthM.toUInt() shl 8) + dataLengthL.toUInt()
 
-        if ((lengthChecksum + dataLength) and 0xFF != 0) {
-            Log.e(
+            if ((lengthChecksum + dataLengthM + dataLengthL) and 0xFF != 0) {
+                Log.e(
                 TAG,
-                "Frame failed length checksum. lengthChecksum: " +
-                        lengthChecksum +
-                        ", dataLength: " +
-                        dataLength +
-                        ", responseFrame: " +
-                        responseFrame.toHex() +
-                        ", data: " +
-                        data,
-            )
+                "Extended Frame failed length checksum. lengthChecksum: " +
+                    lengthChecksum +
+                    ", dataLengthM: " +
+                    dataLengthM +
+                    ", dataLengthL: " +
+                    dataLengthL +
+                    ", responseFrame: " +
+                    responseFrame.toHex() +
+                    ", data: " +
+                    data,
+                )
+            }
+        } else {
+            if (responseFrame.size < NORMAL_FRAME_MIN_SIZE) {
+                Log.e(
+                TAG,
+                "Expected at least " +
+                    NORMAL_FRAME_MIN_SIZE +
+                    " bytes of response data for normal frame. Got " +
+                    responseFrame.size,
+                )
+                return null
+            }
+
+            val dataLength = responseFrame[3]
+            val lengthChecksum = responseFrame[4]
+            expectedDataLength = dataLength.toUByte().toUInt()
+
+            if ((lengthChecksum + dataLength) and 0xFF != 0) {
+                Log.e(
+                TAG,
+                "Normal Frame failed length checksum. lengthChecksum: " +
+                    lengthChecksum +
+                    ", dataLength: " +
+                    dataLength +
+                    ", responseFrame: " +
+                    responseFrame.toHex() +
+                    ", data: " +
+                    data,
+                )
+            }
         }
 
-        val tfi = responseFrame[5]
+        val tfi = if (isExtendedFrame) responseFrame[8] else responseFrame[5]
         if (tfi != 0xD5.toByte()) {
             Log.e(TAG, "Unexpected TFI Byte: Got " + tfi + ", expected 0xD5")
         }
 
-        var dataPacket: ByteArray?
-        var dataCheckSum: Byte
-        var postAmble: Byte
+        val dataPacket: ByteArray?
+        val dataCheckSum: Byte
+        val postAmble: Byte
         if (secondRead) {
-            dataPacket = responseFrame.slice(6..responseFrame.size - 3).toByteArray()
+            dataPacket =
+                if (isExtendedFrame) {
+                responseFrame.slice(9..responseFrame.size - 3).toByteArray()
+                } else {
+                responseFrame.slice(6..responseFrame.size - 3).toByteArray()
+                }
             dataCheckSum = responseFrame[responseFrame.size - 2]
             postAmble = responseFrame[responseFrame.size - 1]
         } else {
-            dataPacket = data.slice(12..data.size - 3).toByteArray()
+            dataPacket =
+                if (isExtendedFrame) {
+                data.slice(15..data.size - 3).toByteArray()
+                } else {
+                data.slice(12..data.size - 3).toByteArray()
+                }
             dataCheckSum = data[data.size - 2]
             postAmble = data[data.size - 1]
         }
 
-        if (dataPacket.size != 0 && dataPacket.size != dataLength.toInt() - 1) {
+        if (dataPacket.size != 0 && dataPacket.size.toUInt() != expectedDataLength - 1.toUInt()) {
             Log.e(
                 TAG,
                 "Unexpected data packet size: Got " +
-                        dataPacket.size +
+                        dataPacket.size.toUInt() +
                         ", expected " +
-                        (dataLength.toInt() - 1).toString() +
+                        (expectedDataLength - 1.toUInt()).toString() +
                         ",",
             )
         }
@@ -269,7 +350,7 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
     private fun crc16a(data: ByteArray): ByteArray {
         var w_crc = 0x6363
         for (byte in data) {
-            var newByte = byte.toInt() xor (w_crc and 0xFF).toInt()
+            var newByte = byte.toInt() xor (w_crc and 0xFF)
             newByte = (newByte xor newByte shl 4) and 0xFF
             w_crc = ((w_crc shr 8) xor (newByte shl 8) xor (newByte shl 3) xor (newByte shr 4)) and 0xFF
         }
@@ -282,15 +363,30 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
     }
 
     private fun constructFrame(data: ByteArray): ByteArray {
+        val isExtendedFrame = data.size > NORMAL_FRAME_DATA_SIZE
         var frame: ByteArray =
-            byteArrayOf(
+            if (isExtendedFrame) {
+                byteArrayOf(
+                0x00,
+                0x00,
+                0xFF.toByte(),
+                0xFF.toByte(),
+                0xFF.toByte(),
+                (data.size / 256).toByte(),
+                (data.size % 256 + 1).toByte(),
+                ((data.size / 256 + data.size % 256 + 1 and 0xFF).inv() + 0x01).toByte(),
+                0xD4.toByte(),
+                )
+            } else {
+                byteArrayOf(
                 0x00,
                 0x00,
                 0xFF.toByte(),
                 (data.size + 1).toByte(),
                 ((data.size + 1 and 0xFF).inv() + 0x01).toByte(),
                 0xD4.toByte(),
-            )
+                )
+            }
         var sum = 0xD4
         for (byte in data) {
             sum += byte
@@ -298,6 +394,7 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
         frame += (data)
         frame += ((sum.inv() and 0xFF) + 0x01).toByte()
         frame += (0x00).toByte()
+        Log.d(TAG, "constructFrame::isExtendedFrame: " + isExtendedFrame + " Frame: " + frame.toHex())
 
         return frame
     }
@@ -328,5 +425,10 @@ class PN532(val device: UsbDevice, val connection: UsbDeviceConnection) {
         private const val IN_COMMUNICATE_THRU = 0x42.toByte()
         private const val IN_DATA_EXCHANGE = 0x40.toByte()
         private val LONG_PREAMBLE = ByteArray(20)
+        private const val MAX_READ_BUFFER_SIZE = 288
+        private const val NORMAL_FRAME_MIN_SIZE = 8
+        private const val NORMAL_FRAME_DATA_SIZE = 255
+        private const val EXTENDED_FRAME_MIN_SIZE = 11
+        private const val ACK_FRAME_SIZE = 6
     }
 }
diff --git a/testutils/pn532/src/com/android/nfc/pn532/TransportLayer.kt b/testutils/pn532/src/com/android/nfc/pn532/TransportLayer.kt
index 895154ac..235eb6a5 100644
--- a/testutils/pn532/src/com/android/nfc/pn532/TransportLayer.kt
+++ b/testutils/pn532/src/com/android/nfc/pn532/TransportLayer.kt
@@ -21,10 +21,12 @@ import android.hardware.usb.UsbDeviceConnection
 import android.hardware.usb.UsbEndpoint
 import android.hardware.usb.UsbRequest
 import android.util.Log
+import com.google.errorprone.annotations.CanIgnoreReturnValue
 
 /** TransportLayer - handles reads/write to USB device */
 class TransportLayer(val device: UsbDevice, val connection: UsbDeviceConnection) {
 
+    private val MAX_READ_BUFFER_SIZE = 288
     lateinit var endpointIn: UsbEndpoint
     lateinit var endpointOut: UsbEndpoint
     val dataRequest: UsbRequest = UsbRequest()
@@ -49,7 +51,7 @@ class TransportLayer(val device: UsbDevice, val connection: UsbDeviceConnection)
         }
     }
 
-    fun read(timeout: Long, numBytes: Int = 255): ByteArray? {
+    fun read(timeout: Long, numBytes: Int = MAX_READ_BUFFER_SIZE): ByteArray? {
         if (numBytes < 0) return null
         val buffer = ByteArray(numBytes)
 
@@ -65,6 +67,7 @@ class TransportLayer(val device: UsbDevice, val connection: UsbDeviceConnection)
         return null
     }
 
+    @CanIgnoreReturnValue
     fun write(bytes: ByteArray): Boolean {
         val size = connection.bulkTransfer(endpointOut, bytes, bytes.size, endpointOut.interval)
         if (size > 0) {
diff --git a/testutils/pn532/tag.py b/testutils/pn532/tag.py
index aaaa4869..f56de05c 100644
--- a/testutils/pn532/tag.py
+++ b/testutils/pn532/tag.py
@@ -15,57 +15,109 @@
 # Lint as: python3
 
 from binascii import hexlify
+from .nfcutils.reader import ReaderTag
 
-class Tag:
-    def __init__(self, target_id: int):
+
+def responses_match(expected: bytes, actual: bytes) -> bool:
+    if expected == actual:
+        return True
+    if expected is None or actual is None:
+        return False
+    if len(expected) == 0 or len(actual) == 0:
+        return False
+    if expected[0] != 0x00 and actual[0] == 0x00:
+        if expected == actual[1:]:
+            return True
+    return False
+
+
+class Tag(ReaderTag):
+    def __init__(self, pn532, target_id: int):
+        self.pn532 = pn532
         self.target_id = target_id
+        self.log = pn532.log
+
+    def transceive(self, data):
+        """Uses PN532.in_data_exchange to transceive data via ISO-DEP"""
+        return self.pn532.in_data_exchange(
+            self.target_id, data, raise_on_error_status=False, timeout=5
+        )
 
     def transact(self, command_apdus, response_apdus):
-        self.log.debug("Starting transaction with %d commands", len(command_apdus))
-        for i in range(len(command_apdus)):
-            rsp = self.pn532.transceive(bytearray([self.target_id]) + command_apdus[i])
-            if response_apdus[i] != "*" and rsp != response_apdus[i]:
-                received_apdu = hexlify(rsp).decode() if type(rsp) is bytes else "None"
+        """Sends command_apdus
+        and verifies successful reception of matching response_apdus"""
+        self.log.debug(f"Starting transaction with {len(command_apdus)} pairs")
+        for command, response in zip(command_apdus, response_apdus):
+            rsp = self.transceive(command)
+            if response != "*" and not responses_match(response, rsp):
+                received_apdu = rsp.hex() if isinstance(rsp, bytes) else "None"
                 self.log.error(
                     "Unexpected APDU: received %s, expected %s",
                     received_apdu,
-                    hexlify(response_apdus[i]).decode(),
+                    hexlify(response).decode(),
                 )
                 return False
-
         return True
 
 
 class TypeATag(Tag):
 
     def __init__(
-            self,
-            pn532: "PN532",
-            target_id: int,
-            sense_res: bytearray,
-            sel_res: int,
-            nfcid: bytearray,
-            ats: bytearray,
+        self,
+        pn532: "PN532",
+        target_id: int,
+        sense_res: bytearray,
+        sel_res: int,
+        nfcid: bytearray,
+        ats: bytearray,
     ):
-        self.pn532 = pn532
-        self.target_id = target_id
+        super().__init__(pn532, target_id)
         self.sense_res = sense_res
         self.sel_res = sel_res
         self.nfcid = nfcid
         self.ats = ats
 
-        self.log = pn532.log
+
+    @classmethod
+    def from_target_data(cls, pn532, data):
+        """Constructs TypeATag from TargetData[] returned by PN532"""
+        target_id = data[0]
+        sense_res = data[1:3]
+        sel_res = data[3]
+        nfcid_length = data[4]
+        nfcid = data[5:5 + nfcid_length]
+        offset = (1 + 2 + 1 + 1) + nfcid_length
+        ats = bytearray()
+        # If Type4A, and extra data available
+        if sel_res & 0x20 and len(data) > offset:
+            ats_length = data[offset]
+            ats = data[offset + 1 : offset + 1 + ats_length]
+            offset += 1 + ats_length
+        return cls(pn532, target_id, sense_res, sel_res, nfcid, ats), offset
+
 
 class TypeBTag(Tag):
 
     def __init__(
-            self,
-            pn532: "PN532",
-            target_id: int,
-            sensb_res: bytearray,
+        self,
+        pn532: "PN532",
+        target_id: int,
+        sensb_res: bytearray,
+        attrib_res: bytearray,
     ):
-        self.pn532 = pn532
-        self.target_id = target_id
+        super().__init__(pn532, target_id)
         self.sensb_res = sensb_res
+        self.attrib_res = attrib_res
+        # NFCID0
+        self.nfcid = sensb_res[1:5]
 
-        self.log = pn532.log
+    @classmethod
+    def from_target_data(cls, pn532, data):
+        """Constructs TypeBTag from TargetData[] returned by PN532"""
+        target_id = data[0]
+        sensb_res = data[1:13]
+        assert sensb_res[0] == 0x50
+        attrib_res_length = data[13]
+        attrib_res = data[14:14 + attrib_res_length]
+        offset = (1 + 12 + 1) + attrib_res_length
+        return cls(pn532, target_id, sensb_res, attrib_res), offset
diff --git a/testutils/src/com/android/nfc/emulator/AndroidManifest.xml b/testutils/src/com/android/nfc/emulator/AndroidManifest.xml
index 49b2547d..1e8bc3d4 100644
--- a/testutils/src/com/android/nfc/emulator/AndroidManifest.xml
+++ b/testutils/src/com/android/nfc/emulator/AndroidManifest.xml
@@ -117,6 +117,16 @@
             android:label="PN532 Activity"
             android:exported="true">
         </activity>
+        <activity
+            android:name=".PollingFrameEmulatorActivity"
+            android:label="Polling Frame Activity"
+            android:exported="true">
+        </activity>
+        <activity
+            android:name=".EventListenerEmulatorActivity"
+            android:label="Event Listener Activity"
+            android:exported="true">
+        </activity>
         <service android:name="com.android.nfc.service.PollingLoopService" android:exported="true"
             android:permission="android.permission.BIND_NFC_SERVICE"
             android:enabled="true">
@@ -173,7 +183,8 @@
         </service>
         <service android:name="com.android.nfc.service.PaymentService1" android:exported="true"
             android:permission="android.permission.BIND_NFC_SERVICE"
-            android:enabled="false">
+            android:enabled="false"
+            android:process="com.android.nfc.emulator.payment">
             <intent-filter>
                 <action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
                 <category android:name="android.intent.category.DEFAULT"/>
diff --git a/testutils/src/com/android/nfc/emulator/BaseEmulatorActivity.java b/testutils/src/com/android/nfc/emulator/BaseEmulatorActivity.java
index 424e9540..bf46f4f6 100644
--- a/testutils/src/com/android/nfc/emulator/BaseEmulatorActivity.java
+++ b/testutils/src/com/android/nfc/emulator/BaseEmulatorActivity.java
@@ -31,6 +31,7 @@ import android.nfc.NfcAdapter;
 import android.nfc.cardemulation.CardEmulation;
 import android.nfc.cardemulation.HostApduService;
 import android.os.Bundle;
+import android.os.Handler;
 import android.util.AttributeSet;
 import android.util.Log;
 import android.util.Xml;
@@ -42,6 +43,7 @@ import com.android.nfc.utils.HceUtils;
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.IOException;
+import java.util.concurrent.Executors;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -86,6 +88,13 @@ public abstract class BaseEmulatorActivity extends Activity {
         registerReceiver(mReceiver, filter, RECEIVER_EXPORTED);
     }
 
+    public void registerEventListener(CardEmulation.NfcEventListener eventListener) {
+        if (android.nfc.Flags.nfcEventListener()) {
+            Log.d(TAG, "registering event listener...");
+            mCardEmulation.registerNfcEventListener(getMainExecutor(), eventListener);
+        }
+    }
+
     @Override
     protected void onResume() {
         super.onResume();
@@ -164,7 +173,7 @@ public abstract class BaseEmulatorActivity extends Activity {
                                             cardEmulation
                                                     .getDescriptionForPreferredPaymentService()
                                                     .toString()));
-        } catch (Exception e) {
+        } catch (Exception|AssertionError e) {
             Log.e(TAG, "Default service not updated. This may cause tests to fail", e);
         }
     }
@@ -197,7 +206,7 @@ public abstract class BaseEmulatorActivity extends Activity {
         try {
             CommonTestUtils.waitUntil("Observe mode has not been set", 6,
                     () -> mAdapter.isObserveModeEnabled() == enabled);
-        } catch (Exception e) {
+        } catch (Exception|AssertionError e) {
             Log.e(TAG, "Observe mode not set to " + enabled + ". This may cause tests to fail", e);
         }
     }
diff --git a/testutils/src/com/android/nfc/emulator/ConflictingNonPaymentPrefixEmulatorActivity.java b/testutils/src/com/android/nfc/emulator/ConflictingNonPaymentPrefixEmulatorActivity.java
index 3b1b3fc0..f93534f8 100644
--- a/testutils/src/com/android/nfc/emulator/ConflictingNonPaymentPrefixEmulatorActivity.java
+++ b/testutils/src/com/android/nfc/emulator/ConflictingNonPaymentPrefixEmulatorActivity.java
@@ -26,11 +26,23 @@ import com.android.nfc.service.PrefixTransportService2;
 import java.util.ArrayList;
 
 public class ConflictingNonPaymentPrefixEmulatorActivity extends BaseEmulatorActivity {
+
+    private String mAidConflictOccurred = null;
+
+    private CardEmulation.NfcEventListener mEventListener = new CardEmulation.NfcEventListener() {
+        @Override
+        public void onAidConflictOccurred(String aid) {
+            mAidConflictOccurred = aid;
+        }
+    };
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setupServices(
                 PrefixTransportService1.COMPONENT, PrefixTransportService2.COMPONENT);
+
+        registerEventListener(mEventListener);
     }
 
     @Override
@@ -51,10 +63,21 @@ public class ConflictingNonPaymentPrefixEmulatorActivity extends BaseEmulatorAct
     @Override
     public void onApduSequenceComplete(ComponentName component, long duration) {
         if (component.equals(PrefixTransportService2.COMPONENT)) {
-            setTestPassed();
+            if (android.nfc.Flags.nfcEventListener()) {
+                if (mAidConflictOccurred.startsWith(HceUtils.TRANSPORT_AID)) {
+                    setTestPassed();
+                }
+            } else {
+                setTestPassed();
+            }
         }
     }
 
+    protected void onDestroy() {
+        super.onDestroy();
+        mCardEmulation.unregisterNfcEventListener(mEventListener);
+    }
+
     @Override
     public ComponentName getPreferredServiceComponent(){
         return PrefixTransportService2.COMPONENT;
diff --git a/testutils/src/com/android/nfc/emulator/EventListenerEmulatorActivity.java b/testutils/src/com/android/nfc/emulator/EventListenerEmulatorActivity.java
new file mode 100644
index 00000000..e551201c
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulator/EventListenerEmulatorActivity.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.emulator;
+
+import android.content.ComponentName;
+import android.nfc.cardemulation.CardEmulation;
+import android.os.Bundle;
+
+import android.util.Log;
+import androidx.annotation.NonNull;
+import com.android.nfc.utils.HceUtils;
+import com.android.nfc.service.TransportService1;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class EventListenerEmulatorActivity extends BaseEmulatorActivity {
+
+    private ArrayList<Boolean> mFieldChanged = new ArrayList<>();
+    private ArrayList<String> mAidNotRouted = new ArrayList<>();
+
+    private CardEmulation.NfcEventListener mEventListener = new CardEmulation.NfcEventListener() {
+        @Override
+        public void onRemoteFieldChanged(boolean isDetected) {
+            mFieldChanged.add(isDetected);
+        }
+
+        public void onAidNotRouted(@NonNull String aid) {
+            mAidNotRouted.add(aid);
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setupServices(TransportService1.COMPONENT);
+    }
+
+    public void onResume() {
+        super.onResume();
+        ComponentName serviceName =
+                new ComponentName(this.getApplicationContext(), TransportService1.class);
+        mCardEmulation.setPreferredService(this, serviceName);
+        waitForPreferredService();
+
+        mFieldChanged.clear();
+        mAidNotRouted.clear();
+        registerEventListener(mEventListener);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        mCardEmulation.unsetPreferredService(this);
+    }
+
+    @Override
+    public void onApduSequenceComplete(ComponentName component, long duration) {
+        boolean success = mAidNotRouted.equals(Arrays.asList(HceUtils.ACCESS_AID));
+        success = success && TransportService1.COMPONENT.equals(component);
+        success = success && mFieldChanged.equals(Arrays.asList(true, false, true));
+
+        if (success) {
+            setTestPassed();
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mCardEmulation.unregisterNfcEventListener(mEventListener);
+    }
+
+    @Override
+    public ComponentName getPreferredServiceComponent(){
+        return TransportService1.COMPONENT;
+    }
+}
diff --git a/testutils/src/com/android/nfc/emulator/NfcEmulatorDeviceSnippet.java b/testutils/src/com/android/nfc/emulator/NfcEmulatorDeviceSnippet.java
index 6580adf2..02274810 100644
--- a/testutils/src/com/android/nfc/emulator/NfcEmulatorDeviceSnippet.java
+++ b/testutils/src/com/android/nfc/emulator/NfcEmulatorDeviceSnippet.java
@@ -15,11 +15,11 @@
  */
 package com.android.nfc.emulator;
 
-
 import android.app.Instrumentation;
 import android.content.ComponentName;
 import android.content.Intent;
 import android.nfc.NfcAdapter;
+import android.nfc.cardemulation.PollingFrame;
 import android.util.Log;
 
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -213,6 +213,19 @@ public class NfcEmulatorDeviceSnippet extends NfcSnippet {
         mActivity = (ThroughputEmulatorActivity) instrumentation.startActivitySync(intent);
     }
 
+    /** Opens polling frame emulator activity */
+    @Rpc(description = "Opens polling frame emulator activity")
+    public void startPollingFrameEmulatorActivity() {
+        Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.setClassName(
+                instrumentation.getTargetContext(), PollingFrameEmulatorActivity.class.getName());
+
+        mActivity = (PollingFrameEmulatorActivity) instrumentation.startActivitySync(intent);
+    }
+
     /** Opens large num AIDs emulator activity */
     @Rpc(description = "Opens large num AIDs emulator activity")
     public void startLargeNumAidsEmulatorActivity() {
@@ -268,7 +281,6 @@ public class NfcEmulatorDeviceSnippet extends NfcSnippet {
         mActivity = (ProtocolParamsEmulatorActivity) instrumentation.startActivitySync(intent);
     }
 
-
     @Rpc(description = "Returns if observe mode is supported.")
     public boolean isObserveModeSupported() {
         NfcAdapter adapter = NfcAdapter.getDefaultAdapter(mContext);
@@ -345,7 +357,7 @@ public class NfcEmulatorDeviceSnippet extends NfcSnippet {
         mActivity = (PollingLoopEmulatorActivity) instrumentation.startActivitySync(intent);
     }
 
-    @Rpc(description = "Open two polling frame emulator activity for two readers test\"")
+    @Rpc(description = "Open two polling frame emulator activity for two readers test")
     public void startTwoPollingFrameEmulatorActivity() {
         Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
 
@@ -358,19 +370,29 @@ public class NfcEmulatorDeviceSnippet extends NfcSnippet {
         mActivity = (TwoPollingFrameEmulatorActivity) instrumentation.startActivitySync(intent);
     }
 
-    @Rpc(description = "Opens PN532 Activity\"")
+    @Rpc(description = "Opens PN532 Activity")
     public void startPN532Activity() {
         Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
 
         Intent intent = new Intent(Intent.ACTION_MAIN);
         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        intent.setClassName(
-                instrumentation.getTargetContext(),
-                PN532Activity.class.getName());
+        intent.setClassName(instrumentation.getTargetContext(), PN532Activity.class.getName());
 
         mActivity = (PN532Activity) instrumentation.startActivitySync(intent);
     }
 
+    @Rpc(description = "Opens the Event Listener Activity")
+    public void startEventListenerActivity() {
+        Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
+
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.setClassName(instrumentation.getTargetContext(),
+            EventListenerEmulatorActivity.class.getName());
+
+        mActivity = (EventListenerEmulatorActivity) instrumentation.startActivitySync(intent);
+    }
+
     /** Registers receiver that waits for RF field broadcast */
     @AsyncRpc(description = "Waits for RF field detected broadcast")
     public void asyncWaitForRfOnBroadcast(String callbackId, String eventName) {
@@ -392,6 +414,25 @@ public class NfcEmulatorDeviceSnippet extends NfcSnippet {
         ((PN532Activity) mActivity).enableReaderMode(flags);
     }
 
+    /** Returns a list of collected polling frames */
+    @Rpc(description = "Get polling frames")
+    public PollingFrame[] getPollingFrames() {
+        if (mActivity == null || !(mActivity instanceof PollingFrameEmulatorActivity)) {
+            Log.e(TAG, "Activity is null.");
+            return new PollingFrame[] {};
+        }
+        Log.e(TAG, "Activity is not null.");
+        return ((PollingFrameEmulatorActivity) mActivity).getPollingFrames();
+    }
+
+    /** Registers receiver that waits for OFF polling frame */
+    @AsyncRpc(description = "Waits for OFF polling frame")
+    public void asyncWaitForPollingFrameOff(String callbackId, String eventName) {
+        registerSnippetBroadcastReceiver(
+                callbackId, eventName, PollingFrameEmulatorActivity.POLLING_FRAME_OFF_DETECTED);
+        Log.i("PollingFrameEmulatorActivity", "register for polling frame off");
+    }
+
     /** Registers receiver for polling loop action */
     @AsyncRpc(description = "Waits for seen correct polling loop")
     public void asyncWaitsForSeenCorrectPollingLoop(String callbackId, String eventName) {
diff --git a/testutils/src/com/android/nfc/emulator/PollingFrameEmulatorActivity.java b/testutils/src/com/android/nfc/emulator/PollingFrameEmulatorActivity.java
new file mode 100644
index 00000000..1f4ba282
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulator/PollingFrameEmulatorActivity.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.emulator;
+
+import android.content.Intent;
+import android.nfc.cardemulation.PollingFrame;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This activity is used to test the polling frame feature.
+ *
+ * <p>This activity will register a broadcast receiver to receive the polling frame information from
+ * the polling loop service.
+ */
+public class PollingFrameEmulatorActivity extends PollingLoopEmulatorActivity {
+    private static final String TAG = "PollingFrameEmulatorActivity";
+    public static final String POLLING_FRAME_OFF_DETECTED =
+            PACKAGE_NAME + ".POLLING_FRAME_OFF_DETECTED";
+
+    private List<PollingFrame> pollingFrames = new ArrayList<PollingFrame>();
+
+    public PollingFrame[] getPollingFrames() {
+        PollingFrame[] result = pollingFrames.stream().toArray(PollingFrame[]::new);
+        this.pollingFrames = new ArrayList<PollingFrame>();
+        return result;
+    }
+
+    @Override
+    void processPollingFrames(List<PollingFrame> frames) {
+        Log.d(TAG, "processPollingFrames of size " + frames.size());
+        pollingFrames.addAll(frames);
+
+        if (frames.stream()
+                .anyMatch(frame -> frame.getType() == PollingFrame.POLLING_LOOP_TYPE_OFF)) {
+            Intent intent = new Intent(POLLING_FRAME_OFF_DETECTED);
+            sendBroadcast(intent);
+        }
+    }
+}
diff --git a/testutils/src/com/android/nfc/emulator/res/values-gl/strings.xml b/testutils/src/com/android/nfc/emulator/res/values-gl/strings.xml
index 9abbe57e..117c924d 100644
--- a/testutils/src/com/android/nfc/emulator/res/values-gl/strings.xml
+++ b/testutils/src/com/android/nfc/emulator/res/values-gl/strings.xml
@@ -19,11 +19,11 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="transportService1" msgid="7110581386972746468">"Servizo de transporte nmero 1"</string>
     <string name="transportService2" msgid="1627086442493069484">"Servizo de transporte nmero 2"</string>
-    <string name="paymentService1" msgid="5034369200915462734">"Servizo de pago nmero 1"</string>
-    <string name="paymentService2" msgid="7677362631959614876">"Servizo de pago nmero 2"</string>
+    <string name="paymentService1" msgid="5034369200915462734">"Servizo de pagos nmero 1"</string>
+    <string name="paymentService2" msgid="7677362631959614876">"Servizo de pagos nmero 2"</string>
     <string name="offhostService" msgid="2153585078114315278">"Servizo fra do servidor"</string>
     <string name="accessService" msgid="169603026393620416">"Acceso ao servizo"</string>
-    <string name="screenOffPaymentService" msgid="4807235640853231967">"Servizo de pago coa pantalla apagada"</string>
+    <string name="screenOffPaymentService" msgid="4807235640853231967">"Servizo de pagos coa pantalla apagada"</string>
     <string name="screenOnOnlyOffHostService" msgid="1209570782652205407">"Servizo fra do servidor s coa pantalla acendida"</string>
     <string name="ppse" msgid="3369197818756940218">"PPSE"</string>
     <string name="mastercard" msgid="2202161212986753725">"MasterCard"</string>
diff --git a/testutils/src/com/android/nfc/emulatorapp/AndroidManifest.xml b/testutils/src/com/android/nfc/emulatorapp/AndroidManifest.xml
new file mode 100644
index 00000000..c9f99907
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/AndroidManifest.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.nfc.emulatorapp">
+
+  <uses-sdk android:minSdkVersion="33" android:targetSdkVersion="33"/>
+  <uses-permission android:name="android.permission.NFC" />
+  <uses-feature android:name="android.hardware.nfc" android:required="true" />
+  <uses-feature android:name="android.hardware.nfc.hce" android:required="true" />
+
+  <application
+      android:label="@string/app_name"
+      android:theme="@style/AppTheme">
+    <service
+        android:name=".EmulatorHostApduService"
+        android:exported="true"
+        android:permission="android.permission.BIND_NFC_SERVICE">
+      <intent-filter>
+        <action android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE"/>
+      </intent-filter>
+      <meta-data
+          android:name="android.nfc.cardemulation.host_apdu_service"
+          android:resource="@xml/aids"/>
+    </service>
+    <activity
+        android:name=".MainActivity"
+        android:launchMode="singleTask"
+        android:exported="true">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/EmulatorHostApduService.kt b/testutils/src/com/android/nfc/emulatorapp/EmulatorHostApduService.kt
new file mode 100644
index 00000000..75b73a2b
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/EmulatorHostApduService.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.emulatorapp
+
+import android.nfc.cardemulation.HostApduService
+import android.nfc.cardemulation.PollingFrame
+import android.os.Bundle
+import androidx.lifecycle.MutableLiveData
+import java.math.BigInteger
+
+/**
+ * Implementation of HostApduService that receives APDU commands from the reader and sends back
+ * responses.
+ */
+class EmulatorHostApduService : HostApduService() {
+
+  override fun processPollingFrames(frames: List<PollingFrame>) {
+    for (frame in frames) {
+      viewModel.addLog("Received polling frame ${frame.toString()}")
+    }
+  }
+
+  /**
+   * Processes the APDU command received from the reader and sends back a response. If the command
+   * was not found in the original snoop log, a failure response is sent instead.
+   */
+  override fun processCommandApdu(commandApdu: ByteArray?, extras: Bundle?): ByteArray {
+    val command = commandApdu?.toHexString()
+    val responseList = apdus.value?.get(command)
+    if (responseList != null && responseList.isNotEmpty()) {
+      val response = responseList.removeAt(0)
+      viewModel.addLog(createApduLog(command, response))
+      return if (response.isEmpty()) ByteArray(0) else BigInteger(response, 16).toByteArray()
+    } else {
+      viewModel.addLog(createApduLog(command, FAILURE_RESPONSE.toHexString()))
+      return FAILURE_RESPONSE
+    }
+  }
+
+  override fun onDeactivated(reason: Int) {
+    if (reason == DEACTIVATION_LINK_LOSS) {
+      viewModel.addLog("Service has been deactivated due to NFC link loss")
+    } else { // DEACTIVATION_DESELECTED
+      viewModel.addLog("Service has been deactivated due to a different AID being selected")
+    }
+  }
+
+  private fun ByteArray.toHexString(): String {
+    return this.joinToString("") { java.lang.String.format("%02x", it) }
+  }
+
+  private fun createApduLog(command: String?, response: String): String {
+    if (command == null) {
+      return "Received null command"
+    }
+    if (responseDecoder.containsKey(response.lowercase())) {
+      return "Received command: $command\n\n     Sent response: ${responseDecoder[response]}"
+    } else {
+      return "Received command: $command\n\n     Sent response: $response"
+    }
+  }
+
+  companion object {
+    private const val TAG = "EmulatorHostApduServiceLog"
+    private val FAILURE_RESPONSE = BigInteger("6f00", 16).toByteArray()
+    val apdus = MutableLiveData<Map<String, MutableList<String>>>()
+    val responseDecoder = mapOf("6f00" to "Failure", "6a82" to "AID not found")
+    lateinit var viewModel: EmulatorViewModel
+  }
+}
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/EmulatorViewModel.kt b/testutils/src/com/android/nfc/emulatorapp/EmulatorViewModel.kt
new file mode 100644
index 00000000..5c2fb5b9
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/EmulatorViewModel.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.emulatorapp
+
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import androidx.lifecycle.ViewModel
+
+class EmulatorViewModel : ViewModel() {
+  private val _uiState: MutableLiveData<EmulatorUiState> = MutableLiveData(EmulatorUiState())
+  val uiState: LiveData<EmulatorUiState> = _uiState
+
+  fun addLog(newLog: String) {
+    val existingLog = _uiState.value?.transactionLog
+    _uiState.value = uiState.value?.copy(transactionLog = "$existingLog\n\n$newLog")
+  }
+
+  fun setSnoopFile(file: String) {
+    _uiState.value = uiState.value?.copy(snoopFile = file)
+  }
+}
+
+data class EmulatorUiState(val snoopFile: String = "", val transactionLog: String = "")
+
+data class ApduPair(val command: String, val response: String)
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/MainActivity.kt b/testutils/src/com/android/nfc/emulatorapp/MainActivity.kt
new file mode 100644
index 00000000..756512c3
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/MainActivity.kt
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.nfc.emulatorapp
+
+import android.content.ComponentName
+import android.content.pm.PackageManager
+import android.os.Bundle
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.activity.viewModels
+import androidx.lifecycle.Observer
+import com.google.android.material.button.MaterialButton
+import com.google.android.material.textview.MaterialTextView
+import java.io.BufferedReader
+import java.io.InputStreamReader
+
+class MainActivity : AppCompatActivity() {
+
+  private val viewModel: EmulatorViewModel by viewModels()
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+    setContentView(R.layout.activity_main)
+
+    val observer =
+      Observer<EmulatorUiState> { state ->
+        val replayedFileText = "${getString(R.string.replayed_file_text)} ${state.snoopFile}"
+        findViewById<MaterialTextView>(R.id.snoop_file_name).text = replayedFileText
+        val logText = "${getString(R.string.log_text)}\n${state.transactionLog}"
+        findViewById<MaterialTextView>(R.id.transaction_log).text = logText
+      }
+    viewModel.uiState.observe(this, observer)
+    EmulatorHostApduService.viewModel = viewModel
+
+    findViewById<MaterialButton>(R.id.service_button).setOnClickListener {
+      startHostApduService()
+      findViewById<MaterialButton>(R.id.service_button).isEnabled = false
+    }
+
+    val snoopFile = intent.getStringExtra(SNOOP_FILE_FLAG)
+    if (snoopFile != null) {
+      val apdus = openAndParseFile(PARSED_FILES_DIR + snoopFile)
+      updateService(apdus)
+      viewModel.setSnoopFile(snoopFile)
+    }
+  }
+
+  private fun startHostApduService() {
+    packageManager.setComponentEnabledSetting(
+      ComponentName(this, EmulatorHostApduService::class.java),
+      PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
+      PackageManager.DONT_KILL_APP,
+    )
+  }
+
+  /** Opens the snoop file and extracts all APDU commands and responses. */
+  private fun openAndParseFile(file: String): List<ApduPair> {
+    val apduPairs = mutableListOf<ApduPair>()
+    val text = BufferedReader(InputStreamReader(getAssets().open(file))).use { it.readText() }
+    val lines = text.split("\n").toTypedArray()
+    for (line in lines) {
+      val arr = line.split(";").toTypedArray()
+      if (arr.size != 2) { // Should contain commands, followed by responses
+        continue
+      }
+      val commands = arr[0].split(",").toTypedArray()
+      val responses = arr[1].split(",").toTypedArray()
+      if (commands.size != responses.size) {
+        continue
+      }
+      for (i in commands.indices) {
+        val command = standardize(commands[i])
+        val response = standardize(responses[i])
+        apduPairs.add(ApduPair(command, response))
+      }
+    }
+    return apduPairs
+  }
+
+  private fun standardize(s: String): String {
+    return s.replace("[", "").replace("]", "").replace("\'", "").replace(" ", "")
+  }
+
+  /** Updates EmulatorHostApduService with the given APDU commands and responses. */
+  private fun updateService(apdus: List<ApduPair>) {
+    val hashmap: HashMap<String, MutableList<String>> = HashMap()
+    for (apduPair in apdus) {
+      val existingList = hashmap[apduPair.command]
+      if (existingList == null) {
+        hashmap[apduPair.command] = mutableListOf(apduPair.response)
+      } else {
+        existingList.add(apduPair.response)
+        hashmap[apduPair.command] = existingList
+      }
+    }
+    EmulatorHostApduService.apdus.postValue(hashmap)
+  }
+
+  companion object {
+    private const val TAG = "EmulatorHostApduServiceLog"
+    private const val SNOOP_FILE_FLAG = "snoop_file"
+    private const val PARSED_FILES_DIR = "src/com/android/nfc/emulatorapp/parsed_files/"
+  }
+}
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/layout/activity_main.xml b/testutils/src/com/android/nfc/emulatorapp/res/layout/activity_main.xml
new file mode 100644
index 00000000..2fbea379
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/layout/activity_main.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="16dp">
+  <com.google.android.material.button.MaterialButton
+      android:id="@+id/service_button"
+      android:layout_width="200dp"
+      android:layout_height="wrap_content"
+      android:layout_alignParentTop="true"
+      android:layout_centerHorizontal="true"
+      android:text="@string/service_button_text" />
+  <com.google.android.material.textview.MaterialTextView
+      android:id="@+id/snoop_file_name"
+      android:layout_height="wrap_content"
+      android:layout_width="match_parent"
+      android:layout_below="@+id/service_button"
+      android:layout_marginLeft="16dp"
+      android:layout_marginRight="16dp"
+      android:text=""/>
+  <androidx.core.widget.NestedScrollView
+      android:layout_width="match_parent"
+      android:layout_height="600dp"
+      android:layout_below="@+id/snoop_file_name">
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:padding="8dp">
+      <com.google.android.material.textview.MaterialTextView
+          android:id="@+id/transaction_log"
+          android:layout_height="wrap_content"
+          android:layout_width="wrap_content"
+          android:text=""
+          android:typeface="monospace"/>
+    </LinearLayout>
+  </androidx.core.widget.NestedScrollView>
+</RelativeLayout>
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-af/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-af/strings.xml
new file mode 100644
index 00000000..2867c0d8
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-af/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay-app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Begin Host APDU-diens"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Herspeel tans ler:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaksielogler:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-am/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-am/strings.xml
new file mode 100644
index 00000000..58267b52
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-am/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   "</string>
+    <string name="log_text" msgid="5517852408962406645">"  "</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ar/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ar/strings.xml
new file mode 100644
index 00000000..a41a6b3d
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ar/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" \" NFC \""</string>
+    <string name="service_button_text" msgid="5013402864802312301">"  APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-as/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-as/strings.xml
new file mode 100644
index 00000000..1927c1bb
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-as/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-az/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-az/strings.xml
new file mode 100644
index 00000000..314baa6e
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-az/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay ttbiqi"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU xidmtini i saln"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Fayl yenidn i salnr:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Tranzaksiya jurnal:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-b+sr+Latn/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-b+sr+Latn/strings.xml
new file mode 100644
index 00000000..93a95b1e
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-b+sr+Latn/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikacija NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Pokreni Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Ponovo se puta fajl:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Evidencija transakcija:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-be/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-be/strings.xml
new file mode 100644
index 00000000..fc098aa4
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-be/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"  Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-bg/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-bg/strings.xml
new file mode 100644
index 00000000..5eca63fe
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-bg/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"      APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">"   :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-bn/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-bn/strings.xml
new file mode 100644
index 00000000..cf0ec2a7
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-bn/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"    :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-bs/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-bs/strings.xml
new file mode 100644
index 00000000..bc46df81
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-bs/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Pokreni HostApduService"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Ponovna reprodukcija fajla:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Zapisnik transakcije:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ca/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ca/strings.xml
new file mode 100644
index 00000000..63169280
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ca/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplicaci NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Inicia el servei APDU d\'amfitri"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"S\'est tornant a reproduir el fitxer:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Registre de transaccions:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-cs/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-cs/strings.xml
new file mode 100644
index 00000000..b38da465
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-cs/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikace NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Spustit slubu Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Pehrvn souboru:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Protokol transakc:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-da/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-da/strings.xml
new file mode 100644
index 00000000..2493beaa
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-da/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Appen NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Filen, der afspilles igen:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaktionslog:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-de/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-de/strings.xml
new file mode 100644
index 00000000..57b6768d
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-de/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"HostApduService starten"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Datei, die noch einmal abgespielt wird:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaktionsprotokoll:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-el/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-el/strings.xml
new file mode 100644
index 00000000..ab40db49
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-el/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"  Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">" :"</string>
+    <string name="log_text" msgid="5517852408962406645">"  :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-en-rAU/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rAU/strings.xml
new file mode 100644
index 00000000..77951db7
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rAU/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start host APDU service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Replaying file:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaction log:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-en-rCA/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rCA/strings.xml
new file mode 100644
index 00000000..bd26ed6e
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rCA/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Replaying File:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaction Log:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-en-rGB/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rGB/strings.xml
new file mode 100644
index 00000000..77951db7
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rGB/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start host APDU service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Replaying file:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaction log:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-en-rIN/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rIN/strings.xml
new file mode 100644
index 00000000..77951db7
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-en-rIN/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start host APDU service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Replaying file:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaction log:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-es-rUS/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-es-rUS/strings.xml
new file mode 100644
index 00000000..193405aa
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-es-rUS/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"App de repeticin de NFC"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniciar el servicio de APDU del host"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Volviendo a reproducir el archivo:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Registro de transacciones:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-es/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-es/strings.xml
new file mode 100644
index 00000000..a38f7eca
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-es/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplicacin NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniciar servicio APDU de host"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Volviendo a reproducir el archivo:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Registro de transaccin:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-et/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-et/strings.xml
new file mode 100644
index 00000000..c466760c
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-et/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Rakendus NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Kivita Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Faili taasesitus:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Tehingu logi:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-eu/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-eu/strings.xml
new file mode 100644
index 00000000..f8418983
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-eu/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay aplikazioa"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Abiarazi APDU zerbitzu ostalaria"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Berriro erreproduzitzen ari den fitxategia:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transakzioen erregistroa:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-fa/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-fa/strings.xml
new file mode 100644
index 00000000..7995e329
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-fa/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"  NFC"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"  APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-fi/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-fi/strings.xml
new file mode 100644
index 00000000..ca4365f6
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-fi/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay -sovellus"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Kynnist isnnn APDU-palvelu"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Toistetaan tiedostoa:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Tapahtumaloki:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-fr-rCA/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-fr-rCA/strings.xml
new file mode 100644
index 00000000..2f060906
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-fr-rCA/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Appli NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Dmarrer Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Relecture du fichier:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Journal des transactions:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-fr/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-fr/strings.xml
new file mode 100644
index 00000000..67b54bfa
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-fr/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Appli NFCReplay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Dmarrer Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Nouvelle lecture du fichier:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Journal des transactions:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-gl/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-gl/strings.xml
new file mode 100644
index 00000000..04dc8a2e
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-gl/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplicacin NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniciar servizo APDU do host"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Reproducindo ficheiro de novo:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Rexistro das transaccins:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-gu/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-gu/strings.xml
new file mode 100644
index 00000000..345d8e83
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-gu/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"    :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-hi/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-hi/strings.xml
new file mode 100644
index 00000000..4fbc3f7f
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-hi/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"     "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"       :"</string>
+    <string name="log_text" msgid="5517852408962406645">"-  :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-hr/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-hr/strings.xml
new file mode 100644
index 00000000..64a6a75b
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-hr/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikacija NCF Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Pokreni Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Reproduciranje datoteke:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Zapisnik transakcija:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-hu/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-hu/strings.xml
new file mode 100644
index 00000000..051b6248
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-hu/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU szolgltats indtsa"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Fjl jrajtszsa:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Tranzakcinapl:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-hy/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-hy/strings.xml
new file mode 100644
index 00000000..7f3b23fe
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-hy/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">" "</string>
+    <string name="log_text" msgid="5517852408962406645">" "</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-in/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-in/strings.xml
new file mode 100644
index 00000000..11ee00d1
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-in/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikasi NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Mulai Layanan Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Memutar Ulang File:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Log Transaksi:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-is/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-is/strings.xml
new file mode 100644
index 00000000..f0122097
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-is/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Forriti NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Virkja APDU-hsiljnustu"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Skr sem er spilu aftur:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Frsluannll:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-it/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-it/strings.xml
new file mode 100644
index 00000000..d75742fb
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-it/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"App NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Avvia servizio APDU host"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Ripetizione del file in corso:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Log di transazione:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-iw/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-iw/strings.xml
new file mode 100644
index 00000000..39535591
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-iw/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"  Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ja/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ja/strings.xml
new file mode 100644
index 00000000..83b43003
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ja/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">":"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ka/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ka/strings.xml
new file mode 100644
index 00000000..5b7219c6
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ka/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-kk/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-kk/strings.xml
new file mode 100644
index 00000000..7d869141
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-kk/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU Service   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-km/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-km/strings.xml
new file mode 100644
index 00000000..2396c40a
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-km/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">""</string>
+    <string name="log_text" msgid="5517852408962406645">""</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-kn/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-kn/strings.xml
new file mode 100644
index 00000000..2898478a
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-kn/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ko/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ko/strings.xml
new file mode 100644
index 00000000..02dad84d
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ko/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ky/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ky/strings.xml
new file mode 100644
index 00000000..99503f2b
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ky/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">" :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-lo/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-lo/strings.xml
new file mode 100644
index 00000000..f8f26153
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-lo/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">":"</string>
+    <string name="log_text" msgid="5517852408962406645">":"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-lt/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-lt/strings.xml
new file mode 100644
index 00000000..253b4116
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-lt/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC pakartojimo programa"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Paleisti prieglobos APDU paslaug"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Pakartojamas failas:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Operacij urnalas:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-lv/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-lv/strings.xml
new file mode 100644
index 00000000..988c4cfb
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-lv/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Lietotne NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Skt HostApduService"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Atkrtoti atskao failu:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Darjumu urnls:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-mk/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-mk/strings.xml
new file mode 100644
index 00000000..17588d32
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-mk/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"    :"</string>
+    <string name="log_text" msgid="5517852408962406645">"  :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ml/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ml/strings.xml
new file mode 100644
index 00000000..a991963c
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ml/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-mn/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-mn/strings.xml
new file mode 100644
index 00000000..71dc6013
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-mn/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU Service- "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-mr/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-mr/strings.xml
new file mode 100644
index 00000000..5a6e4505
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-mr/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ms/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ms/strings.xml
new file mode 100644
index 00000000..647590ae
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ms/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Apl NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Mulakan Perkhidmatan Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Memainkan Semula Fail:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Log Transaksi:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-my/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-my/strings.xml
new file mode 100644
index 00000000..1a8e9ab5
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-my/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">" -"</string>
+    <string name="log_text" msgid="5517852408962406645">"-"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-nb/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-nb/strings.xml
new file mode 100644
index 00000000..0c6551d5
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-nb/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay-app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Start verts-APDU-tjenesten"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Spiller av filen p nytt:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaksjonslogg:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ne/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ne/strings.xml
new file mode 100644
index 00000000..adba248f
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ne/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC  "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-nl/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-nl/strings.xml
new file mode 100644
index 00000000..f14cc6b5
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-nl/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay-app"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU-service starten"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Bestand opnieuw afspelen:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transactielogboek:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-or/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-or/strings.xml
new file mode 100644
index 00000000..6f04f70a
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-or/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-pa/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-pa/strings.xml
new file mode 100644
index 00000000..bb55bfd8
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-pa/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">"-  :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-pl/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-pl/strings.xml
new file mode 100644
index 00000000..70ea41e6
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-pl/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikacja NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Uruchom usug APDU hosta"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Odtwarzam ponownie plik:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Dziennik transakcji:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-pt-rPT/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-pt-rPT/strings.xml
new file mode 100644
index 00000000..0c588a98
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-pt-rPT/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"App de reproduo NFC"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniciar servio APDU do anfitrio"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"A reproduzir o ficheiro:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Registo de transaes:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-pt/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-pt/strings.xml
new file mode 100644
index 00000000..ef01529e
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-pt/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"App NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniciar servio APDU do host"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Arquivo de reproduo:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Registro de transao:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ro/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ro/strings.xml
new file mode 100644
index 00000000..8cfc4a03
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ro/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplicaia NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Iniiaz Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Se red din nou fiierul:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Jurnalul tranzaciilor:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ru/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ru/strings.xml
new file mode 100644
index 00000000..e6ecc9e5
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ru/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">" :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-si/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-si/strings.xml
new file mode 100644
index 00000000..58ad0ee7
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-si/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC   "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sk/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sk/strings.xml
new file mode 100644
index 00000000..346c19a2
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sk/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikcia NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Spusti Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Prehrva sa sbor:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Dennk transakci:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sl/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sl/strings.xml
new file mode 100644
index 00000000..872f9bc8
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sl/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikacija NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Zaeni storitev gostitelja APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Vnovino predvajanje datoteke:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Dnevnik transakcij:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sq/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sq/strings.xml
new file mode 100644
index 00000000..d8e7e913
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sq/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Aplikacioni NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Nis \"Shrbimin APDU t strehimit\""</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Skedari po riluhet:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Evidenca e transaksioneve:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sr/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sr/strings.xml
new file mode 100644
index 00000000..366f5ce5
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sr/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sv/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sv/strings.xml
new file mode 100644
index 00000000..85e07ed1
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sv/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Appen NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Starta APDU-vrdtjnsten"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Spelar upp filen igen:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Transaktionslogg:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-sw/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-sw/strings.xml
new file mode 100644
index 00000000..fcf3a8f3
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-sw/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"Programu ya Kucheza Tena ya NFC"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Anzisha Huduma ya Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Faili ya Kucheza Tena:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Kumbukumbu ya Miamala:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ta/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ta/strings.xml
new file mode 100644
index 00000000..6f38a07f
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ta/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-te/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-te/strings.xml
new file mode 100644
index 00000000..c5b056ed
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-te/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC  "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU  "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"   :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-th/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-th/strings.xml
new file mode 100644
index 00000000..397767b8
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-th/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">":"</string>
+    <string name="log_text" msgid="5517852408962406645">":"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-tl/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-tl/strings.xml
new file mode 100644
index 00000000..d56edcba
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-tl/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay App"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Simulan ang Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Nire-replay ang File:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Log ng Transaksyon:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-tr/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-tr/strings.xml
new file mode 100644
index 00000000..672fa054
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-tr/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay Uygulamas"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Ana Makine APDU Hizmetini Balat"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Tekrar Oynatlan Dosya:"</string>
+    <string name="log_text" msgid="5517852408962406645">"lem Gnl:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-uk/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-uk/strings.xml
new file mode 100644
index 00000000..3d257f20
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-uk/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">" NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">" Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"  :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-ur/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-ur/strings.xml
new file mode 100644
index 00000000..ebbfe358
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-ur/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC   "</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU   "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"      :"</string>
+    <string name="log_text" msgid="5517852408962406645">" :"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-uz/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-uz/strings.xml
new file mode 100644
index 00000000..9d9590dc
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-uz/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay ilovasi"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Host APDU Service boshlash"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Qayta ijrodagi fayl:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Tranzaksiya jurnali:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-vi/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-vi/strings.xml
new file mode 100644
index 00000000..f9f3389d
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-vi/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"ng dng NFC Replay"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Khi ng Host APDU Service"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"ang pht li tp:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Nht k giao dch:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rCN/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rCN/strings.xml
new file mode 100644
index 00000000..edcb5c6b
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rCN/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">""</string>
+    <string name="log_text" msgid="5517852408962406645">""</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rHK/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rHK/strings.xml
new file mode 100644
index 00000000..5e5f8d8d
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rHK/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC Replay "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">""</string>
+    <string name="log_text" msgid="5517852408962406645">""</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rTW/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rTW/strings.xml
new file mode 100644
index 00000000..40d19ff8
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-zh-rTW/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"NFC "</string>
+    <string name="service_button_text" msgid="5013402864802312301">" APDU "</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">""</string>
+    <string name="log_text" msgid="5517852408962406645">""</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values-zu/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values-zu/strings.xml
new file mode 100644
index 00000000..64467439
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values-zu/strings.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="app_name" msgid="2676644544773839281">"I-app Yokudlala Futhi ye-NFC"</string>
+    <string name="service_button_text" msgid="5013402864802312301">"Qala Isevisi Yokusingatha ye-APDU"</string>
+    <string name="replayed_file_text" msgid="2512008003720490850">"Idlala Ifayela Futhi:"</string>
+    <string name="log_text" msgid="5517852408962406645">"Ilogu yethransekshini:"</string>
+</resources>
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values/strings.xml b/testutils/src/com/android/nfc/emulatorapp/res/values/strings.xml
new file mode 100644
index 00000000..921c4e48
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values/strings.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <!-- Name of the app [CHAR_LIMIT=NONE]-->
+  <string name="app_name">NFC Replay App</string>
+  <!-- Text of the button to start the Host APDU service [CHAR_LIMIT=NONE]-->
+  <string name="service_button_text">Start Host APDU Service</string>
+  <!-- Text displaying the name of the snoop file being replayed [CHAR_LIMIT=NONE]-->
+  <string name="replayed_file_text">Replaying File:</string>
+  <!-- Text displaying the transaction log [CHAR_LIMIT=NONE]-->
+  <string name="log_text">Transaction Log:</string>
+</resources>
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/values/styles.xml b/testutils/src/com/android/nfc/emulatorapp/res/values/styles.xml
new file mode 100644
index 00000000..f734e0e3
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/values/styles.xml
@@ -0,0 +1,3 @@
+<resources>
+  <style name="AppTheme" parent="Theme.MaterialComponents.DayNight.DarkActionBar" />
+</resources>
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/emulatorapp/res/xml/aids.xml b/testutils/src/com/android/nfc/emulatorapp/res/xml/aids.xml
new file mode 100644
index 00000000..713c4182
--- /dev/null
+++ b/testutils/src/com/android/nfc/emulatorapp/res/xml/aids.xml
@@ -0,0 +1,9 @@
+<host-apdu-service
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:requireDeviceUnlock="false"
+    android:description="@string/app_name">
+  <aid-group android:category="other">
+    <aid-filter android:name="A000000151000000"/>
+    <aid-filter android:name="A000000003000000"/>
+  </aid-group>
+</host-apdu-service>
\ No newline at end of file
diff --git a/testutils/src/com/android/nfc/utils/AndroidManifest.xml b/testutils/src/com/android/nfc/utils/AndroidManifest.xml
index 5d5a5f32..0dc55b79 100644
--- a/testutils/src/com/android/nfc/utils/AndroidManifest.xml
+++ b/testutils/src/com/android/nfc/utils/AndroidManifest.xml
@@ -18,5 +18,9 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.android.nfc.utils">
     <uses-sdk android:targetSdkVersion="35" android:minSdkVersion="35"/>
-    <application />
+    <application>
+        <meta-data
+            android:name="mobly-object-converter"
+            android:value="com.android.nfc.utils.PollingFrameConverter"/>
+    </application>
 </manifest>
diff --git a/testutils/src/com/android/nfc/utils/PollingFrameConverter.java b/testutils/src/com/android/nfc/utils/PollingFrameConverter.java
new file mode 100644
index 00000000..7b03fc20
--- /dev/null
+++ b/testutils/src/com/android/nfc/utils/PollingFrameConverter.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.nfc.utils;
+
+import android.nfc.cardemulation.PollingFrame;
+
+import com.google.android.mobly.snippet.SnippetObjectConverter;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Type;
+
+public class PollingFrameConverter implements SnippetObjectConverter {
+    @Override
+    public JSONObject serialize(Object object) throws JSONException {
+        JSONObject result = new JSONObject();
+        if (object instanceof PollingFrame) {
+            PollingFrame frame = (PollingFrame) object;
+            result.put("type", Character.toString(frame.getType()));
+            result.put("vendorSpecificGain", frame.getVendorSpecificGain());
+            result.put("timestamp", frame.getTimestamp());
+            result.put("data", HceUtils.getHexBytes(null, frame.getData()).replaceAll("\\s+", ""));
+            result.put("triggeredAutoTransact", frame.getTriggeredAutoTransact());
+            return result;
+        }
+        return null;
+    }
+
+    @Override
+    public Object deserialize(JSONObject jsonObject, Type type) throws JSONException {
+        // Not implemented
+        return null;
+    }
+}
```

